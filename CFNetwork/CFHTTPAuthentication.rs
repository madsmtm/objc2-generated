//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhttpauthentication?language=objc)
#[repr(C)]
pub struct CFHTTPAuthentication {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFHTTPAuthentication {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"_CFHTTPAuthentication"> for CFHTTPAuthentication {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfstreamerrorhttpauthentication?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFStreamErrorHTTPAuthentication(pub c_int);
impl CFStreamErrorHTTPAuthentication {
    #[doc(alias = "kCFStreamErrorHTTPAuthenticationTypeUnsupported")]
    pub const TypeUnsupported: Self = Self(-1000);
    #[doc(alias = "kCFStreamErrorHTTPAuthenticationBadUserName")]
    pub const BadUserName: Self = Self(-1001);
    #[doc(alias = "kCFStreamErrorHTTPAuthenticationBadPassword")]
    pub const BadPassword: Self = Self(-1002);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStreamErrorHTTPAuthentication {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStreamErrorHTTPAuthentication {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfhttpauthenticationusername?language=objc)
    pub static kCFHTTPAuthenticationUsername: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfhttpauthenticationpassword?language=objc)
    pub static kCFHTTPAuthenticationPassword: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfhttpauthenticationaccountdomain?language=objc)
    pub static kCFHTTPAuthenticationAccountDomain: &'static CFString;
}

unsafe impl ConcreteType for CFHTTPAuthentication {
    #[doc(alias = "CFHTTPAuthenticationGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFHTTPAuthenticationGetTypeID() -> CFTypeID;
        }
        unsafe { CFHTTPAuthenticationGetTypeID() }
    }
}

impl CFHTTPAuthentication {
    #[doc(alias = "CFHTTPAuthenticationCreateFromResponse")]
    #[cfg(feature = "CFHTTPMessage")]
    #[inline]
    pub unsafe fn from_response(
        alloc: Option<&CFAllocator>,
        response: &CFHTTPMessage,
    ) -> CFRetained<CFHTTPAuthentication> {
        extern "C-unwind" {
            fn CFHTTPAuthenticationCreateFromResponse(
                alloc: Option<&CFAllocator>,
                response: &CFHTTPMessage,
            ) -> Option<NonNull<CFHTTPAuthentication>>;
        }
        let ret = unsafe { CFHTTPAuthenticationCreateFromResponse(alloc, response) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "CFHTTPAuthenticationIsValid")]
    #[inline]
    pub unsafe fn is_valid(&self, error: *mut CFStreamError) -> bool {
        extern "C-unwind" {
            fn CFHTTPAuthenticationIsValid(
                auth: &CFHTTPAuthentication,
                error: *mut CFStreamError,
            ) -> Boolean;
        }
        let ret = unsafe { CFHTTPAuthenticationIsValid(self, error) };
        ret != 0
    }

    #[doc(alias = "CFHTTPAuthenticationAppliesToRequest")]
    #[cfg(feature = "CFHTTPMessage")]
    #[inline]
    pub unsafe fn applies_to_request(&self, request: &CFHTTPMessage) -> bool {
        extern "C-unwind" {
            fn CFHTTPAuthenticationAppliesToRequest(
                auth: &CFHTTPAuthentication,
                request: &CFHTTPMessage,
            ) -> Boolean;
        }
        let ret = unsafe { CFHTTPAuthenticationAppliesToRequest(self, request) };
        ret != 0
    }

    #[doc(alias = "CFHTTPAuthenticationRequiresOrderedRequests")]
    #[inline]
    pub unsafe fn requires_ordered_requests(&self) -> bool {
        extern "C-unwind" {
            fn CFHTTPAuthenticationRequiresOrderedRequests(auth: &CFHTTPAuthentication) -> Boolean;
        }
        let ret = unsafe { CFHTTPAuthenticationRequiresOrderedRequests(self) };
        ret != 0
    }
}

#[cfg(feature = "CFHTTPMessage")]
impl CFHTTPMessage {
    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "CFHTTPMessageApplyCredentials")]
    #[cfg(feature = "CFHTTPMessage")]
    #[inline]
    pub unsafe fn apply_credentials(
        &self,
        auth: &CFHTTPAuthentication,
        username: Option<&CFString>,
        password: Option<&CFString>,
        error: *mut CFStreamError,
    ) -> bool {
        extern "C-unwind" {
            fn CFHTTPMessageApplyCredentials(
                request: &CFHTTPMessage,
                auth: &CFHTTPAuthentication,
                username: Option<&CFString>,
                password: Option<&CFString>,
                error: *mut CFStreamError,
            ) -> Boolean;
        }
        let ret = unsafe { CFHTTPMessageApplyCredentials(self, auth, username, password, error) };
        ret != 0
    }

    /// # Safety
    ///
    /// - `dict` generics must be of the correct type.
    /// - `error` must be a valid pointer or null.
    #[doc(alias = "CFHTTPMessageApplyCredentialDictionary")]
    #[cfg(feature = "CFHTTPMessage")]
    #[inline]
    pub unsafe fn apply_credential_dictionary(
        &self,
        auth: &CFHTTPAuthentication,
        dict: &CFDictionary,
        error: *mut CFStreamError,
    ) -> bool {
        extern "C-unwind" {
            fn CFHTTPMessageApplyCredentialDictionary(
                request: &CFHTTPMessage,
                auth: &CFHTTPAuthentication,
                dict: &CFDictionary,
                error: *mut CFStreamError,
            ) -> Boolean;
        }
        let ret = unsafe { CFHTTPMessageApplyCredentialDictionary(self, auth, dict, error) };
        ret != 0
    }
}

impl CFHTTPAuthentication {
    #[doc(alias = "CFHTTPAuthenticationCopyRealm")]
    #[inline]
    pub unsafe fn realm(&self) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn CFHTTPAuthenticationCopyRealm(
                auth: &CFHTTPAuthentication,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFHTTPAuthenticationCopyRealm(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CFHTTPAuthenticationCopyDomains")]
    #[inline]
    pub unsafe fn domains(&self) -> CFRetained<CFArray> {
        extern "C-unwind" {
            fn CFHTTPAuthenticationCopyDomains(
                auth: &CFHTTPAuthentication,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CFHTTPAuthenticationCopyDomains(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CFHTTPAuthenticationCopyMethod")]
    #[inline]
    pub unsafe fn method(&self) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn CFHTTPAuthenticationCopyMethod(
                auth: &CFHTTPAuthentication,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFHTTPAuthenticationCopyMethod(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CFHTTPAuthenticationRequiresUserNameAndPassword")]
    #[inline]
    pub unsafe fn requires_user_name_and_password(&self) -> bool {
        extern "C-unwind" {
            fn CFHTTPAuthenticationRequiresUserNameAndPassword(
                auth: &CFHTTPAuthentication,
            ) -> Boolean;
        }
        let ret = unsafe { CFHTTPAuthenticationRequiresUserNameAndPassword(self) };
        ret != 0
    }

    #[doc(alias = "CFHTTPAuthenticationRequiresAccountDomain")]
    #[inline]
    pub unsafe fn requires_account_domain(&self) -> bool {
        extern "C-unwind" {
            fn CFHTTPAuthenticationRequiresAccountDomain(auth: &CFHTTPAuthentication) -> Boolean;
        }
        let ret = unsafe { CFHTTPAuthenticationRequiresAccountDomain(self) };
        ret != 0
    }
}

#[cfg(feature = "CFHTTPMessage")]
#[deprecated = "renamed to `CFHTTPAuthentication::from_response`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationCreateFromResponse(
    alloc: Option<&CFAllocator>,
    response: &CFHTTPMessage,
) -> CFRetained<CFHTTPAuthentication> {
    extern "C-unwind" {
        fn CFHTTPAuthenticationCreateFromResponse(
            alloc: Option<&CFAllocator>,
            response: &CFHTTPMessage,
        ) -> Option<NonNull<CFHTTPAuthentication>>;
    }
    let ret = unsafe { CFHTTPAuthenticationCreateFromResponse(alloc, response) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CFHTTPAuthentication::is_valid`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationIsValid(
    auth: &CFHTTPAuthentication,
    error: *mut CFStreamError,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationIsValid(
            auth: &CFHTTPAuthentication,
            error: *mut CFStreamError,
        ) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationIsValid(auth, error) };
    ret != 0
}

#[cfg(feature = "CFHTTPMessage")]
#[deprecated = "renamed to `CFHTTPAuthentication::applies_to_request`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationAppliesToRequest(
    auth: &CFHTTPAuthentication,
    request: &CFHTTPMessage,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationAppliesToRequest(
            auth: &CFHTTPAuthentication,
            request: &CFHTTPMessage,
        ) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationAppliesToRequest(auth, request) };
    ret != 0
}

#[deprecated = "renamed to `CFHTTPAuthentication::requires_ordered_requests`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationRequiresOrderedRequests(
    auth: &CFHTTPAuthentication,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationRequiresOrderedRequests(auth: &CFHTTPAuthentication) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationRequiresOrderedRequests(auth) };
    ret != 0
}

#[cfg(feature = "CFHTTPMessage")]
#[deprecated = "renamed to `CFHTTPMessage::apply_credentials`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPMessageApplyCredentials(
    request: &CFHTTPMessage,
    auth: &CFHTTPAuthentication,
    username: Option<&CFString>,
    password: Option<&CFString>,
    error: *mut CFStreamError,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPMessageApplyCredentials(
            request: &CFHTTPMessage,
            auth: &CFHTTPAuthentication,
            username: Option<&CFString>,
            password: Option<&CFString>,
            error: *mut CFStreamError,
        ) -> Boolean;
    }
    let ret = unsafe { CFHTTPMessageApplyCredentials(request, auth, username, password, error) };
    ret != 0
}

#[cfg(feature = "CFHTTPMessage")]
#[deprecated = "renamed to `CFHTTPMessage::apply_credential_dictionary`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPMessageApplyCredentialDictionary(
    request: &CFHTTPMessage,
    auth: &CFHTTPAuthentication,
    dict: &CFDictionary,
    error: *mut CFStreamError,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPMessageApplyCredentialDictionary(
            request: &CFHTTPMessage,
            auth: &CFHTTPAuthentication,
            dict: &CFDictionary,
            error: *mut CFStreamError,
        ) -> Boolean;
    }
    let ret = unsafe { CFHTTPMessageApplyCredentialDictionary(request, auth, dict, error) };
    ret != 0
}

#[deprecated = "renamed to `CFHTTPAuthentication::realm`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationCopyRealm(
    auth: &CFHTTPAuthentication,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn CFHTTPAuthenticationCopyRealm(auth: &CFHTTPAuthentication) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFHTTPAuthenticationCopyRealm(auth) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CFHTTPAuthentication::domains`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationCopyDomains(
    auth: &CFHTTPAuthentication,
) -> CFRetained<CFArray> {
    extern "C-unwind" {
        fn CFHTTPAuthenticationCopyDomains(auth: &CFHTTPAuthentication)
            -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CFHTTPAuthenticationCopyDomains(auth) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CFHTTPAuthentication::method`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationCopyMethod(
    auth: &CFHTTPAuthentication,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn CFHTTPAuthenticationCopyMethod(auth: &CFHTTPAuthentication)
            -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFHTTPAuthenticationCopyMethod(auth) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CFHTTPAuthentication::requires_user_name_and_password`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationRequiresUserNameAndPassword(
    auth: &CFHTTPAuthentication,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationRequiresUserNameAndPassword(auth: &CFHTTPAuthentication) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationRequiresUserNameAndPassword(auth) };
    ret != 0
}

#[deprecated = "renamed to `CFHTTPAuthentication::requires_account_domain`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHTTPAuthenticationRequiresAccountDomain(
    auth: &CFHTTPAuthentication,
) -> bool {
    extern "C-unwind" {
        fn CFHTTPAuthenticationRequiresAccountDomain(auth: &CFHTTPAuthentication) -> Boolean;
    }
    let ret = unsafe { CFHTTPAuthenticationRequiresAccountDomain(auth) };
    ret != 0
}
