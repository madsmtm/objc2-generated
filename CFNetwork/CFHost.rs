//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhost?language=objc)
#[repr(C)]
pub struct CFHost {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFHost {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFHost"> for CFHost {}
);

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfstreamerrordomainnetdb?language=objc)
    pub static kCFStreamErrorDomainNetDB: i32;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfstreamerrordomainsystemconfiguration?language=objc)
    pub static kCFStreamErrorDomainSystemConfiguration: i32;
}

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhostinfotype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFHostInfoType(pub c_int);
impl CFHostInfoType {
    #[doc(alias = "kCFHostAddresses")]
    pub const Addresses: Self = Self(0);
    #[doc(alias = "kCFHostNames")]
    pub const Names: Self = Self(1);
    #[doc(alias = "kCFHostReachability")]
    pub const Reachability: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFHostInfoType {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFHostInfoType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhostclientcontext?language=objc)
#[repr(C, packed(2))]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFHostClientContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: CFAllocatorRetainCallBack,
    pub release: CFAllocatorReleaseCallBack,
    pub copyDescription: CFAllocatorCopyDescriptionCallBack,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFHostClientContext {
    const ENCODING: Encoding = Encoding::Struct(
        "CFHostClientContext",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <CFAllocatorRetainCallBack>::ENCODING,
            <CFAllocatorReleaseCallBack>::ENCODING,
            <CFAllocatorCopyDescriptionCallBack>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFHostClientContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhostclientcallback?language=objc)
pub type CFHostClientCallBack = Option<
    unsafe extern "C-unwind" fn(NonNull<CFHost>, CFHostInfoType, *const CFStreamError, *mut c_void),
>;

unsafe impl ConcreteType for CFHost {
    #[doc(alias = "CFHostGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFHostGetTypeID() -> CFTypeID;
        }
        unsafe { CFHostGetTypeID() }
    }
}

impl CFHost {
    #[doc(alias = "CFHostCreateWithName")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn with_name(
        allocator: Option<&CFAllocator>,
        hostname: &CFString,
    ) -> CFRetained<CFHost> {
        extern "C-unwind" {
            fn CFHostCreateWithName(
                allocator: Option<&CFAllocator>,
                hostname: &CFString,
            ) -> Option<NonNull<CFHost>>;
        }
        let ret = unsafe { CFHostCreateWithName(allocator, hostname) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CFHostCreateWithAddress")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn with_address(
        allocator: Option<&CFAllocator>,
        addr: &CFData,
    ) -> CFRetained<CFHost> {
        extern "C-unwind" {
            fn CFHostCreateWithAddress(
                allocator: Option<&CFAllocator>,
                addr: &CFData,
            ) -> Option<NonNull<CFHost>>;
        }
        let ret = unsafe { CFHostCreateWithAddress(allocator, addr) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CFHostCreateCopy")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn new_copy(alloc: Option<&CFAllocator>, host: &CFHost) -> CFRetained<CFHost> {
        extern "C-unwind" {
            fn CFHostCreateCopy(
                alloc: Option<&CFAllocator>,
                host: &CFHost,
            ) -> Option<NonNull<CFHost>>;
        }
        let ret = unsafe { CFHostCreateCopy(alloc, host) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CFHostStartInfoResolution")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn start_info_resolution(
        self: &CFHost,
        info: CFHostInfoType,
        error: *mut CFStreamError,
    ) -> bool {
        extern "C-unwind" {
            fn CFHostStartInfoResolution(
                the_host: &CFHost,
                info: CFHostInfoType,
                error: *mut CFStreamError,
            ) -> Boolean;
        }
        let ret = unsafe { CFHostStartInfoResolution(self, info, error) };
        ret != 0
    }

    #[doc(alias = "CFHostGetAddressing")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn addressing(
        self: &CFHost,
        has_been_resolved: *mut Boolean,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CFHostGetAddressing(
                the_host: &CFHost,
                has_been_resolved: *mut Boolean,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CFHostGetAddressing(self, has_been_resolved) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CFHostGetNames")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn names(
        self: &CFHost,
        has_been_resolved: *mut Boolean,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CFHostGetNames(
                the_host: &CFHost,
                has_been_resolved: *mut Boolean,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CFHostGetNames(self, has_been_resolved) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CFHostGetReachability")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn reachability(
        self: &CFHost,
        has_been_resolved: *mut Boolean,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn CFHostGetReachability(
                the_host: &CFHost,
                has_been_resolved: *mut Boolean,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { CFHostGetReachability(self, has_been_resolved) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CFHostCancelInfoResolution")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn cancel_info_resolution(self: &CFHost, info: CFHostInfoType) {
        extern "C-unwind" {
            fn CFHostCancelInfoResolution(the_host: &CFHost, info: CFHostInfoType);
        }
        unsafe { CFHostCancelInfoResolution(self, info) }
    }

    #[doc(alias = "CFHostSetClient")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn set_client(
        self: &CFHost,
        client_cb: CFHostClientCallBack,
        client_context: *mut CFHostClientContext,
    ) -> bool {
        extern "C-unwind" {
            fn CFHostSetClient(
                the_host: &CFHost,
                client_cb: CFHostClientCallBack,
                client_context: *mut CFHostClientContext,
            ) -> Boolean;
        }
        let ret = unsafe { CFHostSetClient(self, client_cb, client_context) };
        ret != 0
    }

    #[doc(alias = "CFHostScheduleWithRunLoop")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn schedule_with_run_loop(
        self: &CFHost,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    ) {
        extern "C-unwind" {
            fn CFHostScheduleWithRunLoop(
                the_host: &CFHost,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { CFHostScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }

    #[doc(alias = "CFHostUnscheduleFromRunLoop")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn unschedule_from_run_loop(
        self: &CFHost,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    ) {
        extern "C-unwind" {
            fn CFHostUnscheduleFromRunLoop(
                the_host: &CFHost,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { CFHostUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }
}

#[deprecated = "renamed to `CFHost::with_name`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHostCreateWithName(
    allocator: Option<&CFAllocator>,
    hostname: &CFString,
) -> CFRetained<CFHost> {
    extern "C-unwind" {
        fn CFHostCreateWithName(
            allocator: Option<&CFAllocator>,
            hostname: &CFString,
        ) -> Option<NonNull<CFHost>>;
    }
    let ret = unsafe { CFHostCreateWithName(allocator, hostname) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CFHost::with_address`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHostCreateWithAddress(
    allocator: Option<&CFAllocator>,
    addr: &CFData,
) -> CFRetained<CFHost> {
    extern "C-unwind" {
        fn CFHostCreateWithAddress(
            allocator: Option<&CFAllocator>,
            addr: &CFData,
        ) -> Option<NonNull<CFHost>>;
    }
    let ret = unsafe { CFHostCreateWithAddress(allocator, addr) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CFHost::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHostCreateCopy(
    alloc: Option<&CFAllocator>,
    host: &CFHost,
) -> CFRetained<CFHost> {
    extern "C-unwind" {
        fn CFHostCreateCopy(alloc: Option<&CFAllocator>, host: &CFHost) -> Option<NonNull<CFHost>>;
    }
    let ret = unsafe { CFHostCreateCopy(alloc, host) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CFHost::start_info_resolution`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHostStartInfoResolution(
    the_host: &CFHost,
    info: CFHostInfoType,
    error: *mut CFStreamError,
) -> bool {
    extern "C-unwind" {
        fn CFHostStartInfoResolution(
            the_host: &CFHost,
            info: CFHostInfoType,
            error: *mut CFStreamError,
        ) -> Boolean;
    }
    let ret = unsafe { CFHostStartInfoResolution(the_host, info, error) };
    ret != 0
}

#[deprecated = "renamed to `CFHost::addressing`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHostGetAddressing(
    the_host: &CFHost,
    has_been_resolved: *mut Boolean,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CFHostGetAddressing(
            the_host: &CFHost,
            has_been_resolved: *mut Boolean,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CFHostGetAddressing(the_host, has_been_resolved) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CFHost::names`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHostGetNames(
    the_host: &CFHost,
    has_been_resolved: *mut Boolean,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CFHostGetNames(
            the_host: &CFHost,
            has_been_resolved: *mut Boolean,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CFHostGetNames(the_host, has_been_resolved) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CFHost::reachability`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHostGetReachability(
    the_host: &CFHost,
    has_been_resolved: *mut Boolean,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CFHostGetReachability(
            the_host: &CFHost,
            has_been_resolved: *mut Boolean,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { CFHostGetReachability(the_host, has_been_resolved) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFHost::cancel_info_resolution`"]
    pub fn CFHostCancelInfoResolution(the_host: &CFHost, info: CFHostInfoType);
}

#[deprecated = "renamed to `CFHost::set_client`"]
#[inline]
pub unsafe extern "C-unwind" fn CFHostSetClient(
    the_host: &CFHost,
    client_cb: CFHostClientCallBack,
    client_context: *mut CFHostClientContext,
) -> bool {
    extern "C-unwind" {
        fn CFHostSetClient(
            the_host: &CFHost,
            client_cb: CFHostClientCallBack,
            client_context: *mut CFHostClientContext,
        ) -> Boolean;
    }
    let ret = unsafe { CFHostSetClient(the_host, client_cb, client_context) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFHost::schedule_with_run_loop`"]
    pub fn CFHostScheduleWithRunLoop(
        the_host: &CFHost,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFHost::unschedule_from_run_loop`"]
    pub fn CFHostUnscheduleFromRunLoop(
        the_host: &CFHost,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}
