//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhost?language=objc)
#[doc(alias = "CFHostRef")]
#[repr(C)]
pub struct CFHost {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFHost {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFHost"> for CFHost {}
);

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfstreamerrordomainnetdb?language=objc)
    pub static kCFStreamErrorDomainNetDB: i32;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/kcfstreamerrordomainsystemconfiguration?language=objc)
    pub static kCFStreamErrorDomainSystemConfiguration: i32;
}

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhostinfotype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CFHostInfoType(pub c_int);
impl CFHostInfoType {
    #[doc(alias = "kCFHostAddresses")]
    pub const Addresses: Self = Self(0);
    #[doc(alias = "kCFHostNames")]
    pub const Names: Self = Self(1);
    #[doc(alias = "kCFHostReachability")]
    pub const Reachability: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFHostInfoType {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFHostInfoType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhostclientcontext?language=objc)
#[repr(C, packed(2))]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFHostClientContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: CFAllocatorRetainCallBack,
    pub release: CFAllocatorReleaseCallBack,
    pub copyDescription: CFAllocatorCopyDescriptionCallBack,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFHostClientContext {
    const ENCODING: Encoding = Encoding::Struct(
        "CFHostClientContext",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <CFAllocatorRetainCallBack>::ENCODING,
            <CFAllocatorReleaseCallBack>::ENCODING,
            <CFAllocatorCopyDescriptionCallBack>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFHostClientContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/cfnetwork/cfhostclientcallback?language=objc)
pub type CFHostClientCallBack = Option<
    unsafe extern "C-unwind" fn(NonNull<CFHost>, CFHostInfoType, *const CFStreamError, *mut c_void),
>;

unsafe impl ConcreteType for CFHost {
    #[doc(alias = "CFHostGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFHostGetTypeID() -> CFTypeID;
        }
        unsafe { CFHostGetTypeID() }
    }
}

impl CFHost {
    #[doc(alias = "CFHostCreateWithName")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn with_name(
        allocator: Option<&CFAllocator>,
        hostname: &CFString,
    ) -> CFRetained<CFHost> {
        extern "C-unwind" {
            fn CFHostCreateWithName(
                allocator: Option<&CFAllocator>,
                hostname: &CFString,
            ) -> Option<NonNull<CFHost>>;
        }
        let ret = unsafe { CFHostCreateWithName(allocator, hostname) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CFHostCreateWithAddress")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn with_address(
        allocator: Option<&CFAllocator>,
        addr: &CFData,
    ) -> CFRetained<CFHost> {
        extern "C-unwind" {
            fn CFHostCreateWithAddress(
                allocator: Option<&CFAllocator>,
                addr: &CFData,
            ) -> Option<NonNull<CFHost>>;
        }
        let ret = unsafe { CFHostCreateWithAddress(allocator, addr) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CFHostCreateCopy")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn copy(&self, alloc: Option<&CFAllocator>) -> CFRetained<CFHost> {
        extern "C-unwind" {
            fn CFHostCreateCopy(
                alloc: Option<&CFAllocator>,
                host: &CFHost,
            ) -> Option<NonNull<CFHost>>;
        }
        let ret = unsafe { CFHostCreateCopy(alloc, self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// # Safety
    ///
    /// `error` must be a valid pointer or null.
    #[doc(alias = "CFHostStartInfoResolution")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn start_info_resolution(
        &self,
        info: CFHostInfoType,
        error: *mut CFStreamError,
    ) -> bool {
        extern "C-unwind" {
            fn CFHostStartInfoResolution(
                the_host: &CFHost,
                info: CFHostInfoType,
                error: *mut CFStreamError,
            ) -> Boolean;
        }
        let ret = unsafe { CFHostStartInfoResolution(self, info, error) };
        ret != 0
    }

    /// # Safety
    ///
    /// `has_been_resolved` must be a valid pointer or null.
    #[doc(alias = "CFHostGetAddressing")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn addressing(
        &self,
        has_been_resolved: *mut Boolean,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CFHostGetAddressing(
                the_host: &CFHost,
                has_been_resolved: *mut Boolean,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CFHostGetAddressing(self, has_been_resolved) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// # Safety
    ///
    /// `has_been_resolved` must be a valid pointer or null.
    #[doc(alias = "CFHostGetNames")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn names(&self, has_been_resolved: *mut Boolean) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CFHostGetNames(
                the_host: &CFHost,
                has_been_resolved: *mut Boolean,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CFHostGetNames(self, has_been_resolved) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// # Safety
    ///
    /// `has_been_resolved` must be a valid pointer or null.
    #[doc(alias = "CFHostGetReachability")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn reachability(
        &self,
        has_been_resolved: *mut Boolean,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn CFHostGetReachability(
                the_host: &CFHost,
                has_been_resolved: *mut Boolean,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { CFHostGetReachability(self, has_been_resolved) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CFHostCancelInfoResolution")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn cancel_info_resolution(&self, info: CFHostInfoType) {
        extern "C-unwind" {
            fn CFHostCancelInfoResolution(the_host: &CFHost, info: CFHostInfoType);
        }
        unsafe { CFHostCancelInfoResolution(self, info) }
    }

    /// # Safety
    ///
    /// - `client_cb` must be implemented correctly.
    /// - `client_context` must be a valid pointer or null.
    #[doc(alias = "CFHostSetClient")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn set_client(
        &self,
        client_cb: CFHostClientCallBack,
        client_context: *mut CFHostClientContext,
    ) -> bool {
        extern "C-unwind" {
            fn CFHostSetClient(
                the_host: &CFHost,
                client_cb: CFHostClientCallBack,
                client_context: *mut CFHostClientContext,
            ) -> Boolean;
        }
        let ret = unsafe { CFHostSetClient(self, client_cb, client_context) };
        ret != 0
    }

    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "CFHostScheduleWithRunLoop")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn schedule_with_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn CFHostScheduleWithRunLoop(
                the_host: &CFHost,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { CFHostScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }

    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "CFHostUnscheduleFromRunLoop")]
    #[deprecated = "Use Network framework instead, see deprecation notice in <CFNetwork/CFHost.h>"]
    #[inline]
    pub unsafe fn unschedule_from_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn CFHostUnscheduleFromRunLoop(
                the_host: &CFHost,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { CFHostUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }
}
