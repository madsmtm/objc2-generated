//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-uniform-type-identifiers")]
use objc2_uniform_type_identifiers::*;

use crate::*;

extern "C" {
    /// The error domain for the index.
    pub static CSIndexErrorDomain: &'static NSString;
}

/// Error codes that describe indexing-specific errors.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CSIndexErrorCode(pub NSInteger);
impl CSIndexErrorCode {
    /// An unknown error occurred.
    #[doc(alias = "CSIndexErrorCodeUnknownError")]
    pub const UnknownError: Self = Self(-1);
    /// The indexer is unavailable.
    #[doc(alias = "CSIndexErrorCodeIndexUnavailableError")]
    pub const IndexUnavailableError: Self = Self(-1000);
    /// The searchable item object is invalid.
    ///
    /// ## Discussion
    ///
    /// Verify the information in your [`CSSearchableItem`](https://developer.apple.com/documentation/corespotlight/cssearchableitem) object is correct.
    ///
    ///
    #[doc(alias = "CSIndexErrorCodeInvalidItemError")]
    pub const InvalidItemError: Self = Self(-1001);
    /// The provided client state data is invalid.
    #[doc(alias = "CSIndexErrorCodeInvalidClientStateError")]
    pub const InvalidClientStateError: Self = Self(-1002);
    /// An error occurred while communicating with the remote process.
    #[doc(alias = "CSIndexErrorCodeRemoteConnectionError")]
    pub const RemoteConnectionError: Self = Self(-1003);
    /// The quota for the bundle has been exceeded.
    #[doc(alias = "CSIndexErrorCodeQuotaExceeded")]
    pub const QuotaExceeded: Self = Self(-1004);
    /// Indexing isn’t supported on the device.
    #[doc(alias = "CSIndexErrorCodeIndexingUnsupported")]
    pub const IndexingUnsupported: Self = Self(-1005);
    /// The provided client state did not match the information in the index.
    #[doc(alias = "CSIndexErrorCodeMismatchedClientState")]
    pub const MismatchedClientState: Self = Self(-1006);
}

unsafe impl Encode for CSIndexErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CSIndexErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An on-device index for your app’s searchable content.
    ///
    /// ## Overview
    ///
    /// A `CSSearchableIndex` object manages an on-device index for your app’s searchable content. To make your app’s content searchable, package it in one or more [`CSSearchableItem`](https://developer.apple.com/documentation/corespotlight/cssearchableitem) objects and add them to the index. You can create as many searchable indexes as you need to manage your content, and you can apply different levels of encryption to protect the content in each index. When you execute a query, Core Spotlight searches your app’s indexes for the requested information and returns the results to your code.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    /// If your app creates [`NSUserActivity`](https://developer.apple.com/documentation/foundation/nsuseractivity) objects, set the [`eligibleForSearch`](https://developer.apple.com/documentation/foundation/nsuseractivity/iseligibleforsearch) property of those objects to `true` to ensure they appear in search results.
    ///
    ///
    ///
    /// </div>
    /// Put your content into a custom `CSSearchableIndex` that you create. Custom indexes support batch operations and additional levels of data protection. Place sensitive personal information in protected indexes to encrypt that content, and prevent its disclosure without proper authorization from the owner of the device. Although you can put content into the default index, you can’t encrypt the content in that index or perform batch operations to add content to it.
    ///
    /// When adding large amounts of data to the index, consider adding it in batches to minimize risk. Batch-based updates make it easier to handle errors that might occur during the indexing process. For each batch, you provide client-state information to identify the current batch. If your app or extension crashes while a batch operation is in progress, you can use that state information to determine where to start indexing again later.
    ///
    /// Modify custom `CSSearchableIndex` objects only on one thread or task at a time. It’s a programming error to access a custom index from multiple threads simultaneously. When performing batch updates on an index, start each new batch operation only after calling the [`endIndexBatchWithClientState:completionHandler:`](https://developer.apple.com/documentation/corespotlight/cssearchableindex/endbatch(withclientstate:completionhandler:)) or [`endIndexBatchWithExpectedClientState:newClientState:completionHandler:`](https://developer.apple.com/documentation/corespotlight/cssearchableindex/endindexbatch(expectedclientstate:newclientstate:completionhandler:)) method of the previous batch operation.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CSSearchableIndex;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for CSSearchableIndex {}
);

impl CSSearchableIndex {
    extern_methods!(
        #[unsafe(method(indexDelegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn indexDelegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn CSSearchableIndexDelegate>>>;

        /// Setter for [`indexDelegate`][Self::indexDelegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setIndexDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIndexDelegate(
            &self,
            index_delegate: Option<&ProtocolObject<dyn CSSearchableIndexDelegate>>,
        );

        #[unsafe(method(isIndexingAvailable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isIndexingAvailable() -> bool;

        #[unsafe(method(defaultSearchableIndex))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultSearchableIndex() -> Retained<Self>;

        #[unsafe(method(initWithName:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName(this: Allocated<Self>, name: &NSString) -> Retained<Self>;

        #[unsafe(method(initWithName:protectionClass:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName_protectionClass(
            this: Allocated<Self>,
            name: &NSString,
            protection_class: Option<&NSFileProtectionType>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "CSSearchableItem", feature = "block2"))]
        #[unsafe(method(indexSearchableItems:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn indexSearchableItems_completionHandler(
            &self,
            items: &NSArray<CSSearchableItem>,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(deleteSearchableItemsWithIdentifiers:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteSearchableItemsWithIdentifiers_completionHandler(
            &self,
            identifiers: &NSArray<NSString>,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(deleteSearchableItemsWithDomainIdentifiers:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteSearchableItemsWithDomainIdentifiers_completionHandler(
            &self,
            domain_identifiers: &NSArray<NSString>,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(deleteAllSearchableItemsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteAllSearchableItemsWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl CSSearchableIndex {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// CSOptionalBatching.
impl CSSearchableIndex {
    extern_methods!(
        #[unsafe(method(beginIndexBatch))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginIndexBatch(&self);

        #[cfg(feature = "block2")]
        #[unsafe(method(endIndexBatchWithExpectedClientState:newClientState:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn endIndexBatchWithExpectedClientState_newClientState_completionHandler(
            &self,
            expected_client_state: Option<&NSData>,
            new_client_state: &NSData,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(endIndexBatchWithClientState:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn endIndexBatchWithClientState_completionHandler(
            &self,
            client_state: &NSData,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(fetchLastClientStateWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchLastClientStateWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );
    );
}

/// CSExternalProvider.
impl CSSearchableIndex {
    extern_methods!(
        #[cfg(all(feature = "block2", feature = "objc2-uniform-type-identifiers"))]
        #[unsafe(method(fetchDataForBundleIdentifier:itemIdentifier:contentType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchDataForBundleIdentifier_itemIdentifier_contentType_completionHandler(
            &self,
            bundle_identifier: &NSString,
            item_identifier: &NSString,
            content_type: &UTType,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );
    );
}

/// CSOptionalBatchingWithExpectedState.
impl CSSearchableIndex {
    extern_methods!();
}

extern_protocol!(
    /// A protocol that defines methods a delegate object or app extension uses to handle communication from the on-device index.
    ///
    /// ## Overview
    ///
    /// The `CSSearchableIndexDelegate` protocol defines methods that a delegate object or an app extension can use to handle communication from the on-device index. Apps that are long-running or that perform batch updates to the index should implement the required methods of this protocol in either a delegate object or an app extension.
    ///
    /// The index delegate methods are called when there is an issue with the index and more information is needed from an app. For example, the methods can be called when the entire index is lost or there was a failure to process data for some identifiers.
    ///
    ///
    pub unsafe trait CSSearchableIndexDelegate: NSObjectProtocol {
        #[cfg(feature = "block2")]
        #[unsafe(method(searchableIndex:reindexAllSearchableItemsWithAcknowledgementHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn searchableIndex_reindexAllSearchableItemsWithAcknowledgementHandler(
            &self,
            searchable_index: &CSSearchableIndex,
            acknowledgement_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(searchableIndex:reindexSearchableItemsWithIdentifiers:acknowledgementHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn searchableIndex_reindexSearchableItemsWithIdentifiers_acknowledgementHandler(
            &self,
            searchable_index: &CSSearchableIndex,
            identifiers: &NSArray<NSString>,
            acknowledgement_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[optional]
        #[unsafe(method(searchableIndexDidThrottle:))]
        #[unsafe(method_family = none)]
        unsafe fn searchableIndexDidThrottle(&self, searchable_index: &CSSearchableIndex);

        #[optional]
        #[unsafe(method(searchableIndexDidFinishThrottle:))]
        #[unsafe(method_family = none)]
        unsafe fn searchableIndexDidFinishThrottle(&self, searchable_index: &CSSearchableIndex);

        #[optional]
        #[unsafe(method(dataForSearchableIndex:itemIdentifier:typeIdentifier:error:_))]
        #[unsafe(method_family = none)]
        unsafe fn dataForSearchableIndex_itemIdentifier_typeIdentifier_error(
            &self,
            searchable_index: &CSSearchableIndex,
            item_identifier: &NSString,
            type_identifier: &NSString,
        ) -> Result<Retained<NSData>, Retained<NSError>>;

        #[optional]
        #[unsafe(method(fileURLForSearchableIndex:itemIdentifier:typeIdentifier:inPlace:error:_))]
        #[unsafe(method_family = none)]
        unsafe fn fileURLForSearchableIndex_itemIdentifier_typeIdentifier_inPlace_error(
            &self,
            searchable_index: &CSSearchableIndex,
            item_identifier: &NSString,
            type_identifier: &NSString,
            in_place: bool,
        ) -> Result<Retained<NSURL>, Retained<NSError>>;

        #[cfg(all(feature = "CSSearchableItem", feature = "block2"))]
        #[optional]
        #[unsafe(method(searchableItemsForIdentifiers:searchableItemsHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn searchableItemsForIdentifiers_searchableItemsHandler(
            &self,
            identifiers: &NSArray<NSString>,
            searchable_items_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<CSSearchableItem>>)>,
        );

        #[cfg(feature = "CSSearchableItem")]
        #[optional]
        #[unsafe(method(searchableItemsDidUpdate:))]
        #[unsafe(method_family = none)]
        unsafe fn searchableItemsDidUpdate(&self, items: &NSArray<CSSearchableItem>);
    }
);
