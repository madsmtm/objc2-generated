//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// SACrashDetectionManager
    ///
    ///
    /// Use SACrashDetectionManager to receive information about Vehicular Crash Detection events.
    /// Not all phone models support Crash Detection, check for availability before creating an instance of SACrashDetectionManager.
    /// Set the delegate immediately after creating an instance of SACrashDetectionManager. Creating multiple instances of SACrashDetectionManager is not supported and should be avoided.
    ///
    /// SACrashDetectionManager requires an entitlement from Apple. To apply for the entitlement, see Crash Detection Entitlement Request.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/safetykit/sacrashdetectionmanager?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SACrashDetectionManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for SACrashDetectionManager {}
);

impl SACrashDetectionManager {
    extern_methods!(
        /// available
        ///
        ///
        /// Returns a  value indicating whether the current device supports Crash Detection.
        #[unsafe(method(isAvailable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isAvailable() -> bool;

        #[cfg(feature = "SAAuthorizationStatus")]
        /// authorizationStatus
        ///
        ///
        /// Returns a value indicating whether the user has authorized the app to receive Crash Detection updates
        #[unsafe(method(authorizationStatus))]
        #[unsafe(method_family = none)]
        pub unsafe fn authorizationStatus(&self) -> SAAuthorizationStatus;

        /// delegate
        ///
        ///
        /// The delegate object to receive Crash Detection events.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn SACrashDetectionDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn SACrashDetectionDelegate>>,
        );

        #[cfg(all(feature = "SAAuthorizationStatus", feature = "block2"))]
        /// Requests the userâ€™s permission to access Crash Detection information.
        ///
        ///
        /// Parameter `handler`: Completion handler invoked with the status of the authorization request.
        #[unsafe(method(requestAuthorizationWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestAuthorizationWithCompletionHandler(
            &self,
            handler: &block2::DynBlock<dyn Fn(SAAuthorizationStatus, *mut NSError)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl SACrashDetectionManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// SACrashDetectionDelegate
    ///
    ///
    /// SACrashDetectionManager notifies its delegate about Crash Detection related information using this protocol.
    ///
    ///
    /// See also: SACrashDetectionManager
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/safetykit/sacrashdetectiondelegate?language=objc)
    pub unsafe trait SACrashDetectionDelegate: NSObjectProtocol {
        #[cfg(feature = "SACrashDetectionEvent")]
        /// Update the delegate with a new Crash Detection event
        ///
        ///
        /// Crash Detection events may occur when the app is not running.
        /// Following a Crash Detection event, the system will launch the iOS app in the background giving it small amount of background execution time. This time should be used for critical tasks related to the Crash Event. For example: placing a network request or scheduling a local notification.
        /// In order to receive Crash Detection events, create a new SACrashDetectionManager instance and set its delegate early in the iOS app lifecycle (applicationDidFinishLaunching for example).
        ///
        /// If multiple Crash Detection events are generated while the app is not running, only the most recent event will be reported on the next app launch.
        ///
        /// The same event may be reported across different app launches, always check the date of the event before processing it.
        ///
        /// Crash Detection events can be simulated with the iOS simulator. Use it to test the background functionality of your app.
        #[optional]
        #[unsafe(method(crashDetectionManager:didDetectEvent:))]
        #[unsafe(method_family = none)]
        unsafe fn crashDetectionManager_didDetectEvent(
            &self,
            crash_detection_manager: &SACrashDetectionManager,
            event: &SACrashDetectionEvent,
        );
    }
);
