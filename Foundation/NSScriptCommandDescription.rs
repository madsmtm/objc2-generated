//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern_class!(
    /// A script command that a macOS app supports.
    ///
    /// ## Overview
    ///
    /// A scriptable application provides scriptability information that describes the commands and objects scripters can use in scripts that target the application. An application’s scripting information is collected automatically by an instance of [`NSScriptSuiteRegistry`](https://developer.apple.com/documentation/foundation/nsscriptsuiteregistry), which creates an `NSScriptCommandDescription` for each command it finds, caches these objects in memory, and installs a command handler for each command.
    ///
    /// A script command instance stores the name, class, argument types, and return type of a command. For example, commands in AppleScript’s Core suite include `clone`, `count`, `create`, `delete`, `exists`, and `move`.
    ///
    /// The public methods of `NSScriptCommandDescription` are used primarily by Cocoa’s built-in scripting support in responding to Apple events that target the application. Although you can subclass the `NSScriptCommandDescription` class, it is unlikely that you would need to do so, or to create instances of it.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSScriptCommandDescription;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSScriptCommandDescription {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSScriptCommandDescription {}
);

impl NSScriptCommandDescription {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `command_declaration` generic should be of the correct type.
        #[unsafe(method(initWithSuiteName:commandName:dictionary:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSuiteName_commandName_dictionary(
            this: Allocated<Self>,
            suite_name: &NSString,
            command_name: &NSString,
            command_declaration: Option<&NSDictionary>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `in_coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            in_coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(suiteName))]
        #[unsafe(method_family = none)]
        pub fn suiteName(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(commandName))]
        #[unsafe(method_family = none)]
        pub fn commandName(&self) -> Retained<NSString>;

        #[unsafe(method(appleEventClassCode))]
        #[unsafe(method_family = none)]
        pub fn appleEventClassCode(&self) -> FourCharCode;

        #[unsafe(method(appleEventCode))]
        #[unsafe(method_family = none)]
        pub fn appleEventCode(&self) -> FourCharCode;

        #[cfg(feature = "NSString")]
        #[unsafe(method(commandClassName))]
        #[unsafe(method_family = none)]
        pub fn commandClassName(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(returnType))]
        #[unsafe(method_family = none)]
        pub fn returnType(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(appleEventCodeForReturnType))]
        #[unsafe(method_family = none)]
        pub fn appleEventCodeForReturnType(&self) -> FourCharCode;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(argumentNames))]
        #[unsafe(method_family = none)]
        pub fn argumentNames(&self) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(typeForArgumentWithName:))]
        #[unsafe(method_family = none)]
        pub fn typeForArgumentWithName(
            &self,
            argument_name: &NSString,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(appleEventCodeForArgumentWithName:))]
        #[unsafe(method_family = none)]
        pub fn appleEventCodeForArgumentWithName(&self, argument_name: &NSString) -> FourCharCode;

        #[cfg(feature = "NSString")]
        #[unsafe(method(isOptionalArgumentWithName:))]
        #[unsafe(method_family = none)]
        pub fn isOptionalArgumentWithName(&self, argument_name: &NSString) -> bool;

        #[cfg(feature = "NSScriptCommand")]
        #[unsafe(method(createCommandInstance))]
        #[unsafe(method_family = none)]
        pub fn createCommandInstance(&self) -> Retained<NSScriptCommand>;

        #[cfg(all(feature = "NSScriptCommand", feature = "NSZone"))]
        /// # Safety
        ///
        /// `zone` must be a valid pointer or null.
        #[unsafe(method(createCommandInstanceWithZone:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createCommandInstanceWithZone(
            &self,
            zone: *mut NSZone,
        ) -> Retained<NSScriptCommand>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSScriptCommandDescription {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
