//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// The type that defines a persistent identifier value for a user activity.
///
/// ## Discussion
///
/// In Objective-C, [`NSUserActivity`](https://developer.apple.com/documentation/foundation/nsuseractivity) persistent identifiers are a type alias of [`NSString`](https://developer.apple.com/documentation/foundation/nsstring). In Swift, [`NSUserActivity`](https://developer.apple.com/documentation/foundation/nsuseractivity) persistent identifiers use the [`NSUserActivityPersistentIdentifier`](https://developer.apple.com/documentation/foundation/nsuseractivitypersistentidentifier) structure.
///
///
#[cfg(feature = "NSString")]
pub type NSUserActivityPersistentIdentifier = NSString;

extern_class!(
    /// A representation of the state of your app at a moment in time.
    ///
    /// ## Overview
    ///
    /// An [`NSUserActivity`](https://developer.apple.com/documentation/foundation/nsuseractivity) object provides a lightweight way to capture the state of your app and put it to use later. Create this object to capture information about what a person was doing, such as viewing app content, editing a document, viewing a web page, or watching a video. When the system launches your app and an activity object is available, your app can use the information in that object to restore itself to an appropriate state. Spotlight also uses these objects to improve search results for people. To allow people to continue an activity on another device, see [Implementing Handoff in Your App](https://developer.apple.com/documentation/foundation/implementing-handoff-in-your-app).
    ///
    /// ### Siri
    ///
    /// If SiriKit needs to launch your app for any reason, it creates a user activity object and assigns an appropriate doc://com.apple.documentation/documentation/sirikit/ininteraction object to its [`interaction`](https://developer.apple.com/documentation/foundation/nsuseractivity/interaction) property. Your app can use the interaction information to configure itself and display information related to the interaction started by SiriKit. You can also provide SiriKit with a custom user activity object containing additional data that you want passed to your app.
    ///
    /// In iOS 15 and later, a person can share content they’re viewing by asking Siri to “share this”. Apps built with Mac Catalyst provide the same capability with an [`NSSharingServicePickerToolbarItem`](https://developer.apple.com/documentation/appkit/nssharingservicepickertoolbaritem) in the toolbar. You can use [`activityItemsConfiguration`](https://developer.apple.com/documentation/uikit/uiactivityitemsconfigurationproviding/activityitemsconfiguration) or [`activityItemsConfigurationSource`](https://developer.apple.com/documentation/uikit/uiwindowscene/activityitemsconfigurationsource) to provide shareable content. In iOS, if both of those properties are [`nil`](https://developer.apple.com/documentation/objectivec/nil-227m0), Siri uses the [`webpageURL`](https://developer.apple.com/documentation/foundation/nsuseractivity/webpageurl) property of your app’s current user activity as a fallback value.
    ///
    /// ### Quick Note
    ///
    /// Quick Note on macOS and iOS can link to any app content represented as an [`NSUserActivity`](https://developer.apple.com/documentation/foundation/nsuseractivity). To appear as a link, the content must be the app’s current activity, and provide at least one of the following identifiers:
    ///
    /// - [`webpageURL`](https://developer.apple.com/documentation/foundation/nsuseractivity/webpageurl): An `https:` URL, ideally in a canonical form that’s consistent every time a person visits the same content.
    ///
    /// - [`persistentIdentifier`](https://developer.apple.com/documentation/foundation/nsuseractivity/persistentidentifier): A string that uniquely identifies the content in this domain. The identifier should identify the same content across devices.
    ///
    /// - [`targetContentIdentifier`](https://developer.apple.com/documentation/foundation/nsuseractivity/targetcontentidentifier): A string that uniquely identifies the content in this domain, but also allows disambiguating between multiple scenes of an app. The identifier should identify the same content across devices.
    ///
    /// To work well with Quick Note, content must adhere to the following guidelines:
    ///
    /// - The activity [`title`](https://developer.apple.com/documentation/foundation/nsuseractivity/title) should be clear and concise. This text describes the content of the link, like “Photo taken on July 27, 2020” or “Conversation with Maria”. Use nouns for activity titles.
    ///
    /// - Keep the app’s current activity up to date, using [`becomeCurrent`](https://developer.apple.com/documentation/foundation/nsuseractivity/becomecurrent()) and [`resignCurrent`](https://developer.apple.com/documentation/foundation/nsuseractivity/resigncurrent()).
    ///
    /// - Linkable identifiers (listed above) must be stable and consistent for the same content. When you link from a note to a document in an app, and later revisit that document, the system shows an indicator linking back to the note. The system compares identifiers to check that the document is the same as the original source of the link.
    ///
    /// - Maintain support for activities provided by your app, and support navigating to linked content indefinitely. Links added to notes are important to people, who may feel that a broken link indicates data loss.
    ///
    /// - Gracefully handle attempts to navigate to an activity that points to content that doesn’t exist. For example, you can redirect to the new location of moved content, or show an error message. This situation may happen with shared notes, when a person links to content that exists only on another person’s device.
    ///
    /// ### Search results
    ///
    /// If your [`NSUserActivity`](https://developer.apple.com/documentation/foundation/nsuseractivity) objects contain information that a person might want to search for later, set the [`eligibleForSearch`](https://developer.apple.com/documentation/foundation/nsuseractivity/iseligibleforsearch) property to [`true`](https://developer.apple.com/documentation/swift/true). When you enable search, Spotlight indexes your user activity objects and considers them during subsequent on-device searches. For example, if a person viewed information about a particular restaurant in your app, you’d enable search for the corresponding user activity object. Subsequent searches for restaurants using Spotlight could then include the results obtained from your user activity object.
    ///
    /// In addition to on-device searches, you can contribute URLs accessed by your app with the global Spotlight search engine. Sharing a URL helps Spotlight improve its own search results for other people. To contribute a URL, put the URL in the [`webpageURL`](https://developer.apple.com/documentation/foundation/nsuseractivity/webpageurl) property of your activity object and set the [`eligibleForPublicIndexing`](https://developer.apple.com/documentation/foundation/nsuseractivity/iseligibleforpublicindexing) property to [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Your app must maintain a strong reference to any activity objects that you use for search results.
    ///
    ///
    ///
    /// </div>
    /// Employ user activity objects to record user-initiated activities, not as a general-purpose indexing mechanism of your app’s data. To index all of your app’s content, and not just the content touched by people, use the APIs of the [`Core Spotlight`](https://developer.apple.com/documentation/corespotlight) framework.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSUserActivity;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSUserActivity {}
);

impl NSUserActivity {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithActivityType:))]
        #[unsafe(method_family = init)]
        pub fn initWithActivityType(
            this: Allocated<Self>,
            activity_type: &NSString,
        ) -> Retained<Self>;

        #[deprecated = "Use initWithActivityType: with a specific activity type string"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(activityType))]
        #[unsafe(method_family = none)]
        pub fn activityType(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub fn title(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`title`][Self::title].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setTitle:))]
        #[unsafe(method_family = none)]
        pub fn setTitle(&self, title: Option<&NSString>);

        #[cfg(feature = "NSDictionary")]
        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub fn userInfo(&self) -> Option<Retained<NSDictionary>>;

        #[cfg(feature = "NSDictionary")]
        /// Setter for [`userInfo`][Self::userInfo].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[unsafe(method(setUserInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUserInfo(&self, user_info: Option<&NSDictionary>);

        #[cfg(feature = "NSDictionary")]
        /// # Safety
        ///
        /// `other_dictionary` generic should be of the correct type.
        #[unsafe(method(addUserInfoEntriesFromDictionary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addUserInfoEntriesFromDictionary(&self, other_dictionary: &NSDictionary);

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[unsafe(method(requiredUserInfoKeys))]
        #[unsafe(method_family = none)]
        pub fn requiredUserInfoKeys(&self) -> Option<Retained<NSSet<NSString>>>;

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        /// Setter for [`requiredUserInfoKeys`][Self::requiredUserInfoKeys].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setRequiredUserInfoKeys:))]
        #[unsafe(method_family = none)]
        pub fn setRequiredUserInfoKeys(&self, required_user_info_keys: Option<&NSSet<NSString>>);

        #[unsafe(method(needsSave))]
        #[unsafe(method_family = none)]
        pub fn needsSave(&self) -> bool;

        /// Setter for [`needsSave`][Self::needsSave].
        #[unsafe(method(setNeedsSave:))]
        #[unsafe(method_family = none)]
        pub fn setNeedsSave(&self, needs_save: bool);

        #[cfg(feature = "NSURL")]
        #[unsafe(method(webpageURL))]
        #[unsafe(method_family = none)]
        pub fn webpageURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        /// Setter for [`webpageURL`][Self::webpageURL].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setWebpageURL:))]
        #[unsafe(method_family = none)]
        pub fn setWebpageURL(&self, webpage_url: Option<&NSURL>);

        #[cfg(feature = "NSURL")]
        #[unsafe(method(referrerURL))]
        #[unsafe(method_family = none)]
        pub fn referrerURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        /// Setter for [`referrerURL`][Self::referrerURL].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setReferrerURL:))]
        #[unsafe(method_family = none)]
        pub fn setReferrerURL(&self, referrer_url: Option<&NSURL>);

        #[cfg(feature = "NSDate")]
        #[unsafe(method(expirationDate))]
        #[unsafe(method_family = none)]
        pub fn expirationDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        /// Setter for [`expirationDate`][Self::expirationDate].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setExpirationDate:))]
        #[unsafe(method_family = none)]
        pub fn setExpirationDate(&self, expiration_date: Option<&NSDate>);

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[unsafe(method(keywords))]
        #[unsafe(method_family = none)]
        pub fn keywords(&self) -> Retained<NSSet<NSString>>;

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        /// Setter for [`keywords`][Self::keywords].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setKeywords:))]
        #[unsafe(method_family = none)]
        pub fn setKeywords(&self, keywords: &NSSet<NSString>);

        #[unsafe(method(supportsContinuationStreams))]
        #[unsafe(method_family = none)]
        pub fn supportsContinuationStreams(&self) -> bool;

        /// Setter for [`supportsContinuationStreams`][Self::supportsContinuationStreams].
        #[unsafe(method(setSupportsContinuationStreams:))]
        #[unsafe(method_family = none)]
        pub fn setSupportsContinuationStreams(&self, supports_continuation_streams: bool);

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSUserActivityDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSUserActivityDelegate>>);

        #[cfg(feature = "NSString")]
        #[unsafe(method(targetContentIdentifier))]
        #[unsafe(method_family = none)]
        pub fn targetContentIdentifier(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`targetContentIdentifier`][Self::targetContentIdentifier].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setTargetContentIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setTargetContentIdentifier(&self, target_content_identifier: Option<&NSString>);

        #[unsafe(method(becomeCurrent))]
        #[unsafe(method_family = none)]
        pub fn becomeCurrent(&self);

        #[unsafe(method(resignCurrent))]
        #[unsafe(method_family = none)]
        pub fn resignCurrent(&self);

        #[unsafe(method(invalidate))]
        #[unsafe(method_family = none)]
        pub fn invalidate(&self);

        #[cfg(all(feature = "NSError", feature = "NSStream", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(getContinuationStreamsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getContinuationStreamsWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSInputStream, *mut NSOutputStream, *mut NSError),
            >,
        );

        #[unsafe(method(isEligibleForHandoff))]
        #[unsafe(method_family = none)]
        pub fn isEligibleForHandoff(&self) -> bool;

        /// Setter for [`isEligibleForHandoff`][Self::isEligibleForHandoff].
        #[unsafe(method(setEligibleForHandoff:))]
        #[unsafe(method_family = none)]
        pub fn setEligibleForHandoff(&self, eligible_for_handoff: bool);

        #[unsafe(method(isEligibleForSearch))]
        #[unsafe(method_family = none)]
        pub fn isEligibleForSearch(&self) -> bool;

        /// Setter for [`isEligibleForSearch`][Self::isEligibleForSearch].
        #[unsafe(method(setEligibleForSearch:))]
        #[unsafe(method_family = none)]
        pub fn setEligibleForSearch(&self, eligible_for_search: bool);

        #[unsafe(method(isEligibleForPublicIndexing))]
        #[unsafe(method_family = none)]
        pub fn isEligibleForPublicIndexing(&self) -> bool;

        /// Setter for [`isEligibleForPublicIndexing`][Self::isEligibleForPublicIndexing].
        #[unsafe(method(setEligibleForPublicIndexing:))]
        #[unsafe(method_family = none)]
        pub fn setEligibleForPublicIndexing(&self, eligible_for_public_indexing: bool);

        #[unsafe(method(isEligibleForPrediction))]
        #[unsafe(method_family = none)]
        pub fn isEligibleForPrediction(&self) -> bool;

        /// Setter for [`isEligibleForPrediction`][Self::isEligibleForPrediction].
        #[unsafe(method(setEligibleForPrediction:))]
        #[unsafe(method_family = none)]
        pub fn setEligibleForPrediction(&self, eligible_for_prediction: bool);

        #[cfg(feature = "NSString")]
        #[unsafe(method(persistentIdentifier))]
        #[unsafe(method_family = none)]
        pub fn persistentIdentifier(&self) -> Option<Retained<NSUserActivityPersistentIdentifier>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`persistentIdentifier`][Self::persistentIdentifier].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setPersistentIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setPersistentIdentifier(
            &self,
            persistent_identifier: Option<&NSUserActivityPersistentIdentifier>,
        );

        #[cfg(all(feature = "NSArray", feature = "NSString", feature = "block2"))]
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(deleteSavedUserActivitiesWithPersistentIdentifiers:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteSavedUserActivitiesWithPersistentIdentifiers_completionHandler(
            persistent_identifiers: &NSArray<NSUserActivityPersistentIdentifier>,
            handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(deleteAllSavedUserActivitiesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteAllSavedUserActivitiesWithCompletionHandler(
            handler: &block2::DynBlock<dyn Fn()>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSUserActivity {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSUserActivity {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern "C" {
    /// An activity that continues from Handoff or a universal link.
    ///
    /// ## Discussion
    ///
    /// An [`NSUserActivity`](https://developer.apple.com/documentation/foundation/nsuseractivity) object with an [`activityType`](https://developer.apple.com/documentation/foundation/nsuseractivity/activitytype) value of [`NSUserActivityTypeBrowsingWeb`](https://developer.apple.com/documentation/foundation/nsuseractivitytypebrowsingweb) indicates either an activity continued from a web browser-to-native app Handoff or a universal link. For this activity type, the [`webpageURL`](https://developer.apple.com/documentation/foundation/nsuseractivity/webpageurl) property contains the `http` or `https` URL associated with the activity.
    ///
    /// For more information on universal links, see [Allowing apps and websites to link to your content](https://developer.apple.com/documentation/xcode/allowing-apps-and-websites-to-link-to-your-content). For more information on web browser-to-native app Handoff, see [Web Browser–to–Native App Handoff](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/Handoff/AdoptingHandoff/AdoptingHandoff.html#//apple_ref/doc/uid/TP40014338-CH2-SW10).
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSUserActivityTypeBrowsingWeb: &'static NSString;
}

extern_protocol!(
    /// The interface through which a user activity instance notifies its delegate of updates.
    ///
    /// ## Overview
    ///
    /// An object conforming to the [`NSUserActivityDelegate`](https://developer.apple.com/documentation/foundation/nsuseractivitydelegate) protocol works with an [`NSUserActivity`](https://developer.apple.com/documentation/foundation/nsuseractivity) object, which encapsulates the state of a user activity in an application on a particular device and enables the same activity to be continued on another device. For example, a user browsing an article in Safari on a Mac can move to an iOS device where the same webpage automatically opens in Safari with the same scroll position.
    ///
    /// The user activity delegate is responsible for updating the state of an activity and is also notified when an activity has been continued on another device. The user activity delegate is typically a top-level object in the app—such as a window, view controller, or the app delegate—that manages the activity’s interaction with the app.
    ///
    ///
    pub unsafe trait NSUserActivityDelegate: NSObjectProtocol {
        #[optional]
        #[unsafe(method(userActivityWillSave:))]
        #[unsafe(method_family = none)]
        fn userActivityWillSave(&self, user_activity: &NSUserActivity);

        #[optional]
        #[unsafe(method(userActivityWasContinued:))]
        #[unsafe(method_family = none)]
        fn userActivityWasContinued(&self, user_activity: &NSUserActivity);

        #[cfg(feature = "NSStream")]
        #[optional]
        #[unsafe(method(userActivity:didReceiveInputStream:outputStream:))]
        #[unsafe(method_family = none)]
        fn userActivity_didReceiveInputStream_outputStream(
            &self,
            user_activity: &NSUserActivity,
            input_stream: &NSInputStream,
            output_stream: &NSOutputStream,
        );
    }
);
