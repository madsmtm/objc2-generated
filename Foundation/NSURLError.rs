//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern "C" {
    /// URL loading system errors
    #[cfg(all(feature = "NSError", feature = "NSString"))]
    pub static NSURLErrorDomain: &'static NSErrorDomain;
}

extern "C" {
    /// The URL which caused a load to fail.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) instance.
    ///
    ///
    /// The NSError userInfo dictionary key used to store and retrieve the URL which caused a load to fail.
    #[cfg(feature = "NSString")]
    pub static NSURLErrorFailingURLErrorKey: &'static NSString;
}

extern "C" {
    /// The URL which caused a load to fail.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object.
    ///
    /// This constant supersedes [`NSErrorFailingURLStringKey`](https://developer.apple.com/documentation/foundation/nserrorfailingurlstringkey), which was deprecated starting in macOS 10.6.  Both constants refer to the same value for backward-compatibility, but this symbol name has a better prefix.
    ///
    ///
    /// The NSError userInfo dictionary key used to store and retrieve the NSString object for the URL which caused a load to fail.
    ///
    /// This constant supersedes NSErrorFailingURLStringKey, which was deprecated in Mac OS X 10.6.  Both constants refer to the same value for backward-compatibility, but this symbol name has a better prefix.
    #[cfg(feature = "NSString")]
    #[deprecated = "Use NSURLErrorFailingURLErrorKey instead"]
    pub static NSURLErrorFailingURLStringErrorKey: &'static NSString;
}

extern "C" {
    /// The URL that caused the error.
    /// The NSError userInfo dictionary key used to store and retrieve the NSString object for the URL which caused a load to fail.
    ///
    /// This constant is deprecated in Mac OS X 10.6, and is superseded by NSURLErrorFailingURLStringErrorKey.  Both constants refer to the same value for backward-compatibility, but the new symbol name has a better prefix.
    #[cfg(feature = "NSString")]
    #[deprecated = "Use NSURLErrorFailingURLErrorKey instead"]
    pub static NSErrorFailingURLStringKey: &'static NSString;
}

extern "C" {
    /// The state of a failed SSL handshake.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is the [`SecTrustRef`](https://developer.apple.com/documentation/security/sectrust) object.
    ///
    ///
    /// The NSError userInfo dictionary key used to store and retrieve the SecTrustRef object representing the state of a failed SSL handshake.
    #[cfg(feature = "NSString")]
    pub static NSURLErrorFailingURLPeerTrustErrorKey: &'static NSString;
}

extern "C" {
    /// A key in the error dictionary that provides the reason for canceling a background task.
    ///
    /// ## Discussion
    ///
    /// The value associated with this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber). For a list of possible values, see URL Session Background Task Cancellation Reasons.
    ///
    ///
    /// The NSError userInfo dictionary key used to store and retrieve the NSNumber corresponding to the reason why a background
    /// NSURLSessionTask was cancelled
    #[cfg(feature = "NSString")]
    pub static NSURLErrorBackgroundTaskCancelledReasonKey: &'static NSString;
}

/// A reason that indicates the system canceled the background task because the user force-quit the application.
pub const NSURLErrorCancelledReasonUserForceQuitApplication: NSInteger = 0;
/// A reason that indicates the system canceled the background task because background tasks are disabled.
pub const NSURLErrorCancelledReasonBackgroundUpdatesDisabled: NSInteger = 1;
/// A reason that indicates the system canceled the background task because it lacks sufficient resources to perform the task.
///
/// ## Discussion
///
/// This error results from factors including (but not limited to) battery capacity, thermal condition, network connectivity, and cellular data plan.
///
///
pub const NSURLErrorCancelledReasonInsufficientSystemResources: NSInteger = 2;

extern "C" {
    /// The reason the network was unavailable for a task.
    ///
    /// ## Discussion
    ///
    /// The value associated with this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber). For possible values, see [`NSURLErrorNetworkUnavailableReason`](https://developer.apple.com/documentation/foundation/nsurlerrornetworkunavailablereason).
    ///
    ///
    /// The NSErrorUserInfoKey used to store and retrieve the NSNumber object corresponding to the reason why the network is unavailable when the task failed due to unsatisfiable network constraints.  See the NSURLErrorNetworkUnavailableReason enum for details.
    #[cfg(all(feature = "NSError", feature = "NSString"))]
    pub static NSURLErrorNetworkUnavailableReasonKey: &'static NSErrorUserInfoKey;
}

/// An enumeration of reasons why a task couldn’t satisfy networking constraints.
///
/// ## Overview
///
/// The network may be unavailable due to restrictions placed on the [`URLSessionConfiguration`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration), such as [`allowsConstrainedNetworkAccess`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/allowsconstrainednetworkaccess), [`allowsExpensiveNetworkAccess`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/allowsexpensivenetworkaccess) and [`allowsCellularAccess`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/allowscellularaccess).
///
///
/// Constants used by NSError to indicate that a URLSessionTask failed because of unsatisfiable network constraints.
///
/// For example if the URLSessionConfiguration property allowsExpensiveNetworkAccess was set to NO and the only interfaces available were marked as expensive then the task would fail with a NSURLErrorNotConnectedToInternet error and the userInfo dictionary would contain the value NSURLErrorNetworkUnavailableReasonExpensive for the key NSURLErrorNetworkUnavailableReason.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLErrorNetworkUnavailableReason(pub NSInteger);
impl NSURLErrorNetworkUnavailableReason {
    /// A reason that indicates network is unavailable because the interface is cellular and cellular network is disabled.
    #[doc(alias = "NSURLErrorNetworkUnavailableReasonCellular")]
    pub const Cellular: Self = Self(0);
    /// A reason that indicates network is unavailable because the system marked the interface as expensive.
    ///
    /// ## Discussion
    ///
    /// The system determines what constitutes “expensive” based on the nature of the network interface and other factors. iOS 13 considers most cellular networks and personal hotspots expensive, but this may change in the future.
    ///
    /// This reason occurs when the following conditions are true:
    ///
    /// - The only available network interfaces are expensive.
    ///
    /// - The [`URLSessionConfiguration`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration) property [`allowsExpensiveNetworkAccess`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/allowsexpensivenetworkaccess) is [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    #[doc(alias = "NSURLErrorNetworkUnavailableReasonExpensive")]
    pub const Expensive: Self = Self(1);
    /// A reason that indicates network is unavailable because the user enabled “Low Data Mode” in the Settings app.
    ///
    /// ## Discussion
    ///
    /// This reason occurs when the following conditions are true:
    ///
    /// - The only available network is cellular.
    ///
    /// - The user has enabled “Low Data Mode” option in the Cellular Data Options section of the Settings app.
    ///
    /// - The [`URLSessionConfiguration`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration) property [`allowsConstrainedNetworkAccess`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/allowsconstrainednetworkaccess) is [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    #[doc(alias = "NSURLErrorNetworkUnavailableReasonConstrained")]
    pub const Constrained: Self = Self(2);
    #[doc(alias = "NSURLErrorNetworkUnavailableReasonUltraConstrained")]
    pub const UltraConstrained: Self = Self(3);
}

unsafe impl Encode for NSURLErrorNetworkUnavailableReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLErrorNetworkUnavailableReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The URL Loading System encountered an error that it can’t interpret.
///
/// ## Discussion
///
/// This can occur when an error originates from a lower level framework or library. Whenever this error code is received, it is a bug, and should be reported to Apple.
///
///
pub const NSURLErrorUnknown: NSInteger = -1;
/// An asynchronous load has been canceled.
///
/// ## Discussion
///
/// `NSURLSession` sends this error to its delegate when a task is cancelled.
///
///
pub const NSURLErrorCancelled: NSInteger = -999;
/// A malformed URL prevented a URL request from being initiated.
pub const NSURLErrorBadURL: NSInteger = -1000;
/// An asynchronous operation timed out.
///
/// ## Discussion
///
/// [`URLSession`](https://developer.apple.com/documentation/foundation/urlsession) sends this error to its delegate when the [`timeoutInterval`](https://developer.apple.com/documentation/foundation/nsurlrequest/timeoutinterval) of an [`NSURLRequest`](https://developer.apple.com/documentation/foundation/nsurlrequest) expires before a load can complete.
///
///
pub const NSURLErrorTimedOut: NSInteger = -1001;
/// A properly formed URL couldn’t be handled by the framework.
///
/// ## Discussion
///
/// The most likely cause is that there is no available protocol handler for the URL.
///
///
pub const NSURLErrorUnsupportedURL: NSInteger = -1002;
/// The host name for a URL couldn’t be resolved.
pub const NSURLErrorCannotFindHost: NSInteger = -1003;
/// An attempt to connect to a host failed.
///
/// ## Discussion
///
/// This can occur when a host name resolves, but the host is down or may not be accepting connections on a certain port.
///
///
pub const NSURLErrorCannotConnectToHost: NSInteger = -1004;
/// A client or server connection was severed in the middle of an in-progress load.
pub const NSURLErrorNetworkConnectionLost: NSInteger = -1005;
/// The host address couldn’t be found via DNS lookup.
///
/// ## Discussion
///
/// This error code is no longer used. You should expect to handle `NSURLErrorCannotFindHost` instead.
///
///
pub const NSURLErrorDNSLookupFailed: NSInteger = -1006;
/// A redirect loop was detected or the threshold for number of allowable redirects was exceeded (currently 16).
pub const NSURLErrorHTTPTooManyRedirects: NSInteger = -1007;
/// A requested resource couldn’t be retrieved.
///
/// ## Discussion
///
/// This error can indicate a file-not-found situation, or decoding problems that prevent data from being processed correctly.
///
///
pub const NSURLErrorResourceUnavailable: NSInteger = -1008;
/// A network resource was requested, but an internet connection has not been established and can’t be established automatically.
///
/// ## Discussion
///
/// This error occurs when the connection can’t be established a lack of connectivity or because the user chooses not to make a network connection automatically.
///
///
pub const NSURLErrorNotConnectedToInternet: NSInteger = -1009;
/// A redirect was specified by way of server response code, but the server didn’t accompany this code with a redirect URL.
pub const NSURLErrorRedirectToNonExistentLocation: NSInteger = -1010;
/// The URL Loading System received bad data from the server.
///
/// ## Discussion
///
/// This is equivalent to the “500 Server Error” message sent by HTTP servers.
///
///
pub const NSURLErrorBadServerResponse: NSInteger = -1011;
/// An asynchronous request for authentication has been canceled by the user.
///
/// ## Discussion
///
/// This is typically incurred by clicking a “Cancel” button in a username/password dialog, rather than the user making an attempt to authenticate.
///
///
pub const NSURLErrorUserCancelledAuthentication: NSInteger = -1012;
/// Authentication was required to access a resource.
pub const NSURLErrorUserAuthenticationRequired: NSInteger = -1013;
/// A server reported that a URL has a non-zero content length, but terminated the network connection gracefully without sending any data.
pub const NSURLErrorZeroByteResource: NSInteger = -1014;
/// Content data received during a connection request couldn’t be decoded for a known content encoding.
pub const NSURLErrorCannotDecodeRawData: NSInteger = -1015;
/// Content data received during a connection request had an unknown content encoding.
pub const NSURLErrorCannotDecodeContentData: NSInteger = -1016;
/// A response to a connection request couldn’t be parsed.
pub const NSURLErrorCannotParseResponse: NSInteger = -1017;
/// App Transport Security disallowed a connection because there is no secure network connection.
///
/// ## Discussion
///
/// Starting in iOS 9.0 and macOS v10.11, App Transport Security (ATS) is enabled by default for connections created by [`URLSession`](https://developer.apple.com/documentation/foundation/urlsession). ATS requires the use of best practice secure protocols in HTTPS. For more information on ATS, see [NSAppTransportSecurity](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/plist/info/NSAppTransportSecurity) in [Information Property List Key Reference](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html#//apple_ref/doc/uid/TP40009247).
///
///
pub const NSURLErrorAppTransportSecurityRequiresSecureConnection: NSInteger = -1022;
/// The specified file doesn’t exist.
pub const NSURLErrorFileDoesNotExist: NSInteger = -1100;
/// A request for an FTP file resulted in the server responding that the file is not a plain file, but a directory.
pub const NSURLErrorFileIsDirectory: NSInteger = -1101;
/// A resource couldn’t be read because of insufficient permissions.
pub const NSURLErrorNoPermissionsToReadFile: NSInteger = -1102;
/// The length of the resource data exceeded the maximum allowed.
pub const NSURLErrorDataLengthExceedsMaximum: NSInteger = -1103;
/// An internal file operation failed.
///
/// ## Discussion
///
/// This error is never sent to third-party apps.
///
///
pub const NSURLErrorFileOutsideSafeArea: NSInteger = -1104;
/// An attempt to establish a secure connection failed for reasons that can’t be expressed more specifically.
pub const NSURLErrorSecureConnectionFailed: NSInteger = -1200;
/// A server certificate is expired, or is not yet valid.
pub const NSURLErrorServerCertificateHasBadDate: NSInteger = -1201;
/// A server certificate was signed by a root server that isn’t trusted.
pub const NSURLErrorServerCertificateUntrusted: NSInteger = -1202;
/// A server certificate wasn’t signed by any root server.
pub const NSURLErrorServerCertificateHasUnknownRoot: NSInteger = -1203;
/// A server certificate isn’t valid yet.
pub const NSURLErrorServerCertificateNotYetValid: NSInteger = -1204;
/// A server certificate was rejected.
pub const NSURLErrorClientCertificateRejected: NSInteger = -1205;
/// A client certificate was required to authenticate an SSL connection during a connection request.
pub const NSURLErrorClientCertificateRequired: NSInteger = -1206;
/// A specific request to load an item only from the cache couldn’t be satisfied.
///
/// ## Discussion
///
/// This error is sent when the task needs to load from the network, but is blocked from doing so by the “load only from cache” directive.
///
///
pub const NSURLErrorCannotLoadFromNetwork: NSInteger = -2000;
/// A download task couldn’t create the downloaded file on disk because of an I/O failure.
pub const NSURLErrorCannotCreateFile: NSInteger = -3000;
/// A downloaded file on disk couldn’t be opened.
pub const NSURLErrorCannotOpenFile: NSInteger = -3001;
/// A download task couldn’t close the downloaded file on disk.
pub const NSURLErrorCannotCloseFile: NSInteger = -3002;
/// A download task couldn’t write the file to disk.
pub const NSURLErrorCannotWriteToFile: NSInteger = -3003;
/// A downloaded file couldn’t be removed from disk.
pub const NSURLErrorCannotRemoveFile: NSInteger = -3004;
/// A downloaded file on disk couldn’t be moved.
pub const NSURLErrorCannotMoveFile: NSInteger = -3005;
/// A download task failed to decode an encoded file during the download.
pub const NSURLErrorDownloadDecodingFailedMidStream: NSInteger = -3006;
/// A download task failed to decode an encoded file after downloading.
pub const NSURLErrorDownloadDecodingFailedToComplete: NSInteger = -3007;
/// The attempted connection required activating a data context while roaming, but international roaming is disabled.
pub const NSURLErrorInternationalRoamingOff: NSInteger = -1018;
/// A connection was attempted while a phone call was active on a network that doesn’t support simultaneous phone and data communication, such as EDGE or GPRS.
pub const NSURLErrorCallIsActive: NSInteger = -1019;
/// The cellular network disallowed a connection.
pub const NSURLErrorDataNotAllowed: NSInteger = -1020;
/// A body stream was needed but the client did not provide one.
///
/// ## Discussion
///
/// This impacts clients on iOS that send a `POST` request using a body stream but do not implement the [`URLSessionTaskDelegate`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate) delegate method [`urlSession(_:task:needNewBodyStream:)`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate/urlsession(_:task:neednewbodystream:)).
///
///
pub const NSURLErrorRequestBodyStreamExhausted: NSInteger = -1021;
/// The shared container identifier of the URL session configuration is needed but hasn’t been set.
///
/// ## Discussion
///
/// To use a [`URLSession`](https://developer.apple.com/documentation/foundation/urlsession) to perform background uploading or downloading in an app extension, you coordinate with the host app using a shared container. The app extension must set the [`sharedContainerIdentifier`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/sharedcontaineridentifier) of the URL session’s configuration to the shared container’s identifier. See [Performing Uploads and Downloads](https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/ExtensionScenarios.html#//apple_ref/doc/uid/TP40014214-CH21-SW2) in [App Extension Essentials](https://developer.apple.com/library/archive/documentation/General/Conceptual/ExtensibilityPG/index.html#//apple_ref/doc/uid/TP40014214-CH4) for more information.
///
///
pub const NSURLErrorBackgroundSessionRequiresSharedContainer: NSInteger = -995;
/// An app or app extension attempted to connect to a background session that is already connected to a process.
///
/// ## Discussion
///
/// This error can occur when both an app and an app extension attempt to use a background session at the same time.
///
///
pub const NSURLErrorBackgroundSessionInUseByAnotherProcess: NSInteger = -996;
/// The app is suspended or exits while a background data task is processing.
///
/// ## Discussion
///
/// If your app has created a background data task and the app is then suspended, the task will fail with this error code. To prevent this, when you receive the response, convert the data task to a download task.
///
///
pub const NSURLErrorBackgroundSessionWasDisconnected: NSInteger = -997;
