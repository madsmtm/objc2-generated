//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// Options for methods used to read data objects.
/// **************    Read/Write Options    ***************
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSDataReadingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSDataReadingOptions: NSUInteger {
/// A hint indicating the file should be mapped into virtual memory, if possible and safe.
        #[doc(alias = "NSDataReadingMappedIfSafe")]
        const MappedIfSafe = 1<<0;
/// A hint indicating the file should not be stored in the file-system caches.
///
/// ## Discussion
///
/// For data being read once and discarded, this option can improve performance.
///
///
        #[doc(alias = "NSDataReadingUncached")]
        const Uncached = 1<<1;
/// Hint to map the file in if possible.
///
/// ## Discussion
///
/// This takes precedence over [`NSDataReadingMappedIfSafe`](https://developer.apple.com/documentation/foundation/nsdata/readingoptions/mappedifsafe) if both are given.
///
///
        #[doc(alias = "NSDataReadingMappedAlways")]
        const MappedAlways = 1<<3;
/// Deprecated name for [`NSDataReadingMappedIfSafe`](https://developer.apple.com/documentation/foundation/nsdata/readingoptions/mappedifsafe).
        #[doc(alias = "NSDataReadingMapped")]
#[deprecated]
        const Mapped = NSDataReadingOptions::MappedIfSafe.0;
/// Deprecated name for [`NSDataReadingMapped`](https://developer.apple.com/documentation/foundation/nsdata/readingoptions/datareadingmapped).
#[deprecated]
        const NSMappedRead = NSDataReadingOptions::Mapped.0;
/// Deprecated name for [`NSDataReadingUncached`](https://developer.apple.com/documentation/foundation/nsdata/readingoptions/uncached).
#[deprecated]
        const NSUncachedRead = NSDataReadingOptions::Uncached.0;
    }
}

unsafe impl Encode for NSDataReadingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSDataReadingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for methods used to write data objects.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSDataWritingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSDataWritingOptions: NSUInteger {
/// An option to write data to an auxiliary file first and then replace the original file with the auxiliary file when the write completes.
///
/// ## Discussion
///
/// This option is equivalent to using a write method that takes the parameter `atomically` as [`true`](https://developer.apple.com/documentation/swift/true).
///
///
        #[doc(alias = "NSDataWritingAtomic")]
        const Atomic = 1<<0;
/// An option that attempts to write data to a file and fails with an error if the destination file already exists.
///
/// ## Discussion
///
/// You can’t combine this constant with [`NSDataWritingAtomic`](https://developer.apple.com/documentation/foundation/nsdata/writingoptions/atomic) because atomic allows the system to overwrite the original file.
///
///
        #[doc(alias = "NSDataWritingWithoutOverwriting")]
        const WithoutOverwriting = 1<<1;
/// An option to not encrypt the file when writing it out.
///
/// ## Discussion
///
/// In this case, the system doesn’t store the file in an encrypted format and your app can access this file at boot time and while the device is unlocked.
///
///
        #[doc(alias = "NSDataWritingFileProtectionNone")]
        const FileProtectionNone = 0x10000000;
/// An option to make the file accessible only while the device is unlocked.
///
/// ## Discussion
///
/// In this case, the system stores the file in an encrypted format and your app may only read or write to the file while the device is unlocked. At all other times, any  attempts your app makes to read and write the file will fail.
///
///
        #[doc(alias = "NSDataWritingFileProtectionComplete")]
        const FileProtectionComplete = 0x20000000;
/// An option to allow the file to be accessible while the device is unlocked or the file is already open.
///
/// ## Discussion
///
/// In this case, your app cannot open the file to read it or write to it when the device is locked, but your app can create new files with this class. If one of these files is open when the device is locked, your app can read and write to the opened file.
///
///
        #[doc(alias = "NSDataWritingFileProtectionCompleteUnlessOpen")]
        const FileProtectionCompleteUnlessOpen = 0x30000000;
/// An option to allow the file to be accessible after a user first unlocks the device.
///
/// ## Discussion
///
/// In this case, the app can read or write to the file while the device is unlocked, but while it’s booting up, the file has the protection equivalent to [`NSDataWritingFileProtectionComplete`](https://developer.apple.com/documentation/foundation/nsdata/writingoptions/completefileprotection).
///
///
        #[doc(alias = "NSDataWritingFileProtectionCompleteUntilFirstUserAuthentication")]
        const FileProtectionCompleteUntilFirstUserAuthentication = 0x40000000;
        #[doc(alias = "NSDataWritingFileProtectionCompleteWhenUserInactive")]
        const FileProtectionCompleteWhenUserInactive = 0x50000000;
/// An option the system uses when determining the file protection options that the system assigns to the data.
        #[doc(alias = "NSDataWritingFileProtectionMask")]
        const FileProtectionMask = 0xf0000000;
/// An option that attempts to write data to an auxiliary file first and then exchange the files.
#[deprecated]
        const NSAtomicWrite = NSDataWritingOptions::Atomic.0;
    }
}

unsafe impl Encode for NSDataWritingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSDataWritingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for method used to search data objects.
///
/// ## Overview
///
/// These options are used with the [`rangeOfData:options:range:`](https://developer.apple.com/documentation/foundation/nsdata/range(of:options:in:)) method.
///
///
/// **************    Data Search Options    ***************
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSDataSearchOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSDataSearchOptions: NSUInteger {
/// Search from the end of the data object.
        #[doc(alias = "NSDataSearchBackwards")]
        const Backwards = 1<<0;
/// Search is limited to start (or end, if searching backwards) of the data object.
///
/// ## Discussion
///
/// This option performs searching only on bytes at the beginning of the range (or the end when using [`NSDataSearchBackwards`](https://developer.apple.com/documentation/foundation/nsdata/searchoptions/backwards)). No match at the beginning or end means nothing is found, even if a matching sequence of bytes occurs elsewhere in the data object.
///
///
        #[doc(alias = "NSDataSearchAnchored")]
        const Anchored = 1<<1;
    }
}

unsafe impl Encode for NSDataSearchOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSDataSearchOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for methods used to Base64 encode data.
/// **************        Base 64 Options    ***************
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSDataBase64EncodingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSDataBase64EncodingOptions: NSUInteger {
/// Set the maximum line length to 64 characters, after which a line ending is inserted.
        #[doc(alias = "NSDataBase64Encoding64CharacterLineLength")]
        const Encoding64CharacterLineLength = 1<<0;
/// Set the maximum line length to 76 characters, after which a line ending is inserted.
        #[doc(alias = "NSDataBase64Encoding76CharacterLineLength")]
        const Encoding76CharacterLineLength = 1<<1;
/// When a maximum line length is set, specify that the line ending to insert should include a carriage return.
        #[doc(alias = "NSDataBase64EncodingEndLineWithCarriageReturn")]
        const EncodingEndLineWithCarriageReturn = 1<<4;
/// When a maximum line length is set, specify that the line ending to insert should include a line feed.
        #[doc(alias = "NSDataBase64EncodingEndLineWithLineFeed")]
        const EncodingEndLineWithLineFeed = 1<<5;
    }
}

unsafe impl Encode for NSDataBase64EncodingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSDataBase64EncodingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options to modify the decoding algorithm used to decode Base64 encoded data.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSDataBase64DecodingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSDataBase64DecodingOptions: NSUInteger {
/// Modify the decoding algorithm so that it ignores unknown non-Base-64 bytes, including line ending characters.
        #[doc(alias = "NSDataBase64DecodingIgnoreUnknownCharacters")]
        const IgnoreUnknownCharacters = 1<<0;
    }
}

unsafe impl Encode for NSDataBase64DecodingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSDataBase64DecodingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A static byte buffer in memory.
    ///
    /// ## Overview
    ///
    /// In Swift, the buffer bridges to [`Data`](https://developer.apple.com/documentation/foundation/data); use [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) when you need reference semantics or other Foundation-specific behavior.
    ///
    /// [NSData](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/PropertyLists/OldStylePlists/OldStylePLists.html#//apple_ref/doc/uid/20001012-47169) and its mutable subclass [`NSMutableData`](https://developer.apple.com/documentation/foundation/nsmutabledata) provide data objects, or object-oriented wrappers for byte buffers. Data objects let simple allocated buffers (that is, data with no embedded pointers) take on the behavior of Foundation objects.
    ///
    /// The size of the data is subject to a theoretical limit of about 8 exabytes (1 EB = 10¹⁸ bytes; in practice, the limit should not be a factor).
    ///
    /// [NSData](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/PropertyLists/OldStylePlists/OldStylePLists.html#//apple_ref/doc/uid/20001012-47169) is _toll-free bridged_ with its Core Foundation counterpart, [`CFDataRef`](https://developer.apple.com/documentation/corefoundation/cfdata). See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information on toll-free bridging.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The Swift overlay to the Foundation framework provides the [`Data`](https://developer.apple.com/documentation/foundation/data) structure, which bridges to the [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) class and its mutable subclass [`NSMutableData`](https://developer.apple.com/documentation/foundation/nsmutabledata). For more information about value types, see [Working with Cocoa Frameworks](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6) in [Using Swift with Cocoa and Objective-C (Swift 4.1)](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216).
    ///
    ///
    ///
    /// </div>
    /// ### Writing Data Atomically
    ///
    /// [NSData](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/PropertyLists/OldStylePlists/OldStylePLists.html#//apple_ref/doc/uid/20001012-47169) provides methods for atomically saving their contents to a file, which guarantee that the data is either saved in its entirety, or it fails completely. An atomic write first writes the data to a temporary file and then, only if this write succeeds, moves the temporary file to its final location.
    ///
    /// Although atomic write operations minimize the risk of data loss due to corrupt or partially written files, they may not be appropriate when writing to a temporary directory, the user’s home directory or other publicly accessible directories. When you work with a publicly accessible file, treat that file as an untrusted and potentially dangerous resource. An attacker may compromise or corrupt these files. The attacker can also replace the files with hard or symbolic links, causing your write operations to overwrite or corrupt other system resources.
    ///
    /// Avoid using the [`writeToURL:atomically:`](https://developer.apple.com/documentation/foundation/nsdata/write(to:atomically:)) method (and the related methods) when working inside a publicly accessible directory. Instead, use [`NSFileHandle`](https://developer.apple.com/documentation/foundation/filehandle) with an existing file descriptor to securely write the file.
    ///
    /// For more information, see [Securing File Operations](https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Articles/RaceConditions.html#//apple_ref/doc/uid/TP40002585-SW9) in [Secure Coding Guide](https://developer.apple.com/library/archive/documentation/Security/Conceptual/SecureCodingGuide/Introduction.html#//apple_ref/doc/uid/TP40002415).
    ///
    ///
    /// **************    Immutable Data        ***************
    #[unsafe(super(NSObject))]
    #[derive(PartialEq, Eq, Hash)]
    pub struct NSData;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSData> for CFData {
    #[inline]
    fn as_ref(&self) -> &NSData {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFData> for NSData {
    #[inline]
    fn as_ref(&self) -> &CFData {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSData {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSData {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSData {
    type Result = Self;
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSMutableCopying for NSData {}
);

#[cfg(feature = "NSObject")]
unsafe impl MutableCopyingHelper for NSData {
    type Result = NSMutableData;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSData {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSData {}
);

impl NSData {
    extern_methods!(
        #[unsafe(method(length))]
        #[unsafe(method_family = none)]
        pub fn length(&self) -> NSUInteger;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSData {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSData {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSExtendedData.
impl NSData {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(description))]
        #[unsafe(method_family = none)]
        pub fn description(&self) -> Retained<NSString>;

        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[unsafe(method(getBytes:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getBytes_length(&self, buffer: NonNull<c_void>, length: NSUInteger);

        #[cfg(feature = "NSRange")]
        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[unsafe(method(getBytes:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getBytes_range(&self, buffer: NonNull<c_void>, range: NSRange);

        #[unsafe(method(isEqualToData:))]
        #[unsafe(method_family = none)]
        pub fn isEqualToData(&self, other: &NSData) -> bool;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(subdataWithRange:))]
        #[unsafe(method_family = none)]
        pub fn subdataWithRange(&self, range: NSRange) -> Retained<NSData>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(writeToFile:atomically:))]
        #[unsafe(method_family = none)]
        pub fn writeToFile_atomically(&self, path: &NSString, use_auxiliary_file: bool) -> bool;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(writeToURL:atomically:))]
        #[unsafe(method_family = none)]
        pub fn writeToURL_atomically(&self, url: &NSURL, atomically: bool) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(writeToFile:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn writeToFile_options_error(
            &self,
            path: &NSString,
            write_options_mask: NSDataWritingOptions,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(writeToURL:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn writeToURL_options_error(
            &self,
            url: &NSURL,
            write_options_mask: NSDataWritingOptions,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(rangeOfData:options:range:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfData_options_range(
            &self,
            data_to_find: &NSData,
            mask: NSDataSearchOptions,
            search_range: NSRange,
        ) -> NSRange;

        #[cfg(all(feature = "NSRange", feature = "block2"))]
        #[unsafe(method(enumerateByteRangesUsingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateByteRangesUsingBlock(
            &self,
            block: &block2::DynBlock<dyn Fn(NonNull<c_void>, NSRange, NonNull<Bool>) + '_>,
        );
    );
}

/// NSDataCreation.
impl NSData {
    extern_methods!(
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub fn data() -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer or null.
        #[unsafe(method(dataWithBytes:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataWithBytes_length(
            bytes: *const c_void,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(dataWithBytesNoCopy:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataWithBytesNoCopy_length(
            bytes: NonNull<c_void>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(dataWithBytesNoCopy:length:freeWhenDone:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataWithBytesNoCopy_length_freeWhenDone(
            bytes: NonNull<c_void>,
            length: NSUInteger,
            b: bool,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(dataWithContentsOfFile:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn dataWithContentsOfFile_options_error(
            path: &NSString,
            read_options_mask: NSDataReadingOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(dataWithContentsOfURL:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn dataWithContentsOfURL_options_error(
            url: &NSURL,
            read_options_mask: NSDataReadingOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(dataWithContentsOfFile:))]
        #[unsafe(method_family = none)]
        pub fn dataWithContentsOfFile(path: &NSString) -> Option<Retained<Self>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(dataWithContentsOfURL:))]
        #[unsafe(method_family = none)]
        pub fn dataWithContentsOfURL(url: &NSURL) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer or null.
        #[unsafe(method(initWithBytes:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytes_length(
            this: Allocated<Self>,
            bytes: *const c_void,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:freeWhenDone:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length_freeWhenDone(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            length: NSUInteger,
            b: bool,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:deallocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length_deallocator(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            length: NSUInteger,
            deallocator: Option<&block2::DynBlock<dyn Fn(NonNull<c_void>, NSUInteger)>>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(initWithContentsOfFile:options:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile_options_error(
            this: Allocated<Self>,
            path: &NSString,
            read_options_mask: NSDataReadingOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithContentsOfURL:options:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL_options_error(
            this: Allocated<Self>,
            url: &NSURL,
            read_options_mask: NSDataReadingOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithContentsOfFile:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile(
            this: Allocated<Self>,
            path: &NSString,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(initWithContentsOfURL:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL(this: Allocated<Self>, url: &NSURL) -> Option<Retained<Self>>;

        #[unsafe(method(initWithData:))]
        #[unsafe(method_family = init)]
        pub fn initWithData(this: Allocated<Self>, data: &NSData) -> Retained<Self>;

        #[unsafe(method(dataWithData:))]
        #[unsafe(method_family = none)]
        pub fn dataWithData(data: &NSData) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSData`.
///
/// NSDataCreation.
impl NSMutableData {
    extern_methods!(
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub fn data() -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer or null.
        #[unsafe(method(dataWithBytes:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataWithBytes_length(
            bytes: *const c_void,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(dataWithBytesNoCopy:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataWithBytesNoCopy_length(
            bytes: NonNull<c_void>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(dataWithBytesNoCopy:length:freeWhenDone:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataWithBytesNoCopy_length_freeWhenDone(
            bytes: NonNull<c_void>,
            length: NSUInteger,
            b: bool,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(dataWithContentsOfFile:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn dataWithContentsOfFile_options_error(
            path: &NSString,
            read_options_mask: NSDataReadingOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(dataWithContentsOfURL:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn dataWithContentsOfURL_options_error(
            url: &NSURL,
            read_options_mask: NSDataReadingOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(dataWithContentsOfFile:))]
        #[unsafe(method_family = none)]
        pub fn dataWithContentsOfFile(path: &NSString) -> Option<Retained<Self>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(dataWithContentsOfURL:))]
        #[unsafe(method_family = none)]
        pub fn dataWithContentsOfURL(url: &NSURL) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer or null.
        #[unsafe(method(initWithBytes:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytes_length(
            this: Allocated<Self>,
            bytes: *const c_void,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:freeWhenDone:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length_freeWhenDone(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            length: NSUInteger,
            b: bool,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:deallocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length_deallocator(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            length: NSUInteger,
            deallocator: Option<&block2::DynBlock<dyn Fn(NonNull<c_void>, NSUInteger)>>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(initWithContentsOfFile:options:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile_options_error(
            this: Allocated<Self>,
            path: &NSString,
            read_options_mask: NSDataReadingOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithContentsOfURL:options:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL_options_error(
            this: Allocated<Self>,
            url: &NSURL,
            read_options_mask: NSDataReadingOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithContentsOfFile:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile(
            this: Allocated<Self>,
            path: &NSString,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(initWithContentsOfURL:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL(this: Allocated<Self>, url: &NSURL) -> Option<Retained<Self>>;

        #[unsafe(method(initWithData:))]
        #[unsafe(method_family = init)]
        pub fn initWithData(this: Allocated<Self>, data: &NSData) -> Retained<Self>;

        #[unsafe(method(dataWithData:))]
        #[unsafe(method_family = none)]
        pub fn dataWithData(data: &NSData) -> Retained<Self>;
    );
}

/// NSDataBase64Encoding.
impl NSData {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithBase64EncodedString:options:))]
        #[unsafe(method_family = init)]
        pub fn initWithBase64EncodedString_options(
            this: Allocated<Self>,
            base64_string: &NSString,
            options: NSDataBase64DecodingOptions,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(base64EncodedStringWithOptions:))]
        #[unsafe(method_family = none)]
        pub fn base64EncodedStringWithOptions(
            &self,
            options: NSDataBase64EncodingOptions,
        ) -> Retained<NSString>;

        #[unsafe(method(initWithBase64EncodedData:options:))]
        #[unsafe(method_family = init)]
        pub fn initWithBase64EncodedData_options(
            this: Allocated<Self>,
            base64_data: &NSData,
            options: NSDataBase64DecodingOptions,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(base64EncodedDataWithOptions:))]
        #[unsafe(method_family = none)]
        pub fn base64EncodedDataWithOptions(
            &self,
            options: NSDataBase64EncodingOptions,
        ) -> Retained<NSData>;
    );
}

/// Methods declared on superclass `NSData`.
///
/// NSDataBase64Encoding.
impl NSMutableData {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithBase64EncodedString:options:))]
        #[unsafe(method_family = init)]
        pub fn initWithBase64EncodedString_options(
            this: Allocated<Self>,
            base64_string: &NSString,
            options: NSDataBase64DecodingOptions,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithBase64EncodedData:options:))]
        #[unsafe(method_family = init)]
        pub fn initWithBase64EncodedData_options(
            this: Allocated<Self>,
            base64_data: &NSData,
            options: NSDataBase64DecodingOptions,
        ) -> Option<Retained<Self>>;
    );
}

/// An algorithm that indicates how to compress or decompress data.
///
/// ## Overview
///
/// Choose an algorithm that best suits the needs of your app:
///
/// - [`NSDataCompressionAlgorithmLZFSE`](https://developer.apple.com/documentation/foundation/nsdata/compressionalgorithm/lzfse) — The algorithm offers faster speed and generally achieves better compression than   [`NSDataCompressionAlgorithmZlib`](https://developer.apple.com/documentation/foundation/nsdata/compressionalgorithm/zlib). However, it is slower than [`NSDataCompressionAlgorithmLZ4`](https://developer.apple.com/documentation/foundation/nsdata/compressionalgorithm/lz4) and doesn’t compress as well as [`NSDataCompressionAlgorithmLZMA`](https://developer.apple.com/documentation/foundation/nsdata/compressionalgorithm/lzma).
///
/// - [`NSDataCompressionAlgorithmZlib`](https://developer.apple.com/documentation/foundation/nsdata/compressionalgorithm/zlib) — Use this algorithm if your app requires interoperability with non-Apple devices. For example, if you are transferering data to another device where it needs to be compressed or decompressed.
///
/// - [`NSDataCompressionAlgorithmLZ4`](https://developer.apple.com/documentation/foundation/nsdata/compressionalgorithm/lz4) — Use this algorithm if speed is critical, and you’re willing to sacrifice compression ratio to achieve it.
///
/// - [`NSDataCompressionAlgorithmLZMA`](https://developer.apple.com/documentation/foundation/nsdata/compressionalgorithm/lzma) — Use this algorithm if compression ratio is critical, and you’re willing to sacrifice speed to achieve it. It is an order of magnitude slower for both compression and decompression than other choices.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSDataCompressionAlgorithm(pub NSInteger);
impl NSDataCompressionAlgorithm {
    /// The LZFSE compression algorithm, recommended for use on Apple platforms.
    #[doc(alias = "NSDataCompressionAlgorithmLZFSE")]
    pub const LZFSE: Self = Self(0);
    /// The LZ4 compression algorithm, recommended for fast compression.
    #[doc(alias = "NSDataCompressionAlgorithmLZ4")]
    pub const LZ4: Self = Self(1);
    /// The LZMA compression algorithm, recommended for high-compression ratio.
    #[doc(alias = "NSDataCompressionAlgorithmLZMA")]
    pub const LZMA: Self = Self(2);
    /// The zlib compression algorithm, recommended for cross-platform compression.
    #[doc(alias = "NSDataCompressionAlgorithmZlib")]
    pub const Zlib: Self = Self(3);
}

unsafe impl Encode for NSDataCompressionAlgorithm {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSDataCompressionAlgorithm {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// NSDataCompression.
impl NSData {
    extern_methods!(
        #[cfg(feature = "NSError")]
        #[unsafe(method(decompressedDataUsingAlgorithm:error:_))]
        #[unsafe(method_family = none)]
        pub fn decompressedDataUsingAlgorithm_error(
            &self,
            algorithm: NSDataCompressionAlgorithm,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(compressedDataUsingAlgorithm:error:_))]
        #[unsafe(method_family = none)]
        pub fn compressedDataUsingAlgorithm_error(
            &self,
            algorithm: NSDataCompressionAlgorithm,
        ) -> Result<Retained<Self>, Retained<NSError>>;
    );
}

/// NSDeprecated.
impl NSData {
    extern_methods!(
        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[deprecated = "This method is unsafe because it could potentially cause buffer overruns. Use -getBytes:length: instead."]
        #[unsafe(method(getBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getBytes(&self, buffer: NonNull<c_void>);

        #[cfg(feature = "NSString")]
        #[deprecated = "Use +dataWithContentsOfURL:options:error: and NSDataReadingMappedIfSafe or NSDataReadingMappedAlways instead."]
        #[unsafe(method(dataWithContentsOfMappedFile:))]
        #[unsafe(method_family = none)]
        pub fn dataWithContentsOfMappedFile(path: &NSString) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -initWithContentsOfURL:options:error: and NSDataReadingMappedIfSafe or NSDataReadingMappedAlways instead."]
        #[unsafe(method(initWithContentsOfMappedFile:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfMappedFile(
            this: Allocated<Self>,
            path: &NSString,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use initWithBase64EncodedString:options: instead"]
        #[unsafe(method(initWithBase64Encoding:))]
        #[unsafe(method_family = init)]
        pub fn initWithBase64Encoding(
            this: Allocated<Self>,
            base64_string: &NSString,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use base64EncodedStringWithOptions: instead"]
        #[unsafe(method(base64Encoding))]
        #[unsafe(method_family = none)]
        pub fn base64Encoding(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSData`.
///
/// NSDeprecated.
impl NSMutableData {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[deprecated = "Use -initWithContentsOfURL:options:error: and NSDataReadingMappedIfSafe or NSDataReadingMappedAlways instead."]
        #[unsafe(method(initWithContentsOfMappedFile:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfMappedFile(
            this: Allocated<Self>,
            path: &NSString,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use initWithBase64EncodedString:options: instead"]
        #[unsafe(method(initWithBase64Encoding:))]
        #[unsafe(method_family = init)]
        pub fn initWithBase64Encoding(
            this: Allocated<Self>,
            base64_string: &NSString,
        ) -> Option<Retained<Self>>;
    );
}

extern_class!(
    /// An object representing a dynamic byte buffer in memory.
    ///
    /// ## Overview
    ///
    /// In Swift, this object bridges to [`Data`](https://developer.apple.com/documentation/foundation/data); use [`NSMutableData`](https://developer.apple.com/documentation/foundation/nsmutabledata) when you need reference semantics or other Foundation-specific behavior.
    ///
    /// `NSMutableData` and its superclass `NSData` provide data objects, or object-oriented wrappers for byte buffers. Data objects let simple allocated buffers (that is, data with no embedded pointers) take on the behavior of Foundation objects. They are typically used for data storage and are also useful in Distributed Objects applications, where data contained in data objects can be copied or moved between applications. `NSData` creates static data objects, and `NSMutableData` creates dynamic data objects. You can easily convert one type of data object to the other with the initializer that takes an `NSData` object or an  `NSMutableData` object as an argument.
    ///
    /// The following [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) methods change when used on a mutable data object:
    ///
    /// - [`initWithBytesNoCopy:length:freeWhenDone:`](https://developer.apple.com/documentation/foundation/nsdata/init(bytesnocopy:length:freewhendone:))
    ///
    /// - [`initWithBytesNoCopy:length:deallocator:`](https://developer.apple.com/documentation/foundation/nsdata/init(bytesnocopy:length:deallocator:))
    ///
    /// - [`initWithBytesNoCopy:length:`](https://developer.apple.com/documentation/foundation/nsdata/init(bytesnocopy:length:))
    ///
    /// - [`dataWithBytesNoCopy:length:freeWhenDone:`](https://developer.apple.com/documentation/foundation/nsdata/datawithbytesnocopy:length:freewhendone:)
    ///
    /// - [`dataWithBytesNoCopy:length:`](https://developer.apple.com/documentation/foundation/nsdata/datawithbytesnocopy:length:)
    ///
    /// When called, the bytes are immediately copied and then the buffer is freed.
    ///
    /// `NSMutableData` is “toll-free bridged” with its Core Foundation counterpart, [`CFDataRef`](https://developer.apple.com/documentation/corefoundation/cfdata). See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information on toll-free bridging.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The Swift overlay to the Foundation framework provides the [`Data`](https://developer.apple.com/documentation/foundation/data) structure, which bridges to the [`NSMutableData`](https://developer.apple.com/documentation/foundation/nsmutabledata) class and its immutable superclass [`NSData`](https://developer.apple.com/documentation/foundation/nsdata). For more information about value types, see [Working with Cocoa Frameworks](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6) in [Using Swift with Cocoa and Objective-C (Swift 4.1)](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216).
    ///
    ///
    ///
    /// </div>
    ///
    /// **************    Mutable Data        ***************
    #[unsafe(super(NSData, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMutableData;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSMutableData> for CFMutableData {
    #[inline]
    fn as_ref(&self) -> &NSMutableData {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFMutableData> for NSMutableData {
    #[inline]
    fn as_ref(&self) -> &CFMutableData {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSMutableData {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSMutableData {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSMutableData {
    type Result = NSData;
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSMutableCopying for NSMutableData {}
);

#[cfg(feature = "NSObject")]
unsafe impl MutableCopyingHelper for NSMutableData {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSMutableData {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSMutableData {}
);

impl NSMutableData {
    extern_methods!(
        /// Setter for [`length`][Self::length].
        #[unsafe(method(setLength:))]
        #[unsafe(method_family = none)]
        pub fn setLength(&self, length: NSUInteger);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSMutableData {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSMutableData {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSExtendedMutableData.
impl NSMutableData {
    extern_methods!(
        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(appendBytes:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn appendBytes_length(&self, bytes: NonNull<c_void>, length: NSUInteger);

        #[unsafe(method(appendData:))]
        #[unsafe(method_family = none)]
        pub fn appendData(&self, other: &NSData);

        #[unsafe(method(increaseLengthBy:))]
        #[unsafe(method_family = none)]
        pub fn increaseLengthBy(&self, extra_length: NSUInteger);

        #[cfg(feature = "NSRange")]
        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(replaceBytesInRange:withBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn replaceBytesInRange_withBytes(&self, range: NSRange, bytes: NonNull<c_void>);

        #[cfg(feature = "NSRange")]
        #[unsafe(method(resetBytesInRange:))]
        #[unsafe(method_family = none)]
        pub fn resetBytesInRange(&self, range: NSRange);

        #[unsafe(method(setData:))]
        #[unsafe(method_family = none)]
        pub fn setData(&self, data: &NSData);

        #[cfg(feature = "NSRange")]
        /// # Safety
        ///
        /// `replacement_bytes` must be a valid pointer or null.
        #[unsafe(method(replaceBytesInRange:withBytes:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn replaceBytesInRange_withBytes_length(
            &self,
            range: NSRange,
            replacement_bytes: *const c_void,
            replacement_length: NSUInteger,
        );
    );
}

/// NSMutableDataCreation.
impl NSMutableData {
    extern_methods!(
        #[unsafe(method(dataWithCapacity:))]
        #[unsafe(method_family = none)]
        pub fn dataWithCapacity(a_num_items: NSUInteger) -> Option<Retained<Self>>;

        #[unsafe(method(dataWithLength:))]
        #[unsafe(method_family = none)]
        pub fn dataWithLength(length: NSUInteger) -> Option<Retained<Self>>;

        #[unsafe(method(initWithCapacity:))]
        #[unsafe(method_family = init)]
        pub fn initWithCapacity(
            this: Allocated<Self>,
            capacity: NSUInteger,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithLength:))]
        #[unsafe(method_family = init)]
        pub fn initWithLength(this: Allocated<Self>, length: NSUInteger) -> Option<Retained<Self>>;
    );
}

/// NSMutableDataCompression.
impl NSMutableData {
    extern_methods!(
        #[cfg(feature = "NSError")]
        #[unsafe(method(decompressUsingAlgorithm:error:_))]
        #[unsafe(method_family = none)]
        pub fn decompressUsingAlgorithm_error(
            &self,
            algorithm: NSDataCompressionAlgorithm,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(compressUsingAlgorithm:error:_))]
        #[unsafe(method_family = none)]
        pub fn compressUsingAlgorithm_error(
            &self,
            algorithm: NSDataCompressionAlgorithm,
        ) -> Result<(), Retained<NSError>>;
    );
}

extern_class!(
    /// A mutable data object containing bytes that can be discarded when they’re no longer needed.
    ///
    /// ## Overview
    ///
    /// [`NSPurgeableData`](https://developer.apple.com/documentation/foundation/nspurgeabledata) objects inherit their creation methods from their superclass, [`NSMutableData`](https://developer.apple.com/documentation/foundation/nsmutabledata) while providing a default implementation of the [`NSDiscardableContent`](https://developer.apple.com/documentation/foundation/nsdiscardablecontent) protocol.
    ///
    /// All [`NSPurgeableData`](https://developer.apple.com/documentation/foundation/nspurgeabledata) objects begin “accessed” to ensure that they are not instantly discarded. The [`beginContentAccess`](https://developer.apple.com/documentation/foundation/nsdiscardablecontent/begincontentaccess()) method marks the object’s bytes as “accessed,” thus protecting them from being discarded, and must be called before accessing the object, or else an exception will be raised. This method returns [`true`](https://developer.apple.com/documentation/swift/true) if the bytes have not been discarded and if they have been successfully marked as “accessed”. Any method that directly or indirectly accesses these bytes or their length when they are not “accessed” will raise an exception. When you are done with the data, call [`endContentAccess`](https://developer.apple.com/documentation/foundation/nsdiscardablecontent/endcontentaccess()) to allow them to be discarded in order to quickly free up memory.
    ///
    /// You may use these objects by themselves, and do not necessarily have to use them in conjunction with [`NSCache`](https://developer.apple.com/documentation/foundation/nscache) to get the purging behavior. The [`NSCache`](https://developer.apple.com/documentation/foundation/nscache) class incorporates a caching mechanism with some auto-removal policies to ensure that its memory footprint does not get too large.
    ///
    /// [`NSPurgeableData`](https://developer.apple.com/documentation/foundation/nspurgeabledata) objects should not be used as keys in hashing-based collections, because the value of the bytes pointer can change after every mutation of the data.
    ///
    ///
    /// **************        Purgeable Data    ***************
    #[unsafe(super(NSMutableData, NSData, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSPurgeableData;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSPurgeableData {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSDiscardableContent for NSPurgeableData {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSPurgeableData {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSPurgeableData {}
);

impl NSPurgeableData {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NSPurgeableData {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSPurgeableData {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
