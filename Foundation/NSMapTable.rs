//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Equivalent to [`NSPointerFunctionsStrongMemory`](https://developer.apple.com/documentation/foundation/nspointerfunctions/options/strongmemory).
/// **************    Class    ***************
#[cfg(feature = "NSPointerFunctions")]
pub static NSMapTableStrongMemory: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::StrongMemory.0);

/// Equivalent to [`NSPointerFunctionsZeroingWeakMemory`](https://developer.apple.com/documentation/foundation/nspointerfunctionsoptions/nspointerfunctionszeroingweakmemory).
#[cfg(feature = "NSPointerFunctions")]
#[deprecated = "GC no longer supported"]
pub static NSMapTableZeroingWeakMemory: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::ZeroingWeakMemory.0);

/// Equivalent to [`NSPointerFunctionsCopyIn`](https://developer.apple.com/documentation/foundation/nspointerfunctions/options/copyin).
#[cfg(feature = "NSPointerFunctions")]
pub static NSMapTableCopyIn: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::CopyIn.0);

/// Equivalent to [`NSPointerFunctionsObjectPointerPersonality`](https://developer.apple.com/documentation/foundation/nspointerfunctions/options/objectpointerpersonality).
#[cfg(feature = "NSPointerFunctions")]
pub static NSMapTableObjectPointerPersonality: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::ObjectPointerPersonality.0);

/// Equivalent to [`NSPointerFunctionsWeakMemory`](https://developer.apple.com/documentation/foundation/nspointerfunctions/options/weakmemory).
#[cfg(feature = "NSPointerFunctions")]
pub static NSMapTableWeakMemory: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::WeakMemory.0);

/// Constants used as components in a bitfield to specify the behavior of elements (keys and values) in an `NSMapTable` object.
pub type NSMapTableOptions = NSUInteger;

extern_class!(
    /// A collection similar to a dictionary, but with a broader range of available memory semantics.
    ///
    /// ## Overview
    ///
    /// The map table is modeled after [`NSDictionary`](https://developer.apple.com/documentation/foundation/nsdictionary) with the following differences:
    ///
    /// - Keys and/or values are optionally held “weakly” such that entries are removed when one of the objects is reclaimed.
    ///
    /// - Its keys or values may be copied on input or may use pointer identity for equality and hashing.
    ///
    /// - It can contain arbitrary pointers (its contents are not constrained to being objects).
    ///
    /// You can configure an [`NSMapTable`](https://developer.apple.com/documentation/foundation/nsmaptable) instance to operate on arbitrary pointers and not just objects, although typically you are encouraged to use the C function API for void * pointers. The object-based API (such as [`setObject:forKey:`](https://developer.apple.com/documentation/foundation/nsmaptable/setobject(_:forkey:))) will not work for non-object pointers without type-casting.
    ///
    /// When configuring map tables, note that only the options listed in [`NSMapTableOptions`](https://developer.apple.com/documentation/foundation/nsmaptableoptions) guarantee that the rest of the API will work correctly—including copying, archiving, and fast enumeration. While other [`NSPointerFunctions`](https://developer.apple.com/documentation/foundation/nspointerfunctions) options are used for certain configurations, such as to hold arbitrary pointers, not all combinations of the options are valid. With some combinations the map table may not work correctly, or may not even be initialized correctly.
    ///
    /// ### Subclassing Notes
    ///
    /// `NSMapTable` is not suitable for subclassing.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMapTable<KeyType: ?Sized = AnyObject, ObjectType: ?Sized = AnyObject>;
);

impl<KeyType: ?Sized + Message, ObjectType: ?Sized + Message> NSMapTable<KeyType, ObjectType> {
    /// Unchecked conversion of the generic parameters.
    ///
    /// # Safety
    ///
    /// The generics must be valid to reinterpret as the given types.
    #[inline]
    pub unsafe fn cast_unchecked<NewKeyType: ?Sized + Message, NewObjectType: ?Sized + Message>(
        &self,
    ) -> &NSMapTable<NewKeyType, NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<KeyType: ?Sized + NSCoding, ObjectType: ?Sized + NSCoding> NSCoding
        for NSMapTable<KeyType, ObjectType>
    {
    }
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<KeyType: ?Sized, ObjectType: ?Sized> NSCopying for NSMapTable<KeyType, ObjectType> {}
);

#[cfg(feature = "NSObject")]
unsafe impl<KeyType: ?Sized + Message, ObjectType: ?Sized + Message> CopyingHelper
    for NSMapTable<KeyType, ObjectType>
{
    type Result = Self;
}

#[cfg(feature = "NSEnumerator")]
extern_conformance!(
    unsafe impl<KeyType: ?Sized, ObjectType: ?Sized> NSFastEnumeration
        for NSMapTable<KeyType, ObjectType>
    {
    }
);

extern_conformance!(
    unsafe impl<KeyType: ?Sized, ObjectType: ?Sized> NSObjectProtocol
        for NSMapTable<KeyType, ObjectType>
    {
    }
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<KeyType: ?Sized + NSSecureCoding, ObjectType: ?Sized + NSSecureCoding>
        NSSecureCoding for NSMapTable<KeyType, ObjectType>
    {
    }
);

impl<KeyType: Message, ObjectType: Message> NSMapTable<KeyType, ObjectType> {
    extern_methods!(
        #[cfg(feature = "NSPointerFunctions")]
        #[unsafe(method(initWithKeyOptions:valueOptions:capacity:))]
        #[unsafe(method_family = init)]
        pub fn initWithKeyOptions_valueOptions_capacity(
            this: Allocated<Self>,
            key_options: NSPointerFunctionsOptions,
            value_options: NSPointerFunctionsOptions,
            initial_capacity: NSUInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "NSPointerFunctions")]
        #[unsafe(method(initWithKeyPointerFunctions:valuePointerFunctions:capacity:))]
        #[unsafe(method_family = init)]
        pub fn initWithKeyPointerFunctions_valuePointerFunctions_capacity(
            this: Allocated<Self>,
            key_functions: &NSPointerFunctions,
            value_functions: &NSPointerFunctions,
            initial_capacity: NSUInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "NSPointerFunctions")]
        #[unsafe(method(mapTableWithKeyOptions:valueOptions:))]
        #[unsafe(method_family = none)]
        pub fn mapTableWithKeyOptions_valueOptions(
            key_options: NSPointerFunctionsOptions,
            value_options: NSPointerFunctionsOptions,
        ) -> Retained<NSMapTable<KeyType, ObjectType>>;

        #[deprecated = "GC no longer supported"]
        #[unsafe(method(mapTableWithStrongToStrongObjects))]
        #[unsafe(method_family = none)]
        pub fn mapTableWithStrongToStrongObjects() -> Retained<AnyObject>;

        #[deprecated = "GC no longer supported"]
        #[unsafe(method(mapTableWithWeakToStrongObjects))]
        #[unsafe(method_family = none)]
        pub fn mapTableWithWeakToStrongObjects() -> Retained<AnyObject>;

        #[deprecated = "GC no longer supported"]
        #[unsafe(method(mapTableWithStrongToWeakObjects))]
        #[unsafe(method_family = none)]
        pub fn mapTableWithStrongToWeakObjects() -> Retained<AnyObject>;

        #[deprecated = "GC no longer supported"]
        #[unsafe(method(mapTableWithWeakToWeakObjects))]
        #[unsafe(method_family = none)]
        pub fn mapTableWithWeakToWeakObjects() -> Retained<AnyObject>;

        #[unsafe(method(strongToStrongObjectsMapTable))]
        #[unsafe(method_family = none)]
        pub fn strongToStrongObjectsMapTable() -> Retained<NSMapTable<KeyType, ObjectType>>;

        #[unsafe(method(weakToStrongObjectsMapTable))]
        #[unsafe(method_family = none)]
        pub fn weakToStrongObjectsMapTable() -> Retained<NSMapTable<KeyType, ObjectType>>;

        #[unsafe(method(strongToWeakObjectsMapTable))]
        #[unsafe(method_family = none)]
        pub fn strongToWeakObjectsMapTable() -> Retained<NSMapTable<KeyType, ObjectType>>;

        #[unsafe(method(weakToWeakObjectsMapTable))]
        #[unsafe(method_family = none)]
        pub fn weakToWeakObjectsMapTable() -> Retained<NSMapTable<KeyType, ObjectType>>;

        #[cfg(feature = "NSPointerFunctions")]
        #[unsafe(method(keyPointerFunctions))]
        #[unsafe(method_family = none)]
        pub fn keyPointerFunctions(&self) -> Retained<NSPointerFunctions>;

        #[cfg(feature = "NSPointerFunctions")]
        #[unsafe(method(valuePointerFunctions))]
        #[unsafe(method_family = none)]
        pub fn valuePointerFunctions(&self) -> Retained<NSPointerFunctions>;

        #[unsafe(method(objectForKey:))]
        #[unsafe(method_family = none)]
        pub fn objectForKey(&self, a_key: Option<&KeyType>) -> Option<Retained<ObjectType>>;

        #[unsafe(method(removeObjectForKey:))]
        #[unsafe(method_family = none)]
        pub fn removeObjectForKey(&self, a_key: Option<&KeyType>);

        #[unsafe(method(setObject:forKey:))]
        #[unsafe(method_family = none)]
        pub fn setObject_forKey(&self, an_object: Option<&ObjectType>, a_key: Option<&KeyType>);

        #[unsafe(method(count))]
        #[unsafe(method_family = none)]
        pub fn count(&self) -> NSUInteger;

        #[cfg(feature = "NSEnumerator")]
        /// # Safety
        ///
        /// The returned enumerator's underlying collection should not be mutated while in use.
        #[unsafe(method(keyEnumerator))]
        #[unsafe(method_family = none)]
        pub unsafe fn keyEnumerator(&self) -> Retained<NSEnumerator<KeyType>>;

        #[cfg(feature = "NSEnumerator")]
        /// # Safety
        ///
        /// The returned enumerator's underlying collection should not be mutated while in use.
        #[unsafe(method(objectEnumerator))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectEnumerator(&self) -> Option<Retained<NSEnumerator<ObjectType>>>;

        #[unsafe(method(removeAllObjects))]
        #[unsafe(method_family = none)]
        pub fn removeAllObjects(&self);

        #[cfg(feature = "NSDictionary")]
        #[unsafe(method(dictionaryRepresentation))]
        #[unsafe(method_family = none)]
        pub fn dictionaryRepresentation(&self) -> Retained<NSDictionary<KeyType, ObjectType>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl<KeyType: Message, ObjectType: Message> NSMapTable<KeyType, ObjectType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<KeyType: Message, ObjectType: Message> DefaultRetained for NSMapTable<KeyType, ObjectType> {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// Allows successive elements of a map table to be returned each time this structure is passed to [`NSNextMapEnumeratorPair`](https://developer.apple.com/documentation/foundation/nsnextmapenumeratorpair(_:_:_:)).
///
/// ## Overview
///
/// The fields of `NSMapEnumerator` are private.
///
///
/// **************    void * Map table operations    ***************
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NSMapEnumerator {
    pub(crate) _pi: NSUInteger,
    pub(crate) _si: NSUInteger,
    pub(crate) _bs: *mut c_void,
}

unsafe impl Encode for NSMapEnumerator {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <NSUInteger>::ENCODING,
            <NSUInteger>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for NSMapEnumerator {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Deletes the elements of the specified map table.
    ///
    /// Parameters:
    /// - table: A reference to a map table structure.
    ///
    ///
    /// ## Discussion
    ///
    /// Releases each key and value but doesn’t deallocate `table`. This method is useful for preserving the capacity of `table`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `table` generic should be of the correct type.
    pub fn NSResetMapTable(table: &NSMapTable);
}

/// Compares the elements of two map tables for equality.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the keys and corresponding values of `table1` and `table2` are the same, and the two tables are the same size, otherwise [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// # Safety
///
/// - `table1` generic should be of the correct type.
/// - `table2` generic should be of the correct type.
#[inline]
pub unsafe extern "C-unwind" fn NSCompareMapTables(
    table1: &NSMapTable,
    table2: &NSMapTable,
) -> bool {
    extern "C-unwind" {
        fn NSCompareMapTables(table1: &NSMapTable, table2: &NSMapTable) -> Bool;
    }
    unsafe { NSCompareMapTables(table1, table2) }.as_bool()
}

/// Performs a shallow copy of the specified map table.
///
/// ## Return Value
///
/// A pointer to a new copy of `table`, created in `zone` and containing pointers to the keys and values of `table`.
///
///
///
/// ## Discussion
///
/// If `zone` is `NULL`, the new table is created in the default zone.
///
/// The new table adopts the callback functions of `table` and calls the `hash` and `retain` callback functions as appropriate when inserting elements into the new table.
///
///
///
/// # Safety
///
/// - `table` generic should be of the correct type.
/// - `zone` must be a valid pointer or null.
#[cfg(feature = "NSZone")]
#[inline]
pub unsafe extern "C-unwind" fn NSCopyMapTableWithZone(
    table: &NSMapTable,
    zone: *mut NSZone,
) -> Retained<NSMapTable> {
    extern "C-unwind" {
        fn NSCopyMapTableWithZone(table: &NSMapTable, zone: *mut NSZone) -> *mut NSMapTable;
    }
    let ret = unsafe { NSCopyMapTableWithZone(table, zone) };
    unsafe { Retained::from_raw(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

/// Indicates whether a given table contains a given key.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if `table` contains a key equal to `key`, otherwise [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// ## Discussion
///
/// If `table` contains a key equal to `key`, `originalKey` is set to `key`, and `value` is set to the value that `table` maps to `key`.
///
///
///
/// # Safety
///
/// - `table` generic should be of the correct type.
/// - `key` must be a valid pointer.
/// - `original_key` must be a valid pointer or null.
/// - `value` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn NSMapMember(
    table: &NSMapTable,
    key: NonNull<c_void>,
    original_key: *mut *mut c_void,
    value: *mut *mut c_void,
) -> bool {
    extern "C-unwind" {
        fn NSMapMember(
            table: &NSMapTable,
            key: NonNull<c_void>,
            original_key: *mut *mut c_void,
            value: *mut *mut c_void,
        ) -> Bool;
    }
    unsafe { NSMapMember(table, key, original_key, value) }.as_bool()
}

extern "C-unwind" {
    /// Returns a map table value for the specified key.
    ///
    /// ## Return Value
    ///
    /// The value that `table` maps to `key`, or `NULL` if `table` doesn’t contain `key`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `table` generic should be of the correct type.
    /// - `key` must be a valid pointer or null.
    pub fn NSMapGet(table: &NSMapTable, key: *const c_void) -> *mut c_void;
}

extern "C-unwind" {
    /// Inserts a key-value pair into the specified table.
    ///
    /// ## Discussion
    ///
    /// Inserts `key` and `value` into `table`. If `key` matches a key already in `table`, `value` is retained and the previous value is released, using the `retain` and `release` callback functions that were specified when the table was created. Raises `NSInvalidArgumentException` if `key` is equal to the `notAKeyMarker` field of the table’s [`NSMapTableKeyCallBacks`](https://developer.apple.com/documentation/foundation/nsmaptablekeycallbacks) structure.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `table` generic should be of the correct type.
    /// - `key` must be a valid pointer or null.
    /// - `value` must be a valid pointer or null.
    pub fn NSMapInsert(table: &NSMapTable, key: *const c_void, value: *const c_void);
}

extern "C-unwind" {
    /// Inserts a key-value pair into the specified table if the pair had not been previously added.
    ///
    /// ## Discussion
    ///
    /// Inserts `key` (which must not be `notAKeyMarker`) and `value` into `table`. Unlike `NSMapInsert`, this function raises `NSInvalidArgumentException` if `table` already includes a key that matches `key`.
    ///
    /// `key` is compared with `notAKeyMarker` using pointer comparison; if `key` is identical to `notAKeyMarker`, raises `NSInvalidArgumentException`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `table` generic should be of the correct type.
    /// - `key` must be a valid pointer or null.
    /// - `value` must be a valid pointer or null.
    pub fn NSMapInsertKnownAbsent(table: &NSMapTable, key: *const c_void, value: *const c_void);
}

extern "C-unwind" {
    /// Inserts a key-value pair into the specified table.
    ///
    /// ## Return Value
    ///
    /// If `key` matches a key already in `table`, the preexisting value; otherwise, `key` and `value` are added to `table` and returns `NULL`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Raises `NSInvalidArgumentException` if `key` is equal to the `notAKeyMarker` field of the table’s `NSMapTableKeyCallBacks` structure.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `table` generic should be of the correct type.
    /// - `key` must be a valid pointer or null.
    /// - `value` must be a valid pointer or null.
    pub fn NSMapInsertIfAbsent(
        table: &NSMapTable,
        key: *const c_void,
        value: *const c_void,
    ) -> *mut c_void;
}

extern "C-unwind" {
    /// Removes a key and corresponding value from the specified table.
    ///
    /// ## Discussion
    ///
    /// If `key` matches a key already in `table`, this function releases the preexisting key and its corresponding value.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `table` generic should be of the correct type.
    /// - `key` must be a valid pointer or null.
    pub fn NSMapRemove(table: &NSMapTable, key: *const c_void);
}

extern "C-unwind" {
    /// Creates an enumerator for the specified map table.
    ///
    /// Parameters:
    /// - table: A reference to a map table structure.
    ///
    ///
    /// ## Return Value
    ///
    /// An `NSMapEnumerator` structure that will cause successive key-value pairs of `table` to be visited each time this enumerator is passed to `NSNextMapEnumeratorPair`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `table` generic should be of the correct type.
    pub fn NSEnumerateMapTable(table: &NSMapTable) -> NSMapEnumerator;
}

/// Returns a Boolean value that indicates whether the next map-table pair in the enumeration are set.
///
/// ## Return Value
///
/// [`false`](https://developer.apple.com/documentation/swift/false) if `enumerator` has already iterated over all the elements in the table that `enumerator` is associated with; otherwise, sets `key` and `value` to match the next key-value pair in the table and returns [`true`](https://developer.apple.com/documentation/swift/true).
///
///
///
/// # Safety
///
/// - `enumerator` must be a valid pointer.
/// - `key` must be a valid pointer or null.
/// - `value` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn NSNextMapEnumeratorPair(
    enumerator: NonNull<NSMapEnumerator>,
    key: *mut *mut c_void,
    value: *mut *mut c_void,
) -> bool {
    extern "C-unwind" {
        fn NSNextMapEnumeratorPair(
            enumerator: NonNull<NSMapEnumerator>,
            key: *mut *mut c_void,
            value: *mut *mut c_void,
        ) -> Bool;
    }
    unsafe { NSNextMapEnumeratorPair(enumerator, key, value) }.as_bool()
}

extern "C-unwind" {
    /// Used when finished with an enumerator.
    ///
    /// ## Discussion
    ///
    /// This function should be called when you have finished using the enumeration struct `enumerator`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    pub fn NSEndMapTableEnumeration(enumerator: NonNull<NSMapEnumerator>);
}

extern "C-unwind" {
    /// Returns the number of elements in a map table.
    ///
    /// Parameters:
    /// - table: A reference to a map table structure.
    ///
    ///
    /// ## Return Value
    ///
    /// The number of key-value pairs currently in `table`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `table` generic should be of the correct type.
    pub fn NSCountMapTable(table: &NSMapTable) -> NSUInteger;
}

#[cfg(feature = "NSString")]
impl NSString {
    /// Returns a string describing the map table’s contents.
    ///
    /// Parameters:
    /// - table: A reference to a map table structure.
    ///
    ///
    /// ## Return Value
    ///
    /// A string describing the map table’s contents.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The function iterates over the key-value pairs of `table` and for each one appends the string “a = b;\n”, where a and b are the key and value strings returned by the corresponding `describe` callback functions. If `NULL` was specified for the callback function, a and b are the key and value pointers, expressed as hexadecimal numbers.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `table` generic should be of the correct type.
    #[doc(alias = "NSStringFromMapTable")]
    #[cfg(feature = "NSString")]
    #[inline]
    pub unsafe fn from_map_table(table: &NSMapTable) -> Retained<NSString> {
        extern "C-unwind" {
            fn NSStringFromMapTable(table: &NSMapTable) -> *mut NSString;
        }
        let ret = unsafe { NSStringFromMapTable(table) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// Returns all of the keys in the specified map table.
///
/// ## Return Value
///
/// An array object containing all the keys in `table`. This function should be called only when `table` keys are objects, not when they’re any other type of pointer.
///
///
///
/// # Safety
///
/// `table` generic should be of the correct type.
#[cfg(feature = "NSArray")]
#[inline]
pub unsafe extern "C-unwind" fn NSAllMapTableKeys(table: &NSMapTable) -> Retained<NSArray> {
    extern "C-unwind" {
        fn NSAllMapTableKeys(table: &NSMapTable) -> *mut NSArray;
    }
    let ret = unsafe { NSAllMapTableKeys(table) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

/// Returns all of the values in the specified table.
///
/// ## Return Value
///
/// An array object containing all the values in `table`. This function should be called only when `table` values are objects, not when they’re any other type of pointer.
///
///
///
/// # Safety
///
/// `table` generic should be of the correct type.
#[cfg(feature = "NSArray")]
#[inline]
pub unsafe extern "C-unwind" fn NSAllMapTableValues(table: &NSMapTable) -> Retained<NSArray> {
    extern "C-unwind" {
        fn NSAllMapTableValues(table: &NSMapTable) -> *mut NSArray;
    }
    let ret = unsafe { NSAllMapTableValues(table) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

/// The function pointers used to configure behavior of `NSMapTable` with respect to key elements within a map table.
///
/// ## Overview
///
/// All functions must know the types of things in the map table to be able to operate on them. Sets of predefined call backs are described in [`NSMapTable`](https://developer.apple.com/documentation/foundation/nsmaptable).
///
/// Two predefined values to use for `notAKeyMarker` are [`NSNotAnIntMapKey`](https://developer.apple.com/documentation/foundation/nsnotanintmapkey) and [`NSNotAPointerMapKey`](https://developer.apple.com/documentation/foundation/nsnotapointermapkey).
///
///
/// **************     Legacy     **************************************
#[cfg(feature = "NSString")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NSMapTableKeyCallBacks {
    pub hash:
        Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>) -> NSUInteger>,
    pub isEqual: Option<
        unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>, NonNull<c_void>) -> Bool,
    >,
    pub retain: Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>)>,
    pub release: Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>)>,
    pub describe:
        Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>) -> *mut NSString>,
    pub notAKeyMarker: *const c_void,
}

#[cfg(feature = "NSString")]
unsafe impl Encode for NSMapTableKeyCallBacks {
    const ENCODING: Encoding = Encoding::Struct("?", &[
        <Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>,NonNull<c_void>,) -> NSUInteger>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>,NonNull<c_void>,NonNull<c_void>,) -> Bool>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>,NonNull<c_void>,)>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>,NonNull<c_void>,)>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>,NonNull<c_void>,) -> *mut NSString>>::ENCODING,
        <*const c_void>::ENCODING,
    ]);
}

#[cfg(feature = "NSString")]
unsafe impl RefEncode for NSMapTableKeyCallBacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The function pointers used to configure behavior of `NSMapTable` with respect to value elements within a map table.
///
/// ## Overview
///
/// All functions must know the types of things in the map table to be able to operate on them. Sets of predefined call backs are described in [`NSMapTable`](https://developer.apple.com/documentation/foundation/nsmaptable).
///
///
#[cfg(feature = "NSString")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct NSMapTableValueCallBacks {
    pub retain: Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>)>,
    pub release: Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>)>,
    pub describe:
        Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>) -> *mut NSString>,
}

#[cfg(feature = "NSString")]
unsafe impl Encode for NSMapTableValueCallBacks {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>)>>::ENCODING,
            <Option<
                unsafe extern "C-unwind" fn(NonNull<NSMapTable>, NonNull<c_void>) -> *mut NSString,
            >>::ENCODING,
        ],
    );
}

#[cfg(feature = "NSString")]
unsafe impl RefEncode for NSMapTableValueCallBacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Creates a new map table in the specified zone.
///
/// ## Return Value
///
/// A new map table in allocated in `zone`. If `zone` is `NULL`, the hash table is created in the default zone.
///
///
///
/// ## Discussion
///
/// The table’s size is dependent on (but generally not equal to) `capacity`. If `capacity` is 0, a small map table is created. The [`NSMapTableKeyCallBacks`](https://developer.apple.com/documentation/foundation/nsmaptablekeycallbacks) arguments are structures that are very similar to the callback structure used by [`NSCreateHashTable`](https://developer.apple.com/documentation/foundation/nscreatehashtable(_:_:)); in fact, they have the same defaults as documented for that function.
///
///
///
/// # Safety
///
/// - `key_call_backs` struct field 1 must be implemented correctly.
/// - `key_call_backs` struct field 2 must be implemented correctly.
/// - `key_call_backs` struct field 3 must be implemented correctly.
/// - `key_call_backs` struct field 4 must be implemented correctly.
/// - `key_call_backs` struct field 5 must be implemented correctly.
/// - `key_call_backs` struct field 6 must be a valid pointer or null.
/// - `value_call_backs` struct field 1 must be implemented correctly.
/// - `value_call_backs` struct field 2 must be implemented correctly.
/// - `value_call_backs` struct field 3 must be implemented correctly.
/// - `zone` must be a valid pointer or null.
#[cfg(all(feature = "NSString", feature = "NSZone"))]
#[inline]
pub unsafe extern "C-unwind" fn NSCreateMapTableWithZone(
    key_call_backs: NSMapTableKeyCallBacks,
    value_call_backs: NSMapTableValueCallBacks,
    capacity: NSUInteger,
    zone: *mut NSZone,
) -> Retained<NSMapTable> {
    extern "C-unwind" {
        fn NSCreateMapTableWithZone(
            key_call_backs: NSMapTableKeyCallBacks,
            value_call_backs: NSMapTableValueCallBacks,
            capacity: NSUInteger,
            zone: *mut NSZone,
        ) -> *mut NSMapTable;
    }
    let ret = unsafe { NSCreateMapTableWithZone(key_call_backs, value_call_backs, capacity, zone) };
    unsafe { Retained::from_raw(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

/// Creates a new map table in the default zone.
///
/// ## Discussion
///
/// Creates and returns a pointer to an `NSMapTable` structure in the default zone; the table’s size is dependent on (but generally not equal to) `capacity`. If `capacity` is 0, a small map table is created. The [`NSMapTableKeyCallBacks`](https://developer.apple.com/documentation/foundation/nsmaptablekeycallbacks) arguments are structures that are very similar to the callback structure used by [`NSCreateHashTable`](https://developer.apple.com/documentation/foundation/nscreatehashtable(_:_:))—they have the same defaults as documented for that function.
///
///
///
/// # Safety
///
/// - `key_call_backs` struct field 1 must be implemented correctly.
/// - `key_call_backs` struct field 2 must be implemented correctly.
/// - `key_call_backs` struct field 3 must be implemented correctly.
/// - `key_call_backs` struct field 4 must be implemented correctly.
/// - `key_call_backs` struct field 5 must be implemented correctly.
/// - `key_call_backs` struct field 6 must be a valid pointer or null.
/// - `value_call_backs` struct field 1 must be implemented correctly.
/// - `value_call_backs` struct field 2 must be implemented correctly.
/// - `value_call_backs` struct field 3 must be implemented correctly.
#[cfg(feature = "NSString")]
#[inline]
pub unsafe extern "C-unwind" fn NSCreateMapTable(
    key_call_backs: NSMapTableKeyCallBacks,
    value_call_backs: NSMapTableValueCallBacks,
    capacity: NSUInteger,
) -> Retained<NSMapTable> {
    extern "C-unwind" {
        fn NSCreateMapTable(
            key_call_backs: NSMapTableKeyCallBacks,
            value_call_backs: NSMapTableValueCallBacks,
            capacity: NSUInteger,
        ) -> *mut NSMapTable;
    }
    let ret = unsafe { NSCreateMapTable(key_call_backs, value_call_backs, capacity) };
    unsafe { Retained::from_raw(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C" {
    /// For keys that are pointer-sized quantities or smaller (for example, `int`, `long`, or `unichar`).
    /// **************    Common map table key callbacks    ***************
    #[cfg(feature = "NSString")]
    pub static NSIntegerMapKeyCallBacks: NSMapTableKeyCallBacks;
}

extern "C" {
    /// For keys that are pointers not freed.
    #[cfg(feature = "NSString")]
    pub static NSNonOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
}

extern "C" {
    /// For keys that are pointers not freed, or `NULL`.
    #[cfg(feature = "NSString")]
    pub static NSNonOwnedPointerOrNullMapKeyCallBacks: NSMapTableKeyCallBacks;
}

extern "C" {
    /// For sets of objects, but without retaining/releasing.
    #[cfg(feature = "NSString")]
    pub static NSNonRetainedObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
}

extern "C" {
    /// For keys that are objects.
    #[cfg(feature = "NSString")]
    pub static NSObjectMapKeyCallBacks: NSMapTableKeyCallBacks;
}

extern "C" {
    /// For keys that are pointers, with transfer of ownership upon insertion.
    #[cfg(feature = "NSString")]
    pub static NSOwnedPointerMapKeyCallBacks: NSMapTableKeyCallBacks;
}

extern "C" {
    /// For keys that are pointer-sized quantities or smaller (for example, `int`, `long`, or `unichar`).
    #[cfg(feature = "NSString")]
    #[deprecated = "Not supported"]
    pub static NSIntMapKeyCallBacks: NSMapTableKeyCallBacks;
}

extern "C" {
    /// For values that are pointer-sized quantities, (for example, `int`, `long`, or `unichar`).
    /// **************    Common map table value callbacks    ***************
    #[cfg(feature = "NSString")]
    pub static NSIntegerMapValueCallBacks: NSMapTableValueCallBacks;
}

extern "C" {
    /// For values that are not owned pointers.
    #[cfg(feature = "NSString")]
    pub static NSNonOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
}

extern "C" {
    /// For values that are objects.
    #[cfg(feature = "NSString")]
    pub static NSObjectMapValueCallBacks: NSMapTableValueCallBacks;
}

extern "C" {
    /// For sets of objects, but without retaining/releasing.
    #[cfg(feature = "NSString")]
    pub static NSNonRetainedObjectMapValueCallBacks: NSMapTableValueCallBacks;
}

extern "C" {
    /// For values that are owned pointers.
    #[cfg(feature = "NSString")]
    pub static NSOwnedPointerMapValueCallBacks: NSMapTableValueCallBacks;
}

extern "C" {
    /// For values that are pointer-sized quantities, (for example, `int`, `long`, or `unichar`).
    #[cfg(feature = "NSString")]
    #[deprecated = "Not supported"]
    pub static NSIntMapValueCallBacks: NSMapTableValueCallBacks;
}

#[cfg(feature = "NSString")]
#[deprecated = "renamed to `NSString::from_map_table`"]
#[inline]
pub unsafe extern "C-unwind" fn NSStringFromMapTable(table: &NSMapTable) -> Retained<NSString> {
    extern "C-unwind" {
        fn NSStringFromMapTable(table: &NSMapTable) -> *mut NSString;
    }
    let ret = unsafe { NSStringFromMapTable(table) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}
