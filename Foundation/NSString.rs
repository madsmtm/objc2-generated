//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// Type for UTF-16 code units.
pub type unichar = c_ushort;

/// These values represent the options available to many of the string classes‚Äô search and comparison methods.
///
/// ## Overview
///
/// See [Searching, Comparing, and Sorting Strings](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Strings/Articles/SearchingStrings.html#//apple_ref/doc/uid/20000149) for details on the effects of these options.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSStringCompareOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSStringCompareOptions: NSUInteger {
/// A case-insensitive search.
        #[doc(alias = "NSCaseInsensitiveSearch")]
        const CaseInsensitiveSearch = 1;
/// Exact character-by-character equivalence.
        #[doc(alias = "NSLiteralSearch")]
        const LiteralSearch = 2;
/// Search from end of source string.
        #[doc(alias = "NSBackwardsSearch")]
        const BackwardsSearch = 4;
/// Search is limited to start (or end, if `NSBackwardsSearch`) of source string.
        #[doc(alias = "NSAnchoredSearch")]
        const AnchoredSearch = 8;
/// Numbers within strings are compared using numeric value, that is, `Name2.txt` < `Name7.txt` < `Name25.txt`.
///
/// ## Discussion
///
/// Numeric comparison only applies to the numerals in the string, not other characters that would have meaning in a numeric representation such as a negative sign, a comma, or a decimal point.
///
/// This option only applies to compare methods, not find.
///
///
        #[doc(alias = "NSNumericSearch")]
        const NumericSearch = 64;
/// Search ignores diacritic marks.
///
/// ## Discussion
///
/// For example, ‚Äò√∂‚Äô is equal to ‚Äòo‚Äô.
///
///
        #[doc(alias = "NSDiacriticInsensitiveSearch")]
        const DiacriticInsensitiveSearch = 128;
/// Search ignores width differences in characters that have full-width and half-width forms, as occurs in East Asian character sets.
///
/// ## Discussion
///
/// For example, with this option, the full-width Latin small letter ‚ÄòÔΩÅ‚Äô (`U+FF41`) is equal to the basic Latin small letter ‚Äòa‚Äô (`U+0061`).
///
///
        #[doc(alias = "NSWidthInsensitiveSearch")]
        const WidthInsensitiveSearch = 256;
/// Comparisons are forced to return either `NSOrderedAscending` or `NSOrderedDescending` if the strings are equivalent but not strictly equal.
///
/// ## Discussion
///
/// This option ensures reliable, reproducible results when sorting. For example, ‚Äúaaa‚Äù is greater than ‚ÄúAAA‚Äù  if [`NSCaseInsensitiveSearch`](https://developer.apple.com/documentation/foundation/nsstring/compareoptions/caseinsensitive) is specified.
///
///
        #[doc(alias = "NSForcedOrderingSearch")]
        const ForcedOrderingSearch = 512;
/// The search string is treated as an ICU-compatible regular expression. If set, no other options can apply except [`NSCaseInsensitiveSearch`](https://developer.apple.com/documentation/foundation/nsstring/compareoptions/caseinsensitive) and [`NSAnchoredSearch`](https://developer.apple.com/documentation/foundation/nsstring/compareoptions/anchored). You can use this option only with the `rangeOfString:`‚Ä¶ methods and [`stringByReplacingOccurrencesOfString:withString:options:range:`](https://developer.apple.com/documentation/foundation/nsstring/replacingoccurrences(of:with:options:range:)).
        #[doc(alias = "NSRegularExpressionSearch")]
        const RegularExpressionSearch = 1024;
    }
}

unsafe impl Encode for NSStringCompareOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSStringCompareOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The following constants are provided by `NSString` as possible string encodings.
///
/// ## Discussion
///
/// These values represent the various character encodings supported by the `NSString` classes. This is an incomplete list. Additional encodings are defined in [String Programming Guide for Core Foundation](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFStrings/introCFStrings.html#//apple_ref/doc/uid/10000131i) (see `CFStringEncodingExt.h`); these encodings can be used with `NSString` by first passing the Core Foundation encoding to the [`CFStringConvertEncodingToNSStringEncoding(_:)`](https://developer.apple.com/documentation/corefoundation/cfstringconvertencodingtonsstringencoding(_:)) function.
///
///
pub type NSStringEncoding = NSUInteger;

/// Strict 7-bit ASCII encoding within 8-bit chars; ASCII values 0‚Ä¶127 only.
pub const NSASCIIStringEncoding: NSStringEncoding = 1;
/// 8-bit ASCII encoding with NEXTSTEP extensions.
pub const NSNEXTSTEPStringEncoding: NSStringEncoding = 2;
/// 8-bit EUC encoding for Japanese text.
pub const NSJapaneseEUCStringEncoding: NSStringEncoding = 3;
/// An 8-bit representation of Unicode characters, suitable for transmission or storage by ASCII-based systems.
pub const NSUTF8StringEncoding: NSStringEncoding = 4;
/// 8-bit ISO Latin 1 encoding.
pub const NSISOLatin1StringEncoding: NSStringEncoding = 5;
/// 8-bit Adobe Symbol encoding vector.
pub const NSSymbolStringEncoding: NSStringEncoding = 6;
/// 7-bit verbose ASCII to represent all Unicode characters.
pub const NSNonLossyASCIIStringEncoding: NSStringEncoding = 7;
/// 8-bit Shift-JIS encoding for Japanese text.
pub const NSShiftJISStringEncoding: NSStringEncoding = 8;
/// 8-bit ISO Latin 2 encoding.
pub const NSISOLatin2StringEncoding: NSStringEncoding = 9;
/// The canonical Unicode encoding for string objects.
pub const NSUnicodeStringEncoding: NSStringEncoding = 10;
/// Microsoft Windows codepage 1251, encoding Cyrillic characters; equivalent to AdobeStandardCyrillic font encoding.
pub const NSWindowsCP1251StringEncoding: NSStringEncoding = 11;
/// Microsoft Windows codepage 1252; equivalent to WinLatin1.
pub const NSWindowsCP1252StringEncoding: NSStringEncoding = 12;
/// Microsoft Windows codepage 1253, encoding Greek characters.
pub const NSWindowsCP1253StringEncoding: NSStringEncoding = 13;
/// Microsoft Windows codepage 1254, encoding Turkish characters.
pub const NSWindowsCP1254StringEncoding: NSStringEncoding = 14;
/// Microsoft Windows codepage 1250; equivalent to WinLatin2.
pub const NSWindowsCP1250StringEncoding: NSStringEncoding = 15;
/// ISO 2022 Japanese encoding for email.
pub const NSISO2022JPStringEncoding: NSStringEncoding = 21;
/// Classic Macintosh Roman encoding.
pub const NSMacOSRomanStringEncoding: NSStringEncoding = 30;
///
/// ## Discussion
///
/// An alias for `NSUnicodeStringEncoding`.
///
///
pub const NSUTF16StringEncoding: NSStringEncoding = NSUnicodeStringEncoding;
/// `NSUTF16StringEncoding` encoding with explicit endianness specified.
pub const NSUTF16BigEndianStringEncoding: NSStringEncoding = 0x90000100;
/// `NSUTF16StringEncoding` encoding with explicit endianness specified.
pub const NSUTF16LittleEndianStringEncoding: NSStringEncoding = 0x94000100;
/// 32-bit UTF encoding.
pub const NSUTF32StringEncoding: NSStringEncoding = 0x8c000100;
/// `NSUTF32StringEncoding` encoding with explicit endianness specified.
pub const NSUTF32BigEndianStringEncoding: NSStringEncoding = 0x98000100;
/// `NSUTF32StringEncoding` encoding with explicit endianness specified.
pub const NSUTF32LittleEndianStringEncoding: NSStringEncoding = 0x9c000100;

/// Options for converting string encodings.
///
/// ## Overview
///
/// These constants are available in OS X¬†v10.4; they are, however, differently named:
///
/// ```objc
/// typedef enum {
///     NSAllowLossyEncodingConversion = 1,
///     NSExternalRepresentationEncodingConversion = 2
/// } NSStringEncodingConversionOptions;
/// ```
///
/// You can use them in OS X¬†v10.4 if you define the symbols as `extern` constants.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSStringEncodingConversionOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSStringEncodingConversionOptions: NSUInteger {
/// Allows lossy conversion.
        #[doc(alias = "NSStringEncodingConversionAllowLossy")]
        const AllowLossy = 1;
/// Specifies an external representation (with a byte-order mark, if necessary, to indicate endianness).
        #[doc(alias = "NSStringEncodingConversionExternalRepresentation")]
        const ExternalRepresentation = 2;
    }
}

unsafe impl Encode for NSStringEncodingConversionOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSStringEncodingConversionOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A static, plain-text Unicode string object.
    ///
    /// ## Overview
    ///
    /// You can use this type in Swift when you need reference semantics or other Foundation-specific behavior.
    ///
    /// The [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) class and its mutable subclass, [`NSMutableString`](https://developer.apple.com/documentation/foundation/nsmutablestring), provide an extensive set of APIs for working with strings, including methods for comparing, searching, and modifying strings. [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) objects are used throughout Foundation and other Cocoa frameworks, serving as the basis for all textual and linguistic functionality on the platform.
    ///
    /// [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) is _toll-free bridged_ with its Core Foundation counterpart, [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring). See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information.
    ///
    /// ### String Objects
    ///
    /// An [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object encodes a Unicode-compliant text string, represented as a sequence of UTF‚Äì16 code units. All lengths, character indexes, and ranges are expressed in terms of 16-bit platform-endian values, with index values starting at `0`.
    ///
    /// An [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object can be initialized from or written to a C buffer, an [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) object, or the contents of an [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl). It can also be encoded and decoded to and from ASCII, UTF‚Äì8, UTF‚Äì16, UTF‚Äì32, or any other string encoding represented by [`NSStringEncoding`](https://developer.apple.com/documentation/foundation/nsstringencoding).
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  An immutable string is a text string that is defined when it is created and subsequently cannot be changed. An immutable string is implemented as an array of UTF‚Äì16 code units (in other words, a text string). To create and manage an immutable string, use the [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) class. To construct and manage a string that can be changed after it has been created, use [`NSMutableString`](https://developer.apple.com/documentation/foundation/nsmutablestring).
    ///
    ///
    ///
    /// </div>
    /// The objects you create using [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) and [`NSMutableString`](https://developer.apple.com/documentation/foundation/nsmutablestring) are referred to as string objects (or, when no confusion will result, merely as strings). The term C string refers to the standard `char¬†*` type.
    ///
    /// Because of the nature of class clusters, string objects aren‚Äôt actual instances of the [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) or [`NSMutableString`](https://developer.apple.com/documentation/foundation/nsmutablestring) classes but of one of their private subclasses. Although a string object‚Äôs class is private, its interface is public, as declared by these abstract superclasses, [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) and [`NSMutableString`](https://developer.apple.com/documentation/foundation/nsmutablestring). The string classes adopt the [`NSCopying`](https://developer.apple.com/documentation/foundation/nscopying) and [`NSMutableCopying`](https://developer.apple.com/documentation/foundation/nsmutablecopying) protocols, making it convenient to convert a string of one type to the other.
    ///
    /// #### Understanding Characters
    ///
    /// A string object presents itself as a sequence of UTF‚Äì16 code units. You can determine how many UTF-16 code units a string object contains with the [`length`](https://developer.apple.com/documentation/foundation/nsstring/length) method and can retrieve a specific UTF-16 code unit with the [`characterAtIndex:`](https://developer.apple.com/documentation/foundation/nsstring/character(at:)) method. These two ‚Äúprimitive‚Äù methods provide basic access to a string object.
    ///
    /// Most use of strings, however, is at a higher level, with the strings being treated as single entities: You compare strings against one another, search them for substrings, combine them into new strings, and so on. If you need to access string objects character by character, you must understand the Unicode character encoding, specifically issues related to composed character sequences. For details see _The Unicode Standard, Version 4.0_ (The Unicode Consortium, Boston: Addison-Wesley, 2003, ISBN 0-321-18578-1) and the Unicode Consortium web site: [http://www.unicode.org/](http://www.unicode.org/). See also [Characters and Grapheme Clusters](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Strings/Articles/stringsClusters.html#//apple_ref/doc/uid/TP40008025) in [String Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Strings/introStrings.html#//apple_ref/doc/uid/10000035i).
    ///
    /// Localized string comparisons are based on the Unicode Collation Algorithm, as tailored for different languages by CLDR (Common Locale Data Repository). Both are projects of the Unicode Consortium. Unicode is a registered trademark of Unicode, Inc.
    ///
    /// #### Interpreting UTF-16-Encoded Data
    ///
    /// When creating an `NSString` object from a UTF-16-encoded string (or a byte stream interpreted as UTF-16), if the byte order is not otherwise specified, `NSString` assumes that the UTF-16 characters are big-endian, unless there is a BOM (byte-order mark), in which case the BOM dictates the byte order. When creating an `NSString` object from an array of `unichar` values, the returned string is always native-endian, since the array always contains UTF‚Äì16 code units in native byte order.
    ///
    /// ### Subclassing Notes
    ///
    /// It is possible to subclass [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) (and [`NSMutableString`](https://developer.apple.com/documentation/foundation/nsmutablestring)), but doing so requires providing storage facilities for the string (which is not inherited by subclasses) and implementing two primitive methods. The abstract [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) and [`NSMutableString`](https://developer.apple.com/documentation/foundation/nsmutablestring) classes are the public interface of a class cluster consisting mostly of private, concrete classes that create and return a string object appropriate for a given situation. Making your own concrete subclass of this cluster imposes certain requirements (discussed in [Methods to Override](https://developer.apple.com/documentation/foundation/nsstring#methods-to-override)).
    ///
    /// Make sure your reasons for subclassing [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) are valid. Instances of your subclass should represent a string and not something else. Thus the only attributes the subclass should have are the length of the character buffer it‚Äôs managing and access to individual characters in the buffer. Valid reasons for making a subclass of [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) include providing a different backing store (perhaps for better performance) or implementing some aspect of object behavior differently, such as memory management. If your purpose is to add non-essential attributes or metadata to your subclass of [`NSString`](https://developer.apple.com/documentation/foundation/nsstring), a better alternative would be object composition (see [Alternatives to Subclassing](https://developer.apple.com/documentation/foundation/nsstring#alternatives-to-subclassing)). Cocoa already provides an example of this with the [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) class.
    ///
    /// #### Methods to Override
    ///
    /// Any subclass of `NSString`   _must_ override the primitive instance methods [`length`](https://developer.apple.com/documentation/foundation/nsstring/length) and [`characterAtIndex:`](https://developer.apple.com/documentation/foundation/nsstring/character(at:)). These methods must operate on the backing store that you provide for the characters of the string. For this backing store you can use a static array, a dynamically allocated buffer, a standard `NSString` object, or some other data type or mechanism. You may also choose to override, partially or fully, any other `NSString` method for which you want to provide an alternative implementation. For example, for better performance it is recommended that you override [`getCharacters:range:`](https://developer.apple.com/documentation/foundation/nsstring/getcharacters(_:range:)) and give it a faster implementation.
    ///
    /// You might want to implement an initializer for your subclass that is suited to the backing store that the subclass is managing. The `NSString` class does not have a designated initializer, so your initializer need only invoke the [`init`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/init()) method of `super`. The `NSString` class adopts the [`NSCopying`](https://developer.apple.com/documentation/foundation/nscopying), [`NSMutableCopying`](https://developer.apple.com/documentation/foundation/nsmutablecopying), and [`NSCoding`](https://developer.apple.com/documentation/foundation/nscoding) protocols; if you want instances of your own custom subclass created from copying or coding, override the methods in these protocols.
    ///
    /// #### Alternatives to Subclassing
    ///
    /// Often a better and easier alternative to making a subclass of `NSString`‚Äîor of any other abstract, public class of a class cluster, for that matter‚Äîis object composition. This is especially the case when your intent is to add to the subclass metadata or some other attribute that is not essential to a string object. In object composition, you would have an `NSString` object as one instance variable of your custom class (typically a subclass of `NSObject`) and one or more instance variables that store the metadata that you want for the custom object. Then just design your subclass interface to include accessor methods for the embedded string object and the metadata.
    ///
    /// If the behavior you want to add supplements that of the existing class, you could write a category on `NSString`. Keep in mind, however, that this category will be in effect for all instances of `NSString` that you use, and this might have unintended consequences.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(PartialEq, Eq, Hash)]
    pub struct NSString;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSString> for CFString {
    #[inline]
    fn as_ref(&self) -> &NSString {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFString> for NSString {
    #[inline]
    fn as_ref(&self) -> &CFString {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSString {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSString {
    type Result = Self;
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSMutableCopying for NSString {}
);

#[cfg(feature = "NSObject")]
unsafe impl MutableCopyingHelper for NSString {
    type Result = NSMutableString;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSString {}
);

impl NSString {
    extern_methods!(
        #[unsafe(method(length))]
        #[unsafe(method_family = none)]
        pub fn length(&self) -> NSUInteger;

        #[unsafe(method(characterAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn characterAtIndex(&self, index: NSUInteger) -> unichar;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSString {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSString {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// Constants to specify kinds of substrings and styles of enumeration.
///
/// ## Overview
///
/// These options are used with the [`enumerateSubstringsInRange:options:usingBlock:`](https://developer.apple.com/documentation/foundation/nsstring/enumeratesubstrings(in:options:using:)) method. Pass in one `NSStringEnumerationBy...` option and combine with any of the remaining enumeration style constants using the C bitwise `OR` operator.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSStringEnumerationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSStringEnumerationOptions: NSUInteger {
///
/// ## Discussion
///
/// Enumerates by lines. Equivalent to [`lineRangeForRange:`](https://developer.apple.com/documentation/foundation/nsstring/linerange(for:)).
///
///
        #[doc(alias = "NSStringEnumerationByLines")]
        const ByLines = 0;
///
/// ## Discussion
///
/// Enumerates by paragraphs. Equivalent to [`paragraphRangeForRange:`](https://developer.apple.com/documentation/foundation/nsstring/paragraphrange(for:)).
///
///
        #[doc(alias = "NSStringEnumerationByParagraphs")]
        const ByParagraphs = 1;
///
/// ## Discussion
///
/// Enumerates by composed character sequences. Equivalent to [`rangeOfComposedCharacterSequencesForRange:`](https://developer.apple.com/documentation/foundation/nsstring/rangeofcomposedcharactersequences(for:)).
///
///
        #[doc(alias = "NSStringEnumerationByComposedCharacterSequences")]
        const ByComposedCharacterSequences = 2;
///
/// ## Discussion
///
/// Enumerates by words.
///
///
        #[doc(alias = "NSStringEnumerationByWords")]
        const ByWords = 3;
///
/// ## Discussion
///
/// Enumerates by sentences.
///
///
        #[doc(alias = "NSStringEnumerationBySentences")]
        const BySentences = 4;
        #[doc(alias = "NSStringEnumerationByCaretPositions")]
        const ByCaretPositions = 5;
        #[doc(alias = "NSStringEnumerationByDeletionClusters")]
        const ByDeletionClusters = 6;
///
/// ## Discussion
///
/// Causes enumeration to occur from the end of the specified range to the start.
///
///
        #[doc(alias = "NSStringEnumerationReverse")]
        const Reverse = 1<<8;
///
/// ## Discussion
///
/// A way to indicate that the block does not need substring, in which case `nil` will be passed. This is simply a performance shortcut.
///
///
        #[doc(alias = "NSStringEnumerationSubstringNotRequired")]
        const SubstringNotRequired = 1<<9;
///
/// ## Discussion
///
/// Causes the enumeration to occur using the current locale. This does not make a difference in line, paragraph, or composed character sequence enumeration, but it may for words or sentences.
///
///
        #[doc(alias = "NSStringEnumerationLocalized")]
        const Localized = 1<<10;
    }
}

unsafe impl Encode for NSStringEnumerationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSStringEnumerationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants representing an ICU string transform.
///
/// ## Discussion
///
/// These constants are used by the [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) method [`stringByApplyingTransform:reverse:`](https://developer.apple.com/documentation/foundation/nsstring/applyingtransform(_:reverse:)).
///
///
// NS_TYPED_EXTENSIBLE_ENUM
pub type NSStringTransform = NSString;

extern "C" {
    /// A constant containing the transliteration of a string from Latin script to Katakana script.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚Äúkatakana‚Äù transliterates to ‚Äú„Ç´„Çø„Ç´„Éä‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformLatinKatakana`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinkatakana).
    ///
    ///
    pub static NSStringTransformLatinToKatakana: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from Latin script to Hiragana script.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚Äúhiragana‚Äù transliterates to ‚Äú„Å≤„Çâ„Åå„Å™‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformLatinHiragana`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinhiragana).
    ///
    ///
    pub static NSStringTransformLatinToHiragana: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from Latin script to Hangul script.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚Äúhangul‚Äù transliterates to ‚ÄúÌïúÍµ¥‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformLatinHangul`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinhangul).
    ///
    ///
    pub static NSStringTransformLatinToHangul: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from Latin script to Arabic script.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚Äú·∫°l øarabƒ´·∫ó‚Äé‚Äù transliterates to ‚ÄúÿßŸÑÿπŸéÿ±Ÿéÿ®ŸêŸäÿ©‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformLatinArabic`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinarabic).
    ///
    ///
    pub static NSStringTransformLatinToArabic: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from Latin script to Hebrew script.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚Äú ªbry≈£‚Äù transliterates to ‚Äú◊¢◊ë◊®◊ô◊™‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformLatinHebrew`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinhebrew).
    ///
    ///
    pub static NSStringTransformLatinToHebrew: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from Latin script to Thai script.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚ÄúpÃ£hƒÅsÃÑ πƒÅ th·ªãy‚Äù transliterates to ‚Äú‡∏†‡∏≤‡∏©‡∏≤‡πÑ‡∏ó‡∏¢‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformLatinThai`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinthai).
    ///
    ///
    pub static NSStringTransformLatinToThai: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from Latin script to Cyrillic script.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚Äúkirillica‚Äù transliterates to ‚Äú–∫–∏—Ä–∏–ª–ª–∏—Ü–∞‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformLatinCyrillic`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatincyrillic).
    ///
    ///
    pub static NSStringTransformLatinToCyrillic: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from Latin script to Greek script.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚ÄúEllƒìnik√≥ alph√°bƒìto‚Äé‚Äù transliterates to ‚ÄúŒïŒªŒªŒ∑ŒΩŒπŒ∫œå Œ±ŒªœÜŒ¨Œ≤Œ∑œÑŒø‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformLatinGreek`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatingreek).
    ///
    ///
    pub static NSStringTransformLatinToGreek: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from any script to Latin script.
    ///
    /// ## Discussion
    ///
    /// This is equivalent to [`kCFStringTransformToLatin`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformtolatin).
    ///
    ///
    pub static NSStringTransformToLatin: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from Han script to Latin.
    ///
    /// ## Discussion
    ///
    /// For example, the string ‚Äúh√†n z√¨‚Äù transliterates to ‚ÄúÊ±âÂ≠ó‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformMandarinLatin`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformmandarinlatin).
    ///
    ///
    pub static NSStringTransformMandarinToLatin: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transliteration of a string from Hiragana script to Katakana script.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚Äú„Å≤„Çâ„Åå„Å™‚Äù transliterates to ‚Äú„Ç´„Çø„Ç´„Éä‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformHiraganaKatakana`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformhiraganakatakana).
    ///
    ///
    pub static NSStringTransformHiraganaToKatakana: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transformation of a string from full-width CJK characters to half-width forms.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚Äú„Éû„ÉÉ„Éà‚Äù transforms to ‚ÄúÔæèÔΩØÔæÑ‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformFullwidthHalfwidth`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformfullwidthhalfwidth).
    ///
    ///
    pub static NSStringTransformFullwidthToHalfwidth: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transformation of a string from characters to XML hexadecimal escape codes.
    ///
    /// ## Discussion
    ///
    /// This transformation is reversible.
    ///
    /// For example, the string ‚Äú‚ù¶‚Äù transforms to ‚Äú&#x2766;‚Äù.
    ///
    /// This is equivalent to [`kCFStringTransformToXMLHex`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformtoxmlhex).
    ///
    ///
    pub static NSStringTransformToXMLHex: &'static NSStringTransform;
}

extern "C" {
    /// An identifier for a transform that converts characters to Unicode names.
    ///
    /// ## Discussion
    ///
    /// For example, the string ‚Äúüê∂üêÆ‚Äù transforms to `"``\N{DOG FACE}\N{COW FACE}"` .
    ///
    /// Passing this constant to the [`applyTransform:reverse:range:updatedRange:`](https://developer.apple.com/documentation/foundation/nsmutablestring/applytransform(_:reverse:range:updatedrange:)) method is equivalent to passing [`kCFStringTransformToUnicodeName`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformtounicodename) to [`CFStringTransform`](https://developer.apple.com/documentation/corefoundation/cfstringtransform(_:_:_:_:)).
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The result of a forward transformation delimits each Unicode name with enclosing curly braces and the leading character sequence `"\N"`. In some programming languages, `"\N{...}"` is used as an escape sequence for Unicode characters in strings and regular expressions; this isn‚Äôt supported in Swift or Objective-C. To perform the reverse transform of a string literal in Swift or Objective-C, escape the leading backslash (`"\\N{...}"`) for each Unicode name.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSStringTransformToUnicodeName: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transformation of a string by removing combining marks.
    ///
    /// ## Discussion
    ///
    /// This is equivalent to [`kCFStringTransformStripCombiningMarks`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformstripcombiningmarks).
    ///
    ///
    pub static NSStringTransformStripCombiningMarks: &'static NSStringTransform;
}

extern "C" {
    /// A constant containing the transformation of a string by removing diacritics.
    ///
    /// ## Discussion
    ///
    /// This is equivalent to [`kCFStringTransformStripDiacritics`](https://developer.apple.com/documentation/corefoundation/kcfstringtransformstripdiacritics).
    ///
    ///
    pub static NSStringTransformStripDiacritics: &'static NSStringTransform;
}

/// NSStringExtensionMethods.
impl NSString {
    extern_methods!(
        #[unsafe(method(substringFromIndex:))]
        #[unsafe(method_family = none)]
        pub fn substringFromIndex(&self, from: NSUInteger) -> Retained<NSString>;

        #[unsafe(method(substringToIndex:))]
        #[unsafe(method_family = none)]
        pub fn substringToIndex(&self, to: NSUInteger) -> Retained<NSString>;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(substringWithRange:))]
        #[unsafe(method_family = none)]
        pub fn substringWithRange(&self, range: NSRange) -> Retained<NSString>;

        #[cfg(feature = "NSRange")]
        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[unsafe(method(getCharacters:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getCharacters_range(&self, buffer: NonNull<unichar>, range: NSRange);

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(compare:))]
        #[unsafe(method_family = none)]
        pub fn compare(&self, string: &NSString) -> NSComparisonResult;

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(compare:options:))]
        #[unsafe(method_family = none)]
        pub fn compare_options(
            &self,
            string: &NSString,
            mask: NSStringCompareOptions,
        ) -> NSComparisonResult;

        #[cfg(all(feature = "NSObjCRuntime", feature = "NSRange"))]
        #[unsafe(method(compare:options:range:))]
        #[unsafe(method_family = none)]
        pub fn compare_options_range(
            &self,
            string: &NSString,
            mask: NSStringCompareOptions,
            range_of_receiver_to_compare: NSRange,
        ) -> NSComparisonResult;

        #[cfg(all(feature = "NSObjCRuntime", feature = "NSRange"))]
        /// # Safety
        ///
        /// `locale` should be of the correct type.
        #[unsafe(method(compare:options:range:locale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn compare_options_range_locale(
            &self,
            string: &NSString,
            mask: NSStringCompareOptions,
            range_of_receiver_to_compare: NSRange,
            locale: Option<&AnyObject>,
        ) -> NSComparisonResult;

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(caseInsensitiveCompare:))]
        #[unsafe(method_family = none)]
        pub fn caseInsensitiveCompare(&self, string: &NSString) -> NSComparisonResult;

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(localizedCompare:))]
        #[unsafe(method_family = none)]
        pub fn localizedCompare(&self, string: &NSString) -> NSComparisonResult;

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(localizedCaseInsensitiveCompare:))]
        #[unsafe(method_family = none)]
        pub fn localizedCaseInsensitiveCompare(&self, string: &NSString) -> NSComparisonResult;

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(localizedStandardCompare:))]
        #[unsafe(method_family = none)]
        pub fn localizedStandardCompare(&self, string: &NSString) -> NSComparisonResult;

        #[unsafe(method(isEqualToString:))]
        #[unsafe(method_family = none)]
        pub fn isEqualToString(&self, a_string: &NSString) -> bool;

        #[unsafe(method(hasPrefix:))]
        #[unsafe(method_family = none)]
        pub fn hasPrefix(&self, str: &NSString) -> bool;

        #[unsafe(method(hasSuffix:))]
        #[unsafe(method_family = none)]
        pub fn hasSuffix(&self, str: &NSString) -> bool;

        #[unsafe(method(commonPrefixWithString:options:))]
        #[unsafe(method_family = none)]
        pub fn commonPrefixWithString_options(
            &self,
            str: &NSString,
            mask: NSStringCompareOptions,
        ) -> Retained<NSString>;

        #[unsafe(method(containsString:))]
        #[unsafe(method_family = none)]
        pub fn containsString(&self, str: &NSString) -> bool;

        #[unsafe(method(localizedCaseInsensitiveContainsString:))]
        #[unsafe(method_family = none)]
        pub fn localizedCaseInsensitiveContainsString(&self, str: &NSString) -> bool;

        #[unsafe(method(localizedStandardContainsString:))]
        #[unsafe(method_family = none)]
        pub fn localizedStandardContainsString(&self, str: &NSString) -> bool;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(localizedStandardRangeOfString:))]
        #[unsafe(method_family = none)]
        pub fn localizedStandardRangeOfString(&self, str: &NSString) -> NSRange;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(rangeOfString:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfString(&self, search_string: &NSString) -> NSRange;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(rangeOfString:options:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfString_options(
            &self,
            search_string: &NSString,
            mask: NSStringCompareOptions,
        ) -> NSRange;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(rangeOfString:options:range:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfString_options_range(
            &self,
            search_string: &NSString,
            mask: NSStringCompareOptions,
            range_of_receiver_to_search: NSRange,
        ) -> NSRange;

        #[cfg(all(feature = "NSLocale", feature = "NSRange"))]
        #[unsafe(method(rangeOfString:options:range:locale:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfString_options_range_locale(
            &self,
            search_string: &NSString,
            mask: NSStringCompareOptions,
            range_of_receiver_to_search: NSRange,
            locale: Option<&NSLocale>,
        ) -> NSRange;

        #[cfg(all(feature = "NSCharacterSet", feature = "NSRange"))]
        #[unsafe(method(rangeOfCharacterFromSet:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfCharacterFromSet(&self, search_set: &NSCharacterSet) -> NSRange;

        #[cfg(all(feature = "NSCharacterSet", feature = "NSRange"))]
        #[unsafe(method(rangeOfCharacterFromSet:options:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfCharacterFromSet_options(
            &self,
            search_set: &NSCharacterSet,
            mask: NSStringCompareOptions,
        ) -> NSRange;

        #[cfg(all(feature = "NSCharacterSet", feature = "NSRange"))]
        #[unsafe(method(rangeOfCharacterFromSet:options:range:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfCharacterFromSet_options_range(
            &self,
            search_set: &NSCharacterSet,
            mask: NSStringCompareOptions,
            range_of_receiver_to_search: NSRange,
        ) -> NSRange;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(rangeOfComposedCharacterSequenceAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfComposedCharacterSequenceAtIndex(&self, index: NSUInteger) -> NSRange;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(rangeOfComposedCharacterSequencesForRange:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfComposedCharacterSequencesForRange(&self, range: NSRange) -> NSRange;

        #[unsafe(method(stringByAppendingString:))]
        #[unsafe(method_family = none)]
        pub fn stringByAppendingString(&self, a_string: &NSString) -> Retained<NSString>;

        #[unsafe(method(doubleValue))]
        #[unsafe(method_family = none)]
        pub fn doubleValue(&self) -> c_double;

        #[unsafe(method(floatValue))]
        #[unsafe(method_family = none)]
        pub fn floatValue(&self) -> c_float;

        #[unsafe(method(intValue))]
        #[unsafe(method_family = none)]
        pub fn intValue(&self) -> c_int;

        #[unsafe(method(integerValue))]
        #[unsafe(method_family = none)]
        pub fn integerValue(&self) -> NSInteger;

        #[unsafe(method(longLongValue))]
        #[unsafe(method_family = none)]
        pub fn longLongValue(&self) -> c_longlong;

        #[unsafe(method(boolValue))]
        #[unsafe(method_family = none)]
        pub fn boolValue(&self) -> bool;

        #[unsafe(method(uppercaseString))]
        #[unsafe(method_family = none)]
        pub fn uppercaseString(&self) -> Retained<NSString>;

        #[unsafe(method(lowercaseString))]
        #[unsafe(method_family = none)]
        pub fn lowercaseString(&self) -> Retained<NSString>;

        #[unsafe(method(capitalizedString))]
        #[unsafe(method_family = none)]
        pub fn capitalizedString(&self) -> Retained<NSString>;

        #[unsafe(method(localizedUppercaseString))]
        #[unsafe(method_family = none)]
        pub fn localizedUppercaseString(&self) -> Retained<NSString>;

        #[unsafe(method(localizedLowercaseString))]
        #[unsafe(method_family = none)]
        pub fn localizedLowercaseString(&self) -> Retained<NSString>;

        #[unsafe(method(localizedCapitalizedString))]
        #[unsafe(method_family = none)]
        pub fn localizedCapitalizedString(&self) -> Retained<NSString>;

        #[cfg(feature = "NSLocale")]
        #[unsafe(method(uppercaseStringWithLocale:))]
        #[unsafe(method_family = none)]
        pub fn uppercaseStringWithLocale(&self, locale: Option<&NSLocale>) -> Retained<NSString>;

        #[cfg(feature = "NSLocale")]
        #[unsafe(method(lowercaseStringWithLocale:))]
        #[unsafe(method_family = none)]
        pub fn lowercaseStringWithLocale(&self, locale: Option<&NSLocale>) -> Retained<NSString>;

        #[cfg(feature = "NSLocale")]
        #[unsafe(method(capitalizedStringWithLocale:))]
        #[unsafe(method_family = none)]
        pub fn capitalizedStringWithLocale(&self, locale: Option<&NSLocale>) -> Retained<NSString>;

        #[cfg(feature = "NSRange")]
        /// # Safety
        ///
        /// - `start_ptr` must be a valid pointer or null.
        /// - `line_end_ptr` must be a valid pointer or null.
        /// - `contents_end_ptr` must be a valid pointer or null.
        #[unsafe(method(getLineStart:end:contentsEnd:forRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLineStart_end_contentsEnd_forRange(
            &self,
            start_ptr: *mut NSUInteger,
            line_end_ptr: *mut NSUInteger,
            contents_end_ptr: *mut NSUInteger,
            range: NSRange,
        );

        #[cfg(feature = "NSRange")]
        #[unsafe(method(lineRangeForRange:))]
        #[unsafe(method_family = none)]
        pub fn lineRangeForRange(&self, range: NSRange) -> NSRange;

        #[cfg(feature = "NSRange")]
        /// # Safety
        ///
        /// - `start_ptr` must be a valid pointer or null.
        /// - `par_end_ptr` must be a valid pointer or null.
        /// - `contents_end_ptr` must be a valid pointer or null.
        #[unsafe(method(getParagraphStart:end:contentsEnd:forRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getParagraphStart_end_contentsEnd_forRange(
            &self,
            start_ptr: *mut NSUInteger,
            par_end_ptr: *mut NSUInteger,
            contents_end_ptr: *mut NSUInteger,
            range: NSRange,
        );

        #[cfg(feature = "NSRange")]
        #[unsafe(method(paragraphRangeForRange:))]
        #[unsafe(method_family = none)]
        pub fn paragraphRangeForRange(&self, range: NSRange) -> NSRange;

        #[cfg(all(feature = "NSRange", feature = "block2"))]
        #[unsafe(method(enumerateSubstringsInRange:options:usingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateSubstringsInRange_options_usingBlock(
            &self,
            range: NSRange,
            opts: NSStringEnumerationOptions,
            block: &block2::DynBlock<dyn Fn(*mut NSString, NSRange, NSRange, NonNull<Bool>)>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(enumerateLinesUsingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateLinesUsingBlock(
            &self,
            block: &block2::DynBlock<dyn Fn(NonNull<NSString>, NonNull<Bool>)>,
        );

        #[unsafe(method(UTF8String))]
        #[unsafe(method_family = none)]
        pub fn UTF8String(&self) -> *const c_char;

        #[unsafe(method(fastestEncoding))]
        #[unsafe(method_family = none)]
        pub fn fastestEncoding(&self) -> NSStringEncoding;

        #[unsafe(method(smallestEncoding))]
        #[unsafe(method_family = none)]
        pub fn smallestEncoding(&self) -> NSStringEncoding;

        #[cfg(feature = "NSData")]
        #[unsafe(method(dataUsingEncoding:allowLossyConversion:))]
        #[unsafe(method_family = none)]
        pub fn dataUsingEncoding_allowLossyConversion(
            &self,
            encoding: NSStringEncoding,
            lossy: bool,
        ) -> Option<Retained<NSData>>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(dataUsingEncoding:))]
        #[unsafe(method_family = none)]
        pub fn dataUsingEncoding(&self, encoding: NSStringEncoding) -> Option<Retained<NSData>>;

        #[unsafe(method(canBeConvertedToEncoding:))]
        #[unsafe(method_family = none)]
        pub fn canBeConvertedToEncoding(&self, encoding: NSStringEncoding) -> bool;

        #[unsafe(method(cStringUsingEncoding:))]
        #[unsafe(method_family = none)]
        pub fn cStringUsingEncoding(&self, encoding: NSStringEncoding) -> *const c_char;

        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[unsafe(method(getCString:maxLength:encoding:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getCString_maxLength_encoding(
            &self,
            buffer: NonNull<c_char>,
            max_buffer_count: NSUInteger,
            encoding: NSStringEncoding,
        ) -> bool;

        #[cfg(feature = "NSRange")]
        /// # Safety
        ///
        /// - `buffer` must be a valid pointer or null.
        /// - `used_buffer_count` must be a valid pointer or null.
        /// - `leftover` must be a valid pointer or null.
        #[unsafe(method(getBytes:maxLength:usedLength:encoding:options:range:remainingRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getBytes_maxLength_usedLength_encoding_options_range_remainingRange(
            &self,
            buffer: *mut c_void,
            max_buffer_count: NSUInteger,
            used_buffer_count: *mut NSUInteger,
            encoding: NSStringEncoding,
            options: NSStringEncodingConversionOptions,
            range: NSRange,
            leftover: NSRangePointer,
        ) -> bool;

        #[unsafe(method(maximumLengthOfBytesUsingEncoding:))]
        #[unsafe(method_family = none)]
        pub fn maximumLengthOfBytesUsingEncoding(&self, enc: NSStringEncoding) -> NSUInteger;

        #[unsafe(method(lengthOfBytesUsingEncoding:))]
        #[unsafe(method_family = none)]
        pub fn lengthOfBytesUsingEncoding(&self, enc: NSStringEncoding) -> NSUInteger;

        #[unsafe(method(availableStringEncodings))]
        #[unsafe(method_family = none)]
        pub fn availableStringEncodings() -> NonNull<NSStringEncoding>;

        #[unsafe(method(localizedNameOfStringEncoding:))]
        #[unsafe(method_family = none)]
        pub fn localizedNameOfStringEncoding(encoding: NSStringEncoding) -> Retained<NSString>;

        #[unsafe(method(defaultCStringEncoding))]
        #[unsafe(method_family = none)]
        pub fn defaultCStringEncoding() -> NSStringEncoding;

        #[unsafe(method(decomposedStringWithCanonicalMapping))]
        #[unsafe(method_family = none)]
        pub fn decomposedStringWithCanonicalMapping(&self) -> Retained<NSString>;

        #[unsafe(method(precomposedStringWithCanonicalMapping))]
        #[unsafe(method_family = none)]
        pub fn precomposedStringWithCanonicalMapping(&self) -> Retained<NSString>;

        #[unsafe(method(decomposedStringWithCompatibilityMapping))]
        #[unsafe(method_family = none)]
        pub fn decomposedStringWithCompatibilityMapping(&self) -> Retained<NSString>;

        #[unsafe(method(precomposedStringWithCompatibilityMapping))]
        #[unsafe(method_family = none)]
        pub fn precomposedStringWithCompatibilityMapping(&self) -> Retained<NSString>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(componentsSeparatedByString:))]
        #[unsafe(method_family = none)]
        pub fn componentsSeparatedByString(
            &self,
            separator: &NSString,
        ) -> Retained<NSArray<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSCharacterSet"))]
        #[unsafe(method(componentsSeparatedByCharactersInSet:))]
        #[unsafe(method_family = none)]
        pub fn componentsSeparatedByCharactersInSet(
            &self,
            separator: &NSCharacterSet,
        ) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "NSCharacterSet")]
        #[unsafe(method(stringByTrimmingCharactersInSet:))]
        #[unsafe(method_family = none)]
        pub fn stringByTrimmingCharactersInSet(&self, set: &NSCharacterSet) -> Retained<NSString>;

        #[unsafe(method(stringByPaddingToLength:withString:startingAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn stringByPaddingToLength_withString_startingAtIndex(
            &self,
            new_length: NSUInteger,
            pad_string: &NSString,
            pad_index: NSUInteger,
        ) -> Retained<NSString>;

        #[cfg(feature = "NSLocale")]
        #[unsafe(method(stringByFoldingWithOptions:locale:))]
        #[unsafe(method_family = none)]
        pub fn stringByFoldingWithOptions_locale(
            &self,
            options: NSStringCompareOptions,
            locale: Option<&NSLocale>,
        ) -> Retained<NSString>;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(stringByReplacingOccurrencesOfString:withString:options:range:))]
        #[unsafe(method_family = none)]
        pub fn stringByReplacingOccurrencesOfString_withString_options_range(
            &self,
            target: &NSString,
            replacement: &NSString,
            options: NSStringCompareOptions,
            search_range: NSRange,
        ) -> Retained<NSString>;

        #[unsafe(method(stringByReplacingOccurrencesOfString:withString:))]
        #[unsafe(method_family = none)]
        pub fn stringByReplacingOccurrencesOfString_withString(
            &self,
            target: &NSString,
            replacement: &NSString,
        ) -> Retained<NSString>;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(stringByReplacingCharactersInRange:withString:))]
        #[unsafe(method_family = none)]
        pub fn stringByReplacingCharactersInRange_withString(
            &self,
            range: NSRange,
            replacement: &NSString,
        ) -> Retained<NSString>;

        #[unsafe(method(stringByApplyingTransform:reverse:))]
        #[unsafe(method_family = none)]
        pub fn stringByApplyingTransform_reverse(
            &self,
            transform: &NSStringTransform,
            reverse: bool,
        ) -> Option<Retained<NSString>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(writeToURL:atomically:encoding:error:_))]
        #[unsafe(method_family = none)]
        pub fn writeToURL_atomically_encoding_error(
            &self,
            url: &NSURL,
            use_auxiliary_file: bool,
            enc: NSStringEncoding,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(writeToFile:atomically:encoding:error:_))]
        #[unsafe(method_family = none)]
        pub fn writeToFile_atomically_encoding_error(
            &self,
            path: &NSString,
            use_auxiliary_file: bool,
            enc: NSStringEncoding,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(description))]
        #[unsafe(method_family = none)]
        pub fn description(&self) -> Retained<NSString>;

        #[unsafe(method(hash))]
        #[unsafe(method_family = none)]
        pub fn hash(&self) -> NSUInteger;

        /// # Safety
        ///
        /// `characters` must be a valid pointer.
        #[unsafe(method(initWithCharactersNoCopy:length:freeWhenDone:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCharactersNoCopy_length_freeWhenDone(
            this: Allocated<Self>,
            characters: NonNull<unichar>,
            length: NSUInteger,
            free_buffer: bool,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `chars` must be a valid pointer.
        #[unsafe(method(initWithCharactersNoCopy:length:deallocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCharactersNoCopy_length_deallocator(
            this: Allocated<Self>,
            chars: NonNull<unichar>,
            len: NSUInteger,
            deallocator: Option<&block2::DynBlock<dyn Fn(NonNull<unichar>, NSUInteger)>>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `characters` must be a valid pointer.
        #[unsafe(method(initWithCharacters:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCharacters_length(
            this: Allocated<Self>,
            characters: NonNull<unichar>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `null_terminated_c_string` must be a valid pointer.
        #[unsafe(method(initWithUTF8String:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUTF8String(
            this: Allocated<Self>,
            null_terminated_c_string: NonNull<c_char>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithString:))]
        #[unsafe(method_family = init)]
        pub fn initWithString(this: Allocated<Self>, a_string: &NSString) -> Retained<Self>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(initWithData:encoding:))]
        #[unsafe(method_family = init)]
        pub fn initWithData_encoding(
            this: Allocated<Self>,
            data: &NSData,
            encoding: NSStringEncoding,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytes:length:encoding:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytes_length_encoding(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            len: NSUInteger,
            encoding: NSStringEncoding,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:encoding:freeWhenDone:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length_encoding_freeWhenDone(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            len: NSUInteger,
            encoding: NSStringEncoding,
            free_buffer: bool,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:encoding:deallocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length_encoding_deallocator(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            len: NSUInteger,
            encoding: NSStringEncoding,
            deallocator: Option<&block2::DynBlock<dyn Fn(NonNull<c_void>, NSUInteger)>>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(string))]
        #[unsafe(method_family = none)]
        pub fn string() -> Retained<Self>;

        #[unsafe(method(stringWithString:))]
        #[unsafe(method_family = none)]
        pub fn stringWithString(string: &NSString) -> Retained<Self>;

        /// # Safety
        ///
        /// `characters` must be a valid pointer.
        #[unsafe(method(stringWithCharacters:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithCharacters_length(
            characters: NonNull<unichar>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `null_terminated_c_string` must be a valid pointer.
        #[unsafe(method(stringWithUTF8String:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithUTF8String(
            null_terminated_c_string: NonNull<c_char>,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `null_terminated_c_string` must be a valid pointer.
        #[unsafe(method(initWithCString:encoding:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCString_encoding(
            this: Allocated<Self>,
            null_terminated_c_string: NonNull<c_char>,
            encoding: NSStringEncoding,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `c_string` must be a valid pointer.
        #[unsafe(method(stringWithCString:encoding:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithCString_encoding(
            c_string: NonNull<c_char>,
            enc: NSStringEncoding,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithContentsOfURL:encoding:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL_encoding_error(
            this: Allocated<Self>,
            url: &NSURL,
            enc: NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(initWithContentsOfFile:encoding:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile_encoding_error(
            this: Allocated<Self>,
            path: &NSString,
            enc: NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(stringWithContentsOfURL:encoding:error:_))]
        #[unsafe(method_family = none)]
        pub fn stringWithContentsOfURL_encoding_error(
            url: &NSURL,
            enc: NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(stringWithContentsOfFile:encoding:error:_))]
        #[unsafe(method_family = none)]
        pub fn stringWithContentsOfFile_encoding_error(
            path: &NSString,
            enc: NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        /// # Safety
        ///
        /// `enc` must be a valid pointer or null.
        #[unsafe(method(initWithContentsOfURL:usedEncoding:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContentsOfURL_usedEncoding_error(
            this: Allocated<Self>,
            url: &NSURL,
            enc: *mut NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        /// # Safety
        ///
        /// `enc` must be a valid pointer or null.
        #[unsafe(method(initWithContentsOfFile:usedEncoding:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContentsOfFile_usedEncoding_error(
            this: Allocated<Self>,
            path: &NSString,
            enc: *mut NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        /// # Safety
        ///
        /// `enc` must be a valid pointer or null.
        #[unsafe(method(stringWithContentsOfURL:usedEncoding:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithContentsOfURL_usedEncoding_error(
            url: &NSURL,
            enc: *mut NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        /// # Safety
        ///
        /// `enc` must be a valid pointer or null.
        #[unsafe(method(stringWithContentsOfFile:usedEncoding:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithContentsOfFile_usedEncoding_error(
            path: &NSString,
            enc: *mut NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSString`.
///
/// NSStringExtensionMethods.
impl NSMutableString {
    extern_methods!(
        /// # Safety
        ///
        /// `characters` must be a valid pointer.
        #[unsafe(method(initWithCharactersNoCopy:length:freeWhenDone:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCharactersNoCopy_length_freeWhenDone(
            this: Allocated<Self>,
            characters: NonNull<unichar>,
            length: NSUInteger,
            free_buffer: bool,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `chars` must be a valid pointer.
        #[unsafe(method(initWithCharactersNoCopy:length:deallocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCharactersNoCopy_length_deallocator(
            this: Allocated<Self>,
            chars: NonNull<unichar>,
            len: NSUInteger,
            deallocator: Option<&block2::DynBlock<dyn Fn(NonNull<unichar>, NSUInteger)>>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `characters` must be a valid pointer.
        #[unsafe(method(initWithCharacters:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCharacters_length(
            this: Allocated<Self>,
            characters: NonNull<unichar>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `null_terminated_c_string` must be a valid pointer.
        #[unsafe(method(initWithUTF8String:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUTF8String(
            this: Allocated<Self>,
            null_terminated_c_string: NonNull<c_char>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithString:))]
        #[unsafe(method_family = init)]
        pub fn initWithString(this: Allocated<Self>, a_string: &NSString) -> Retained<Self>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(initWithData:encoding:))]
        #[unsafe(method_family = init)]
        pub fn initWithData_encoding(
            this: Allocated<Self>,
            data: &NSData,
            encoding: NSStringEncoding,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytes:length:encoding:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytes_length_encoding(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            len: NSUInteger,
            encoding: NSStringEncoding,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:encoding:freeWhenDone:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length_encoding_freeWhenDone(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            len: NSUInteger,
            encoding: NSStringEncoding,
            free_buffer: bool,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytesNoCopy:length:encoding:deallocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytesNoCopy_length_encoding_deallocator(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            len: NSUInteger,
            encoding: NSStringEncoding,
            deallocator: Option<&block2::DynBlock<dyn Fn(NonNull<c_void>, NSUInteger)>>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(string))]
        #[unsafe(method_family = none)]
        pub fn string() -> Retained<Self>;

        #[unsafe(method(stringWithString:))]
        #[unsafe(method_family = none)]
        pub fn stringWithString(string: &NSString) -> Retained<Self>;

        /// # Safety
        ///
        /// `characters` must be a valid pointer.
        #[unsafe(method(stringWithCharacters:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithCharacters_length(
            characters: NonNull<unichar>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `null_terminated_c_string` must be a valid pointer.
        #[unsafe(method(stringWithUTF8String:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithUTF8String(
            null_terminated_c_string: NonNull<c_char>,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `null_terminated_c_string` must be a valid pointer.
        #[unsafe(method(initWithCString:encoding:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCString_encoding(
            this: Allocated<Self>,
            null_terminated_c_string: NonNull<c_char>,
            encoding: NSStringEncoding,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `c_string` must be a valid pointer.
        #[unsafe(method(stringWithCString:encoding:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithCString_encoding(
            c_string: NonNull<c_char>,
            enc: NSStringEncoding,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithContentsOfURL:encoding:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL_encoding_error(
            this: Allocated<Self>,
            url: &NSURL,
            enc: NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(initWithContentsOfFile:encoding:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile_encoding_error(
            this: Allocated<Self>,
            path: &NSString,
            enc: NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(stringWithContentsOfURL:encoding:error:_))]
        #[unsafe(method_family = none)]
        pub fn stringWithContentsOfURL_encoding_error(
            url: &NSURL,
            enc: NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(stringWithContentsOfFile:encoding:error:_))]
        #[unsafe(method_family = none)]
        pub fn stringWithContentsOfFile_encoding_error(
            path: &NSString,
            enc: NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        /// # Safety
        ///
        /// `enc` must be a valid pointer or null.
        #[unsafe(method(initWithContentsOfURL:usedEncoding:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContentsOfURL_usedEncoding_error(
            this: Allocated<Self>,
            url: &NSURL,
            enc: *mut NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        /// # Safety
        ///
        /// `enc` must be a valid pointer or null.
        #[unsafe(method(initWithContentsOfFile:usedEncoding:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContentsOfFile_usedEncoding_error(
            this: Allocated<Self>,
            path: &NSString,
            enc: *mut NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        /// # Safety
        ///
        /// `enc` must be a valid pointer or null.
        #[unsafe(method(stringWithContentsOfURL:usedEncoding:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithContentsOfURL_usedEncoding_error(
            url: &NSURL,
            enc: *mut NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        /// # Safety
        ///
        /// `enc` must be a valid pointer or null.
        #[unsafe(method(stringWithContentsOfFile:usedEncoding:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithContentsOfFile_usedEncoding_error(
            path: &NSString,
            enc: *mut NSStringEncoding,
        ) -> Result<Retained<Self>, Retained<NSError>>;
    );
}

// NS_TYPED_ENUM
pub type NSStringEncodingDetectionOptionsKey = NSString;

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Option specifying any suggested string encodings. Use this when you have prior knowledge about the likely or expected encoding. The corresponding value for this key is an `NSArray` of `NSNumber` objects that contain `NSStringEncoding` values. If this option is unspecified, all allowed encodings are evaluated with equal consideration.
    ///
    ///
    pub static NSStringEncodingDetectionSuggestedEncodingsKey:
        &'static NSStringEncodingDetectionOptionsKey;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Option specifying any string encodings not to be considered. The corresponding value for this key is an `NSArray` of `NSNumber` objects that contain `NSStringEncoding` values. If this option is unspecified, no additional string encodings are removed from consideration.
    ///
    ///
    pub static NSStringEncodingDetectionDisallowedEncodingsKey:
        &'static NSStringEncodingDetectionOptionsKey;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Option specifying whether to only consider suggested string encodings. Use this only if you specify a value for `NSStringEncodingDetectionSuggestedEncodingsKey`. The corresponding value for this key is an `NSNumber` object containing a Boolean value. By default, this value is `@(NO)`.
    ///
    ///
    pub static NSStringEncodingDetectionUseOnlySuggestedEncodingsKey:
        &'static NSStringEncodingDetectionOptionsKey;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Option specifying whether to allow lossy string conversion. The corresponding value for this key is an `NSNumber` object containing a Boolean value. If `@(NO)`, the a lossy string encoding may not be chosen. By default, this value is `@(YES)`.
    ///
    ///
    pub static NSStringEncodingDetectionAllowLossyKey: &'static NSStringEncodingDetectionOptionsKey;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Option specifying whether to consider string encodings corresponding to Windows codepage numbers. The corresponding value for this key is an `NSNumber` object containing a Boolean value. If `@(YES)`, Windows string encodings are removed from consideration. By default, this value is `@(NO)`.
    ///
    ///
    pub static NSStringEncodingDetectionFromWindowsKey:
        &'static NSStringEncodingDetectionOptionsKey;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Option specifying the string used to substitute for any unsupported characters when converting to a lossy string encoding. If a `@(NO)` value is specified for `NSStringEncodingDetectionAllowLossyKey`, this option has no effect. The corresponding value for this key is an `NSString` object. By default, this value is `U+FFFD`.
    ///
    ///
    pub static NSStringEncodingDetectionLossySubstitutionKey:
        &'static NSStringEncodingDetectionOptionsKey;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Option specifying the likely two-letter ISO 639-1 language code for the converted string. Use this when you have prior knowledge about the expected language of the converted string. The corresponding value for this key is an `NSString` object. If no value is specified, the language of the converted string is not considered.
    ///
    ///
    pub static NSStringEncodingDetectionLikelyLanguageKey:
        &'static NSStringEncodingDetectionOptionsKey;
}

/// NSStringEncodingDetection.
impl NSString {
    extern_methods!(
        #[cfg(all(feature = "NSData", feature = "NSDictionary"))]
        /// # Safety
        ///
        /// - `opts` generic should be of the correct type.
        /// - `used_lossy_conversion` must be a valid pointer or null.
        #[unsafe(method(stringEncodingForData:encodingOptions:convertedString:usedLossyConversion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringEncodingForData_encodingOptions_convertedString_usedLossyConversion(
            data: &NSData,
            opts: Option<&NSDictionary<NSStringEncodingDetectionOptionsKey, AnyObject>>,
            string: Option<&mut Option<Retained<NSString>>>,
            used_lossy_conversion: *mut Bool,
        ) -> NSStringEncoding;
    );
}

/// NSItemProvider.
impl NSString {
    extern_methods!();
}

#[cfg(feature = "NSItemProvider")]
extern_conformance!(
    unsafe impl NSItemProviderReading for NSString {}
);

#[cfg(feature = "NSItemProvider")]
extern_conformance!(
    unsafe impl NSItemProviderWriting for NSString {}
);

extern_class!(
    /// A dynamic plain-text Unicode string object.
    ///
    /// ## Overview
    ///
    /// In Swift, you can use this type instead of a [`String`](https://developer.apple.com/documentation/swift/string) in cases that require reference semantics.
    ///
    /// The `NSMutableString` class declares the programmatic interface to an object that manages a mutable string‚Äîthat is, a string whose contents can be edited‚Äîthat conceptually represents an array of Unicode characters. To construct and manage an immutable string‚Äîor a string that cannot be changed after it has been created‚Äîuse an object of the [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) class.
    ///
    /// The `NSMutableString` class adds one primitive method‚Äî[`replaceCharactersInRange:withString:`](https://developer.apple.com/documentation/foundation/nsmutablestring/replacecharacters(in:with:))‚Äîto the basic string-handling behavior inherited from `NSString`. All other methods that modify a string work through this method. For example, [`insertString:atIndex:`](https://developer.apple.com/documentation/foundation/nsmutablestring/insert(_:at:)) simply replaces the characters in a range of `0` length, while [`deleteCharactersInRange:`](https://developer.apple.com/documentation/foundation/nsmutablestring/deletecharacters(in:)) replaces the characters in a given range with no characters.
    ///
    /// NSMutableString is ‚Äútoll-free bridged‚Äù with its Core Foundation counterpart, [`CFMutableStringRef`](https://developer.apple.com/documentation/corefoundation/cfmutablestring). See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information.
    ///
    ///
    #[unsafe(super(NSString, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMutableString;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSMutableString> for CFMutableString {
    #[inline]
    fn as_ref(&self) -> &NSMutableString {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFMutableString> for NSMutableString {
    #[inline]
    fn as_ref(&self) -> &CFMutableString {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSMutableString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSMutableString {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSMutableString {
    type Result = NSString;
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSMutableCopying for NSMutableString {}
);

#[cfg(feature = "NSObject")]
unsafe impl MutableCopyingHelper for NSMutableString {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSMutableString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSMutableString {}
);

impl NSMutableString {
    extern_methods!(
        #[cfg(feature = "NSRange")]
        #[unsafe(method(replaceCharactersInRange:withString:))]
        #[unsafe(method_family = none)]
        pub fn replaceCharactersInRange_withString(&self, range: NSRange, a_string: &NSString);
    );
}

/// Methods declared on superclass `NSString`.
impl NSMutableString {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSMutableString {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSMutableString {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSMutableStringExtensionMethods.
impl NSMutableString {
    extern_methods!(
        #[unsafe(method(insertString:atIndex:))]
        #[unsafe(method_family = none)]
        pub fn insertString_atIndex(&self, a_string: &NSString, loc: NSUInteger);

        #[cfg(feature = "NSRange")]
        #[unsafe(method(deleteCharactersInRange:))]
        #[unsafe(method_family = none)]
        pub fn deleteCharactersInRange(&self, range: NSRange);

        #[unsafe(method(appendString:))]
        #[unsafe(method_family = none)]
        pub fn appendString(&self, a_string: &NSString);

        #[unsafe(method(setString:))]
        #[unsafe(method_family = none)]
        pub fn setString(&self, a_string: &NSString);

        #[cfg(feature = "NSRange")]
        #[unsafe(method(replaceOccurrencesOfString:withString:options:range:))]
        #[unsafe(method_family = none)]
        pub fn replaceOccurrencesOfString_withString_options_range(
            &self,
            target: &NSString,
            replacement: &NSString,
            options: NSStringCompareOptions,
            search_range: NSRange,
        ) -> NSUInteger;

        #[cfg(feature = "NSRange")]
        /// # Safety
        ///
        /// `resulting_range` must be a valid pointer or null.
        #[unsafe(method(applyTransform:reverse:range:updatedRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn applyTransform_reverse_range_updatedRange(
            &self,
            transform: &NSStringTransform,
            reverse: bool,
            range: NSRange,
            resulting_range: NSRangePointer,
        ) -> bool;

        #[unsafe(method(initWithCapacity:))]
        #[unsafe(method_family = init)]
        pub fn initWithCapacity(
            this: Allocated<Self>,
            capacity: NSUInteger,
        ) -> Retained<NSMutableString>;

        #[unsafe(method(stringWithCapacity:))]
        #[unsafe(method_family = none)]
        pub fn stringWithCapacity(capacity: NSUInteger) -> Retained<NSMutableString>;
    );
}

extern "C" {
    /// `NSString` raises an `NSCharacterConversionException` if a string cannot be represented in a file-system or string encoding.
    #[cfg(feature = "NSObjCRuntime")]
    pub static NSCharacterConversionException: &'static NSExceptionName;
}

extern "C" {
    /// `NSString` raises an `NSParseErrorException` if a string cannot be parsed as a property list.
    #[cfg(feature = "NSObjCRuntime")]
    pub static NSParseErrorException: &'static NSExceptionName;
}

/// NSExtendedStringPropertyListParsing.
impl NSString {
    extern_methods!(
        #[unsafe(method(propertyList))]
        #[unsafe(method_family = none)]
        pub fn propertyList(&self) -> Retained<AnyObject>;

        #[cfg(feature = "NSDictionary")]
        #[unsafe(method(propertyListFromStringsFileFormat))]
        #[unsafe(method_family = none)]
        pub fn propertyListFromStringsFileFormat(&self) -> Option<Retained<NSDictionary>>;
    );
}

/// NSStringDeprecated.
impl NSString {
    extern_methods!(
        #[deprecated = "Use -cStringUsingEncoding: instead"]
        #[unsafe(method(cString))]
        #[unsafe(method_family = none)]
        pub fn cString(&self) -> *const c_char;

        #[deprecated = "Use -cStringUsingEncoding: instead"]
        #[unsafe(method(lossyCString))]
        #[unsafe(method_family = none)]
        pub fn lossyCString(&self) -> *const c_char;

        #[deprecated = "Use -lengthOfBytesUsingEncoding: instead"]
        #[unsafe(method(cStringLength))]
        #[unsafe(method_family = none)]
        pub fn cStringLength(&self) -> NSUInteger;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use -getCString:maxLength:encoding: instead"]
        #[unsafe(method(getCString:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getCString(&self, bytes: NonNull<c_char>);

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use -getCString:maxLength:encoding: instead"]
        #[unsafe(method(getCString:maxLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getCString_maxLength(&self, bytes: NonNull<c_char>, max_length: NSUInteger);

        #[cfg(feature = "NSRange")]
        /// # Safety
        ///
        /// - `bytes` must be a valid pointer.
        /// - `leftover_range` must be a valid pointer or null.
        #[deprecated = "Use -getCString:maxLength:encoding: instead"]
        #[unsafe(method(getCString:maxLength:range:remainingRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getCString_maxLength_range_remainingRange(
            &self,
            bytes: NonNull<c_char>,
            max_length: NSUInteger,
            a_range: NSRange,
            leftover_range: NSRangePointer,
        );

        #[deprecated = "Use -writeToFile:atomically:encoding:error: instead"]
        #[unsafe(method(writeToFile:atomically:))]
        #[unsafe(method_family = none)]
        pub fn writeToFile_atomically(&self, path: &NSString, use_auxiliary_file: bool) -> bool;

        #[cfg(feature = "NSURL")]
        #[deprecated = "Use -writeToURL:atomically:encoding:error: instead"]
        #[unsafe(method(writeToURL:atomically:))]
        #[unsafe(method_family = none)]
        pub fn writeToURL_atomically(&self, url: &NSURL, atomically: bool) -> bool;

        #[deprecated = "Use -initWithContentsOfFile:encoding:error: instead"]
        #[unsafe(method(initWithContentsOfFile:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile(
            this: Allocated<Self>,
            path: &NSString,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSURL")]
        #[deprecated = "Use -initWithContentsOfURL:encoding:error: instead"]
        #[unsafe(method(initWithContentsOfURL:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL(this: Allocated<Self>, url: &NSURL) -> Option<Retained<Self>>;

        #[deprecated = "Use +stringWithContentsOfFile:encoding:error: instead"]
        #[unsafe(method(stringWithContentsOfFile:))]
        #[unsafe(method_family = none)]
        pub fn stringWithContentsOfFile(path: &NSString) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSURL")]
        #[deprecated = "Use +stringWithContentsOfURL:encoding:error: instead"]
        #[unsafe(method(stringWithContentsOfURL:))]
        #[unsafe(method_family = none)]
        pub fn stringWithContentsOfURL(url: &NSURL) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use -initWithCString:encoding: instead"]
        #[unsafe(method(initWithCStringNoCopy:length:freeWhenDone:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCStringNoCopy_length_freeWhenDone(
            this: Allocated<Self>,
            bytes: NonNull<c_char>,
            length: NSUInteger,
            free_buffer: bool,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use -initWithCString:encoding: instead"]
        #[unsafe(method(initWithCString:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCString_length(
            this: Allocated<Self>,
            bytes: NonNull<c_char>,
            length: NSUInteger,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use -initWithCString:encoding: instead"]
        #[unsafe(method(initWithCString:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCString(
            this: Allocated<Self>,
            bytes: NonNull<c_char>,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use +stringWithCString:encoding:"]
        #[unsafe(method(stringWithCString:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithCString_length(
            bytes: NonNull<c_char>,
            length: NSUInteger,
        ) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use +stringWithCString:encoding: instead"]
        #[unsafe(method(stringWithCString:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithCString(bytes: NonNull<c_char>) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[unsafe(method(getCharacters:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getCharacters(&self, buffer: NonNull<unichar>);
    );
}

/// Methods declared on superclass `NSString`.
///
/// NSStringDeprecated.
impl NSMutableString {
    extern_methods!(
        #[deprecated = "Use -initWithContentsOfFile:encoding:error: instead"]
        #[unsafe(method(initWithContentsOfFile:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile(
            this: Allocated<Self>,
            path: &NSString,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSURL")]
        #[deprecated = "Use -initWithContentsOfURL:encoding:error: instead"]
        #[unsafe(method(initWithContentsOfURL:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL(this: Allocated<Self>, url: &NSURL) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use -initWithCString:encoding: instead"]
        #[unsafe(method(initWithCStringNoCopy:length:freeWhenDone:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCStringNoCopy_length_freeWhenDone(
            this: Allocated<Self>,
            bytes: NonNull<c_char>,
            length: NSUInteger,
            free_buffer: bool,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use -initWithCString:encoding: instead"]
        #[unsafe(method(initWithCString:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCString_length(
            this: Allocated<Self>,
            bytes: NonNull<c_char>,
            length: NSUInteger,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[deprecated = "Use -initWithCString:encoding: instead"]
        #[unsafe(method(initWithCString:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCString(
            this: Allocated<Self>,
            bytes: NonNull<c_char>,
        ) -> Option<Retained<Self>>;
    );
}

extern_class!(
    #[unsafe(super(NSString, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSSimpleCString;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSSimpleCString {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSSimpleCString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSSimpleCString {}
);

impl NSSimpleCString {
    extern_methods!();
}

/// Methods declared on superclass `NSString`.
impl NSSimpleCString {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSSimpleCString {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSSimpleCString {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    #[unsafe(super(NSSimpleCString, NSString, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSConstantString;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSConstantString {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSConstantString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSConstantString {}
);

impl NSConstantString {
    extern_methods!();
}

/// Methods declared on superclass `NSString`.
impl NSConstantString {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSConstantString {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSConstantString {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
