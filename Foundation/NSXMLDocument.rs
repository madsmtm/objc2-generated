//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Type used to define the kind of document content.
///
/// ## Overview
///
/// For possible values, see doc:xmldocument/document_content_types.
///
///
/// Define what type of document this is.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSXMLDocumentContentKind(pub NSUInteger);
impl NSXMLDocumentContentKind {
    /// The default type of document content type, which is XML.
    #[doc(alias = "NSXMLDocumentXMLKind")]
    pub const XMLKind: Self = Self(0);
    /// The document output is XHTML.
    ///
    /// ## Discussion
    ///
    /// This is set automatically if the `NSXMLDocumentTidyHTML` option is set and NSXML detects HTML.
    ///
    ///
    #[doc(alias = "NSXMLDocumentXHTMLKind")]
    pub const XHTMLKind: Self = Self(1);
    /// Outputs empty tags in HTML without a close tag, such as `<br>`.
    #[doc(alias = "NSXMLDocumentHTMLKind")]
    pub const HTMLKind: Self = Self(2);
    /// Outputs the string value of the document by extracting the string values from all text nodes.
    #[doc(alias = "NSXMLDocumentTextKind")]
    pub const TextKind: Self = Self(3);
}

unsafe impl Encode for NSXMLDocumentContentKind {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSXMLDocumentContentKind {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An XML document as internalized into a logical tree structure.
    ///
    /// ## Overview
    ///
    /// An [`NSXMLDocument`](https://developer.apple.com/documentation/foundation/xmldocument) object can have multiple child nodes but only one element, the root element. Any other node must be a [`NSXMLNode`](https://developer.apple.com/documentation/foundation/xmlnode) object representing a comment or a processing instruction. If you attempt to add any other kind of child node to an [`NSXMLDocument`](https://developer.apple.com/documentation/foundation/xmldocument) object, such as an attribute, namespace, another document object, or an element other than the root, [`NSXMLDocument`](https://developer.apple.com/documentation/foundation/xmldocument) raises an exception. If you add a valid child node and that object already has a parent, [`NSXMLDocument`](https://developer.apple.com/documentation/foundation/xmldocument) raises an exception. An [`NSXMLDocument`](https://developer.apple.com/documentation/foundation/xmldocument) object may also have document-global attributes, such as XML version, character encoding, referenced DTD, and MIME type.
    ///
    /// The initializers of the [`NSXMLDocument`](https://developer.apple.com/documentation/foundation/xmldocument) class read an external source of XML, whether it be a local file or remote website, parse it, and process it into the tree representation. You can also construct an [`NSXMLDocument`](https://developer.apple.com/documentation/foundation/xmldocument) programmatically. There are accessor methods for getting and setting document attributes, methods for transforming documents using XSLT, a method for dynamically validating a document, and methods for printing out the content of an [`NSXMLDocument`](https://developer.apple.com/documentation/foundation/xmldocument) as XML, XHTML, HTML, or plain text.
    ///
    /// The [`NSXMLDocument`](https://developer.apple.com/documentation/foundation/xmldocument) class is thread-safe as long as any given instance is used only in one thread.
    ///
    /// ### Subclassing Notes
    ///
    /// #### Methods to Override
    ///
    /// To subclass `NSXMLDocument` you need to override the primary initializer, [`initWithData:options:error:`](https://developer.apple.com/documentation/foundation/xmldocument/init(data:options:)), and the methods listed below. In most cases, you need only invoke the superclass implementation, adding any subclass-specific code before or after the invocation, as necessary.
    ///
    /// - [`rootElement`](https://developer.apple.com/documentation/foundation/xmldocument/rootelement())
    ///
    /// - [`setChildren:`](https://developer.apple.com/documentation/foundation/xmldocument/setchildren(_:))
    ///
    /// - [`removeChildAtIndex:`](https://developer.apple.com/documentation/foundation/xmldocument/removechild(at:))
    ///
    /// - [`insertChild:atIndex:`](https://developer.apple.com/documentation/foundation/xmldocument/insertchild(_:at:))
    ///
    /// - [`characterEncoding`](https://developer.apple.com/documentation/foundation/xmldocument/characterencoding)
    ///
    /// - [`characterEncoding`](https://developer.apple.com/documentation/foundation/xmldocument/characterencoding)
    ///
    /// - [`documentContentKind`](https://developer.apple.com/documentation/foundation/xmldocument/documentcontentkind)
    ///
    /// - [`documentContentKind`](https://developer.apple.com/documentation/foundation/xmldocument/documentcontentkind)
    ///
    /// - [`DTD`](https://developer.apple.com/documentation/foundation/xmldocument/dtd)
    ///
    /// - [`MIMEType`](https://developer.apple.com/documentation/foundation/xmldocument/mimetype)
    ///
    /// - [`standalone`](https://developer.apple.com/documentation/foundation/xmldocument/isstandalone)
    ///
    /// - [`version`](https://developer.apple.com/documentation/foundation/xmldocument/version)
    ///
    /// - [`version`](https://developer.apple.com/documentation/foundation/xmldocument/version)
    ///
    /// By default `NSXMLDocument` implements the `NSObject` [`isEqual:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/isequal(_:)) method to perform a deep comparison: two `NSXMLDocument` objects are not considered equal unless they have the same name, same child nodes, same attributes, and so on. The comparison does not consider the parent node (and hence the node’s location). If you want a different standard of comparison, override `isEqual:`.
    ///
    /// #### Special Considerations
    ///
    /// Because of the architecture and data model of NSXML, when it parses and processes a source of XML it cannot know about your subclass unless you override the class method [`replacementClassForClass:`](https://developer.apple.com/documentation/foundation/xmldocument/replacementclass(for:)) to return your custom class in place of an `NSXML` class. If your custom class has no direct `NSXML` counterpart—for example, it is a subclass of `NSXMLNode` that represents CDATA sections—then you can walk the tree after it has been created and insert the new node where appropriate.
    ///
    ///
    /// An XML Document
    ///
    /// Note: if the application of a method would result in more than one element in the children array, an exception is thrown. Trying to add a document, namespace, attribute, or node with a parent also throws an exception. To add a node with a parent first detach or create a copy of it.
    #[unsafe(super(NSXMLNode, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSXMLNode")]
    pub struct NSXMLDocument;
);

#[cfg(all(feature = "NSObject", feature = "NSXMLNode"))]
extern_conformance!(
    unsafe impl NSCopying for NSXMLDocument {}
);

#[cfg(all(feature = "NSObject", feature = "NSXMLNode"))]
unsafe impl CopyingHelper for NSXMLDocument {
    type Result = Self;
}

#[cfg(feature = "NSXMLNode")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSXMLDocument {}
);

#[cfg(feature = "NSXMLNode")]
impl NSXMLDocument {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(
            feature = "NSError",
            feature = "NSString",
            feature = "NSXMLNodeOptions"
        ))]
        /// Returns a document created from either XML or HTML, if the HTMLTidy option is set. Parse errors are returned in
        /// <tt>
        /// error
        /// </tt>
        /// .
        #[unsafe(method(initWithXMLString:options:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithXMLString_options_error(
            this: Allocated<Self>,
            string: &NSString,
            mask: NSXMLNodeOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL", feature = "NSXMLNodeOptions"))]
        /// Returns a document created from the contents of an XML or HTML URL. Connection problems such as 404, parse errors are returned in
        /// <tt>
        /// error
        /// </tt>
        /// .
        #[unsafe(method(initWithContentsOfURL:options:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL_options_error(
            this: Allocated<Self>,
            url: &NSURL,
            mask: NSXMLNodeOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSData", feature = "NSError", feature = "NSXMLNodeOptions"))]
        /// Returns a document created from data. Parse errors are returned in
        /// <tt>
        /// error
        /// </tt>
        /// .
        #[unsafe(method(initWithData:options:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithData_options_error(
            this: Allocated<Self>,
            data: &NSData,
            mask: NSXMLNodeOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSXMLElement")]
        /// Returns a document with a single child, the root element.
        #[unsafe(method(initWithRootElement:))]
        #[unsafe(method_family = init)]
        pub fn initWithRootElement(
            this: Allocated<Self>,
            element: Option<&NSXMLElement>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `cls` probably has further requirements.
        #[unsafe(method(replacementClassForClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn replacementClassForClass(cls: &AnyClass) -> &'static AnyClass;

        #[cfg(feature = "NSString")]
        /// Sets the character encoding to an IANA type.
        #[unsafe(method(characterEncoding))]
        #[unsafe(method_family = none)]
        pub fn characterEncoding(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`characterEncoding`][Self::characterEncoding].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setCharacterEncoding:))]
        #[unsafe(method_family = none)]
        pub fn setCharacterEncoding(&self, character_encoding: Option<&NSString>);

        #[cfg(feature = "NSString")]
        /// Sets the XML version. Should be 1.0 or 1.1.
        #[unsafe(method(version))]
        #[unsafe(method_family = none)]
        pub fn version(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`version`][Self::version].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setVersion:))]
        #[unsafe(method_family = none)]
        pub fn setVersion(&self, version: Option<&NSString>);

        /// Set whether this document depends on an external DTD. If this option is set the standalone declaration will appear on output.
        #[unsafe(method(isStandalone))]
        #[unsafe(method_family = none)]
        pub fn isStandalone(&self) -> bool;

        /// Setter for [`isStandalone`][Self::isStandalone].
        #[unsafe(method(setStandalone:))]
        #[unsafe(method_family = none)]
        pub fn setStandalone(&self, standalone: bool);

        /// The kind of document.
        #[unsafe(method(documentContentKind))]
        #[unsafe(method_family = none)]
        pub fn documentContentKind(&self) -> NSXMLDocumentContentKind;

        /// Setter for [`documentContentKind`][Self::documentContentKind].
        #[unsafe(method(setDocumentContentKind:))]
        #[unsafe(method_family = none)]
        pub fn setDocumentContentKind(&self, document_content_kind: NSXMLDocumentContentKind);

        #[cfg(feature = "NSString")]
        /// Set the MIME type, eg text/xml.
        #[unsafe(method(MIMEType))]
        #[unsafe(method_family = none)]
        pub fn MIMEType(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`MIMEType`][Self::MIMEType].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setMIMEType:))]
        #[unsafe(method_family = none)]
        pub fn setMIMEType(&self, mime_type: Option<&NSString>);

        #[cfg(feature = "NSXMLDTD")]
        /// Set the associated DTD. This DTD will be output with the document.
        #[unsafe(method(DTD))]
        #[unsafe(method_family = none)]
        pub fn DTD(&self) -> Option<Retained<NSXMLDTD>>;

        #[cfg(feature = "NSXMLDTD")]
        /// Setter for [`DTD`][Self::DTD].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setDTD:))]
        #[unsafe(method_family = none)]
        pub fn setDTD(&self, dtd: Option<&NSXMLDTD>);

        #[cfg(feature = "NSXMLElement")]
        /// Set the root element. Removes all other children including comments and processing-instructions.
        #[unsafe(method(setRootElement:))]
        #[unsafe(method_family = none)]
        pub fn setRootElement(&self, root: &NSXMLElement);

        #[cfg(feature = "NSXMLElement")]
        /// The root element.
        #[unsafe(method(rootElement))]
        #[unsafe(method_family = none)]
        pub fn rootElement(&self) -> Option<Retained<NSXMLElement>>;

        /// Inserts a child at a particular index.
        #[unsafe(method(insertChild:atIndex:))]
        #[unsafe(method_family = none)]
        pub fn insertChild_atIndex(&self, child: &NSXMLNode, index: NSUInteger);

        #[cfg(feature = "NSArray")]
        /// Insert several children at a particular index.
        #[unsafe(method(insertChildren:atIndex:))]
        #[unsafe(method_family = none)]
        pub fn insertChildren_atIndex(&self, children: &NSArray<NSXMLNode>, index: NSUInteger);

        /// Removes a child at a particular index.
        #[unsafe(method(removeChildAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn removeChildAtIndex(&self, index: NSUInteger);

        #[cfg(feature = "NSArray")]
        /// Removes all existing children and replaces them with the new children. Set children to nil to simply remove all children.
        #[unsafe(method(setChildren:))]
        #[unsafe(method_family = none)]
        pub fn setChildren(&self, children: Option<&NSArray<NSXMLNode>>);

        /// Adds a child to the end of the existing children.
        #[unsafe(method(addChild:))]
        #[unsafe(method_family = none)]
        pub fn addChild(&self, child: &NSXMLNode);

        /// Replaces a child at a particular index with another child.
        #[unsafe(method(replaceChildAtIndex:withNode:))]
        #[unsafe(method_family = none)]
        pub fn replaceChildAtIndex_withNode(&self, index: NSUInteger, node: &NSXMLNode);

        #[cfg(feature = "NSData")]
        /// Invokes XMLDataWithOptions with NSXMLNodeOptionsNone.
        #[unsafe(method(XMLData))]
        #[unsafe(method_family = none)]
        pub fn XMLData(&self) -> Retained<NSData>;

        #[cfg(all(feature = "NSData", feature = "NSXMLNodeOptions"))]
        /// The representation of this node as it would appear in an XML document, encoded based on characterEncoding.
        #[unsafe(method(XMLDataWithOptions:))]
        #[unsafe(method_family = none)]
        pub fn XMLDataWithOptions(&self, options: NSXMLNodeOptions) -> Retained<NSData>;

        #[cfg(all(
            feature = "NSData",
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSString"
        ))]
        /// Applies XSLT with arguments (NSString key/value pairs) to this document, returning a new document.
        #[unsafe(method(objectByApplyingXSLT:arguments:error:_))]
        #[unsafe(method_family = none)]
        pub fn objectByApplyingXSLT_arguments_error(
            &self,
            xslt: &NSData,
            arguments: Option<&NSDictionary<NSString, NSString>>,
        ) -> Result<Retained<AnyObject>, Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSError", feature = "NSString"))]
        /// Applies XSLT as expressed by a string with arguments (NSString key/value pairs) to this document, returning a new document.
        #[unsafe(method(objectByApplyingXSLTString:arguments:error:_))]
        #[unsafe(method_family = none)]
        pub fn objectByApplyingXSLTString_arguments_error(
            &self,
            xslt: &NSString,
            arguments: Option<&NSDictionary<NSString, NSString>>,
        ) -> Result<Retained<AnyObject>, Retained<NSError>>;

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL"
        ))]
        /// Applies the XSLT at a URL with arguments (NSString key/value pairs) to this document, returning a new document. Error may contain a connection error from the URL.
        #[unsafe(method(objectByApplyingXSLTAtURL:arguments:error:_))]
        #[unsafe(method_family = none)]
        pub fn objectByApplyingXSLTAtURL_arguments_error(
            &self,
            xslt_url: &NSURL,
            argument: Option<&NSDictionary<NSString, NSString>>,
        ) -> Result<Retained<AnyObject>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(validateAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub fn validateAndReturnError(&self) -> Result<(), Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSXMLNode`.
#[cfg(feature = "NSXMLNode")]
impl NSXMLDocument {
    extern_methods!(
        /// Invokes
        ///
        /// ```text
        ///  initWithKind:options:
        /// ```
        ///
        /// with options set to NSXMLNodeOptionsNone
        #[unsafe(method(initWithKind:))]
        #[unsafe(method_family = init)]
        pub fn initWithKind(this: Allocated<Self>, kind: NSXMLNodeKind) -> Retained<Self>;

        #[cfg(feature = "NSXMLNodeOptions")]
        /// Inits a node with fidelity options as description NSXMLNodeOptions.h
        #[unsafe(method(initWithKind:options:))]
        #[unsafe(method_family = init)]
        pub fn initWithKind_options(
            this: Allocated<Self>,
            kind: NSXMLNodeKind,
            options: NSXMLNodeOptions,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSXMLNode")]
impl NSXMLDocument {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

#[cfg(feature = "NSXMLNode")]
impl DefaultRetained for NSXMLDocument {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
