//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Reading options that can be set by the [`initWithURL:options:error:`](https://developer.apple.com/documentation/foundation/filewrapper/init(url:options:)) and [`readFromURL:options:error:`](https://developer.apple.com/documentation/foundation/filewrapper/read(from:options:)) methods.
///
/// ## Overview
///
/// You can use the `NSFileWrapperReadingImmediate` and `NSFileWrapperReadingWithoutMapping` reading options together to take an exact snapshot of a file-system hierarchy that is safe from all errors (including the ones mentioned above) once reading has succeeded. If reading with both options succeeds, then subsequent invocations of the methods listed in the comment for the `NSFileWrapperReadingImmediate` reading option to the receiver and all its descendant file wrappers will never fail. However, note that reading with both options together is expensive in terms of both I/O and memory for large files, or directories containing large files, or even directories containing many small files.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSFileWrapperReadingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSFileWrapperReadingOptions: NSUInteger {
/// The option to read files immediately after creating a file wrapper.
///
/// ## Discussion
///
/// When you create a file wrapper and pass the [`NSFileWrapperReadingImmediate`](https://developer.apple.com/documentation/foundation/filewrapper/readingoptions/immediate) reading option, the content of the file is read immediately. Otherwise, file content is read only when requested, such as by accessing the [`regularFileContents`](https://developer.apple.com/documentation/foundation/filewrapper/regularfilecontents), [`fileWrappers`](https://developer.apple.com/documentation/foundation/filewrapper/filewrappers), [`serializedRepresentation`](https://developer.apple.com/documentation/foundation/filewrapper/serializedrepresentation), or [`symbolicLinkDestinationURL`](https://developer.apple.com/documentation/foundation/filewrapper/symboliclinkdestinationurl) properties.
///
/// Reading a file immediately rather than lazily can help mitigate against reading errors caused by the user moving or deleting the file after a file wrapper is created. However, passing this option can result in unnecessary disk or network access—particularly when opening a document file package, which causes all of its directory contents to be enumerated and read preemptively.
///
/// Even when [`NSFileWrapperReadingImmediate`](https://developer.apple.com/documentation/foundation/filewrapper/readingoptions/immediate) is specified, [`NSFileWrapper`](https://developer.apple.com/documentation/foundation/filewrapper) may not read the contents of some file packages immediately. For example, because the contents of bundles are immutable to the user, [`NSFileWrapper`](https://developer.apple.com/documentation/foundation/filewrapper) may read the children of such a directory lazily as a performance optimization.
///
/// You can use this option to take a snapshot of a file or folder for writing later. For example, an application like TextEdit can use this option when creating new file wrappers to represent attachments that the user creates by copying and pasting or dragging and dropping from the Finder to a TextEdit document.
///
///
        #[doc(alias = "NSFileWrapperReadingImmediate")]
        const Immediate = 1<<0;
/// Whether file mapping for regular file wrappers is disallowed.
///
/// ## Discussion
///
/// You can use this option to keep `NSFileWrapper` from memory-mapping files. This is useful if you want to make sure your application doesn’t hold files open (mapped files are open files), therefore preventing the user from ejecting DVDs, unmounting disk partitions, or unmounting disk images. In macOS 10.6 and later, `NSFileWrapper` memory-maps files that are on internal drives only. It never memory-maps files on external drives or network volumes, regardless of whether this option is used.
///
///
        #[doc(alias = "NSFileWrapperReadingWithoutMapping")]
        const WithoutMapping = 1<<1;
    }
}

unsafe impl Encode for NSFileWrapperReadingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFileWrapperReadingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Writing options that can be set by the [`writeToURL:options:originalContentsURL:error:`](https://developer.apple.com/documentation/foundation/filewrapper/write(to:options:originalcontentsurl:)) method.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSFileWrapperWritingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSFileWrapperWritingOptions: NSUInteger {
/// Whether writing is done atomically.
///
/// ## Discussion
///
/// You can use this option to ensure that, when overwriting a file package, the overwriting either completely succeeds or completely fails, with no possibility of leaving the file package in an inconsistent state. Because this option causes additional I/O, you shouldn’t use it unnecessarily. For example, don’t use this option in an override of `-[NSDocument` [`writeToURL:ofType:error:`](https://developer.apple.com/documentation/appkit/nsdocument/write(to:oftype:))`]`, because `NSDocument` safe-saving is already done atomically.
///
///
        #[doc(alias = "NSFileWrapperWritingAtomic")]
        const Atomic = 1<<0;
/// Whether descendant file wrappers’[`filename`](https://developer.apple.com/documentation/foundation/filewrapper/filename) properties are set if the writing succeeds.
///
/// ## Discussion
///
/// This option is necessary when your application passes a URL in the `originalContentsURL` parameter to the [`writeToURL:options:originalContentsURL:error:`](https://developer.apple.com/documentation/foundation/filewrapper/write(to:options:originalcontentsurl:)) method. Without using this option (and reusing child file wrappers properly), subsequent invocations of [`writeToURL:options:originalContentsURL:error:`](https://developer.apple.com/documentation/foundation/filewrapper/write(to:options:originalcontentsurl:)) would not be able to reliably create hard links in a new file package, because the record of names in the old file package would be out of date.
///
///
        #[doc(alias = "NSFileWrapperWritingWithNameUpdating")]
        const WithNameUpdating = 1<<1;
    }
}

unsafe impl Encode for NSFileWrapperWritingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFileWrapperWritingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A representation of a node (a file, directory, or symbolic link) in the file system.
    ///
    /// ## Overview
    ///
    /// The [`NSFileWrapper`](https://developer.apple.com/documentation/foundation/filewrapper) class provides access to the attributes and contents of file system nodes. A file system node is a file, directory, or symbolic link. Instances of this class are known as file wrappers.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Starting in macOS 10.7, [`NSFileWrapper`](https://developer.apple.com/documentation/foundation/filewrapper) moved from Application Kit to Foundation. As a result of this the `icon`, and `setIcon:` methods have moved to a new category of [`NSFileWrapper`](https://developer.apple.com/documentation/foundation/filewrapper) that remains in Application Kit.
    ///
    ///
    ///
    /// </div>
    /// File wrappers represent a file system node as an object that can be displayed as an image (and possibly edited in place), saved to the file system, or transmitted to another application.
    ///
    /// There are three types of file wrappers:
    ///
    /// - Regular-file file wrapper: Represents a regular file.
    ///
    /// - Directory file wrapper: Represents a directory.
    ///
    /// - Symbolic-link file wrapper: Represents a symbolic link.
    ///
    /// A file wrapper has these attributes:
    ///
    /// - Filename. Name of the file system node the file wrapper represents.
    ///
    /// - file-system attributes. See [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager) for information on the contents of the `attributes` dictionary.
    ///
    /// - Regular-file contents. Applicable only to regular-file file wrappers.
    ///
    /// - File wrappers. Applicable only to directory file wrappers.
    ///
    /// - Destination node. Applicable only to symbolic-link file wrappers.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSFileWrapper;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSFileWrapper {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSFileWrapper {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSFileWrapper {}
);

impl NSFileWrapper {
    extern_methods!(
        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithURL:options:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithURL_options_error(
            this: Allocated<Self>,
            url: &NSURL,
            options: NSFileWrapperReadingOptions,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(initDirectoryWithFileWrappers:))]
        #[unsafe(method_family = init)]
        pub fn initDirectoryWithFileWrappers(
            this: Allocated<Self>,
            children_by_preferred_name: &NSDictionary<NSString, NSFileWrapper>,
        ) -> Retained<Self>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(initRegularFileWithContents:))]
        #[unsafe(method_family = init)]
        pub fn initRegularFileWithContents(
            this: Allocated<Self>,
            contents: &NSData,
        ) -> Retained<Self>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(initSymbolicLinkWithDestinationURL:))]
        #[unsafe(method_family = init)]
        pub fn initSymbolicLinkWithDestinationURL(
            this: Allocated<Self>,
            url: &NSURL,
        ) -> Retained<Self>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(initWithSerializedRepresentation:))]
        #[unsafe(method_family = init)]
        pub fn initWithSerializedRepresentation(
            this: Allocated<Self>,
            serialize_representation: &NSData,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `in_coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            in_coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(isDirectory))]
        #[unsafe(method_family = none)]
        pub fn isDirectory(&self) -> bool;

        #[unsafe(method(isRegularFile))]
        #[unsafe(method_family = none)]
        pub fn isRegularFile(&self) -> bool;

        #[unsafe(method(isSymbolicLink))]
        #[unsafe(method_family = none)]
        pub fn isSymbolicLink(&self) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(preferredFilename))]
        #[unsafe(method_family = none)]
        pub fn preferredFilename(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`preferredFilename`][Self::preferredFilename].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setPreferredFilename:))]
        #[unsafe(method_family = none)]
        pub fn setPreferredFilename(&self, preferred_filename: Option<&NSString>);

        #[cfg(feature = "NSString")]
        #[unsafe(method(filename))]
        #[unsafe(method_family = none)]
        pub fn filename(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`filename`][Self::filename].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setFilename:))]
        #[unsafe(method_family = none)]
        pub fn setFilename(&self, filename: Option<&NSString>);

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(fileAttributes))]
        #[unsafe(method_family = none)]
        pub fn fileAttributes(&self) -> Retained<NSDictionary<NSString, AnyObject>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// Setter for [`fileAttributes`][Self::fileAttributes].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `file_attributes` generic should be of the correct type.
        #[unsafe(method(setFileAttributes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFileAttributes(&self, file_attributes: &NSDictionary<NSString, AnyObject>);

        #[cfg(feature = "NSURL")]
        #[unsafe(method(matchesContentsOfURL:))]
        #[unsafe(method_family = none)]
        pub fn matchesContentsOfURL(&self, url: &NSURL) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(readFromURL:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn readFromURL_options_error(
            &self,
            url: &NSURL,
            options: NSFileWrapperReadingOptions,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(writeToURL:options:originalContentsURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn writeToURL_options_originalContentsURL_error(
            &self,
            url: &NSURL,
            options: NSFileWrapperWritingOptions,
            original_contents_url: Option<&NSURL>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(serializedRepresentation))]
        #[unsafe(method_family = none)]
        pub fn serializedRepresentation(&self) -> Option<Retained<NSData>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(addFileWrapper:))]
        #[unsafe(method_family = none)]
        pub fn addFileWrapper(&self, child: &NSFileWrapper) -> Retained<NSString>;

        #[cfg(all(feature = "NSData", feature = "NSString"))]
        #[unsafe(method(addRegularFileWithContents:preferredFilename:))]
        #[unsafe(method_family = none)]
        pub fn addRegularFileWithContents_preferredFilename(
            &self,
            data: &NSData,
            file_name: &NSString,
        ) -> Retained<NSString>;

        #[unsafe(method(removeFileWrapper:))]
        #[unsafe(method_family = none)]
        pub fn removeFileWrapper(&self, child: &NSFileWrapper);

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(fileWrappers))]
        #[unsafe(method_family = none)]
        pub fn fileWrappers(&self) -> Option<Retained<NSDictionary<NSString, NSFileWrapper>>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(keyForFileWrapper:))]
        #[unsafe(method_family = none)]
        pub fn keyForFileWrapper(&self, child: &NSFileWrapper) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(regularFileContents))]
        #[unsafe(method_family = none)]
        pub fn regularFileContents(&self) -> Option<Retained<NSData>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(symbolicLinkDestinationURL))]
        #[unsafe(method_family = none)]
        pub fn symbolicLinkDestinationURL(&self) -> Option<Retained<NSURL>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSFileWrapper {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSFileWrapper {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSDeprecated.
impl NSFileWrapper {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[deprecated = "Use -initWithURL:options:error: instead."]
        #[unsafe(method(initWithPath:))]
        #[unsafe(method_family = init)]
        pub fn initWithPath(this: Allocated<Self>, path: &NSString) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -initSymbolicLinkWithDestinationURL: and -setPreferredFileName:, if necessary, instead."]
        #[unsafe(method(initSymbolicLinkWithDestination:))]
        #[unsafe(method_family = init)]
        pub fn initSymbolicLinkWithDestination(
            this: Allocated<Self>,
            path: &NSString,
        ) -> Retained<Self>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -matchesContentsOfURL: instead."]
        #[unsafe(method(needsToBeUpdatedFromPath:))]
        #[unsafe(method_family = none)]
        pub fn needsToBeUpdatedFromPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -readFromURL:options:error: instead."]
        #[unsafe(method(updateFromPath:))]
        #[unsafe(method_family = none)]
        pub fn updateFromPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -writeToURL:options:originalContentsURL:error: instead."]
        #[unsafe(method(writeToFile:atomically:updateFilenames:))]
        #[unsafe(method_family = none)]
        pub fn writeToFile_atomically_updateFilenames(
            &self,
            path: &NSString,
            atomic_flag: bool,
            update_filenames_flag: bool,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[deprecated = "Instantiate a new NSFileWrapper with -initWithURL:options:error:, send it -setPreferredFileName: if necessary, then use -addFileWrapper: instead."]
        #[unsafe(method(addFileWithPath:))]
        #[unsafe(method_family = none)]
        pub fn addFileWithPath(&self, path: &NSString) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Instantiate a new NSFileWrapper with -initWithSymbolicLinkDestinationURL:, send it -setPreferredFileName: if necessary, then use -addFileWrapper: instead."]
        #[unsafe(method(addSymbolicLinkWithDestination:preferredFilename:))]
        #[unsafe(method_family = none)]
        pub fn addSymbolicLinkWithDestination_preferredFilename(
            &self,
            path: &NSString,
            filename: &NSString,
        ) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -symbolicLinkDestinationURL instead."]
        #[unsafe(method(symbolicLinkDestination))]
        #[unsafe(method_family = none)]
        pub fn symbolicLinkDestination(&self) -> Retained<NSString>;
    );
}
