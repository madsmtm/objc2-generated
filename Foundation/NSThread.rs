//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use crate::common::*;
use crate::Foundation;

extern_class!(
    #[derive(PartialEq, Eq, Hash)]
    pub struct NSThread;

    unsafe impl ClassType for NSThread {
        type Super = NSObject;
    }
);

extern_methods!(
    #[cfg(feature = "Foundation_NSThread")]
    unsafe impl NSThread {
        #[method_id(@__retain_semantics Other currentThread)]
        pub fn currentThread() -> Id<Foundation::NSThread, Shared>;

        #[method(detachNewThreadWithBlock:)]
        pub unsafe fn detachNewThreadWithBlock(block: &Block<(), ()>);

        #[method(detachNewThreadSelector:toTarget:withObject:)]
        pub unsafe fn detachNewThreadSelector_toTarget_withObject(
            selector: Sel,
            target: &Object,
            argument: Option<&Object>,
        );

        #[method(isMultiThreaded)]
        pub fn isMultiThreaded() -> bool;

        #[cfg(feature = "Foundation_NSMutableDictionary")]
        #[method_id(@__retain_semantics Other threadDictionary)]
        pub unsafe fn threadDictionary(&self) -> Id<Foundation::NSMutableDictionary, Owned>;

        #[cfg(feature = "Foundation_NSDate")]
        #[method(sleepUntilDate:)]
        pub unsafe fn sleepUntilDate(date: &Foundation::NSDate);

        #[method(sleepForTimeInterval:)]
        pub unsafe fn sleepForTimeInterval(ti: NSTimeInterval);

        #[method(exit)]
        pub unsafe fn exit();

        #[method(qualityOfService)]
        pub unsafe fn qualityOfService(&self) -> NSQualityOfService;

        #[method(setQualityOfService:)]
        pub unsafe fn setQualityOfService(&self, qualityOfService: NSQualityOfService);

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSNumber"))]
        #[method_id(@__retain_semantics Other callStackReturnAddresses)]
        pub unsafe fn callStackReturnAddresses(
        ) -> Id<Foundation::NSArray<Foundation::NSNumber>, Shared>;

        #[cfg(all(feature = "Foundation_NSArray", feature = "Foundation_NSString"))]
        #[method_id(@__retain_semantics Other callStackSymbols)]
        pub unsafe fn callStackSymbols() -> Id<Foundation::NSArray<Foundation::NSString>, Shared>;

        #[cfg(feature = "Foundation_NSString")]
        #[method_id(@__retain_semantics Other name)]
        pub fn name(&self) -> Option<Id<Foundation::NSString, Shared>>;

        #[cfg(feature = "Foundation_NSString")]
        #[method(setName:)]
        pub unsafe fn setName(&self, name: Option<&Foundation::NSString>);

        #[method(stackSize)]
        pub unsafe fn stackSize(&self) -> NSUInteger;

        #[method(setStackSize:)]
        pub unsafe fn setStackSize(&self, stackSize: NSUInteger);

        #[method_id(@__retain_semantics Other mainThread)]
        pub fn mainThread() -> Id<Foundation::NSThread, Shared>;

        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Option<Allocated<Self>>) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics Init initWithTarget:selector:object:)]
        pub unsafe fn initWithTarget_selector_object(
            this: Option<Allocated<Self>>,
            target: &Object,
            selector: Sel,
            argument: Option<&Object>,
        ) -> Id<Self, Shared>;

        #[method_id(@__retain_semantics Init initWithBlock:)]
        pub unsafe fn initWithBlock(
            this: Option<Allocated<Self>>,
            block: &Block<(), ()>,
        ) -> Id<Self, Shared>;

        #[method(isExecuting)]
        pub unsafe fn isExecuting(&self) -> bool;

        #[method(isFinished)]
        pub unsafe fn isFinished(&self) -> bool;

        #[method(isCancelled)]
        pub unsafe fn isCancelled(&self) -> bool;

        #[method(cancel)]
        pub unsafe fn cancel(&self);

        #[method(start)]
        pub unsafe fn start(&self);

        #[method(main)]
        pub unsafe fn main(&self);
    }
);

extern_static!(NSWillBecomeMultiThreadedNotification: &'static Foundation::NSNotificationName);

extern_static!(NSDidBecomeSingleThreadedNotification: &'static Foundation::NSNotificationName);

extern_static!(NSThreadWillExitNotification: &'static Foundation::NSNotificationName);
