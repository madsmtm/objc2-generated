//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// The version of the Foundation framework in which `NSFileManager` first supported resource forks.
pub const NSFoundationVersionWithFileManagerResourceForkSupport: c_uint = 412;
/// Keys in dictionaries used to get and set file attributes.
///
/// ## Discussion
///
/// These keys are used with the methods listed in the Getting and Setting Attributes topic of [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager).
///
///
// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSFileAttributeKey = NSString;

/// Values representing a file’s type attribute.
///
/// ## Discussion
///
/// These strings are the possible values for the [`NSFileType`](https://developer.apple.com/documentation/foundation/fileattributekey/type) attribute key contained in the dictionary object returned by [`attributesOfItemAtPath:error:`](https://developer.apple.com/documentation/foundation/filemanager/attributesofitem(atpath:)).
///
///
// NS_TYPED_ENUM
#[cfg(feature = "NSString")]
pub type NSFileAttributeType = NSString;

/// Protection level values that can be associated with a file attribute key.
///
/// ## Overview
///
/// These values are associated with the [`NSFileProtectionKey`](https://developer.apple.com/documentation/foundation/fileattributekey/protectionkey) key.
///
///
// NS_TYPED_ENUM
#[cfg(feature = "NSString")]
pub type NSFileProtectionType = NSString;

/// The name used to identify a File Provider service.
///
/// ## Discussion
///
/// The team providing the protocol also defines the name. To create a new service’s name:
///
/// - Use reverse domain name notation for the interfaces name (for example, `com.example.MyInterface`).
///
/// - (Optional) Incorporate versioning by appending a version number to the end of the name (`com.example.MyInterface.v2`).
///
/// For more information on defining a service’s protocol, see [Defining the Service’s Protocol](https://developer.apple.com/documentation/foundation/nsfileproviderservice#defining-the-services-protocol).
///
///
// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSFileProviderServiceName = NSString;

/// Options for enumerating mounted volumes with the [`mountedVolumeURLsIncludingResourceValuesForKeys:options:`](https://developer.apple.com/documentation/foundation/filemanager/mountedvolumeurls(includingresourcevaluesforkeys:options:)) method.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSVolumeEnumerationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSVolumeEnumerationOptions: NSUInteger {
/// The enumeration skips hidden volumes.
        #[doc(alias = "NSVolumeEnumerationSkipHiddenVolumes")]
        const SkipHiddenVolumes = 1<<1;
/// The enumeration produces file reference URLs rather than path-based URLs.
        #[doc(alias = "NSVolumeEnumerationProduceFileReferenceURLs")]
        const ProduceFileReferenceURLs = 1<<2;
    }
}

unsafe impl Encode for NSVolumeEnumerationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSVolumeEnumerationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for enumerating the contents of directories.
///
/// ## Overview
///
/// These options are used with the [`contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:`](https://developer.apple.com/documentation/foundation/filemanager/contentsofdirectory(at:includingpropertiesforkeys:options:)) method.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSDirectoryEnumerationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSDirectoryEnumerationOptions: NSUInteger {
/// An option to perform a shallow enumeration that doesn’t descend into directories.
        #[doc(alias = "NSDirectoryEnumerationSkipsSubdirectoryDescendants")]
        const SkipsSubdirectoryDescendants = 1<<0;
/// An option to treat packages like files and not descend into their contents.
        #[doc(alias = "NSDirectoryEnumerationSkipsPackageDescendants")]
        const SkipsPackageDescendants = 1<<1;
/// An option to skip hidden files.
        #[doc(alias = "NSDirectoryEnumerationSkipsHiddenFiles")]
        const SkipsHiddenFiles = 1<<2;
        #[doc(alias = "NSDirectoryEnumerationIncludesDirectoriesPostOrder")]
        const IncludesDirectoriesPostOrder = 1<<3;
        #[doc(alias = "NSDirectoryEnumerationProducesRelativePathURLs")]
        const ProducesRelativePathURLs = 1<<4;
    }
}

unsafe impl Encode for NSDirectoryEnumerationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSDirectoryEnumerationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for specifying the behavior of file replacement operations.
///
/// ## Overview
///
/// These options are used by [`replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:`](https://developer.apple.com/documentation/foundation/filemanager/replaceitem(at:withitemat:backupitemname:options:resultingitemurl:)).
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSFileManagerItemReplacementOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSFileManagerItemReplacementOptions: NSUInteger {
/// Only metadata from the new item is used, and metadata from the original item isn’t preserved (default).
        #[doc(alias = "NSFileManagerItemReplacementUsingNewMetadataOnly")]
        const UsingNewMetadataOnly = 1<<0;
/// The backup item remains in place after a successful replacement.
        #[doc(alias = "NSFileManagerItemReplacementWithoutDeletingBackupItem")]
        const WithoutDeletingBackupItem = 1<<1;
    }
}

unsafe impl Encode for NSFileManagerItemReplacementOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFileManagerItemReplacementOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants indicating the relationship between a directory and an item.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLRelationship(pub NSInteger);
impl NSURLRelationship {
    /// The directory contains the specified item.
    #[doc(alias = "NSURLRelationshipContains")]
    pub const Contains: Self = Self(0);
    /// The directory and the item are the same. This relationship occurs when the value of the [`NSURLFileResourceIdentifierKey`](https://developer.apple.com/documentation/foundation/urlresourcekey/fileresourceidentifierkey) is the same for the directory and item.
    #[doc(alias = "NSURLRelationshipSame")]
    pub const Same: Self = Self(1);
    /// The directory does not contain the item and is not the same as the item.
    #[doc(alias = "NSURLRelationshipOther")]
    pub const Other: Self = Self(2);
}

unsafe impl Encode for NSURLRelationship {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLRelationship {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options that specify the behavior of an unmount operation.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSFileManagerUnmountOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSFileManagerUnmountOptions: NSUInteger {
/// Specifies that all partitions on an unmountable disk should be unmounted.
///
/// ## Discussion
///
/// If the volume is on a partitioned disk, this option unmounts all volumes on that disk. Then, then the disk is ejected (if it is ejectable).
///
///
        #[doc(alias = "NSFileManagerUnmountAllPartitionsAndEjectDisk")]
        const AllPartitionsAndEjectDisk = 1<<0;
/// Specifies that no UI should accompany the unmount operation.
///
/// ## Discussion
///
/// If this option is not specified when calling [`unmountVolumeAtURL:options:completionHandler:`](https://developer.apple.com/documentation/foundation/filemanager/unmountvolume(at:options:completionhandler:)), any needed UI will delay completion of the completion handler.
///
///
        #[doc(alias = "NSFileManagerUnmountWithoutUI")]
        const WithoutUI = 1<<1;
    }
}

unsafe impl Encode for NSFileManagerUnmountOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFileManagerUnmountOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The process identifier of the process that prevented a volume from unmounting.
    ///
    /// ## Discussion
    ///
    /// If [`unmountVolumeAtURL:options:completionHandler:`](https://developer.apple.com/documentation/foundation/filemanager/unmountvolume(at:options:completionhandler:)) fails, the error sent to its completion handler will contain a `userInfo` dictionary with this string as one of its keys. The value is the process identifier of the process that prevented the unmounting, as an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber).
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileManagerUnmountDissentingProcessIdentifierErrorKey: &'static NSString;
}

extern "C" {
    /// Sent after the iCloud (“ubiquity”) identity has changed.
    ///
    /// ## Discussion
    ///
    /// The system generates this notification when the user logs into or out of an iCloud account or enables or disables the syncing of documents and data. This notification is your cue to update caches and any interface elements displaying iCloud–related content. For example, hide all references to iCloud files when the user logs out of iCloud.
    ///
    /// When your app receives this notification, get the new token from the [`ubiquityIdentityToken`](https://developer.apple.com/documentation/foundation/filemanager/ubiquityidentitytoken) instance property. The value of that token is `nil` if the user disabled iCloud or logged out. There is no `userInfo` dictionary.
    ///
    ///
    #[cfg(all(feature = "NSNotification", feature = "NSString"))]
    pub static NSUbiquityIdentityDidChangeNotification: &'static NSNotificationName;
}

/// An option set of the sync controls available for an item.
///
/// ## Overview
///
/// Get an instance of this type by calling [`resourceValues(forKeys:)`](https://developer.apple.com/documentation/foundation/url/resourcevalues(forkeys:)) on a [`URL`](https://developer.apple.com/documentation/foundation/url) instance (Swift) or [`getResourceValue:forKey:error:`](https://developer.apple.com/documentation/foundation/nsurl/getresourcevalue(_:forkey:)) on an [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) (Swift or Objective-C) and passing in the key [`NSURLUbiquitousItemSupportedSyncControlsKey`](https://developer.apple.com/documentation/foundation/urlresourcekey/ubiquitousitemsupportedsynccontrolskey).
///
///
/// An option set of the sync controls available for an item.
///
/// Get an instance of this type by calling ``URL/resourceValues(forKeys:)`` on a ``URL`` instance (Swift) or ``NSURL/getResourceValue:forKey:error:`` on an ``NSURL`` (Swift or Objective-C) and passing in the key ``NSURLUbiquitousItemSupportedSyncControlsKey``.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSFileManagerSupportedSyncControls(pub NSUInteger);
bitflags::bitflags! {
    impl NSFileManagerSupportedSyncControls: NSUInteger {
/// The file provider supports pausing the sync on the item.
/// The file provider supports pausing the sync on the item.
        #[doc(alias = "NSFileManagerSupportedSyncControlsPauseSync")]
        const PauseSync = 1<<0;
/// The file provider supports failing an upload if the local and server versions conflict.
/// The file provider supports failing an upload if the local and server versions conflict.
        #[doc(alias = "NSFileManagerSupportedSyncControlsFailUploadOnConflict")]
        const FailUploadOnConflict = 1<<1;
    }
}

unsafe impl Encode for NSFileManagerSupportedSyncControls {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFileManagerSupportedSyncControls {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The behaviors the file manager can apply to resolve conflicts when resuming a sync.
///
/// ## Overview
///
/// You use this type when calling [`resumeSyncForUbiquitousItemAtURL:withBehavior:completionHandler:`](https://developer.apple.com/documentation/foundation/filemanager/resumesyncforubiquitousitem(at:with:completionhandler:)) to resume synchronizing. In most situations, the [`NSFileManagerResumeSyncBehaviorPreserveLocalChanges`](https://developer.apple.com/documentation/foundation/nsfilemanagerresumesyncbehavior/preservelocalchanges) behavior is the best choice to avoid risk of data loss.
///
///
/// The behaviors the file manager can apply to resolve conflicts when resuming a sync.
///
/// You use this type when calling ``FileManager/resumeSyncForUbiquitousItem(at:with:completionHandler:)`` to resume synchronizing.
/// In most situations, the ``NSFileManagerResumeSyncBehavior/preserveLocalChanges`` behavior is the best choice to avoid risk of data loss.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSFileManagerResumeSyncBehavior(pub NSInteger);
impl NSFileManagerResumeSyncBehavior {
    /// Resumes synchronizing by uploading the local version of the file.
    ///
    /// ## Discussion
    ///
    /// If the server has a newer version, the server may create a conflict copy of the file, or may automatically pick the winner of the conflict. Apps can choose to implement conflict handling themselves by passing `NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict`.
    ///
    ///
    /// Resumes synchronizing by uploading the local version of the file.
    ///
    /// If the server has a newer version, the server may create a conflict copy of the file, or may automatically pick the winner of the conflict.
    /// Apps can choose to implement conflict handling themselves by passing `NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict`.
    #[doc(alias = "NSFileManagerResumeSyncBehaviorPreserveLocalChanges")]
    pub const PreserveLocalChanges: Self = Self(0);
    /// Resumes sync by first uploading the local version of the file, failing if the provider detects a conflict.
    ///
    /// ## Discussion
    ///
    /// If the upload succeeds, the sync resumes with the [`NSFileManagerResumeSyncBehaviorPreserveLocalChanges`](https://developer.apple.com/documentation/foundation/nsfilemanagerresumesyncbehavior/preservelocalchanges) behavior.
    ///
    /// If the provider detects a conflict, the upload fails with an  [`NSFileWriteUnknownError`](https://developer.apple.com/documentation/foundation/nsfilewriteunknownerror-c.enum.case), with the underlying error of [`localVersionConflictingWithServer`](https://developer.apple.com/documentation/fileprovider/nsfileprovidererror/localversionconflictingwithserver). In this case, the app needs to call [`fetchLatestRemoteVersionOfItemAtURL:completionHandler:`](https://developer.apple.com/documentation/foundation/filemanager/fetchlatestremoteversionofitem(at:completionhandler:)), rebase local changes on top of the newly fetched version to resolve the conflict, and try again to resume sync. This scenario is only available on paused items for which the file provider supports the fail-on-conflict behavior. To check that the file provider supports the behavior, get the [`NSURLUbiquitousItemSupportedSyncControlsKey`](https://developer.apple.com/documentation/foundation/urlresourcekey/ubiquitousitemsupportedsynccontrolskey) URL resource and verify that [`NSFileManagerSupportedSyncControlsFailUploadOnConflict`](https://developer.apple.com/documentation/foundation/nsfilemanagersupportedsynccontrols/failuploadonconflict) is `true`.
    ///
    ///
    /// Resumes sync by first uploading the local version of the file, failing if the provider detects a conflict.
    ///
    /// If the upload succeeds, the sync resumes with the ``preserveLocalChanges`` behavior.
    ///
    /// If the provider detects a conflict, the upload fails with an  ``NSFileWriteUnknownError-enum.case``, with the underlying error of
    /// <doc
    /// ://com.apple.documentation/documentation/FileProvider/NSFileProviderError/localVersionConflictingWithServer>.
    /// In this case, the app needs to call ``FileManager/fetchLatestRemoteVersionOfItem(at:completionHandler:)``, rebase local changes on top of the newly fetched version to resolve the conflict, and try again to resume sync.
    /// This scenario is only available on paused items for which the file provider supports the fail-on-conflict behavior.
    /// To check that the file provider supports the behavior, get the ``NSURLUbiquitousItemSupportedSyncControlsKey`` URL resource and verify that ``NSFileManagerSupportedSyncControls/failUploadOnConflict`` is `true`.
    #[doc(alias = "NSFileManagerResumeSyncBehaviorAfterUploadWithFailOnConflict")]
    pub const AfterUploadWithFailOnConflict: Self = Self(1);
    /// Resumes synchronizing by overwriting any local changes with the remote version of the file.
    ///
    /// ## Discussion
    ///
    /// If a conflict occurs, the file manager stores the local changes as an alternate version. Only use this behavior if you provide a separate means of resolving and merging conflicts.
    ///
    ///
    /// Resumes synchronizing by overwriting any local changes with the remote version of the file.
    ///
    /// If a conflict occurs, the file manager stores the local changes as an alternate version.
    /// Only use this behavior if you provide a separate means of resolving and merging conflicts.
    #[doc(alias = "NSFileManagerResumeSyncBehaviorDropLocalChanges")]
    pub const DropLocalChanges: Self = Self(2);
}

unsafe impl Encode for NSFileManagerResumeSyncBehavior {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSFileManagerResumeSyncBehavior {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The policies the file manager can apply to resolve conflicts when uploading a local version of a file.
/// The policies the file manager can apply to resolve conflicts when uploading a local version of a file.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSFileManagerUploadLocalVersionConflictPolicy(pub NSInteger);
impl NSFileManagerUploadLocalVersionConflictPolicy {
    /// Resolves the conflict using the policy defined by the file provider.
    /// Resolves the conflict using the policy defined by the file provider.
    #[doc(alias = "NSFileManagerUploadConflictPolicyDefault")]
    pub const ConflictPolicyDefault: Self = Self(0);
    /// Resolves the conflict by causing the upload to fail.
    ///
    /// ## Discussion
    ///
    /// This policy causes an upload to fail if the local version of a file, with any local changes applied, doesn’t match the server version. In this scenario, call [`fetchLatestRemoteVersionOfItemAtURL:completionHandler:`](https://developer.apple.com/documentation/foundation/filemanager/fetchlatestremoteversionofitem(at:completionhandler:)), rebase local changes on top of the newly fetched version, and retry the upload.
    ///
    /// This policy is only available on paused items for which the file provider supports the fail-on-conflict behavior. To check that the file provider supports the behavior, get the [`NSURLUbiquitousItemSupportedSyncControlsKey`](https://developer.apple.com/documentation/foundation/urlresourcekey/ubiquitousitemsupportedsynccontrolskey) URL resource and verify that [`NSFileManagerSupportedSyncControlsFailUploadOnConflict`](https://developer.apple.com/documentation/foundation/nsfilemanagersupportedsynccontrols/failuploadonconflict) is `true`.
    ///
    ///
    /// Resolves the conflict by causing the upload to fail.
    ///
    /// This policy causes an upload to fail if the local version of a file, with any local changes applied, doesn't match the server version.
    /// In this scenario, call ``FileManager/fetchLatestRemoteVersionOfItem(at:completionHandler:)``, rebase local changes on top of the newly fetched version, and retry the upload.
    ///
    /// This policy is only available on paused items for which the file provider supports the fail-on-conflict behavior.
    /// To check that the file provider supports the behavior, get the ``NSURLUbiquitousItemSupportedSyncControlsKey`` URL resource and verify that ``NSFileManagerSupportedSyncControls/failUploadOnConflict`` is `true`.
    #[doc(alias = "NSFileManagerUploadConflictPolicyFailOnConflict")]
    pub const ConflictPolicyFailOnConflict: Self = Self(1);
}

unsafe impl Encode for NSFileManagerUploadLocalVersionConflictPolicy {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSFileManagerUploadLocalVersionConflictPolicy {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A convenient interface to the contents of the file system, and the primary means of interacting with it.
    ///
    /// ## Overview
    ///
    /// A file manager object lets you examine the contents of the file system and make changes to it. The [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager) class provides convenient access to a shared file manager object that is suitable for most types of file-related manipulations. A file manager object is typically your primary mode of interaction with the file system. You use it to locate, create, copy, and move files and directories. You also use it to get information about a file or directory or change some of its attributes.
    ///
    /// When specifying the location of files, you can use either [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) or [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) objects. The use of the [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) class is generally preferred for specifying file-system items because URLs can convert path information to a more efficient representation internally. You can also obtain a bookmark from an [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) object, which is similar to an alias and offers a more sure way of locating the file or directory later.
    ///
    /// If you are moving, copying, linking, or removing files or directories, you can use a delegate in conjunction with a file manager object to manage those operations. The delegate’s role is to affirm the operation and to decide whether to proceed when errors occur. In macOS 10.7 and later, the delegate must conform to the [`NSFileManagerDelegate`](https://developer.apple.com/documentation/foundation/filemanagerdelegate) protocol.
    ///
    /// In iOS 5.0 and later and in macOS 10.7 and later, [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager) includes methods for managing items stored in iCloud. Files and directories tagged for cloud storage are synced to iCloud so that they can be made available to the user’s iOS devices and Macintosh computers. Changes to an item in one location are propagated to all other locations to ensure the items stay in sync.
    ///
    /// ### Sync control
    ///
    /// A [package](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/DocumentPackages/DocumentPackages.html#//apple_ref/doc/uid/10000123i-CH106-SW1) is a directory that the system presents as a single file to the person using the device. Apps with documents that contain multiple files can use packages to manage contents like media assets. In iOS 26 and macOS 26 and later, [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager) introduces methods for controlling how a file provider syncs these items. By pausing sync when your app opens a package and resuming when it closes, your app can prevent the file provider from changing the contents of the package in unexpected ways, which potentially leaves the document in an inconsistent state. You can also use this pause and resume API on regular “flat” files.
    ///
    /// ### Threading considerations
    ///
    /// The methods of the shared [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager) object can be called from multiple threads safely. However, if you use a delegate to receive notifications about the status of move, copy, remove, and link operations, you should create a unique instance of the file manager object, assign your delegate to that object, and use that file manager to initiate your operations.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSFileManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSFileManager {}
);

impl NSFileManager {
    extern_methods!(
        #[unsafe(method(defaultManager))]
        #[unsafe(method_family = none)]
        pub fn defaultManager() -> Retained<NSFileManager>;

        #[cfg(all(feature = "NSArray", feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(mountedVolumeURLsIncludingResourceValuesForKeys:options:))]
        #[unsafe(method_family = none)]
        pub fn mountedVolumeURLsIncludingResourceValuesForKeys_options(
            &self,
            property_keys: Option<&NSArray<NSURLResourceKey>>,
            options: NSVolumeEnumerationOptions,
        ) -> Option<Retained<NSArray<NSURL>>>;

        #[cfg(all(feature = "NSError", feature = "NSURL", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(unmountVolumeAtURL:options:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn unmountVolumeAtURL_options_completionHandler(
            &self,
            url: &NSURL,
            mask: NSFileManagerUnmountOptions,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(
            feature = "NSArray",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL"
        ))]
        #[unsafe(method(contentsOfDirectoryAtURL:includingPropertiesForKeys:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn contentsOfDirectoryAtURL_includingPropertiesForKeys_options_error(
            &self,
            url: &NSURL,
            keys: Option<&NSArray<NSURLResourceKey>>,
            mask: NSDirectoryEnumerationOptions,
        ) -> Result<Retained<NSArray<NSURL>>, Retained<NSError>>;

        #[cfg(all(feature = "NSArray", feature = "NSPathUtilities", feature = "NSURL"))]
        #[unsafe(method(URLsForDirectory:inDomains:))]
        #[unsafe(method_family = none)]
        pub fn URLsForDirectory_inDomains(
            &self,
            directory: NSSearchPathDirectory,
            domain_mask: NSSearchPathDomainMask,
        ) -> Retained<NSArray<NSURL>>;

        #[cfg(all(feature = "NSError", feature = "NSPathUtilities", feature = "NSURL"))]
        #[unsafe(method(URLForDirectory:inDomain:appropriateForURL:create:error:_))]
        #[unsafe(method_family = none)]
        pub fn URLForDirectory_inDomain_appropriateForURL_create_error(
            &self,
            directory: NSSearchPathDirectory,
            domain: NSSearchPathDomainMask,
            url: Option<&NSURL>,
            should_create: bool,
        ) -> Result<Retained<NSURL>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        /// # Safety
        ///
        /// `out_relationship` must be a valid pointer.
        #[unsafe(method(getRelationship:ofDirectoryAtURL:toItemAtURL:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn getRelationship_ofDirectoryAtURL_toItemAtURL_error(
            &self,
            out_relationship: NonNull<NSURLRelationship>,
            directory_url: &NSURL,
            other_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSPathUtilities", feature = "NSURL"))]
        /// # Safety
        ///
        /// `out_relationship` must be a valid pointer.
        #[unsafe(method(getRelationship:ofDirectory:inDomain:toItemAtURL:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn getRelationship_ofDirectory_inDomain_toItemAtURL_error(
            &self,
            out_relationship: NonNull<NSURLRelationship>,
            directory: NSSearchPathDirectory,
            domain_mask: NSSearchPathDomainMask,
            url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL"
        ))]
        /// # Safety
        ///
        /// `attributes` generic should be of the correct type.
        #[unsafe(method(createDirectoryAtURL:withIntermediateDirectories:attributes:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn createDirectoryAtURL_withIntermediateDirectories_attributes_error(
            &self,
            url: &NSURL,
            create_intermediates: bool,
            attributes: Option<&NSDictionary<NSFileAttributeKey, AnyObject>>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(createSymbolicLinkAtURL:withDestinationURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn createSymbolicLinkAtURL_withDestinationURL_error(
            &self,
            url: &NSURL,
            dest_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSFileManagerDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSFileManagerDelegate>>,
        );

        #[cfg(all(feature = "NSDictionary", feature = "NSError", feature = "NSString"))]
        /// # Safety
        ///
        /// `attributes` generic should be of the correct type.
        #[unsafe(method(setAttributes:ofItemAtPath:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAttributes_ofItemAtPath_error(
            &self,
            attributes: &NSDictionary<NSFileAttributeKey, AnyObject>,
            path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSError", feature = "NSString"))]
        /// # Safety
        ///
        /// `attributes` generic should be of the correct type.
        #[unsafe(method(createDirectoryAtPath:withIntermediateDirectories:attributes:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn createDirectoryAtPath_withIntermediateDirectories_attributes_error(
            &self,
            path: &NSString,
            create_intermediates: bool,
            attributes: Option<&NSDictionary<NSFileAttributeKey, AnyObject>>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSArray", feature = "NSError", feature = "NSString"))]
        #[unsafe(method(contentsOfDirectoryAtPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn contentsOfDirectoryAtPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSArray<NSString>>, Retained<NSError>>;

        #[cfg(all(feature = "NSArray", feature = "NSError", feature = "NSString"))]
        #[unsafe(method(subpathsOfDirectoryAtPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn subpathsOfDirectoryAtPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSArray<NSString>>, Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSError", feature = "NSString"))]
        #[unsafe(method(attributesOfItemAtPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn attributesOfItemAtPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSDictionary<NSFileAttributeKey, AnyObject>>, Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSError", feature = "NSString"))]
        #[unsafe(method(attributesOfFileSystemForPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn attributesOfFileSystemForPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSDictionary<NSFileAttributeKey, AnyObject>>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(createSymbolicLinkAtPath:withDestinationPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn createSymbolicLinkAtPath_withDestinationPath_error(
            &self,
            path: &NSString,
            dest_path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(destinationOfSymbolicLinkAtPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn destinationOfSymbolicLinkAtPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSString>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(copyItemAtPath:toPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn copyItemAtPath_toPath_error(
            &self,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(moveItemAtPath:toPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn moveItemAtPath_toPath_error(
            &self,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(linkItemAtPath:toPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn linkItemAtPath_toPath_error(
            &self,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[unsafe(method(removeItemAtPath:error:_))]
        #[unsafe(method_family = none)]
        pub fn removeItemAtPath_error(&self, path: &NSString) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(copyItemAtURL:toURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn copyItemAtURL_toURL_error(
            &self,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(moveItemAtURL:toURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn moveItemAtURL_toURL_error(
            &self,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(linkItemAtURL:toURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn linkItemAtURL_toURL_error(
            &self,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(removeItemAtURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn removeItemAtURL_error(&self, url: &NSURL) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(trashItemAtURL:resultingItemURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn trashItemAtURL_resultingItemURL_error(
            &self,
            url: &NSURL,
            out_resulting_url: Option<&mut Option<Retained<NSURL>>>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[deprecated = "Use -attributesOfItemAtPath:error: instead"]
        #[unsafe(method(fileAttributesAtPath:traverseLink:))]
        #[unsafe(method_family = none)]
        pub fn fileAttributesAtPath_traverseLink(
            &self,
            path: &NSString,
            yorn: bool,
        ) -> Option<Retained<NSDictionary>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `attributes` generic should be of the correct type.
        #[deprecated = "Use -setAttributes:ofItemAtPath:error: instead"]
        #[unsafe(method(changeFileAttributes:atPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn changeFileAttributes_atPath(
            &self,
            attributes: &NSDictionary,
            path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[deprecated = "Use -contentsOfDirectoryAtPath:error: instead"]
        #[unsafe(method(directoryContentsAtPath:))]
        #[unsafe(method_family = none)]
        pub fn directoryContentsAtPath(&self, path: &NSString) -> Option<Retained<NSArray>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[deprecated = "Use -attributesOfFileSystemForPath:error: instead"]
        #[unsafe(method(fileSystemAttributesAtPath:))]
        #[unsafe(method_family = none)]
        pub fn fileSystemAttributesAtPath(&self, path: &NSString)
            -> Option<Retained<NSDictionary>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -destinationOfSymbolicLinkAtPath:error:"]
        #[unsafe(method(pathContentOfSymbolicLinkAtPath:))]
        #[unsafe(method_family = none)]
        pub fn pathContentOfSymbolicLinkAtPath(
            &self,
            path: &NSString,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use -createSymbolicLinkAtPath:error: instead"]
        #[unsafe(method(createSymbolicLinkAtPath:pathContent:))]
        #[unsafe(method_family = none)]
        pub fn createSymbolicLinkAtPath_pathContent(
            &self,
            path: &NSString,
            otherpath: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `attributes` generic should be of the correct type.
        #[deprecated = "Use -createDirectoryAtPath:withIntermediateDirectories:attributes:error: instead"]
        #[unsafe(method(createDirectoryAtPath:attributes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createDirectoryAtPath_attributes(
            &self,
            path: &NSString,
            attributes: &NSDictionary,
        ) -> bool;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `handler` should be of the correct type.
        #[deprecated = "Not supported"]
        #[unsafe(method(linkPath:toPath:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn linkPath_toPath_handler(
            &self,
            src: &NSString,
            dest: &NSString,
            handler: Option<&AnyObject>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `handler` should be of the correct type.
        #[deprecated = "Not supported"]
        #[unsafe(method(copyPath:toPath:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn copyPath_toPath_handler(
            &self,
            src: &NSString,
            dest: &NSString,
            handler: Option<&AnyObject>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `handler` should be of the correct type.
        #[deprecated = "Not supported"]
        #[unsafe(method(movePath:toPath:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn movePath_toPath_handler(
            &self,
            src: &NSString,
            dest: &NSString,
            handler: Option<&AnyObject>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `handler` should be of the correct type.
        #[deprecated = "Not supported"]
        #[unsafe(method(removeFileAtPath:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFileAtPath_handler(
            &self,
            path: &NSString,
            handler: Option<&AnyObject>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(currentDirectoryPath))]
        #[unsafe(method_family = none)]
        pub fn currentDirectoryPath(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(changeCurrentDirectoryPath:))]
        #[unsafe(method_family = none)]
        pub fn changeCurrentDirectoryPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(fileExistsAtPath:))]
        #[unsafe(method_family = none)]
        pub fn fileExistsAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `is_directory` must be a valid pointer or null.
        #[unsafe(method(fileExistsAtPath:isDirectory:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileExistsAtPath_isDirectory(
            &self,
            path: &NSString,
            is_directory: *mut Bool,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(isReadableFileAtPath:))]
        #[unsafe(method_family = none)]
        pub fn isReadableFileAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(isWritableFileAtPath:))]
        #[unsafe(method_family = none)]
        pub fn isWritableFileAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(isExecutableFileAtPath:))]
        #[unsafe(method_family = none)]
        pub fn isExecutableFileAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(isDeletableFileAtPath:))]
        #[unsafe(method_family = none)]
        pub fn isDeletableFileAtPath(&self, path: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(contentsEqualAtPath:andPath:))]
        #[unsafe(method_family = none)]
        pub fn contentsEqualAtPath_andPath(&self, path1: &NSString, path2: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(displayNameAtPath:))]
        #[unsafe(method_family = none)]
        pub fn displayNameAtPath(&self, path: &NSString) -> Retained<NSString>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(componentsToDisplayForPath:))]
        #[unsafe(method_family = none)]
        pub fn componentsToDisplayForPath(
            &self,
            path: &NSString,
        ) -> Option<Retained<NSArray<NSString>>>;

        #[cfg(all(feature = "NSEnumerator", feature = "NSString"))]
        #[unsafe(method(enumeratorAtPath:))]
        #[unsafe(method_family = none)]
        pub fn enumeratorAtPath(
            &self,
            path: &NSString,
        ) -> Option<Retained<NSDirectoryEnumerator<NSString>>>;

        #[cfg(all(
            feature = "NSArray",
            feature = "NSEnumerator",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL",
            feature = "block2"
        ))]
        #[unsafe(method(enumeratorAtURL:includingPropertiesForKeys:options:errorHandler:))]
        #[unsafe(method_family = none)]
        pub fn enumeratorAtURL_includingPropertiesForKeys_options_errorHandler(
            &self,
            url: &NSURL,
            keys: Option<&NSArray<NSURLResourceKey>>,
            mask: NSDirectoryEnumerationOptions,
            handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSURL>, NonNull<NSError>) -> Bool>>,
        ) -> Option<Retained<NSDirectoryEnumerator<NSURL>>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(subpathsAtPath:))]
        #[unsafe(method_family = none)]
        pub fn subpathsAtPath(&self, path: &NSString) -> Option<Retained<NSArray<NSString>>>;

        #[cfg(all(feature = "NSData", feature = "NSString"))]
        #[unsafe(method(contentsAtPath:))]
        #[unsafe(method_family = none)]
        pub fn contentsAtPath(&self, path: &NSString) -> Option<Retained<NSData>>;

        #[cfg(all(feature = "NSData", feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `attr` generic should be of the correct type.
        #[unsafe(method(createFileAtPath:contents:attributes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createFileAtPath_contents_attributes(
            &self,
            path: &NSString,
            data: Option<&NSData>,
            attr: Option<&NSDictionary<NSFileAttributeKey, AnyObject>>,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(fileSystemRepresentationWithPath:))]
        #[unsafe(method_family = none)]
        pub fn fileSystemRepresentationWithPath(&self, path: &NSString) -> NonNull<c_char>;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `str` must be a valid pointer.
        #[unsafe(method(stringWithFileSystemRepresentation:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithFileSystemRepresentation_length(
            &self,
            str: NonNull<c_char>,
            len: NSUInteger,
        ) -> Retained<NSString>;

        #[cfg(all(feature = "NSError", feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn replaceItemAtURL_withItemAtURL_backupItemName_options_resultingItemURL_error(
            &self,
            original_item_url: &NSURL,
            new_item_url: &NSURL,
            backup_item_name: Option<&NSString>,
            options: NSFileManagerItemReplacementOptions,
            resulting_url: Option<&mut Option<Retained<NSURL>>>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(setUbiquitous:itemAtURL:destinationURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn setUbiquitous_itemAtURL_destinationURL_error(
            &self,
            flag: bool,
            url: &NSURL,
            destination_url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(isUbiquitousItemAtURL:))]
        #[unsafe(method_family = none)]
        pub fn isUbiquitousItemAtURL(&self, url: &NSURL) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(startDownloadingUbiquitousItemAtURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn startDownloadingUbiquitousItemAtURL_error(
            &self,
            url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(evictUbiquitousItemAtURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn evictUbiquitousItemAtURL_error(&self, url: &NSURL) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(URLForUbiquityContainerIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn URLForUbiquityContainerIdentifier(
            &self,
            container_identifier: Option<&NSString>,
        ) -> Option<Retained<NSURL>>;

        #[cfg(all(feature = "NSDate", feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(URLForPublishingUbiquitousItemAtURL:expirationDate:error:_))]
        #[unsafe(method_family = none)]
        pub fn URLForPublishingUbiquitousItemAtURL_expirationDate_error(
            &self,
            url: &NSURL,
            out_date: Option<&mut Option<Retained<NSDate>>>,
        ) -> Result<Retained<NSURL>, Retained<NSError>>;

        #[cfg(feature = "NSObject")]
        #[unsafe(method(ubiquityIdentityToken))]
        #[unsafe(method_family = none)]
        pub fn ubiquityIdentityToken(
            &self,
        ) -> Option<Retained<AnyObject /* NSObjectProtocol+ NSCopying+ NSCoding */>>;

        #[cfg(all(feature = "NSError", feature = "NSURL", feature = "block2"))]
        /// Asynchronously pauses sync of an item at the given URL.
        ///
        /// Call this when opening an item to prevent sync from altering the contents of the URL.
        /// Once paused, the file provider will not upload local changes nor download remote changes.
        ///
        /// While paused, call ``uploadLocalVersionOfUbiquitousItem(at:withConflictResolutionPolicy:completionHandler:)`` when the document is in a stable state.
        /// This action keeps the server version as up-to-date as possible.
        ///
        /// If the item is already paused, a second call to this method reports success.
        /// If the file provider is already applying changes to the item, the pause fails with an ``NSFileWriteUnknownError-enum.case``, with an underlying error that has domain ``NSPOSIXErrorDomain`` and code ``POSIXError/EBUSY``.
        /// If the pause fails, wait for the state to stabilize before retrying.
        /// Pausing also fails with ``CocoaError/featureUnsupported`` if `url` refers to a regular (non-package) directory.
        ///
        /// Pausing sync is independent of the calling app's lifecycle; sync doesn't automatically resume if the app closes or crashes and relaunches later.
        /// To resume syncing, explicitly call ``resumeSyncForUbiquitousItem(at:with:completionHandler:)``.
        /// Always be sure to resume syncing before you close the item.
        ///
        /// - Parameters:
        /// - url: The URL of the item for which to pause sync.
        /// - completionHandler: A closure or block that the framework calls when the pause action completes. It receives a single ``NSError`` parameter to indicate an error that prevented pausing; this value is `nil` if the pause succeeded. In Swift, you can omit the completion handler and catch the thrown error instead.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(pauseSyncForUbiquitousItemAtURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn pauseSyncForUbiquitousItemAtURL_completionHandler(
            &self,
            url: &NSURL,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(feature = "NSError", feature = "NSURL", feature = "block2"))]
        /// Asynchronously resumes the sync on a paused item using the given resume behavior.
        ///
        /// Always call this method when your app closes an item to allow the file provider to sync local changes back to the server.
        ///
        /// In most situations, the ``NSFileManagerResumeSyncBehavior/preserveLocalChanges`` behavior is the best choice to avoid any risk of data loss.
        ///
        /// The resume call fails with ``CocoaError/featureUnsupported`` if `url` isn't currently paused.
        /// If the device isn't connected to the network, the call may fail with ``NSFileWriteUnknownError-enum.case``, with the underlying error of
        /// <doc
        /// ://com.apple.documentation/documentation/FileProvider/NSFileProviderError/serverUnreachable>.
        ///
        /// - Parameters:
        /// - url: The URL of the item for which to resume sync.
        /// - behavior: A ``NSFileManagerResumeSyncBehavior`` value that tells the file manager how to handle conflicts between local and remote versions of files.
        /// - completionHandler: A closure or block that the framework calls when the resume action completes. It receives a single ``NSError`` parameter to indicate an error that prevented the resume action; the value is `nil` if the resume succeeded. In Swift, you can omit the completion handler and catch the thrown error instead.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(resumeSyncForUbiquitousItemAtURL:withBehavior:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn resumeSyncForUbiquitousItemAtURL_withBehavior_completionHandler(
            &self,
            url: &NSURL,
            behavior: NSFileManagerResumeSyncBehavior,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(
            feature = "NSError",
            feature = "NSFileVersion",
            feature = "NSURL",
            feature = "block2"
        ))]
        /// Asynchronously fetches the latest remote version of a given item from the server.
        ///
        /// Use this method if uploading fails due to a version conflict and sync is paused.
        /// In this case, fetching the latest remote version allows you to inspect the newer item from the server, resolve the conflict, and resume uploading.
        ///
        /// The version provided by this call depends on several factors:
        /// * If there is no newer version of the file on the server, the caller receives the current version of the file.
        /// * If the server has a newer version and sync isn't paused, this call replaces the local item and provides the version of the new item.
        /// * If the server has a newer version but sync is paused, the returned version points to a side location. In this case, call ``NSFileVersion/replaceItem(at:options:)`` on the provided version object to replace the local item with the newer item from the server.
        ///
        /// If the device isn't connected to the network, the call may fail with ``NSFileReadUnknownError-enum.case``, with the underlying error of
        /// <doc
        /// ://com.apple.documentation/documentation/FileProvider/NSFileProviderError/serverUnreachable>.
        ///
        /// - Parameters:
        /// - url: The URL of the item for which to check the version.
        /// - completionHandler: A closure or block that the framework calls when the fetch action completes. It receives parameters of types ``NSFileVersion`` and ``NSError``. The error is `nil` if fetching the remote version succeeded; otherwise it indicates the error that caused the call to fail. In Swift, you can omit the completion handler, catching any error in a `do`-`catch` block and receiving the version as the return value.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchLatestRemoteVersionOfItemAtURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchLatestRemoteVersionOfItemAtURL_completionHandler(
            &self,
            url: &NSURL,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSFileVersion, *mut NSError)>,
        );

        #[cfg(all(
            feature = "NSError",
            feature = "NSFileVersion",
            feature = "NSURL",
            feature = "block2"
        ))]
        /// Asynchronously uploads the local version of the item using the provided conflict resolution policy.
        ///
        /// Once your app pauses a sync for an item, call this method every time your document is in a stable state.
        /// This action keeps the server version as up-to-date as possible.
        ///
        /// If the server has a newer version than the one to which the app made changes, uploading fails with ``NSFileWriteUnknownError-enum.case``, with an underlying error of
        /// <doc
        /// ://com.apple.documentation/documentation/FileProvider/NSFileProviderError/localVersionConflictingWithServer>.
        /// In this case, call ``FileManager/fetchLatestRemoteVersionOfItem(at:completionHandler:)``, rebase local changes on top of that version, and retry the upload.
        ///
        /// If the device isn't connected to the network, the call may fail with ``NSFileWriteUnknownError-enum.case``, with the underlying error of
        /// <doc
        /// ://com.apple.documentation/documentation/FileProvider/NSFileProviderError/serverUnreachable>.
        ///
        /// - Parameters:
        /// - url: The URL of the item for which to check the version.
        /// - conflictResolutionPolicy: The policy the file manager applies if the local and server versions conflict.
        /// - completionHandler: A closure or block that the framework calls when the upload completes. It receives parameters of types ``NSFileVersion`` and ``NSError``. The error is `nil` if fetching the remote version succeeded; otherwise it indicates the error that caused the call to fail. In Swift, you can omit the completion handler, catching any error in a `do`-`catch` block and receiving the version as the return value.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(uploadLocalVersionOfUbiquitousItemAtURL:withConflictResolutionPolicy:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn uploadLocalVersionOfUbiquitousItemAtURL_withConflictResolutionPolicy_completionHandler(
            &self,
            url: &NSURL,
            conflict_resolution_policy: NSFileManagerUploadLocalVersionConflictPolicy,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSFileVersion, *mut NSError)>,
        );

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(getFileProviderServicesForItemAtURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getFileProviderServicesForItemAtURL_completionHandler(
            &self,
            url: &NSURL,
            completion_handler: &block2::DynBlock<
                dyn Fn(
                    *mut NSDictionary<NSFileProviderServiceName, NSFileProviderService>,
                    *mut NSError,
                ),
            >,
        );

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(containerURLForSecurityApplicationGroupIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn containerURLForSecurityApplicationGroupIdentifier(
            &self,
            group_identifier: &NSString,
        ) -> Option<Retained<NSURL>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSFileManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSFileManager {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSUserInformation.
impl NSFileManager {
    extern_methods!(
        #[cfg(feature = "NSURL")]
        #[unsafe(method(homeDirectoryForCurrentUser))]
        #[unsafe(method_family = none)]
        pub fn homeDirectoryForCurrentUser(&self) -> Retained<NSURL>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(temporaryDirectory))]
        #[unsafe(method_family = none)]
        pub fn temporaryDirectory(&self) -> Retained<NSURL>;

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(homeDirectoryForUser:))]
        #[unsafe(method_family = none)]
        pub fn homeDirectoryForUser(&self, user_name: &NSString) -> Option<Retained<NSURL>>;
    );
}

extern_protocol!(
    /// The interface a file manager’s delegate uses to intervene during operations or if an error occurs.
    ///
    /// ## Overview
    ///
    /// The [`NSFileManagerDelegate`](https://developer.apple.com/documentation/foundation/filemanagerdelegate) protocol defines optional methods for managing operations involving the copying, moving, linking, or removal of files and directories. When you use an [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager) object to initiate a copy, move, link, or remove operation, the file manager asks its delegate whether the operation should begin at all and whether it should proceed when an error occurs.
    ///
    /// The methods of this protocol accept either [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) or [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) objects. The file manager always prefers methods that take an [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) object over those that take an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object.
    ///
    /// You should associate your delegate with a unique instance of the [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager) class, as opposed to the shared instance.
    ///
    ///
    pub unsafe trait NSFileManagerDelegate: NSObjectProtocol {
        #[cfg(feature = "NSString")]
        #[optional]
        #[unsafe(method(fileManager:shouldCopyItemAtPath:toPath:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldCopyItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(feature = "NSURL")]
        #[optional]
        #[unsafe(method(fileManager:shouldCopyItemAtURL:toURL:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldCopyItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[optional]
        #[unsafe(method(fileManager:shouldProceedAfterError:copyingItemAtPath:toPath:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldProceedAfterError_copyingItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[optional]
        #[unsafe(method(fileManager:shouldProceedAfterError:copyingItemAtURL:toURL:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldProceedAfterError_copyingItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[optional]
        #[unsafe(method(fileManager:shouldMoveItemAtPath:toPath:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldMoveItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(feature = "NSURL")]
        #[optional]
        #[unsafe(method(fileManager:shouldMoveItemAtURL:toURL:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldMoveItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[optional]
        #[unsafe(method(fileManager:shouldProceedAfterError:movingItemAtPath:toPath:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldProceedAfterError_movingItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[optional]
        #[unsafe(method(fileManager:shouldProceedAfterError:movingItemAtURL:toURL:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldProceedAfterError_movingItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[optional]
        #[unsafe(method(fileManager:shouldLinkItemAtPath:toPath:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldLinkItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(feature = "NSURL")]
        #[optional]
        #[unsafe(method(fileManager:shouldLinkItemAtURL:toURL:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldLinkItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[optional]
        #[unsafe(method(fileManager:shouldProceedAfterError:linkingItemAtPath:toPath:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldProceedAfterError_linkingItemAtPath_toPath(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_path: &NSString,
            dst_path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[optional]
        #[unsafe(method(fileManager:shouldProceedAfterError:linkingItemAtURL:toURL:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldProceedAfterError_linkingItemAtURL_toURL(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            src_url: &NSURL,
            dst_url: &NSURL,
        ) -> bool;

        #[cfg(feature = "NSString")]
        #[optional]
        #[unsafe(method(fileManager:shouldRemoveItemAtPath:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldRemoveItemAtPath(
            &self,
            file_manager: &NSFileManager,
            path: &NSString,
        ) -> bool;

        #[cfg(feature = "NSURL")]
        #[optional]
        #[unsafe(method(fileManager:shouldRemoveItemAtURL:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldRemoveItemAtURL(
            &self,
            file_manager: &NSFileManager,
            url: &NSURL,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSString"))]
        #[optional]
        #[unsafe(method(fileManager:shouldProceedAfterError:removingItemAtPath:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldProceedAfterError_removingItemAtPath(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            path: &NSString,
        ) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[optional]
        #[unsafe(method(fileManager:shouldProceedAfterError:removingItemAtURL:))]
        #[unsafe(method_family = none)]
        fn fileManager_shouldProceedAfterError_removingItemAtURL(
            &self,
            file_manager: &NSFileManager,
            error: &NSError,
            url: &NSURL,
        ) -> bool;
    }
);

extern_class!(
    /// An object that enumerates the contents of a directory.
    ///
    /// ## Overview
    ///
    /// You obtain a directory enumerator using [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager)’s [`enumeratorAtPath:`](https://developer.apple.com/documentation/foundation/filemanager/enumerator(atpath:)) method. The enumeration provides the pathnames of all files and directories contained within that directory. These pathnames are relative to the directory.
    ///
    /// An enumeration is recursive, including the files of all subdirectories, and crosses device boundaries. An enumeration does not resolve symbolic links, or attempt to traverse symbolic links that point to directories.
    ///
    ///
    #[unsafe(super(NSEnumerator<ObjectType>, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSEnumerator")]
    pub struct NSDirectoryEnumerator<ObjectType: ?Sized = AnyObject>;
);

#[cfg(feature = "NSEnumerator")]
impl<ObjectType: ?Sized + Message> NSDirectoryEnumerator<ObjectType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewObjectType: ?Sized + Message>(
        &self,
    ) -> &NSDirectoryEnumerator<NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSEnumerator")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSFastEnumeration for NSDirectoryEnumerator<ObjectType> {}
);

#[cfg(feature = "NSEnumerator")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSObjectProtocol for NSDirectoryEnumerator<ObjectType> {}
);

#[cfg(feature = "NSEnumerator")]
impl<ObjectType: Message> NSDirectoryEnumerator<ObjectType> {
    extern_methods!(
        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(fileAttributes))]
        #[unsafe(method_family = none)]
        pub fn fileAttributes(
            &self,
        ) -> Option<Retained<NSDictionary<NSFileAttributeKey, AnyObject>>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(directoryAttributes))]
        #[unsafe(method_family = none)]
        pub fn directoryAttributes(
            &self,
        ) -> Option<Retained<NSDictionary<NSFileAttributeKey, AnyObject>>>;

        #[unsafe(method(isEnumeratingDirectoryPostOrder))]
        #[unsafe(method_family = none)]
        pub fn isEnumeratingDirectoryPostOrder(&self) -> bool;

        #[unsafe(method(skipDescendents))]
        #[unsafe(method_family = none)]
        pub fn skipDescendents(&self);

        #[unsafe(method(level))]
        #[unsafe(method_family = none)]
        pub fn level(&self) -> NSUInteger;

        #[unsafe(method(skipDescendants))]
        #[unsafe(method_family = none)]
        pub fn skipDescendants(&self);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSEnumerator")]
impl<ObjectType: Message> NSDirectoryEnumerator<ObjectType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

#[cfg(feature = "NSEnumerator")]
impl<ObjectType: Message> DefaultRetained for NSDirectoryEnumerator<ObjectType> {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// A service that provides a custom communication channel between your app and a File Provider extension.
    ///
    /// ## Overview
    ///
    /// To communicate, both your app and the File Provider extension must implement their part of the service:
    ///
    /// - Your app requests the proxy object, and calls its methods.
    ///
    /// - The File Provider extension declares the supported services and vends a proxy object that implements the protocol for each service.
    ///
    /// The app and File Provider extension communicate using an XPC service. This service performs actions only on items managed by the File Provider extension. For more information, see [Creating XPC Services](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/CreatingXPCServices.html#//apple_ref/doc/uid/10000172i-SW6).
    ///
    /// ### Defining the Service’s Protocol
    ///
    /// Services let you define custom actions that are not provided by Apple’s APIs. Both the app and the File Provider extension must agree upon the service’s name and protocol.  Communicate the name and protocol through an outside source (for example, posting a header file that defines both the name and protocol, or publishing a library that includes them both).
    ///
    /// The service can be defined by either the app or the File Provider extension:
    ///
    /// - Apps can define a service for features they would like to use. File providers can then choose to support those features by implementing the service.
    ///
    /// - File Provider extensions can provide a service for the features they support. Apps can then choose to use the specified service.
    ///
    /// When defining a service’s protocol, the parameters for each method must adhere to the following rules:
    ///
    /// - The parameter’s class must conform to [`NSSecureCoding`](https://developer.apple.com/documentation/foundation/nssecurecoding).
    ///
    /// - The parameter’s class must be defined in both the app and the File Provider extension (for example, standard system types or classes defined in a library imported by both sides).
    ///
    /// - If a collection parameter contains types other than property list types (see [Property List Types and Objects](https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/PropertyList.html#//apple_ref/doc/uid/TP40008195-CH44-SW2)), declare the valid types using the [`NSXPCInterface`](https://developer.apple.com/documentation/foundation/nsxpcinterface) class’s [`classesForSelector:argumentIndex:ofReply:`](https://developer.apple.com/documentation/foundation/nsxpcinterface/classes(for:argumentindex:ofreply:)) method.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSFileProviderService;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSFileProviderService {}
);

impl NSFileProviderService {
    extern_methods!(
        #[cfg(all(feature = "NSError", feature = "NSXPCConnection", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(getFileProviderConnectionWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getFileProviderConnectionWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSXPCConnection, *mut NSError)>,
        );

        #[cfg(feature = "NSString")]
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub fn name(&self) -> Retained<NSFileProviderServiceName>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSFileProviderService {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSFileProviderService {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s type.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object (see `NSFileType Attribute Values` for possible values).
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileType: &'static NSFileAttributeKey;
}

extern "C" {
    /// A directory.
    #[cfg(feature = "NSString")]
    pub static NSFileTypeDirectory: &'static NSFileAttributeType;
}

extern "C" {
    /// A regular file.
    #[cfg(feature = "NSString")]
    pub static NSFileTypeRegular: &'static NSFileAttributeType;
}

extern "C" {
    /// A symbolic link.
    #[cfg(feature = "NSString")]
    pub static NSFileTypeSymbolicLink: &'static NSFileAttributeType;
}

extern "C" {
    /// A socket.
    #[cfg(feature = "NSString")]
    pub static NSFileTypeSocket: &'static NSFileAttributeType;
}

extern "C" {
    /// A character special file.
    #[cfg(feature = "NSString")]
    pub static NSFileTypeCharacterSpecial: &'static NSFileAttributeType;
}

extern "C" {
    /// A block special file.
    #[cfg(feature = "NSString")]
    pub static NSFileTypeBlockSpecial: &'static NSFileAttributeType;
}

extern "C" {
    /// A file whose type is unknown.
    #[cfg(feature = "NSString")]
    pub static NSFileTypeUnknown: &'static NSFileAttributeType;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s size in bytes.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an `unsigned long long`.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  If the file has a resource fork, the returned value does _not_ include the size of the resource fork.
    ///
    ///
    ///
    /// </div>
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileSize: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s last modified date.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) object.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  This API has the potential of being misused to access device signals to try to identify the device or user, also known as fingerprinting. Regardless of whether a user gives your app permission to track, fingerprinting is not allowed. When you use this API in your app or third-party SDK (an SDK not provided by Apple), declare your usage and the reason for using the API in your app or third-party SDK’s `PrivacyInfo.xcprivacy` file. For more information, including the list of valid reasons for using the API, see [Describing use of required reason API](https://developer.apple.com/documentation/bundleresources/describing-use-of-required-reason-api).
    ///
    ///
    ///
    /// </div>
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileModificationDate: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s reference count.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an `unsigned long`.
    ///
    /// The number specifies the number of hard links to a file.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileReferenceCount: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the identifier for the device on which the file resides.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an `unsigned long`.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileDeviceIdentifier: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the name of the file’s owner.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileOwnerAccountName: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the group name of the file’s owner.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileGroupOwnerAccountName: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s Posix permissions.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object. Use the [`shortValue`](https://developer.apple.com/documentation/foundation/nsnumber/int16value) method to retrieve the integer value for the permissions.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFilePosixPermissions: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file system attribute dictionary whose value indicates the filesystem number of the file system.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object that specifies the filesystem number of the file system. The value corresponds to the value of `st_dev`, as returned by `stat`(2).
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileSystemNumber: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s filesystem file number.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an `unsigned long`. The value corresponds to the value of `st_ino`, as returned by `stat`(2).
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileSystemFileNumber: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates whether the file’s extension is hidden.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a Boolean value.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileExtensionHidden: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s HFS creator code.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an `OSType` (unsigned 32-bit integer). See HFS File Types for possible values.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileHFSCreatorCode: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s HFS type code.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an `OSType` (unsigned 32-bit integer). See HFS File Types for possible values.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileHFSTypeCode: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates whether the file is mutable.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a Boolean value.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileImmutable: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates whether the file is read-only.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a Boolean value.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileAppendOnly: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s creation date.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) object.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  This API has the potential of being misused to access device signals to try to identify the device or user, also known as fingerprinting. Regardless of whether a user gives your app permission to track, fingerprinting is not allowed. When you use this API in your app or third-party SDK (an SDK not provided by Apple), declare your usage and the reason for using the API in your app or third-party SDK’s `PrivacyInfo.xcprivacy` file. For more information, including the list of valid reasons for using the API, see [Describing use of required reason API](https://developer.apple.com/documentation/bundleresources/describing-use-of-required-reason-api).
    ///
    ///
    ///
    /// </div>
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileCreationDate: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s owner’s account ID.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an `unsigned long`.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileOwnerAccountID: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates the file’s group ID.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing an `unsigned long`.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileGroupOwnerAccountID: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value indicates whether the file is busy.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object containing a Boolean value.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileBusy: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file attribute dictionary whose value identifies the protection level for this file.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) value. For a list of possible values, see `File Protection Values`.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionKey: &'static NSFileAttributeKey;
}

extern "C" {
    /// The file has no special protections associated with it.
    ///
    /// ## Discussion
    ///
    /// A file with this type of protection can be read from or written to at any time.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionNone: &'static NSFileProtectionType;
}

extern "C" {
    /// The file is stored in an encrypted format on disk and cannot be read from or written to while the device is locked or booting.
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionComplete: &'static NSFileProtectionType;
}

extern "C" {
    /// The file is stored in an encrypted format on disk after it is closed.
    ///
    /// ## Discussion
    ///
    /// Files with this type of protection can be created while the device is locked, but once closed, cannot be opened again until the device is unlocked. If the file is opened when unlocked, you may continue to access the file normally, even if the user locks the device. There is a small performance penalty when the file is created and opened, though not when being written to or read from. This can be mitigated by changing the file protection to [`NSFileProtectionComplete`](https://developer.apple.com/documentation/foundation/fileprotectiontype/complete) when the device is unlocked.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionCompleteUnlessOpen: &'static NSFileProtectionType;
}

extern "C" {
    /// The file is stored in an encrypted format on disk and cannot be accessed until after the device has booted.
    ///
    /// ## Discussion
    ///
    /// After the user unlocks the device for the first time, your app can access the file and continue to access it even if the user subsequently locks the device.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionCompleteUntilFirstUserAuthentication: &'static NSFileProtectionType;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSFileProtectionCompleteWhenUserInactive: &'static NSFileProtectionType;
}

extern "C" {
    /// The key in a file system attribute dictionary whose value indicates the size of the file system.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object that specifies the size of the file system in bytes. The value is determined by `statfs()`.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  This API has the potential of being misused to access device signals to try to identify the device or user, also known as fingerprinting. Regardless of whether a user gives your app permission to track, fingerprinting is not allowed. When you use this API in your app or third-party SDK (an SDK not provided by Apple), declare your usage and the reason for using the API in your app or third-party SDK’s `PrivacyInfo.xcprivacy` file. For more information, including the list of valid reasons for using the API, see [Describing use of required reason API](https://developer.apple.com/documentation/bundleresources/describing-use-of-required-reason-api).
    ///
    ///
    ///
    /// </div>
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileSystemSize: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file system attribute dictionary whose value indicates the amount of free space on the file system.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object that specifies the amount of free space on the file system in bytes. The value is determined by `statfs()`.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  This API has the potential of being misused to access device signals to try to identify the device or user, also known as fingerprinting. Regardless of whether a user gives your app permission to track, fingerprinting is not allowed. When you use this API in your app or third-party SDK (an SDK not provided by Apple), declare your usage and the reason for using the API in your app or third-party SDK’s `PrivacyInfo.xcprivacy` file. For more information, including the list of valid reasons for using the API, see [Describing use of required reason API](https://developer.apple.com/documentation/bundleresources/describing-use-of-required-reason-api).
    ///
    ///
    ///
    /// </div>
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileSystemFreeSize: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file system attribute dictionary whose value indicates the number of nodes in the file system.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object that specifies the number of nodes in the file system.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileSystemNodes: &'static NSFileAttributeKey;
}

extern "C" {
    /// The key in a file system attribute dictionary whose value indicates the number of free nodes in the file system.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object that specifies the number of free nodes in the file system.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFileSystemFreeNodes: &'static NSFileAttributeKey;
}

/// NSFileAttributes.
#[cfg(feature = "NSDictionary")]
impl<KeyType: Message, ObjectType: Message> NSDictionary<KeyType, ObjectType> {
    extern_methods!(
        #[unsafe(method(fileSize))]
        #[unsafe(method_family = none)]
        pub fn fileSize(&self) -> c_ulonglong;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(fileModificationDate))]
        #[unsafe(method_family = none)]
        pub fn fileModificationDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(fileType))]
        #[unsafe(method_family = none)]
        pub fn fileType(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(filePosixPermissions))]
        #[unsafe(method_family = none)]
        pub fn filePosixPermissions(&self) -> NSUInteger;

        #[cfg(feature = "NSString")]
        #[unsafe(method(fileOwnerAccountName))]
        #[unsafe(method_family = none)]
        pub fn fileOwnerAccountName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(fileGroupOwnerAccountName))]
        #[unsafe(method_family = none)]
        pub fn fileGroupOwnerAccountName(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(fileSystemNumber))]
        #[unsafe(method_family = none)]
        pub fn fileSystemNumber(&self) -> NSInteger;

        #[unsafe(method(fileSystemFileNumber))]
        #[unsafe(method_family = none)]
        pub fn fileSystemFileNumber(&self) -> NSUInteger;

        #[unsafe(method(fileExtensionHidden))]
        #[unsafe(method_family = none)]
        pub fn fileExtensionHidden(&self) -> bool;

        #[unsafe(method(fileHFSCreatorCode))]
        #[unsafe(method_family = none)]
        pub fn fileHFSCreatorCode(&self) -> OSType;

        #[unsafe(method(fileHFSTypeCode))]
        #[unsafe(method_family = none)]
        pub fn fileHFSTypeCode(&self) -> OSType;

        #[unsafe(method(fileIsImmutable))]
        #[unsafe(method_family = none)]
        pub fn fileIsImmutable(&self) -> bool;

        #[unsafe(method(fileIsAppendOnly))]
        #[unsafe(method_family = none)]
        pub fn fileIsAppendOnly(&self) -> bool;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(fileCreationDate))]
        #[unsafe(method_family = none)]
        pub fn fileCreationDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSValue")]
        #[unsafe(method(fileOwnerAccountID))]
        #[unsafe(method_family = none)]
        pub fn fileOwnerAccountID(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "NSValue")]
        #[unsafe(method(fileGroupOwnerAccountID))]
        #[unsafe(method_family = none)]
        pub fn fileGroupOwnerAccountID(&self) -> Option<Retained<NSNumber>>;
    );
}
