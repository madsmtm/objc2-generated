//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// A notification posted whenever the system clock is changed.
    ///
    /// ## Discussion
    ///
    /// This can be initiated by a call to `settimeofday(_:_:)` or the user changing values in the Date and Time Preference panel.
    ///
    /// The notification object is `null`. This notification does not contain a `userInfo` dictionary.
    ///
    ///
    #[cfg(all(feature = "NSNotification", feature = "NSString"))]
    pub static NSSystemClockDidChangeNotification: &'static NSNotificationName;
}

/// A number of seconds.
///
/// ## Discussion
///
/// A [`NSTimeInterval`](https://developer.apple.com/documentation/foundation/timeinterval) value is always specified in seconds; it yields sub-millisecond precision over a range of 10,000 years.
///
/// On its own, a time interval does not specify a unique point in time, or even a span between specific times. Combining a time interval with one or more known reference points yields a [`Date`](https://developer.apple.com/documentation/foundation/date) or [`DateInterval`](https://developer.apple.com/documentation/foundation/dateinterval) value.
///
///
pub type NSTimeInterval = c_double;

extern_class!(
    /// A representation of a specific point in time, independent of any calendar or time zone.
    ///
    /// ## Overview
    ///
    /// In Swift, use this type when you need reference semantics or other Foundation-specific behavior.
    ///
    /// [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) objects encapsulate a single point in time, independent of any particular calendrical system or time zone. Date objects are immutable, representing an invariant time interval relative to an absolute reference date (00:00:00 UTC on 1 January 2001).
    ///
    /// The [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) class provides methods for comparing dates, calculating the time interval between two dates, and creating a new date from a time interval relative to another date. [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) objects can be used in conjunction with [`NSDateFormatter`](https://developer.apple.com/documentation/foundation/dateformatter) objects to create localized representations of dates and times, as well as with [`NSCalendar`](https://developer.apple.com/documentation/foundation/nscalendar) objects to perform calendar arithmetic.
    ///
    /// [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) is _toll-free bridged_ with its Core Foundation counterpart, [`CFDateRef`](https://developer.apple.com/documentation/corefoundation/cfdate). See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information on toll-free bridging.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The Swift overlay to the Foundation framework provides the [`Date`](https://developer.apple.com/documentation/foundation/date) structure, which bridges to the [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) class. For more information about value types, see [Working with Cocoa Frameworks](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/BuildingCocoaApps/WorkingWithCocoaDataTypes.html#//apple_ref/doc/uid/TP40014216-CH6) in [Using Swift with Cocoa and Objective-C (Swift 4.1)](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/BuildingCocoaApps/index.html#//apple_ref/doc/uid/TP40014216).
    ///
    ///
    ///
    /// </div>
    /// ### Subclassing Notes
    ///
    /// You might subclass [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) in order to make it easier to work with a particular calendrical system, or to work with date and time values with a finer temporal granularity.
    ///
    /// #### Methods to Override and Other Requirements
    ///
    /// If you want to subclass [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) to obtain behavior different than that provided by the private or public subclasses, you must:
    ///
    /// - Declare a suitable instance variable to hold the date and time value (relative to an absolute reference date)
    ///
    /// - Override the [`timeIntervalSinceReferenceDate`](https://developer.apple.com/documentation/foundation/nsdate/timeintervalsincereferencedate-swift.property) instance method to provide the correct date and time value based on your instance variable
    ///
    /// - Override [`initWithTimeIntervalSinceReferenceDate:`](https://developer.apple.com/documentation/foundation/nsdate/init(timeintervalsincereferencedate:)), one of the designated initializer methods
    ///
    /// - If creating a subclass that represents a calendrical system, define methods that partition past and future periods into the units of this calendar
    ///
    /// - Implement the methods required by the [`NSCopying`](https://developer.apple.com/documentation/foundation/nscopying) and [NSCoding](https://developer.apple.com/library/archive/documentation/Swift/Conceptual/BuildingCocoaApps/WritingSwiftClassesWithObjective-CBehavior.html#//apple_ref/doc/uid/TP40014216-CH5-ID152) protocols, because [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) adopts these protocols
    ///
    /// #### Special Considerations
    ///
    /// Your subclass may use a different reference date than the absolute reference date used by [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) (00:00:00 UTC on 1 January 2001). If it does, it must still use the absolute reference date in its implementations of the methods [`timeIntervalSinceReferenceDate`](https://developer.apple.com/documentation/foundation/nsdate/timeintervalsincereferencedate-swift.property) and [`initWithTimeIntervalSinceReferenceDate:`](https://developer.apple.com/documentation/foundation/nsdate/init(timeintervalsincereferencedate:)). That is, the reference date referred to in the titles of these methods is the absolute reference date. If you do not use the absolute reference date in these methods, comparisons between [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate) objects of your subclass and `NSDate` objects of a private subclass will not work.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSDate;
);

unsafe impl Send for NSDate {}

unsafe impl Sync for NSDate {}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSDate> for CFDate {
    #[inline]
    fn as_ref(&self) -> &NSDate {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFDate> for NSDate {
    #[inline]
    fn as_ref(&self) -> &CFDate {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSDate {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSDate {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSDate {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSDate {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSDate {}
);

impl NSDate {
    extern_methods!(
        #[unsafe(method(timeIntervalSinceReferenceDate))]
        #[unsafe(method_family = none)]
        pub fn timeIntervalSinceReferenceDate(&self) -> NSTimeInterval;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithTimeIntervalSinceReferenceDate:))]
        #[unsafe(method_family = init)]
        pub fn initWithTimeIntervalSinceReferenceDate(
            this: Allocated<Self>,
            ti: NSTimeInterval,
        ) -> Retained<Self>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSDate {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSDate {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSExtendedDate.
impl NSDate {
    extern_methods!(
        #[unsafe(method(timeIntervalSinceDate:))]
        #[unsafe(method_family = none)]
        pub fn timeIntervalSinceDate(&self, another_date: &NSDate) -> NSTimeInterval;

        #[unsafe(method(timeIntervalSinceNow))]
        #[unsafe(method_family = none)]
        pub fn timeIntervalSinceNow(&self) -> NSTimeInterval;

        #[unsafe(method(timeIntervalSince1970))]
        #[unsafe(method_family = none)]
        pub fn timeIntervalSince1970(&self) -> NSTimeInterval;

        #[deprecated = "Use dateByAddingTimeInterval instead"]
        #[unsafe(method(addTimeInterval:))]
        #[unsafe(method_family = none)]
        pub fn addTimeInterval(&self, seconds: NSTimeInterval) -> Retained<AnyObject>;

        #[unsafe(method(dateByAddingTimeInterval:))]
        #[unsafe(method_family = none)]
        pub fn dateByAddingTimeInterval(&self, ti: NSTimeInterval) -> Retained<Self>;

        #[unsafe(method(earlierDate:))]
        #[unsafe(method_family = none)]
        pub fn earlierDate(&self, another_date: &NSDate) -> Retained<NSDate>;

        #[unsafe(method(laterDate:))]
        #[unsafe(method_family = none)]
        pub fn laterDate(&self, another_date: &NSDate) -> Retained<NSDate>;

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(compare:))]
        #[unsafe(method_family = none)]
        pub fn compare(&self, other: &NSDate) -> NSComparisonResult;

        #[unsafe(method(isEqualToDate:))]
        #[unsafe(method_family = none)]
        pub fn isEqualToDate(&self, other_date: &NSDate) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(description))]
        #[unsafe(method_family = none)]
        pub fn description(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `locale` should be of the correct type.
        #[unsafe(method(descriptionWithLocale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn descriptionWithLocale(
            &self,
            locale: Option<&AnyObject>,
        ) -> Retained<NSString>;

        #[unsafe(method(timeIntervalSinceReferenceDate))]
        #[unsafe(method_family = none)]
        pub fn timeIntervalSinceReferenceDate_class() -> NSTimeInterval;
    );
}

/// NSDateCreation.
impl NSDate {
    extern_methods!(
        #[unsafe(method(date))]
        #[unsafe(method_family = none)]
        pub fn date() -> Retained<Self>;

        #[unsafe(method(dateWithTimeIntervalSinceNow:))]
        #[unsafe(method_family = none)]
        pub fn dateWithTimeIntervalSinceNow(secs: NSTimeInterval) -> Retained<Self>;

        #[unsafe(method(dateWithTimeIntervalSinceReferenceDate:))]
        #[unsafe(method_family = none)]
        pub fn dateWithTimeIntervalSinceReferenceDate(ti: NSTimeInterval) -> Retained<Self>;

        #[unsafe(method(dateWithTimeIntervalSince1970:))]
        #[unsafe(method_family = none)]
        pub fn dateWithTimeIntervalSince1970(secs: NSTimeInterval) -> Retained<Self>;

        #[unsafe(method(dateWithTimeInterval:sinceDate:))]
        #[unsafe(method_family = none)]
        pub fn dateWithTimeInterval_sinceDate(
            secs_to_be_added: NSTimeInterval,
            date: &NSDate,
        ) -> Retained<Self>;

        #[unsafe(method(distantFuture))]
        #[unsafe(method_family = none)]
        pub fn distantFuture() -> Retained<NSDate>;

        #[unsafe(method(distantPast))]
        #[unsafe(method_family = none)]
        pub fn distantPast() -> Retained<NSDate>;

        #[unsafe(method(now))]
        #[unsafe(method_family = none)]
        pub fn now() -> Retained<NSDate>;

        #[unsafe(method(initWithTimeIntervalSinceNow:))]
        #[unsafe(method_family = init)]
        pub fn initWithTimeIntervalSinceNow(
            this: Allocated<Self>,
            secs: NSTimeInterval,
        ) -> Retained<Self>;

        #[unsafe(method(initWithTimeIntervalSince1970:))]
        #[unsafe(method_family = init)]
        pub fn initWithTimeIntervalSince1970(
            this: Allocated<Self>,
            secs: NSTimeInterval,
        ) -> Retained<Self>;

        #[unsafe(method(initWithTimeInterval:sinceDate:))]
        #[unsafe(method_family = init)]
        pub fn initWithTimeInterval_sinceDate(
            this: Allocated<Self>,
            secs_to_be_added: NSTimeInterval,
            date: &NSDate,
        ) -> Retained<Self>;
    );
}
