//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Equal to [`NSPointerFunctionsStrongMemory`](https://developer.apple.com/documentation/foundation/nspointerfunctions/options/strongmemory).
#[cfg(feature = "NSPointerFunctions")]
pub static NSHashTableStrongMemory: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::StrongMemory.0);

/// This option has been deprecated. Instead use the `NSHashTableWeakMemory` option. Equal to [`NSPointerFunctionsZeroingWeakMemory`](https://developer.apple.com/documentation/foundation/nspointerfunctionsoptions/nspointerfunctionszeroingweakmemory).
///
/// ## Discussion
///
/// Note that `NSHashTableWeakMemory` is not entirely equivalent to and compatible with the previous option’s behavior: objects must be weak-reference-safe under manual and automatic reference counting; not all objects are.
///
///
#[cfg(feature = "NSPointerFunctions")]
#[deprecated = "GC no longer supported"]
pub static NSHashTableZeroingWeakMemory: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::ZeroingWeakMemory.0);

/// Equal to [`NSPointerFunctionsCopyIn`](https://developer.apple.com/documentation/foundation/nspointerfunctions/options/copyin).
#[cfg(feature = "NSPointerFunctions")]
pub static NSHashTableCopyIn: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::CopyIn.0);

/// Equal to [`NSPointerFunctionsObjectPointerPersonality`](https://developer.apple.com/documentation/foundation/nspointerfunctions/options/objectpointerpersonality).
#[cfg(feature = "NSPointerFunctions")]
pub static NSHashTableObjectPointerPersonality: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::ObjectPointerPersonality.0);

/// Equal to [`NSPointerFunctionsWeakMemory`](https://developer.apple.com/documentation/foundation/nspointerfunctions/options/weakmemory). Uses weak read and write barriers appropriate for ARC or GC. Using [`NSPointerFunctionsWeakMemory`](https://developer.apple.com/documentation/foundation/nspointerfunctions/options/weakmemory) object references will turn to `NULL` on last release.
#[cfg(feature = "NSPointerFunctions")]
pub static NSHashTableWeakMemory: NSPointerFunctionsOptions =
    NSPointerFunctionsOptions(NSPointerFunctionsOptions::WeakMemory.0);

/// Components in a bit-field to specify the behavior of elements in an [`NSHashTable`](https://developer.apple.com/documentation/foundation/nshashtable) object.
pub type NSHashTableOptions = NSUInteger;

extern_class!(
    /// A collection similar to a set, but with broader range of available memory semantics.
    ///
    /// ## Overview
    ///
    /// The hash table is modeled after [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) with the following differences:
    ///
    /// - It can hold weak references to its members.
    ///
    /// - Its members may be copied on input or may use pointer identity for equality and hashing.
    ///
    /// - It can contain arbitrary pointers (its members are not constrained to being objects).
    ///
    /// You can configure an [`NSHashTable`](https://developer.apple.com/documentation/foundation/nshashtable) instance to operate on arbitrary pointers and not just objects, although typically you are encouraged to use the C function API for void * pointers. The object-based API (such as [`addObject:`](https://developer.apple.com/documentation/foundation/nshashtable/add(_:))) will not work for non-object pointers without type-casting.
    ///
    /// Because of its options, `NSHashTable` is not a set because it can behave differently (for example, if pointer equality is specified two `isEqual:` strings will both be entered).
    ///
    /// When configuring hash tables, note that only the options listed in [`NSHashTableOptions`](https://developer.apple.com/documentation/foundation/nshashtableoptions) guarantee that the rest of the API will work correctly—including copying, archiving, and fast enumeration. While other [`NSPointerFunctions`](https://developer.apple.com/documentation/foundation/nspointerfunctions) options are used for certain configurations, such as to hold arbitrary pointers, not all combinations of the options are valid. With some combinations the hash table may not work correctly, or may not even be initialized correctly.
    ///
    /// ### Subclassing Notes
    ///
    /// `NSHashTable` is not suitable for subclassing.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSHashTable<ObjectType: ?Sized = AnyObject>;
);

impl<ObjectType: ?Sized + Message> NSHashTable<ObjectType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewObjectType: ?Sized + Message>(
        &self,
    ) -> &NSHashTable<NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + NSCoding> NSCoding for NSHashTable<ObjectType> {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSCopying for NSHashTable<ObjectType> {}
);

#[cfg(feature = "NSObject")]
unsafe impl<ObjectType: ?Sized + Message> CopyingHelper for NSHashTable<ObjectType> {
    type Result = Self;
}

#[cfg(feature = "NSEnumerator")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSFastEnumeration for NSHashTable<ObjectType> {}
);

extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSObjectProtocol for NSHashTable<ObjectType> {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + NSSecureCoding> NSSecureCoding for NSHashTable<ObjectType> {}
);

impl<ObjectType: Message> NSHashTable<ObjectType> {
    extern_methods!(
        #[cfg(feature = "NSPointerFunctions")]
        #[unsafe(method(initWithOptions:capacity:))]
        #[unsafe(method_family = init)]
        pub fn initWithOptions_capacity(
            this: Allocated<Self>,
            options: NSPointerFunctionsOptions,
            initial_capacity: NSUInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "NSPointerFunctions")]
        #[unsafe(method(initWithPointerFunctions:capacity:))]
        #[unsafe(method_family = init)]
        pub fn initWithPointerFunctions_capacity(
            this: Allocated<Self>,
            functions: &NSPointerFunctions,
            initial_capacity: NSUInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "NSPointerFunctions")]
        #[unsafe(method(hashTableWithOptions:))]
        #[unsafe(method_family = none)]
        pub fn hashTableWithOptions(
            options: NSPointerFunctionsOptions,
        ) -> Retained<NSHashTable<ObjectType>>;

        #[deprecated = "GC no longer supported"]
        #[unsafe(method(hashTableWithWeakObjects))]
        #[unsafe(method_family = none)]
        pub fn hashTableWithWeakObjects() -> Retained<AnyObject>;

        #[unsafe(method(weakObjectsHashTable))]
        #[unsafe(method_family = none)]
        pub fn weakObjectsHashTable() -> Retained<NSHashTable<ObjectType>>;

        #[cfg(feature = "NSPointerFunctions")]
        #[unsafe(method(pointerFunctions))]
        #[unsafe(method_family = none)]
        pub fn pointerFunctions(&self) -> Retained<NSPointerFunctions>;

        #[unsafe(method(count))]
        #[unsafe(method_family = none)]
        pub fn count(&self) -> NSUInteger;

        #[unsafe(method(member:))]
        #[unsafe(method_family = none)]
        pub fn member(&self, object: Option<&ObjectType>) -> Option<Retained<ObjectType>>;

        #[cfg(feature = "NSEnumerator")]
        /// # Safety
        ///
        /// The returned enumerator's underlying collection should not be mutated while in use.
        #[unsafe(method(objectEnumerator))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectEnumerator(&self) -> Retained<NSEnumerator<ObjectType>>;

        #[unsafe(method(addObject:))]
        #[unsafe(method_family = none)]
        pub fn addObject(&self, object: Option<&ObjectType>);

        #[unsafe(method(removeObject:))]
        #[unsafe(method_family = none)]
        pub fn removeObject(&self, object: Option<&ObjectType>);

        #[unsafe(method(removeAllObjects))]
        #[unsafe(method_family = none)]
        pub fn removeAllObjects(&self);

        #[cfg(feature = "NSArray")]
        #[unsafe(method(allObjects))]
        #[unsafe(method_family = none)]
        pub fn allObjects(&self) -> Retained<NSArray<ObjectType>>;

        #[unsafe(method(anyObject))]
        #[unsafe(method_family = none)]
        pub fn anyObject(&self) -> Option<Retained<ObjectType>>;

        #[unsafe(method(containsObject:))]
        #[unsafe(method_family = none)]
        pub fn containsObject(&self, an_object: Option<&ObjectType>) -> bool;

        #[unsafe(method(intersectsHashTable:))]
        #[unsafe(method_family = none)]
        pub fn intersectsHashTable(&self, other: &NSHashTable<ObjectType>) -> bool;

        #[unsafe(method(isEqualToHashTable:))]
        #[unsafe(method_family = none)]
        pub fn isEqualToHashTable(&self, other: &NSHashTable<ObjectType>) -> bool;

        #[unsafe(method(isSubsetOfHashTable:))]
        #[unsafe(method_family = none)]
        pub fn isSubsetOfHashTable(&self, other: &NSHashTable<ObjectType>) -> bool;

        #[unsafe(method(intersectHashTable:))]
        #[unsafe(method_family = none)]
        pub fn intersectHashTable(&self, other: &NSHashTable<ObjectType>);

        #[unsafe(method(unionHashTable:))]
        #[unsafe(method_family = none)]
        pub fn unionHashTable(&self, other: &NSHashTable<ObjectType>);

        #[unsafe(method(minusHashTable:))]
        #[unsafe(method_family = none)]
        pub fn minusHashTable(&self, other: &NSHashTable<ObjectType>);

        #[cfg(feature = "NSSet")]
        #[unsafe(method(setRepresentation))]
        #[unsafe(method_family = none)]
        pub fn setRepresentation(&self) -> Retained<NSSet<ObjectType>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl<ObjectType: Message> NSHashTable<ObjectType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<ObjectType: Message> DefaultRetained for NSHashTable<ObjectType> {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// Allows successive elements of a hash table to be returned each time this structure is passed to [`NSNextHashEnumeratorItem`](https://developer.apple.com/documentation/foundation/nsnexthashenumeratoritem(_:)).
///
/// ## Overview
///
/// The fields of `NSHashEnumerator` are private.
///
///
/// **************    (void *) Hash table operations    ***************
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NSHashEnumerator {
    pub(crate) _pi: NSUInteger,
    pub(crate) _si: NSUInteger,
    pub(crate) _bs: *mut c_void,
}

unsafe impl Encode for NSHashEnumerator {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <NSUInteger>::ENCODING,
            <NSUInteger>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for NSHashEnumerator {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Deletes the specified hash table.
    ///
    /// ## Discussion
    ///
    /// Releases each element of the specified hash table and frees the table itself.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `table` generic should be of the correct type.
    pub fn NSFreeHashTable(table: &NSHashTable);
}

extern "C-unwind" {
    /// Deletes the elements of the specified hash table.
    ///
    /// ## Discussion
    ///
    /// Releases each element but doesn’t deallocate `table`. This function is useful for preserving the capacity of `table`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `table` generic should be of the correct type.
    pub fn NSResetHashTable(table: &NSHashTable);
}

/// Returns a Boolean value that indicates whether the elements of two hash tables are equal.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the two hash tables are equal—that is, if each element of `table1` is in `table2` and the two tables are the same size, otherwise [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// # Safety
///
/// - `table1` generic should be of the correct type.
/// - `table2` generic should be of the correct type.
#[inline]
pub unsafe extern "C-unwind" fn NSCompareHashTables(
    table1: &NSHashTable,
    table2: &NSHashTable,
) -> bool {
    extern "C-unwind" {
        fn NSCompareHashTables(table1: &NSHashTable, table2: &NSHashTable) -> Bool;
    }
    unsafe { NSCompareHashTables(table1, table2) }.as_bool()
}

/// Performs a shallow copy of the specified hash table.
///
/// ## Return Value
///
/// A pointer to a new copy of `table`, created in `zone` and containing pointers to the data elements of `table`.
///
///
///
/// ## Discussion
///
/// If `zone` is `NULL`, the new table is created in the default zone.
///
/// The new table adopts the callback functions of `table` and calls the `hash` and `retain` callback functions as appropriate when inserting elements into the new table.
///
///
///
/// # Safety
///
/// - `table` generic should be of the correct type.
/// - `zone` must be a valid pointer or null.
#[cfg(feature = "NSZone")]
#[inline]
pub unsafe extern "C-unwind" fn NSCopyHashTableWithZone(
    table: &NSHashTable,
    zone: *mut NSZone,
) -> Retained<NSHashTable> {
    extern "C-unwind" {
        fn NSCopyHashTableWithZone(table: &NSHashTable, zone: *mut NSZone) -> *mut NSHashTable;
    }
    let ret = unsafe { NSCopyHashTableWithZone(table, zone) };
    unsafe { Retained::from_raw(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

/// Returns an element of the hash table.
///
/// ## Return Value
///
/// The pointer in the table that matches `pointer` (as defined by the `isEqual` callback function). If there is no matching element, returns `NULL`.
///
///
///
/// # Safety
///
/// - `table` generic should be of the correct type.
/// - `pointer` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn NSHashGet(
    table: &NSHashTable,
    pointer: *const c_void,
) -> NonNull<c_void> {
    extern "C-unwind" {
        fn NSHashGet(table: &NSHashTable, pointer: *const c_void) -> Option<NonNull<c_void>>;
    }
    let ret = unsafe { NSHashGet(table, pointer) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Adds an element to the specified hash table.
    ///
    /// ## Discussion
    ///
    /// Inserts `pointer`, which must not be `NULL`, into `table`. If `pointer` matches an item already in the table, the previous pointer is released using the `release` callback function that was specified when the table was created.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `table` generic should be of the correct type.
    /// - `pointer` must be a valid pointer or null.
    pub fn NSHashInsert(table: &NSHashTable, pointer: *const c_void);
}

extern "C-unwind" {
    /// Adds an element to the specified hash table.
    ///
    /// ## Discussion
    ///
    /// Inserts `pointer`, which must not be `NULL`, into `table`. Unlike `NSHashInsert`, this function raises `NSInvalidArgumentException` if `table` already includes an element that matches `pointer`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `table` generic should be of the correct type.
    /// - `pointer` must be a valid pointer or null.
    pub fn NSHashInsertKnownAbsent(table: &NSHashTable, pointer: *const c_void);
}

extern "C-unwind" {
    /// Adds an element to the specified hash table only if the table does not already contain the element.
    ///
    /// ## Return Value
    ///
    /// If `pointer` matches an item already in `table`, returns the preexisting pointer; otherwise, `pointer` is added to the `table` and returns `NULL`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You must not specify `NULL` for `pointer`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `table` generic should be of the correct type.
    /// - `pointer` must be a valid pointer or null.
    pub fn NSHashInsertIfAbsent(table: &NSHashTable, pointer: *const c_void) -> *mut c_void;
}

extern "C-unwind" {
    /// Removes an element from the specified hash table.
    ///
    /// ## Discussion
    ///
    /// If `pointer` matches an item already in `table`, this function releases the preexisting item.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `table` generic should be of the correct type.
    /// - `pointer` must be a valid pointer or null.
    pub fn NSHashRemove(table: &NSHashTable, pointer: *const c_void);
}

extern "C-unwind" {
    /// Creates an enumerator for the specified hash table.
    ///
    /// ## Return Value
    ///
    /// An NSHashEnumerator structure that will cause successive elements of `table` to be returned each time this enumerator is passed to `NSNextHashEnumeratorItem`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `table` generic should be of the correct type.
    pub fn NSEnumerateHashTable(table: &NSHashTable) -> NSHashEnumerator;
}

extern "C-unwind" {
    /// Returns the next hash-table element in the enumeration.
    ///
    /// ## Return Value
    ///
    /// The next element in the table that `enumerator` is associated with, or `NULL` if `enumerator` has already iterated over all the elements.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    pub fn NSNextHashEnumeratorItem(enumerator: NonNull<NSHashEnumerator>) -> *mut c_void;
}

extern "C-unwind" {
    /// Used when finished with an enumerator.
    ///
    /// ## Discussion
    ///
    /// This function should be called when you have finished using the enumeration struct `enumerator`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `enumerator` must be a valid pointer.
    pub fn NSEndHashTableEnumeration(enumerator: NonNull<NSHashEnumerator>);
}

extern "C-unwind" {
    /// Returns the number of elements in a hash table.
    ///
    /// ## Return Value
    ///
    /// The number of elements currently in `table`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `table` generic should be of the correct type.
    pub fn NSCountHashTable(table: &NSHashTable) -> NSUInteger;
}

#[cfg(feature = "NSString")]
impl NSString {
    /// Returns a string describing the hash table’s contents.
    ///
    /// ## Return Value
    ///
    /// A string describing `table`’s contents.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The function iterates over the elements of `table`, and for each one appends the string returned by the `describe` callback function. If `NULL` was specified for the callback function, the hexadecimal value of each pointer is added to the string.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `table` generic should be of the correct type.
    #[doc(alias = "NSStringFromHashTable")]
    #[cfg(feature = "NSString")]
    #[inline]
    pub unsafe fn from_hash_table(table: &NSHashTable) -> Retained<NSString> {
        extern "C-unwind" {
            fn NSStringFromHashTable(table: &NSHashTable) -> *mut NSString;
        }
        let ret = unsafe { NSStringFromHashTable(table) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// Returns all of the elements in the specified hash table.
///
/// ## Return Value
///
/// An array object containing all the elements of `table`.
///
///
///
/// ## Discussion
///
/// This function should be called only when the table elements are objects, not when they’re any other data type.
///
///
///
/// # Safety
///
/// `table` generic should be of the correct type.
#[cfg(feature = "NSArray")]
#[inline]
pub unsafe extern "C-unwind" fn NSAllHashTableObjects(table: &NSHashTable) -> Retained<NSArray> {
    extern "C-unwind" {
        fn NSAllHashTableObjects(table: &NSHashTable) -> *mut NSArray;
    }
    let ret = unsafe { NSAllHashTableObjects(table) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

/// Defines a structure that contains the function pointers used to configure behavior of `NSHashTable` with respect to elements within a hash table.
///
/// ## Overview
///
/// All functions must know the types of things in the hash table to be able to operate on them. Sets of predefined call backs are described in [`NSHashTable`](https://developer.apple.com/documentation/foundation/nshashtable).
///
///
/// **************    Legacy    ***************
#[cfg(feature = "NSString")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct NSHashTableCallBacks {
    pub hash:
        Option<unsafe extern "C-unwind" fn(NonNull<NSHashTable>, NonNull<c_void>) -> NSUInteger>,
    pub isEqual: Option<
        unsafe extern "C-unwind" fn(NonNull<NSHashTable>, NonNull<c_void>, NonNull<c_void>) -> Bool,
    >,
    pub retain: Option<unsafe extern "C-unwind" fn(NonNull<NSHashTable>, NonNull<c_void>)>,
    pub release: Option<unsafe extern "C-unwind" fn(NonNull<NSHashTable>, NonNull<c_void>)>,
    pub describe:
        Option<unsafe extern "C-unwind" fn(NonNull<NSHashTable>, NonNull<c_void>) -> *mut NSString>,
}

#[cfg(feature = "NSString")]
unsafe impl Encode for NSHashTableCallBacks {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <Option<
                unsafe extern "C-unwind" fn(NonNull<NSHashTable>, NonNull<c_void>) -> NSUInteger,
            >>::ENCODING,
            <Option<
                unsafe extern "C-unwind" fn(
                    NonNull<NSHashTable>,
                    NonNull<c_void>,
                    NonNull<c_void>,
                ) -> Bool,
            >>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(NonNull<NSHashTable>, NonNull<c_void>)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(NonNull<NSHashTable>, NonNull<c_void>)>>::ENCODING,
            <Option<
                unsafe extern "C-unwind" fn(NonNull<NSHashTable>, NonNull<c_void>) -> *mut NSString,
            >>::ENCODING,
        ],
    );
}

#[cfg(feature = "NSString")]
unsafe impl RefEncode for NSHashTableCallBacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Creates a new hash table in a given zone.
///
/// ## Return Value
///
/// A pointer to a new hash table created in the specified zone. If `zone` is `NULL`, the hash table is created in the default zone.
///
///
///
/// ## Discussion
///
/// The table’s size is dependent on (but generally not equal to) `capacity`. If `capacity` is 0, a small hash table is created. The [`NSHashTableCallBacks`](https://developer.apple.com/documentation/foundation/nshashtablecallbacks) structure `callBacks` has five pointers to functions, with the following defaults: pointer hashing, if `hash` is `NULL`; pointer equality, if `isEqual` is `NULL`; no callback upon adding an element, if `retain` is `NULL`; no callback upon removing an element, if `release` is `NULL`; and a function returning a pointer’s hexadecimal value as a string, if `describe` is `NULL`. The hashing function must be defined such that if two data elements are equal, as defined by the comparison function, the values produced by hashing on these elements must also be equal. Also, data elements must remain invariant if the value of the hashing function depends on them; for example, if the hashing function operates directly on the characters of a string, that string can’t change.
///
///
///
/// # Safety
///
/// - `call_backs` struct field 1 must be implemented correctly.
/// - `call_backs` struct field 2 must be implemented correctly.
/// - `call_backs` struct field 3 must be implemented correctly.
/// - `call_backs` struct field 4 must be implemented correctly.
/// - `call_backs` struct field 5 must be implemented correctly.
/// - `zone` must be a valid pointer or null.
#[cfg(all(feature = "NSString", feature = "NSZone"))]
#[inline]
pub unsafe extern "C-unwind" fn NSCreateHashTableWithZone(
    call_backs: NSHashTableCallBacks,
    capacity: NSUInteger,
    zone: *mut NSZone,
) -> Retained<NSHashTable> {
    extern "C-unwind" {
        fn NSCreateHashTableWithZone(
            call_backs: NSHashTableCallBacks,
            capacity: NSUInteger,
            zone: *mut NSZone,
        ) -> *mut NSHashTable;
    }
    let ret = unsafe { NSCreateHashTableWithZone(call_backs, capacity, zone) };
    unsafe { Retained::from_raw(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

/// Creates and returns a new hash table.
///
/// ## Return Value
///
/// A pointer to an NSHashTable created in the default zone.
///
///
///
/// ## Discussion
///
/// The table’s size is dependent on (but generally not equal to) `capacity`. If `capacity` is 0, a small hash table is created. The [`NSHashTableCallBacks`](https://developer.apple.com/documentation/foundation/nshashtablecallbacks) structure `callBacks` has five pointers to functions, with the following defaults: pointer hashing, if `hash` is `NULL`; pointer equality, if `isEqual` is `NULL`; no callback upon adding an element, if `retain` is `NULL`; no callback upon removing an element, if `release` is `NULL`; and a function returning a pointer’s hexadecimal value as a string, if `describe` is `NULL`. The hashing function must be defined such that if two data elements are equal, as defined by the comparison function, the values produced by hashing on these elements must also be equal. Also, data elements must remain invariant if the value of the hashing function depends on them; for example, if the hashing function operates directly on the characters of a string, that string can’t change.
///
///
///
/// # Safety
///
/// - `call_backs` struct field 1 must be implemented correctly.
/// - `call_backs` struct field 2 must be implemented correctly.
/// - `call_backs` struct field 3 must be implemented correctly.
/// - `call_backs` struct field 4 must be implemented correctly.
/// - `call_backs` struct field 5 must be implemented correctly.
#[cfg(feature = "NSString")]
#[inline]
pub unsafe extern "C-unwind" fn NSCreateHashTable(
    call_backs: NSHashTableCallBacks,
    capacity: NSUInteger,
) -> Retained<NSHashTable> {
    extern "C-unwind" {
        fn NSCreateHashTable(
            call_backs: NSHashTableCallBacks,
            capacity: NSUInteger,
        ) -> *mut NSHashTable;
    }
    let ret = unsafe { NSCreateHashTable(call_backs, capacity) };
    unsafe { Retained::from_raw(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C" {
    /// For sets of `NSInteger`-sized quantities or smaller (for example, `int`, `long`, or `unichar`).
    #[cfg(feature = "NSString")]
    pub static NSIntegerHashCallBacks: NSHashTableCallBacks;
}

extern "C" {
    /// For sets of pointers, hashed by address.
    #[cfg(feature = "NSString")]
    pub static NSNonOwnedPointerHashCallBacks: NSHashTableCallBacks;
}

extern "C" {
    /// For sets of objects, but without retaining/releasing.
    #[cfg(feature = "NSString")]
    pub static NSNonRetainedObjectHashCallBacks: NSHashTableCallBacks;
}

extern "C" {
    /// For sets of objects (similar to `NSSet`).
    #[cfg(feature = "NSString")]
    pub static NSObjectHashCallBacks: NSHashTableCallBacks;
}

extern "C" {
    /// For sets of objects, with transfer of ownership upon insertion, using pointer equality.
    #[cfg(feature = "NSString")]
    pub static NSOwnedObjectIdentityHashCallBacks: NSHashTableCallBacks;
}

extern "C" {
    /// For sets of pointers, with transfer of ownership upon insertion.
    #[cfg(feature = "NSString")]
    pub static NSOwnedPointerHashCallBacks: NSHashTableCallBacks;
}

extern "C" {
    /// For sets of pointers to structs, when the first field of the struct is `int`-sized.
    #[cfg(feature = "NSString")]
    pub static NSPointerToStructHashCallBacks: NSHashTableCallBacks;
}

extern "C" {
    /// For sets of pointer-sized quantities or smaller (for example, `int`, `long`, or `unichar`).
    #[cfg(feature = "NSString")]
    #[deprecated = "Not supported"]
    pub static NSIntHashCallBacks: NSHashTableCallBacks;
}

#[cfg(feature = "NSString")]
#[deprecated = "renamed to `NSString::from_hash_table`"]
#[inline]
pub unsafe extern "C-unwind" fn NSStringFromHashTable(table: &NSHashTable) -> Retained<NSString> {
    extern "C-unwind" {
        fn NSStringFromHashTable(table: &NSHashTable) -> *mut NSString;
    }
    let ret = unsafe { NSStringFromHashTable(table) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}
