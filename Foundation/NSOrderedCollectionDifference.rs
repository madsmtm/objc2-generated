//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Constants that specify the options to use when creating an ordered collection difference.
/// Options supported by methods that produce difference objects.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSOrderedCollectionDifferenceCalculationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSOrderedCollectionDifferenceCalculationOptions: NSUInteger {
/// An option that indicates that the difference should omit references to the insertions.
/// Insertion changes do not store a reference to the inserted object.
        #[doc(alias = "NSOrderedCollectionDifferenceCalculationOmitInsertedObjects")]
        const OmitInsertedObjects = 1<<0;
/// An option that indicates that the difference should omit references to the removals.
/// Insertion changes do not store a reference to the removed object.
        #[doc(alias = "NSOrderedCollectionDifferenceCalculationOmitRemovedObjects")]
        const OmitRemovedObjects = 1<<1;
/// An option that identifies insertions or removals as moves.
///
/// ## Discussion
///
/// When you use the option to infer moves, the difference calculation adds an associated index to change objects to indicate the original positions of the objects.
///
///
/// Assume objects that were uniquely removed and inserted were moved.
/// This is useful when diffing based on identity instead of equality.
        #[doc(alias = "NSOrderedCollectionDifferenceCalculationInferMoves")]
        const InferMoves = 1<<2;
    }
}

unsafe impl Encode for NSOrderedCollectionDifferenceCalculationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSOrderedCollectionDifferenceCalculationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object representing the difference between two ordered collections.
    ///
    /// ## Overview
    ///
    /// Use [`differenceFromArray:`](https://developer.apple.com/documentation/foundation/nsarray/differencefromarray:) or one of its variations to get an instance of [`NSOrderedCollectionDifference`](https://developer.apple.com/documentation/foundation/nsorderedcollectiondifference), which represents the difference between two ordered collections.
    ///
    /// For example, the following sample compares two arrays of strings to create a difference that represents the changes:
    ///
    /// ```objc
    /// NSArray *original = @[@"Red", @"Green", @"Blue"];
    /// NSArray *modified = @[@"Red", @"Blue", @"Green"];
    ///
    /// NSOrderedCollectionDifference *diff = [original differenceFromArray:modified];
    ///
    /// // diff.hasChanges == TRUE
    /// // diff.insertions.count == 1
    /// // diff.removals.count == 1
    ///
    /// ```
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSOrderedCollectionDifference<ObjectType: ?Sized = AnyObject>;
);

impl<ObjectType: ?Sized + Message> NSOrderedCollectionDifference<ObjectType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewObjectType: ?Sized + Message>(
        &self,
    ) -> &NSOrderedCollectionDifference<NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSEnumerator")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSFastEnumeration for NSOrderedCollectionDifference<ObjectType> {}
);

extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSObjectProtocol for NSOrderedCollectionDifference<ObjectType> {}
);

impl<ObjectType: Message> NSOrderedCollectionDifference<ObjectType> {
    extern_methods!(
        #[cfg(all(feature = "NSArray", feature = "NSOrderedCollectionChange"))]
        /// Creates a new difference representing the changes in the parameter.
        ///
        /// For clients interested in the difference between two collections, the
        /// collection's differenceFrom method should be used instead.
        ///
        /// To guarantee that instances are unambiguous and safe for compatible base
        /// states, this method requires that its parameter conform to the following
        /// requirements:
        ///
        /// 1) All insertion offsets are unique
        /// 2) All removal offsets are unique
        /// 3) All associated indexes match a change with the opposite parity.
        #[unsafe(method(initWithChanges:))]
        #[unsafe(method_family = init)]
        pub fn initWithChanges(
            this: Allocated<Self>,
            changes: &NSArray<NSOrderedCollectionChange<ObjectType>>,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "NSArray",
            feature = "NSIndexSet",
            feature = "NSOrderedCollectionChange"
        ))]
        #[unsafe(method(initWithInsertIndexes:insertedObjects:removeIndexes:removedObjects:additionalChanges:))]
        #[unsafe(method_family = init)]
        pub fn initWithInsertIndexes_insertedObjects_removeIndexes_removedObjects_additionalChanges(
            this: Allocated<Self>,
            inserts: &NSIndexSet,
            inserted_objects: Option<&NSArray<ObjectType>>,
            removes: &NSIndexSet,
            removed_objects: Option<&NSArray<ObjectType>>,
            changes: &NSArray<NSOrderedCollectionChange<ObjectType>>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSArray", feature = "NSIndexSet"))]
        #[unsafe(method(initWithInsertIndexes:insertedObjects:removeIndexes:removedObjects:))]
        #[unsafe(method_family = init)]
        pub fn initWithInsertIndexes_insertedObjects_removeIndexes_removedObjects(
            this: Allocated<Self>,
            inserts: &NSIndexSet,
            inserted_objects: Option<&NSArray<ObjectType>>,
            removes: &NSIndexSet,
            removed_objects: Option<&NSArray<ObjectType>>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSArray", feature = "NSOrderedCollectionChange"))]
        #[unsafe(method(insertions))]
        #[unsafe(method_family = none)]
        pub fn insertions(&self) -> Retained<NSArray<NSOrderedCollectionChange<ObjectType>>>;

        #[cfg(all(feature = "NSArray", feature = "NSOrderedCollectionChange"))]
        #[unsafe(method(removals))]
        #[unsafe(method_family = none)]
        pub fn removals(&self) -> Retained<NSArray<NSOrderedCollectionChange<ObjectType>>>;

        #[unsafe(method(hasChanges))]
        #[unsafe(method_family = none)]
        pub fn hasChanges(&self) -> bool;

        #[cfg(all(feature = "NSOrderedCollectionChange", feature = "block2"))]
        /// # Safety
        ///
        /// `block` block's return must be a valid pointer.
        #[unsafe(method(differenceByTransformingChangesWithBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn differenceByTransformingChangesWithBlock(
            &self,
            block: &block2::DynBlock<
                dyn Fn(
                        NonNull<NSOrderedCollectionChange<ObjectType>>,
                    ) -> NonNull<NSOrderedCollectionChange<AnyObject>>
                    + '_,
            >,
        ) -> Retained<NSOrderedCollectionDifference<AnyObject>>;

        #[unsafe(method(inverseDifference))]
        #[unsafe(method_family = none)]
        pub fn inverseDifference(&self) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl<ObjectType: Message> NSOrderedCollectionDifference<ObjectType> {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<ObjectType: Message> DefaultRetained for NSOrderedCollectionDifference<ObjectType> {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
