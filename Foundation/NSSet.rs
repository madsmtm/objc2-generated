//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

extern_class!(
    /// A static, unordered collection of unique objects.
    ///
    /// ## Overview
    ///
    /// The [`NSSet`](https://developer.apple.com/documentation/foundation/nsset), [`NSMutableSet`](https://developer.apple.com/documentation/foundation/nsmutableset), and [`NSCountedSet`](https://developer.apple.com/documentation/foundation/nscountedset) classes declare the programmatic interface to an unordered collection of objects.
    ///
    /// [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) declares the programmatic interface for static sets of distinct objects. You establish a static set’s entries when it’s created, and can’t modify the entries after that. [`NSMutableSet`](https://developer.apple.com/documentation/foundation/nsmutableset), on the other hand, declares a programmatic interface for dynamic sets of distinct objects. A dynamic — or mutable — set allows the addition and deletion of entries at any time, automatically allocating memory as needed.
    ///
    /// Use sets as an alternative to arrays when the order of elements isn’t important and you need to consider performance in testing whether the set contains an object. With an array, testing for membership is slower than with sets.
    ///
    /// [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) is “toll-free bridged” with its Core Foundation counterpart, [`CFSetRef`](https://developer.apple.com/documentation/corefoundation/cfset). See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information on toll-free bridging.
    ///
    /// In Swift, use this class instead of a [`Set`](https://developer.apple.com/documentation/swift/set) constant in cases where you require reference semantics.
    ///
    /// ### Subclassing Notes
    ///
    /// There should be little need of subclassing. If you need to customize behavior, it’s often better to consider composition instead of subclassing.
    ///
    /// #### Methods to Override
    ///
    /// In a subclass, you must override all of its primitive methods:
    ///
    /// - [`count`](https://developer.apple.com/documentation/foundation/nsset/count)
    ///
    /// - [`member:`](https://developer.apple.com/documentation/foundation/nsset/member(_:))
    ///
    /// - [`objectEnumerator`](https://developer.apple.com/documentation/foundation/nsset/objectenumerator())
    ///
    /// #### Alternatives to Subclassing
    ///
    /// Before making a custom class of [`NSSet`](https://developer.apple.com/documentation/foundation/nsset), investigate [`NSHashTable`](https://developer.apple.com/documentation/foundation/nshashtable) and the corresponding Core Foundation type, [`CFSetRef`](https://developer.apple.com/documentation/corefoundation/cfset). Because [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) and [`CFSetRef`](https://developer.apple.com/documentation/corefoundation/cfset) are “toll-free bridged,” you can substitute a [`CFSetRef`](https://developer.apple.com/documentation/corefoundation/cfset) object for a [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) object in your code (with appropriate casting). Although they’re corresponding types, [`CFSetRef`](https://developer.apple.com/documentation/corefoundation/cfset) and [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) don’t have identical interfaces or implementations, and you can sometimes do things with [`CFSetRef`](https://developer.apple.com/documentation/corefoundation/cfset) that you can’t easily do with [`NSSet`](https://developer.apple.com/documentation/foundation/nsset).
    ///
    /// If the behavior you want to add supplements that of the existing class, you could write a category on [`NSSet`](https://developer.apple.com/documentation/foundation/nsset). Keep in mind, however, that this category affects all instances of [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) that you use, and this might have unintended consequences. Alternatively, you could use composition to achieve the desired behavior.
    ///
    ///
    /// **************    Immutable Set    ***************
    #[unsafe(super(NSObject))]
    #[derive(PartialEq, Eq, Hash)]
    pub struct NSSet<ObjectType: ?Sized = AnyObject>;
);

#[cfg(feature = "objc2-core-foundation")]
impl<ObjectType: ?Sized + Message> AsRef<NSSet<ObjectType>> for CFSet<ObjectType> {
    #[inline]
    fn as_ref(&self) -> &NSSet<ObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl<ObjectType: ?Sized + Message> AsRef<CFSet<ObjectType>> for NSSet<ObjectType> {
    #[inline]
    fn as_ref(&self) -> &CFSet<ObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

impl<ObjectType: ?Sized + Message> NSSet<ObjectType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewObjectType: ?Sized + Message>(&self) -> &NSSet<NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + NSCoding> NSCoding for NSSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSCopying for NSSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
unsafe impl<ObjectType: ?Sized + Message> CopyingHelper for NSSet<ObjectType> {
    type Result = Self;
}

#[cfg(feature = "NSEnumerator")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSFastEnumeration for NSSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSMutableCopying for NSSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
unsafe impl<ObjectType: ?Sized + Message> MutableCopyingHelper for NSSet<ObjectType> {
    type Result = NSMutableSet<ObjectType>;
}

extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSObjectProtocol for NSSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + NSSecureCoding> NSSecureCoding for NSSet<ObjectType> {}
);

impl<ObjectType: Message> NSSet<ObjectType> {
    extern_methods!(
        #[unsafe(method(count))]
        #[unsafe(method_family = none)]
        pub fn count(&self) -> NSUInteger;

        #[unsafe(method(member:))]
        #[unsafe(method_family = none)]
        pub fn member(&self, object: &ObjectType) -> Option<Retained<ObjectType>>;

        #[cfg(feature = "NSEnumerator")]
        /// # Safety
        ///
        /// The returned enumerator's underlying collection should not be mutated while in use.
        #[unsafe(method(objectEnumerator))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectEnumerator(&self) -> Retained<NSEnumerator<ObjectType>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `objects` must be a valid pointer or null.
        #[unsafe(method(initWithObjects:count:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithObjects_count(
            this: Allocated<Self>,
            objects: *mut NonNull<ObjectType>,
            cnt: NSUInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl<ObjectType: Message> NSSet<ObjectType> {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<ObjectType: Message> DefaultRetained for NSSet<ObjectType> {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSExtendedSet.
impl<ObjectType: Message> NSSet<ObjectType> {
    extern_methods!(
        #[cfg(feature = "NSArray")]
        #[unsafe(method(allObjects))]
        #[unsafe(method_family = none)]
        pub fn allObjects(&self) -> Retained<NSArray<ObjectType>>;

        #[unsafe(method(anyObject))]
        #[unsafe(method_family = none)]
        pub fn anyObject(&self) -> Option<Retained<ObjectType>>;

        #[unsafe(method(containsObject:))]
        #[unsafe(method_family = none)]
        pub fn containsObject(&self, an_object: &ObjectType) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(description))]
        #[unsafe(method_family = none)]
        pub fn description(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `locale` should be of the correct type.
        #[unsafe(method(descriptionWithLocale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn descriptionWithLocale(
            &self,
            locale: Option<&AnyObject>,
        ) -> Retained<NSString>;

        #[unsafe(method(intersectsSet:))]
        #[unsafe(method_family = none)]
        pub fn intersectsSet(&self, other_set: &NSSet<ObjectType>) -> bool;

        #[unsafe(method(isEqualToSet:))]
        #[unsafe(method_family = none)]
        pub fn isEqualToSet(&self, other_set: &NSSet<ObjectType>) -> bool;

        #[unsafe(method(isSubsetOfSet:))]
        #[unsafe(method_family = none)]
        pub fn isSubsetOfSet(&self, other_set: &NSSet<ObjectType>) -> bool;

        /// # Safety
        ///
        /// `a_selector` must be a valid selector.
        #[unsafe(method(makeObjectsPerformSelector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeObjectsPerformSelector(&self, a_selector: Sel);

        /// # Safety
        ///
        /// - `a_selector` must be a valid selector.
        /// - `argument` should be of the correct type.
        #[unsafe(method(makeObjectsPerformSelector:withObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeObjectsPerformSelector_withObject(
            &self,
            a_selector: Sel,
            argument: Option<&AnyObject>,
        );

        #[unsafe(method(setByAddingObject:))]
        #[unsafe(method_family = none)]
        pub fn setByAddingObject(&self, an_object: &ObjectType) -> Retained<NSSet<ObjectType>>;

        #[unsafe(method(setByAddingObjectsFromSet:))]
        #[unsafe(method_family = none)]
        pub fn setByAddingObjectsFromSet(
            &self,
            other: &NSSet<ObjectType>,
        ) -> Retained<NSSet<ObjectType>>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(setByAddingObjectsFromArray:))]
        #[unsafe(method_family = none)]
        pub fn setByAddingObjectsFromArray(
            &self,
            other: &NSArray<ObjectType>,
        ) -> Retained<NSSet<ObjectType>>;

        #[cfg(feature = "block2")]
        #[unsafe(method(enumerateObjectsUsingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateObjectsUsingBlock(
            &self,
            block: &block2::DynBlock<dyn Fn(NonNull<ObjectType>, NonNull<Bool>) + '_>,
        );

        #[cfg(all(feature = "NSObjCRuntime", feature = "block2"))]
        #[unsafe(method(enumerateObjectsWithOptions:usingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateObjectsWithOptions_usingBlock(
            &self,
            opts: NSEnumerationOptions,
            block: &block2::DynBlock<dyn Fn(NonNull<ObjectType>, NonNull<Bool>) + '_>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(objectsPassingTest:))]
        #[unsafe(method_family = none)]
        pub fn objectsPassingTest(
            &self,
            predicate: &block2::DynBlock<dyn Fn(NonNull<ObjectType>, NonNull<Bool>) -> Bool + '_>,
        ) -> Retained<NSSet<ObjectType>>;

        #[cfg(all(feature = "NSObjCRuntime", feature = "block2"))]
        #[unsafe(method(objectsWithOptions:passingTest:))]
        #[unsafe(method_family = none)]
        pub fn objectsWithOptions_passingTest(
            &self,
            opts: NSEnumerationOptions,
            predicate: &block2::DynBlock<dyn Fn(NonNull<ObjectType>, NonNull<Bool>) -> Bool + '_>,
        ) -> Retained<NSSet<ObjectType>>;
    );
}

/// NSSetCreation.
impl<ObjectType: Message> NSSet<ObjectType> {
    extern_methods!(
        #[unsafe(method(set))]
        #[unsafe(method_family = none)]
        pub fn set() -> Retained<Self>;

        #[unsafe(method(setWithObject:))]
        #[unsafe(method_family = none)]
        pub fn setWithObject(object: &ObjectType) -> Retained<Self>;

        /// # Safety
        ///
        /// `objects` must be a valid pointer.
        #[unsafe(method(setWithObjects:count:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWithObjects_count(
            objects: NonNull<NonNull<ObjectType>>,
            cnt: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(setWithSet:))]
        #[unsafe(method_family = none)]
        pub fn setWithSet(set: &NSSet<ObjectType>) -> Retained<Self>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(setWithArray:))]
        #[unsafe(method_family = none)]
        pub fn setWithArray(array: &NSArray<ObjectType>) -> Retained<Self>;

        #[unsafe(method(initWithSet:))]
        #[unsafe(method_family = init)]
        pub fn initWithSet(this: Allocated<Self>, set: &NSSet<ObjectType>) -> Retained<Self>;

        #[unsafe(method(initWithSet:copyItems:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSet_copyItems(
            this: Allocated<Self>,
            set: &NSSet<ObjectType>,
            flag: bool,
        ) -> Retained<Self>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(initWithArray:))]
        #[unsafe(method_family = init)]
        pub fn initWithArray(this: Allocated<Self>, array: &NSArray<ObjectType>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSSet`.
///
/// NSSetCreation.
impl<ObjectType: Message> NSMutableSet<ObjectType> {
    extern_methods!(
        #[unsafe(method(set))]
        #[unsafe(method_family = none)]
        pub fn set() -> Retained<Self>;

        #[unsafe(method(setWithObject:))]
        #[unsafe(method_family = none)]
        pub fn setWithObject(object: &ObjectType) -> Retained<Self>;

        /// # Safety
        ///
        /// `objects` must be a valid pointer.
        #[unsafe(method(setWithObjects:count:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWithObjects_count(
            objects: NonNull<NonNull<ObjectType>>,
            cnt: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(setWithSet:))]
        #[unsafe(method_family = none)]
        pub fn setWithSet(set: &NSSet<ObjectType>) -> Retained<Self>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(setWithArray:))]
        #[unsafe(method_family = none)]
        pub fn setWithArray(array: &NSArray<ObjectType>) -> Retained<Self>;

        #[unsafe(method(initWithSet:))]
        #[unsafe(method_family = init)]
        pub fn initWithSet(this: Allocated<Self>, set: &NSSet<ObjectType>) -> Retained<Self>;

        #[unsafe(method(initWithSet:copyItems:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSet_copyItems(
            this: Allocated<Self>,
            set: &NSSet<ObjectType>,
            flag: bool,
        ) -> Retained<Self>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(initWithArray:))]
        #[unsafe(method_family = init)]
        pub fn initWithArray(this: Allocated<Self>, array: &NSArray<ObjectType>) -> Retained<Self>;
    );
}

extern_class!(
    /// A dynamic unordered collection of unique objects.
    ///
    /// ## Overview
    ///
    /// You can use this type in Swift instead of a [`Set`](https://developer.apple.com/documentation/swift/set) in cases that require reference semantics.
    ///
    /// The `NSMutableSet` class declares the programmatic interface to a mutable, unordered collection of distinct objects.
    ///
    /// The [`NSCountedSet`](https://developer.apple.com/documentation/foundation/nscountedset) class, which is a concrete subclass of `NSMutableSet`, supports mutable sets that can contain multiple instances of the same element. The [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) class supports creating and managing immutable sets.
    ///
    /// NSMutableSet is “toll-free bridged” with its Core Foundation counterpart, [`CFMutableSetRef`](https://developer.apple.com/documentation/corefoundation/cfmutableset). See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information.
    ///
    /// ### Subclassing Notes
    ///
    /// There should be little need of subclassing. If you need to customize behavior, it is often better to consider composition instead of subclassing.
    ///
    /// #### Methods to Override
    ///
    /// In a subclass, you must override both of its primitive methods:
    ///
    /// - [`addObject:`](https://developer.apple.com/documentation/foundation/nsmutableset/add(_:))
    ///
    /// - [`removeObject:`](https://developer.apple.com/documentation/foundation/nsmutableset/remove(_:))
    ///
    /// You must also override the primitive methods of the [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) class.
    ///
    ///
    /// **************    Mutable Set    ***************
    #[unsafe(super(NSSet<ObjectType>, NSObject))]
    #[derive(PartialEq, Eq, Hash)]
    pub struct NSMutableSet<ObjectType: ?Sized = AnyObject>;
);

#[cfg(feature = "objc2-core-foundation")]
impl<ObjectType: ?Sized + Message> AsRef<NSMutableSet<ObjectType>> for CFMutableSet<ObjectType> {
    #[inline]
    fn as_ref(&self) -> &NSMutableSet<ObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl<ObjectType: ?Sized + Message> AsRef<CFMutableSet<ObjectType>> for NSMutableSet<ObjectType> {
    #[inline]
    fn as_ref(&self) -> &CFMutableSet<ObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

impl<ObjectType: ?Sized + Message> NSMutableSet<ObjectType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewObjectType: ?Sized + Message>(
        &self,
    ) -> &NSMutableSet<NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + NSCoding> NSCoding for NSMutableSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSCopying for NSMutableSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
unsafe impl<ObjectType: ?Sized + Message> CopyingHelper for NSMutableSet<ObjectType> {
    type Result = NSSet<ObjectType>;
}

#[cfg(feature = "NSEnumerator")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSFastEnumeration for NSMutableSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSMutableCopying for NSMutableSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
unsafe impl<ObjectType: ?Sized + Message> MutableCopyingHelper for NSMutableSet<ObjectType> {
    type Result = Self;
}

extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSObjectProtocol for NSMutableSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + NSSecureCoding> NSSecureCoding for NSMutableSet<ObjectType> {}
);

impl<ObjectType: Message> NSMutableSet<ObjectType> {
    extern_methods!(
        #[unsafe(method(addObject:))]
        #[unsafe(method_family = none)]
        pub fn addObject(&self, object: &ObjectType);

        #[unsafe(method(removeObject:))]
        #[unsafe(method_family = none)]
        pub fn removeObject(&self, object: &ObjectType);

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithCapacity:))]
        #[unsafe(method_family = init)]
        pub fn initWithCapacity(this: Allocated<Self>, num_items: NSUInteger) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSSet`.
impl<ObjectType: Message> NSMutableSet<ObjectType> {
    extern_methods!(
        /// # Safety
        ///
        /// `objects` must be a valid pointer or null.
        #[unsafe(method(initWithObjects:count:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithObjects_count(
            this: Allocated<Self>,
            objects: *mut NonNull<ObjectType>,
            cnt: NSUInteger,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl<ObjectType: Message> NSMutableSet<ObjectType> {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<ObjectType: Message> DefaultRetained for NSMutableSet<ObjectType> {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSExtendedMutableSet.
impl<ObjectType: Message> NSMutableSet<ObjectType> {
    extern_methods!(
        #[cfg(feature = "NSArray")]
        #[unsafe(method(addObjectsFromArray:))]
        #[unsafe(method_family = none)]
        pub fn addObjectsFromArray(&self, array: &NSArray<ObjectType>);

        #[unsafe(method(intersectSet:))]
        #[unsafe(method_family = none)]
        pub fn intersectSet(&self, other_set: &NSSet<ObjectType>);

        #[unsafe(method(minusSet:))]
        #[unsafe(method_family = none)]
        pub fn minusSet(&self, other_set: &NSSet<ObjectType>);

        #[unsafe(method(removeAllObjects))]
        #[unsafe(method_family = none)]
        pub fn removeAllObjects(&self);

        #[unsafe(method(unionSet:))]
        #[unsafe(method_family = none)]
        pub fn unionSet(&self, other_set: &NSSet<ObjectType>);

        #[unsafe(method(setSet:))]
        #[unsafe(method_family = none)]
        pub fn setSet(&self, other_set: &NSSet<ObjectType>);
    );
}

/// NSMutableSetCreation.
impl<ObjectType: Message> NSMutableSet<ObjectType> {
    extern_methods!(
        #[unsafe(method(setWithCapacity:))]
        #[unsafe(method_family = none)]
        pub fn setWithCapacity(num_items: NSUInteger) -> Retained<Self>;
    );
}

extern_class!(
    /// A mutable, unordered collection of distinct objects that may appear more than once in the collection.
    ///
    /// ## Overview
    ///
    /// Each distinct object inserted into an [`NSCountedSet`](https://developer.apple.com/documentation/foundation/nscountedset) object has a counter associated with it. [`NSCountedSet`](https://developer.apple.com/documentation/foundation/nscountedset) keeps track of the number of times objects are inserted and requires that objects be removed the same number of times. Thus, there is only one instance of an object in an [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) object even if the object has been added to the set multiple times. The [`count`](https://developer.apple.com/documentation/foundation/nsset/count) method defined by the superclass [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) has special significance; it returns the number of distinct objects, not the total number of times objects are represented in the set. The [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) and [`NSMutableSet`](https://developer.apple.com/documentation/foundation/nsmutableset) classes are provided for static and dynamic sets, respectively, whose elements are distinct.
    ///
    /// While [`NSCountedSet`](https://developer.apple.com/documentation/foundation/nscountedset) and [`CFBagRef`](https://developer.apple.com/documentation/corefoundation/cfbag) are not toll-free bridged, they provide similar functionality. For more information about `CFBag`, see the [`CFBagRef`](https://developer.apple.com/documentation/corefoundation/cfbag).
    ///
    /// ### Subclassing Notes
    ///
    /// Because [`NSCountedSet`](https://developer.apple.com/documentation/foundation/nscountedset) is not a class cluster, it does not have primitive methods that provide the basis for its implementation. In general, there should be little need for subclassing.
    ///
    /// #### Methods to Override
    ///
    /// If you subclass [`NSCountedSet`](https://developer.apple.com/documentation/foundation/nscountedset), you must override any method of which you want to change the behavior.
    ///
    /// If you change the primitive behavior of an [`NSCountedSet`](https://developer.apple.com/documentation/foundation/nscountedset), for instance if you change how objects are stored, you must override all of the affected methods. These include:
    ///
    /// - [`addObject:`](https://developer.apple.com/documentation/foundation/nscountedset/add(_:))
    ///
    /// - [`removeObject:`](https://developer.apple.com/documentation/foundation/nscountedset/remove(_:))
    ///
    /// - [`objectEnumerator`](https://developer.apple.com/documentation/foundation/nscountedset/objectenumerator())
    ///
    /// - [`countForObject:`](https://developer.apple.com/documentation/foundation/nscountedset/count(for:))
    ///
    /// If you change the primitive behavior, you must also override the primitive methods of [`NSSet`](https://developer.apple.com/documentation/foundation/nsset) and [`NSMutableSet`](https://developer.apple.com/documentation/foundation/nsmutableset).
    ///
    ///
    /// **************    Counted Set    ***************
    #[unsafe(super(NSMutableSet<ObjectType>, NSSet<ObjectType>, NSObject))]
    #[derive(PartialEq, Eq, Hash)]
    pub struct NSCountedSet<ObjectType: ?Sized = AnyObject>;
);

impl<ObjectType: ?Sized + Message> NSCountedSet<ObjectType> {
    /// Unchecked conversion of the generic parameter.
    ///
    /// # Safety
    ///
    /// The generic must be valid to reinterpret as the given type.
    #[inline]
    pub unsafe fn cast_unchecked<NewObjectType: ?Sized + Message>(
        &self,
    ) -> &NSCountedSet<NewObjectType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + NSCoding> NSCoding for NSCountedSet<ObjectType> {}
);

#[cfg(feature = "NSEnumerator")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSFastEnumeration for NSCountedSet<ObjectType> {}
);

extern_conformance!(
    unsafe impl<ObjectType: ?Sized> NSObjectProtocol for NSCountedSet<ObjectType> {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl<ObjectType: ?Sized + NSSecureCoding> NSSecureCoding for NSCountedSet<ObjectType> {}
);

impl<ObjectType: Message> NSCountedSet<ObjectType> {
    extern_methods!(
        #[unsafe(method(initWithCapacity:))]
        #[unsafe(method_family = init)]
        pub fn initWithCapacity(this: Allocated<Self>, num_items: NSUInteger) -> Retained<Self>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(initWithArray:))]
        #[unsafe(method_family = init)]
        pub fn initWithArray(this: Allocated<Self>, array: &NSArray<ObjectType>) -> Retained<Self>;

        #[unsafe(method(initWithSet:))]
        #[unsafe(method_family = init)]
        pub fn initWithSet(this: Allocated<Self>, set: &NSSet<ObjectType>) -> Retained<Self>;

        #[unsafe(method(countForObject:))]
        #[unsafe(method_family = none)]
        pub fn countForObject(&self, object: &ObjectType) -> NSUInteger;

        #[cfg(feature = "NSEnumerator")]
        /// # Safety
        ///
        /// The returned enumerator's underlying collection should not be mutated while in use.
        #[unsafe(method(objectEnumerator))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectEnumerator(&self) -> Retained<NSEnumerator<ObjectType>>;

        #[unsafe(method(addObject:))]
        #[unsafe(method_family = none)]
        pub fn addObject(&self, object: &ObjectType);

        #[unsafe(method(removeObject:))]
        #[unsafe(method_family = none)]
        pub fn removeObject(&self, object: &ObjectType);
    );
}

/// Methods declared on superclass `NSMutableSet`.
impl<ObjectType: Message> NSCountedSet<ObjectType> {
    extern_methods!(
        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSSet`.
impl<ObjectType: Message> NSCountedSet<ObjectType> {
    extern_methods!(
        /// # Safety
        ///
        /// `objects` must be a valid pointer or null.
        #[unsafe(method(initWithObjects:count:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithObjects_count(
            this: Allocated<Self>,
            objects: *mut NonNull<ObjectType>,
            cnt: NSUInteger,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl<ObjectType: Message> NSCountedSet<ObjectType> {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<ObjectType: Message> DefaultRetained for NSCountedSet<ObjectType> {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
