//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Implement this block to retrieve the error of the script executed by [`executeWithCompletionHandler:`](https://developer.apple.com/documentation/foundation/nsuserscripttask/execute(completionhandler:)).
#[cfg(all(feature = "NSError", feature = "block2"))]
pub type NSUserScriptTaskCompletionHandler = *mut block2::DynBlock<dyn Fn(*mut NSError)>;

extern_class!(
    /// An object that executes scripts.
    ///
    /// ## Overview
    ///
    /// The [`NSUserScriptTask`](https://developer.apple.com/documentation/foundation/nsuserscripttask) class is able to run all the scripts normally run by the one of its subclasses, however it ignores the results. It is intended to execute user-supplied scripts and will execute them outside of the application’s sandbox, if any.
    ///
    /// If you need to execute scripts and get the input and output information use the [`NSUserUnixTask`](https://developer.apple.com/documentation/foundation/nsuserunixtask), [`NSUserAppleScriptTask`](https://developer.apple.com/documentation/foundation/nsuserapplescripttask), and [`NSUserAutomatorTask`](https://developer.apple.com/documentation/foundation/nsuserautomatortask) sub classes.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSUserScriptTask;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSUserScriptTask {}
);

impl NSUserScriptTask {
    extern_methods!(
        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithURL_error(
            this: Allocated<Self>,
            url: &NSURL,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(scriptURL))]
        #[unsafe(method_family = none)]
        pub fn scriptURL(&self) -> Retained<NSURL>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        /// # Safety
        ///
        /// `handler` must be a valid pointer or null.
        #[unsafe(method(executeWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn executeWithCompletionHandler(
            &self,
            handler: NSUserScriptTaskCompletionHandler,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSUserScriptTask {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSUserScriptTask {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// Implement this block to retrieve an error from the Unix scripted executed by [`executeWithArguments:completionHandler:`](https://developer.apple.com/documentation/foundation/nsuserunixtask/execute(witharguments:completionhandler:)).
#[cfg(all(feature = "NSError", feature = "block2"))]
pub type NSUserUnixTaskCompletionHandler = *mut block2::DynBlock<dyn Fn(*mut NSError)>;

extern_class!(
    /// An object that executes unix applications.
    ///
    /// ## Overview
    ///
    /// The [`NSUserUnixTask`](https://developer.apple.com/documentation/foundation/nsuserunixtask) class is intended to run unix applications, typically a shell script, from your application. It is intended to execute user-supplied scripts, and will execute them outside of the application’s sandbox, if any.
    ///
    /// The class is not intended to execute scripts built into an application; for that, use one of the [`NSTask`](https://developer.apple.com/documentation/foundation/process), [`NSAppleScript`](https://developer.apple.com/documentation/foundation/nsapplescript), or [`AMWorkflow`](https://developer.apple.com/documentation/automator/amworkflow) classes.  If the application is sandboxed, then the script must be in the [`NSApplicationScriptsDirectory`](https://developer.apple.com/documentation/foundation/filemanager/searchpathdirectory/applicationscriptsdirectory) folder.  A sandboxed application may read from, but not write to, this folder.
    ///
    /// If you simply need to execute unix scripts without regard to input or output, use [`NSUserScriptTask`](https://developer.apple.com/documentation/foundation/nsuserscripttask), which can execute any of the specific types.  If you need specific control over the input to, or output from, or the error stream of the script, use this class.
    ///
    ///
    #[unsafe(super(NSUserScriptTask, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSUserUnixTask;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSUserUnixTask {}
);

impl NSUserUnixTask {
    extern_methods!(
        #[cfg(feature = "NSFileHandle")]
        #[unsafe(method(standardInput))]
        #[unsafe(method_family = none)]
        pub fn standardInput(&self) -> Option<Retained<NSFileHandle>>;

        #[cfg(feature = "NSFileHandle")]
        /// Setter for [`standardInput`][Self::standardInput].
        #[unsafe(method(setStandardInput:))]
        #[unsafe(method_family = none)]
        pub fn setStandardInput(&self, standard_input: Option<&NSFileHandle>);

        #[cfg(feature = "NSFileHandle")]
        #[unsafe(method(standardOutput))]
        #[unsafe(method_family = none)]
        pub fn standardOutput(&self) -> Option<Retained<NSFileHandle>>;

        #[cfg(feature = "NSFileHandle")]
        /// Setter for [`standardOutput`][Self::standardOutput].
        #[unsafe(method(setStandardOutput:))]
        #[unsafe(method_family = none)]
        pub fn setStandardOutput(&self, standard_output: Option<&NSFileHandle>);

        #[cfg(feature = "NSFileHandle")]
        #[unsafe(method(standardError))]
        #[unsafe(method_family = none)]
        pub fn standardError(&self) -> Option<Retained<NSFileHandle>>;

        #[cfg(feature = "NSFileHandle")]
        /// Setter for [`standardError`][Self::standardError].
        #[unsafe(method(setStandardError:))]
        #[unsafe(method_family = none)]
        pub fn setStandardError(&self, standard_error: Option<&NSFileHandle>);

        #[cfg(all(
            feature = "NSArray",
            feature = "NSError",
            feature = "NSString",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `handler` must be a valid pointer or null.
        #[unsafe(method(executeWithArguments:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn executeWithArguments_completionHandler(
            &self,
            arguments: Option<&NSArray<NSString>>,
            handler: NSUserUnixTaskCompletionHandler,
        );
    );
}

/// Methods declared on superclass `NSUserScriptTask`.
impl NSUserUnixTask {
    extern_methods!(
        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithURL_error(
            this: Allocated<Self>,
            url: &NSURL,
        ) -> Result<Retained<Self>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSUserUnixTask {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSUserUnixTask {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// Implement this block to retrieve the result of the AppleScript executed by [`executeWithAppleEvent:completionHandler:`](https://developer.apple.com/documentation/foundation/nsuserapplescripttask/execute(withappleevent:completionhandler:)).
#[cfg(all(
    feature = "NSAppleEventDescriptor",
    feature = "NSError",
    feature = "block2"
))]
pub type NSUserAppleScriptTaskCompletionHandler =
    *mut block2::DynBlock<dyn Fn(*mut NSAppleEventDescriptor, *mut NSError)>;

extern_class!(
    /// An object that executes AppleScript scripts.
    ///
    /// ## Overview
    ///
    /// The [`NSUserAppleScriptTask`](https://developer.apple.com/documentation/foundation/nsuserapplescripttask) class is intended to run AppleScript scripts from your application. It is intended to execute user-supplied scripts and will execute them outside of the application’s sandbox, if any.
    ///
    /// The class is not intended to execute scripts built into an application; for that, use one of the [`NSTask`](https://developer.apple.com/documentation/foundation/process) classes. If the application is sandboxed, then the script must be in the [`NSApplicationScriptsDirectory`](https://developer.apple.com/documentation/foundation/filemanager/searchpathdirectory/applicationscriptsdirectory) folder. A sandboxed application may read from, but not write to, this folder.
    ///
    /// If you simply need to execute scripts without regard to input or output, use [`NSUserScriptTask`](https://developer.apple.com/documentation/foundation/nsuserscripttask), which can execute any of the specific types. If you need specific control over the input to or output from the script, use this class.
    ///
    ///
    #[unsafe(super(NSUserScriptTask, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSUserAppleScriptTask;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSUserAppleScriptTask {}
);

impl NSUserAppleScriptTask {
    extern_methods!(
        #[cfg(all(
            feature = "NSAppleEventDescriptor",
            feature = "NSError",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `handler` must be a valid pointer or null.
        #[unsafe(method(executeWithAppleEvent:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn executeWithAppleEvent_completionHandler(
            &self,
            event: Option<&NSAppleEventDescriptor>,
            handler: NSUserAppleScriptTaskCompletionHandler,
        );
    );
}

/// Methods declared on superclass `NSUserScriptTask`.
impl NSUserAppleScriptTask {
    extern_methods!(
        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithURL_error(
            this: Allocated<Self>,
            url: &NSURL,
        ) -> Result<Retained<Self>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSUserAppleScriptTask {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSUserAppleScriptTask {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// Implement this block to retrieve the output of the Automator workflow executed by [`executeWithInput:completionHandler:`](https://developer.apple.com/documentation/foundation/nsuserautomatortask/execute(withinput:completionhandler:)).
#[cfg(all(feature = "NSError", feature = "block2"))]
pub type NSUserAutomatorTaskCompletionHandler =
    *mut block2::DynBlock<dyn Fn(*mut AnyObject, *mut NSError)>;

extern_class!(
    /// An object that executes Automator workflows.
    ///
    /// ## Overview
    ///
    /// The [`NSUserAutomatorTask`](https://developer.apple.com/documentation/foundation/nsuserautomatortask) class is intended to run Automator workflows from your application. It is intended to execute user-supplied workflows, and will execute them outside of the application’s sandbox, if any.
    ///
    /// The class is not intended to execute scripts built into an application; for that, use one of the [`NSTask`](https://developer.apple.com/documentation/foundation/process) or [`AMWorkflow`](https://developer.apple.com/documentation/automator/amworkflow) classes.  If the application is sandboxed, then the script must be in the [`NSApplicationScriptsDirectory`](https://developer.apple.com/documentation/foundation/filemanager/searchpathdirectory/applicationscriptsdirectory) folder.  A sandboxed application may read from, but not write to, this folder.
    ///
    /// If you simply need to execute scripts without regard to input or output, use [`NSUserScriptTask`](https://developer.apple.com/documentation/foundation/nsuserscripttask), which can execute any of the specific types.  If you need specific control over the input to or output from the workflow, use this class.
    ///
    ///
    #[unsafe(super(NSUserScriptTask, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSUserAutomatorTask;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSUserAutomatorTask {}
);

impl NSUserAutomatorTask {
    extern_methods!(
        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(variables))]
        #[unsafe(method_family = none)]
        pub fn variables(&self) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// Setter for [`variables`][Self::variables].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `variables` generic should be of the correct type.
        #[unsafe(method(setVariables:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVariables(&self, variables: Option<&NSDictionary<NSString, AnyObject>>);

        #[cfg(all(feature = "NSError", feature = "NSObject", feature = "block2"))]
        /// # Safety
        ///
        /// - `input` should be of the correct type.
        /// - `handler` must be a valid pointer or null.
        #[unsafe(method(executeWithInput:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn executeWithInput_completionHandler(
            &self,
            input: Option<&ProtocolObject<dyn NSSecureCoding>>,
            handler: NSUserAutomatorTaskCompletionHandler,
        );
    );
}

/// Methods declared on superclass `NSUserScriptTask`.
impl NSUserAutomatorTask {
    extern_methods!(
        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithURL_error(
            this: Allocated<Self>,
            url: &NSURL,
        ) -> Result<Retained<Self>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSUserAutomatorTask {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSUserAutomatorTask {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
