//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// These constants let you prioritize the order in which operations execute.
///
/// ## Overview
///
/// You can use these constants to specify the relative ordering of operations that are waiting to be started in an operation queue. You should always use these constants (and not the defined value) for determining priority.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSOperationQueuePriority(pub NSInteger);
impl NSOperationQueuePriority {
    /// Operations receive very low priority for execution.
    #[doc(alias = "NSOperationQueuePriorityVeryLow")]
    pub const VeryLow: Self = Self(-8);
    /// Operations receive low priority for execution.
    #[doc(alias = "NSOperationQueuePriorityLow")]
    pub const Low: Self = Self(-4);
    /// Operations receive the normal priority for execution.
    #[doc(alias = "NSOperationQueuePriorityNormal")]
    pub const Normal: Self = Self(0);
    /// Operations receive high priority for execution.
    #[doc(alias = "NSOperationQueuePriorityHigh")]
    pub const High: Self = Self(4);
    /// Operations receive very high priority for execution.
    #[doc(alias = "NSOperationQueuePriorityVeryHigh")]
    pub const VeryHigh: Self = Self(8);
}

unsafe impl Encode for NSOperationQueuePriority {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSOperationQueuePriority {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An abstract class that represents the code and data associated with a single task.
    ///
    /// ## Overview
    ///
    /// Because the [`NSOperation`](https://developer.apple.com/documentation/foundation/operation) class is an abstract class, you do not use it directly but instead subclass or use one of the system-defined subclasses ([`NSInvocationOperation`](https://developer.apple.com/documentation/foundation/nsinvocationoperation) or [`NSBlockOperation`](https://developer.apple.com/documentation/foundation/blockoperation)) to perform the actual task. Despite being abstract, the base implementation of [`NSOperation`](https://developer.apple.com/documentation/foundation/operation) does include significant logic to coordinate the safe execution of your task. The presence of this built-in logic allows you to focus on the actual implementation of your task, rather than on the glue code needed to ensure it works correctly with other system objects.
    ///
    /// An operation object is a single-shot object—that is, it executes its task once and cannot be used to execute it again. You typically execute operations by adding them to an operation queue (an instance of the [`NSOperationQueue`](https://developer.apple.com/documentation/foundation/operationqueue) class). An operation queue executes its operations either directly, by running them on secondary threads, or indirectly using the `libdispatch` library (also known as Grand Central Dispatch). For more information about how queues execute operations, see [`NSOperationQueue`](https://developer.apple.com/documentation/foundation/operationqueue).
    ///
    /// If you do not want to use an operation queue, you can execute an operation yourself by calling its [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method directly from your code. Executing operations manually does put more of a burden on your code, because starting an operation that is not in the ready state triggers an exception. The [`ready`](https://developer.apple.com/documentation/foundation/operation/isready) property reports on the operation’s readiness.
    ///
    /// ### Operation Dependencies
    ///
    /// Dependencies are a convenient way to execute operations in a specific order. You can add and remove dependencies for an operation using the [`addDependency:`](https://developer.apple.com/documentation/foundation/operation/adddependency(_:)) and [`removeDependency:`](https://developer.apple.com/documentation/foundation/operation/removedependency(_:)) methods. By default, an operation object that has dependencies is not considered ready until all of its dependent operation objects have finished executing. Once the last dependent operation finishes, however, the operation object becomes ready and able to execute.
    ///
    /// The dependencies supported by `NSOperation` make no distinction about whether a dependent operation finished successfully or unsuccessfully. (In other words, canceling an operation similarly marks it as finished.) It is up to you to determine whether an operation with dependencies should proceed in cases where its dependent operations were cancelled or did not complete their task successfully. This may require you to incorporate some additional error tracking capabilities into your operation objects.
    ///
    /// ### KVO-Compliant Properties
    ///
    /// The `NSOperation` class is key-value coding (KVC) and key-value observing (KVO) compliant for several of its properties. As needed, you can observe these properties to control other parts of your application. To observe the properties, use the following key paths:
    ///
    /// - `isCancelled` - read-only
    ///
    /// - `isAsynchronous` - read-only
    ///
    /// - `isExecuting` - read-only
    ///
    /// - `isFinished` - read-only
    ///
    /// - `isReady` - read-only
    ///
    /// - `dependencies` - read-only
    ///
    /// - `queuePriority` - readable and writable
    ///
    /// - `completionBlock` - readable and writable
    ///
    /// Although you can attach observers to these properties, you should not use Cocoa bindings to bind them to elements of your application’s user interface. Code associated with your user interface typically must execute only in your application’s main thread. Because an operation may execute in any thread, KVO notifications associated with that operation may similarly occur in any thread.
    ///
    /// If you provide custom implementations for any of the preceding properties, your implementations must maintain KVC and KVO compliance. If you define additional properties for your `NSOperation` objects, it is recommended that you make those properties KVC and KVO compliant as well. For information on how to support key-value coding, see [Key-Value Coding Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueCoding/index.html#//apple_ref/doc/uid/10000107i). For information on how to support key-value observing, see [Key-Value Observing Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i).
    ///
    /// ### Multicore Considerations
    ///
    /// The `NSOperation` class is itself multicore aware. It is therefore safe to call the methods of an `NSOperation` object from multiple threads without creating additional locks to synchronize access to the object. This behavior is necessary because an operation typically runs in a separate thread from the one that created and is monitoring it.
    ///
    /// When you subclass `NSOperation`, you must make sure that any overridden methods remain safe to call from multiple threads. If you implement custom methods in your subclass, such as custom data accessors, you must also make sure those methods are thread-safe. Thus, access to any data variables in the operation must be synchronized to prevent potential data corruption. For more information about synchronization, see [Threading Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/Introduction/Introduction.html#//apple_ref/doc/uid/10000057i).
    ///
    /// ### Asynchronous Versus Synchronous Operations
    ///
    /// If you plan on executing an operation object manually, instead of adding it to a queue, you can design your operation to execute in a synchronous or asynchronous manner. Operation objects are synchronous by default. In a synchronous operation, the operation object does not create a separate thread on which to run its task. When you call the [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method of a synchronous operation directly from your code, the operation executes immediately in the current thread. By the time the [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method of such an object returns control to the caller, the task itself is complete.
    ///
    /// When you call the [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method of an asynchronous operation, that method may return before the corresponding task is completed. An asynchronous operation object is responsible for scheduling its task on a separate thread. The operation could do that by starting a new thread directly, by calling an asynchronous method, or by submitting a block to a dispatch queue for execution. It does not actually matter if the operation is ongoing when control returns to the caller, only that it could be ongoing.
    ///
    /// If you always plan to use queues to execute your operations, it is simpler to define them as synchronous. If you execute operations manually, though, you might want to define your operation objects as asynchronous. Defining an asynchronous operation requires more work, because you have to monitor the ongoing state of your task and report changes in that state using KVO notifications. But defining asynchronous operations is useful in cases where you want to ensure that a manually executed operation does not block the calling thread.
    ///
    /// When you add an operation to an operation queue, the queue ignores the value of the [`asynchronous`](https://developer.apple.com/documentation/foundation/operation/isasynchronous) property and always calls the [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method from a separate thread. Therefore, if you always run operations by adding them to an operation queue, there is no reason to make them asynchronous.
    ///
    /// For information on how to define both synchronous and asynchronous operations, see the subclassing notes.
    ///
    /// ### Subclassing Notes
    ///
    /// The `NSOperation` class provides the basic logic to track the execution state of your operation but otherwise must be subclassed to do any real work. How you create your subclass depends on whether your operation is designed to execute concurrently or non-concurrently.
    ///
    /// #### Methods to Override
    ///
    /// For non-concurrent operations, you typically override only one method:
    ///
    /// - [`main`](https://developer.apple.com/documentation/foundation/operation/main())
    ///
    /// Into this method, you place the code needed to perform the given task. Of course, you should also define a custom initialization method to make it easier to create instances of your custom class. You might also want to define getter and setter methods to access the data from the operation. However, if you do define custom getter and setter methods, you must make sure those methods can be called safely from multiple threads.
    ///
    /// If you are creating a concurrent operation, you need to override the following methods and properties at a minimum:
    ///
    /// - [`start`](https://developer.apple.com/documentation/foundation/operation/start())
    ///
    /// - [`asynchronous`](https://developer.apple.com/documentation/foundation/operation/isasynchronous)
    ///
    /// - [`executing`](https://developer.apple.com/documentation/foundation/operation/isexecuting)
    ///
    /// - [`finished`](https://developer.apple.com/documentation/foundation/operation/isfinished)
    ///
    /// In a concurrent operation, your [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method is responsible for starting the operation in an asynchronous manner. Whether you spawn a thread or call an asynchronous function, you do it from this method. Upon starting the operation, your [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method should also update the execution state of the operation as reported by the [`executing`](https://developer.apple.com/documentation/foundation/operation/isexecuting) property. You do this by sending out KVO notifications for the [`executing`](https://developer.apple.com/documentation/foundation/operation/isexecuting) key path, which lets interested clients know that the operation is now running. Your [`executing`](https://developer.apple.com/documentation/foundation/operation/isexecuting) property must also provide the status in a thread-safe manner.
    ///
    /// Upon completion or cancellation of its task, your concurrent operation object must generate KVO notifications for both the `isExecuting` and `isFinished` key paths to mark the final change of state for your operation. (In the case of cancellation, it is still important to update the `isFinished` key path, even if the operation did not completely finish its task. Queued operations must report that they are finished before they can be removed from a queue.) In addition to generating KVO notifications, your overrides of the [`executing`](https://developer.apple.com/documentation/foundation/operation/isexecuting) and [`finished`](https://developer.apple.com/documentation/foundation/operation/isfinished) properties should also continue to report accurate values based on the state of your operation.
    ///
    /// For additional information and guidance on how to define concurrent operations, see [Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  At no time in your [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method should you ever call `super`. When you define a concurrent operation, you take it upon yourself to provide the same behavior that the default [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method provides, which includes starting the task and generating the appropriate KVO notifications. Your [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method should also check to see if the operation itself was cancelled before actually starting the task. For more information about cancellation semantics, see [Responding to the Cancel Command](https://developer.apple.com/documentation/foundation/operation#responding-to-the-cancel-command).
    ///
    ///
    ///
    /// </div>
    /// Even for concurrent operations, there should be little need to override methods other than those described above. However, if you customize the dependency features of operations, you might have to override additional methods and provide additional KVO notifications. In the case of dependencies, this would likely only require providing notifications for the `isReady` key path. Because the [`dependencies`](https://developer.apple.com/documentation/foundation/operation/dependencies) property contains the list of dependent operations, changes to it are already handled by the default `NSOperation` class.
    ///
    /// #### Maintaining Operation Object States
    ///
    /// Operation objects maintain state information internally to determine when it is safe to execute and also to notify external clients of the progression through the operation’s life cycle. Your custom subclasses maintains this state information to ensure the correct execution of operations in your code. The key paths associated with an operation’s states are:
    ///
    /// - **`isReady`**: The `isReady` key path lets clients know when an operation is ready to execute. The [`ready`](https://developer.apple.com/documentation/foundation/operation/isready) property contains the value `true` when the operation is ready to execute now or `false` if there are still unfinished operations on which it is dependent.
    ///
    /// In most cases, you do not have to manage the state of this key path yourself. If the readiness of your operations is determined by factors other than dependent operations, however—such as by some external condition in your program—you can provide your own implementation of the [`ready`](https://developer.apple.com/documentation/foundation/operation/isready) property and track your operation’s readiness yourself. It is often simpler though just to create operation objects only when your external state allows it.
    ///
    /// In macOS 10.6 and later, if you cancel an operation while it is waiting on the completion of one or more dependent operations, those dependencies are thereafter ignored and the value of this property is updated to reflect that it is now ready to run. This behavior gives an operation queue the chance to flush cancelled operations out of its queue more quickly.
    ///
    /// - **`isExecuting`**: The `isExecuting` key path lets clients know whether the operation is actively working on its assigned task. The [`executing`](https://developer.apple.com/documentation/foundation/operation/isexecuting) property must report the value `true` if the operation is working on its task or `false` if it is not.
    ///
    /// If you replace the [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method of your operation object, you must also replace the [`executing`](https://developer.apple.com/documentation/foundation/operation/isexecuting) property and generate KVO notifications when the execution state of your operation changes.
    ///
    /// - **`isFinished`**: The `isFinished` key path lets clients know that an operation finished its task successfully or was cancelled and is exiting. An operation object does not clear a dependency until the value at the `isFinished` key path changes to `true`. Similarly, an operation queue does not dequeue an operation until the [`finished`](https://developer.apple.com/documentation/foundation/operation/isfinished) property contains the value `true`. Thus, marking operations as finished is critical to keeping queues from backing up with in-progress or cancelled operations.
    ///
    /// If you replace the [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method or your operation object, you must also replace the [`finished`](https://developer.apple.com/documentation/foundation/operation/isfinished) property and generate KVO notifications when the operation finishes executing or is cancelled.
    ///
    /// - **`isCancelled`**: The `isCancelled` key path lets clients know that the cancellation of an operation was requested. Support for cancellation is voluntary but encouraged and your own code should not have to send KVO notifications for this key path. The handling of cancellation notices in an operation is described in more detail in [Responding to the Cancel Command](https://developer.apple.com/documentation/foundation/operation#responding-to-the-cancel-command).
    ///
    /// #### Responding to the Cancel Command
    ///
    /// Once you add an operation to a queue, the operation is out of your hands. The queue takes over and handles the scheduling of that task. However, if you decide later that you do not want to execute the operation after all—because the user pressed a cancel button in a progress panel or quit the application, for example—you can cancel the operation to prevent it from consuming CPU time needlessly. You do this by calling the [`cancel`](https://developer.apple.com/documentation/foundation/operation/cancel()) method of the operation object itself or by calling the [`cancelAllOperations`](https://developer.apple.com/documentation/foundation/operationqueue/cancelalloperations()) method of the [`NSOperationQueue`](https://developer.apple.com/documentation/foundation/operationqueue) class.
    ///
    /// Canceling an operation does not immediately force it to stop what it is doing. Although respecting the value in the [`cancelled`](https://developer.apple.com/documentation/foundation/operation/iscancelled) property is expected of all operations, your code must explicitly check the value in this property and abort as needed. The default implementation of `NSOperation` includes checks for cancellation. For example, if you cancel an operation before its [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method is called, the [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method exits without starting the task.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  In macOS 10.6 and later, if you call the [`cancel`](https://developer.apple.com/documentation/foundation/operation/cancel()) method on an operation that is in an operation queue and has unfinished dependent operations, those dependent operations are subsequently ignored. Because the operation is already cancelled, this behavior allows the queue to call the operation’s [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method to remove the operation from the queue without calling its [`main`](https://developer.apple.com/documentation/foundation/operation/main()) method. If you call the [`cancel`](https://developer.apple.com/documentation/foundation/operation/cancel()) method on an operation that is not in a queue, the operation is immediately marked as being cancelled. In each case, marking the operation as ready or finished results in the generation of the appropriate KVO notifications.
    ///
    ///
    ///
    /// </div>
    /// You should always support cancellation semantics in any custom code you write. In particular, your main task code should periodically check the value of the [`cancelled`](https://developer.apple.com/documentation/foundation/operation/iscancelled) property. If the property reports the value [`true`](https://developer.apple.com/documentation/swift/true), your operation object should clean up and exit as quickly as possible. If you implement a custom [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method, that method should include early checks for cancellation and behave appropriately. Your custom [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method must be prepared to handle this type of early cancellation.
    ///
    /// In addition to simply exiting when an operation is cancelled, it is also important that you move a cancelled operation to the appropriate final state. Specifically, if you manage the values for the [`finished`](https://developer.apple.com/documentation/foundation/operation/isfinished) and [`executing`](https://developer.apple.com/documentation/foundation/operation/isexecuting) properties yourself (perhaps because you are implementing a concurrent operation), you must update those properties accordingly. Specifically, you must change the value returned by [`finished`](https://developer.apple.com/documentation/foundation/operation/isfinished) to [`true`](https://developer.apple.com/documentation/swift/true) and the value returned by [`executing`](https://developer.apple.com/documentation/foundation/operation/isexecuting) to [`false`](https://developer.apple.com/documentation/swift/false). You must make these changes even if the operation was cancelled before it started executing.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSOperation;
);

unsafe impl Send for NSOperation {}

unsafe impl Sync for NSOperation {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSOperation {}
);

impl NSOperation {
    extern_methods!(
        #[unsafe(method(start))]
        #[unsafe(method_family = none)]
        pub fn start(&self);

        #[unsafe(method(main))]
        #[unsafe(method_family = none)]
        pub fn main(&self);

        #[unsafe(method(isCancelled))]
        #[unsafe(method_family = none)]
        pub fn isCancelled(&self) -> bool;

        #[unsafe(method(cancel))]
        #[unsafe(method_family = none)]
        pub fn cancel(&self);

        #[unsafe(method(isExecuting))]
        #[unsafe(method_family = none)]
        pub fn isExecuting(&self) -> bool;

        #[unsafe(method(isFinished))]
        #[unsafe(method_family = none)]
        pub fn isFinished(&self) -> bool;

        #[unsafe(method(isConcurrent))]
        #[unsafe(method_family = none)]
        pub fn isConcurrent(&self) -> bool;

        #[unsafe(method(isAsynchronous))]
        #[unsafe(method_family = none)]
        pub fn isAsynchronous(&self) -> bool;

        #[unsafe(method(isReady))]
        #[unsafe(method_family = none)]
        pub fn isReady(&self) -> bool;

        #[unsafe(method(addDependency:))]
        #[unsafe(method_family = none)]
        pub fn addDependency(&self, op: &NSOperation);

        #[unsafe(method(removeDependency:))]
        #[unsafe(method_family = none)]
        pub fn removeDependency(&self, op: &NSOperation);

        #[cfg(feature = "NSArray")]
        #[unsafe(method(dependencies))]
        #[unsafe(method_family = none)]
        pub fn dependencies(&self) -> Retained<NSArray<NSOperation>>;

        #[unsafe(method(queuePriority))]
        #[unsafe(method_family = none)]
        pub fn queuePriority(&self) -> NSOperationQueuePriority;

        /// Setter for [`queuePriority`][Self::queuePriority].
        #[unsafe(method(setQueuePriority:))]
        #[unsafe(method_family = none)]
        pub fn setQueuePriority(&self, queue_priority: NSOperationQueuePriority);

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block must be sendable.
        #[unsafe(method(completionBlock))]
        #[unsafe(method_family = none)]
        pub unsafe fn completionBlock(&self) -> *mut block2::DynBlock<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`completionBlock`][Self::completionBlock].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `completion_block` block must be sendable.
        #[unsafe(method(setCompletionBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCompletionBlock(
            &self,
            completion_block: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[unsafe(method(waitUntilFinished))]
        #[unsafe(method_family = none)]
        pub fn waitUntilFinished(&self);

        #[deprecated = "Not supported"]
        #[unsafe(method(threadPriority))]
        #[unsafe(method_family = none)]
        pub fn threadPriority(&self) -> c_double;

        /// Setter for [`threadPriority`][Self::threadPriority].
        #[deprecated = "Not supported"]
        #[unsafe(method(setThreadPriority:))]
        #[unsafe(method_family = none)]
        pub fn setThreadPriority(&self, thread_priority: c_double);

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(qualityOfService))]
        #[unsafe(method_family = none)]
        pub fn qualityOfService(&self) -> NSQualityOfService;

        #[cfg(feature = "NSObjCRuntime")]
        /// Setter for [`qualityOfService`][Self::qualityOfService].
        #[unsafe(method(setQualityOfService:))]
        #[unsafe(method_family = none)]
        pub fn setQualityOfService(&self, quality_of_service: NSQualityOfService);

        #[cfg(feature = "NSString")]
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub fn name(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub fn setName(&self, name: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSOperation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSOperation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// An operation that manages the concurrent execution of one or more blocks.
    ///
    /// ## Overview
    ///
    /// The [`NSBlockOperation`](https://developer.apple.com/documentation/foundation/blockoperation) class is a concrete subclass of [`NSOperation`](https://developer.apple.com/documentation/foundation/operation) that manages the concurrent execution of one or more blocks. You can use this object to execute several blocks at once without having to create separate operation objects for each. When executing more than one block, the operation itself is considered finished only when all blocks have finished executing.
    ///
    /// Blocks added to a block operation are dispatched with default priority to an appropriate work queue. The blocks themselves should not make any assumptions about the configuration of their execution environment.
    ///
    /// For more information about blocks, see [Blocks Programming Topics](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Blocks/Articles/00_Introduction.html#//apple_ref/doc/uid/TP40007502).
    ///
    ///
    #[unsafe(super(NSOperation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSBlockOperation;
);

unsafe impl Send for NSBlockOperation {}

unsafe impl Sync for NSBlockOperation {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSBlockOperation {}
);

impl NSBlockOperation {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `block` block must be sendable.
        #[unsafe(method(blockOperationWithBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn blockOperationWithBlock(block: &block2::DynBlock<dyn Fn()>)
            -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `block` block must be sendable.
        #[unsafe(method(addExecutionBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addExecutionBlock(&self, block: &block2::DynBlock<dyn Fn()>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSBlockOperation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSBlockOperation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// An operation that manages the execution of a single encapsulated task specified as an invocation.
    ///
    /// ## Overview
    ///
    /// The [`NSInvocationOperation`](https://developer.apple.com/documentation/foundation/nsinvocationoperation) class is a concrete subclass of [`Operation`](https://developer.apple.com/documentation/foundation/operation) that you use to initiate an operation that consists of invoking a selector on a specified object. This class implements a non-concurrent operation.
    ///
    /// For more information on concurrent versus non-concurrent operations, see [`Operation`](https://developer.apple.com/documentation/foundation/operation).
    ///
    ///
    #[unsafe(super(NSOperation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSInvocationOperation;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSInvocationOperation {}
);

impl NSInvocationOperation {
    extern_methods!(
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `sel` must be a valid selector.
        /// - `arg` should be of the correct type.
        #[unsafe(method(initWithTarget:selector:object:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTarget_selector_object(
            this: Allocated<Self>,
            target: &AnyObject,
            sel: Sel,
            arg: Option<&AnyObject>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSInvocation")]
        #[unsafe(method(initWithInvocation:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithInvocation(
            this: Allocated<Self>,
            inv: &NSInvocation,
        ) -> Retained<Self>;

        #[cfg(feature = "NSInvocation")]
        #[unsafe(method(invocation))]
        #[unsafe(method_family = none)]
        pub unsafe fn invocation(&self) -> Retained<NSInvocation>;

        #[unsafe(method(result))]
        #[unsafe(method_family = none)]
        pub fn result(&self) -> Option<Retained<AnyObject>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSInvocationOperation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSInvocationOperation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern "C" {
    /// The name of the exception raised if the [`result`](https://developer.apple.com/documentation/foundation/nsinvocationoperation/result) method is called for an invocation method with a `void` return type.
    #[cfg(all(feature = "NSObjCRuntime", feature = "NSString"))]
    pub static NSInvocationOperationVoidResultException: &'static NSExceptionName;
}

extern "C" {
    /// The name of the exception raised if the [`result`](https://developer.apple.com/documentation/foundation/nsinvocationoperation/result) method is called after the operation was cancelled.
    #[cfg(all(feature = "NSObjCRuntime", feature = "NSString"))]
    pub static NSInvocationOperationCancelledException: &'static NSExceptionName;
}

/// The default maximum number of operations to invoke concurrently in a queue.
///
/// ## Discussion
///
/// The operation queue determines this number dynamically based on current system conditions.
///
///
pub static NSOperationQueueDefaultMaxConcurrentOperationCount: NSInteger = -1;

extern_class!(
    /// A queue that regulates the execution of operations.
    ///
    /// ## Overview
    ///
    /// An operation queue invokes its queued [`NSOperation`](https://developer.apple.com/documentation/foundation/operation) objects based on their priority and readiness. After you add an operation to a queue, it remains in the queue until the operation finishes its task. You can’t directly remove an operation from a queue after you add it.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Operation queues retain operations until the operations finish, and queues themselves are retained until all operations are finished. Suspending an operation queue with operations that aren’t finished can result in a memory leak.
    ///
    ///
    ///
    /// </div>
    /// For more information about using operation queues, see the [Concurrency Programming Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008091).
    ///
    /// ### Determine the Execution Order
    ///
    /// An operation queue organizes and invokes its operations according to their readiness, priority level, and interoperation dependencies. If all of the queued operations have the same [`queuePriority`](https://developer.apple.com/documentation/foundation/operation/queuepriority-swift.property) and the [`ready`](https://developer.apple.com/documentation/foundation/operation/isready) property returns [`true`](https://developer.apple.com/documentation/swift/true), the queue invokes them in the order you added them. Otherwise, the operation queue always invokes the operation with the highest priority relative to the other ready operations.
    ///
    /// However, don’t rely on queue semantics to ensure a specific execution order of operations  because changes in the readiness of an operation can change the resulting execution order. Interoperation dependencies provide an absolute execution order for operations, even if those operations are located in different operation queues. An operation object isn’t ready to run until all of its dependent operations have finished running.
    ///
    /// For details on how to set priority levels and dependencies, see Managing Dependencies in [`NSOperation`](https://developer.apple.com/documentation/foundation/operation).
    ///
    /// ### Respond to Operation Cancelation
    ///
    /// Finishing its task doesn’t necessarily mean that the operation performed that task to completion; an operation can also be canceled. Canceling an operation object leaves the object in the queue but notifies the object that it should stop its task as quickly as possible. For currently executing operations, this means that the operation object’s work code must check the cancellation state, stop what it is doing, and mark itself as finished. For operations that are queued but not yet executing, the queue must still call the operation object’s [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method so that it can processes the cancellation event and mark itself as finished.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Canceling an operation causes the operation to ignore any dependencies it may have. This behavior makes it possible for the queue to invoke the operation’s [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method as soon as possible. The [`start`](https://developer.apple.com/documentation/foundation/operation/start()) method, in turn, moves the operation to the finished state so that it can be removed from the queue.
    ///
    ///
    ///
    /// </div>
    /// For more information about operation cancellation, see [Responding to the Cancel Command](https://developer.apple.com/documentation/foundation/operation#responding-to-the-cancel-command) in [`NSOperation`](https://developer.apple.com/documentation/foundation/operation).
    ///
    /// ### Observe Operations Using Key-Value Observing
    ///
    /// The [`NSOperationQueue`](https://developer.apple.com/documentation/foundation/operationqueue) class is key-value coding (KVC) and key-value observing (KVO) compliant. You can observe these properties to control other parts of your application. To observe the properties, use the following key paths:
    ///
    /// - [`operations`](https://developer.apple.com/documentation/foundation/operationqueue/operations) — Read-only
    ///
    /// - [`operationCount`](https://developer.apple.com/documentation/foundation/operationqueue/operationcount) — Read-only
    ///
    /// - [`maxConcurrentOperationCount`](https://developer.apple.com/documentation/foundation/operationqueue/maxconcurrentoperationcount) — Readable and writable
    ///
    /// - [`suspended`](https://developer.apple.com/documentation/foundation/operationqueue/issuspended) — Readable and writable
    ///
    /// - [`name`](https://developer.apple.com/documentation/foundation/operationqueue/name) — Readable and writable
    ///
    /// Although you can attach observers to these properties, don’t use Cocoa bindings to bind these properties to elements of your application’s user interface. Code associated with your user interface typically must run only in your app’s main thread. However, KVO notifications associated with an operation queue may occur in any thread.
    ///
    /// For more information about KVO and how to attach observers to an object, see the [Key-Value Observing Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i).
    ///
    /// ### Plan for Thread Safety
    ///
    /// You can safely use a single [`NSOperationQueue`](https://developer.apple.com/documentation/foundation/operationqueue) object from multiple threads without creating additional locks to synchronize access to that object.
    ///
    /// Operation queues use the [`Dispatch`](https://developer.apple.com/documentation/dispatch) framework to initiate the execution of their operations. As a result, queues always invoke operations on a separate thread, regardless of whether the operation is synchronous or asynchronous.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSOperationQueue;
);

unsafe impl Send for NSOperationQueue {}

unsafe impl Sync for NSOperationQueue {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSOperationQueue {}
);

#[cfg(feature = "NSProgress")]
extern_conformance!(
    unsafe impl NSProgressReporting for NSOperationQueue {}
);

impl NSOperationQueue {
    extern_methods!(
        #[cfg(feature = "NSProgress")]
        /// The `progress` property represents a total progress of the operations executed in the queue. By default NSOperationQueue
        /// does not report progress until the `totalUnitCount` of the progress is set. When the `totalUnitCount` property of the progress is set the
        /// queue then opts into participating in progress reporting. When enabled, each operation will contribute 1 unit of completion to the
        /// overall progress of the queue for operations that are finished by the end of main (operations that override start and do not invoke super
        /// will not contribute to progress). Special attention to race conditions should be made when updating the `totalUnitCount` of the progress
        /// as well as care should be taken to avoid 'backwards progress'. For example; when a NSOperationQueue's progress is 5/10, representing 50%
        /// completed, and there are 90 more operations about to be added and the `totalUnitCount` that would then make the progress report as 5/100
        /// which represents 5%. In this example it would mean that any progress bar would jump from displaying 50% back to 5%, which might not be
        /// desirable. In the cases where the `totalUnitCount` needs to be adjusted it is suggested to do this for thread-safety in a barrier by
        /// using the `addBarrierBlock:` API. This ensures that no un-expected execution state occurs adjusting into a potentially backwards moving
        /// progress scenario.
        ///
        ///
        /// NSOperationQueue *queue = [[NSOperationQueue alloc] init];
        /// queue.progress.totalUnitCount = 10;
        #[unsafe(method(progress))]
        #[unsafe(method_family = none)]
        pub fn progress(&self) -> Retained<NSProgress>;

        #[unsafe(method(addOperation:))]
        #[unsafe(method_family = none)]
        pub fn addOperation(&self, op: &NSOperation);

        #[cfg(feature = "NSArray")]
        #[unsafe(method(addOperations:waitUntilFinished:))]
        #[unsafe(method_family = none)]
        pub fn addOperations_waitUntilFinished(&self, ops: &NSArray<NSOperation>, wait: bool);

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `block` block must be sendable.
        #[unsafe(method(addOperationWithBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addOperationWithBlock(&self, block: &block2::DynBlock<dyn Fn()>);

        #[cfg(feature = "block2")]
        /// Parameter `barrier`: A block to execute
        ///
        /// The `addBarrierBlock:` method executes the block when the NSOperationQueue has finished all enqueued operations and
        /// prevents any subsequent operations to be executed until the barrier has been completed. This acts similarly to the
        /// `dispatch_barrier_async` function.
        ///
        /// # Safety
        ///
        /// `barrier` block must be sendable.
        #[unsafe(method(addBarrierBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addBarrierBlock(&self, barrier: &block2::DynBlock<dyn Fn()>);

        #[unsafe(method(maxConcurrentOperationCount))]
        #[unsafe(method_family = none)]
        pub fn maxConcurrentOperationCount(&self) -> NSInteger;

        /// Setter for [`maxConcurrentOperationCount`][Self::maxConcurrentOperationCount].
        #[unsafe(method(setMaxConcurrentOperationCount:))]
        #[unsafe(method_family = none)]
        pub fn setMaxConcurrentOperationCount(&self, max_concurrent_operation_count: NSInteger);

        #[unsafe(method(isSuspended))]
        #[unsafe(method_family = none)]
        pub fn isSuspended(&self) -> bool;

        /// Setter for [`isSuspended`][Self::isSuspended].
        #[unsafe(method(setSuspended:))]
        #[unsafe(method_family = none)]
        pub fn setSuspended(&self, suspended: bool);

        #[cfg(feature = "NSString")]
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub fn name(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub fn setName(&self, name: Option<&NSString>);

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(qualityOfService))]
        #[unsafe(method_family = none)]
        pub fn qualityOfService(&self) -> NSQualityOfService;

        #[cfg(feature = "NSObjCRuntime")]
        /// Setter for [`qualityOfService`][Self::qualityOfService].
        #[unsafe(method(setQualityOfService:))]
        #[unsafe(method_family = none)]
        pub fn setQualityOfService(&self, quality_of_service: NSQualityOfService);

        #[unsafe(method(cancelAllOperations))]
        #[unsafe(method_family = none)]
        pub fn cancelAllOperations(&self);

        #[unsafe(method(waitUntilAllOperationsAreFinished))]
        #[unsafe(method_family = none)]
        pub fn waitUntilAllOperationsAreFinished(&self);

        #[unsafe(method(currentQueue))]
        #[unsafe(method_family = none)]
        pub fn currentQueue() -> Option<Retained<NSOperationQueue>>;

        #[unsafe(method(mainQueue))]
        #[unsafe(method_family = none)]
        pub fn mainQueue() -> Retained<NSOperationQueue>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSOperationQueue {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSOperationQueue {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSDeprecated.
impl NSOperationQueue {
    extern_methods!(
        #[cfg(feature = "NSArray")]
        #[deprecated = "access to operations is inherently a race condition, it should not be used. For barrier style behaviors please use addBarrierBlock: instead"]
        #[unsafe(method(operations))]
        #[unsafe(method_family = none)]
        pub fn operations(&self) -> Retained<NSArray<NSOperation>>;

        #[deprecated]
        #[unsafe(method(operationCount))]
        #[unsafe(method_family = none)]
        pub fn operationCount(&self) -> NSUInteger;
    );
}
