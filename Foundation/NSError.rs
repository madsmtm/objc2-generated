//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "NSString")]
pub type NSErrorDomain = NSString;

extern "C" {
    /// Cocoa errors
    #[cfg(feature = "NSString")]
    pub static NSCocoaErrorDomain: &'static NSErrorDomain;
}

extern "C" {
    /// POSIX/BSD errors
    #[cfg(feature = "NSString")]
    pub static NSPOSIXErrorDomain: &'static NSErrorDomain;
}

extern "C" {
    /// Mac OS 9/Carbon errors
    #[cfg(feature = "NSString")]
    pub static NSOSStatusErrorDomain: &'static NSErrorDomain;
}

extern "C" {
    /// Mach errors
    #[cfg(feature = "NSString")]
    pub static NSMachErrorDomain: &'static NSErrorDomain;
}

/// These keys may exist in the user info dictionary.
#[cfg(feature = "NSString")]
pub type NSErrorUserInfoKey = NSString;

extern "C" {
    /// The corresponding value is an error that was encountered in an underlying implementation and caused the error that the receiver represents to occur.
    #[cfg(feature = "NSString")]
    pub static NSUnderlyingErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSMultipleUnderlyingErrorsKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    /// The corresponding value is a localized string representation of the error that, if present, will be returned by [`localizedDescription`](https://developer.apple.com/documentation/foundation/nserror/localizeddescription).
    #[cfg(feature = "NSString")]
    pub static NSLocalizedDescriptionKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    /// The corresponding value is a localized string representation containing the reason for the failure that, if present, will be returned by [`localizedFailureReason`](https://developer.apple.com/documentation/foundation/nserror/localizedfailurereason).
    #[cfg(feature = "NSString")]
    pub static NSLocalizedFailureReasonErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    /// The corresponding value is a string containing the localized recovery suggestion for the error.
    ///
    /// ## Discussion
    ///
    /// This string is suitable for displaying as the secondary message in an alert panel.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSLocalizedRecoverySuggestionErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    /// The corresponding value is an array containing the localized titles of buttons appropriate for displaying in an alert panel.
    ///
    /// ## Discussion
    ///
    /// The first string is the title of the right-most and default button, the second the one to the left, and so on. The recovery options should be appropriate for the recovery suggestion returned by [`localizedRecoverySuggestion`](https://developer.apple.com/documentation/foundation/nserror/localizedrecoverysuggestion).
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSLocalizedRecoveryOptionsErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    /// The corresponding value is an object that conforms to the NSErrorRecoveryAttempting informal protocol.
    ///
    /// ## Discussion
    ///
    /// The recovery attempter must be an object that can correctly interpret an index into the array returned by [`recoveryAttempter`](https://developer.apple.com/documentation/foundation/nserror/recoveryattempter).
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSRecoveryAttempterErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    /// The corresponding value is an `NSString` containing the localized help corresponding to the help button. See [`helpAnchor`](https://developer.apple.com/documentation/foundation/nserror/helpanchor) for more information.
    #[cfg(feature = "NSString")]
    pub static NSHelpAnchorErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSDebugDescriptionErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSLocalizedFailureErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    /// The corresponding value is an `NSNumber` object containing the `NSStringEncoding` value.
    #[cfg(feature = "NSString")]
    pub static NSStringEncodingErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    /// The corresponding value is an `NSURL` object.
    #[cfg(feature = "NSString")]
    pub static NSURLErrorKey: &'static NSErrorUserInfoKey;
}

extern "C" {
    /// Contains the file path of the error.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an `NSString` object.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSFilePathErrorKey: &'static NSErrorUserInfoKey;
}

extern_class!(
    /// Information about an error condition including a domain, a domain-specific error code, and application-specific information.
    ///
    /// ## Overview
    ///
    /// Objective-C methods can signal an error condition by returning an [`NSError`](https://developer.apple.com/documentation/foundation/nserror) object by reference, which provides additional information about the kind of error and any underlying cause, if one can be determined. An [`NSError`](https://developer.apple.com/documentation/foundation/nserror) object may also provide localized error descriptions suitable for display to the user in its user info dictionary. See [Error Handling Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorHandling/ErrorHandling.html#//apple_ref/doc/uid/TP40001806) for more information.
    ///
    /// Methods in Foundation and other Cocoa frameworks most often produce errors in the Cocoa error domain ([`NSCocoaErrorDomain`](https://developer.apple.com/documentation/foundation/nscocoaerrordomain)); error codes for the Cocoa Error Domain are documented in the [Foundation Constants](https://developer.apple.com/documentation/foundation/foundation-constants). There are also predefined domains corresponding to Mach ([`NSMachErrorDomain`](https://developer.apple.com/documentation/foundation/nsmacherrordomain)), POSIX ([`NSPOSIXErrorDomain`](https://developer.apple.com/documentation/foundation/nsposixerrordomain)), and Carbon ([`NSOSStatusErrorDomain`](https://developer.apple.com/documentation/foundation/nsosstatuserrordomain)) errors.
    ///
    /// [`NSError`](https://developer.apple.com/documentation/foundation/nserror) is “toll-free bridged” with its Core Foundation counterpart, [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror). See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information.
    ///
    /// ### Subclassing Notes
    ///
    /// Applications may choose to create subclasses of `NSError`, for example, to provide better localized error strings by overriding [`localizedDescription`](https://developer.apple.com/documentation/foundation/nserror/localizeddescription).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(PartialEq, Eq, Hash)]
    pub struct NSError;
);

unsafe impl Send for NSError {}

unsafe impl Sync for NSError {}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSError> for CFError {
    #[inline]
    fn as_ref(&self) -> &NSError {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFError> for NSError {
    #[inline]
    fn as_ref(&self) -> &CFError {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSError {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSError {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSError {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSError {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSError {}
);

impl NSError {
    extern_methods!(
        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `dict` generic should be of the correct type.
        #[unsafe(method(initWithDomain:code:userInfo:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDomain_code_userInfo(
            this: Allocated<Self>,
            domain: &NSErrorDomain,
            code: NSInteger,
            dict: Option<&NSDictionary<NSErrorUserInfoKey, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `dict` generic should be of the correct type.
        #[unsafe(method(errorWithDomain:code:userInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn errorWithDomain_code_userInfo(
            domain: &NSErrorDomain,
            code: NSInteger,
            dict: Option<&NSDictionary<NSErrorUserInfoKey, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(domain))]
        #[unsafe(method_family = none)]
        pub fn domain(&self) -> Retained<NSErrorDomain>;

        #[unsafe(method(code))]
        #[unsafe(method_family = none)]
        pub fn code(&self) -> NSInteger;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub fn userInfo(&self) -> Retained<NSDictionary<NSErrorUserInfoKey, AnyObject>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(localizedDescription))]
        #[unsafe(method_family = none)]
        pub fn localizedDescription(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(localizedFailureReason))]
        #[unsafe(method_family = none)]
        pub fn localizedFailureReason(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(localizedRecoverySuggestion))]
        #[unsafe(method_family = none)]
        pub fn localizedRecoverySuggestion(&self) -> Option<Retained<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(localizedRecoveryOptions))]
        #[unsafe(method_family = none)]
        pub fn localizedRecoveryOptions(&self) -> Option<Retained<NSArray<NSString>>>;

        #[unsafe(method(recoveryAttempter))]
        #[unsafe(method_family = none)]
        pub fn recoveryAttempter(&self) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(helpAnchor))]
        #[unsafe(method_family = none)]
        pub fn helpAnchor(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(underlyingErrors))]
        #[unsafe(method_family = none)]
        pub fn underlyingErrors(&self) -> Retained<NSArray<NSError>>;

        #[cfg(all(feature = "NSString", feature = "block2"))]
        /// # Safety
        ///
        /// `provider` block must be sendable.
        #[unsafe(method(setUserInfoValueProviderForDomain:provider:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUserInfoValueProviderForDomain_provider(
            error_domain: &NSErrorDomain,
            provider: Option<
                &block2::DynBlock<
                    dyn Fn(NonNull<NSError>, NonNull<NSErrorUserInfoKey>) -> *mut AnyObject,
                >,
            >,
        );

        #[cfg(all(feature = "NSString", feature = "block2"))]
        /// # Safety
        ///
        /// The returned block must be sendable.
        #[unsafe(method(userInfoValueProviderForDomain:))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInfoValueProviderForDomain(
            error_domain: &NSErrorDomain,
        ) -> *mut block2::DynBlock<
            dyn Fn(NonNull<NSError>, NonNull<NSErrorUserInfoKey>) -> *mut AnyObject,
        >;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSError {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

mod private_NSObjectNSErrorRecoveryAttempting {
    pub trait Sealed {}
}

/// Category "NSErrorRecoveryAttempting" on [`NSObject`].
#[doc(alias = "NSErrorRecoveryAttempting")]
pub unsafe trait NSObjectNSErrorRecoveryAttempting:
    ClassType + Sized + private_NSObjectNSErrorRecoveryAttempting::Sealed
{
    extern_methods!(
        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_recover_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(attemptRecoveryFromError:optionIndex:delegate:didRecoverSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        unsafe fn attemptRecoveryFromError_optionIndex_delegate_didRecoverSelector_contextInfo(
            &self,
            error: &NSError,
            recovery_option_index: NSUInteger,
            delegate: Option<&AnyObject>,
            did_recover_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[unsafe(method(attemptRecoveryFromError:optionIndex:))]
        #[unsafe(method_family = none)]
        fn attemptRecoveryFromError_optionIndex(
            &self,
            error: &NSError,
            recovery_option_index: NSUInteger,
        ) -> bool;
    );
}

impl private_NSObjectNSErrorRecoveryAttempting::Sealed for NSObject {}
unsafe impl NSObjectNSErrorRecoveryAttempting for NSObject {}
