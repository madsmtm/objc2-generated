//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// `NSStream` defines these string constants as keys for accessing stream properties using [`propertyForKey:`](https://developer.apple.com/documentation/foundation/stream/property(forkey:)) and setting properties with [`setProperty:forKey:`](https://developer.apple.com/documentation/foundation/stream/setproperty(_:forkey:)):
// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSStreamPropertyKey = NSString;

/// The type declared for the constants listed in doc:stream/stream_status_constants.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSStreamStatus(pub NSUInteger);
impl NSStreamStatus {
    /// The stream is not open for reading or writing. This status is returned before the underlying call to open a stream but after it’s been created.
    #[doc(alias = "NSStreamStatusNotOpen")]
    pub const NotOpen: Self = Self(0);
    /// The stream is in the process of being opened for reading or for writing. For network streams, this status might include the time after the stream was opened, but while network DNS resolution is happening.
    #[doc(alias = "NSStreamStatusOpening")]
    pub const Opening: Self = Self(1);
    /// The stream is open, but no reading or writing is occurring.
    #[doc(alias = "NSStreamStatusOpen")]
    pub const Open: Self = Self(2);
    /// Data is being read from the stream. This status would be returned if code on another thread were to call [`streamStatus`](https://developer.apple.com/documentation/foundation/stream/streamstatus) on the stream while a [`read:maxLength:`](https://developer.apple.com/documentation/foundation/inputstream/read(_:maxlength:)) call ([`NSInputStream`](https://developer.apple.com/documentation/foundation/inputstream)) was in progress.
    #[doc(alias = "NSStreamStatusReading")]
    pub const Reading: Self = Self(3);
    /// Data is being written to the stream. This status would be returned if code on another thread were to call [`streamStatus`](https://developer.apple.com/documentation/foundation/stream/streamstatus) on the stream while a [`write:maxLength:`](https://developer.apple.com/documentation/foundation/outputstream/write(_:maxlength:)) call ([`NSOutputStream`](https://developer.apple.com/documentation/foundation/outputstream)) was in progress.
    #[doc(alias = "NSStreamStatusWriting")]
    pub const Writing: Self = Self(4);
    /// There is no more data to read, or no more data can be written to the stream. When this status is returned, the stream is in a “non-blocking” mode and no data are available.
    #[doc(alias = "NSStreamStatusAtEnd")]
    pub const AtEnd: Self = Self(5);
    /// The stream is closed ([`close`](https://developer.apple.com/documentation/foundation/stream/close()) has been called on it).
    #[doc(alias = "NSStreamStatusClosed")]
    pub const Closed: Self = Self(6);
    /// The remote end of the connection can’t be contacted, or the connection has been severed for some other reason.
    #[doc(alias = "NSStreamStatusError")]
    pub const Error: Self = Self(7);
}

unsafe impl Encode for NSStreamStatus {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSStreamStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes the constants that may be sent to the delegate as a bit field in the second parameter of [`stream:handleEvent:`](https://developer.apple.com/documentation/foundation/streamdelegate/stream(_:handle:)) to specify the kind of stream event.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSStreamEvent(pub NSUInteger);
bitflags::bitflags! {
    impl NSStreamEvent: NSUInteger {
/// No event has occurred.
        #[doc(alias = "NSStreamEventNone")]
        const None = 0;
/// The open has completed successfully.
        #[doc(alias = "NSStreamEventOpenCompleted")]
        const OpenCompleted = 1<<0;
/// The stream has bytes to be read.
        #[doc(alias = "NSStreamEventHasBytesAvailable")]
        const HasBytesAvailable = 1<<1;
/// The stream can accept bytes for writing.
        #[doc(alias = "NSStreamEventHasSpaceAvailable")]
        const HasSpaceAvailable = 1<<2;
/// An error has occurred on the stream.
        #[doc(alias = "NSStreamEventErrorOccurred")]
        const ErrorOccurred = 1<<3;
/// The end of the stream has been reached.
        #[doc(alias = "NSStreamEventEndEncountered")]
        const EndEncountered = 1<<4;
    }
}

unsafe impl Encode for NSStreamEvent {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSStreamEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An abstract class representing a stream.
    ///
    /// ## Overview
    ///
    /// This class’s interface is common to all Cocoa stream classes, including its concrete subclasses [`NSInputStream`](https://developer.apple.com/documentation/foundation/inputstream) and [`NSOutputStream`](https://developer.apple.com/documentation/foundation/outputstream).
    ///
    /// [`NSStream`](https://developer.apple.com/documentation/foundation/stream) objects provide an easy way to read and write data to and from a variety of media in a device-independent way. You can create stream objects for data located in memory, in a file, or on a network (using sockets), and you can use stream objects without loading all of the data into memory at once.
    ///
    /// By default, [`NSStream`](https://developer.apple.com/documentation/foundation/stream) instances that aren’t file-based are non-seekable, one-way streams (although custom seekable subclasses are possible). After you provide or consume data, you can’t retrieve the data from the stream.
    ///
    /// ### Subclassing Notes
    ///
    /// [`NSStream`](https://developer.apple.com/documentation/foundation/stream) is an abstract class, incapable of instantiation and intended for you to subclass it. It publishes a programmatic interface that all subclasses must adopt and provide implementations for. The two Apple-provided concrete subclasses of [`NSStream`](https://developer.apple.com/documentation/foundation/stream), [`NSInputStream`](https://developer.apple.com/documentation/foundation/inputstream) and [`NSOutputStream`](https://developer.apple.com/documentation/foundation/outputstream), are suitable for most purposes. However, there might be situations when you want a peer subclass to [`NSInputStream`](https://developer.apple.com/documentation/foundation/inputstream) and [`NSOutputStream`](https://developer.apple.com/documentation/foundation/outputstream). For example, you might want a class that implements a full-duplex (two-way) stream, or a class whose instances are capable of seeking through a stream.
    ///
    /// #### Methods to Override
    ///
    /// All subclasses must fully implement the following methods:
    ///
    /// - [`open`](https://developer.apple.com/documentation/foundation/stream/open()) and [`close`](https://developer.apple.com/documentation/foundation/stream/close())
    ///
    /// Implement [`open`](https://developer.apple.com/documentation/foundation/stream/open()) to open the stream for reading or writing and make the stream available to the client directly or, if the stream object is scheduled on a run loop, to the delegate. Implement [`close`](https://developer.apple.com/documentation/foundation/stream/close()) to close the stream and remove the stream object from the run loop, if necessary. A closed stream should still be able to accept new properties and report its current properties. Once you close a stream, you can’t reopen it.
    ///
    /// - [`delegate`](https://developer.apple.com/documentation/foundation/stream/delegate)
    ///
    /// Return and set the delegate. By a default, a stream object must be its own delegate; so a [`delegate`](https://developer.apple.com/documentation/foundation/stream/delegate) message with an argument of `nil` should restore this delegate. Don’t retain the delegate to prevent retain cycles.
    ///
    /// To learn about delegates and delegation, read “Delegation” in Cocoa Fundamentals Guide.
    ///
    /// - [`scheduleInRunLoop:forMode:`](https://developer.apple.com/documentation/foundation/stream/schedule(in:formode:)) and [`removeFromRunLoop:forMode:`](https://developer.apple.com/documentation/foundation/stream/remove(from:formode:))
    ///
    /// Implement [`scheduleInRunLoop:forMode:`](https://developer.apple.com/documentation/foundation/stream/schedule(in:formode:)) to schedule the stream object on the specified run loop for the specified mode. Implement [`removeFromRunLoop:forMode:`](https://developer.apple.com/documentation/foundation/stream/remove(from:formode:)) to remove the object from the run loop. See the documentation of the [`NSRunLoop`](https://developer.apple.com/documentation/foundation/runloop) class for details. Once the stream object for an open stream is scheduled on a run loop, it is the responsibility of the subclass as it processes stream data to send [`stream:handleEvent:`](https://developer.apple.com/documentation/foundation/streamdelegate/stream(_:handle:)) messages to its delegate.
    ///
    /// - [`propertyForKey:`](https://developer.apple.com/documentation/foundation/stream/property(forkey:)) and [`setProperty:forKey:`](https://developer.apple.com/documentation/foundation/stream/setproperty(_:forkey:))
    ///
    /// Implement these methods to return and set, respectively, the property value for the specified key. You may add custom properties, but be sure to handle all properties defined by [`NSStream`](https://developer.apple.com/documentation/foundation/stream) as well.
    ///
    /// - [`streamStatus`](https://developer.apple.com/documentation/foundation/stream/streamstatus) and [`streamError`](https://developer.apple.com/documentation/foundation/stream/streamerror)
    ///
    /// Implement [`streamStatus`](https://developer.apple.com/documentation/foundation/stream/streamstatus) to return the current status of the stream as a [`NSStreamStatus`](https://developer.apple.com/documentation/foundation/stream/status) constant; you may define new [`NSStreamStatus`](https://developer.apple.com/documentation/foundation/stream/status) constants, but be sure to handle the system defined constants properly. Implement [`streamError`](https://developer.apple.com/documentation/foundation/stream/streamerror) to return an [`NSError`](https://developer.apple.com/documentation/foundation/nserror) object representing the current error. You might decide to return a custom [`NSError`](https://developer.apple.com/documentation/foundation/nserror) object that can provide complete and localized information about the error.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSStream;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSStream {}
);

impl NSStream {
    extern_methods!(
        #[unsafe(method(open))]
        #[unsafe(method_family = none)]
        pub fn open(&self);

        #[unsafe(method(close))]
        #[unsafe(method_family = none)]
        pub fn close(&self);

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSStreamDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSStreamDelegate>>);

        #[cfg(feature = "NSString")]
        #[unsafe(method(propertyForKey:))]
        #[unsafe(method_family = none)]
        pub fn propertyForKey(&self, key: &NSStreamPropertyKey) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `property` should be of the correct type.
        #[unsafe(method(setProperty:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProperty_forKey(
            &self,
            property: Option<&AnyObject>,
            key: &NSStreamPropertyKey,
        ) -> bool;

        #[cfg(all(feature = "NSObjCRuntime", feature = "NSRunLoop", feature = "NSString"))]
        /// # Safety
        ///
        /// `a_run_loop` possibly has additional threading requirements.
        #[unsafe(method(scheduleInRunLoop:forMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scheduleInRunLoop_forMode(
            &self,
            a_run_loop: &NSRunLoop,
            mode: &NSRunLoopMode,
        );

        #[cfg(all(feature = "NSObjCRuntime", feature = "NSRunLoop", feature = "NSString"))]
        /// # Safety
        ///
        /// `a_run_loop` possibly has additional threading requirements.
        #[unsafe(method(removeFromRunLoop:forMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromRunLoop_forMode(
            &self,
            a_run_loop: &NSRunLoop,
            mode: &NSRunLoopMode,
        );

        #[unsafe(method(streamStatus))]
        #[unsafe(method_family = none)]
        pub fn streamStatus(&self) -> NSStreamStatus;

        #[cfg(feature = "NSError")]
        #[unsafe(method(streamError))]
        #[unsafe(method_family = none)]
        pub fn streamError(&self) -> Option<Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSStream {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSStream {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// A stream that provides read-only stream functionality.
    ///
    /// ## Overview
    ///
    /// [`NSInputStream`](https://developer.apple.com/documentation/foundation/inputstream) is “toll-free bridged” with its Core Foundation counterpart, [`CFReadStreamRef`](https://developer.apple.com/documentation/corefoundation/cfreadstream). For more information on toll-free bridging, see [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2).
    ///
    /// ### Subclassing Notes
    ///
    /// `NSInputStream` is an abstract superclass of a _class cluster_ consisting of concrete subclasses of `NSStream` that provide standard read-only access to stream data. Although `NSInputStream` is probably sufficient for most situations requiring access to stream data, you can create a subclass of `NSInputStream` if you want more specialized behavior (for example, you want to record statistics on the data in a stream).
    ///
    /// #### Methods to Override
    ///
    /// To create a subclass of `NSInputStream` you may have to implement initializers for the type of stream data supported and suitably re-implement existing initializers. You must also provide complete implementations of the following methods:
    ///
    /// - [`read:maxLength:`](https://developer.apple.com/documentation/foundation/inputstream/read(_:maxlength:))
    ///
    /// From the current read index, take up to the number of bytes specified in the second parameter from the stream and place them in the client-supplied buffer (first parameter). The buffer must be of the size specified by the second parameter. Return the actual number of bytes placed in the buffer; if there is nothing left in the stream, return `0`. Reset the index into the stream for the next read operation.
    ///
    /// - [`getBuffer:length:`](https://developer.apple.com/documentation/foundation/inputstream/getbuffer(_:length:))
    ///
    /// Return in 0(1) a pointer to the subclass-allocated buffer (first parameter). Return by reference in the second parameter the number of bytes actually put into the buffer. The buffer’s contents are valid only until the next stream operation. Return [`false`](https://developer.apple.com/documentation/swift/false) if you cannot access data in the buffer; otherwise, return [`true`](https://developer.apple.com/documentation/swift/true). If this method is not appropriate for your type of stream, you may return [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    /// - [`hasBytesAvailable`](https://developer.apple.com/documentation/foundation/inputstream/hasbytesavailable)
    ///
    /// Return [`true`](https://developer.apple.com/documentation/swift/true) if there is more data to read in the stream, [`false`](https://developer.apple.com/documentation/swift/false) if there is not. If you want to be semantically compatible with `NSInputStream`, return [`true`](https://developer.apple.com/documentation/swift/true) if a read must be attempted to determine if bytes are available.
    ///
    ///
    #[unsafe(super(NSStream, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSInputStream;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSInputStream> for CFReadStream {
    #[inline]
    fn as_ref(&self) -> &NSInputStream {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFReadStream> for NSInputStream {
    #[inline]
    fn as_ref(&self) -> &CFReadStream {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSInputStream {}
);

impl NSInputStream {
    extern_methods!(
        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[unsafe(method(read:maxLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn read_maxLength(&self, buffer: NonNull<u8>, len: NSUInteger) -> NSInteger;

        /// # Safety
        ///
        /// - `buffer` must be a valid pointer.
        /// - `len` must be a valid pointer.
        #[unsafe(method(getBuffer:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getBuffer_length(
            &self,
            buffer: NonNull<*mut u8>,
            len: NonNull<NSUInteger>,
        ) -> bool;

        #[unsafe(method(hasBytesAvailable))]
        #[unsafe(method_family = none)]
        pub fn hasBytesAvailable(&self) -> bool;

        #[cfg(feature = "NSData")]
        #[unsafe(method(initWithData:))]
        #[unsafe(method_family = init)]
        pub fn initWithData(this: Allocated<Self>, data: &NSData) -> Retained<Self>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(initWithURL:))]
        #[unsafe(method_family = init)]
        pub fn initWithURL(this: Allocated<Self>, url: &NSURL) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSInputStream {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSInputStream {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// A stream that provides write-only stream functionality.
    ///
    /// ## Overview
    ///
    /// [`NSOutputStream`](https://developer.apple.com/documentation/foundation/outputstream) is “toll-free bridged” with its Core Foundation counterpart, [`CFWriteStreamRef`](https://developer.apple.com/documentation/corefoundation/cfwritestream). For more information on toll-free bridging, see [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2).
    ///
    /// ### Subclassing Notes
    ///
    /// `NSOutputStream` is a concrete subclass of `NSStream` that lets you write data to a stream. Although `NSOutputStream` is probably sufficient for most situations requiring this capability, you can create a subclass of `NSOutputStream` if you want more specialized behavior (for example, you want to record statistics on the data in a stream).
    ///
    /// #### Methods to Override
    ///
    /// To create a subclass of `NSOutputStream` you may have to implement initializers for the type of stream data supported and suitably reimplement existing initializers. You must also provide complete implementations of the following methods:
    ///
    /// - [`write:maxLength:`](https://developer.apple.com/documentation/foundation/outputstream/write(_:maxlength:))
    ///
    /// From the current write pointer, take up to the number of bytes specified in the `maxLength:` parameter from the client-supplied buffer (first parameter) and put them onto the stream. The buffer must be of the size specified by the second parameter. To prepare for the next operation, offset the write pointer by the number of bytes written. Return a signed integer based on the outcome of the current operation:
    ///
    /// - If the write operation is successful, return the actual number of bytes put onto the stream.
    ///
    /// - If the stream is of a fixed length and has reached its capacity, return `0`.
    ///
    /// - If there was an error writing to the stream, return `-1`.
    ///
    /// - [`hasSpaceAvailable`](https://developer.apple.com/documentation/foundation/outputstream/hasspaceavailable)
    ///
    /// Return [`true`](https://developer.apple.com/documentation/swift/true) if the stream can currently accept more data, [`false`](https://developer.apple.com/documentation/swift/false) if it cannot. If you want to be semantically compatible with `NSOutputStream`, return [`true`](https://developer.apple.com/documentation/swift/true) if a write must be attempted to determine if space is available.
    ///
    ///
    #[unsafe(super(NSStream, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSOutputStream;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSOutputStream> for CFWriteStream {
    #[inline]
    fn as_ref(&self) -> &NSOutputStream {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFWriteStream> for NSOutputStream {
    #[inline]
    fn as_ref(&self) -> &CFWriteStream {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSOutputStream {}
);

impl NSOutputStream {
    extern_methods!(
        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[unsafe(method(write:maxLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn write_maxLength(&self, buffer: NonNull<u8>, len: NSUInteger) -> NSInteger;

        #[unsafe(method(hasSpaceAvailable))]
        #[unsafe(method_family = none)]
        pub fn hasSpaceAvailable(&self) -> bool;

        #[unsafe(method(initToMemory))]
        #[unsafe(method_family = init)]
        pub fn initToMemory(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[unsafe(method(initToBuffer:capacity:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initToBuffer_capacity(
            this: Allocated<Self>,
            buffer: NonNull<u8>,
            capacity: NSUInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(initWithURL:append:))]
        #[unsafe(method_family = init)]
        pub fn initWithURL_append(
            this: Allocated<Self>,
            url: &NSURL,
            should_append: bool,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSOutputStream {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSOutputStream {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSSocketStreamCreationExtensions.
impl NSStream {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[deprecated = "Use nw_connection_t in Network framework instead"]
        #[unsafe(method(getStreamsToHostWithName:port:inputStream:outputStream:))]
        #[unsafe(method_family = none)]
        pub fn getStreamsToHostWithName_port_inputStream_outputStream(
            hostname: &NSString,
            port: NSInteger,
            input_stream: Option<&mut Option<Retained<NSInputStream>>>,
            output_stream: Option<&mut Option<Retained<NSOutputStream>>>,
        );

        #[cfg(feature = "NSHost")]
        #[deprecated = "Use nw_connection_t in Network framework instead"]
        #[unsafe(method(getStreamsToHost:port:inputStream:outputStream:))]
        #[unsafe(method_family = none)]
        pub fn getStreamsToHost_port_inputStream_outputStream(
            host: &NSHost,
            port: NSInteger,
            input_stream: Option<&mut Option<Retained<NSInputStream>>>,
            output_stream: Option<&mut Option<Retained<NSOutputStream>>>,
        );
    );
}

/// NSStreamBoundPairCreationExtensions.
impl NSStream {
    extern_methods!(
        #[unsafe(method(getBoundStreamsWithBufferSize:inputStream:outputStream:))]
        #[unsafe(method_family = none)]
        pub fn getBoundStreamsWithBufferSize_inputStream_outputStream(
            buffer_size: NSUInteger,
            input_stream: Option<&mut Option<Retained<NSInputStream>>>,
            output_stream: Option<&mut Option<Retained<NSOutputStream>>>,
        );
    );
}

/// NSInputStreamExtensions.
impl NSInputStream {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithFileAtPath:))]
        #[unsafe(method_family = init)]
        pub fn initWithFileAtPath(this: Allocated<Self>, path: &NSString)
            -> Option<Retained<Self>>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(inputStreamWithData:))]
        #[unsafe(method_family = none)]
        pub fn inputStreamWithData(data: &NSData) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(inputStreamWithFileAtPath:))]
        #[unsafe(method_family = none)]
        pub fn inputStreamWithFileAtPath(path: &NSString) -> Option<Retained<Self>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(inputStreamWithURL:))]
        #[unsafe(method_family = none)]
        pub fn inputStreamWithURL(url: &NSURL) -> Option<Retained<Self>>;
    );
}

/// NSOutputStreamExtensions.
impl NSOutputStream {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(initToFileAtPath:append:))]
        #[unsafe(method_family = init)]
        pub fn initToFileAtPath_append(
            this: Allocated<Self>,
            path: &NSString,
            should_append: bool,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(outputStreamToMemory))]
        #[unsafe(method_family = none)]
        pub fn outputStreamToMemory() -> Retained<Self>;

        /// # Safety
        ///
        /// `buffer` must be a valid pointer.
        #[unsafe(method(outputStreamToBuffer:capacity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn outputStreamToBuffer_capacity(
            buffer: NonNull<u8>,
            capacity: NSUInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(outputStreamToFileAtPath:append:))]
        #[unsafe(method_family = none)]
        pub fn outputStreamToFileAtPath_append(
            path: &NSString,
            should_append: bool,
        ) -> Retained<Self>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(outputStreamWithURL:append:))]
        #[unsafe(method_family = none)]
        pub fn outputStreamWithURL_append(
            url: &NSURL,
            should_append: bool,
        ) -> Option<Retained<Self>>;
    );
}

extern_protocol!(
    /// An interface that delegates of a stream instance use to handle events on the stream.
    pub unsafe trait NSStreamDelegate: NSObjectProtocol {
        #[optional]
        #[unsafe(method(stream:handleEvent:))]
        #[unsafe(method_family = none)]
        fn stream_handleEvent(&self, a_stream: &NSStream, event_code: NSStreamEvent);
    }
);

extern "C" {
    ///
    /// ## Discussion
    ///
    /// The security level of the target stream. See `Secure-Socket Layer (SSL) Security Level` for a list of possible values.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSStreamSocketSecurityLevelKey: &'static NSStreamPropertyKey;
}

/// `NSStream` defines these string constants for specifying the secure-socket layer (SSL) security level.
///
/// ## Discussion
///
/// You access and set these values using the `NSStreamSocketSecurityLevelKey` property key.
///
///
// NS_TYPED_ENUM
#[cfg(feature = "NSString")]
pub type NSStreamSocketSecurityLevel = NSString;

extern "C" {
    /// Specifies that no security level be set for a socket stream.
    #[cfg(feature = "NSString")]
    pub static NSStreamSocketSecurityLevelNone: &'static NSStreamSocketSecurityLevel;
}

extern "C" {
    /// Specifies that SSL version 2 be set as the security protocol for a socket stream.
    #[cfg(feature = "NSString")]
    pub static NSStreamSocketSecurityLevelSSLv2: &'static NSStreamSocketSecurityLevel;
}

extern "C" {
    /// Specifies that SSL version 3 be set as the security protocol for a socket stream.
    #[cfg(feature = "NSString")]
    pub static NSStreamSocketSecurityLevelSSLv3: &'static NSStreamSocketSecurityLevel;
}

extern "C" {
    /// Specifies that TLS version 1 be set as the security protocol for a socket stream.
    #[cfg(feature = "NSString")]
    pub static NSStreamSocketSecurityLevelTLSv1: &'static NSStreamSocketSecurityLevel;
}

extern "C" {
    /// Specifies that the highest level security protocol that can be negotiated be set as the security protocol for a socket stream.
    #[cfg(feature = "NSString")]
    pub static NSStreamSocketSecurityLevelNegotiatedSSL: &'static NSStreamSocketSecurityLevel;
}

extern "C" {
    /// Value is an `NSDictionary` object containing SOCKS proxy configuration information.
    ///
    /// ## Discussion
    ///
    /// The dictionary returned from the System Configuration framework for SOCKS proxies usually suffices.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSStreamSOCKSProxyConfigurationKey: &'static NSStreamPropertyKey;
}

// NS_TYPED_ENUM
#[cfg(feature = "NSString")]
pub type NSStreamSOCKSProxyConfiguration = NSString;

extern "C" {
    /// Value is an `NSString` object that represents the SOCKS proxy host.
    #[cfg(feature = "NSString")]
    pub static NSStreamSOCKSProxyHostKey: &'static NSStreamSOCKSProxyConfiguration;
}

extern "C" {
    /// Value is an `NSNumber` object containing an integer that represents the port on which the proxy listens.
    #[cfg(feature = "NSString")]
    pub static NSStreamSOCKSProxyPortKey: &'static NSStreamSOCKSProxyConfiguration;
}

extern "C" {
    /// Value is either `NSStreamSOCKSProxyVersion4` or `NSStreamSOCKSProxyVersion5`.
    ///
    /// ## Discussion
    ///
    /// If this key is not present, `NSStreamSOCKSProxyVersion5` is used by default.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSStreamSOCKSProxyVersionKey: &'static NSStreamSOCKSProxyConfiguration;
}

extern "C" {
    /// Value is an `NSString` object containing the user’s name.
    #[cfg(feature = "NSString")]
    pub static NSStreamSOCKSProxyUserKey: &'static NSStreamSOCKSProxyConfiguration;
}

extern "C" {
    /// Value is an `NSString` object containing the user’s password.
    #[cfg(feature = "NSString")]
    pub static NSStreamSOCKSProxyPasswordKey: &'static NSStreamSOCKSProxyConfiguration;
}

// NS_TYPED_ENUM
#[cfg(feature = "NSString")]
pub type NSStreamSOCKSProxyVersion = NSString;

extern "C" {
    /// Possible value for `NSStreamSOCKSProxyVersionKey`.
    #[cfg(feature = "NSString")]
    pub static NSStreamSOCKSProxyVersion4: &'static NSStreamSOCKSProxyVersion;
}

extern "C" {
    /// Possible value for `NSStreamSOCKSProxyVersionKey`.
    #[cfg(feature = "NSString")]
    pub static NSStreamSOCKSProxyVersion5: &'static NSStreamSOCKSProxyVersion;
}

extern "C" {
    /// Value is an `NSData` instance containing the data written to a memory stream.
    ///
    /// ## Discussion
    ///
    /// Use this property when you have an output-stream object instantiated to collect written data in memory. The value of this property is read-only.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSStreamDataWrittenToMemoryStreamKey: &'static NSStreamPropertyKey;
}

extern "C" {
    /// Value is an `NSNumber` object containing the current absolute offset of the stream.
    #[cfg(feature = "NSString")]
    pub static NSStreamFileCurrentOffsetKey: &'static NSStreamPropertyKey;
}

extern "C" {
    /// The error domain used by `NSError` when reporting SSL errors.
    #[cfg(all(feature = "NSError", feature = "NSString"))]
    pub static NSStreamSocketSSLErrorDomain: &'static NSErrorDomain;
}

extern "C" {
    /// The error domain used by `NSError` when reporting SOCKS errors.
    #[cfg(all(feature = "NSError", feature = "NSString"))]
    pub static NSStreamSOCKSErrorDomain: &'static NSErrorDomain;
}

extern "C" {
    /// The type of service for the stream. Providing the service type allows the system to properly handle certain attributes of the stream, including routing and suspension behavior. Most streams do not need to set this property. See `Stream Service Types` for a list of possible values.
    #[cfg(feature = "NSString")]
    pub static NSStreamNetworkServiceType: &'static NSStreamPropertyKey;
}

/// `NSStream` defines these string constants for specifying the service type of a stream.
// NS_TYPED_ENUM
#[cfg(feature = "NSString")]
pub type NSStreamNetworkServiceTypeValue = NSString;

extern "C" {
    /// Specifies that the stream is providing VoIP service.
    #[cfg(feature = "NSString")]
    pub static NSStreamNetworkServiceTypeVoIP: &'static NSStreamNetworkServiceTypeValue;
}

extern "C" {
    /// Specifies that the stream is providing video service.
    #[cfg(feature = "NSString")]
    pub static NSStreamNetworkServiceTypeVideo: &'static NSStreamNetworkServiceTypeValue;
}

extern "C" {
    /// Specifies that the stream is providing a background service.
    #[cfg(feature = "NSString")]
    pub static NSStreamNetworkServiceTypeBackground: &'static NSStreamNetworkServiceTypeValue;
}

extern "C" {
    /// Specifies that the stream is providing voice service.
    #[cfg(feature = "NSString")]
    pub static NSStreamNetworkServiceTypeVoice: &'static NSStreamNetworkServiceTypeValue;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSStreamNetworkServiceTypeCallSignaling: &'static NSStreamNetworkServiceTypeValue;
}
