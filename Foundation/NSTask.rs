//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Constants that specify the termination reason values that the system returns.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSTaskTerminationReason(pub NSInteger);
impl NSTaskTerminationReason {
    /// The task exited normally.
    #[doc(alias = "NSTaskTerminationReasonExit")]
    pub const Exit: Self = Self(1);
    /// The task exited due to an uncaught signal.
    #[doc(alias = "NSTaskTerminationReasonUncaughtSignal")]
    pub const UncaughtSignal: Self = Self(2);
}

unsafe impl Encode for NSTaskTerminationReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSTaskTerminationReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that represents a subprocess of the current process.
    ///
    /// ## Overview
    ///
    /// Using this class, your program can run another program as a subprocess and monitor that program’s execution. Unlike [`NSThread`](https://developer.apple.com/documentation/foundation/thread), it doesn’t share memory space with the process that creates it.
    ///
    /// A process operates within an environment defined by the current values for several items: the current directory, standard input, standard output, standard error, and the values of any environment variables, inheriting its environment from the process that launches it. If there are any environment variables that should be different for the subprocess (for example, if the current directory needs to change), change it in the instance after initialization, before your app launches it. Your app can’t change a process’s environment while it’s running.
    ///
    /// You can only run the subprocess once per instance. Subsequent attempts raise an error.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  In a sandboxed app, child processes you create with this class inherit the sandbox of the parent app. Instead, write helper apps as XPC Services because it allows you to specify different sandbox entitlements for helper apps. For more information, see [Daemons and Services Programming Guide](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPSystemStartup/Chapters/Introduction.html#//apple_ref/doc/uid/10000172i) and [`XPC`](https://developer.apple.com/documentation/xpc).
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSTask;
);

unsafe impl Send for NSTask {}

unsafe impl Sync for NSTask {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSTask {}
);

impl NSTask {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(executableURL))]
        #[unsafe(method_family = none)]
        pub fn executableURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        /// Setter for [`executableURL`][Self::executableURL].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setExecutableURL:))]
        #[unsafe(method_family = none)]
        pub fn setExecutableURL(&self, executable_url: Option<&NSURL>);

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(arguments))]
        #[unsafe(method_family = none)]
        pub fn arguments(&self) -> Option<Retained<NSArray<NSString>>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        /// Setter for [`arguments`][Self::arguments].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setArguments:))]
        #[unsafe(method_family = none)]
        pub fn setArguments(&self, arguments: Option<&NSArray<NSString>>);

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(environment))]
        #[unsafe(method_family = none)]
        pub fn environment(&self) -> Option<Retained<NSDictionary<NSString, NSString>>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// Setter for [`environment`][Self::environment].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setEnvironment:))]
        #[unsafe(method_family = none)]
        pub fn setEnvironment(&self, environment: Option<&NSDictionary<NSString, NSString>>);

        #[cfg(feature = "NSURL")]
        #[unsafe(method(currentDirectoryURL))]
        #[unsafe(method_family = none)]
        pub fn currentDirectoryURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        /// Setter for [`currentDirectoryURL`][Self::currentDirectoryURL].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setCurrentDirectoryURL:))]
        #[unsafe(method_family = none)]
        pub fn setCurrentDirectoryURL(&self, current_directory_url: Option<&NSURL>);

        #[cfg(feature = "NSData")]
        #[unsafe(method(launchRequirementData))]
        #[unsafe(method_family = none)]
        pub fn launchRequirementData(&self) -> Option<Retained<NSData>>;

        #[cfg(feature = "NSData")]
        /// Setter for [`launchRequirementData`][Self::launchRequirementData].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setLaunchRequirementData:))]
        #[unsafe(method_family = none)]
        pub fn setLaunchRequirementData(&self, launch_requirement_data: Option<&NSData>);

        #[unsafe(method(standardInput))]
        #[unsafe(method_family = none)]
        pub fn standardInput(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`standardInput`][Self::standardInput].
        ///
        /// # Safety
        ///
        /// `standard_input` should be of the correct type.
        #[unsafe(method(setStandardInput:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStandardInput(&self, standard_input: Option<&AnyObject>);

        #[unsafe(method(standardOutput))]
        #[unsafe(method_family = none)]
        pub fn standardOutput(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`standardOutput`][Self::standardOutput].
        ///
        /// # Safety
        ///
        /// `standard_output` should be of the correct type.
        #[unsafe(method(setStandardOutput:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStandardOutput(&self, standard_output: Option<&AnyObject>);

        #[unsafe(method(standardError))]
        #[unsafe(method_family = none)]
        pub fn standardError(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`standardError`][Self::standardError].
        ///
        /// # Safety
        ///
        /// `standard_error` should be of the correct type.
        #[unsafe(method(setStandardError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStandardError(&self, standard_error: Option<&AnyObject>);

        #[cfg(feature = "NSError")]
        #[unsafe(method(launchAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub fn launchAndReturnError(&self) -> Result<(), Retained<NSError>>;

        #[unsafe(method(interrupt))]
        #[unsafe(method_family = none)]
        pub fn interrupt(&self);

        #[unsafe(method(terminate))]
        #[unsafe(method_family = none)]
        pub fn terminate(&self);

        #[unsafe(method(suspend))]
        #[unsafe(method_family = none)]
        pub fn suspend(&self) -> bool;

        #[unsafe(method(resume))]
        #[unsafe(method_family = none)]
        pub fn resume(&self) -> bool;

        #[unsafe(method(processIdentifier))]
        #[unsafe(method_family = none)]
        pub fn processIdentifier(&self) -> c_int;

        #[unsafe(method(isRunning))]
        #[unsafe(method_family = none)]
        pub fn isRunning(&self) -> bool;

        #[unsafe(method(terminationStatus))]
        #[unsafe(method_family = none)]
        pub fn terminationStatus(&self) -> c_int;

        #[unsafe(method(terminationReason))]
        #[unsafe(method_family = none)]
        pub fn terminationReason(&self) -> NSTaskTerminationReason;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block must be sendable.
        #[unsafe(method(terminationHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn terminationHandler(&self) -> *mut block2::DynBlock<dyn Fn(NonNull<NSTask>)>;

        #[cfg(feature = "block2")]
        /// Setter for [`terminationHandler`][Self::terminationHandler].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `termination_handler` block must be sendable.
        #[unsafe(method(setTerminationHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTerminationHandler(
            &self,
            termination_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSTask>)>>,
        );

        #[cfg(feature = "NSObjCRuntime")]
        #[unsafe(method(qualityOfService))]
        #[unsafe(method_family = none)]
        pub fn qualityOfService(&self) -> NSQualityOfService;

        #[cfg(feature = "NSObjCRuntime")]
        /// Setter for [`qualityOfService`][Self::qualityOfService].
        #[unsafe(method(setQualityOfService:))]
        #[unsafe(method_family = none)]
        pub fn setQualityOfService(&self, quality_of_service: NSQualityOfService);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSTask {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSTask {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSTaskConveniences.
impl NSTask {
    extern_methods!(
        #[cfg(all(
            feature = "NSArray",
            feature = "NSError",
            feature = "NSString",
            feature = "NSURL",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `termination_handler` block must be sendable.
        #[unsafe(method(launchedTaskWithExecutableURL:arguments:error:terminationHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn launchedTaskWithExecutableURL_arguments_error_terminationHandler(
            url: &NSURL,
            arguments: &NSArray<NSString>,
            error: Option<&mut Option<Retained<NSError>>>,
            termination_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSTask>)>>,
        ) -> Option<Retained<NSTask>>;

        #[unsafe(method(waitUntilExit))]
        #[unsafe(method_family = none)]
        pub fn waitUntilExit(&self);
    );
}

/// NSDeprecated.
impl NSTask {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[deprecated]
        #[unsafe(method(launchPath))]
        #[unsafe(method_family = none)]
        pub fn launchPath(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`launchPath`][Self::launchPath].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[deprecated]
        #[unsafe(method(setLaunchPath:))]
        #[unsafe(method_family = none)]
        pub fn setLaunchPath(&self, launch_path: Option<&NSString>);

        #[cfg(feature = "NSString")]
        #[deprecated]
        #[unsafe(method(currentDirectoryPath))]
        #[unsafe(method_family = none)]
        pub fn currentDirectoryPath(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        /// Setter for [`currentDirectoryPath`][Self::currentDirectoryPath].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[deprecated]
        #[unsafe(method(setCurrentDirectoryPath:))]
        #[unsafe(method_family = none)]
        pub fn setCurrentDirectoryPath(&self, current_directory_path: &NSString);

        #[deprecated]
        #[unsafe(method(launch))]
        #[unsafe(method_family = none)]
        pub fn launch(&self);

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[deprecated]
        #[unsafe(method(launchedTaskWithLaunchPath:arguments:))]
        #[unsafe(method_family = none)]
        pub fn launchedTaskWithLaunchPath_arguments(
            path: &NSString,
            arguments: &NSArray<NSString>,
        ) -> Retained<NSTask>;
    );
}

extern "C" {
    /// Posted when the task has stopped execution.
    ///
    /// ## Discussion
    ///
    /// The notification object is the `NSTask` object that the system terminated. This notification doesn’t contain a `userInfo` dictionary.
    ///
    /// The system posts this notification from the thread in which the `NSTask` object called [`launch`](https://developer.apple.com/documentation/foundation/process/launch()). When launching a task from a secondary thread or background queue, you can use the [`terminationHandler`](https://developer.apple.com/documentation/foundation/process/terminationhandler) property instead for greater control over the execution context of any operations to be performed after the task finishes.
    ///
    /// This notification can be posted either when the task has exited normally or as a result of [`terminate`](https://developer.apple.com/documentation/foundation/process/terminate()) being sent to the `NSTask` object. If the `NSTask` object gets released, however, this notification won’t get sent, as the port the message would have been sent on was released as part of the task release. The observer method can use [`terminationStatus`](https://developer.apple.com/documentation/foundation/process/terminationstatus) to determine why the task died.
    ///
    ///
    #[cfg(all(feature = "NSNotification", feature = "NSString"))]
    pub static NSTaskDidTerminateNotification: &'static NSNotificationName;
}
