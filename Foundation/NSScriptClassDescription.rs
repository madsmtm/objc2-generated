//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern_class!(
    /// A scriptable class that a macOS app supports.
    ///
    /// ## Overview
    ///
    /// A scriptable application provides scriptability information that describes the commands and objects scripters can use in scripts that target the application. That includes information about the classes those scriptable objects are created from.
    ///
    /// An application’s scriptability information is collected automatically by an instance of [`NSScriptSuiteRegistry`](https://developer.apple.com/documentation/foundation/nsscriptsuiteregistry). The registry object creates an `NSScriptClassDescription` for each class it finds and caches these objects in memory. Cocoa scripting uses registry information in handling scripting requests that target the application.
    ///
    /// A class description instance stores the name, attributes, relationships, and supported commands for a class. For example, a scriptable `document` class for a drawing application might support attributes such as `file` and `file type`, relationships such as collections of `circles`, `rectangles`, and `lines`, and commands such as `align` and `rotate`.
    ///
    /// As with many of the classes in Cocoa’s built-in scripting support, your application may never need to directly work with instances of `NSScriptClassDescription`. However, one case where you might need access to a class description is if you override `objectSpecifier` in a scriptable class. For information on how to do this, see [Object Specifiers](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ScriptableCocoaApplications/SApps_object_specifiers/SAppsObjectSpecifiers.html#//apple_ref/doc/uid/TP40002164-CH3) in [Cocoa Scripting Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ScriptableCocoaApplications/SApps_intro/SAppsIntro.html#//apple_ref/doc/uid/TP40002164).
    ///
    /// Another case where your application may need access to class description information is if you override `indicesOfObjectsByEvaluatingWithContainer:count:` in a specifier class.
    ///
    /// Although you can subclass `NSScriptClassDescription`, it is unlikely that you would need to do so, or even to create instances of it.
    ///
    ///
    #[unsafe(super(NSClassDescription, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSClassDescription")]
    pub struct NSScriptClassDescription;
);

#[cfg(feature = "NSClassDescription")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSScriptClassDescription {}
);

#[cfg(feature = "NSClassDescription")]
impl NSScriptClassDescription {
    extern_methods!(
        /// # Safety
        ///
        /// `a_class` probably has further requirements.
        #[unsafe(method(classDescriptionForClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn classDescriptionForClass(
            a_class: &AnyClass,
        ) -> Option<Retained<NSScriptClassDescription>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `class_declaration` generic should be of the correct type.
        #[unsafe(method(initWithSuiteName:className:dictionary:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSuiteName_className_dictionary(
            this: Allocated<Self>,
            suite_name: &NSString,
            class_name: &NSString,
            class_declaration: Option<&NSDictionary>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(suiteName))]
        #[unsafe(method_family = none)]
        pub fn suiteName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(className))]
        #[unsafe(method_family = none)]
        pub fn className(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(implementationClassName))]
        #[unsafe(method_family = none)]
        pub fn implementationClassName(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(superclassDescription))]
        #[unsafe(method_family = none)]
        pub fn superclassDescription(&self) -> Option<Retained<NSScriptClassDescription>>;

        #[unsafe(method(appleEventCode))]
        #[unsafe(method_family = none)]
        pub fn appleEventCode(&self) -> FourCharCode;

        #[unsafe(method(matchesAppleEventCode:))]
        #[unsafe(method_family = none)]
        pub fn matchesAppleEventCode(&self, apple_event_code: FourCharCode) -> bool;

        #[cfg(feature = "NSScriptCommandDescription")]
        #[unsafe(method(supportsCommand:))]
        #[unsafe(method_family = none)]
        pub fn supportsCommand(&self, command_description: &NSScriptCommandDescription) -> bool;

        #[cfg(feature = "NSScriptCommandDescription")]
        #[unsafe(method(selectorForCommand:))]
        #[unsafe(method_family = none)]
        pub fn selectorForCommand(
            &self,
            command_description: &NSScriptCommandDescription,
        ) -> Option<Sel>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(typeForKey:))]
        #[unsafe(method_family = none)]
        pub fn typeForKey(&self, key: &NSString) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(classDescriptionForKey:))]
        #[unsafe(method_family = none)]
        pub fn classDescriptionForKey(
            &self,
            key: &NSString,
        ) -> Option<Retained<NSScriptClassDescription>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(appleEventCodeForKey:))]
        #[unsafe(method_family = none)]
        pub fn appleEventCodeForKey(&self, key: &NSString) -> FourCharCode;

        #[cfg(feature = "NSString")]
        #[unsafe(method(keyWithAppleEventCode:))]
        #[unsafe(method_family = none)]
        pub fn keyWithAppleEventCode(
            &self,
            apple_event_code: FourCharCode,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(defaultSubcontainerAttributeKey))]
        #[unsafe(method_family = none)]
        pub fn defaultSubcontainerAttributeKey(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(isLocationRequiredToCreateForKey:))]
        #[unsafe(method_family = none)]
        pub fn isLocationRequiredToCreateForKey(&self, to_many_relationship_key: &NSString)
            -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(hasPropertyForKey:))]
        #[unsafe(method_family = none)]
        pub fn hasPropertyForKey(&self, key: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(hasOrderedToManyRelationshipForKey:))]
        #[unsafe(method_family = none)]
        pub fn hasOrderedToManyRelationshipForKey(&self, key: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(hasReadablePropertyForKey:))]
        #[unsafe(method_family = none)]
        pub fn hasReadablePropertyForKey(&self, key: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(hasWritablePropertyForKey:))]
        #[unsafe(method_family = none)]
        pub fn hasWritablePropertyForKey(&self, key: &NSString) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSClassDescription")]
impl NSScriptClassDescription {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

#[cfg(feature = "NSClassDescription")]
impl DefaultRetained for NSScriptClassDescription {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSDeprecated.
#[cfg(feature = "NSClassDescription")]
impl NSScriptClassDescription {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[deprecated]
        #[unsafe(method(isReadOnlyKey:))]
        #[unsafe(method_family = none)]
        pub fn isReadOnlyKey(&self, key: &NSString) -> bool;
    );
}

mod private_NSObjectNSScriptClassDescription {
    pub trait Sealed {}
}

/// Category "NSScriptClassDescription" on [`NSObject`].
#[doc(alias = "NSScriptClassDescription")]
pub unsafe trait NSObjectNSScriptClassDescription:
    ClassType + Sized + private_NSObjectNSScriptClassDescription::Sealed
{
    extern_methods!(
        #[unsafe(method(classCode))]
        #[unsafe(method_family = none)]
        fn classCode(&self) -> FourCharCode;

        #[cfg(feature = "NSString")]
        #[unsafe(method(className))]
        #[unsafe(method_family = none)]
        fn className(&self) -> Retained<NSString>;
    );
}

impl private_NSObjectNSScriptClassDescription::Sealed for NSObject {}
unsafe impl NSObjectNSScriptClassDescription for NSObject {}
