//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// The values that can be returned in a change dictionary.
///
/// ## Overview
///
/// These constants are passed to [`addObserver:forKeyPath:options:context:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/addobserver(_:forkeypath:options:context:)) and determine the values that are returned as part of the change dictionary passed to an [`observeValueForKeyPath:ofObject:change:context:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/observevalue(forkeypath:of:change:context:)). You can pass `0` if you require no change dictionary values.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSKeyValueObservingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSKeyValueObservingOptions: NSUInteger {
/// Indicates that the change dictionary should provide the new attribute value, if applicable.
        #[doc(alias = "NSKeyValueObservingOptionNew")]
        const New = 0x01;
/// Indicates that the change dictionary should contain the old attribute value, if applicable.
        #[doc(alias = "NSKeyValueObservingOptionOld")]
        const Old = 0x02;
/// If specified, a notification should be sent to the observer immediately, before the observer registration method even returns.
///
/// ## Discussion
///
/// The change dictionary in the notification will always contain an [`NSKeyValueChangeNewKey`](https://developer.apple.com/documentation/foundation/nskeyvaluechangekey/newkey) entry if [`NSKeyValueObservingOptionNew`](https://developer.apple.com/documentation/foundation/nskeyvalueobservingoptions/new) is also specified but will never contain an [`NSKeyValueChangeOldKey`](https://developer.apple.com/documentation/foundation/nskeyvaluechangekey/oldkey) entry. (In an initial notification the current value of the observed property may be old, but it’s new to the observer.) You can use this option instead of explicitly invoking, at the same time, code that is also invoked by the observer’s [`observeValueForKeyPath:ofObject:change:context:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/observevalue(forkeypath:of:change:context:)) method. When this option is used with[`addObserver:forKeyPath:options:context:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/addobserver(_:forkeypath:options:context:)) a notification will be sent for each indexed object to which the observer is being added.
///
///
        #[doc(alias = "NSKeyValueObservingOptionInitial")]
        const Initial = 0x04;
/// Whether separate notifications should be sent to the observer before and after each change, instead of a single notification after the change.
///
/// ## Discussion
///
/// The change dictionary in a notification sent before a change always contains an [`NSKeyValueChangeNotificationIsPriorKey`](https://developer.apple.com/documentation/foundation/nskeyvaluechangekey/notificationispriorkey) entry whose value is an `NSNumber` object that contains the Boolean value [`true`](https://developer.apple.com/documentation/swift/true), but never contains an [`NSKeyValueChangeNewKey`](https://developer.apple.com/documentation/foundation/nskeyvaluechangekey/newkey) entry. When this option is specified the change dictionary in a notification sent after a change contains the same entries that it would contain if this option were not specified. You can use this option when the observer’s own key-value observing-compliance requires it to invoke one of the `-willChange...` methods for one of its own properties, and the value of that property depends on the value of the observed object’s property. (In that situation it’s too late to easily invoke `-willChange...` properly in response to receiving an [`observeValueForKeyPath:ofObject:change:context:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/observevalue(forkeypath:of:change:context:)) message after the change.)
///
///
        #[doc(alias = "NSKeyValueObservingOptionPrior")]
        const Prior = 0x08;
    }
}

unsafe impl Encode for NSKeyValueObservingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSKeyValueObservingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The kinds of changes that can be observed.
///
/// ## Overview
///
/// These constants are returned as the value for a [`NSKeyValueChangeKindKey`](https://developer.apple.com/documentation/foundation/nskeyvaluechangekey/kindkey) key in the change dictionary passed to [`observeValueForKeyPath:ofObject:change:context:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/observevalue(forkeypath:of:change:context:)) indicating the type of change made.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSKeyValueChange(pub NSUInteger);
impl NSKeyValueChange {
    /// Indicates that the value of the observed key path was set to a new value. This change can occur when observing an attribute of an object, as well as properties that specify to-one and to-many relationships.
    #[doc(alias = "NSKeyValueChangeSetting")]
    pub const Setting: Self = Self(1);
    /// Indicates that an object has been inserted into the to-many relationship that is being observed.
    #[doc(alias = "NSKeyValueChangeInsertion")]
    pub const Insertion: Self = Self(2);
    /// Indicates that an object has been removed from the to-many relationship that is being observed.
    #[doc(alias = "NSKeyValueChangeRemoval")]
    pub const Removal: Self = Self(3);
    /// Indicates that an object has been replaced in the to-many relationship that is being observed.
    #[doc(alias = "NSKeyValueChangeReplacement")]
    pub const Replacement: Self = Self(4);
}

unsafe impl Encode for NSKeyValueChange {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSKeyValueChange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSKeyValueSetMutationKind(pub NSUInteger);
impl NSKeyValueSetMutationKind {
    #[doc(alias = "NSKeyValueUnionSetMutation")]
    pub const UnionSetMutation: Self = Self(1);
    #[doc(alias = "NSKeyValueMinusSetMutation")]
    pub const MinusSetMutation: Self = Self(2);
    #[doc(alias = "NSKeyValueIntersectSetMutation")]
    pub const IntersectSetMutation: Self = Self(3);
    #[doc(alias = "NSKeyValueSetSetMutation")]
    pub const SetSetMutation: Self = Self(4);
}

unsafe impl Encode for NSKeyValueSetMutationKind {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSKeyValueSetMutationKind {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The keys that can appear in the change dictionary.
///
/// ## Discussion
///
/// These constants are used as keys in the change dictionary passed to [`observeValueForKeyPath:ofObject:change:context:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/observevalue(forkeypath:of:change:context:)).
///
///
// NS_TYPED_ENUM
#[cfg(feature = "NSString")]
pub type NSKeyValueChangeKey = NSString;

extern "C" {
    /// An `NSNumber` object that contains a value corresponding to one of the [`NSKeyValueChange`](https://developer.apple.com/documentation/foundation/nskeyvaluechange) enums, indicating what sort of change has occurred.
    ///
    /// ## Discussion
    ///
    /// A value of [`NSKeyValueChangeSetting`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/setting) indicates that the observed object has received a [`setValue:forKey:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/setvalue(_:forkey:)) message, or that the key-value-coding-compliant set method for the key has been invoked, or that one of the [`willChangeValueForKey:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/willchangevalue(forkey:)) or [`didChangeValueForKey:`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/didchangevalue(forkey:)) methods has otherwise been invoked.
    ///
    /// A value of [`NSKeyValueChangeInsertion`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/insertion), [`NSKeyValueChangeRemoval`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/removal), or [`NSKeyValueChangeReplacement`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/replacement) indicates that mutating messages have been sent a key-value observing compliant collection proxy, or that one of the key-value-coding-compliant collection mutation methods for the key has been invoked, or a collection will change or did change method has been otherwise been invoked.
    ///
    /// You can use the [`unsignedIntegerValue`](https://developer.apple.com/documentation/foundation/nsnumber/uintvalue) method on the `NSNumber` object to retrieve the value of the change kind.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSKeyValueChangeKindKey: &'static NSKeyValueChangeKey;
}

extern "C" {
    /// If the value of the [`NSKeyValueChangeKindKey`](https://developer.apple.com/documentation/foundation/nskeyvaluechangekey/kindkey) entry is [`NSKeyValueChangeSetting`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/setting), and [`NSKeyValueObservingOptionNew`](https://developer.apple.com/documentation/foundation/nskeyvalueobservingoptions/new) was specified when the observer was registered, the value of this key is the new value for the attribute.
    ///
    /// ## Discussion
    ///
    /// For [`NSKeyValueChangeInsertion`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/insertion) or [`NSKeyValueChangeReplacement`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/replacement), if [`NSKeyValueObservingOptionNew`](https://developer.apple.com/documentation/foundation/nskeyvalueobservingoptions/new) was specified when the observer was registered, the value for this key is an `NSArray` instance that contains the objects that have been inserted or replaced other objects, respectively.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSKeyValueChangeNewKey: &'static NSKeyValueChangeKey;
}

extern "C" {
    /// If the value of the [`NSKeyValueChangeKindKey`](https://developer.apple.com/documentation/foundation/nskeyvaluechangekey/kindkey) entry is [`NSKeyValueChangeSetting`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/setting), and [`NSKeyValueObservingOptionOld`](https://developer.apple.com/documentation/foundation/nskeyvalueobservingoptions/old) was specified when the observer was registered, the value of this key is the value before the attribute was changed.
    ///
    /// ## Discussion
    ///
    /// For [`NSKeyValueChangeRemoval`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/removal) or [`NSKeyValueChangeReplacement`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/replacement), if [`NSKeyValueObservingOptionOld`](https://developer.apple.com/documentation/foundation/nskeyvalueobservingoptions/old) was specified when the observer was registered, the value is an `NSArray` instance that contains the objects that have been removed or have been replaced by other objects, respectively.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSKeyValueChangeOldKey: &'static NSKeyValueChangeKey;
}

extern "C" {
    /// If the value of the [`NSKeyValueChangeKindKey`](https://developer.apple.com/documentation/foundation/nskeyvaluechangekey/kindkey) entry is [`NSKeyValueChangeInsertion`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/insertion), [`NSKeyValueChangeRemoval`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/removal), or [`NSKeyValueChangeReplacement`](https://developer.apple.com/documentation/foundation/nskeyvaluechange/replacement), the value of this key is an `NSIndexSet` object that contains the indexes of the inserted, removed, or replaced objects.
    #[cfg(feature = "NSString")]
    pub static NSKeyValueChangeIndexesKey: &'static NSKeyValueChangeKey;
}

extern "C" {
    /// If the [`NSKeyValueObservingOptionPrior`](https://developer.apple.com/documentation/foundation/nskeyvalueobservingoptions/prior) option was specified when the observer was registered this notification is sent prior to a change.
    ///
    /// ## Discussion
    ///
    /// The change dictionary contains an [`NSKeyValueChangeNotificationIsPriorKey`](https://developer.apple.com/documentation/foundation/nskeyvaluechangekey/notificationispriorkey) entry whose value is an `NSNumber` object that contains the Boolean value [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSKeyValueChangeNotificationIsPriorKey: &'static NSKeyValueChangeKey;
}

mod private_NSObjectNSKeyValueObserving {
    pub trait Sealed {}
}

/// Category "NSKeyValueObserving" on [`NSObject`].
#[doc(alias = "NSKeyValueObserving")]
pub unsafe trait NSObjectNSKeyValueObserving:
    ClassType + Sized + private_NSObjectNSKeyValueObserving::Sealed
{
    extern_methods!(
        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `change` generic should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(observeValueForKeyPath:ofObject:change:context:))]
        #[unsafe(method_family = none)]
        unsafe fn observeValueForKeyPath_ofObject_change_context(
            &self,
            key_path: Option<&NSString>,
            object: Option<&AnyObject>,
            change: Option<&NSDictionary<NSKeyValueChangeKey, AnyObject>>,
            context: *mut c_void,
        );
    );
}

impl private_NSObjectNSKeyValueObserving::Sealed for NSObject {}
unsafe impl NSObjectNSKeyValueObserving for NSObject {}

mod private_NSObjectNSKeyValueObserverRegistration {
    pub trait Sealed {}
}

/// Category "NSKeyValueObserverRegistration" on [`NSObject`].
#[doc(alias = "NSKeyValueObserverRegistration")]
pub unsafe trait NSObjectNSKeyValueObserverRegistration:
    ClassType + Sized + private_NSObjectNSKeyValueObserverRegistration::Sealed
{
    extern_methods!(
        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(addObserver:forKeyPath:options:context:))]
        #[unsafe(method_family = none)]
        unsafe fn addObserver_forKeyPath_options_context(
            &self,
            observer: &NSObject,
            key_path: &NSString,
            options: NSKeyValueObservingOptions,
            context: *mut c_void,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(removeObserver:forKeyPath:context:))]
        #[unsafe(method_family = none)]
        unsafe fn removeObserver_forKeyPath_context(
            &self,
            observer: &NSObject,
            key_path: &NSString,
            context: *mut c_void,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `observer` should be of the correct type.
        #[unsafe(method(removeObserver:forKeyPath:))]
        #[unsafe(method_family = none)]
        unsafe fn removeObserver_forKeyPath(&self, observer: &NSObject, key_path: &NSString);
    );
}

impl private_NSObjectNSKeyValueObserverRegistration::Sealed for NSObject {}
unsafe impl NSObjectNSKeyValueObserverRegistration for NSObject {}

/// NSKeyValueObserverRegistration.
#[cfg(feature = "NSArray")]
impl<ObjectType: Message> NSArray<ObjectType> {
    extern_methods!(
        #[cfg(all(feature = "NSIndexSet", feature = "NSString"))]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(addObserver:toObjectsAtIndexes:forKeyPath:options:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addObserver_toObjectsAtIndexes_forKeyPath_options_context(
            &self,
            observer: &NSObject,
            indexes: &NSIndexSet,
            key_path: &NSString,
            options: NSKeyValueObservingOptions,
            context: *mut c_void,
        );

        #[cfg(all(feature = "NSIndexSet", feature = "NSString"))]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(removeObserver:fromObjectsAtIndexes:forKeyPath:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObserver_fromObjectsAtIndexes_forKeyPath_context(
            &self,
            observer: &NSObject,
            indexes: &NSIndexSet,
            key_path: &NSString,
            context: *mut c_void,
        );

        #[cfg(all(feature = "NSIndexSet", feature = "NSString"))]
        /// # Safety
        ///
        /// `observer` should be of the correct type.
        #[unsafe(method(removeObserver:fromObjectsAtIndexes:forKeyPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObserver_fromObjectsAtIndexes_forKeyPath(
            &self,
            observer: &NSObject,
            indexes: &NSIndexSet,
            key_path: &NSString,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(addObserver:forKeyPath:options:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addObserver_forKeyPath_options_context(
            &self,
            observer: &NSObject,
            key_path: &NSString,
            options: NSKeyValueObservingOptions,
            context: *mut c_void,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(removeObserver:forKeyPath:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObserver_forKeyPath_context(
            &self,
            observer: &NSObject,
            key_path: &NSString,
            context: *mut c_void,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `observer` should be of the correct type.
        #[unsafe(method(removeObserver:forKeyPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObserver_forKeyPath(&self, observer: &NSObject, key_path: &NSString);
    );
}

/// NSKeyValueObserverRegistration.
#[cfg(feature = "NSOrderedSet")]
impl<ObjectType: Message> NSOrderedSet<ObjectType> {
    extern_methods!(
        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(addObserver:forKeyPath:options:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addObserver_forKeyPath_options_context(
            &self,
            observer: &NSObject,
            key_path: &NSString,
            options: NSKeyValueObservingOptions,
            context: *mut c_void,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(removeObserver:forKeyPath:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObserver_forKeyPath_context(
            &self,
            observer: &NSObject,
            key_path: &NSString,
            context: *mut c_void,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `observer` should be of the correct type.
        #[unsafe(method(removeObserver:forKeyPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObserver_forKeyPath(&self, observer: &NSObject, key_path: &NSString);
    );
}

/// NSKeyValueObserverRegistration.
#[cfg(feature = "NSSet")]
impl<ObjectType: Message> NSSet<ObjectType> {
    extern_methods!(
        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(addObserver:forKeyPath:options:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addObserver_forKeyPath_options_context(
            &self,
            observer: &NSObject,
            key_path: &NSString,
            options: NSKeyValueObservingOptions,
            context: *mut c_void,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(removeObserver:forKeyPath:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObserver_forKeyPath_context(
            &self,
            observer: &NSObject,
            key_path: &NSString,
            context: *mut c_void,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `observer` should be of the correct type.
        #[unsafe(method(removeObserver:forKeyPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObserver_forKeyPath(&self, observer: &NSObject, key_path: &NSString);
    );
}

mod private_NSObjectNSKeyValueObserverNotification {
    pub trait Sealed {}
}

/// Category "NSKeyValueObserverNotification" on [`NSObject`].
#[doc(alias = "NSKeyValueObserverNotification")]
pub unsafe trait NSObjectNSKeyValueObserverNotification:
    ClassType + Sized + private_NSObjectNSKeyValueObserverNotification::Sealed
{
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(willChangeValueForKey:))]
        #[unsafe(method_family = none)]
        fn willChangeValueForKey(&self, key: &NSString);

        #[cfg(feature = "NSString")]
        #[unsafe(method(didChangeValueForKey:))]
        #[unsafe(method_family = none)]
        fn didChangeValueForKey(&self, key: &NSString);

        #[cfg(all(feature = "NSIndexSet", feature = "NSString"))]
        #[unsafe(method(willChange:valuesAtIndexes:forKey:))]
        #[unsafe(method_family = none)]
        fn willChange_valuesAtIndexes_forKey(
            &self,
            change_kind: NSKeyValueChange,
            indexes: &NSIndexSet,
            key: &NSString,
        );

        #[cfg(all(feature = "NSIndexSet", feature = "NSString"))]
        #[unsafe(method(didChange:valuesAtIndexes:forKey:))]
        #[unsafe(method_family = none)]
        fn didChange_valuesAtIndexes_forKey(
            &self,
            change_kind: NSKeyValueChange,
            indexes: &NSIndexSet,
            key: &NSString,
        );

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        /// # Safety
        ///
        /// `objects` generic should be of the correct type.
        #[unsafe(method(willChangeValueForKey:withSetMutation:usingObjects:))]
        #[unsafe(method_family = none)]
        unsafe fn willChangeValueForKey_withSetMutation_usingObjects(
            &self,
            key: &NSString,
            mutation_kind: NSKeyValueSetMutationKind,
            objects: &NSSet,
        );

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        /// # Safety
        ///
        /// `objects` generic should be of the correct type.
        #[unsafe(method(didChangeValueForKey:withSetMutation:usingObjects:))]
        #[unsafe(method_family = none)]
        unsafe fn didChangeValueForKey_withSetMutation_usingObjects(
            &self,
            key: &NSString,
            mutation_kind: NSKeyValueSetMutationKind,
            objects: &NSSet,
        );
    );
}

impl private_NSObjectNSKeyValueObserverNotification::Sealed for NSObject {}
unsafe impl NSObjectNSKeyValueObserverNotification for NSObject {}

mod private_NSObjectNSKeyValueObservingCustomization {
    pub trait Sealed {}
}

/// Category "NSKeyValueObservingCustomization" on [`NSObject`].
#[doc(alias = "NSKeyValueObservingCustomization")]
pub unsafe trait NSObjectNSKeyValueObservingCustomization:
    ClassType + Sized + private_NSObjectNSKeyValueObservingCustomization::Sealed
{
    extern_methods!(
        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[unsafe(method(keyPathsForValuesAffectingValueForKey:))]
        #[unsafe(method_family = none)]
        fn keyPathsForValuesAffectingValueForKey(key: &NSString) -> Retained<NSSet<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(automaticallyNotifiesObserversForKey:))]
        #[unsafe(method_family = none)]
        fn automaticallyNotifiesObserversForKey(key: &NSString) -> bool;

        #[unsafe(method(observationInfo))]
        #[unsafe(method_family = none)]
        fn observationInfo(&self) -> *mut c_void;

        /// Setter for [`observationInfo`][Self::observationInfo].
        ///
        /// # Safety
        ///
        /// `observation_info` must be a valid pointer or null.
        #[unsafe(method(setObservationInfo:))]
        #[unsafe(method_family = none)]
        unsafe fn setObservationInfo(&self, observation_info: *mut c_void);
    );
}

impl private_NSObjectNSKeyValueObservingCustomization::Sealed for NSObject {}
unsafe impl NSObjectNSKeyValueObservingCustomization for NSObject {}
