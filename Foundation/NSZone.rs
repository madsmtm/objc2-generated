//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Returns the default zone.
///
/// ## Return Value
///
/// The default zone, which is created automatically at startup.
///
///
///
/// ## Discussion
///
/// This zone is used by the standard C function `malloc`.
///
///
#[inline]
pub extern "C-unwind" fn NSDefaultMallocZone() -> NonNull<NSZone> {
    extern "C-unwind" {
        fn NSDefaultMallocZone() -> Option<NonNull<NSZone>>;
    }
    let ret = unsafe { NSDefaultMallocZone() };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Creates a new zone.
///
/// ## Return Value
///
/// A pointer to a new zone of `startSize` bytes, which will grow and shrink by `granularity` bytes. If `canFree` is 0, the allocator will never free memory, and `malloc` will be fast. Returns `NULL` if a new zone could not be created.
///
///
#[inline]
pub extern "C-unwind" fn NSCreateZone(
    start_size: NSUInteger,
    granularity: NSUInteger,
    can_free: bool,
) -> NonNull<NSZone> {
    extern "C-unwind" {
        fn NSCreateZone(
            start_size: NSUInteger,
            granularity: NSUInteger,
            can_free: Bool,
        ) -> Option<NonNull<NSZone>>;
    }
    let ret = unsafe { NSCreateZone(start_size, granularity, Bool::new(can_free)) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Frees memory in a zone.
    ///
    /// ## Discussion
    ///
    /// Frees `zone` after adding any of its pointers still in use to the default zone. (This strategy prevents retained objects from being inadvertently destroyed.)
    ///
    ///
    ///
    /// # Safety
    ///
    /// `zone` must be a valid pointer.
    pub fn NSRecycleZone(zone: NonNull<NSZone>);
}

extern "C-unwind" {
    /// Sets the name of the specified zone.
    ///
    /// ## Discussion
    ///
    /// Sets the name of `zone` to `name`, which can aid in debugging.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `zone` must be a valid pointer or null.
    #[cfg(feature = "NSString")]
    pub fn NSSetZoneName(zone: *mut NSZone, name: &NSString);
}

/// Returns the name of the specified zone.
///
/// ## Return Value
///
/// A string containing the name associated with `zone`. If `zone` is `nil`, the default zone is used. If no name is associated with `zone`, the returned string is empty.
///
///
///
/// # Safety
///
/// `zone` must be a valid pointer or null.
#[cfg(feature = "NSString")]
#[inline]
pub unsafe extern "C-unwind" fn NSZoneName(zone: *mut NSZone) -> Retained<NSString> {
    extern "C-unwind" {
        fn NSZoneName(zone: *mut NSZone) -> *mut NSString;
    }
    let ret = unsafe { NSZoneName(zone) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Gets the zone for a given block of memory.
    ///
    /// ## Return Value
    ///
    /// The zone for the block of memory indicated by `pointer`, or `NULL` if the block was not allocated from a zone.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// `pointer` must be one that was returned by a prior call to an allocation function.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `ptr` must be a valid pointer.
    pub fn NSZoneFromPointer(ptr: NonNull<c_void>) -> *mut NSZone;
}

/// Allocates memory in a zone.
///
/// ## Discussion
///
/// Allocates `size` bytes in `zone` and returns a pointer to the allocated memory. This function returns `NULL` if it was unable to allocate the requested memory.
///
///
///
/// # Safety
///
/// `zone` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn NSZoneMalloc(
    zone: *mut NSZone,
    size: NSUInteger,
) -> NonNull<c_void> {
    extern "C-unwind" {
        fn NSZoneMalloc(zone: *mut NSZone, size: NSUInteger) -> Option<NonNull<c_void>>;
    }
    let ret = unsafe { NSZoneMalloc(zone, size) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Allocates memory in a zone.
///
/// ## Discussion
///
/// Allocates enough memory from `zone` for `numElems` elements, each with a size `numBytes` bytes, and returns a pointer to the allocated memory. The memory is initialized with zeros. This function returns `NULL` if it was unable to allocate the requested memory.
///
///
///
/// # Safety
///
/// `zone` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn NSZoneCalloc(
    zone: *mut NSZone,
    num_elems: NSUInteger,
    byte_size: NSUInteger,
) -> NonNull<c_void> {
    extern "C-unwind" {
        fn NSZoneCalloc(
            zone: *mut NSZone,
            num_elems: NSUInteger,
            byte_size: NSUInteger,
        ) -> Option<NonNull<c_void>>;
    }
    let ret = unsafe { NSZoneCalloc(zone, num_elems, byte_size) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Allocates memory in a zone.
///
/// ## Discussion
///
/// Changes the size of the block of memory pointed to by `ptr` to `size` bytes. It may allocate new memory to replace the old, in which case it moves the contents of the old memory block to the new block, up to a maximum of `size` bytes. `ptr` may be `NULL`. This function returns `NULL` if it was unable to allocate the requested memory.
///
///
///
/// # Safety
///
/// - `zone` must be a valid pointer or null.
/// - `ptr` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn NSZoneRealloc(
    zone: *mut NSZone,
    ptr: *mut c_void,
    size: NSUInteger,
) -> NonNull<c_void> {
    extern "C-unwind" {
        fn NSZoneRealloc(
            zone: *mut NSZone,
            ptr: *mut c_void,
            size: NSUInteger,
        ) -> Option<NonNull<c_void>>;
    }
    let ret = unsafe { NSZoneRealloc(zone, ptr, size) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Deallocates a block of memory in the specified zone.
    ///
    /// ## Discussion
    ///
    /// Returns memory to the `zone` from which it was allocated. The standard C function `free` does the same, but spends time finding which zone the memory belongs to.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `zone` must be a valid pointer or null.
    /// - `ptr` must be a valid pointer.
    pub fn NSZoneFree(zone: *mut NSZone, ptr: NonNull<c_void>);
}

/// Specifies allocation of scanned memory.
pub const NSScannedOption: NSUInteger = 1 << 0;
/// Specifies that the block is retained, and therefore ineligible for collection. Specifying this option is equivalent to invoking [`disableCollectorForPointer:`](https://developer.apple.com/documentation/foundation/nsgarbagecollector/disablecollectorforpointer:) with the returned block as the argument.
pub const NSCollectorDisabledOption: NSUInteger = 1 << 1;

/// Allocates collectable memory.
///
/// Parameters:
/// - size: The number of bytes of memory to allocate.
///
/// - options: `0` or `NSScannedOption`: A value of `0` allocates non-scanned memory; a value of `NSScannedOption` allocates scanned memory.
///
///
/// ## Return Value
///
/// A pointer to the allocated memory, or `NULL` if the function is unable to allocate the requested memory.
///
///
#[inline]
pub extern "C-unwind" fn NSAllocateCollectable(
    size: NSUInteger,
    options: NSUInteger,
) -> NonNull<c_void> {
    extern "C-unwind" {
        fn NSAllocateCollectable(size: NSUInteger, options: NSUInteger) -> Option<NonNull<c_void>>;
    }
    let ret = unsafe { NSAllocateCollectable(size, options) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Reallocates collectable memory.
///
/// ## Discussion
///
/// Changes the size of the block of memory pointed to by `ptr` to `size` bytes. It may allocate new memory to replace the old, in which case it moves the contents of the old memory block to the new block, up to a maximum of `size` bytes.
///
/// `options` can be `0` or `NSScannedOption`: A value of `0` allocates non-scanned memory; a value of `NSScannedOption` allocates scanned memory.
///
/// This function returns `NULL` if it’s unable to allocate the requested memory.
///
///
///
/// # Safety
///
/// `ptr` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn NSReallocateCollectable(
    ptr: *mut c_void,
    size: NSUInteger,
    options: NSUInteger,
) -> NonNull<c_void> {
    extern "C-unwind" {
        fn NSReallocateCollectable(
            ptr: *mut c_void,
            size: NSUInteger,
            options: NSUInteger,
        ) -> Option<NonNull<c_void>>;
    }
    let ret = unsafe { NSReallocateCollectable(ptr, size, options) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

/// Returns the number of bytes in a page.
///
/// ## Return Value
///
/// The number of bytes in a page.
///
///
#[inline]
pub extern "C-unwind" fn NSPageSize() -> NSUInteger {
    extern "C-unwind" {
        fn NSPageSize() -> NSUInteger;
    }
    unsafe { NSPageSize() }
}

/// Returns the binary log of the page size.
///
/// ## Return Value
///
/// The binary log of the page size.
///
///
#[inline]
pub extern "C-unwind" fn NSLogPageSize() -> NSUInteger {
    extern "C-unwind" {
        fn NSLogPageSize() -> NSUInteger;
    }
    unsafe { NSLogPageSize() }
}

/// Returns the specified number of bytes rounded up to a multiple of the page size.
///
/// ## Return Value
///
/// In bytes, the multiple of the page size that is closest to, but not less than, `byteCount` (that is, the number of bytes rounded up to a multiple of the page size).
///
///
#[inline]
pub extern "C-unwind" fn NSRoundUpToMultipleOfPageSize(bytes: NSUInteger) -> NSUInteger {
    extern "C-unwind" {
        fn NSRoundUpToMultipleOfPageSize(bytes: NSUInteger) -> NSUInteger;
    }
    unsafe { NSRoundUpToMultipleOfPageSize(bytes) }
}

/// Returns the specified number of bytes rounded down to a multiple of the page size.
///
/// ## Return Value
///
/// In bytes, the multiple of the page size that is closest to, but not greater than, `byteCount` (that is, the number of bytes rounded down to a multiple of the page size).
///
///
#[inline]
pub extern "C-unwind" fn NSRoundDownToMultipleOfPageSize(bytes: NSUInteger) -> NSUInteger {
    extern "C-unwind" {
        fn NSRoundDownToMultipleOfPageSize(bytes: NSUInteger) -> NSUInteger;
    }
    unsafe { NSRoundDownToMultipleOfPageSize(bytes) }
}

/// Allocates a new block of memory.
///
/// ## Discussion
///
/// Allocates the integral number of pages whose total size is closest to, but not less than, `byteCount`. The allocated pages are guaranteed to be filled with zeros. If the allocation fails, raises `NSInvalidArgumentException`.
///
///
#[inline]
pub extern "C-unwind" fn NSAllocateMemoryPages(bytes: NSUInteger) -> NonNull<c_void> {
    extern "C-unwind" {
        fn NSAllocateMemoryPages(bytes: NSUInteger) -> Option<NonNull<c_void>>;
    }
    let ret = unsafe { NSAllocateMemoryPages(bytes) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Deallocates the specified block of memory.
    ///
    /// ## Discussion
    ///
    /// This function deallocates memory that was allocated with `NSAllocateMemoryPages`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `ptr` must be a valid pointer.
    pub fn NSDeallocateMemoryPages(ptr: NonNull<c_void>, bytes: NSUInteger);
}

extern "C-unwind" {
    /// Copies a block of memory.
    ///
    /// ## Discussion
    ///
    /// Copies (or copies on write) `byteCount` bytes from `source` to `destination`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `source` must be a valid pointer.
    /// - `dest` must be a valid pointer.
    pub fn NSCopyMemoryPages(source: NonNull<c_void>, dest: NonNull<c_void>, bytes: NSUInteger);
}

/// Returns information about the user’s system.
///
/// ## Return Value
///
/// The number of bytes available in RAM.
///
///
#[deprecated = "Use NSProcessInfo instead"]
#[inline]
pub extern "C-unwind" fn NSRealMemoryAvailable() -> NSUInteger {
    extern "C-unwind" {
        fn NSRealMemoryAvailable() -> NSUInteger;
    }
    unsafe { NSRealMemoryAvailable() }
}
