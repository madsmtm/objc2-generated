//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// An object that represents the kind of progress.
///
/// ## Discussion
///
/// When tracking file operations with the progress [`kind`](https://developer.apple.com/documentation/foundation/progress/kind) set to [`NSProgressKindFile`](https://developer.apple.com/documentation/foundation/progresskind/file), provide a value for the [`NSProgressFileOperationKindKey`](https://developer.apple.com/documentation/foundation/progressuserinfokey/fileoperationkindkey) in the user info dictionary.
///
/// To specify the kind of file operation, provide one of the following values:
///
/// - [`NSProgressFileOperationKindCopying`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/copying)
///
/// - [`NSProgressFileOperationKindDecompressingAfterDownloading`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/decompressingafterdownloading)
///
/// - [`NSProgressFileOperationKindDownloading`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/downloading)
///
/// - [`NSProgressFileOperationKindUploading`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/uploading)
///
/// - [`NSProgressFileOperationKindReceiving`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/receiving)
///
///
// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSProgressKind = NSString;

/// Keys for the user info dictionary that affect the autogenerated localized additional description string.
///
/// ## Discussion
///
/// Enhance the autogenerated description that [`localizedAdditionalDescription`](https://developer.apple.com/documentation/foundation/progress/localizedadditionaldescription) provides by including keys and related values in the user info dictionary. For example, if you provide the keys [`NSProgressFileCompletedCountKey`](https://developer.apple.com/documentation/foundation/progressuserinfokey/filecompletedcountkey) and [`NSProgressFileTotalCountKey`](https://developer.apple.com/documentation/foundation/progressuserinfokey/filetotalcountkey), the [`localizedAdditionalDescription`](https://developer.apple.com/documentation/foundation/progress/localizedadditionaldescription) method uses the values from those keys to provide strings showing the number of completed and total files.
///
///
// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSProgressUserInfoKey = NSString;

/// The kind of file operation.
///
/// ## Discussion
///
/// When tracking file operations with the progress [`kind`](https://developer.apple.com/documentation/foundation/progress/kind) set to [`NSProgressKindFile`](https://developer.apple.com/documentation/foundation/progresskind/file), provide a value for the [`NSProgressFileOperationKindKey`](https://developer.apple.com/documentation/foundation/progressuserinfokey/fileoperationkindkey) in the user info dictionary.
///
/// To specify the kind of file operation, provide one of the following values:
///
/// - [`NSProgressFileOperationKindCopying`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/copying)
///
/// - [`NSProgressFileOperationKindDecompressingAfterDownloading`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/decompressingafterdownloading)
///
/// - [`NSProgressFileOperationKindDownloading`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/downloading)
///
/// - [`NSProgressFileOperationKindUploading`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/uploading)
///
/// - [`NSProgressFileOperationKindReceiving`](https://developer.apple.com/documentation/foundation/progress/fileoperationkind-swift.struct/receiving)
///
///
// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSProgressFileOperationKind = NSString;

/// A block that the system calls when an observed progress object terminates the subscription.
#[cfg(feature = "block2")]
pub type NSProgressUnpublishingHandler = *mut block2::DynBlock<dyn Fn()>;

/// A block that the system calls when an observed progress object matches the subscription.
///
/// Parameters:
/// - progress: The proxy to the observed progress object.
///
///
/// ## Return Value
///
/// An optional block that the system invokes when the observed progress object invokes [`unpublish`](https://developer.apple.com/documentation/foundation/progress/unpublish()), the publishing process terminates, or you invoke [`removeSubscriber:`](https://developer.apple.com/documentation/foundation/progress/removesubscriber(_:)).
///
///
#[cfg(feature = "block2")]
pub type NSProgressPublishingHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<NSProgress>) -> NSProgressUnpublishingHandler>;

extern_class!(
    /// An object that conveys ongoing progress to the user for a specified task.
    ///
    /// ## Overview
    ///
    /// The [`NSProgress`](https://developer.apple.com/documentation/foundation/progress) class provides a self-contained mechanism for progress reporting. It makes it easy for code that performs work to report the progress of that work, and for user interface code to observe that progress for presentation to the user. Specifically, you can use a progress object to show the user a progress bar and explanatory text that update as you do work. It also allows the user to cancel or pause work.
    ///
    /// ### Reporting Progress
    ///
    /// Using the methods of this class, your code can report the progress it’s currently making toward completing a task, including progress in related subtasks. You can create instances of this class using the [`initWithParent:userInfo:`](https://developer.apple.com/documentation/foundation/progress/init(parent:userinfo:)) instance method or the [`progressWithTotalUnitCount:`](https://developer.apple.com/documentation/foundation/progress/init(totalunitcount:)) class method.
    ///
    /// Progress objects have many properties that you can use to observe and report current progress. For instance, the [`totalUnitCount`](https://developer.apple.com/documentation/foundation/progress/totalunitcount) property represents the total number of units of work, and the [`completedUnitCount`](https://developer.apple.com/documentation/foundation/progress/completedunitcount) and [`fractionCompleted`](https://developer.apple.com/documentation/foundation/progress/fractioncompleted) properties represent how much of that work is complete. The [`fractionCompleted`](https://developer.apple.com/documentation/foundation/progress/fractioncompleted) property is useful for updating progress indicators or textual descriptors. To check whether progress is complete, test the [`finished`](https://developer.apple.com/documentation/foundation/progress/isfinished) property.
    ///
    /// The following code shows a sample method that reports the progress of performing an operation on a piece of data. When creating the progress object, you set the value of its [`totalUnitCount`](https://developer.apple.com/documentation/foundation/progress/totalunitcount) property to a suitable batch size for the operation, and the [`completedUnitCount`](https://developer.apple.com/documentation/foundation/progress/completedunitcount) count is `0`. Each time the loop executes and processes a batch of data, you increment the progress object’s [`completedUnitCount`](https://developer.apple.com/documentation/foundation/progress/completedunitcount) property appropriately.
    ///
    /// ```objc
    /// - (void)startTaskWithData:(NSData *)data {
    ///     NSUInteger batchSize = ... use a suitable batch size
    ///     NSProgress *progress = [NSProgress progressWithTotalUnitCount:batchSize];
    ///  
    ///     for (NSUInteger index = 0; index < batchSize; index++) {
    ///         // Check for cancellation.
    ///         if ([progress isCancelled]) {
    ///              // Tidy up as necessary.
    ///              break;
    ///         }
    ///  
    ///         // Do something with this batch of data.
    ///  
    ///         // Report progress (add 1 because the work is complete for the current index).
    ///         [progress setCompletedUnitCount:(index + 1)];
    ///     }
    /// }
    /// ```
    ///
    /// Each of the properties of a progress object, including [`totalUnitCount`](https://developer.apple.com/documentation/foundation/progress/totalunitcount), [`completedUnitCount`](https://developer.apple.com/documentation/foundation/progress/completedunitcount), and [`fractionCompleted`](https://developer.apple.com/documentation/foundation/progress/fractioncompleted), support key-value observing (KVO). This makes it extremely easy for a view or window controller object to observe the properties, and update UI elements, such as progress indicators, when the values change. It also means that there is a nonzero cost to updating the values of those properties, so avoid using a unit count that is too granular. If you’re iterating over a large dataset, for example, and each operation takes only a trivial amount of time, divide the work into batches so you can update the unit count once per batch rather than once per iteration.
    ///
    /// ### Reporting Progress for Multiple Operations
    ///
    /// Sometimes, your code may need to report the _overall_ progress of an operation that consists of several suboperations. To accomplish this, your code can report the progress of each suboperation by building up a tree of progress objects.
    ///
    /// The [`NSProgress`](https://developer.apple.com/documentation/foundation/progress) reporting mechanism supports a loosely coupled relationship between progress objects. Suboperations don’t need to know anything about the containing progress item — you can create new progress objects as suboperations of another progress instance. When you assign a progress instance, the system allocates a portion of the containing progress instance’s pending unit count. When the suboperation’s progress object completes, the containing progress object’s [`completedUnitCount`](https://developer.apple.com/documentation/foundation/progress/completedunitcount) property automatically increases by a predefined amount.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The [`completedUnitCount`](https://developer.apple.com/documentation/foundation/progress/completedunitcount) property for a containing progress object only updates when the suboperation is `100%` complete. The [`fractionCompleted`](https://developer.apple.com/documentation/foundation/progress/fractioncompleted) property for a containing progress object updates continuously as work progresses for all suboperations.
    ///
    ///
    ///
    /// </div>
    /// You add suboperation progress objects to your tree implicitly or explicitly.
    ///
    /// #### Adding a Progress Operation Implicitly
    ///
    /// Add a suboperation implicitly by setting a pending unit count for the containing progress object and creating a new [`NSProgress`](https://developer.apple.com/documentation/foundation/progress) instance. When you create the new progress instance, the system sets it as a suboperation of the containing progress object, and assigns the pending unit count.
    ///
    /// As an example, consider that you’re tracking the progress of code downloading and copying files on disk. You can use a single progress object to track the entire task, but it’s easier to manage each subtask using a separate progress object. You start by creating an overall progress object with a suitable total unit count, call [`becomeCurrentWithPendingUnitCount:`](https://developer.apple.com/documentation/foundation/progress/becomecurrent(withpendingunitcount:)), then create your suboperation progress objects before finally calling [`resignCurrent`](https://developer.apple.com/documentation/foundation/progress/resigncurrent()).
    ///
    /// The system divides the pending unit count that you specify in the first method equally among the suboperation progress objects you create between these two method calls. Each suboperation progress object maintains its own internal unit count. When the suboperation object’s [`completedUnitCount`](https://developer.apple.com/documentation/foundation/progress/completedunitcount) equals or exceeds its [`totalUnitCount`](https://developer.apple.com/documentation/foundation/progress/totalunitcount), the system increases the containing progress object’s [`completedUnitCount`](https://developer.apple.com/documentation/foundation/progress/completedunitcount) by the assigned portion of the original pending unit count.
    ///
    /// In the following example, the overall progress object has 100 units. The two suboperation objects, therefore, get 50 pending units each, and keep track internally of 10 units of work each. When each suboperation completes its 10 units, the system increases the overall progress object’s completed unit count by 50.
    ///
    /// ```objc
    /// - (void)startLongOperation {
    ///     self.overallProgress = [NSProgress progressWithTotalUnitCount:100];
    ///  
    ///     [self.overallProgress becomeCurrentWithPendingUnitCount:50];
    ///     [self work1];
    ///     [self.overallProgress resignCurrent];
    ///  
    ///     [self.overallProgress becomeCurrentWithPendingUnitCount:50];
    ///     [self work2];
    ///     [self.overallProgress resignCurrent];
    /// }
    ///  
    /// - (void)work1 {
    ///     NSProgress *firstTaskProgress = [NSProgress progressWithTotalUnitCount:10];
    ///     // Perform first task.
    /// }
    ///  
    /// - (void)work2 {
    ///     NSProgress *secondTaskProgress = [NSProgress progressWithTotalUnitCount:10];
    ///     // Perform second task.
    /// }
    /// ```
    ///
    /// If you don’t create any suboperation progress objects between the calls to [`becomeCurrentWithPendingUnitCount:`](https://developer.apple.com/documentation/foundation/progress/becomecurrent(withpendingunitcount:)) and [`resignCurrent`](https://developer.apple.com/documentation/foundation/progress/resigncurrent()), the containing progress object automatically updates its [`completedUnitCount`](https://developer.apple.com/documentation/foundation/progress/completedunitcount) by adding the pending units.
    ///
    /// #### Adding a Progress Operation Explicitly
    ///
    /// To add a progress operation explicitly, call [`addChild:withPendingUnitCount:`](https://developer.apple.com/documentation/foundation/progress/addchild(_:withpendingunitcount:)) on the containing progress object. The value for the pending unit count is the amount of the containing progress object’s [`totalUnitCount`](https://developer.apple.com/documentation/foundation/progress/totalunitcount) that the suboperation consumes, which conforms to the [`NSProgressReporting`](https://developer.apple.com/documentation/foundation/progressreporting) protocol.
    ///
    /// In the following example, the overall progress object has 10 units. The suboperation progress for the download gets eight units and tracks the download of a photo. The progress for the filter takes a lot less time and gets the remaining two units. When the download completes, the system updates the containing progress object’s completed unit count by eight. When the filter completes, the system updates it by the remaining two units.
    ///
    /// ```objc
    /// - (void)startLongOperation {
    ///     self.overallProgress = [NSProgress progressWithTotalUnitCount:10];
    ///  
    ///     [self.overallProgress addChild:download.progress withPendingUnitCount:8];
    ///     // Do the download.
    ///  
    ///     [self.overallProgress addChild:filter.progress withPendingUnitCount:2];
    ///     // Perform the filter.
    /// }
    /// ```
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSProgress;
);

unsafe impl Send for NSProgress {}

unsafe impl Sync for NSProgress {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSProgress {}
);

impl NSProgress {
    extern_methods!(
        #[unsafe(method(currentProgress))]
        #[unsafe(method_family = none)]
        pub fn currentProgress() -> Option<Retained<NSProgress>>;

        #[unsafe(method(progressWithTotalUnitCount:))]
        #[unsafe(method_family = none)]
        pub fn progressWithTotalUnitCount(unit_count: i64) -> Retained<NSProgress>;

        #[unsafe(method(discreteProgressWithTotalUnitCount:))]
        #[unsafe(method_family = none)]
        pub fn discreteProgressWithTotalUnitCount(unit_count: i64) -> Retained<NSProgress>;

        #[unsafe(method(progressWithTotalUnitCount:parent:pendingUnitCount:))]
        #[unsafe(method_family = none)]
        pub fn progressWithTotalUnitCount_parent_pendingUnitCount(
            unit_count: i64,
            parent: &NSProgress,
            portion_of_parent_total_unit_count: i64,
        ) -> Retained<NSProgress>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `user_info_or_nil` generic should be of the correct type.
        #[unsafe(method(initWithParent:userInfo:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithParent_userInfo(
            this: Allocated<Self>,
            parent_progress_or_nil: Option<&NSProgress>,
            user_info_or_nil: Option<&NSDictionary<NSProgressUserInfoKey, AnyObject>>,
        ) -> Retained<Self>;

        #[unsafe(method(becomeCurrentWithPendingUnitCount:))]
        #[unsafe(method_family = none)]
        pub fn becomeCurrentWithPendingUnitCount(&self, unit_count: i64);

        #[cfg(feature = "block2")]
        #[unsafe(method(performAsCurrentWithPendingUnitCount:usingBlock:))]
        #[unsafe(method_family = none)]
        pub fn performAsCurrentWithPendingUnitCount_usingBlock(
            &self,
            unit_count: i64,
            work: &block2::DynBlock<dyn Fn() + '_>,
        );

        #[unsafe(method(resignCurrent))]
        #[unsafe(method_family = none)]
        pub fn resignCurrent(&self);

        #[unsafe(method(addChild:withPendingUnitCount:))]
        #[unsafe(method_family = none)]
        pub fn addChild_withPendingUnitCount(&self, child: &NSProgress, in_unit_count: i64);

        #[unsafe(method(totalUnitCount))]
        #[unsafe(method_family = none)]
        pub fn totalUnitCount(&self) -> i64;

        /// Setter for [`totalUnitCount`][Self::totalUnitCount].
        #[unsafe(method(setTotalUnitCount:))]
        #[unsafe(method_family = none)]
        pub fn setTotalUnitCount(&self, total_unit_count: i64);

        #[unsafe(method(completedUnitCount))]
        #[unsafe(method_family = none)]
        pub fn completedUnitCount(&self) -> i64;

        /// Setter for [`completedUnitCount`][Self::completedUnitCount].
        #[unsafe(method(setCompletedUnitCount:))]
        #[unsafe(method_family = none)]
        pub fn setCompletedUnitCount(&self, completed_unit_count: i64);

        #[cfg(feature = "NSString")]
        #[unsafe(method(localizedDescription))]
        #[unsafe(method_family = none)]
        pub fn localizedDescription(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        /// Setter for [`localizedDescription`][Self::localizedDescription].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedDescription:))]
        #[unsafe(method_family = none)]
        pub fn setLocalizedDescription(&self, localized_description: Option<&NSString>);

        #[cfg(feature = "NSString")]
        #[unsafe(method(localizedAdditionalDescription))]
        #[unsafe(method_family = none)]
        pub fn localizedAdditionalDescription(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        /// Setter for [`localizedAdditionalDescription`][Self::localizedAdditionalDescription].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedAdditionalDescription:))]
        #[unsafe(method_family = none)]
        pub fn setLocalizedAdditionalDescription(
            &self,
            localized_additional_description: Option<&NSString>,
        );

        #[unsafe(method(isCancellable))]
        #[unsafe(method_family = none)]
        pub fn isCancellable(&self) -> bool;

        /// Setter for [`isCancellable`][Self::isCancellable].
        #[unsafe(method(setCancellable:))]
        #[unsafe(method_family = none)]
        pub fn setCancellable(&self, cancellable: bool);

        #[unsafe(method(isPausable))]
        #[unsafe(method_family = none)]
        pub fn isPausable(&self) -> bool;

        /// Setter for [`isPausable`][Self::isPausable].
        #[unsafe(method(setPausable:))]
        #[unsafe(method_family = none)]
        pub fn setPausable(&self, pausable: bool);

        #[unsafe(method(isCancelled))]
        #[unsafe(method_family = none)]
        pub fn isCancelled(&self) -> bool;

        #[unsafe(method(isPaused))]
        #[unsafe(method_family = none)]
        pub fn isPaused(&self) -> bool;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block must be sendable.
        #[unsafe(method(cancellationHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancellationHandler(&self) -> *mut block2::DynBlock<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`cancellationHandler`][Self::cancellationHandler].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `cancellation_handler` block must be sendable.
        #[unsafe(method(setCancellationHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCancellationHandler(
            &self,
            cancellation_handler: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block must be sendable.
        #[unsafe(method(pausingHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn pausingHandler(&self) -> *mut block2::DynBlock<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`pausingHandler`][Self::pausingHandler].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `pausing_handler` block must be sendable.
        #[unsafe(method(setPausingHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPausingHandler(
            &self,
            pausing_handler: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block must be sendable.
        #[unsafe(method(resumingHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn resumingHandler(&self) -> *mut block2::DynBlock<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`resumingHandler`][Self::resumingHandler].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `resuming_handler` block must be sendable.
        #[unsafe(method(setResumingHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setResumingHandler(
            &self,
            resuming_handler: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `object_or_nil` should be of the correct type.
        #[unsafe(method(setUserInfoObject:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUserInfoObject_forKey(
            &self,
            object_or_nil: Option<&AnyObject>,
            key: &NSProgressUserInfoKey,
        );

        #[unsafe(method(isIndeterminate))]
        #[unsafe(method_family = none)]
        pub fn isIndeterminate(&self) -> bool;

        #[unsafe(method(fractionCompleted))]
        #[unsafe(method_family = none)]
        pub fn fractionCompleted(&self) -> c_double;

        #[unsafe(method(isFinished))]
        #[unsafe(method_family = none)]
        pub fn isFinished(&self) -> bool;

        #[unsafe(method(cancel))]
        #[unsafe(method_family = none)]
        pub fn cancel(&self);

        #[unsafe(method(pause))]
        #[unsafe(method_family = none)]
        pub fn pause(&self);

        #[unsafe(method(resume))]
        #[unsafe(method_family = none)]
        pub fn resume(&self);

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub fn userInfo(&self) -> Retained<NSDictionary<NSProgressUserInfoKey, AnyObject>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(kind))]
        #[unsafe(method_family = none)]
        pub fn kind(&self) -> Option<Retained<NSProgressKind>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`kind`][Self::kind].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setKind:))]
        #[unsafe(method_family = none)]
        pub fn setKind(&self, kind: Option<&NSProgressKind>);

        #[cfg(feature = "NSValue")]
        #[unsafe(method(estimatedTimeRemaining))]
        #[unsafe(method_family = none)]
        pub fn estimatedTimeRemaining(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "NSValue")]
        /// Setter for [`estimatedTimeRemaining`][Self::estimatedTimeRemaining].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setEstimatedTimeRemaining:))]
        #[unsafe(method_family = none)]
        pub fn setEstimatedTimeRemaining(&self, estimated_time_remaining: Option<&NSNumber>);

        #[cfg(feature = "NSValue")]
        #[unsafe(method(throughput))]
        #[unsafe(method_family = none)]
        pub fn throughput(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "NSValue")]
        /// Setter for [`throughput`][Self::throughput].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setThroughput:))]
        #[unsafe(method_family = none)]
        pub fn setThroughput(&self, throughput: Option<&NSNumber>);

        #[cfg(feature = "NSString")]
        #[unsafe(method(fileOperationKind))]
        #[unsafe(method_family = none)]
        pub fn fileOperationKind(&self) -> Option<Retained<NSProgressFileOperationKind>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`fileOperationKind`][Self::fileOperationKind].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setFileOperationKind:))]
        #[unsafe(method_family = none)]
        pub fn setFileOperationKind(
            &self,
            file_operation_kind: Option<&NSProgressFileOperationKind>,
        );

        #[cfg(feature = "NSURL")]
        #[unsafe(method(fileURL))]
        #[unsafe(method_family = none)]
        pub fn fileURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        /// Setter for [`fileURL`][Self::fileURL].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setFileURL:))]
        #[unsafe(method_family = none)]
        pub fn setFileURL(&self, file_url: Option<&NSURL>);

        #[cfg(feature = "NSValue")]
        #[unsafe(method(fileTotalCount))]
        #[unsafe(method_family = none)]
        pub fn fileTotalCount(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "NSValue")]
        /// Setter for [`fileTotalCount`][Self::fileTotalCount].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setFileTotalCount:))]
        #[unsafe(method_family = none)]
        pub fn setFileTotalCount(&self, file_total_count: Option<&NSNumber>);

        #[cfg(feature = "NSValue")]
        #[unsafe(method(fileCompletedCount))]
        #[unsafe(method_family = none)]
        pub fn fileCompletedCount(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "NSValue")]
        /// Setter for [`fileCompletedCount`][Self::fileCompletedCount].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setFileCompletedCount:))]
        #[unsafe(method_family = none)]
        pub fn setFileCompletedCount(&self, file_completed_count: Option<&NSNumber>);

        #[unsafe(method(publish))]
        #[unsafe(method_family = none)]
        pub fn publish(&self);

        #[unsafe(method(unpublish))]
        #[unsafe(method_family = none)]
        pub fn unpublish(&self);

        #[cfg(all(feature = "NSURL", feature = "block2"))]
        /// # Safety
        ///
        /// `publishing_handler` must be a valid pointer.
        #[unsafe(method(addSubscriberForFileURL:withPublishingHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addSubscriberForFileURL_withPublishingHandler(
            url: &NSURL,
            publishing_handler: NSProgressPublishingHandler,
        ) -> Retained<AnyObject>;

        /// # Safety
        ///
        /// `subscriber` should be of the correct type.
        #[unsafe(method(removeSubscriber:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeSubscriber(subscriber: &AnyObject);

        #[unsafe(method(isOld))]
        #[unsafe(method_family = none)]
        pub fn isOld(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSProgress {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSProgress {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// An interface for objects that report progress using a single progress instance.
    ///
    /// ## Overview
    ///
    /// Create the returned progress object using [`NSProgressReporting`](https://developer.apple.com/documentation/foundation/progressreporting). The resulting object has no parent allowing the caller to add it to a progress tree using [`NSProgressReporting`](https://developer.apple.com/documentation/foundation/progressreporting).
    ///
    /// You can return a single progress object or a progress tree. If you are creating a progress tree, add the children to the returned progress object as described in [Reporting Progress for Multiple Operations](https://developer.apple.com/documentation/foundation/progress#reporting-progress-for-multiple-operations).
    ///
    /// You are responsible for setting and updating the [`NSProgressReporting`](https://developer.apple.com/documentation/foundation/progressreporting) of any [`NSProgress`](https://developer.apple.com/documentation/foundation/progress) object you create.
    ///
    ///
    pub unsafe trait NSProgressReporting: NSObjectProtocol {
        #[unsafe(method(progress))]
        #[unsafe(method_family = none)]
        fn progress(&self) -> Retained<NSProgress>;
    }
);

extern "C" {
    /// A key with a corresponding value that represents the time remaining, in seconds.
    ///
    /// ## Discussion
    ///
    /// If present, the autogenerated [`localizedAdditionalDescription`](https://developer.apple.com/documentation/foundation/progress/localizedadditionaldescription) uses the value to provide a string that presents more information.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressEstimatedTimeRemainingKey: &'static NSProgressUserInfoKey;
}

extern "C" {
    /// A key with a corresponding value that indicates the speed of data processing, in bytes per second.
    ///
    /// ## Discussion
    ///
    /// If present, the autogenerated [`localizedAdditionalDescription`](https://developer.apple.com/documentation/foundation/progress/localizedadditionaldescription) uses the value to provide a string that presents more information.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressThroughputKey: &'static NSProgressUserInfoKey;
}

extern "C" {
    /// The value that indicates that the progress is tracking a file operation.
    ///
    /// ## Discussion
    ///
    /// If you set this value for the progress [`kind`](https://developer.apple.com/documentation/foundation/progress/kind), set a value in the user info dictionary for the [`NSProgressFileOperationKindKey`](https://developer.apple.com/documentation/foundation/progressuserinfokey/fileoperationkindkey).
    ///
    /// The system assumes [`NSProgress`](https://developer.apple.com/documentation/foundation/progress) of this kind uses bytes as the unit of work. The default implementation of [`localizedDescription`](https://developer.apple.com/documentation/foundation/progress/localizeddescription) takes advantage of that to return more specific text than it does otherwise. If present, [`localizedDescription`](https://developer.apple.com/documentation/foundation/progress/localizeddescription) uses the [`NSProgressFileTotalCountKey`](https://developer.apple.com/documentation/foundation/progressuserinfokey/filetotalcountkey) and [`NSProgressFileCompletedCountKey`](https://developer.apple.com/documentation/foundation/progressuserinfokey/filecompletedcountkey) keys in the [`userInfo`](https://developer.apple.com/documentation/foundation/progress/userinfo) dictionary for the overall count of files.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressKindFile: &'static NSProgressKind;
}

extern "C" {
    /// A key with a corresponding value that indicates the kind of file operation a progress object represents.
    ///
    /// ## Discussion
    ///
    /// When you set the property [`kind`](https://developer.apple.com/documentation/foundation/progress/kind) on a progress to [`NSProgressKindFile`](https://developer.apple.com/documentation/foundation/progresskind/file), set the corresponding value to one of the entries in Recognizing Kinds of File Operations.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressFileOperationKindKey: &'static NSProgressUserInfoKey;
}

extern "C" {
    /// The progress is tracking a file download operation.
    #[cfg(feature = "NSString")]
    pub static NSProgressFileOperationKindDownloading: &'static NSProgressFileOperationKind;
}

extern "C" {
    /// The progress is tracking file decompression after a download.
    #[cfg(feature = "NSString")]
    pub static NSProgressFileOperationKindDecompressingAfterDownloading:
        &'static NSProgressFileOperationKind;
}

extern "C" {
    /// The progress is tracking the receipt of a file from another source.
    #[cfg(feature = "NSString")]
    pub static NSProgressFileOperationKindReceiving: &'static NSProgressFileOperationKind;
}

extern "C" {
    /// The progress is tracking the copying of a file from source to destination.
    #[cfg(feature = "NSString")]
    pub static NSProgressFileOperationKindCopying: &'static NSProgressFileOperationKind;
}

extern "C" {
    /// The progress is tracking a file upload operation.
    #[cfg(feature = "NSString")]
    pub static NSProgressFileOperationKindUploading: &'static NSProgressFileOperationKind;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSProgressFileOperationKindDuplicating: &'static NSProgressFileOperationKind;
}

extern "C" {
    /// A key with a corresponding value that represents the file URL of a file operation for the progress object.
    ///
    /// ## Discussion
    ///
    /// If present, [`NSProgress`](https://developer.apple.com/documentation/foundation/progress) presents additional information in its localized description.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressFileURLKey: &'static NSProgressUserInfoKey;
}

extern "C" {
    /// A key with a corresponding value that represents the total number of files within a file operation.
    ///
    /// ## Discussion
    ///
    /// If present, the autogenerated [`localizedAdditionalDescription`](https://developer.apple.com/documentation/foundation/progress/localizedadditionaldescription) uses the value to provide a string that presents more information.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressFileTotalCountKey: &'static NSProgressUserInfoKey;
}

extern "C" {
    /// A key with a corresponding value that represents the number of completed files.
    ///
    /// ## Discussion
    ///
    /// If present, the autogenerated [`localizedAdditionalDescription`](https://developer.apple.com/documentation/foundation/progress/localizedadditionaldescription) uses the value to provide a string that presents more information.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressFileCompletedCountKey: &'static NSProgressUserInfoKey;
}

extern "C" {
    /// A key with a corresponding value that is an image, typically an icon to represent the file.
    ///
    /// ## Discussion
    ///
    /// This entry is optional, but if present, along with a value for [`NSProgressFileAnimationImageOriginalRectKey`](https://developer.apple.com/documentation/foundation/progressuserinfokey/fileanimationimageoriginalrectkey), the Dock may show an animation. When the Dock has an item for the folder that contains the relevant file (such as the Downloads folder), the Dock uses this key to show an animation of the file flying into the Dock.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressFileAnimationImageKey: &'static NSProgressUserInfoKey;
}

extern "C" {
    /// A key with a corresponding value that indicates the starting location of the image onscreen.
    ///
    /// ## Discussion
    ///
    /// The associated value is an [`NSValue`](https://developer.apple.com/documentation/foundation/nsvalue) that contains an [`NSRect`](https://developer.apple.com/documentation/foundation/nsrect), in screen coordinates. This entry is optional, but if present, along with a value for [`NSProgressFileAnimationImageKey`](https://developer.apple.com/documentation/foundation/progressuserinfokey/fileanimationimagekey), the Dock may show an animation. When the Dock has an item for the folder that contains the relevant file (such as the Downloads folder), the Dock uses this key to show an animation of the file flying into the Dock.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressFileAnimationImageOriginalRectKey: &'static NSProgressUserInfoKey;
}

extern "C" {
    /// A key with a corresponding value that must be an image, typically an icon to represent the file.
    ///
    /// ## Discussion
    ///
    /// If present, the Finder uses this corresponding value to show the icon of a file that a progress object is tracking.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSProgressFileIconKey: &'static NSProgressUserInfoKey;
}
