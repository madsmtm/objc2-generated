//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// The 32-bit Intel architecture.
pub const NSBundleExecutableArchitectureI386: c_uint = 0x00000007;
/// The 32-bit PowerPC architecture.
pub const NSBundleExecutableArchitecturePPC: c_uint = 0x00000012;
/// The 64-bit Intel architecture.
pub const NSBundleExecutableArchitectureX86_64: c_uint = 0x01000007;
/// The 64-bit PowerPC architecture.
pub const NSBundleExecutableArchitecturePPC64: c_uint = 0x01000012;
/// The 64-bit ARM architecture.
pub const NSBundleExecutableArchitectureARM64: c_uint = 0x0100000c;

extern_class!(
    /// A representation of the code and resources stored in a bundle directory on disk.
    ///
    /// ## Overview
    ///
    /// Apple uses bundles to represent apps, frameworks, plug-ins, and many other specific types of content. Bundles organize their contained resources into well-defined subdirectories, and bundle structures vary depending on the platform and the type of the bundle. By using a bundle object, you can access a bundle’s resources without knowing the structure of the bundle. The bundle object provides a single interface for locating items, taking into account the bundle structure, user preferences, available localizations, and other relevant factors.
    ///
    /// Any executable can use a bundle object to locate resources, either inside an app’s bundle or in a known bundle located elsewhere. You don’t use a bundle object to locate files in a container directory or in other parts of the file system.
    ///
    /// The general pattern for using a bundle object is as follows:
    ///
    /// 1. Create a bundle object for the intended bundle directory.
    ///
    /// 2. Use the methods of the bundle object to locate or load the needed resource.
    ///
    /// 3. Use other system APIs to interact with the resource.
    ///
    /// Some types of frequently used resources can be located and opened without a bundle. For example, when loading images, you store images in asset catalogs and load them using the [`imageNamed:`](https://developer.apple.com/documentation/uikit/uiimage/init(named:)) methods of [`UIImage`](https://developer.apple.com/documentation/uikit/uiimage) or [`NSImage`](https://developer.apple.com/documentation/appkit/nsimage). Similarly, for string resources, you use [`NSLocalizedString`](https://developer.apple.com/documentation/foundation/nslocalizedstring) to load individual strings instead of loading the entire `.strings` file yourself.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    /// Unlike some other Foundation classes with corresponding Core Foundation names (such as [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) and [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring)), [`NSBundle`](https://developer.apple.com/documentation/foundation/bundle) objects cannot be cast to [`CFBundleRef`](https://developer.apple.com/documentation/corefoundation/cfbundle) references. If you need functionality provided by [`CFBundleRef`](https://developer.apple.com/documentation/corefoundation/cfbundle), you can still create a [`CFBundleRef`](https://developer.apple.com/documentation/corefoundation/cfbundle) and use the [`CFBundleRef`](https://developer.apple.com/documentation/corefoundation/cfbundle) API. See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information.
    ///
    ///
    ///
    /// </div>
    /// ### Finding and Opening a Bundle
    ///
    /// Before you can locate a resource, you must first specify which bundle contains it. The [`NSBundle`](https://developer.apple.com/documentation/foundation/bundle) class has many constructors, but the one you use most often is [`mainBundle`](https://developer.apple.com/documentation/foundation/bundle/main). The main bundle represents the bundle directory that contains the currently executing code. So for an app, the main bundle object gives you access to the resources that shipped with your app.
    ///
    /// If your app interacts directly with plug-ins, frameworks, or other bundled content, you can use other methods of this class to create appropriate bundle objects. You can always create bundle objects from a known URL or path, but other methods make it easier to access bundles your app is already using. For example, if you link to a framework, you can use the [`bundleForClass:`](https://developer.apple.com/documentation/foundation/bundle/init(for:)) method to locate the framework bundle based on a class defined in that framework.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Get the app's main bundle", "let mainBundle = Bundle.main", "", "// Get the bundle containing the specified private class.", "let myBundle = Bundle(for: NSClassFromString(\"MyPrivateClass\")!)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Get the app's main bundle", "NSBundle *main = [NSBundle mainBundle];", "", "// Get the bundle containing the specified private class.", "NSBundle *myBundle = [NSBundle bundleForClass:[MyPrivateClass class]];"], metadata: None }] }] })
    /// In Swift, use the [`bundle()`](https://developer.apple.com/documentation/foundation/bundle()) macro to insert a bundle instance appropriate to the current execution context, whether an app, app extension, framework, or Swift package.
    ///
    /// ### Locating Resources in a Bundle
    ///
    /// You use [`NSBundle`](https://developer.apple.com/documentation/foundation/bundle) objects to obtain the location of specific resources inside the bundle. When looking for resources, you provide the name of the resource and its type at a minimum. For resources in a specific subdirectory, you can also specify that directory. After locating the resource, the bundle routines return a path string or URL that you can use to open the file.
    ///
    /// Locating a single resource in a bundle
    ///
    /// ```objc
    /// NSBundle *main = [NSBundle mainBundle];
    /// NSString *resourcePath = [main pathForResource:@"Seagull" ofType:@"jpg"];
    /// ```
    ///
    /// Bundle objects follow a specific search pattern when looking for resources on disk. Global resources—that is, resources not in a language-specific `.lproj` directory—are returned first, followed by region- and language-specific resources. This search pattern means that the bundle looks for resources in the following order:
    ///
    /// 1. Global (nonlocalized) resources
    ///
    /// 2. Region-specific localized resources (based on the user’s region preferences)
    ///
    /// 3. Language-specific localized resources (based on the user’s language preferences)
    ///
    /// 4. Development language resources (as specified by the [CFBundleDevelopmentRegion](https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CoreFoundationKeys.html#//apple_ref/doc/uid/20001431-130430) key in the bundle’s Info.plist file)
    ///
    /// Because global resources take precedence over language-specific resources, you should never include both a global and localized version of a given resource in your app. When a global version of a resource exists, language-specific versions are never returned. The reason for this precedence is performance. If localized resources were searched first, the bundle object might waste time searching for a nonexistent localized resource before returning the global resource.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Bundle objects always consider case when searching for resource files, even on file systems that support case-insensitive filenames. Always make sure that you specify filenames with case sensitivity in mind.
    ///
    ///
    ///
    /// </div>
    /// When locating resource files, the bundle object automatically considers many standard filename modifiers when determining which file to return. Resources may be tagged for a specific device (`~iphone`, `~ipad`) or for a specific screen resolution (`@2x`, `@3x`). Do not include these modifiers when specifying the name of the resource you want. The bundle object selects the file that is most appropriate for the underlying device. For more information, see [App Icons on iPhone, iPad and Apple Watch](https://developer.apple.com/library/archive/qa/qa1686/_index.html#//apple_ref/doc/uid/DTS40009882).
    ///
    /// ### Understanding Bundle Structures
    ///
    /// Bundle structures vary depending on the target platform and the type of bundle you are building. The [`NSBundle`](https://developer.apple.com/documentation/foundation/bundle) class hides this underlying structure in most (but not all) cases. Many of the methods you use to load resources from a bundle automatically locate the appropriate starting directory and look for resources in known places. You can also use the methods and properties of this class to get the location of known bundle directories and to retrieve resources specifically from those directories.
    ///
    /// For information about the bundle structure of iOS and macOS apps, see [Bundle Programming Guide](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBundles/Introduction/Introduction.html#//apple_ref/doc/uid/10000123i). For information about the structure of framework bundles, see [Framework Programming Guide](https://developer.apple.com/library/archive/documentation/MacOSX/Conceptual/BPFrameworks/Frameworks.html#//apple_ref/doc/uid/10000183i). For information about the structure of macOS plug-ins, see [Code Loading Programming Topics](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/LoadingCode/LoadingCode.html#//apple_ref/doc/uid/10000052i).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSBundle;
);

unsafe impl Send for NSBundle {}

unsafe impl Sync for NSBundle {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSBundle {}
);

impl NSBundle {
    extern_methods!(
        #[unsafe(method(mainBundle))]
        #[unsafe(method_family = none)]
        pub fn mainBundle() -> Retained<NSBundle>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(bundleWithPath:))]
        #[unsafe(method_family = none)]
        pub fn bundleWithPath(path: &NSString) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithPath:))]
        #[unsafe(method_family = init)]
        pub fn initWithPath(this: Allocated<Self>, path: &NSString) -> Option<Retained<Self>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(bundleWithURL:))]
        #[unsafe(method_family = none)]
        pub fn bundleWithURL(url: &NSURL) -> Option<Retained<Self>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(initWithURL:))]
        #[unsafe(method_family = init)]
        pub fn initWithURL(this: Allocated<Self>, url: &NSURL) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// `a_class` probably has further requirements.
        #[unsafe(method(bundleForClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundleForClass(a_class: &AnyClass) -> Retained<NSBundle>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(bundleWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn bundleWithIdentifier(identifier: &NSString) -> Option<Retained<NSBundle>>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(allBundles))]
        #[unsafe(method_family = none)]
        pub unsafe fn allBundles() -> Retained<NSArray<NSBundle>>;

        #[cfg(feature = "NSArray")]
        #[unsafe(method(allFrameworks))]
        #[unsafe(method_family = none)]
        pub unsafe fn allFrameworks() -> Retained<NSArray<NSBundle>>;

        #[unsafe(method(load))]
        #[unsafe(method_family = none)]
        pub unsafe fn load(&self) -> bool;

        #[unsafe(method(isLoaded))]
        #[unsafe(method_family = none)]
        pub fn isLoaded(&self) -> bool;

        #[unsafe(method(unload))]
        #[unsafe(method_family = none)]
        pub unsafe fn unload(&self) -> bool;

        #[cfg(feature = "NSError")]
        #[unsafe(method(preflightAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub fn preflightAndReturnError(&self) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(loadAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadAndReturnError(&self) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(bundleURL))]
        #[unsafe(method_family = none)]
        pub fn bundleURL(&self) -> Retained<NSURL>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(resourceURL))]
        #[unsafe(method_family = none)]
        pub fn resourceURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(executableURL))]
        #[unsafe(method_family = none)]
        pub fn executableURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(URLForAuxiliaryExecutable:))]
        #[unsafe(method_family = none)]
        pub fn URLForAuxiliaryExecutable(
            &self,
            executable_name: &NSString,
        ) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(privateFrameworksURL))]
        #[unsafe(method_family = none)]
        pub fn privateFrameworksURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(sharedFrameworksURL))]
        #[unsafe(method_family = none)]
        pub fn sharedFrameworksURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(sharedSupportURL))]
        #[unsafe(method_family = none)]
        pub fn sharedSupportURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(builtInPlugInsURL))]
        #[unsafe(method_family = none)]
        pub fn builtInPlugInsURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(appStoreReceiptURL))]
        #[unsafe(method_family = none)]
        pub fn appStoreReceiptURL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(bundlePath))]
        #[unsafe(method_family = none)]
        pub fn bundlePath(&self) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(resourcePath))]
        #[unsafe(method_family = none)]
        pub fn resourcePath(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(executablePath))]
        #[unsafe(method_family = none)]
        pub fn executablePath(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(pathForAuxiliaryExecutable:))]
        #[unsafe(method_family = none)]
        pub fn pathForAuxiliaryExecutable(
            &self,
            executable_name: &NSString,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(privateFrameworksPath))]
        #[unsafe(method_family = none)]
        pub fn privateFrameworksPath(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(sharedFrameworksPath))]
        #[unsafe(method_family = none)]
        pub fn sharedFrameworksPath(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(sharedSupportPath))]
        #[unsafe(method_family = none)]
        pub fn sharedSupportPath(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(builtInPlugInsPath))]
        #[unsafe(method_family = none)]
        pub fn builtInPlugInsPath(&self) -> Option<Retained<NSString>>;

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(URLForResource:withExtension:subdirectory:inBundleWithURL:))]
        #[unsafe(method_family = none)]
        pub fn URLForResource_withExtension_subdirectory_inBundleWithURL(
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            bundle_url: &NSURL,
        ) -> Option<Retained<NSURL>>;

        #[cfg(all(feature = "NSArray", feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(URLsForResourcesWithExtension:subdirectory:inBundleWithURL:))]
        #[unsafe(method_family = none)]
        pub fn URLsForResourcesWithExtension_subdirectory_inBundleWithURL(
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            bundle_url: &NSURL,
        ) -> Option<Retained<NSArray<NSURL>>>;

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(URLForResource:withExtension:))]
        #[unsafe(method_family = none)]
        pub fn URLForResource_withExtension(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
        ) -> Option<Retained<NSURL>>;

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(URLForResource:withExtension:subdirectory:))]
        #[unsafe(method_family = none)]
        pub fn URLForResource_withExtension_subdirectory(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
        ) -> Option<Retained<NSURL>>;

        #[cfg(all(feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(URLForResource:withExtension:subdirectory:localization:))]
        #[unsafe(method_family = none)]
        pub fn URLForResource_withExtension_subdirectory_localization(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            localization_name: Option<&NSString>,
        ) -> Option<Retained<NSURL>>;

        #[cfg(all(feature = "NSArray", feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(URLsForResourcesWithExtension:subdirectory:))]
        #[unsafe(method_family = none)]
        pub fn URLsForResourcesWithExtension_subdirectory(
            &self,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
        ) -> Option<Retained<NSArray<NSURL>>>;

        #[cfg(all(feature = "NSArray", feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(URLsForResourcesWithExtension:subdirectory:localization:))]
        #[unsafe(method_family = none)]
        pub fn URLsForResourcesWithExtension_subdirectory_localization(
            &self,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            localization_name: Option<&NSString>,
        ) -> Option<Retained<NSArray<NSURL>>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(pathForResource:ofType:inDirectory:))]
        #[unsafe(method_family = none)]
        pub fn pathForResource_ofType_inDirectory_class(
            name: Option<&NSString>,
            ext: Option<&NSString>,
            bundle_path: &NSString,
        ) -> Option<Retained<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(pathsForResourcesOfType:inDirectory:))]
        #[unsafe(method_family = none)]
        pub fn pathsForResourcesOfType_inDirectory_class(
            ext: Option<&NSString>,
            bundle_path: &NSString,
        ) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(pathForResource:ofType:))]
        #[unsafe(method_family = none)]
        pub fn pathForResource_ofType(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(pathForResource:ofType:inDirectory:))]
        #[unsafe(method_family = none)]
        pub fn pathForResource_ofType_inDirectory(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(pathForResource:ofType:inDirectory:forLocalization:))]
        #[unsafe(method_family = none)]
        pub fn pathForResource_ofType_inDirectory_forLocalization(
            &self,
            name: Option<&NSString>,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            localization_name: Option<&NSString>,
        ) -> Option<Retained<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(pathsForResourcesOfType:inDirectory:))]
        #[unsafe(method_family = none)]
        pub fn pathsForResourcesOfType_inDirectory(
            &self,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
        ) -> Retained<NSArray<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(pathsForResourcesOfType:inDirectory:forLocalization:))]
        #[unsafe(method_family = none)]
        pub fn pathsForResourcesOfType_inDirectory_forLocalization(
            &self,
            ext: Option<&NSString>,
            subpath: Option<&NSString>,
            localization_name: Option<&NSString>,
        ) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(localizedStringForKey:value:table:))]
        #[unsafe(method_family = none)]
        pub fn localizedStringForKey_value_table(
            &self,
            key: &NSString,
            value: Option<&NSString>,
            table_name: Option<&NSString>,
        ) -> Retained<NSString>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        /// Look up a localized string given a list of available localizations.
        /// - Parameters:
        /// - key: The key for the localized string to retrieve.
        /// - value: A default value to return if a localized string for ``key`` cannot be found.
        /// - tableName: The name of the strings file to search. If `nil`, the method uses tables in `Localizable.strings`.
        /// - localizations: An array of BCP 47 language codes corresponding to available localizations. Bundle compares the array against its available localizations, and uses the best result to retrieve the localized string. If empty, we treat it as no localization is available, and may return a fallback.
        /// - Returns: A localized version of the string designated by ``key`` in table ``tableName``.
        #[unsafe(method(localizedStringForKey:value:table:localizations:))]
        #[unsafe(method_family = none)]
        pub fn localizedStringForKey_value_table_localizations(
            &self,
            key: &NSString,
            value: Option<&NSString>,
            table_name: Option<&NSString>,
            localizations: &NSArray<NSString>,
        ) -> Retained<NSString>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(bundleIdentifier))]
        #[unsafe(method_family = none)]
        pub fn bundleIdentifier(&self) -> Option<Retained<NSString>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(infoDictionary))]
        #[unsafe(method_family = none)]
        pub fn infoDictionary(&self) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        #[unsafe(method(localizedInfoDictionary))]
        #[unsafe(method_family = none)]
        pub fn localizedInfoDictionary(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(objectForInfoDictionaryKey:))]
        #[unsafe(method_family = none)]
        pub fn objectForInfoDictionaryKey(&self, key: &NSString) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(classNamed:))]
        #[unsafe(method_family = none)]
        pub fn classNamed(&self, class_name: &NSString) -> Option<&'static AnyClass>;

        #[unsafe(method(principalClass))]
        #[unsafe(method_family = none)]
        pub fn principalClass(&self) -> Option<&'static AnyClass>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(preferredLocalizations))]
        #[unsafe(method_family = none)]
        pub fn preferredLocalizations(&self) -> Retained<NSArray<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(localizations))]
        #[unsafe(method_family = none)]
        pub fn localizations(&self) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(developmentLocalization))]
        #[unsafe(method_family = none)]
        pub fn developmentLocalization(&self) -> Option<Retained<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(preferredLocalizationsFromArray:))]
        #[unsafe(method_family = none)]
        pub fn preferredLocalizationsFromArray(
            localizations_array: &NSArray<NSString>,
        ) -> Retained<NSArray<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(preferredLocalizationsFromArray:forPreferences:))]
        #[unsafe(method_family = none)]
        pub fn preferredLocalizationsFromArray_forPreferences(
            localizations_array: &NSArray<NSString>,
            preferences_array: Option<&NSArray<NSString>>,
        ) -> Retained<NSArray<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSValue"))]
        #[unsafe(method(executableArchitectures))]
        #[unsafe(method_family = none)]
        pub fn executableArchitectures(&self) -> Option<Retained<NSArray<NSNumber>>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSBundle {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSBundle {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSBundleExtensionMethods.
#[cfg(feature = "NSString")]
impl NSString {
    extern_methods!(
        #[unsafe(method(variantFittingPresentationWidth:))]
        #[unsafe(method_family = none)]
        pub fn variantFittingPresentationWidth(&self, width: NSInteger) -> Retained<NSString>;
    );
}

extern "C" {
    /// A notification that lets observers know when classes are dynamically loaded.
    ///
    /// ## Discussion
    ///
    /// When a request is made to a bundle for a class ([`classNamed:`](https://developer.apple.com/documentation/foundation/bundle/classnamed(_:)) or [`principalClass`](https://developer.apple.com/documentation/foundation/bundle/principalclass)), the bundle dynamically loads the executable code file that contains the class implementation and all other class definitions contained in the file. After the module is loaded, the bundle posts the [`NSBundleDidLoadNotification`](https://developer.apple.com/documentation/foundation/bundle/didloadnotification).
    ///
    /// The notification object is the [`NSBundle`](https://developer.apple.com/documentation/foundation/bundle) instance that dynamically loads classes. The `userInfo` dictionary contains an [`NSLoadedClasses`](https://developer.apple.com/documentation/foundation/nsloadedclasses) key.
    ///
    /// In a typical use of this notification, an object might want to enumerate the `userInfo` array to check if each loaded class conformed to a certain protocol (say, an protocol for a plug-and-play tool set); if a class does conform, the object would create an instance of that class and add the instance to another [`NSArray`](https://developer.apple.com/documentation/foundation/nsarray) object.
    ///
    ///
    #[cfg(all(feature = "NSNotification", feature = "NSString"))]
    pub static NSBundleDidLoadNotification: &'static NSNotificationName;
}

extern "C" {
    /// A constant used as a key for the `userInfo` dictionary of a [`NSBundleDidLoadNotification`](https://developer.apple.com/documentation/foundation/bundle/didloadnotification) notification that corresponds to an array of names of each class that was loaded.
    #[cfg(feature = "NSString")]
    pub static NSLoadedClasses: &'static NSString;
}

extern_class!(
    /// A resource manager you use to download content hosted on the App Store at the time your app needs it.
    ///
    /// ## Overview
    ///
    /// You identify on-demand resources during development by creating string identifiers known as tags and assigning one or more tags to each resource. An [`NSBundleResourceRequest`](https://developer.apple.com/documentation/foundation/nsbundleresourcerequest) object manages the resources marked by one or more tags.
    ///
    /// You use the resource request to inform the system when the managed tags are needed and when you have finished accessing them. The resource request manages the downloading of any resources marked with the managed tags that are not already on the device and informs your app when the resources are ready for use.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This class ignores calls from Mac apps built with Mac Catalyst.
    ///
    ///
    ///
    /// </div>
    /// The system will not attempt to purge the resources marked with a tag from on-device storage as long as at least one [`NSBundleResourceRequest`](https://developer.apple.com/documentation/foundation/nsbundleresourcerequest) object is managing the tag. Apps can access resources after the completion handler of either [`beginAccessingResourcesWithCompletionHandler:`](https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/beginaccessingresources(completionhandler:)) or [`conditionallyBeginAccessingResourcesWithCompletionHandler:`](https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/conditionallybeginaccessingresources(completionhandler:)) is called successfully. Management ends after a call to [`endAccessingResources`](https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/endaccessingresources()) or after the resource request object is deallocated.
    ///
    /// Other properties and methods let you track the progress of a download, change the priority of a download, and check whether the resources marked by a set of tags are already on the device. Methods in [`NSBundle`](https://developer.apple.com/documentation/foundation/bundle) indicate to the system the relative importance of preserving a tag in memory after it is no longer in use. For more information, see [`setPreservationPriority:forTags:`](https://developer.apple.com/documentation/foundation/bundle/setpreservationpriority(_:fortags:)) and [`preservationPriorityForTag:`](https://developer.apple.com/documentation/foundation/bundle/preservationpriority(fortag:)).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  An [`NSBundleResourceRequest`](https://developer.apple.com/documentation/foundation/nsbundleresourcerequest) object can only be used for one successful resource request.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSBundleResourceRequest;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSBundleResourceRequest {}
);

#[cfg(feature = "NSProgress")]
extern_conformance!(
    unsafe impl NSProgressReporting for NSBundleResourceRequest {}
);

impl NSBundleResourceRequest {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[unsafe(method(initWithTags:))]
        #[unsafe(method_family = init)]
        pub fn initWithTags(this: Allocated<Self>, tags: &NSSet<NSString>) -> Retained<Self>;

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[unsafe(method(initWithTags:bundle:))]
        #[unsafe(method_family = init)]
        pub fn initWithTags_bundle(
            this: Allocated<Self>,
            tags: &NSSet<NSString>,
            bundle: &NSBundle,
        ) -> Retained<Self>;

        #[unsafe(method(loadingPriority))]
        #[unsafe(method_family = none)]
        pub fn loadingPriority(&self) -> c_double;

        /// Setter for [`loadingPriority`][Self::loadingPriority].
        #[unsafe(method(setLoadingPriority:))]
        #[unsafe(method_family = none)]
        pub fn setLoadingPriority(&self, loading_priority: c_double);

        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[unsafe(method(tags))]
        #[unsafe(method_family = none)]
        pub fn tags(&self) -> Retained<NSSet<NSString>>;

        #[unsafe(method(bundle))]
        #[unsafe(method_family = none)]
        pub fn bundle(&self) -> Retained<NSBundle>;

        #[cfg(all(feature = "NSError", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(beginAccessingResourcesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginAccessingResourcesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(conditionallyBeginAccessingResourcesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn conditionallyBeginAccessingResourcesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(Bool)>,
        );

        #[unsafe(method(endAccessingResources))]
        #[unsafe(method_family = none)]
        pub fn endAccessingResources(&self);

        #[cfg(feature = "NSProgress")]
        #[unsafe(method(progress))]
        #[unsafe(method_family = none)]
        pub fn progress(&self) -> Retained<NSProgress>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSBundleResourceRequest {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// NSBundleResourceRequestAdditions.
impl NSBundle {
    extern_methods!(
        #[cfg(all(feature = "NSSet", feature = "NSString"))]
        #[unsafe(method(setPreservationPriority:forTags:))]
        #[unsafe(method_family = none)]
        pub fn setPreservationPriority_forTags(&self, priority: c_double, tags: &NSSet<NSString>);

        #[cfg(feature = "NSString")]
        #[unsafe(method(preservationPriorityForTag:))]
        #[unsafe(method_family = none)]
        pub fn preservationPriorityForTag(&self, tag: &NSString) -> c_double;
    );
}

extern "C" {
    /// Posted after the system detects that the amount of available disk space is getting low. The notification is posted to the default notification center.
    ///
    /// ## Discussion
    ///
    /// After receiving this notification, the app should release any on-demand resources that are not required. Call [`endAccessingResources`](https://developer.apple.com/documentation/foundation/nsbundleresourcerequest/endaccessingresources()) to release the managed resources. If the app is in the background and the app does not free up enough space, it may be terminated.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This notification is generated independently of any other iOS notifications for low disk space.
    ///
    ///
    ///
    /// </div>
    ///
    #[cfg(all(feature = "NSNotification", feature = "NSString"))]
    pub static NSBundleResourceRequestLowDiskSpaceNotification: &'static NSNotificationName;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// A special value for loading priority informing the system that the user cannot continue until the resources marked with the tags managed by the request are downloaded. The system will dedicate the maximum amount of capacity to completing the resource request.
    ///
    ///
    pub static NSBundleResourceRequestLoadingPriorityUrgent: c_double;
}
