//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// Type for the platform-specific native socket handle.
pub type NSSocketNativeHandle = c_int;

extern "C" {
    /// Posted from the [`invalidate`](https://developer.apple.com/documentation/foundation/port/invalidate()) method, which is invoked when the `NSPort` is deallocated or when it notices that its communication channel has been damaged. The notification object is the `NSPort` object that has become invalid. This notification does not contain a `userInfo` dictionary.
    ///
    /// ## Discussion
    ///
    /// An `NSSocketPort` object cannot detect when its connection to a remote port is lost, even if the remote port is on the same machine. Therefore, it cannot invalidate itself and post this notification. Instead, you must detect the timeout error when the next message is sent.
    ///
    /// The `NSPort` object posting this notification is no longer useful, so all receivers should unregister themselves for any notifications involving the `NSPort`. A method receiving this notification should check to see which port became invalid before attempting to do anything. In particular, observers that receive all [`NSPortDidBecomeInvalidNotification`](https://developer.apple.com/documentation/foundation/port/didbecomeinvalidnotification) messages should be aware that communication with the window server is handled through an `NSPort`. If this port becomes invalid, drawing operations will cause a fatal error.
    ///
    ///
    #[cfg(all(feature = "NSNotification", feature = "NSString"))]
    pub static NSPortDidBecomeInvalidNotification: &'static NSNotificationName;
}

extern_class!(
    /// An abstract class that represents a communication channel.
    ///
    /// ## Overview
    ///
    /// Communication occurs between [`NSPort`](https://developer.apple.com/documentation/foundation/port) objects, which typically reside in different threads or tasks. The distributed objects system uses [`NSPort`](https://developer.apple.com/documentation/foundation/port) objects to send [`NSPortMessage`](https://developer.apple.com/documentation/foundation/portmessage) objects back and forth. Implement interapplication communication using distributed objects whenever possible and use [`NSPort`](https://developer.apple.com/documentation/foundation/port) objects only when necessary.
    ///
    /// To receive incoming messages, add [`NSPort`](https://developer.apple.com/documentation/foundation/port) objects to an instance of [`NSRunLoop`](https://developer.apple.com/documentation/foundation/runloop) as input sources. [`NSConnection`](https://developer.apple.com/documentation/foundation/nsconnection) objects automatically add their receive port when initialized.
    ///
    /// When the [`NSPort`](https://developer.apple.com/documentation/foundation/port) object receives a port message, it forwards the message to its delegate in a [`handleMachMessage:`](https://developer.apple.com/documentation/foundation/nsmachportdelegate/handlemachmessage(_:)) or [`handlePortMessage:`](https://developer.apple.com/documentation/foundation/portdelegate/handle(_:)) message. The delegate should implement only one of these methods to process the incoming message in whatever form desired. [`handleMachMessage:`](https://developer.apple.com/documentation/foundation/nsmachportdelegate/handlemachmessage(_:)) provides a message as a raw Mach message beginning with a `msg_header_t` structure. [`handlePortMessage:`](https://developer.apple.com/documentation/foundation/portdelegate/handle(_:)) provides a message as an instance of [`NSPortMessage`](https://developer.apple.com/documentation/foundation/portmessage), which is an object-oriented wrapper for a Mach message. If a delegate has not been set, the `NSPort` object handles the message itself.
    ///
    /// When you are finished using a port object, you must explicitly invalidate the port object prior to sending it a `release` message. Similarly, if your application uses garbage collection, you must invalidate the port object before removing any strong references to it. If you do not invalidate the port, the resulting port object may linger and create a memory leak. To invalidate the port object, invoke its [`invalidate`](https://developer.apple.com/documentation/foundation/port/invalidate()) method.
    ///
    /// Foundation defines three concrete subclasses of `NSPort`. [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) and [`NSMessagePort`](https://developer.apple.com/documentation/foundation/messageport) allow local (on the same machine) communication only. [`NSSocketPort`](https://developer.apple.com/documentation/foundation/socketport) allows for both local and remote communication, but may be more expensive than the others for the local case. When creating an `NSPort` object, using doc:nsport/1807189-allocwithzone or [`port`](https://developer.apple.com/documentation/foundation/nsport/port), an [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) object is created instead.
    ///
    /// For backward compatibility on Mach, `- [NSPort allocWithZone:]` returns an instance of the [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) class when sent to this class. Otherwise, it returns an instance of a concrete subclass that can be used for messaging between threads or processes on the local machine, or, in the case of [`NSSocketPort`](https://developer.apple.com/documentation/foundation/socketport), between processes on separate machines.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  [`NSPort`](https://developer.apple.com/documentation/foundation/port) conforms to the [`NSCoding`](https://developer.apple.com/documentation/foundation/nscoding) protocol, but only supports coding by an [`NSPortCoder`](https://developer.apple.com/documentation/foundation/nsportcoder). [`NSPort`](https://developer.apple.com/documentation/foundation/port) and its subclasses do not support archiving.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSPort;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSPort {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSPort {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSPort {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSPort {}
);

impl NSPort {
    extern_methods!(
        #[unsafe(method(port))]
        #[unsafe(method_family = none)]
        pub fn port() -> Retained<NSPort>;

        #[unsafe(method(invalidate))]
        #[unsafe(method_family = none)]
        pub fn invalidate(&self);

        #[unsafe(method(isValid))]
        #[unsafe(method_family = none)]
        pub fn isValid(&self) -> bool;

        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, an_object: Option<&ProtocolObject<dyn NSPortDelegate>>);

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSPortDelegate>>>;

        #[cfg(all(feature = "NSObjCRuntime", feature = "NSRunLoop", feature = "NSString"))]
        /// # Safety
        ///
        /// `run_loop` possibly has additional threading requirements.
        #[unsafe(method(scheduleInRunLoop:forMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scheduleInRunLoop_forMode(&self, run_loop: &NSRunLoop, mode: &NSRunLoopMode);

        #[cfg(all(feature = "NSObjCRuntime", feature = "NSRunLoop", feature = "NSString"))]
        /// # Safety
        ///
        /// `run_loop` possibly has additional threading requirements.
        #[unsafe(method(removeFromRunLoop:forMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromRunLoop_forMode(&self, run_loop: &NSRunLoop, mode: &NSRunLoopMode);

        #[unsafe(method(reservedSpaceLength))]
        #[unsafe(method_family = none)]
        pub fn reservedSpaceLength(&self) -> NSUInteger;

        #[cfg(all(feature = "NSArray", feature = "NSDate"))]
        /// # Safety
        ///
        /// `components` generic should be of the correct type.
        #[unsafe(method(sendBeforeDate:components:from:reserved:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendBeforeDate_components_from_reserved(
            &self,
            limit_date: &NSDate,
            components: Option<&NSMutableArray>,
            receive_port: Option<&NSPort>,
            header_space_reserved: NSUInteger,
        ) -> bool;

        #[cfg(all(feature = "NSArray", feature = "NSDate"))]
        /// # Safety
        ///
        /// `components` generic should be of the correct type.
        #[unsafe(method(sendBeforeDate:msgid:components:from:reserved:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendBeforeDate_msgid_components_from_reserved(
            &self,
            limit_date: &NSDate,
            msg_id: NSUInteger,
            components: Option<&NSMutableArray>,
            receive_port: Option<&NSPort>,
            header_space_reserved: NSUInteger,
        ) -> bool;

        #[cfg(all(
            feature = "NSConnection",
            feature = "NSObjCRuntime",
            feature = "NSRunLoop",
            feature = "NSString"
        ))]
        /// # Safety
        ///
        /// `run_loop` possibly has additional threading requirements.
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(addConnection:toRunLoop:forMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addConnection_toRunLoop_forMode(
            &self,
            conn: &NSConnection,
            run_loop: &NSRunLoop,
            mode: &NSRunLoopMode,
        );

        #[cfg(all(
            feature = "NSConnection",
            feature = "NSObjCRuntime",
            feature = "NSRunLoop",
            feature = "NSString"
        ))]
        /// # Safety
        ///
        /// `run_loop` possibly has additional threading requirements.
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(removeConnection:fromRunLoop:forMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeConnection_fromRunLoop_forMode(
            &self,
            conn: &NSConnection,
            run_loop: &NSRunLoop,
            mode: &NSRunLoopMode,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSPort {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSPort {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// An interface for handling incoming messages.
    ///
    /// ## Overview
    ///
    /// The [`NSPortDelegate`](https://developer.apple.com/documentation/foundation/portdelegate) protocol defines the optional methods implemented by delegates of [`NSPort`](https://developer.apple.com/documentation/foundation/port) objects.
    ///
    ///
    pub unsafe trait NSPortDelegate: NSObjectProtocol {
        #[cfg(feature = "NSPortMessage")]
        #[optional]
        #[unsafe(method(handlePortMessage:))]
        #[unsafe(method_family = none)]
        fn handlePortMessage(&self, message: &NSPortMessage);
    }
);

/// Used to remove access rights to a mach port when the `NSMachPort` object is invalidated or destroyed.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSMachPortOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSMachPortOptions: NSUInteger {
/// Do not remove any send or receive rights.
        #[doc(alias = "NSMachPortDeallocateNone")]
        const DeallocateNone = 0;
/// Deallocate a send right when the `NSMachPort` object is invalidated or destroyed.
        #[doc(alias = "NSMachPortDeallocateSendRight")]
        const DeallocateSendRight = 1<<0;
/// Remove a receive right when the `NSMachPort` object is invalidated or destroyed.
        #[doc(alias = "NSMachPortDeallocateReceiveRight")]
        const DeallocateReceiveRight = 1<<1;
    }
}

unsafe impl Encode for NSMachPortOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSMachPortOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A port that can be used as an endpoint for distributed object connections (or raw messaging).
    ///
    /// ## Overview
    ///
    /// [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) is a subclass of [`NSPort`](https://developer.apple.com/documentation/foundation/port) that wraps a Mach port, the fundamental communication port in macOS. [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) allows for local (on the same machine) communication only. A companion class, [`NSSocketPort`](https://developer.apple.com/documentation/foundation/socketport), allows for both local and remote distributed object communication, but may be more expensive than [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) for the local case.
    ///
    /// To use [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) effectively, you should be familiar with Mach ports, port access rights, and Mach messages. See the Mach OS documentation for more information.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) conforms to the [`NSCoding`](https://developer.apple.com/documentation/foundation/nscoding) protocol, but only supports coding by an [`NSPortCoder`](https://developer.apple.com/documentation/foundation/nsportcoder). [`NSPort`](https://developer.apple.com/documentation/foundation/port) and its subclasses do not support archiving.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSPort, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMachPort;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSMachPort> for CFMachPort {
    #[inline]
    fn as_ref(&self) -> &NSMachPort {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFMachPort> for NSMachPort {
    #[inline]
    fn as_ref(&self) -> &CFMachPort {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSMachPort {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSMachPort {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSMachPort {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSMachPort {}
);

impl NSMachPort {
    extern_methods!(
        #[unsafe(method(portWithMachPort:))]
        #[unsafe(method_family = none)]
        pub fn portWithMachPort(mach_port: u32) -> Retained<NSPort>;

        #[unsafe(method(initWithMachPort:))]
        #[unsafe(method_family = init)]
        pub fn initWithMachPort(this: Allocated<Self>, mach_port: u32) -> Retained<Self>;

        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            an_object: Option<&ProtocolObject<dyn NSMachPortDelegate>>,
        );

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSMachPortDelegate>>>;

        #[unsafe(method(portWithMachPort:options:))]
        #[unsafe(method_family = none)]
        pub fn portWithMachPort_options(mach_port: u32, f: NSMachPortOptions) -> Retained<NSPort>;

        #[unsafe(method(initWithMachPort:options:))]
        #[unsafe(method_family = init)]
        pub fn initWithMachPort_options(
            this: Allocated<Self>,
            mach_port: u32,
            f: NSMachPortOptions,
        ) -> Retained<Self>;

        #[unsafe(method(machPort))]
        #[unsafe(method_family = none)]
        pub fn machPort(&self) -> u32;

        #[cfg(all(feature = "NSObjCRuntime", feature = "NSRunLoop", feature = "NSString"))]
        /// # Safety
        ///
        /// `run_loop` possibly has additional threading requirements.
        #[unsafe(method(scheduleInRunLoop:forMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scheduleInRunLoop_forMode(&self, run_loop: &NSRunLoop, mode: &NSRunLoopMode);

        #[cfg(all(feature = "NSObjCRuntime", feature = "NSRunLoop", feature = "NSString"))]
        /// # Safety
        ///
        /// `run_loop` possibly has additional threading requirements.
        #[unsafe(method(removeFromRunLoop:forMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromRunLoop_forMode(&self, run_loop: &NSRunLoop, mode: &NSRunLoopMode);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSMachPort {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSMachPort {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// An interface for handling incoming Mach messages.
    ///
    /// ## Overview
    ///
    /// Delegates of [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) objects optionally adopt this protocol.
    ///
    ///
    pub unsafe trait NSMachPortDelegate: NSPortDelegate {
        /// # Safety
        ///
        /// `msg` must be a valid pointer.
        #[optional]
        #[unsafe(method(handleMachMessage:))]
        #[unsafe(method_family = none)]
        unsafe fn handleMachMessage(&self, msg: NonNull<c_void>);
    }
);

extern_class!(
    /// A port that can be used as an endpoint for distributed object connections (or raw messaging).
    ///
    /// ## Overview
    ///
    /// [`NSMessagePort`](https://developer.apple.com/documentation/foundation/messageport) is a subclass of [`NSPort`](https://developer.apple.com/documentation/foundation/port) that allows for local (on the same machine) communication only. A companion class, [`NSSocketPort`](https://developer.apple.com/documentation/foundation/socketport), allows for both local and remote communication, but may be more expensive than [`NSMessagePort`](https://developer.apple.com/documentation/foundation/messageport) for the local case.
    ///
    /// [`NSMessagePort`](https://developer.apple.com/documentation/foundation/messageport) defines no additional methods over those already defined by [`NSPort`](https://developer.apple.com/documentation/foundation/port).
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  [`NSMessagePort`](https://developer.apple.com/documentation/foundation/messageport) conforms to the [`NSCoding`](https://developer.apple.com/documentation/foundation/nscoding) protocol, but only supports coding by an [`NSPortCoder`](https://developer.apple.com/documentation/foundation/nsportcoder) object. [`NSPort`](https://developer.apple.com/documentation/foundation/port) and its subclasses do not support archiving.
    ///
    ///
    ///
    /// </div>
    /// <div class="warning">
    ///
    /// ### Important
    ///  Avoid [`NSMessagePort`](https://developer.apple.com/documentation/foundation/messageport). There’s little reason to use [`NSMessagePort`](https://developer.apple.com/documentation/foundation/messageport) rather than [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) or [`NSSocketPort`](https://developer.apple.com/documentation/foundation/socketport). There’s no particular performance or functionality advantage. It is recommended avoiding its use.
    ///
    /// [`NSMessagePort`](https://developer.apple.com/documentation/foundation/messageport) may be deprecated in the macOS 10.6 or later.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSPort, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMessagePort;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSMessagePort> for CFMessagePort {
    #[inline]
    fn as_ref(&self) -> &NSMessagePort {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFMessagePort> for NSMessagePort {
    #[inline]
    fn as_ref(&self) -> &CFMessagePort {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSMessagePort {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSMessagePort {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSMessagePort {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSMessagePort {}
);

impl NSMessagePort {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NSMessagePort {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSMessagePort {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// A port that represents a BSD socket.
    ///
    /// ## Overview
    ///
    /// A [`NSSocketPort`](https://developer.apple.com/documentation/foundation/socketport) object can be used as an endpoint for distributed object connections. Companion classes, [`NSMachPort`](https://developer.apple.com/documentation/foundation/nsmachport) and [`NSMessagePort`](https://developer.apple.com/documentation/foundation/messageport), allow for local (on the same machine) communication only. The [`NSSocketPort`](https://developer.apple.com/documentation/foundation/socketport) class allows for both local and remote communication, but may be more expensive than the others for the local case.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The [`NSSocketPort`](https://developer.apple.com/documentation/foundation/socketport) class conforms to the [`NSCoding`](https://developer.apple.com/documentation/foundation/nscoding) protocol, but only supports coding by an [`NSPortCoder`](https://developer.apple.com/documentation/foundation/nsportcoder). [`NSPort`](https://developer.apple.com/documentation/foundation/port) and its other subclasses do not support archiving.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSPort, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSSocketPort;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSSocketPort {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSSocketPort {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSSocketPort {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSSocketPort {}
);

impl NSSocketPort {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithTCPPort:))]
        #[unsafe(method_family = init)]
        pub fn initWithTCPPort(this: Allocated<Self>, port: c_ushort) -> Option<Retained<Self>>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(initWithProtocolFamily:socketType:protocol:address:))]
        #[unsafe(method_family = init)]
        pub fn initWithProtocolFamily_socketType_protocol_address(
            this: Allocated<Self>,
            family: c_int,
            r#type: c_int,
            protocol: c_int,
            address: &NSData,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithProtocolFamily:socketType:protocol:socket:))]
        #[unsafe(method_family = init)]
        pub fn initWithProtocolFamily_socketType_protocol_socket(
            this: Allocated<Self>,
            family: c_int,
            r#type: c_int,
            protocol: c_int,
            sock: NSSocketNativeHandle,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(initRemoteWithTCPPort:host:))]
        #[unsafe(method_family = init)]
        pub fn initRemoteWithTCPPort_host(
            this: Allocated<Self>,
            port: c_ushort,
            host_name: Option<&NSString>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(initRemoteWithProtocolFamily:socketType:protocol:address:))]
        #[unsafe(method_family = init)]
        pub fn initRemoteWithProtocolFamily_socketType_protocol_address(
            this: Allocated<Self>,
            family: c_int,
            r#type: c_int,
            protocol: c_int,
            address: &NSData,
        ) -> Retained<Self>;

        #[unsafe(method(protocolFamily))]
        #[unsafe(method_family = none)]
        pub fn protocolFamily(&self) -> c_int;

        #[unsafe(method(socketType))]
        #[unsafe(method_family = none)]
        pub fn socketType(&self) -> c_int;

        #[unsafe(method(protocol))]
        #[unsafe(method_family = none)]
        pub fn protocol(&self) -> c_int;

        #[cfg(feature = "NSData")]
        #[unsafe(method(address))]
        #[unsafe(method_family = none)]
        pub fn address(&self) -> Retained<NSData>;

        #[unsafe(method(socket))]
        #[unsafe(method_family = none)]
        pub fn socket(&self) -> NSSocketNativeHandle;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSSocketPort {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSSocketPort {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
