//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Type indicating a parameter is a pointer to an `NSRange` structure.
pub type NSRangePointer = *mut NSRange;

// TODO: pub fn NSMakeRange(loc: NSUInteger,len: NSUInteger,) -> NSRange;

// TODO: pub fn NSMaxRange(range: NSRange,) -> NSUInteger;

// TODO: pub fn NSLocationInRange(loc: NSUInteger,range: NSRange,) -> Bool;

// TODO: pub fn NSEqualRanges(range1: NSRange,range2: NSRange,) -> Bool;

/// Returns the union of the specified ranges.
///
/// ## Return Value
///
/// A range covering all indices in and between `range1` and `range2`. If one range is completely contained in the other, the returned range is equal to the larger range.
///
///
#[inline]
pub extern "C-unwind" fn NSUnionRange(range1: NSRange, range2: NSRange) -> NSRange {
    extern "C-unwind" {
        fn NSUnionRange(range1: NSRange, range2: NSRange) -> NSRange;
    }
    unsafe { NSUnionRange(range1, range2) }
}

/// Returns the intersection of the specified ranges.
///
/// ## Return Value
///
/// A range describing the intersection of `range1` and `range2`—that is, a range containing the indices that exist in both ranges.
///
///
///
/// ## Discussion
///
/// If the returned range’s length field is 0, then the two ranges don’t intersect, and the value of the location field is undefined.
///
///
#[inline]
pub extern "C-unwind" fn NSIntersectionRange(range1: NSRange, range2: NSRange) -> NSRange {
    extern "C-unwind" {
        fn NSIntersectionRange(range1: NSRange, range2: NSRange) -> NSRange;
    }
    unsafe { NSIntersectionRange(range1, range2) }
}

#[cfg(feature = "NSString")]
impl NSString {
    /// Returns a string representation of a range.
    ///
    /// ## Return Value
    ///
    /// A string of the form “{a, b}”, where a and b are non-negative integers representing `aRange`.
    ///
    ///
    #[doc(alias = "NSStringFromRange")]
    #[cfg(feature = "NSString")]
    #[inline]
    pub fn from_range(range: NSRange) -> Retained<NSString> {
        extern "C-unwind" {
            fn NSStringFromRange(range: NSRange) -> *mut NSString;
        }
        let ret = unsafe { NSStringFromRange(range) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// Returns a range from a textual representation.
///
/// ## Discussion
///
/// Scans `aString` for two integers which are used as the location and length values, in that order, to create an `NSRange` struct. If `aString` only contains a single integer, it is used as the location value. If `aString` does not contain any integers, this function returns an `NSRange` struct whose location and length values are both 0.
///
///
#[cfg(feature = "NSString")]
#[inline]
pub extern "C-unwind" fn NSRangeFromString(a_string: &NSString) -> NSRange {
    extern "C-unwind" {
        fn NSRangeFromString(a_string: &NSString) -> NSRange;
    }
    unsafe { NSRangeFromString(a_string) }
}

/// NSValueRangeExtensions.
#[cfg(feature = "NSValue")]
impl NSValue {
    extern_methods!(
        #[unsafe(method(valueWithRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithRange(range: NSRange) -> Retained<NSValue>;

        #[unsafe(method(rangeValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn rangeValue(&self) -> NSRange;
    );
}

#[cfg(feature = "NSString")]
#[deprecated = "renamed to `NSString::from_range`"]
#[inline]
pub extern "C-unwind" fn NSStringFromRange(range: NSRange) -> Retained<NSString> {
    extern "C-unwind" {
        fn NSStringFromRange(range: NSRange) -> *mut NSString;
    }
    let ret = unsafe { NSStringFromRange(range) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}
