//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern_class!(
    /// An object that manages the communication between objects in different threads or between a thread and a process running on a local or remote system.
    ///
    /// ## Overview
    ///
    /// Connection objects form the backbone of the distributed objects mechanism and normally operate in the background. You use the methods of [`NSConnection`](https://developer.apple.com/documentation/foundation/nsconnection) explicitly when vending an object to other applications, when accessing such a vended object through a proxy, and when altering default communication parameters. At other times, you simply interact with a vended object or its proxy.
    ///
    /// A single connection object may be shared by multiple threads and used to access a vended object.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use NSXPCConnection instead"]
    pub struct NSConnection;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSConnection {}
);

impl NSConnection {
    extern_methods!(
        #[cfg(all(feature = "NSDictionary", feature = "NSString", feature = "NSValue"))]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(statistics))]
        #[unsafe(method_family = none)]
        pub fn statistics(&self) -> Retained<NSDictionary<NSString, NSNumber>>;

        #[cfg(feature = "NSArray")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(allConnections))]
        #[unsafe(method_family = none)]
        pub fn allConnections() -> Retained<NSArray<NSConnection>>;

        #[deprecated]
        #[unsafe(method(defaultConnection))]
        #[unsafe(method_family = none)]
        pub fn defaultConnection() -> Retained<NSConnection>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(connectionWithRegisteredName:host:))]
        #[unsafe(method_family = none)]
        pub fn connectionWithRegisteredName_host(
            name: &NSString,
            host_name: Option<&NSString>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "NSPortNameServer", feature = "NSString"))]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(connectionWithRegisteredName:host:usingNameServer:))]
        #[unsafe(method_family = none)]
        pub fn connectionWithRegisteredName_host_usingNameServer(
            name: &NSString,
            host_name: Option<&NSString>,
            server: &NSPortNameServer,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "NSDistantObject", feature = "NSProxy", feature = "NSString"))]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(rootProxyForConnectionWithRegisteredName:host:))]
        #[unsafe(method_family = none)]
        pub fn rootProxyForConnectionWithRegisteredName_host(
            name: &NSString,
            host_name: Option<&NSString>,
        ) -> Option<Retained<NSDistantObject>>;

        #[cfg(all(
            feature = "NSDistantObject",
            feature = "NSPortNameServer",
            feature = "NSProxy",
            feature = "NSString"
        ))]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(rootProxyForConnectionWithRegisteredName:host:usingNameServer:))]
        #[unsafe(method_family = none)]
        pub fn rootProxyForConnectionWithRegisteredName_host_usingNameServer(
            name: &NSString,
            host_name: Option<&NSString>,
            server: &NSPortNameServer,
        ) -> Option<Retained<NSDistantObject>>;

        #[cfg(all(feature = "NSPortNameServer", feature = "NSString"))]
        /// # Safety
        ///
        /// `root` should be of the correct type.
        #[unsafe(method(serviceConnectionWithName:rootObject:usingNameServer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn serviceConnectionWithName_rootObject_usingNameServer(
            name: &NSString,
            root: &AnyObject,
            server: &NSPortNameServer,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `root` should be of the correct type.
        #[unsafe(method(serviceConnectionWithName:rootObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn serviceConnectionWithName_rootObject(
            name: &NSString,
            root: &AnyObject,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSDate")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(requestTimeout))]
        #[unsafe(method_family = none)]
        pub fn requestTimeout(&self) -> NSTimeInterval;

        #[cfg(feature = "NSDate")]
        /// Setter for [`requestTimeout`][Self::requestTimeout].
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(setRequestTimeout:))]
        #[unsafe(method_family = none)]
        pub fn setRequestTimeout(&self, request_timeout: NSTimeInterval);

        #[cfg(feature = "NSDate")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(replyTimeout))]
        #[unsafe(method_family = none)]
        pub fn replyTimeout(&self) -> NSTimeInterval;

        #[cfg(feature = "NSDate")]
        /// Setter for [`replyTimeout`][Self::replyTimeout].
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(setReplyTimeout:))]
        #[unsafe(method_family = none)]
        pub fn setReplyTimeout(&self, reply_timeout: NSTimeInterval);

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(rootObject))]
        #[unsafe(method_family = none)]
        pub fn rootObject(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`rootObject`][Self::rootObject].
        ///
        /// # Safety
        ///
        /// `root_object` should be of the correct type.
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(setRootObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRootObject(&self, root_object: Option<&AnyObject>);

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self)
            -> Option<Retained<ProtocolObject<dyn NSConnectionDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSConnectionDelegate>>,
        );

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(independentConversationQueueing))]
        #[unsafe(method_family = none)]
        pub fn independentConversationQueueing(&self) -> bool;

        /// Setter for [`independentConversationQueueing`][Self::independentConversationQueueing].
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(setIndependentConversationQueueing:))]
        #[unsafe(method_family = none)]
        pub fn setIndependentConversationQueueing(&self, independent_conversation_queueing: bool);

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(isValid))]
        #[unsafe(method_family = none)]
        pub fn isValid(&self) -> bool;

        #[cfg(all(feature = "NSDistantObject", feature = "NSProxy"))]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(rootProxy))]
        #[unsafe(method_family = none)]
        pub fn rootProxy(&self) -> Retained<NSDistantObject>;

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(invalidate))]
        #[unsafe(method_family = none)]
        pub fn invalidate(&self);

        #[cfg(feature = "NSString")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(addRequestMode:))]
        #[unsafe(method_family = none)]
        pub fn addRequestMode(&self, rmode: &NSString);

        #[cfg(feature = "NSString")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(removeRequestMode:))]
        #[unsafe(method_family = none)]
        pub fn removeRequestMode(&self, rmode: &NSString);

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(requestModes))]
        #[unsafe(method_family = none)]
        pub fn requestModes(&self) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(registerName:))]
        #[unsafe(method_family = none)]
        pub fn registerName(&self, name: Option<&NSString>) -> bool;

        #[cfg(all(feature = "NSPortNameServer", feature = "NSString"))]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(registerName:withNameServer:))]
        #[unsafe(method_family = none)]
        pub fn registerName_withNameServer(
            &self,
            name: Option<&NSString>,
            server: &NSPortNameServer,
        ) -> bool;

        #[cfg(feature = "NSPort")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(connectionWithReceivePort:sendPort:))]
        #[unsafe(method_family = none)]
        pub fn connectionWithReceivePort_sendPort(
            receive_port: Option<&NSPort>,
            send_port: Option<&NSPort>,
        ) -> Option<Retained<Self>>;

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(currentConversation))]
        #[unsafe(method_family = none)]
        pub fn currentConversation() -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSPort")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(initWithReceivePort:sendPort:))]
        #[unsafe(method_family = init)]
        pub fn initWithReceivePort_sendPort(
            this: Allocated<Self>,
            receive_port: Option<&NSPort>,
            send_port: Option<&NSPort>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSPort")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(sendPort))]
        #[unsafe(method_family = none)]
        pub fn sendPort(&self) -> Retained<NSPort>;

        #[cfg(feature = "NSPort")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(receivePort))]
        #[unsafe(method_family = none)]
        pub fn receivePort(&self) -> Retained<NSPort>;

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(enableMultipleThreads))]
        #[unsafe(method_family = none)]
        pub fn enableMultipleThreads(&self);

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(multipleThreadsEnabled))]
        #[unsafe(method_family = none)]
        pub fn multipleThreadsEnabled(&self) -> bool;

        #[cfg(feature = "NSRunLoop")]
        /// # Safety
        ///
        /// `runloop` possibly has additional threading requirements.
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(addRunLoop:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRunLoop(&self, runloop: &NSRunLoop);

        #[cfg(feature = "NSRunLoop")]
        /// # Safety
        ///
        /// `runloop` possibly has additional threading requirements.
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(removeRunLoop:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeRunLoop(&self, runloop: &NSRunLoop);

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(runInNewThread))]
        #[unsafe(method_family = none)]
        pub fn runInNewThread(&self);

        #[cfg(feature = "NSArray")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(remoteObjects))]
        #[unsafe(method_family = none)]
        pub fn remoteObjects(&self) -> Retained<NSArray>;

        #[cfg(feature = "NSArray")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(localObjects))]
        #[unsafe(method_family = none)]
        pub fn localObjects(&self) -> Retained<NSArray>;

        #[cfg(feature = "NSArray")]
        /// # Safety
        ///
        /// `components` generic should be of the correct type.
        #[unsafe(method(dispatchWithComponents:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dispatchWithComponents(&self, components: &NSArray);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSConnection {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSConnection {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern "C" {
    /// The mode to indicate an `NSConnection` object waiting for replies.
    ///
    /// ## Discussion
    ///
    /// You should rarely need to use this mode.
    ///
    ///
    #[cfg(feature = "NSString")]
    #[deprecated = "Use NSXPCConnection instead"]
    pub static NSConnectionReplyMode: &'static NSString;
}

extern "C" {
    /// Posted when an `NSConnection` object is deallocated or when it’s notified that its `NSPort` object has become invalid. The notification object is the `NSConnection` object. This notification does not contain a `userInfo` dictionary.
    ///
    /// ## Discussion
    ///
    /// An `NSConnection` object attached to a remote `NSSocketPort` object cannot detect when the remote port becomes invalid, even if the remote port is on the same machine. Therefore, it cannot post this notification when the connection is lost. Instead, you must detect the timeout error when the next message is sent.
    ///
    /// The `NSConnection` object posting this notification is no longer useful, so all receivers should unregister themselves for any notifications involving the `NSConnection` object.
    ///
    ///
    #[cfg(feature = "NSString")]
    #[deprecated = "Use NSXPCConnection instead"]
    pub static NSConnectionDidDieNotification: &'static NSString;
}

extern_protocol!(
    /// An interface for interacting with low-level, interprocess connections.
    ///
    /// ## Overview
    ///
    /// The [`NSConnectionDelegate`](https://developer.apple.com/documentation/foundation/nsconnectiondelegate) protocol defines the optional methods implemented by delegates of [`NSConnection`](https://developer.apple.com/documentation/foundation/nsconnection) objects.
    ///
    ///
    #[deprecated = "Use NSXPCConnection instead"]
    pub unsafe trait NSConnectionDelegate: NSObjectProtocol {
        #[deprecated = "Use NSXPCConnection instead"]
        #[optional]
        #[unsafe(method(makeNewConnection:sender:))]
        #[unsafe(method_family = none)]
        fn makeNewConnection_sender(&self, conn: &NSConnection, ancestor: &NSConnection) -> bool;

        #[deprecated = "Use NSXPCConnection instead"]
        #[optional]
        #[unsafe(method(connection:shouldMakeNewConnection:))]
        #[unsafe(method_family = none)]
        fn connection_shouldMakeNewConnection(
            &self,
            ancestor: &NSConnection,
            conn: &NSConnection,
        ) -> bool;

        #[cfg(all(feature = "NSArray", feature = "NSData"))]
        /// # Safety
        ///
        /// `components` generic should be of the correct type.
        #[deprecated = "Use NSXPCConnection instead"]
        #[optional]
        #[unsafe(method(authenticationDataForComponents:))]
        #[unsafe(method_family = none)]
        unsafe fn authenticationDataForComponents(&self, components: &NSArray) -> Retained<NSData>;

        #[cfg(all(feature = "NSArray", feature = "NSData"))]
        /// # Safety
        ///
        /// `components` generic should be of the correct type.
        #[deprecated = "Use NSXPCConnection instead"]
        #[optional]
        #[unsafe(method(authenticateComponents:withData:))]
        #[unsafe(method_family = none)]
        unsafe fn authenticateComponents_withData(
            &self,
            components: &NSArray,
            signature: &NSData,
        ) -> bool;

        #[deprecated = "Use NSXPCConnection instead"]
        #[optional]
        #[unsafe(method(createConversationForConnection:))]
        #[unsafe(method_family = none)]
        fn createConversationForConnection(&self, conn: &NSConnection) -> Retained<AnyObject>;

        #[deprecated = "Use NSXPCConnection instead"]
        #[optional]
        #[unsafe(method(connection:handleRequest:))]
        #[unsafe(method_family = none)]
        fn connection_handleRequest(
            &self,
            connection: &NSConnection,
            doreq: &NSDistantObjectRequest,
        ) -> bool;
    }
);

extern "C" {
    /// Raised by `NSConnection` on receipt of a remote message the delegate doesn’t authenticate.
    #[cfg(feature = "NSString")]
    #[deprecated = "Use NSXPCConnection instead"]
    pub static NSFailedAuthenticationException: &'static NSString;
}

extern "C" {
    /// Posted when an `NSConnection` object is initialized using [`initWithReceivePort:sendPort:`](https://developer.apple.com/documentation/foundation/nsconnection/initwithreceiveport:sendport:) (the designated initializer for `NSConnection`). The notification object is the `NSConnection` object. This notification does not contain a `userInfo` dictionary.
    ///
    /// ## Discussion
    ///
    ///
    #[cfg(feature = "NSString")]
    #[deprecated = "Use NSXPCConnection instead"]
    pub static NSConnectionDidInitializeNotification: &'static NSString;
}

extern_class!(
    /// An object used by the distributed objects system to help handle invocations between different processes.
    ///
    /// ## Overview
    ///
    /// Do not create [`NSDistantObjectRequest`](https://developer.apple.com/documentation/foundation/nsdistantobjectrequest) objects directly. Unless you are getting involved with the low-level details of distributed objects, there should never be a need to access an [`NSDistantObjectRequest`](https://developer.apple.com/documentation/foundation/nsdistantobjectrequest). To intercept and possibly process requests yourself, implement the [`NSConnection`](https://developer.apple.com/documentation/foundation/nsconnection) delegate method [`connection:handleRequest:`](https://developer.apple.com/documentation/foundation/nsconnectiondelegate/connection:handlerequest:).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use NSXPCConnection instead"]
    pub struct NSDistantObjectRequest;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSDistantObjectRequest {}
);

impl NSDistantObjectRequest {
    extern_methods!(
        #[cfg(feature = "NSInvocation")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(invocation))]
        #[unsafe(method_family = none)]
        pub unsafe fn invocation(&self) -> Retained<NSInvocation>;

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(connection))]
        #[unsafe(method_family = none)]
        pub fn connection(&self) -> Retained<NSConnection>;

        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(conversation))]
        #[unsafe(method_family = none)]
        pub fn conversation(&self) -> Retained<AnyObject>;

        #[cfg(feature = "NSException")]
        #[deprecated = "Use NSXPCConnection instead"]
        #[unsafe(method(replyWithException:))]
        #[unsafe(method_family = none)]
        pub fn replyWithException(&self, exception: Option<&NSException>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSDistantObjectRequest {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSDistantObjectRequest {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
