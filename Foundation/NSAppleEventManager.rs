//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-services")]
#[cfg(target_vendor = "apple")]
use objc2_core_services::*;

use crate::*;

#[repr(C)]
#[derive(Debug)]
pub struct __NSAppleEventManagerSuspension {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for __NSAppleEventManagerSuspension {
    const ENCODING_REF: Encoding =
        Encoding::Pointer(&Encoding::Struct("__NSAppleEventManagerSuspension", &[]));
}

/// Identifies an Apple event whose handling has been suspended. Can be used to resume handling of the Apple event.
pub type NSAppleEventManagerSuspensionID = *const __NSAppleEventManagerSuspension;

extern "C" {
    /// Specifies that an event-processing operation should continue until a timeout occurs based on a value determined by the Apple Event Manager (about 1 minute). Not currently used by applications.
    pub static NSAppleEventTimeOutDefault: c_double;
}

extern "C" {
    /// Specifies that the application is willing to wait indefinitely for the current operation to complete. Not currently used by applications.
    pub static NSAppleEventTimeOutNone: c_double;
}

extern "C" {
    /// Posted by `NSAppleEventManager` before it first dispatches an Apple event. Your application can use this notification to avoid registering any Apple event handlers until the first time at which they may be needed.
    ///
    /// ## Discussion
    ///
    /// The notification object is the `NSAppleEventManager`. This notification does not contain a `userInfo` dictionary.
    ///
    ///
    #[cfg(all(feature = "NSNotification", feature = "NSString"))]
    pub static NSAppleEventManagerWillProcessFirstEventNotification: &'static NSNotificationName;
}

extern_class!(
    /// A mechanism for registering handler routines for specific types of Apple events and dispatching events to those handlers.
    ///
    /// ## Overview
    ///
    /// Cocoa provides built-in scriptability support that uses scriptability information supplied by an application to automatically convert Apple events into script command objects that perform the desired operation. However, some applications may want to perform more basic Apple event handling, in which an application registers handlers for the Apple events it can process, then calls on the Apple Event Manager to dispatch received Apple events to the appropriate handler. `NSAppleEventManager` supports these mechanisms by providing methods to register and remove handlers and to dispatch Apple events to the appropriate handler, if one exists. For related information, see [How Cocoa Applications Handle Apple Events](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ScriptableCocoaApplications/SApps_handle_AEs/SAppsHandleAEs.html#//apple_ref/doc/uid/20001239)
    ///
    /// Each application has at most one instance of `NSAppleEventManager`. To obtain a reference to it, you call the class method [`sharedAppleEventManager`](https://developer.apple.com/documentation/foundation/nsappleeventmanager/shared()), which creates the instance if it doesnâ€™t already exist.
    ///
    /// For information about the Apple Event Manager, see [Apple Event Manager](https://developer.apple.com/documentation/applicationservices/apple_event_manager) and Apple Events Programming Guide.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSAppleEventManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSAppleEventManager {}
);

impl NSAppleEventManager {
    extern_methods!(
        #[unsafe(method(sharedAppleEventManager))]
        #[unsafe(method_family = none)]
        pub fn sharedAppleEventManager() -> Retained<NSAppleEventManager>;

        #[cfg(feature = "objc2-core-services")]
        #[cfg(target_vendor = "apple")]
        /// # Safety
        ///
        /// - `handler` should be of the correct type.
        /// - `handle_event_selector` must be a valid selector.
        #[unsafe(method(setEventHandler:andSelector:forEventClass:andEventID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEventHandler_andSelector_forEventClass_andEventID(
            &self,
            handler: &AnyObject,
            handle_event_selector: Sel,
            event_class: AEEventClass,
            event_id: AEEventID,
        );

        #[cfg(feature = "objc2-core-services")]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(removeEventHandlerForEventClass:andEventID:))]
        #[unsafe(method_family = none)]
        pub fn removeEventHandlerForEventClass_andEventID(
            &self,
            event_class: AEEventClass,
            event_id: AEEventID,
        );

        #[cfg(feature = "objc2-core-services")]
        #[cfg(target_vendor = "apple")]
        /// # Safety
        ///
        /// - `the_apple_event` must be a valid pointer.
        /// - `the_reply` must be a valid pointer.
        /// - `handler_ref_con` must be a valid pointer.
        #[unsafe(method(dispatchRawAppleEvent:withRawReply:handlerRefCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dispatchRawAppleEvent_withRawReply_handlerRefCon(
            &self,
            the_apple_event: NonNull<AppleEvent>,
            the_reply: NonNull<AppleEvent>,
            handler_ref_con: SRefCon,
        ) -> OSErr;

        #[cfg(feature = "NSAppleEventDescriptor")]
        #[unsafe(method(currentAppleEvent))]
        #[unsafe(method_family = none)]
        pub fn currentAppleEvent(&self) -> Option<Retained<NSAppleEventDescriptor>>;

        #[cfg(feature = "NSAppleEventDescriptor")]
        #[unsafe(method(currentReplyAppleEvent))]
        #[unsafe(method_family = none)]
        pub fn currentReplyAppleEvent(&self) -> Option<Retained<NSAppleEventDescriptor>>;

        #[unsafe(method(suspendCurrentAppleEvent))]
        #[unsafe(method_family = none)]
        pub fn suspendCurrentAppleEvent(&self) -> NSAppleEventManagerSuspensionID;

        #[cfg(feature = "NSAppleEventDescriptor")]
        /// # Safety
        ///
        /// `suspension_id` must be a valid pointer.
        #[unsafe(method(appleEventForSuspensionID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn appleEventForSuspensionID(
            &self,
            suspension_id: NSAppleEventManagerSuspensionID,
        ) -> Retained<NSAppleEventDescriptor>;

        #[cfg(feature = "NSAppleEventDescriptor")]
        /// # Safety
        ///
        /// `suspension_id` must be a valid pointer.
        #[unsafe(method(replyAppleEventForSuspensionID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn replyAppleEventForSuspensionID(
            &self,
            suspension_id: NSAppleEventManagerSuspensionID,
        ) -> Retained<NSAppleEventDescriptor>;

        /// # Safety
        ///
        /// `suspension_id` must be a valid pointer.
        #[unsafe(method(setCurrentAppleEventAndReplyEventWithSuspensionID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCurrentAppleEventAndReplyEventWithSuspensionID(
            &self,
            suspension_id: NSAppleEventManagerSuspensionID,
        );

        /// # Safety
        ///
        /// `suspension_id` must be a valid pointer.
        #[unsafe(method(resumeWithSuspensionID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn resumeWithSuspensionID(&self, suspension_id: NSAppleEventManagerSuspensionID);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSAppleEventManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSAppleEventManager {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
