//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Options for adding a new file version.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSFileVersionAddingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSFileVersionAddingOptions: NSUInteger {
///
/// ## Discussion
///
/// When adding a file, you can specify this option if you want to create the version by moving the source file to the specified location.
///
///
        #[doc(alias = "NSFileVersionAddingByMoving")]
        const ByMoving = 1<<0;
    }
}

unsafe impl Encode for NSFileVersionAddingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFileVersionAddingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for replacing a file version.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSFileVersionReplacingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSFileVersionReplacingOptions: NSUInteger {
/// An option to perform replacing by moving a file.
///
/// ## Discussion
///
/// This option results in moving the old version of the file out of the version store instead of copying the new contents into the fileâ€™s version. Use this option in conjunction with a file coordinator to make sure the operation is coordinated with other clients of the file.
///
///
        #[doc(alias = "NSFileVersionReplacingByMoving")]
        const ByMoving = 1<<0;
    }
}

unsafe impl Encode for NSFileVersionReplacingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSFileVersionReplacingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A snapshot of a file at a specific point in time.
    ///
    /// ## Overview
    ///
    /// Use the methods of this class to access, create, and manage file revisions in your app.
    ///
    /// Each file version instance contains metadata about a single revision, including the location of the associated file, the modification date of the revision, and whether the revision is discardable.
    ///
    /// In Mac apps, you can use file version objects to track changes to a local file over time and to prevent the loss of data during editing. When managing local versions, the document architecture creates versions at specific points in the lifetime of your application. Your application can also create versions explicitly at times that your application designates as appropriate.
    ///
    /// In addition to managing local files, the system also uses this class to manage cloud-based files. For files in the cloud, there is usually only one version of the file at any given time. However, additional file versions may be created in cases where two different computers attempt to save the file to the cloud at the same time. In that case, one file is chosen as the current version and any other versions are tagged as being in conflict with the original. Conflict versions are reported to the appropriate file presenter objects and should be resolved as soon as possible so that the corresponding files can be removed from the cloud.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSFileVersion;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSFileVersion {}
);

impl NSFileVersion {
    extern_methods!(
        #[cfg(feature = "NSURL")]
        #[unsafe(method(currentVersionOfItemAtURL:))]
        #[unsafe(method_family = none)]
        pub fn currentVersionOfItemAtURL(url: &NSURL) -> Option<Retained<NSFileVersion>>;

        #[cfg(all(feature = "NSArray", feature = "NSURL"))]
        #[unsafe(method(otherVersionsOfItemAtURL:))]
        #[unsafe(method_family = none)]
        pub fn otherVersionsOfItemAtURL(url: &NSURL) -> Option<Retained<NSArray<NSFileVersion>>>;

        #[cfg(all(feature = "NSArray", feature = "NSURL"))]
        #[unsafe(method(unresolvedConflictVersionsOfItemAtURL:))]
        #[unsafe(method_family = none)]
        pub fn unresolvedConflictVersionsOfItemAtURL(
            url: &NSURL,
        ) -> Option<Retained<NSArray<NSFileVersion>>>;

        #[cfg(all(
            feature = "NSArray",
            feature = "NSError",
            feature = "NSURL",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(getNonlocalVersionsOfItemAtURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getNonlocalVersionsOfItemAtURL_completionHandler(
            url: &NSURL,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<NSFileVersion>, *mut NSError),
            >,
        );

        #[cfg(feature = "NSURL")]
        /// # Safety
        ///
        /// `persistent_identifier` should be of the correct type.
        #[unsafe(method(versionOfItemAtURL:forPersistentIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn versionOfItemAtURL_forPersistentIdentifier(
            url: &NSURL,
            persistent_identifier: &AnyObject,
        ) -> Option<Retained<NSFileVersion>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(addVersionOfItemAtURL:withContentsOfURL:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn addVersionOfItemAtURL_withContentsOfURL_options_error(
            url: &NSURL,
            contents_url: &NSURL,
            options: NSFileVersionAddingOptions,
        ) -> Result<Retained<NSFileVersion>, Retained<NSError>>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(temporaryDirectoryURLForNewVersionOfItemAtURL:))]
        #[unsafe(method_family = none)]
        pub fn temporaryDirectoryURLForNewVersionOfItemAtURL(url: &NSURL) -> Retained<NSURL>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(URL))]
        #[unsafe(method_family = none)]
        pub fn URL(&self) -> Retained<NSURL>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(localizedName))]
        #[unsafe(method_family = none)]
        pub fn localizedName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(localizedNameOfSavingComputer))]
        #[unsafe(method_family = none)]
        pub fn localizedNameOfSavingComputer(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSPersonNameComponents")]
        #[unsafe(method(originatorNameComponents))]
        #[unsafe(method_family = none)]
        pub fn originatorNameComponents(&self) -> Option<Retained<NSPersonNameComponents>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(modificationDate))]
        #[unsafe(method_family = none)]
        pub fn modificationDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSObject")]
        #[unsafe(method(persistentIdentifier))]
        #[unsafe(method_family = none)]
        pub fn persistentIdentifier(&self) -> Retained<ProtocolObject<dyn NSCoding>>;

        #[unsafe(method(isConflict))]
        #[unsafe(method_family = none)]
        pub fn isConflict(&self) -> bool;

        #[unsafe(method(isResolved))]
        #[unsafe(method_family = none)]
        pub fn isResolved(&self) -> bool;

        /// Setter for [`isResolved`][Self::isResolved].
        #[unsafe(method(setResolved:))]
        #[unsafe(method_family = none)]
        pub fn setResolved(&self, resolved: bool);

        #[unsafe(method(isDiscardable))]
        #[unsafe(method_family = none)]
        pub fn isDiscardable(&self) -> bool;

        /// Setter for [`isDiscardable`][Self::isDiscardable].
        #[unsafe(method(setDiscardable:))]
        #[unsafe(method_family = none)]
        pub fn setDiscardable(&self, discardable: bool);

        #[unsafe(method(hasLocalContents))]
        #[unsafe(method_family = none)]
        pub fn hasLocalContents(&self) -> bool;

        #[unsafe(method(hasThumbnail))]
        #[unsafe(method_family = none)]
        pub fn hasThumbnail(&self) -> bool;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(replaceItemAtURL:options:error:_))]
        #[unsafe(method_family = none)]
        pub fn replaceItemAtURL_options_error(
            &self,
            url: &NSURL,
            options: NSFileVersionReplacingOptions,
        ) -> Result<Retained<NSURL>, Retained<NSError>>;

        #[cfg(feature = "NSError")]
        #[unsafe(method(removeAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub fn removeAndReturnError(&self) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(removeOtherVersionsOfItemAtURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn removeOtherVersionsOfItemAtURL_error(url: &NSURL) -> Result<(), Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSFileVersion {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSFileVersion {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
