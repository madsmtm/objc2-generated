//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// The attributes you apply to ranges of characters in an attributed string.
///
/// ## Discussion
///
/// The [`NSAttributedStringKey`](https://developer.apple.com/documentation/foundation/nsattributedstring/key) type defines the attributes you apply to ranges of characters in an attributed string. Some attributes provide information about how to render, lay out, or interpret the text, while other attributes provide transient or collaborative information. Attributes like the [`font`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/font), [`kern`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/kern), and [`strokeColor`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/strokecolor) contain information that the rendering system uses to display the text. Attributes like the [`spellingState`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/spellingstate), [`textHighlightStyle`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/texthighlightstyle), or [`accessibilityCustomText`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/accessibilitycustomtext) contain semantic information from other parts of the system. Some of these semantic attributes also affect how the system renders the text, but they are transient attributes unlike the core rendering attributes.
///
///
// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSAttributedStringKey = NSString;

// NS_TYPED_EXTENSIBLE_ENUM
#[cfg(feature = "NSString")]
pub type NSAttributedStringFormattingContextKey = NSString;

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSInflectionConceptsKey: &'static NSAttributedStringFormattingContextKey;
}

extern_class!(
    /// A string of text that manages data, layout, and stylistic information for ranges of characters to support rendering.
    ///
    /// ## Overview
    ///
    /// [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) is a type you use to manage strings of stylized Unicode text. In addition to text, an attributed string contains key-value pairs known as _attributes_ that specify additional information to apply to ranges of characters within the string. Attributed strings support many different kinds of attributes, including:
    ///
    /// - Rendering attributes that specify font, color, kern, ligature, and other details
    ///
    /// - Attributes for attachments and adaptive image glyphs
    ///
    /// - Semantic attributes such as link URLs or tool-tip information
    ///
    /// - Language attributes to support automatic gender agreement and text layout
    ///
    /// - Accessibility attributes that provide information for assistive technologies
    ///
    /// - Attributes that summarize details of the Markdown import process
    ///
    /// - Custom attributes you define for your app
    ///
    /// Use attributed strings anywhere you need styled text, or when you need to associate additional information with your text. Because [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) is an immutable type, you specify all of the text and attributes for it at creation time and can’t change them later. You can create attributed strings directly from a string of characters and a dictionary of attributes. You can also create attributed strings from the contents of a file, including files that contain RTF, RTFD, HTML, Markdown, or other file formats. If you need to modify the contents of an attributed string later, use the [`NSMutableAttributedString`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring) type instead.
    ///
    /// If you create an [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) without any font information, the string’s default font is Helvetica 12-point, which might differ from the default system font for the platform. To change the font, specify a font attribute at creation time.
    ///
    /// ### Persistence
    ///
    /// Be aware of how you persist attributed strings to and from the disk. RTF and RTFD are the preferred format for attributed strings because they offer the best fidelity for reading and writing attribute data. The RTF formats support a large number of standard attributes, and Apple extends the formats to support many Apple-specific attributes. If you define custom attributes for ranges of characters, store them separately alongside the RTF file for your text.
    ///
    /// If you work extensively with HTML content, validate the results and performance of import and export operations during testing. WebKit handles the conversion between HTML markup and attributed strings. If an HTML file contains tags or constructs that attributed strings don’t support, the import process ignores them and imports what it can.
    ///
    /// When you create an attributed string from Markdown, the system adds presentation intent attributes with information about the original Markdown content. The system doesn’t add style attributes to match the Markdown elements, but the system applies default style information when it renders a string with intent attributes. To change the rendering behavior of your Markdown content, remove the intent attributes and add the style attributes you prefer.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  When reading or writing attributed strings, choose methods that return or throw an error, and check any errors you receive. Handling errors is the best way to detect issues with the import or export process and take corrective action.
    ///
    ///
    ///
    /// </div>
    /// The methods for reading and writing common file formats also support document attributes. Document attributes aren’t part of the attributed string itself, but accompany the text when you save it to a file. When you read a file, the system returns any document attributes that it finds. Similarly, when you write an attributed string to a file, you can specify the attributes to include. For more information about document attributes, see [`NSAttributedString.DocumentAttributeKey`](https://developer.apple.com/documentation/foundation/nsattributedstring/documentattributekey) and [`NSAttributedString.DocumentReadingOptionKey`](https://developer.apple.com/documentation/foundation/nsattributedstring/documentreadingoptionkey).
    ///
    /// ### System framework interoperability
    ///
    /// [TextKit](https://developer.apple.com/documentation/uikit/textkit) and [`Core Text`](https://developer.apple.com/documentation/coretext) use attributed strings extensively during the layout and rendering processes. These technologies use the string’s text and rendering-related attributes to calculate the text metrics needed during layout. Similarly, these technologies apply those same attributes during rendering to give the text its styled appearance. The technologies use only attributes that directly affect the appearance of the text, and ignore most other attributes. For some attributes, the text system adds attributes during rendering as needed. For example, the text system provides default style attributes for text with the [`link`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/link) attribute.
    ///
    /// [`AppKit`](https://developer.apple.com/documentation/appkit) and [`UIKit`](https://developer.apple.com/documentation/uikit) also support attributed strings in several ways. Some views and controls in these frameworks have APIs that accept attributed strings, and render the string with its style information. The frameworks also add methods to the [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) class that let you draw a styled string directly in one of your custom views. Because these methods use TextKit to draw the string, they recognize the same rendering-related attributes as that technology.
    ///
    /// The [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) class and its Core Foundation counterpart, [`CFAttributedStringRef`](https://developer.apple.com/documentation/corefoundation/cfattributedstring), are toll-free bridged, which means you can use the two types interchangeably in your code without losing any text or attribute information.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSAttributedString;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSAttributedString> for CFAttributedString {
    #[inline]
    fn as_ref(&self) -> &NSAttributedString {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFAttributedString> for NSAttributedString {
    #[inline]
    fn as_ref(&self) -> &CFAttributedString {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSAttributedString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSAttributedString {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSAttributedString {
    type Result = Self;
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSMutableCopying for NSAttributedString {}
);

#[cfg(feature = "NSObject")]
unsafe impl MutableCopyingHelper for NSAttributedString {
    type Result = NSMutableAttributedString;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSAttributedString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSAttributedString {}
);

impl NSAttributedString {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(string))]
        #[unsafe(method_family = none)]
        pub fn string(&self) -> Retained<NSString>;

        #[cfg(all(feature = "NSDictionary", feature = "NSRange", feature = "NSString"))]
        /// # Safety
        ///
        /// `range` must be a valid pointer or null.
        #[unsafe(method(attributesAtIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attributesAtIndex_effectiveRange(
            &self,
            location: NSUInteger,
            range: NSRangePointer,
        ) -> Retained<NSDictionary<NSAttributedStringKey, AnyObject>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSAttributedString {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSAttributedString {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// Options for enumerating attributes.
///
/// ## Overview
///
/// These constants describe the options available to the [`enumerateAttribute:inRange:options:usingBlock:`](https://developer.apple.com/documentation/foundation/nsattributedstring/enumerateattribute(_:in:options:using:)) and [`enumerateAttributesInRange:options:usingBlock:`](https://developer.apple.com/documentation/foundation/nsattributedstring/enumerateattributes(in:options:using:)) methods.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSAttributedStringEnumerationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSAttributedStringEnumerationOptions: NSUInteger {
/// Causes the enumeration to occur in reverse.
        #[doc(alias = "NSAttributedStringEnumerationReverse")]
        const Reverse = 1<<1;
/// If `NSAttributedStringEnumerationLongestEffectiveRangeNotRequired` option is supplied, then the longest effective range computation is not performed; the blocks may be invoked with consecutive attribute runs that have the same value.
        #[doc(alias = "NSAttributedStringEnumerationLongestEffectiveRangeNotRequired")]
        const LongestEffectiveRangeNotRequired = 1<<20;
    }
}

unsafe impl Encode for NSAttributedStringEnumerationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSAttributedStringEnumerationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// NSExtendedAttributedString.
impl NSAttributedString {
    extern_methods!(
        #[unsafe(method(length))]
        #[unsafe(method_family = none)]
        pub fn length(&self) -> NSUInteger;

        #[cfg(all(feature = "NSRange", feature = "NSString"))]
        /// # Safety
        ///
        /// `range` must be a valid pointer or null.
        #[unsafe(method(attribute:atIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attribute_atIndex_effectiveRange(
            &self,
            attr_name: &NSAttributedStringKey,
            location: NSUInteger,
            range: NSRangePointer,
        ) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSRange")]
        #[unsafe(method(attributedSubstringFromRange:))]
        #[unsafe(method_family = none)]
        pub fn attributedSubstringFromRange(&self, range: NSRange) -> Retained<NSAttributedString>;

        #[cfg(all(feature = "NSDictionary", feature = "NSRange", feature = "NSString"))]
        /// # Safety
        ///
        /// `range` must be a valid pointer or null.
        #[unsafe(method(attributesAtIndex:longestEffectiveRange:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attributesAtIndex_longestEffectiveRange_inRange(
            &self,
            location: NSUInteger,
            range: NSRangePointer,
            range_limit: NSRange,
        ) -> Retained<NSDictionary<NSAttributedStringKey, AnyObject>>;

        #[cfg(all(feature = "NSRange", feature = "NSString"))]
        /// # Safety
        ///
        /// `range` must be a valid pointer or null.
        #[unsafe(method(attribute:atIndex:longestEffectiveRange:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attribute_atIndex_longestEffectiveRange_inRange(
            &self,
            attr_name: &NSAttributedStringKey,
            location: NSUInteger,
            range: NSRangePointer,
            range_limit: NSRange,
        ) -> Option<Retained<AnyObject>>;

        #[unsafe(method(isEqualToAttributedString:))]
        #[unsafe(method_family = none)]
        pub fn isEqualToAttributedString(&self, other: &NSAttributedString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithString:))]
        #[unsafe(method_family = init)]
        pub fn initWithString(this: Allocated<Self>, str: &NSString) -> Retained<Self>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `attrs` generic should be of the correct type.
        #[unsafe(method(initWithString:attributes:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithString_attributes(
            this: Allocated<Self>,
            str: &NSString,
            attrs: Option<&NSDictionary<NSAttributedStringKey, AnyObject>>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithAttributedString:))]
        #[unsafe(method_family = init)]
        pub fn initWithAttributedString(
            this: Allocated<Self>,
            attr_str: &NSAttributedString,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSRange",
            feature = "NSString",
            feature = "block2"
        ))]
        #[unsafe(method(enumerateAttributesInRange:options:usingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateAttributesInRange_options_usingBlock(
            &self,
            enumeration_range: NSRange,
            opts: NSAttributedStringEnumerationOptions,
            block: &block2::DynBlock<
                dyn Fn(
                        NonNull<NSDictionary<NSAttributedStringKey, AnyObject>>,
                        NSRange,
                        NonNull<Bool>,
                    ) + '_,
            >,
        );

        #[cfg(all(feature = "NSRange", feature = "NSString", feature = "block2"))]
        #[unsafe(method(enumerateAttribute:inRange:options:usingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateAttribute_inRange_options_usingBlock(
            &self,
            attr_name: &NSAttributedStringKey,
            enumeration_range: NSRange,
            opts: NSAttributedStringEnumerationOptions,
            block: &block2::DynBlock<dyn Fn(*mut AnyObject, NSRange, NonNull<Bool>) + '_>,
        );
    );
}

/// Methods declared on superclass `NSAttributedString`.
///
/// NSExtendedAttributedString.
impl NSMutableAttributedString {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithString:))]
        #[unsafe(method_family = init)]
        pub fn initWithString(this: Allocated<Self>, str: &NSString) -> Retained<Self>;

        #[cfg(all(feature = "NSDictionary", feature = "NSString"))]
        /// # Safety
        ///
        /// `attrs` generic should be of the correct type.
        #[unsafe(method(initWithString:attributes:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithString_attributes(
            this: Allocated<Self>,
            str: &NSString,
            attrs: Option<&NSDictionary<NSAttributedStringKey, AnyObject>>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithAttributedString:))]
        #[unsafe(method_family = init)]
        pub fn initWithAttributedString(
            this: Allocated<Self>,
            attr_str: &NSAttributedString,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// A mutable string with associated attributes (such as visual style, hyperlinks, or accessibility data) for portions of its text.
    ///
    /// ## Overview
    ///
    /// The `NSMutableAttributedString` class declares additional methods for mutating the content of an attributed string. You can add and remove characters (raw strings) and attributes separately or together as attributed strings. See the class description for [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) for more information about attributed strings.
    ///
    /// `NSMutableAttributedString` adds two primitive methods to those of `NSAttributedString`. These primitive methods provide the basis for all the other methods in its class. The primitive [`replaceCharactersInRange:withString:`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring/replacecharacters(in:with:)-6oq9r) method replaces a range of characters with those from a string, leaving all attribute information outside that range intact. The primitive [`setAttributes:range:`](https://developer.apple.com/documentation/foundation/nsmutableattributedstring/setattributes(_:range:)) method sets attributes and values for a given range of characters, replacing any previous attributes and values for that range.
    ///
    /// In macOS, AppKit also uses [`NSParagraphStyle`](https://developer.apple.com/documentation/appkit/nsparagraphstyle) and its subclass [`NSMutableParagraphStyle`](https://developer.apple.com/documentation/appkit/nsmutableparagraphstyle) to encapsulate the paragraph or ruler attributes used by the `NSAttributedString` classes.
    ///
    /// Note that the default font for `NSAttributedString` objects is Helvetica 12-point, which may differ from the macOS system font, so you may wish to create the string with non-default attributes suitable for your application using, for example, [`initWithString:attributes:`](https://developer.apple.com/documentation/foundation/nsattributedstring/init(string:attributes:)).
    ///
    /// <div class="warning">
    ///
    /// ### iOS Note
    ///  In iOS, this class is used primarily in conjunction with the Core Text framework.
    ///
    ///
    ///
    /// </div>
    /// `NSMutableAttributedString` is “toll-free bridged” with its Core Foundation counterpart, [`CFMutableAttributedStringRef`](https://developer.apple.com/documentation/corefoundation/cfmutableattributedstring). See [Toll-Free Bridging](https://developer.apple.com/library/archive/documentation/General/Conceptual/CocoaEncyclopedia/Toll-FreeBridgin/Toll-FreeBridgin.html#//apple_ref/doc/uid/TP40010810-CH2) for more information.
    ///
    ///
    #[unsafe(super(NSAttributedString, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMutableAttributedString;
);

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<NSMutableAttributedString> for CFMutableAttributedString {
    #[inline]
    fn as_ref(&self) -> &NSMutableAttributedString {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AsRef<CFMutableAttributedString> for NSMutableAttributedString {
    #[inline]
    fn as_ref(&self) -> &CFMutableAttributedString {
        unsafe { &*((self as *const Self).cast()) }
    }
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSMutableAttributedString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSMutableAttributedString {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSMutableAttributedString {
    type Result = NSAttributedString;
}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSMutableCopying for NSMutableAttributedString {}
);

#[cfg(feature = "NSObject")]
unsafe impl MutableCopyingHelper for NSMutableAttributedString {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSMutableAttributedString {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSMutableAttributedString {}
);

impl NSMutableAttributedString {
    extern_methods!(
        #[cfg(all(feature = "NSRange", feature = "NSString"))]
        #[unsafe(method(replaceCharactersInRange:withString:))]
        #[unsafe(method_family = none)]
        pub fn replaceCharactersInRange_withString(&self, range: NSRange, str: &NSString);

        #[cfg(all(feature = "NSDictionary", feature = "NSRange", feature = "NSString"))]
        /// # Safety
        ///
        /// `attrs` generic should be of the correct type.
        #[unsafe(method(setAttributes:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAttributes_range(
            &self,
            attrs: Option<&NSDictionary<NSAttributedStringKey, AnyObject>>,
            range: NSRange,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSMutableAttributedString {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSMutableAttributedString {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSExtendedMutableAttributedString.
impl NSMutableAttributedString {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[unsafe(method(mutableString))]
        #[unsafe(method_family = none)]
        pub fn mutableString(&self) -> Retained<NSMutableString>;

        #[cfg(all(feature = "NSRange", feature = "NSString"))]
        /// # Safety
        ///
        /// `value` should be of the correct type.
        #[unsafe(method(addAttribute:value:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAttribute_value_range(
            &self,
            name: &NSAttributedStringKey,
            value: &AnyObject,
            range: NSRange,
        );

        #[cfg(all(feature = "NSDictionary", feature = "NSRange", feature = "NSString"))]
        /// # Safety
        ///
        /// `attrs` generic should be of the correct type.
        #[unsafe(method(addAttributes:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAttributes_range(
            &self,
            attrs: &NSDictionary<NSAttributedStringKey, AnyObject>,
            range: NSRange,
        );

        #[cfg(all(feature = "NSRange", feature = "NSString"))]
        #[unsafe(method(removeAttribute:range:))]
        #[unsafe(method_family = none)]
        pub fn removeAttribute_range(&self, name: &NSAttributedStringKey, range: NSRange);

        #[cfg(feature = "NSRange")]
        #[unsafe(method(replaceCharactersInRange:withAttributedString:))]
        #[unsafe(method_family = none)]
        pub fn replaceCharactersInRange_withAttributedString(
            &self,
            range: NSRange,
            attr_string: &NSAttributedString,
        );

        #[unsafe(method(insertAttributedString:atIndex:))]
        #[unsafe(method_family = none)]
        pub fn insertAttributedString_atIndex(
            &self,
            attr_string: &NSAttributedString,
            loc: NSUInteger,
        );

        #[unsafe(method(appendAttributedString:))]
        #[unsafe(method_family = none)]
        pub fn appendAttributedString(&self, attr_string: &NSAttributedString);

        #[cfg(feature = "NSRange")]
        #[unsafe(method(deleteCharactersInRange:))]
        #[unsafe(method_family = none)]
        pub fn deleteCharactersInRange(&self, range: NSRange);

        #[unsafe(method(setAttributedString:))]
        #[unsafe(method_family = none)]
        pub fn setAttributedString(&self, attr_string: &NSAttributedString);

        #[unsafe(method(beginEditing))]
        #[unsafe(method_family = none)]
        pub fn beginEditing(&self);

        #[unsafe(method(endEditing))]
        #[unsafe(method_family = none)]
        pub fn endEditing(&self);
    );
}

/// A type that defines presentation intent for runs of characters for traits like emphasis, strikethrough, and code voice.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSInlinePresentationIntent(pub NSUInteger);
bitflags::bitflags! {
    impl NSInlinePresentationIntent: NSUInteger {
/// An intent that represents an emphasized presentation.
        #[doc(alias = "NSInlinePresentationIntentEmphasized")]
        const Emphasized = 1<<0;
/// An intent that represents a strongly emphasized presentation.
        #[doc(alias = "NSInlinePresentationIntentStronglyEmphasized")]
        const StronglyEmphasized = 1<<1;
/// An intent that represents a code voice presentation.
        #[doc(alias = "NSInlinePresentationIntentCode")]
        const Code = 1<<2;
/// An intent that represents a strikethrough presentation.
        #[doc(alias = "NSInlinePresentationIntentStrikethrough")]
        const Strikethrough = 1<<5;
/// An intent that represents a soft line break.
        #[doc(alias = "NSInlinePresentationIntentSoftBreak")]
        const SoftBreak = 1<<6;
/// An intent that represents a line break.
        #[doc(alias = "NSInlinePresentationIntentLineBreak")]
        const LineBreak = 1<<7;
/// An intent that represents an inline HTML presentation.
        #[doc(alias = "NSInlinePresentationIntentInlineHTML")]
        const InlineHTML = 1<<8;
/// An intent that represents a block HTML presentation.
        #[doc(alias = "NSInlinePresentationIntentBlockHTML")]
        const BlockHTML = 1<<9;
    }
}

unsafe impl Encode for NSInlinePresentationIntent {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSInlinePresentationIntent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// An attribute that provides details for an inline Markdown element.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) that contains a value from the [`NSInlinePresentationIntent`](https://developer.apple.com/documentation/foundation/inlinepresentationintent) type. This value indicates the Markdown formatting to apply to the range of text.
    ///
    /// The system provides default visual treatments for ranges of text with this attribute. To replace the default visual treatment, remove this attribute and replace it with the formatting options you want.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSInlinePresentationIntentAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    /// An alternate description for a URL or image.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) with the alternate description of the URL or image.
    ///
    /// When a Markdown link contains a title string, the system adds this key to the link text and sets the value to the title. For example, in the Markdown tect `[Visit the Apple Store](https://store.apple.com “The Apple Store website”)`, the system sets the value of this key to `The Apple Store website`.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSAlternateDescriptionAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    /// The URL for an image in Markdown text.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) with the link to the image.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSImageURLAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    /// The language identifier associated with the range of text.
    ///
    /// ## Discussion
    ///
    /// The value of this property is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) with the language identifier code in ISO 639 format.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSLanguageIdentifierAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    /// The position in a Markdown source string corresponding to some attributed text.
    ///
    /// ## Discussion
    ///
    /// This attribute indicates the position in the Markdown source where a run of attributed text begins and ends, omitting markup characters in the source. For example, after parsing the source string `“This is *emphasized*.”`, the text `emphasized` has a Markdown source position that starts at column `10`. This index is the `“e”` character, not the `“*”` formatting character.
    ///
    /// An attributed string parsed from Markdown text includes this attribute only if the [`appliesSourcePositionAttributes`](https://developer.apple.com/documentation/foundation/nsattributedstringmarkdownparsingoptions/appliessourcepositionattributes) value in the directory of [`NSAttributedString.DocumentReadingOptionKey`](https://developer.apple.com/documentation/foundation/nsattributedstring/documentreadingoptionkey) options provided to the [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) initializer is `YES`.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSMarkdownSourcePositionAttributeName: &'static NSAttributedStringKey;
}

/// A type that represents policies for handling parsing failures.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSAttributedStringMarkdownParsingFailurePolicy(pub NSInteger);
impl NSAttributedStringMarkdownParsingFailurePolicy {
    /// A policy to return an error from the initializer if parsing fails.
    #[doc(alias = "NSAttributedStringMarkdownParsingFailureReturnError")]
    pub const ReturnError: Self = Self(0);
    /// A policy to return a partially parsed string, if possible.
    ///
    /// ## Discussion
    ///
    /// With this policy, the returned string may include unparsed markup. If returning a partially parsed string isn’t possible, the parser may return an error anyway.
    ///
    ///
    #[doc(alias = "NSAttributedStringMarkdownParsingFailureReturnPartiallyParsedIfPossible")]
    pub const ReturnPartiallyParsedIfPossible: Self = Self(1);
}

unsafe impl Encode for NSAttributedStringMarkdownParsingFailurePolicy {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSAttributedStringMarkdownParsingFailurePolicy {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A type that represents the syntax for intepreting a Markdown string.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSAttributedStringMarkdownInterpretedSyntax(pub NSInteger);
impl NSAttributedStringMarkdownInterpretedSyntax {
    /// A syntax value that interprets the full Markdown syntax and produces all relevant attributes.
    #[doc(alias = "NSAttributedStringMarkdownInterpretedSyntaxFull")]
    pub const Full: Self = Self(0);
    /// A syntax value that parses all Markdown text, but interprets only attributes that apply to inline spans.
    ///
    /// ## Discussion
    ///
    /// With this syntax, the parser doesn’t apply attributes that differentiate blocks, like [`presentationIntentAttributeName`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/presentationintentattributename). However, extended attributes apply to inline spans, so the parser includes them, if the [`allowsExtendedAttributes`](https://developer.apple.com/documentation/foundation/nsattributedstringmarkdownparsingoptions/allowsextendedattributes) property allows them.
    ///
    ///
    #[doc(alias = "NSAttributedStringMarkdownInterpretedSyntaxInlineOnly")]
    pub const InlineOnly: Self = Self(1);
    /// A syntax value that parses all Markdown text, but interprets only attributes that apply to inline spans, perserving white space.
    ///
    /// ## Discussion
    ///
    /// This value behaves like [`NSAttributedStringMarkdownInterpretedSyntaxInlineOnly`](https://developer.apple.com/documentation/foundation/nsattributedstringmarkdowninterpretedsyntax/nsattributedstringmarkdowninterpretedsyntaxinlineonly), but doesn’t interpret multiple consecutive instances of white space as a single separator space. All whitespace characters appear in the result as the source specifies.
    ///
    ///
    #[doc(alias = "NSAttributedStringMarkdownInterpretedSyntaxInlineOnlyPreservingWhitespace")]
    pub const InlineOnlyPreservingWhitespace: Self = Self(2);
}

unsafe impl Encode for NSAttributedStringMarkdownInterpretedSyntax {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSAttributedStringMarkdownInterpretedSyntax {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The position of attributed string text in its original Markdown source string.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSAttributedStringMarkdownSourcePosition;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSAttributedStringMarkdownSourcePosition {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSAttributedStringMarkdownSourcePosition {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSAttributedStringMarkdownSourcePosition {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSAttributedStringMarkdownSourcePosition {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSAttributedStringMarkdownSourcePosition {}
);

impl NSAttributedStringMarkdownSourcePosition {
    extern_methods!(
        #[unsafe(method(startLine))]
        #[unsafe(method_family = none)]
        pub fn startLine(&self) -> NSInteger;

        #[unsafe(method(startColumn))]
        #[unsafe(method_family = none)]
        pub fn startColumn(&self) -> NSInteger;

        #[unsafe(method(endLine))]
        #[unsafe(method_family = none)]
        pub fn endLine(&self) -> NSInteger;

        #[unsafe(method(endColumn))]
        #[unsafe(method_family = none)]
        pub fn endColumn(&self) -> NSInteger;

        #[unsafe(method(initWithStartLine:startColumn:endLine:endColumn:))]
        #[unsafe(method_family = init)]
        pub fn initWithStartLine_startColumn_endLine_endColumn(
            this: Allocated<Self>,
            start_line: NSInteger,
            start_column: NSInteger,
            end_line: NSInteger,
            end_column: NSInteger,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSRange", feature = "NSString"))]
        #[unsafe(method(rangeInString:))]
        #[unsafe(method_family = none)]
        pub fn rangeInString(&self, string: &NSString) -> NSRange;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSAttributedStringMarkdownSourcePosition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSAttributedStringMarkdownSourcePosition {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// Options that affect the parsing of Markdown content into an attributed string.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSAttributedStringMarkdownParsingOptions;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSAttributedStringMarkdownParsingOptions {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSAttributedStringMarkdownParsingOptions {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSAttributedStringMarkdownParsingOptions {}
);

impl NSAttributedStringMarkdownParsingOptions {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(allowsExtendedAttributes))]
        #[unsafe(method_family = none)]
        pub fn allowsExtendedAttributes(&self) -> bool;

        /// Setter for [`allowsExtendedAttributes`][Self::allowsExtendedAttributes].
        #[unsafe(method(setAllowsExtendedAttributes:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsExtendedAttributes(&self, allows_extended_attributes: bool);

        #[unsafe(method(interpretedSyntax))]
        #[unsafe(method_family = none)]
        pub fn interpretedSyntax(&self) -> NSAttributedStringMarkdownInterpretedSyntax;

        /// Setter for [`interpretedSyntax`][Self::interpretedSyntax].
        #[unsafe(method(setInterpretedSyntax:))]
        #[unsafe(method_family = none)]
        pub fn setInterpretedSyntax(
            &self,
            interpreted_syntax: NSAttributedStringMarkdownInterpretedSyntax,
        );

        #[unsafe(method(failurePolicy))]
        #[unsafe(method_family = none)]
        pub fn failurePolicy(&self) -> NSAttributedStringMarkdownParsingFailurePolicy;

        /// Setter for [`failurePolicy`][Self::failurePolicy].
        #[unsafe(method(setFailurePolicy:))]
        #[unsafe(method_family = none)]
        pub fn setFailurePolicy(
            &self,
            failure_policy: NSAttributedStringMarkdownParsingFailurePolicy,
        );

        #[cfg(feature = "NSString")]
        #[unsafe(method(languageCode))]
        #[unsafe(method_family = none)]
        pub fn languageCode(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`languageCode`][Self::languageCode].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setLanguageCode:))]
        #[unsafe(method_family = none)]
        pub fn setLanguageCode(&self, language_code: Option<&NSString>);

        #[unsafe(method(appliesSourcePositionAttributes))]
        #[unsafe(method_family = none)]
        pub fn appliesSourcePositionAttributes(&self) -> bool;

        /// Setter for [`appliesSourcePositionAttributes`][Self::appliesSourcePositionAttributes].
        #[unsafe(method(setAppliesSourcePositionAttributes:))]
        #[unsafe(method_family = none)]
        pub fn setAppliesSourcePositionAttributes(&self, applies_source_position_attributes: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSAttributedStringMarkdownParsingOptions {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSAttributedStringMarkdownParsingOptions {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSAttributedStringCreateFromMarkdown.
impl NSAttributedString {
    extern_methods!(
        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithContentsOfMarkdownFileAtURL:options:baseURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfMarkdownFileAtURL_options_baseURL_error(
            this: Allocated<Self>,
            markdown_file: &NSURL,
            options: Option<&NSAttributedStringMarkdownParsingOptions>,
            base_url: Option<&NSURL>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSData", feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithMarkdown:options:baseURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithMarkdown_options_baseURL_error(
            this: Allocated<Self>,
            markdown: &NSData,
            options: Option<&NSAttributedStringMarkdownParsingOptions>,
            base_url: Option<&NSURL>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(initWithMarkdownString:options:baseURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithMarkdownString_options_baseURL_error(
            this: Allocated<Self>,
            markdown_string: &NSString,
            options: Option<&NSAttributedStringMarkdownParsingOptions>,
            base_url: Option<&NSURL>,
        ) -> Result<Retained<Self>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSAttributedString`.
///
/// NSAttributedStringCreateFromMarkdown.
impl NSMutableAttributedString {
    extern_methods!(
        #[cfg(all(feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithContentsOfMarkdownFileAtURL:options:baseURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfMarkdownFileAtURL_options_baseURL_error(
            this: Allocated<Self>,
            markdown_file: &NSURL,
            options: Option<&NSAttributedStringMarkdownParsingOptions>,
            base_url: Option<&NSURL>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSData", feature = "NSError", feature = "NSURL"))]
        #[unsafe(method(initWithMarkdown:options:baseURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithMarkdown_options_baseURL_error(
            this: Allocated<Self>,
            markdown: &NSData,
            options: Option<&NSAttributedStringMarkdownParsingOptions>,
            base_url: Option<&NSURL>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSError", feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(initWithMarkdownString:options:baseURL:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithMarkdownString_options_baseURL_error(
            this: Allocated<Self>,
            markdown_string: &NSString,
            options: Option<&NSAttributedStringMarkdownParsingOptions>,
            base_url: Option<&NSURL>,
        ) -> Result<Retained<Self>, Retained<NSError>>;
    );
}

/// Options to use when creating an attributed string from a format string and variable list of arguments.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSAttributedStringFormattingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSAttributedStringFormattingOptions: NSUInteger {
/// An option to replace the attributes in a substituted string with those of the provided attributed string.
///
/// ## Discussion
///
/// This option applies when a format string includes the %@ format string specifier and the substituted value is an attributed string. If you include this option, the creation method prefers the attributes in the substitute attributed string over the attributes in the format string. If you don’t include this option, the creation method prefers the attributes from the format string over those in the substitute string.
///
/// Consider a format string `“Name: %@”` that applies a red text color to the substituted value, and consider an attributed string that applies green text using the same attribute. If you don’t include this option, the substituted text in the new string is red. If you include the option, the substituted text is green. This option affects only attributes that are common to both the format string and the substitute string.
///
/// If a creation method doesn’t let you specify options, it behaves as if this option isn’t present.
///
///
        #[doc(alias = "NSAttributedStringFormattingInsertArgumentAttributesWithoutMerging")]
        const InsertArgumentAttributesWithoutMerging = 1<<0;
/// An option to apply to the replaced portions of text in a format string.
///
/// ## Discussion
///
/// When creating an attributed string from a format string, specify this option to apply an attribute to all substituted text. Consider the creation of an attributed string using the format string `“Count: %d; Total: %d”`. After generating the attributed string, the creation method applies the [`replacementIndex`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/replacementindex) attribute to the both integer values in the resulting string.
///
/// The value of the [`replacementIndex`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/replacementindex) attribute is an `NSNumber` with the replacement’s position in the format string. The value for the first replacement is 1, for the second replacement is 2, and so on. If you include a positional marker in the format string specifier, the value of the attribute reflects that position, regardless of its actual position in the string. For example, the string `“%2@ -- %1@”` causes the first argument to have an index value of `2` and the second argument to have an index value of `1`.
///
///
        #[doc(alias = "NSAttributedStringFormattingApplyReplacementIndexAttribute")]
        const ApplyReplacementIndexAttribute = 1<<1;
    }
}

unsafe impl Encode for NSAttributedStringFormattingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSAttributedStringFormattingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// NSAttributedStringFormatting.
impl NSAttributedString {
    extern_methods!();
}

/// NSMutableAttributedStringFormatting.
impl NSMutableAttributedString {
    extern_methods!();
}

extern "C" {
    /// The replacement position associated with a format string specifier.
    ///
    /// ## Discussion
    ///
    /// When creating an attributed string from a format string and one or more replacement values, this attribute indicates the ordinal index of each replacement. You must specify the [`NSAttributedStringFormattingApplyReplacementIndexAttribute`](https://developer.apple.com/documentation/foundation/nsattributedstringformattingoptions/nsattributedstringformattingapplyreplacementindexattribute) option at creation time to add this attribute to the substituted text. The value of this key is an `NSNumber` with the replacement position of the substitute text.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSReplacementIndexAttributeName: &'static NSAttributedStringKey;
}

/// NSMorphology.
impl NSAttributedString {
    extern_methods!(
        /// If the string has portions tagged with NSInflectionRuleAttributeName
        /// that have no format specifiers, create a new string with those portions inflected
        /// by following the rule in the attribute.
        #[unsafe(method(attributedStringByInflectingString))]
        #[unsafe(method_family = none)]
        pub fn attributedStringByInflectingString(&self) -> Retained<NSAttributedString>;
    );
}

extern "C" {
    /// An attribute that contains grammatical properties to apply to the text.
    ///
    /// ## Discussion
    ///
    /// The value of this property is an [`NSMorphology`](https://developer.apple.com/documentation/foundation/nsmorphology) object. Use the value to determine the appropriate gender and other grammatical rules to apply to the text.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSMorphologyAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    /// An attribute that tells the system how to apply grammar rules and other modifiers to the range of text.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSInflectionRule`](https://developer.apple.com/documentation/foundation/nsinflectionrule) object.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSInflectionRuleAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSInflectionAgreementArgumentAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSInflectionAgreementConceptAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSInflectionReferentConceptAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    /// The alternative translation for a string when no suitable inflection exists.
    ///
    /// ## Discussion
    ///
    /// In languages that change the form of words to match someone’s gender, the system can automatically change (or inflect) the gender to match someone’s personal preferences. If a suitable inflection doesn’t exist, the system uses the value of this attribute instead. Add this attribute to specify a suitable translation that applies to anyone. For example, if a language has only masculine and feminine genders, specify an appropriately neutral translation of the text.
    ///
    /// The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) with the replacement phrase to use.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSInflectionAlternativeAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSLocalizedNumberFormatAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    #[cfg(feature = "NSString")]
    pub static NSListItemDelimiterAttributeName: &'static NSAttributedStringKey;
}

extern "C" {
    /// An attribute that provides details for a block-level Markdown element.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSPresentationIntent`](https://developer.apple.com/documentation/foundation/nspresentationintent) object. Block-level elements include paragraphs, headers, lists, tables, and other structural elements of the Markdown content.
    ///
    /// The system provides default visual treatments for ranges of text with this attribute. To replace the default visual treatment, remove this attribute and replace it with the formatting options you want.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSPresentationIntentAttributeName: &'static NSAttributedStringKey;
}

/// An enumeration of intended display styles for blocks of text like paragraphs, lists, and code blocks.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSPresentationIntentKind(pub NSInteger);
impl NSPresentationIntentKind {
    /// A presentation style for a paragraph of text.
    #[doc(alias = "NSPresentationIntentKindParagraph")]
    pub const Paragraph: Self = Self(0);
    /// A presentation style for a section header.
    #[doc(alias = "NSPresentationIntentKindHeader")]
    pub const Header: Self = Self(1);
    /// A presentation style for an ordered list of items.
    #[doc(alias = "NSPresentationIntentKindOrderedList")]
    pub const OrderedList: Self = Self(2);
    /// A presentation style for an unordered list of items.
    #[doc(alias = "NSPresentationIntentKindUnorderedList")]
    pub const UnorderedList: Self = Self(3);
    /// A presentation style for a list of items.
    #[doc(alias = "NSPresentationIntentKindListItem")]
    pub const ListItem: Self = Self(4);
    /// A presentation style for a block of code.
    #[doc(alias = "NSPresentationIntentKindCodeBlock")]
    pub const CodeBlock: Self = Self(5);
    /// A presentation style for a block quote.
    #[doc(alias = "NSPresentationIntentKindBlockQuote")]
    pub const BlockQuote: Self = Self(6);
    /// A presentation style for a horizontal rule.
    #[doc(alias = "NSPresentationIntentKindThematicBreak")]
    pub const ThematicBreak: Self = Self(7);
    /// A presentation style for a table.
    #[doc(alias = "NSPresentationIntentKindTable")]
    pub const Table: Self = Self(8);
    /// A presentation style for the header row of a table.
    #[doc(alias = "NSPresentationIntentKindTableHeaderRow")]
    pub const TableHeaderRow: Self = Self(9);
    /// A presentation style for a row of a table.
    #[doc(alias = "NSPresentationIntentKindTableRow")]
    pub const TableRow: Self = Self(10);
    /// A presentation style for a single cell of a table.
    #[doc(alias = "NSPresentationIntentKindTableCell")]
    pub const TableCell: Self = Self(11);
}

unsafe impl Encode for NSPresentationIntentKind {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSPresentationIntentKind {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An enumeration of values for aligning the contents of table columns.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSPresentationIntentTableColumnAlignment(pub NSInteger);
impl NSPresentationIntentTableColumnAlignment {
    /// A presentation style for columns with left-aligned text.
    #[doc(alias = "NSPresentationIntentTableColumnAlignmentLeft")]
    pub const Left: Self = Self(0);
    /// A presentation style for columns with center-aligned text.
    #[doc(alias = "NSPresentationIntentTableColumnAlignmentCenter")]
    pub const Center: Self = Self(1);
    /// A presentation style for columns with right-aligned text.
    #[doc(alias = "NSPresentationIntentTableColumnAlignmentRight")]
    pub const Right: Self = Self(2);
}

unsafe impl Encode for NSPresentationIntentTableColumnAlignment {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSPresentationIntentTableColumnAlignment {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A type that contains the Markdown formatting for blocks of text, like paragraphs, lists, code blocks, and parts of tables.
    ///
    /// ## Overview
    ///
    /// An [`NSPresentationIntent`](https://developer.apple.com/documentation/foundation/nspresentationintent) object stores the Markdown semantics for a range of characters in an attributed string. When parsing Markdown into an attributed string, the system sets the value of the [`presentationIntentAttributeName`](https://developer.apple.com/documentation/foundation/nsattributedstring/key/presentationintentattributename) attribute to an instance of this class. When displaying your string in system views, the system applies a default visual style to match the corresponding information in this type. To replace the system’s default formatting, remove these attributes from your attributed string and apply the formatting you want.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSPresentationIntent;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCoding for NSPresentationIntent {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSPresentationIntent {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSPresentationIntent {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSPresentationIntent {}
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSSecureCoding for NSPresentationIntent {}
);

impl NSPresentationIntent {
    extern_methods!(
        #[unsafe(method(intentKind))]
        #[unsafe(method_family = none)]
        pub fn intentKind(&self) -> NSPresentationIntentKind;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(parentIntent))]
        #[unsafe(method_family = none)]
        pub fn parentIntent(&self) -> Option<Retained<NSPresentationIntent>>;

        #[unsafe(method(paragraphIntentWithIdentity:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn paragraphIntentWithIdentity_nestedInsideIntent(
            identity: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[unsafe(method(headerIntentWithIdentity:level:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn headerIntentWithIdentity_level_nestedInsideIntent(
            identity: NSInteger,
            level: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(codeBlockIntentWithIdentity:languageHint:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn codeBlockIntentWithIdentity_languageHint_nestedInsideIntent(
            identity: NSInteger,
            language_hint: Option<&NSString>,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[unsafe(method(thematicBreakIntentWithIdentity:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn thematicBreakIntentWithIdentity_nestedInsideIntent(
            identity: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[unsafe(method(orderedListIntentWithIdentity:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn orderedListIntentWithIdentity_nestedInsideIntent(
            identity: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[unsafe(method(unorderedListIntentWithIdentity:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn unorderedListIntentWithIdentity_nestedInsideIntent(
            identity: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[unsafe(method(listItemIntentWithIdentity:ordinal:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn listItemIntentWithIdentity_ordinal_nestedInsideIntent(
            identity: NSInteger,
            ordinal: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[unsafe(method(blockQuoteIntentWithIdentity:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn blockQuoteIntentWithIdentity_nestedInsideIntent(
            identity: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[cfg(all(feature = "NSArray", feature = "NSValue"))]
        #[unsafe(method(tableIntentWithIdentity:columnCount:alignments:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn tableIntentWithIdentity_columnCount_alignments_nestedInsideIntent(
            identity: NSInteger,
            column_count: NSInteger,
            alignments: &NSArray<NSNumber>,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[unsafe(method(tableHeaderRowIntentWithIdentity:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn tableHeaderRowIntentWithIdentity_nestedInsideIntent(
            identity: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[unsafe(method(tableRowIntentWithIdentity:row:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn tableRowIntentWithIdentity_row_nestedInsideIntent(
            identity: NSInteger,
            row: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        #[unsafe(method(tableCellIntentWithIdentity:column:nestedInsideIntent:))]
        #[unsafe(method_family = none)]
        pub fn tableCellIntentWithIdentity_column_nestedInsideIntent(
            identity: NSInteger,
            column: NSInteger,
            parent: Option<&NSPresentationIntent>,
        ) -> Retained<NSPresentationIntent>;

        /// An integer value which uniquely identifies this intent in the document. Identity disambiguates attributes which apply to contiguous text -- for example, two headers in a row with the same level. It can also be used to track the location in an attributed string of a particular part of a document, even after mutation.
        #[unsafe(method(identity))]
        #[unsafe(method_family = none)]
        pub fn identity(&self) -> NSInteger;

        /// If the intent is not a list, this value is 0.
        #[unsafe(method(ordinal))]
        #[unsafe(method_family = none)]
        pub fn ordinal(&self) -> NSInteger;

        #[cfg(all(feature = "NSArray", feature = "NSValue"))]
        /// If the intent is not a table, this value is `nil`.
        #[unsafe(method(columnAlignments))]
        #[unsafe(method_family = none)]
        pub fn columnAlignments(&self) -> Option<Retained<NSArray<NSNumber>>>;

        /// If the intent is not a table, this value is 0.
        #[unsafe(method(columnCount))]
        #[unsafe(method_family = none)]
        pub fn columnCount(&self) -> NSInteger;

        /// If the intent is not a header, this value is 0.
        #[unsafe(method(headerLevel))]
        #[unsafe(method_family = none)]
        pub fn headerLevel(&self) -> NSInteger;

        #[cfg(feature = "NSString")]
        /// If the intent is not a code block, this value is `nil`.
        #[unsafe(method(languageHint))]
        #[unsafe(method_family = none)]
        pub fn languageHint(&self) -> Option<Retained<NSString>>;

        /// The column to which this cell belongs (0-based). If the intent is not a cell, this value is 0.
        #[unsafe(method(column))]
        #[unsafe(method_family = none)]
        pub fn column(&self) -> NSInteger;

        /// The row to which this cell belongs (0-based). If the intent is not a row, this value is 0. Header rows are always row 0. If the table has more rows, those start at row 1.
        #[unsafe(method(row))]
        #[unsafe(method_family = none)]
        pub fn row(&self) -> NSInteger;

        /// The indentation level of this intent. Each nested list increases the indentation level by one; all elements within the same list (and not then nested into a child list intent) have the same indentation level.
        /// Text outside list intents has an indentation level of 0.
        #[unsafe(method(indentationLevel))]
        #[unsafe(method_family = none)]
        pub fn indentationLevel(&self) -> NSInteger;

        /// Returns `YES` if this intent is equivalent to the other presentation intent. Equivalence is the same as equality except that identity is not taken into account.
        #[unsafe(method(isEquivalentToPresentationIntent:))]
        #[unsafe(method_family = none)]
        pub fn isEquivalentToPresentationIntent(&self, other: &NSPresentationIntent) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSPresentationIntent {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
