//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern "C" {
    /// The total size of the transfer cannot be determined.
    pub static NSURLSessionTransferSizeUnknown: i64;
}

extern_class!(
    /// An object that coordinates a group of related, network data transfer tasks.
    ///
    /// ## Overview
    ///
    /// The [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) class and related classes provide an API for downloading data from and uploading data to endpoints indicated by URLs. Your app can also use this API to perform background downloads when your app isn’t running or, in iOS, while your app is suspended. You can use the related [`NSURLSessionDelegate`](https://developer.apple.com/documentation/foundation/urlsessiondelegate) and [`NSURLSessionTaskDelegate`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate) to support authentication and receive events like redirection and task completion.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) API involves many different classes that work together in a fairly complex way which may not be obvious if you read the reference documentation by itself. Before using the API, read the overview in the [URL Loading System](https://developer.apple.com/documentation/foundation/url-loading-system) topic. The articles in the Essentials, Uploading, and Downloading sections offer examples of performing common tasks with [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession).
    ///
    ///
    ///
    /// </div>
    /// Your app creates one or more [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) instances, each of which coordinates a group of related data-transfer tasks. For example, if you’re creating a web browser, your app might create one session per tab or window, or one session for interactive use and another for background downloads. Within each session, your app adds a series of tasks, each of which represents a request for a specific URL (following HTTP redirects, if necessary).
    ///
    /// ### Types of URL sessions
    ///
    /// The tasks within a given URL session share a common session configuration object, which defines connection behavior, like the maximum number of simultaneous connections to make to a single host, whether connections can use the cellular network, and so on.
    ///
    /// [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) has a singleton [`sharedSession`](https://developer.apple.com/documentation/foundation/urlsession/shared) session (which doesn’t have a configuration object) for basic requests. It’s not as customizable as sessions you create, but it serves as a good starting point if you have very limited requirements. You access this session by calling the shared class method. For other kinds of sessions, you create a [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) with one of three kinds of configurations:
    ///
    /// - A default session behaves much like the shared session, but lets you configure it. You can also assign a delegate to the default session to obtain data incrementally.
    ///
    /// - Ephemeral sessions are similar to shared sessions, but don’t write caches, cookies, or credentials to disk.
    ///
    /// - Background sessions let you perform uploads and downloads of content in the background while your app isn’t running.
    ///
    /// See Creating a session configuration object in the [`NSURLSessionConfiguration`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration) class for details on creating each type of configuration.
    ///
    /// ### Types of URL session tasks
    ///
    /// Within a session, you create tasks that optionally upload data to a server and then retrieve data from the server either as a file on disk or as one or more [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) objects in memory. The [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) API provides four types of tasks:
    ///
    /// - Data tasks send and receive data using [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) objects. Data tasks are intended for short, often interactive requests to a server.
    ///
    /// - Upload tasks are similar to data tasks, but they also send data (often in the form of a file), and support background uploads while the app isn’t running.
    ///
    /// - Download tasks retrieve data in the form of a file, and support background downloads and uploads while the app isn’t running.
    ///
    /// - WebSocket tasks exchange messages over TCP and TLS, using the WebSocket protocol defined in [RFC 6455](https://tools.ietf.org/html/rfc6455).
    ///
    /// ### Using a session delegate
    ///
    /// Tasks in a session also share a common delegate object. You implement this delegate to provide and obtain information when various events occur, including when:
    ///
    /// - Authentication fails.
    ///
    /// - Data arrives from the server.
    ///
    /// - Data becomes available for caching.
    ///
    /// If you don’t need the features provided by a delegate, you can use this API without providing one by passing `nil` when you create a session.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The session object keeps a strong reference to the delegate until your app exits or explicitly invalidates the session. If you don’t invalidate the session, your app leaks memory until the app terminates.
    ///
    ///
    ///
    /// </div>
    /// Each task you create with the session calls back to the session’s delegate, using the methods defined in [`NSURLSessionTaskDelegate`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate). You can also intercept these callbacks before they reach the session delegate by populating a separate [`delegate`](https://developer.apple.com/documentation/foundation/urlsessiontask/delegate) that’s specific to the task.
    ///
    /// ### Asynchronicity and URL sessions
    ///
    /// Like most networking APIs, the [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) API is highly asynchronous. It returns data to your app in one of three ways, depending on the methods you call:
    ///
    /// - If you’re using Swift, you can use the methods marked with the `async` keyword to perform common tasks. For example, [`data(from:delegate:)`](https://developer.apple.com/documentation/foundation/urlsession/data(from:delegate:)) fetches data, while [`download(from:delegate:)`](https://developer.apple.com/documentation/foundation/urlsession/download(from:delegate:)) downloads files. Your call point uses the `await` keyword to suspend running until the transfer completes. You can also use the [`bytes(from:delegate:)`](https://developer.apple.com/documentation/foundation/urlsession/bytes(from:delegate:)) method to receive data as an [`AsyncSequence`](https://developer.apple.com/documentation/swift/asyncsequence). With this approach, you use the `for`-`await`-`in` syntax to iterate over the data as your app receives it. The [`URL`](https://developer.apple.com/documentation/foundation/url) type also offers covenience methods to fetch bytes or lines from the shared URL session.
    ///
    /// - In Swift or Objective-C, you can provide a completion handler block, which runs when the transfer completes.
    ///
    /// - In Swift or Objective-C, you can receive callbacks to a delegate method as the transfer progresses and immediately after it completes.
    ///
    /// In addition to delivering this information to delegates, the [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) provides status and progress properties. Query these properties if you need to make programmatic decisions based on the current state of the task (with the caveat that its state can change at any time).
    ///
    /// ### Protocol support
    ///
    /// The [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) class natively supports the `data`, `file`, `ftp`, `http`, and `https` URL schemes, with transparent support for proxy servers and SOCKS gateways, as configured in the user’s system preferences.
    ///
    /// [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) supports the HTTP/1.1, HTTP/2, and HTTP/3 protocols. HTTP/2 support, as described by [RFC 7540](https://tools.ietf.org/html/rfc7540), requires a server that supports Application-Layer Protocol Negotiation (ALPN).
    ///
    /// You can also add support for your own custom networking protocols and URL schemes (for your app’s private use) by subclassing [`NSURLProtocol`](https://developer.apple.com/documentation/foundation/urlprotocol).
    ///
    /// ### App Transport Security (ATS)
    ///
    /// iOS 9.0 and macOS 10.11 and later use App Transport Security (ATS) for all HTTP connections made with [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession). ATS requires that HTTP connections use HTTPS ([RFC 2818](https://tools.ietf.org/html/rfc2818)).
    ///
    /// For more information, see [`NSAppTransportSecurity`](https://developer.apple.com/documentation/bundleresources/information-property-list/nsapptransportsecurity).
    ///
    /// ### Foundation copying behavior
    ///
    /// Session and task objects conform to the [`NSCopying`](https://developer.apple.com/documentation/foundation/nscopying) protocol as follows:
    ///
    /// - When your app copies a session or task object, you get the same object back.
    ///
    /// - When your app copies a configuration object, you get a new copy you can independently modify.
    ///
    /// ### Thread safety
    ///
    /// The URL session API is thread-safe. You can freely create sessions and tasks in any thread context. When your delegate methods call the provided completion handlers, the work is automatically scheduled on the correct delegate queue.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSession;
);

unsafe impl Send for NSURLSession {}

unsafe impl Sync for NSURLSession {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSession {}
);

impl NSURLSession {
    extern_methods!(
        #[unsafe(method(sharedSession))]
        #[unsafe(method_family = none)]
        pub fn sharedSession() -> Retained<NSURLSession>;

        #[unsafe(method(sessionWithConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn sessionWithConfiguration(
            configuration: &NSURLSessionConfiguration,
        ) -> Retained<NSURLSession>;

        #[cfg(feature = "NSOperation")]
        /// # Safety
        ///
        /// `queue` possibly has additional threading requirements.
        #[unsafe(method(sessionWithConfiguration:delegate:delegateQueue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sessionWithConfiguration_delegate_delegateQueue(
            configuration: &NSURLSessionConfiguration,
            delegate: Option<&ProtocolObject<dyn NSURLSessionDelegate>>,
            queue: Option<&NSOperationQueue>,
        ) -> Retained<NSURLSession>;

        #[cfg(feature = "NSOperation")]
        #[unsafe(method(delegateQueue))]
        #[unsafe(method_family = none)]
        pub fn delegateQueue(&self) -> Retained<NSOperationQueue>;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSURLSessionDelegate>>>;

        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub fn configuration(&self) -> Retained<NSURLSessionConfiguration>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(sessionDescription))]
        #[unsafe(method_family = none)]
        pub fn sessionDescription(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`sessionDescription`][Self::sessionDescription].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setSessionDescription:))]
        #[unsafe(method_family = none)]
        pub fn setSessionDescription(&self, session_description: Option<&NSString>);

        #[unsafe(method(finishTasksAndInvalidate))]
        #[unsafe(method_family = none)]
        pub fn finishTasksAndInvalidate(&self);

        #[unsafe(method(invalidateAndCancel))]
        #[unsafe(method_family = none)]
        pub fn invalidateAndCancel(&self);

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(resetWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn resetWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(flushWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn flushWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "NSArray", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(getTasksWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getTasksWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(
                    NonNull<NSArray<NSURLSessionDataTask>>,
                    NonNull<NSArray<NSURLSessionUploadTask>>,
                    NonNull<NSArray<NSURLSessionDownloadTask>>,
                ),
            >,
        );

        #[cfg(all(feature = "NSArray", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(getAllTasksWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAllTasksWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSURLSessionTask>>)>,
        );

        #[cfg(feature = "NSURLRequest")]
        #[unsafe(method(dataTaskWithRequest:))]
        #[unsafe(method_family = none)]
        pub fn dataTaskWithRequest(&self, request: &NSURLRequest)
            -> Retained<NSURLSessionDataTask>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(dataTaskWithURL:))]
        #[unsafe(method_family = none)]
        pub fn dataTaskWithURL(&self, url: &NSURL) -> Retained<NSURLSessionDataTask>;

        #[cfg(all(feature = "NSURL", feature = "NSURLRequest"))]
        #[unsafe(method(uploadTaskWithRequest:fromFile:))]
        #[unsafe(method_family = none)]
        pub fn uploadTaskWithRequest_fromFile(
            &self,
            request: &NSURLRequest,
            file_url: &NSURL,
        ) -> Retained<NSURLSessionUploadTask>;

        #[cfg(all(feature = "NSData", feature = "NSURLRequest"))]
        #[unsafe(method(uploadTaskWithRequest:fromData:))]
        #[unsafe(method_family = none)]
        pub fn uploadTaskWithRequest_fromData(
            &self,
            request: &NSURLRequest,
            body_data: &NSData,
        ) -> Retained<NSURLSessionUploadTask>;

        #[cfg(feature = "NSData")]
        /// Creates an upload task from a resume data blob. Requires the server to support the latest resumable uploads
        /// Internet-Draft from the HTTP Working Group, found at
        /// https://datatracker.ietf.org/doc/draft-ietf-httpbis-resumable-upload/
        /// If resuming from an upload file, the file must still exist and be unmodified. If the upload cannot be successfully
        /// resumed, URLSession:task:didCompleteWithError: will be called.
        ///
        /// - Parameter resumeData: Resume data blob from an incomplete upload, such as data returned by the cancelByProducingResumeData: method.
        /// - Returns: A new session upload task, or nil if the resumeData is invalid.
        #[unsafe(method(uploadTaskWithResumeData:))]
        #[unsafe(method_family = none)]
        pub fn uploadTaskWithResumeData(
            &self,
            resume_data: &NSData,
        ) -> Retained<NSURLSessionUploadTask>;

        #[cfg(feature = "NSURLRequest")]
        #[unsafe(method(uploadTaskWithStreamedRequest:))]
        #[unsafe(method_family = none)]
        pub fn uploadTaskWithStreamedRequest(
            &self,
            request: &NSURLRequest,
        ) -> Retained<NSURLSessionUploadTask>;

        #[cfg(feature = "NSURLRequest")]
        #[unsafe(method(downloadTaskWithRequest:))]
        #[unsafe(method_family = none)]
        pub fn downloadTaskWithRequest(
            &self,
            request: &NSURLRequest,
        ) -> Retained<NSURLSessionDownloadTask>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(downloadTaskWithURL:))]
        #[unsafe(method_family = none)]
        pub fn downloadTaskWithURL(&self, url: &NSURL) -> Retained<NSURLSessionDownloadTask>;

        #[cfg(feature = "NSData")]
        #[unsafe(method(downloadTaskWithResumeData:))]
        #[unsafe(method_family = none)]
        pub fn downloadTaskWithResumeData(
            &self,
            resume_data: &NSData,
        ) -> Retained<NSURLSessionDownloadTask>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(streamTaskWithHostName:port:))]
        #[unsafe(method_family = none)]
        pub fn streamTaskWithHostName_port(
            &self,
            hostname: &NSString,
            port: NSInteger,
        ) -> Retained<NSURLSessionStreamTask>;

        #[cfg(feature = "NSNetServices")]
        #[deprecated = "Use nw_connection_t in Network framework instead"]
        #[unsafe(method(streamTaskWithNetService:))]
        #[unsafe(method_family = none)]
        pub fn streamTaskWithNetService(
            &self,
            service: &NSNetService,
        ) -> Retained<NSURLSessionStreamTask>;

        #[cfg(feature = "NSURL")]
        #[unsafe(method(webSocketTaskWithURL:))]
        #[unsafe(method_family = none)]
        pub fn webSocketTaskWithURL(&self, url: &NSURL) -> Retained<NSURLSessionWebSocketTask>;

        #[cfg(all(feature = "NSArray", feature = "NSString", feature = "NSURL"))]
        #[unsafe(method(webSocketTaskWithURL:protocols:))]
        #[unsafe(method_family = none)]
        pub fn webSocketTaskWithURL_protocols(
            &self,
            url: &NSURL,
            protocols: &NSArray<NSString>,
        ) -> Retained<NSURLSessionWebSocketTask>;

        #[cfg(feature = "NSURLRequest")]
        #[unsafe(method(webSocketTaskWithRequest:))]
        #[unsafe(method_family = none)]
        pub fn webSocketTaskWithRequest(
            &self,
            request: &NSURLRequest,
        ) -> Retained<NSURLSessionWebSocketTask>;

        #[deprecated = "Please use +[NSURLSession sessionWithConfiguration:] or other class methods to create instances"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[deprecated = "Please use +[NSURLSession sessionWithConfiguration:] or other class methods to create instances"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

/// NSURLSessionAsynchronousConvenience.
impl NSURLSession {
    extern_methods!(
        #[cfg(all(
            feature = "NSData",
            feature = "NSError",
            feature = "NSURLRequest",
            feature = "NSURLResponse",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(dataTaskWithRequest:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataTaskWithRequest_completionHandler(
            &self,
            request: &NSURLRequest,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSData, *mut NSURLResponse, *mut NSError),
            >,
        ) -> Retained<NSURLSessionDataTask>;

        #[cfg(all(
            feature = "NSData",
            feature = "NSError",
            feature = "NSURL",
            feature = "NSURLResponse",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(dataTaskWithURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataTaskWithURL_completionHandler(
            &self,
            url: &NSURL,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSData, *mut NSURLResponse, *mut NSError),
            >,
        ) -> Retained<NSURLSessionDataTask>;

        #[cfg(all(
            feature = "NSData",
            feature = "NSError",
            feature = "NSURL",
            feature = "NSURLRequest",
            feature = "NSURLResponse",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(uploadTaskWithRequest:fromFile:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn uploadTaskWithRequest_fromFile_completionHandler(
            &self,
            request: &NSURLRequest,
            file_url: &NSURL,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSData, *mut NSURLResponse, *mut NSError),
            >,
        ) -> Retained<NSURLSessionUploadTask>;

        #[cfg(all(
            feature = "NSData",
            feature = "NSError",
            feature = "NSURLRequest",
            feature = "NSURLResponse",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(uploadTaskWithRequest:fromData:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn uploadTaskWithRequest_fromData_completionHandler(
            &self,
            request: &NSURLRequest,
            body_data: Option<&NSData>,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSData, *mut NSURLResponse, *mut NSError),
            >,
        ) -> Retained<NSURLSessionUploadTask>;

        #[cfg(all(
            feature = "NSData",
            feature = "NSError",
            feature = "NSURLResponse",
            feature = "block2"
        ))]
        /// Creates a URLSessionUploadTask from a resume data blob. If resuming from an upload
        /// file, the file must still exist and be unmodified.
        ///
        /// - Parameter resumeData: Resume data blob from an incomplete upload, such as data returned by the cancelByProducingResumeData: method.
        /// - Parameter completionHandler: The completion handler to call when the load request is complete.
        /// - Returns: A new session upload task, or nil if the resumeData is invalid.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(uploadTaskWithResumeData:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn uploadTaskWithResumeData_completionHandler(
            &self,
            resume_data: &NSData,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSData, *mut NSURLResponse, *mut NSError),
            >,
        ) -> Retained<NSURLSessionUploadTask>;

        #[cfg(all(
            feature = "NSError",
            feature = "NSURL",
            feature = "NSURLRequest",
            feature = "NSURLResponse",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(downloadTaskWithRequest:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn downloadTaskWithRequest_completionHandler(
            &self,
            request: &NSURLRequest,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSURL, *mut NSURLResponse, *mut NSError),
            >,
        ) -> Retained<NSURLSessionDownloadTask>;

        #[cfg(all(
            feature = "NSError",
            feature = "NSURL",
            feature = "NSURLResponse",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(downloadTaskWithURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn downloadTaskWithURL_completionHandler(
            &self,
            url: &NSURL,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSURL, *mut NSURLResponse, *mut NSError),
            >,
        ) -> Retained<NSURLSessionDownloadTask>;

        #[cfg(all(
            feature = "NSData",
            feature = "NSError",
            feature = "NSURL",
            feature = "NSURLResponse",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(downloadTaskWithResumeData:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn downloadTaskWithResumeData_completionHandler(
            &self,
            resume_data: &NSData,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSURL, *mut NSURLResponse, *mut NSError),
            >,
        ) -> Retained<NSURLSessionDownloadTask>;
    );
}

/// Constants for determining the current state of a task.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLSessionTaskState(pub NSInteger);
impl NSURLSessionTaskState {
    /// The task is currently being serviced by the session.
    ///
    /// ## Discussion
    ///
    /// A task in this state is subject to the request and resource timeouts specified in the session configuration object.
    ///
    ///
    #[doc(alias = "NSURLSessionTaskStateRunning")]
    pub const Running: Self = Self(0);
    /// The task was suspended by the app.
    ///
    /// ## Discussion
    ///
    /// No further processing takes place until the task is resumed. A task in this state is not subject to timeouts.
    ///
    ///
    #[doc(alias = "NSURLSessionTaskStateSuspended")]
    pub const Suspended: Self = Self(1);
    /// The task has received a `cancel` message.
    ///
    /// ## Discussion
    ///
    /// The delegate may or may not have received a [`URLSession:task:didCompleteWithError:`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate/urlsession(_:task:didcompletewitherror:)) message yet. A task in this state is not subject to timeouts.
    ///
    ///
    #[doc(alias = "NSURLSessionTaskStateCanceling")]
    pub const Canceling: Self = Self(2);
    /// The task has completed (without being canceled), and the task’s delegate receives no further callbacks.
    ///
    /// ## Discussion
    ///
    /// If the task completed successfully, the task’s [`error`](https://developer.apple.com/documentation/foundation/urlsessiontask/error) property is `nil`. Otherwise, it provides an error object that tells what went wrong. A task in this state is not subject to timeouts.
    ///
    ///
    #[doc(alias = "NSURLSessionTaskStateCompleted")]
    pub const Completed: Self = Self(3);
}

unsafe impl Encode for NSURLSessionTaskState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLSessionTaskState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A task, like downloading a specific resource, performed in a URL session.
    ///
    /// ## Overview
    ///
    /// The [`NSURLSessionTask`](https://developer.apple.com/documentation/foundation/urlsessiontask) class is the base class for tasks in a URL session. Tasks are always part of a session; you create a task by calling one of the task creation methods on a [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) instance. The method you call determines the type of task.
    ///
    /// - Use [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession)‘s [`dataTaskWithURL:`](https://developer.apple.com/documentation/foundation/urlsession/datatask(with:)-10dy7) and related methods to create [`NSURLSessionDataTask`](https://developer.apple.com/documentation/foundation/urlsessiondatatask) instances. Data tasks request a resource, returning the server’s response as one or more `NSData` objects in memory. They are supported in default, ephemeral, and shared sessions, but are not supported in background sessions.
    ///
    /// - Use [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession)‘s [`uploadTaskWithRequest:fromData:`](https://developer.apple.com/documentation/foundation/urlsession/uploadtask(with:from:)) and related methods to create [`NSURLSessionUploadTask`](https://developer.apple.com/documentation/foundation/urlsessionuploadtask) instances. Upload tasks are like data tasks, except that they make it easier to provide a request body so you can upload data before retrieving the server’s response. Additionally, upload tasks are supported in background sessions.
    ///
    /// - Use [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession)’s [`downloadTaskWithURL:`](https://developer.apple.com/documentation/foundation/urlsession/downloadtask(with:)-1onj) and related methods to create [`NSURLSessionDownloadTask`](https://developer.apple.com/documentation/foundation/urlsessiondownloadtask) instances. Download tasks download a resource directly to a file on disk. Download tasks are supported in any type of session.
    ///
    /// - Use [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession)’s [`streamTaskWithHostName:port:`](https://developer.apple.com/documentation/foundation/urlsession/streamtask(withhostname:port:)) or [`streamTaskWithNetService:`](https://developer.apple.com/documentation/foundation/urlsession/streamtask(with:)) to create [`NSURLSessionStreamTask`](https://developer.apple.com/documentation/foundation/urlsessionstreamtask) instances. Stream tasks establish a TCP/IP connection from a host name and port or a net service object.
    ///
    /// After you create a task, you start it by calling its [`resume`](https://developer.apple.com/documentation/foundation/urlsessiontask/resume()) method. The session then maintains a strong reference to the task until the request finishes or fails; you don’t need to maintain a reference to the task unless it’s useful for your app’s internal bookkeeping.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  All task properties support key-value observing.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionTask;
);

unsafe impl Send for NSURLSessionTask {}

unsafe impl Sync for NSURLSessionTask {}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSURLSessionTask {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSURLSessionTask {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionTask {}
);

#[cfg(feature = "NSProgress")]
extern_conformance!(
    unsafe impl NSProgressReporting for NSURLSessionTask {}
);

impl NSURLSessionTask {
    extern_methods!(
        #[unsafe(method(taskIdentifier))]
        #[unsafe(method_family = none)]
        pub fn taskIdentifier(&self) -> NSUInteger;

        #[cfg(feature = "NSURLRequest")]
        #[unsafe(method(originalRequest))]
        #[unsafe(method_family = none)]
        pub fn originalRequest(&self) -> Option<Retained<NSURLRequest>>;

        #[cfg(feature = "NSURLRequest")]
        #[unsafe(method(currentRequest))]
        #[unsafe(method_family = none)]
        pub fn currentRequest(&self) -> Option<Retained<NSURLRequest>>;

        #[cfg(feature = "NSURLResponse")]
        #[unsafe(method(response))]
        #[unsafe(method_family = none)]
        pub fn response(&self) -> Option<Retained<NSURLResponse>>;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSURLSessionTaskDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSURLSessionTaskDelegate>>);

        #[cfg(feature = "NSProgress")]
        #[unsafe(method(progress))]
        #[unsafe(method_family = none)]
        pub fn progress(&self) -> Retained<NSProgress>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(earliestBeginDate))]
        #[unsafe(method_family = none)]
        pub fn earliestBeginDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        /// Setter for [`earliestBeginDate`][Self::earliestBeginDate].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setEarliestBeginDate:))]
        #[unsafe(method_family = none)]
        pub fn setEarliestBeginDate(&self, earliest_begin_date: Option<&NSDate>);

        #[unsafe(method(countOfBytesClientExpectsToSend))]
        #[unsafe(method_family = none)]
        pub fn countOfBytesClientExpectsToSend(&self) -> i64;

        /// Setter for [`countOfBytesClientExpectsToSend`][Self::countOfBytesClientExpectsToSend].
        #[unsafe(method(setCountOfBytesClientExpectsToSend:))]
        #[unsafe(method_family = none)]
        pub fn setCountOfBytesClientExpectsToSend(
            &self,
            count_of_bytes_client_expects_to_send: i64,
        );

        #[unsafe(method(countOfBytesClientExpectsToReceive))]
        #[unsafe(method_family = none)]
        pub fn countOfBytesClientExpectsToReceive(&self) -> i64;

        /// Setter for [`countOfBytesClientExpectsToReceive`][Self::countOfBytesClientExpectsToReceive].
        #[unsafe(method(setCountOfBytesClientExpectsToReceive:))]
        #[unsafe(method_family = none)]
        pub fn setCountOfBytesClientExpectsToReceive(
            &self,
            count_of_bytes_client_expects_to_receive: i64,
        );

        #[unsafe(method(countOfBytesSent))]
        #[unsafe(method_family = none)]
        pub fn countOfBytesSent(&self) -> i64;

        #[unsafe(method(countOfBytesReceived))]
        #[unsafe(method_family = none)]
        pub fn countOfBytesReceived(&self) -> i64;

        #[unsafe(method(countOfBytesExpectedToSend))]
        #[unsafe(method_family = none)]
        pub fn countOfBytesExpectedToSend(&self) -> i64;

        #[unsafe(method(countOfBytesExpectedToReceive))]
        #[unsafe(method_family = none)]
        pub fn countOfBytesExpectedToReceive(&self) -> i64;

        #[cfg(feature = "NSString")]
        #[unsafe(method(taskDescription))]
        #[unsafe(method_family = none)]
        pub fn taskDescription(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`taskDescription`][Self::taskDescription].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setTaskDescription:))]
        #[unsafe(method_family = none)]
        pub fn setTaskDescription(&self, task_description: Option<&NSString>);

        #[unsafe(method(cancel))]
        #[unsafe(method_family = none)]
        pub fn cancel(&self);

        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub fn state(&self) -> NSURLSessionTaskState;

        #[cfg(feature = "NSError")]
        #[unsafe(method(error))]
        #[unsafe(method_family = none)]
        pub fn error(&self) -> Option<Retained<NSError>>;

        #[unsafe(method(suspend))]
        #[unsafe(method_family = none)]
        pub fn suspend(&self);

        #[unsafe(method(resume))]
        #[unsafe(method_family = none)]
        pub fn resume(&self);

        #[unsafe(method(priority))]
        #[unsafe(method_family = none)]
        pub fn priority(&self) -> c_float;

        /// Setter for [`priority`][Self::priority].
        #[unsafe(method(setPriority:))]
        #[unsafe(method_family = none)]
        pub fn setPriority(&self, priority: c_float);

        #[unsafe(method(prefersIncrementalDelivery))]
        #[unsafe(method_family = none)]
        pub fn prefersIncrementalDelivery(&self) -> bool;

        /// Setter for [`prefersIncrementalDelivery`][Self::prefersIncrementalDelivery].
        #[unsafe(method(setPrefersIncrementalDelivery:))]
        #[unsafe(method_family = none)]
        pub fn setPrefersIncrementalDelivery(&self, prefers_incremental_delivery: bool);

        #[deprecated = "Not supported"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[deprecated = "Not supported"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

extern "C" {
    /// The default URL session task priority, used implicitly for any task you have not prioritized.
    ///
    /// ## Discussion
    ///
    /// The floating point value of this constant is `0.5`.
    ///
    ///
    pub static NSURLSessionTaskPriorityDefault: c_float;
}

extern "C" {
    /// A low URL session task priority, with a floating point value above the minimum of `0` and below the default value.
    pub static NSURLSessionTaskPriorityLow: c_float;
}

extern "C" {
    /// A high URL session task priority, with a floating point value above the default value and below the maximum of `1.0`.
    pub static NSURLSessionTaskPriorityHigh: c_float;
}

extern_class!(
    /// A URL session task that returns downloaded data directly to the app in memory.
    ///
    /// ## Overview
    ///
    /// A [`NSURLSessionDataTask`](https://developer.apple.com/documentation/foundation/urlsessiondatatask) is a concrete subclass of [`NSURLSessionTask`](https://developer.apple.com/documentation/foundation/urlsessiontask). The methods in the [`NSURLSessionDataTask`](https://developer.apple.com/documentation/foundation/urlsessiondatatask) class are documented in [`NSURLSessionTask`](https://developer.apple.com/documentation/foundation/urlsessiontask).
    ///
    /// A data task returns data directly to the app (in memory) as one or more `NSData` objects. When you use a data task:
    ///
    /// - During upload of the body data (if your app provides any), the session periodically calls its delegate’s [`URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate/urlsession(_:task:didsendbodydata:totalbytessent:totalbytesexpectedtosend:)) method with status information.
    ///
    /// - After receiving an initial response, the session calls its delegate’s [`URLSession:dataTask:didReceiveResponse:completionHandler:`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/urlsession(_:datatask:didreceive:completionhandler:)) method to let you examine the status code and headers, and optionally convert the data task into a download task.
    ///
    /// - During the transfer, the session calls its delegate’s [`URLSession:dataTask:didReceiveData:`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/urlsession(_:datatask:didreceive:)) method to provide your app with the content as it arrives.
    ///
    /// - Upon completion, the session calls its delegate’s [`URLSession:dataTask:willCacheResponse:completionHandler:`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/urlsession(_:datatask:willcacheresponse:completionhandler:)) method to let you determine whether the response should be cached.
    ///
    /// For examples of using data tasks for fetching and uploading data, see [Fetching website data into memory](https://developer.apple.com/documentation/foundation/fetching-website-data-into-memory) and [Uploading data to a website](https://developer.apple.com/documentation/foundation/uploading-data-to-a-website).
    ///
    ///
    #[unsafe(super(NSURLSessionTask, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionDataTask;
);

unsafe impl Send for NSURLSessionDataTask {}

unsafe impl Sync for NSURLSessionDataTask {}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSURLSessionDataTask {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSURLSessionDataTask {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionDataTask {}
);

#[cfg(feature = "NSProgress")]
extern_conformance!(
    unsafe impl NSProgressReporting for NSURLSessionDataTask {}
);

impl NSURLSessionDataTask {
    extern_methods!(
        #[deprecated = "Please use -[NSURLSession dataTaskWithRequest:] or other NSURLSession methods to create instances"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[deprecated = "Please use -[NSURLSession dataTaskWithRequest:] or other NSURLSession methods to create instances"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A URL session task that uploads data to the network in a request body.
    ///
    /// ## Overview
    ///
    /// The [`NSURLSessionUploadTask`](https://developer.apple.com/documentation/foundation/urlsessionuploadtask) class is a subclass of [`NSURLSessionDataTask`](https://developer.apple.com/documentation/foundation/urlsessiondatatask), which in turn is a concrete subclass of [`NSURLSessionTask`](https://developer.apple.com/documentation/foundation/urlsessiontask). The methods associated with the [`NSURLSessionUploadTask`](https://developer.apple.com/documentation/foundation/urlsessionuploadtask) class are documented in [`NSURLSessionTask`](https://developer.apple.com/documentation/foundation/urlsessiontask).
    ///
    /// Upload tasks are used for making HTTP requests that require a request body (such as `POST` or `PUT`). They behave similarly to data tasks, but you create them by calling different methods on the session that are designed to make it easier to provide the content to upload. As with data tasks, if the server provides a response, upload tasks return that response as one or more `NSData` objects in memory.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Unlike data tasks, you can use upload tasks to upload content in the background.
    ///
    ///
    ///
    /// </div>
    /// When you create an upload task, you provide a [`URLRequest`](https://developer.apple.com/documentation/foundation/urlrequest) instance that contains any additional headers that you might need to send alongside the upload, such as the content type, content disposition, and so on. In iOS, when you create an upload task for a file in a background session, the system copies that file to a temporary location and streams data from there.
    ///
    /// While the upload is in progress, the task calls the session delegate’s [`URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate/urlsession(_:task:didsendbodydata:totalbytessent:totalbytesexpectedtosend:)) method periodically to provide you with status information.
    ///
    /// When the upload phase of the request finishes, the task behaves like a data task, calling methods on the session delegate to provide you with the server’s response—headers, status code, content data, and so on.
    ///
    ///
    #[unsafe(super(NSURLSessionDataTask, NSURLSessionTask, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionUploadTask;
);

unsafe impl Send for NSURLSessionUploadTask {}

unsafe impl Sync for NSURLSessionUploadTask {}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSURLSessionUploadTask {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSURLSessionUploadTask {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionUploadTask {}
);

#[cfg(feature = "NSProgress")]
extern_conformance!(
    unsafe impl NSProgressReporting for NSURLSessionUploadTask {}
);

impl NSURLSessionUploadTask {
    extern_methods!(
        #[deprecated = "Please use -[NSURLSession uploadTaskWithStreamedRequest:] or other NSURLSession methods to create instances"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[deprecated = "Please use -[NSURLSession uploadTaskWithStreamedRequest:] or other NSURLSession methods to create instances"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;

        #[cfg(all(feature = "NSData", feature = "block2"))]
        /// Cancels an upload and calls the completion handler with resume data for later use.
        /// resumeData will be nil if the server does not support the latest resumable uploads
        /// Internet-Draft from the HTTP Working Group, found at
        /// https://datatracker.ietf.org/doc/draft-ietf-httpbis-resumable-upload/
        ///
        /// - Parameter completionHandler: The completion handler to call when the upload has been successfully canceled.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(cancelByProducingResumeData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelByProducingResumeData(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData)>,
        );
    );
}

extern_class!(
    /// A URL session task that stores downloaded data to a file.
    ///
    /// ## Overview
    ///
    /// An [`NSURLSessionDownloadTask`](https://developer.apple.com/documentation/foundation/urlsessiondownloadtask) is a concrete subclass of [`NSURLSessionTask`](https://developer.apple.com/documentation/foundation/urlsessiontask), which provides most of the methods for this class.
    ///
    /// Download tasks directly write the server’s response data to a temporary file, providing your app with progress updates as data arrives from the server. When you use download tasks in background sessions, these downloads continue even when your app is in the suspended state or otherwise not running.
    ///
    /// You can pause (cancel) download tasks and resume them later (assuming the server supports doing so). You can also resume downloads that failed because of network connectivity problems.
    ///
    /// ### Download delegate behavior
    ///
    /// When you use a download task, your delegate receives several callbacks unique to download scenarios.
    ///
    /// - During download, the session periodically calls the delegate’s [`URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:`](https://developer.apple.com/documentation/foundation/urlsessiondownloaddelegate/urlsession(_:downloadtask:didwritedata:totalbyteswritten:totalbytesexpectedtowrite:)) method with status information.
    ///
    /// - Upon successful completion, the session calls the delegate’s [`URLSession:downloadTask:didFinishDownloadingToURL:`](https://developer.apple.com/documentation/foundation/urlsessiondownloaddelegate/urlsession(_:downloadtask:didfinishdownloadingto:)) method or completion handler. In that method, you must either open the file for reading or move it to a permanent location in your app’s sandbox container directory.
    ///
    /// - Upon unsuccessful completion, the session calls the delegate’s [`URLSession:task:didCompleteWithError:`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate/urlsession(_:task:didcompletewitherror:)) method or completion handler. The only errors your delegate receives through the `error` parameter are client-side errors, such as being unable to resolve the hostname or connect to the host. To check for server-side errors, inspect the [`response`](https://developer.apple.com/documentation/foundation/urlsessiontask/response) property of the `task` parameter received by this callback.
    ///
    ///
    #[unsafe(super(NSURLSessionTask, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionDownloadTask;
);

unsafe impl Send for NSURLSessionDownloadTask {}

unsafe impl Sync for NSURLSessionDownloadTask {}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSURLSessionDownloadTask {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSURLSessionDownloadTask {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionDownloadTask {}
);

#[cfg(feature = "NSProgress")]
extern_conformance!(
    unsafe impl NSProgressReporting for NSURLSessionDownloadTask {}
);

impl NSURLSessionDownloadTask {
    extern_methods!(
        #[cfg(all(feature = "NSData", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(cancelByProducingResumeData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelByProducingResumeData(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData)>,
        );

        #[deprecated = "Please use -[NSURLSession downloadTaskWithRequest:] or other NSURLSession methods to create instances"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[deprecated = "Please use -[NSURLSession downloadTaskWithRequest:] or other NSURLSession methods to create instances"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A URL session task that is stream-based.
    ///
    /// ## Overview
    ///
    /// [`NSURLSessionStreamTask`](https://developer.apple.com/documentation/foundation/urlsessionstreamtask) is a concrete subclass of [`NSURLSessionTask`](https://developer.apple.com/documentation/foundation/urlsessiontask). Many of the methods in the [`NSURLSessionStreamTask`](https://developer.apple.com/documentation/foundation/urlsessionstreamtask) class are documented in [`NSURLSessionTask`](https://developer.apple.com/documentation/foundation/urlsessiontask).
    ///
    /// The [`NSURLSessionStreamTask`](https://developer.apple.com/documentation/foundation/urlsessionstreamtask) class provides an interface a TCP/IP connection created via [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession). Tasks may be created from an [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) using the [`streamTaskWithHostName:port:`](https://developer.apple.com/documentation/foundation/urlsession/streamtask(withhostname:port:)) and [`streamTaskWithNetService:`](https://developer.apple.com/documentation/foundation/urlsession/streamtask(with:)) methods. They may also be created as a result of an [`NSURLSessionDataTask`](https://developer.apple.com/documentation/foundation/urlsessiondatatask) being upgraded via the HTTP `Upgrade:` response header and appropriate use of the [`HTTPShouldUsePipelining`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/httpshouldusepipelining) option of [`NSURLSessionConfiguration`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration).
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  See [RFC 2817](https://tools.ietf.org/html/rfc2817) and [RFC 6455](https://tools.ietf.org/html/rfc6455) for information about the `Upgrade:` header.
    ///
    ///
    ///
    /// </div>
    /// A [`NSURLSessionStreamTask`](https://developer.apple.com/documentation/foundation/urlsessionstreamtask) object performs asynchronous reads and writes, which are enqueued and executed serially, calling a handler upon completion being on the session delegate queue. If the task is canceled, all enqueued reads and writes will call their completion handlers with an appropriate error.
    ///
    /// When working with APIs that accept [`NSStream`](https://developer.apple.com/documentation/foundation/stream) objects, you can create [`NSInputStream`](https://developer.apple.com/documentation/foundation/inputstream) and [`NSOutputStream`](https://developer.apple.com/documentation/foundation/outputstream) objects from an [`NSURLSessionStreamTask`](https://developer.apple.com/documentation/foundation/urlsessionstreamtask) object by calling the [`captureStreams`](https://developer.apple.com/documentation/foundation/urlsessionstreamtask/capturestreams()) method.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  watchOS supports [`NSURLSessionStreamTask`](https://developer.apple.com/documentation/foundation/urlsessionstreamtask) for specific use cases. For more details, see [TN3135: Low-level networking on watchOS](https://developer.apple.com/documentation/technotes/tn3135-low-level-networking-on-watchos).
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSURLSessionTask, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionStreamTask;
);

unsafe impl Send for NSURLSessionStreamTask {}

unsafe impl Sync for NSURLSessionStreamTask {}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSURLSessionStreamTask {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSURLSessionStreamTask {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionStreamTask {}
);

#[cfg(feature = "NSProgress")]
extern_conformance!(
    unsafe impl NSProgressReporting for NSURLSessionStreamTask {}
);

impl NSURLSessionStreamTask {
    extern_methods!(
        #[cfg(all(
            feature = "NSData",
            feature = "NSDate",
            feature = "NSError",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(readDataOfMinLength:maxLength:timeout:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readDataOfMinLength_maxLength_timeout_completionHandler(
            &self,
            min_bytes: NSUInteger,
            max_bytes: NSUInteger,
            timeout: NSTimeInterval,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData, Bool, *mut NSError)>,
        );

        #[cfg(all(
            feature = "NSData",
            feature = "NSDate",
            feature = "NSError",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(writeData:timeout:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeData_timeout_completionHandler(
            &self,
            data: &NSData,
            timeout: NSTimeInterval,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[unsafe(method(captureStreams))]
        #[unsafe(method_family = none)]
        pub fn captureStreams(&self);

        #[unsafe(method(closeWrite))]
        #[unsafe(method_family = none)]
        pub fn closeWrite(&self);

        #[unsafe(method(closeRead))]
        #[unsafe(method_family = none)]
        pub fn closeRead(&self);

        #[unsafe(method(startSecureConnection))]
        #[unsafe(method_family = none)]
        pub fn startSecureConnection(&self);

        #[deprecated = "TLS cannot be disabled once it is enabled"]
        #[unsafe(method(stopSecureConnection))]
        #[unsafe(method_family = none)]
        pub fn stopSecureConnection(&self);

        #[deprecated = "Please use -[NSURLSession streamTaskWithHostName:port:] or other NSURLSession methods to create instances"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[deprecated = "Please use -[NSURLSession streamTaskWithHostName:port:] or other NSURLSession methods to create instances"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLSessionWebSocketMessageType(pub NSInteger);
impl NSURLSessionWebSocketMessageType {
    #[doc(alias = "NSURLSessionWebSocketMessageTypeData")]
    pub const Data: Self = Self(0);
    #[doc(alias = "NSURLSessionWebSocketMessageTypeString")]
    pub const String: Self = Self(1);
}

unsafe impl Encode for NSURLSessionWebSocketMessageType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLSessionWebSocketMessageType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionWebSocketMessage;
);

unsafe impl Send for NSURLSessionWebSocketMessage {}

unsafe impl Sync for NSURLSessionWebSocketMessage {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionWebSocketMessage {}
);

impl NSURLSessionWebSocketMessage {
    extern_methods!(
        #[cfg(feature = "NSData")]
        #[unsafe(method(initWithData:))]
        #[unsafe(method_family = init)]
        pub fn initWithData(this: Allocated<Self>, data: &NSData) -> Retained<Self>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(initWithString:))]
        #[unsafe(method_family = init)]
        pub fn initWithString(this: Allocated<Self>, string: &NSString) -> Retained<Self>;

        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        pub fn r#type(&self) -> NSURLSessionWebSocketMessageType;

        #[cfg(feature = "NSData")]
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub fn data(&self) -> Option<Retained<NSData>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(string))]
        #[unsafe(method_family = none)]
        pub fn string(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// A code that indicates why a WebSocket connection closed.
///
/// ## Overview
///
/// The WebSocket close codes follow the close codes defined in [RFC 6455](https://tools.ietf.org/html/rfc6455#section-7.4.1).
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLSessionWebSocketCloseCode(pub NSInteger);
impl NSURLSessionWebSocketCloseCode {
    /// A code that indicates the connection is still open.
    #[doc(alias = "NSURLSessionWebSocketCloseCodeInvalid")]
    pub const Invalid: Self = Self(0);
    /// A code that indicates normal connection closure.
    #[doc(alias = "NSURLSessionWebSocketCloseCodeNormalClosure")]
    pub const NormalClosure: Self = Self(1000);
    /// A code that indicates an endpoint is going away.
    ///
    /// ## Discussion
    ///
    /// This code indicates situations like a server going down or a browser having navigated away from a page.
    ///
    ///
    #[doc(alias = "NSURLSessionWebSocketCloseCodeGoingAway")]
    pub const GoingAway: Self = Self(1001);
    /// A code that indicates an endpoint terminated the connection due to a protocol error.
    #[doc(alias = "NSURLSessionWebSocketCloseCodeProtocolError")]
    pub const ProtocolError: Self = Self(1002);
    /// A code that indicates an endpoint terminated the connection after receiving a type of data it can’t accept.
    ///
    /// ## Discussion
    ///
    /// An endpoint that only accepts text may send this close code if it receives a binary message.
    ///
    ///
    #[doc(alias = "NSURLSessionWebSocketCloseCodeUnsupportedData")]
    pub const UnsupportedData: Self = Self(1003);
    /// A reserved code that indicates an endpoint expected a status code and didn’t receive one.
    #[doc(alias = "NSURLSessionWebSocketCloseCodeNoStatusReceived")]
    pub const NoStatusReceived: Self = Self(1005);
    /// A reserved code that indicates the connection closed without a close control frame.
    #[doc(alias = "NSURLSessionWebSocketCloseCodeAbnormalClosure")]
    pub const AbnormalClosure: Self = Self(1006);
    /// A code that indicates the server terminated the connection because it received data inconsistent with the message’s type.
    #[doc(alias = "NSURLSessionWebSocketCloseCodeInvalidFramePayloadData")]
    pub const InvalidFramePayloadData: Self = Self(1007);
    /// A code that indicates an endpoint terminated the connection because it received a message that violates its policy.
    ///
    /// ## Discussion
    ///
    /// This is a generic code for use when a more specific code is unavailable.
    ///
    ///
    #[doc(alias = "NSURLSessionWebSocketCloseCodePolicyViolation")]
    pub const PolicyViolation: Self = Self(1008);
    /// A code that indicates an endpoint is terminating the connection because it received a message too big for it to process.
    #[doc(alias = "NSURLSessionWebSocketCloseCodeMessageTooBig")]
    pub const MessageTooBig: Self = Self(1009);
    /// A code that indicates the client terminated the connection because the server didn’t negotiate a required extension.
    ///
    /// ## Discussion
    ///
    /// RFC 6455 indicates the client should provide a [`closeReason`](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/closereason) with a list of the needed extensions.
    ///
    ///
    #[doc(alias = "NSURLSessionWebSocketCloseCodeMandatoryExtensionMissing")]
    pub const MandatoryExtensionMissing: Self = Self(1010);
    /// A code that indicates the server terminated the connection because it encountered an unexpected condition.
    #[doc(alias = "NSURLSessionWebSocketCloseCodeInternalServerError")]
    pub const InternalServerError: Self = Self(1011);
    /// A reserved code that indicates the connection closed due to the failure to perform a TLS handshake.
    #[doc(alias = "NSURLSessionWebSocketCloseCodeTLSHandshakeFailure")]
    pub const TLSHandshakeFailure: Self = Self(1015);
}

unsafe impl Encode for NSURLSessionWebSocketCloseCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLSessionWebSocketCloseCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A URL session task that communicates over the WebSockets protocol standard.
    ///
    /// ## Overview
    ///
    /// [`NSURLSessionWebSocketTask`](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) is a concrete subclass of [`NSURLSessionTask`](https://developer.apple.com/documentation/foundation/urlsessiontask) that provides a message-oriented transport protocol over TCP and TLS in the form of WebSocket framing. It follows the WebSocket Protocol defined in [RFC 6455](https://tools.ietf.org/html/rfc6455).
    ///
    /// You create a [`NSURLSessionWebSocketTask`](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) with either a `ws:` or `wss:` URL. When creating the task, you can also provide a list of protocols to advertise during the handshake phase. Once the handshake completes, your app receives notifications through the session’s [`delegate`](https://developer.apple.com/documentation/foundation/urlsession/delegate).
    ///
    /// You send data with [`send(_:completionHandler:)`](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/send(_:completionhandler:)) and receive data with [`receive(completionHandler:)`](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask/receive(completionhandler:)). The task performs reads and writes asynchronously, and allows you to send and receive messages that contain both binary frames and UTF-8 encoded text frames. The task enqueues any reads or writes you perform prior to the handshake’s completion, and executes them after the handshake completes.
    ///
    /// [`NSURLSessionWebSocketTask`](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) supports redirection and authentication like other types of tasks do, using the methods in [`NSURLSessionTaskDelegate`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate). The WebSocket task calls the redirection and authentication delegate methods prior to completing the handshake. The WebSocket task also supports cookies, by storing cookies to the session configuration’s [`HTTPCookieStorage`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration/httpcookiestorage), and attaches cookies to outgoing HTTP handshake requests.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  watchOS supports [`NSURLSessionWebSocketTask`](https://developer.apple.com/documentation/foundation/urlsessionwebsockettask) for specific use cases. For more details, see [TN3135: Low-level networking on watchOS](https://developer.apple.com/documentation/technotes/tn3135-low-level-networking-on-watchos).
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSURLSessionTask, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionWebSocketTask;
);

unsafe impl Send for NSURLSessionWebSocketTask {}

unsafe impl Sync for NSURLSessionWebSocketTask {}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSURLSessionWebSocketTask {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSURLSessionWebSocketTask {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionWebSocketTask {}
);

#[cfg(feature = "NSProgress")]
extern_conformance!(
    unsafe impl NSProgressReporting for NSURLSessionWebSocketTask {}
);

impl NSURLSessionWebSocketTask {
    extern_methods!(
        #[cfg(all(feature = "NSError", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(sendMessage:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendMessage_completionHandler(
            &self,
            message: &NSURLSessionWebSocketMessage,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(feature = "NSError", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(receiveMessageWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn receiveMessageWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSURLSessionWebSocketMessage, *mut NSError),
            >,
        );

        #[cfg(all(feature = "NSError", feature = "block2"))]
        /// # Safety
        ///
        /// `pong_receive_handler` block must be sendable.
        #[unsafe(method(sendPingWithPongReceiveHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendPingWithPongReceiveHandler(
            &self,
            pong_receive_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "NSData")]
        #[unsafe(method(cancelWithCloseCode:reason:))]
        #[unsafe(method_family = none)]
        pub fn cancelWithCloseCode_reason(
            &self,
            close_code: NSURLSessionWebSocketCloseCode,
            reason: Option<&NSData>,
        );

        #[unsafe(method(maximumMessageSize))]
        #[unsafe(method_family = none)]
        pub fn maximumMessageSize(&self) -> NSInteger;

        /// Setter for [`maximumMessageSize`][Self::maximumMessageSize].
        #[unsafe(method(setMaximumMessageSize:))]
        #[unsafe(method_family = none)]
        pub fn setMaximumMessageSize(&self, maximum_message_size: NSInteger);

        #[unsafe(method(closeCode))]
        #[unsafe(method_family = none)]
        pub fn closeCode(&self) -> NSURLSessionWebSocketCloseCode;

        #[cfg(feature = "NSData")]
        #[unsafe(method(closeReason))]
        #[unsafe(method_family = none)]
        pub fn closeReason(&self) -> Option<Retained<NSData>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Constants that specify the type of service that Multipath TCP uses.
/// The NSURLSessionMultipathServiceType enum defines constants that
/// can be used to specify the multipath service type to associate an NSURLSession.  The
/// multipath service type determines whether multipath TCP should be attempted and the conditions
/// for creating and switching between subflows.  Using these service types requires the appropriate entitlement.  Any connection attempt will fail if the process does not have the required entitlement.
/// A primary interface is a generally less expensive interface in terms of both cost and power (such as WiFi or ethernet).  A secondary interface is more expensive (such as 3G or LTE).
///
///
/// This is the default value.  No entitlement is required to set this value.
///
///
/// when the primary subflow is not performing adequately.   Requires the com.apple.developer.networking.multipath entitlement.
///
///
/// primary subflow is not performing adequately (packet loss, high round trip times, bandwidth issues).  The secondary
/// subflow will be created more aggressively than with NSURLSessionMultipathServiceTypeHandover.  Requires the com.apple.developer.networking.multipath entitlement.
///
///
/// used for better bandwidth.  This mode is only available for experimentation on devices configured for development use.
/// It can be enabled in the Developer section of the Settings app.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLSessionMultipathServiceType(pub NSInteger);
impl NSURLSessionMultipathServiceType {
    /// The default service type indicating that Multipath TCP should not be used.
    #[doc(alias = "NSURLSessionMultipathServiceTypeNone")]
    pub const None: Self = Self(0);
    /// A Multipath TCP service that provides seamless handover between Wi-Fi and cellular in order to preserve the connection.
    ///
    /// ## Discussion
    ///
    /// Specify this option for long-lived or persistent connections. You must also set the [`Multipath Entitlement`](https://developer.apple.com/documentation/bundleresources/entitlements/com.apple.developer.networking.multipath) in the Xcode Capabilities pane for your app.
    ///
    ///
    #[doc(alias = "NSURLSessionMultipathServiceTypeHandover")]
    pub const Handover: Self = Self(1);
    /// A service whereby Multipath TCP attempts to use the lowest-latency interface.
    ///
    /// ## Discussion
    ///
    /// Specify this option for latency-sensitive, low-volume connections that might use cellular data. You must also set the [`Multipath Entitlement`](https://developer.apple.com/documentation/bundleresources/entitlements/com.apple.developer.networking.multipath) in the Xcode Capabilities pane for your app.
    ///
    ///
    #[doc(alias = "NSURLSessionMultipathServiceTypeInteractive")]
    pub const Interactive: Self = Self(2);
    /// A service that aggregates the capacities of other Multipath options in an attempt to increase throughput and minimize latency.
    ///
    /// ## Discussion
    ///
    /// This option is available only for experimentation. Specify it for connections that use cellular data. You must also set the [`Multipath Entitlement`](https://developer.apple.com/documentation/bundleresources/entitlements/com.apple.developer.networking.multipath) in the Xcode Capabilities pane for your app.
    ///
    /// To enable the aggregation mode, open the Settings app on your development iPhone and navigate to Developer, and then turn on Multipath Networking.
    ///
    /// Multipath Aggregation requires an iOS device in Developer mode with a cellular connection running iOS 11.0 or later.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Setting this option will use a considerable amount of cellular data.
    ///
    ///
    ///
    /// </div>
    ///
    #[doc(alias = "NSURLSessionMultipathServiceTypeAggregate")]
    pub const Aggregate: Self = Self(3);
}

unsafe impl Encode for NSURLSessionMultipathServiceType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLSessionMultipathServiceType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A configuration object that defines behavior and policies for a URL session.
    ///
    /// ## Overview
    ///
    /// An [`NSURLSessionConfiguration`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration) object defines the behavior and policies to use when uploading and downloading data using an [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) object. When uploading or downloading data, creating a configuration object is always the first step you must take. You use this object to configure the timeout values, caching policies, connection requirements, and other types of information that you intend to use with your [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) object.
    ///
    /// It is important to configure your [`NSURLSessionConfiguration`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration) object appropriately before using it to initialize a session object. Session objects make a copy of the configuration settings you provide and use those settings to configure the session. Once configured, the session object ignores any changes you make to the [`NSURLSessionConfiguration`](https://developer.apple.com/documentation/foundation/urlsessionconfiguration) object. If you need to modify your transfer policies, you must update the session configuration object and use it to create a new [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) object.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  In some cases, the policies defined in this configuration may be overridden by policies specified by an [`NSURLRequest`](https://developer.apple.com/documentation/foundation/nsurlrequest) object provided for a task. Any policy specified on the request object is respected unless the session’s policy is more restrictive. For example, if the session configuration specifies that cellular networking should not be allowed, the [`NSURLRequest`](https://developer.apple.com/documentation/foundation/nsurlrequest) object cannot request cellular networking.
    ///
    ///
    ///
    /// </div>
    /// For more information about using configuration objects to create sessions, see [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession).
    ///
    /// ### Types of session configurations
    ///
    /// The behavior and capabilities of a URL session are largely determined by the kind of configuration used to create the session.
    ///
    /// The singleton shared session (which has no configuration object) is for basic requests. It’s not as customizable as sessions that you create, but it serves as a good starting point if you have very limited requirements. You access this session by calling the shared class method. See that method’s discussion for more information about its limitations.
    ///
    /// Default sessions behave much like the shared session (unless you customize them further), but let you obtain data incrementally using a delegate. You can create a default session configuration by calling the default method on the URLSessionConfiguration class.
    ///
    /// Ephemeral sessions are similar to default sessions, but they don’t write caches, cookies, or credentials to disk. You can create an ephemeral session configuration by calling the ephemeral method on the URLSessionConfiguration class.
    ///
    /// Background sessions let you perform uploads and downloads of content in the background while your app isn’t running. You can create a background session configuration by calling the backgroundSessionConfiguration(_:) method on the URLSessionConfiguration class.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionConfiguration;
);

unsafe impl Send for NSURLSessionConfiguration {}

unsafe impl Sync for NSURLSessionConfiguration {}

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSURLSessionConfiguration {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSURLSessionConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionConfiguration {}
);

impl NSURLSessionConfiguration {
    extern_methods!(
        #[unsafe(method(defaultSessionConfiguration))]
        #[unsafe(method_family = none)]
        pub fn defaultSessionConfiguration() -> Retained<NSURLSessionConfiguration>;

        #[unsafe(method(ephemeralSessionConfiguration))]
        #[unsafe(method_family = none)]
        pub fn ephemeralSessionConfiguration() -> Retained<NSURLSessionConfiguration>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(backgroundSessionConfigurationWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn backgroundSessionConfigurationWithIdentifier(
            identifier: &NSString,
        ) -> Retained<NSURLSessionConfiguration>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub fn identifier(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSURLRequest")]
        #[unsafe(method(requestCachePolicy))]
        #[unsafe(method_family = none)]
        pub fn requestCachePolicy(&self) -> NSURLRequestCachePolicy;

        #[cfg(feature = "NSURLRequest")]
        /// Setter for [`requestCachePolicy`][Self::requestCachePolicy].
        #[unsafe(method(setRequestCachePolicy:))]
        #[unsafe(method_family = none)]
        pub fn setRequestCachePolicy(&self, request_cache_policy: NSURLRequestCachePolicy);

        #[cfg(feature = "NSDate")]
        #[unsafe(method(timeoutIntervalForRequest))]
        #[unsafe(method_family = none)]
        pub fn timeoutIntervalForRequest(&self) -> NSTimeInterval;

        #[cfg(feature = "NSDate")]
        /// Setter for [`timeoutIntervalForRequest`][Self::timeoutIntervalForRequest].
        #[unsafe(method(setTimeoutIntervalForRequest:))]
        #[unsafe(method_family = none)]
        pub fn setTimeoutIntervalForRequest(&self, timeout_interval_for_request: NSTimeInterval);

        #[cfg(feature = "NSDate")]
        #[unsafe(method(timeoutIntervalForResource))]
        #[unsafe(method_family = none)]
        pub fn timeoutIntervalForResource(&self) -> NSTimeInterval;

        #[cfg(feature = "NSDate")]
        /// Setter for [`timeoutIntervalForResource`][Self::timeoutIntervalForResource].
        #[unsafe(method(setTimeoutIntervalForResource:))]
        #[unsafe(method_family = none)]
        pub fn setTimeoutIntervalForResource(&self, timeout_interval_for_resource: NSTimeInterval);

        #[cfg(feature = "NSURLRequest")]
        #[unsafe(method(networkServiceType))]
        #[unsafe(method_family = none)]
        pub fn networkServiceType(&self) -> NSURLRequestNetworkServiceType;

        #[cfg(feature = "NSURLRequest")]
        /// Setter for [`networkServiceType`][Self::networkServiceType].
        #[unsafe(method(setNetworkServiceType:))]
        #[unsafe(method_family = none)]
        pub fn setNetworkServiceType(&self, network_service_type: NSURLRequestNetworkServiceType);

        #[unsafe(method(allowsCellularAccess))]
        #[unsafe(method_family = none)]
        pub fn allowsCellularAccess(&self) -> bool;

        /// Setter for [`allowsCellularAccess`][Self::allowsCellularAccess].
        #[unsafe(method(setAllowsCellularAccess:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsCellularAccess(&self, allows_cellular_access: bool);

        #[unsafe(method(allowsExpensiveNetworkAccess))]
        #[unsafe(method_family = none)]
        pub fn allowsExpensiveNetworkAccess(&self) -> bool;

        /// Setter for [`allowsExpensiveNetworkAccess`][Self::allowsExpensiveNetworkAccess].
        #[unsafe(method(setAllowsExpensiveNetworkAccess:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsExpensiveNetworkAccess(&self, allows_expensive_network_access: bool);

        #[unsafe(method(allowsConstrainedNetworkAccess))]
        #[unsafe(method_family = none)]
        pub fn allowsConstrainedNetworkAccess(&self) -> bool;

        /// Setter for [`allowsConstrainedNetworkAccess`][Self::allowsConstrainedNetworkAccess].
        #[unsafe(method(setAllowsConstrainedNetworkAccess:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsConstrainedNetworkAccess(&self, allows_constrained_network_access: bool);

        #[unsafe(method(allowsUltraConstrainedNetworkAccess))]
        #[unsafe(method_family = none)]
        pub fn allowsUltraConstrainedNetworkAccess(&self) -> bool;

        /// Setter for [`allowsUltraConstrainedNetworkAccess`][Self::allowsUltraConstrainedNetworkAccess].
        #[unsafe(method(setAllowsUltraConstrainedNetworkAccess:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsUltraConstrainedNetworkAccess(
            &self,
            allows_ultra_constrained_network_access: bool,
        );

        #[unsafe(method(requiresDNSSECValidation))]
        #[unsafe(method_family = none)]
        pub fn requiresDNSSECValidation(&self) -> bool;

        /// Setter for [`requiresDNSSECValidation`][Self::requiresDNSSECValidation].
        #[unsafe(method(setRequiresDNSSECValidation:))]
        #[unsafe(method_family = none)]
        pub fn setRequiresDNSSECValidation(&self, requires_dnssec_validation: bool);

        #[unsafe(method(waitsForConnectivity))]
        #[unsafe(method_family = none)]
        pub fn waitsForConnectivity(&self) -> bool;

        /// Setter for [`waitsForConnectivity`][Self::waitsForConnectivity].
        #[unsafe(method(setWaitsForConnectivity:))]
        #[unsafe(method_family = none)]
        pub fn setWaitsForConnectivity(&self, waits_for_connectivity: bool);

        #[unsafe(method(isDiscretionary))]
        #[unsafe(method_family = none)]
        pub fn isDiscretionary(&self) -> bool;

        /// Setter for [`isDiscretionary`][Self::isDiscretionary].
        #[unsafe(method(setDiscretionary:))]
        #[unsafe(method_family = none)]
        pub fn setDiscretionary(&self, discretionary: bool);

        #[cfg(feature = "NSString")]
        #[unsafe(method(sharedContainerIdentifier))]
        #[unsafe(method_family = none)]
        pub fn sharedContainerIdentifier(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`sharedContainerIdentifier`][Self::sharedContainerIdentifier].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setSharedContainerIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setSharedContainerIdentifier(&self, shared_container_identifier: Option<&NSString>);

        #[unsafe(method(sessionSendsLaunchEvents))]
        #[unsafe(method_family = none)]
        pub fn sessionSendsLaunchEvents(&self) -> bool;

        /// Setter for [`sessionSendsLaunchEvents`][Self::sessionSendsLaunchEvents].
        #[unsafe(method(setSessionSendsLaunchEvents:))]
        #[unsafe(method_family = none)]
        pub fn setSessionSendsLaunchEvents(&self, session_sends_launch_events: bool);

        #[cfg(feature = "NSDictionary")]
        #[unsafe(method(connectionProxyDictionary))]
        #[unsafe(method_family = none)]
        pub fn connectionProxyDictionary(&self) -> Option<Retained<NSDictionary>>;

        #[cfg(feature = "NSDictionary")]
        /// Setter for [`connectionProxyDictionary`][Self::connectionProxyDictionary].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `connection_proxy_dictionary` generic should be of the correct type.
        #[unsafe(method(setConnectionProxyDictionary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConnectionProxyDictionary(
            &self,
            connection_proxy_dictionary: Option<&NSDictionary>,
        );

        #[deprecated = "Only supported in the classic loader, please adopt HTTP/2 and HTTP/3 instead"]
        #[unsafe(method(HTTPShouldUsePipelining))]
        #[unsafe(method_family = none)]
        pub fn HTTPShouldUsePipelining(&self) -> bool;

        /// Setter for [`HTTPShouldUsePipelining`][Self::HTTPShouldUsePipelining].
        #[deprecated = "Only supported in the classic loader, please adopt HTTP/2 and HTTP/3 instead"]
        #[unsafe(method(setHTTPShouldUsePipelining:))]
        #[unsafe(method_family = none)]
        pub fn setHTTPShouldUsePipelining(&self, http_should_use_pipelining: bool);

        #[unsafe(method(HTTPShouldSetCookies))]
        #[unsafe(method_family = none)]
        pub fn HTTPShouldSetCookies(&self) -> bool;

        /// Setter for [`HTTPShouldSetCookies`][Self::HTTPShouldSetCookies].
        #[unsafe(method(setHTTPShouldSetCookies:))]
        #[unsafe(method_family = none)]
        pub fn setHTTPShouldSetCookies(&self, http_should_set_cookies: bool);

        #[cfg(feature = "NSHTTPCookieStorage")]
        #[unsafe(method(HTTPCookieAcceptPolicy))]
        #[unsafe(method_family = none)]
        pub fn HTTPCookieAcceptPolicy(&self) -> NSHTTPCookieAcceptPolicy;

        #[cfg(feature = "NSHTTPCookieStorage")]
        /// Setter for [`HTTPCookieAcceptPolicy`][Self::HTTPCookieAcceptPolicy].
        #[unsafe(method(setHTTPCookieAcceptPolicy:))]
        #[unsafe(method_family = none)]
        pub fn setHTTPCookieAcceptPolicy(
            &self,
            http_cookie_accept_policy: NSHTTPCookieAcceptPolicy,
        );

        #[cfg(feature = "NSDictionary")]
        #[unsafe(method(HTTPAdditionalHeaders))]
        #[unsafe(method_family = none)]
        pub fn HTTPAdditionalHeaders(&self) -> Option<Retained<NSDictionary>>;

        #[cfg(feature = "NSDictionary")]
        /// Setter for [`HTTPAdditionalHeaders`][Self::HTTPAdditionalHeaders].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `http_additional_headers` generic should be of the correct type.
        #[unsafe(method(setHTTPAdditionalHeaders:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHTTPAdditionalHeaders(
            &self,
            http_additional_headers: Option<&NSDictionary>,
        );

        #[unsafe(method(HTTPMaximumConnectionsPerHost))]
        #[unsafe(method_family = none)]
        pub fn HTTPMaximumConnectionsPerHost(&self) -> NSInteger;

        /// Setter for [`HTTPMaximumConnectionsPerHost`][Self::HTTPMaximumConnectionsPerHost].
        #[unsafe(method(setHTTPMaximumConnectionsPerHost:))]
        #[unsafe(method_family = none)]
        pub fn setHTTPMaximumConnectionsPerHost(
            &self,
            http_maximum_connections_per_host: NSInteger,
        );

        #[cfg(feature = "NSHTTPCookieStorage")]
        #[unsafe(method(HTTPCookieStorage))]
        #[unsafe(method_family = none)]
        pub fn HTTPCookieStorage(&self) -> Option<Retained<NSHTTPCookieStorage>>;

        #[cfg(feature = "NSHTTPCookieStorage")]
        /// Setter for [`HTTPCookieStorage`][Self::HTTPCookieStorage].
        #[unsafe(method(setHTTPCookieStorage:))]
        #[unsafe(method_family = none)]
        pub fn setHTTPCookieStorage(&self, http_cookie_storage: Option<&NSHTTPCookieStorage>);

        #[cfg(feature = "NSURLCredentialStorage")]
        #[unsafe(method(URLCredentialStorage))]
        #[unsafe(method_family = none)]
        pub fn URLCredentialStorage(&self) -> Option<Retained<NSURLCredentialStorage>>;

        #[cfg(feature = "NSURLCredentialStorage")]
        /// Setter for [`URLCredentialStorage`][Self::URLCredentialStorage].
        #[unsafe(method(setURLCredentialStorage:))]
        #[unsafe(method_family = none)]
        pub fn setURLCredentialStorage(
            &self,
            url_credential_storage: Option<&NSURLCredentialStorage>,
        );

        #[cfg(feature = "NSURLCache")]
        #[unsafe(method(URLCache))]
        #[unsafe(method_family = none)]
        pub fn URLCache(&self) -> Option<Retained<NSURLCache>>;

        #[cfg(feature = "NSURLCache")]
        /// Setter for [`URLCache`][Self::URLCache].
        #[unsafe(method(setURLCache:))]
        #[unsafe(method_family = none)]
        pub fn setURLCache(&self, url_cache: Option<&NSURLCache>);

        #[deprecated = "Not supported"]
        #[unsafe(method(shouldUseExtendedBackgroundIdleMode))]
        #[unsafe(method_family = none)]
        pub fn shouldUseExtendedBackgroundIdleMode(&self) -> bool;

        /// Setter for [`shouldUseExtendedBackgroundIdleMode`][Self::shouldUseExtendedBackgroundIdleMode].
        #[deprecated = "Not supported"]
        #[unsafe(method(setShouldUseExtendedBackgroundIdleMode:))]
        #[unsafe(method_family = none)]
        pub fn setShouldUseExtendedBackgroundIdleMode(
            &self,
            should_use_extended_background_idle_mode: bool,
        );

        #[cfg(feature = "NSArray")]
        #[unsafe(method(protocolClasses))]
        #[unsafe(method_family = none)]
        pub fn protocolClasses(&self) -> Option<Retained<NSArray<AnyClass>>>;

        #[cfg(feature = "NSArray")]
        /// Setter for [`protocolClasses`][Self::protocolClasses].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `protocol_classes` generic probably has further requirements.
        #[unsafe(method(setProtocolClasses:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProtocolClasses(&self, protocol_classes: Option<&NSArray<AnyClass>>);

        #[unsafe(method(multipathServiceType))]
        #[unsafe(method_family = none)]
        pub fn multipathServiceType(&self) -> NSURLSessionMultipathServiceType;

        /// Setter for [`multipathServiceType`][Self::multipathServiceType].
        #[unsafe(method(setMultipathServiceType:))]
        #[unsafe(method_family = none)]
        pub fn setMultipathServiceType(
            &self,
            multipath_service_type: NSURLSessionMultipathServiceType,
        );

        #[unsafe(method(usesClassicLoadingMode))]
        #[unsafe(method_family = none)]
        pub fn usesClassicLoadingMode(&self) -> bool;

        /// Setter for [`usesClassicLoadingMode`][Self::usesClassicLoadingMode].
        #[unsafe(method(setUsesClassicLoadingMode:))]
        #[unsafe(method_family = none)]
        pub fn setUsesClassicLoadingMode(&self, uses_classic_loading_mode: bool);

        #[unsafe(method(enablesEarlyData))]
        #[unsafe(method_family = none)]
        pub fn enablesEarlyData(&self) -> bool;

        /// Setter for [`enablesEarlyData`][Self::enablesEarlyData].
        #[unsafe(method(setEnablesEarlyData:))]
        #[unsafe(method_family = none)]
        pub fn setEnablesEarlyData(&self, enables_early_data: bool);

        #[deprecated = "Please use NSURLSessionConfiguration.defaultSessionConfiguration or other class methods to create instances"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[deprecated = "Please use NSURLSessionConfiguration.defaultSessionConfiguration or other class methods to create instances"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

/// The action to take on a delayed URL session task.
///
/// ## Overview
///
/// The values of this enumeration indicate how to handle a task with a delayed start time (as set with the [`earliestBeginDate`](https://developer.apple.com/documentation/foundation/urlsessiontask/earliestbegindate) property). When the task is ready to start, it calls the [`URLSession:task:willBeginDelayedRequest:completionHandler:`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate/urlsession(_:task:willbegindelayedrequest:completionhandler:)) method of [`NSURLSessionTaskDelegate`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate). The implementation of this method must call the provided completion handler, passing in one case of this enumeration as the first argument. If the [`NSURLSessionDelayedRequestUseNewRequest`](https://developer.apple.com/documentation/foundation/urlsession/delayedrequestdisposition/usenewrequest) disposition is used for the first argument, the caller must also provide a new [`NSURLRequest`](https://developer.apple.com/documentation/foundation/nsurlrequest) as the second argument.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLSessionDelayedRequestDisposition(pub NSInteger);
impl NSURLSessionDelayedRequestDisposition {
    /// A disposition indicating that the task should proceed with the original request.
    #[doc(alias = "NSURLSessionDelayedRequestContinueLoading")]
    pub const ContinueLoading: Self = Self(0);
    /// A disposition indicating that the task should use a new request to perform the network load.
    #[doc(alias = "NSURLSessionDelayedRequestUseNewRequest")]
    pub const UseNewRequest: Self = Self(1);
    /// A disposition indicating that the task should be canceled.
    #[doc(alias = "NSURLSessionDelayedRequestCancel")]
    pub const Cancel: Self = Self(2);
}

unsafe impl Encode for NSURLSessionDelayedRequestDisposition {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLSessionDelayedRequestDisposition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants passed by session or task delegates to the provided continuation block in response to an authentication challenge.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLSessionAuthChallengeDisposition(pub NSInteger);
impl NSURLSessionAuthChallengeDisposition {
    /// Use the specified credential, which may be `nil`.
    #[doc(alias = "NSURLSessionAuthChallengeUseCredential")]
    pub const UseCredential: Self = Self(0);
    /// Use the default handling for the challenge as though this delegate method were not implemented. The provided credential parameter is ignored.
    #[doc(alias = "NSURLSessionAuthChallengePerformDefaultHandling")]
    pub const PerformDefaultHandling: Self = Self(1);
    /// Cancel the entire request. The provided credential parameter is ignored.
    #[doc(alias = "NSURLSessionAuthChallengeCancelAuthenticationChallenge")]
    pub const CancelAuthenticationChallenge: Self = Self(2);
    /// Reject this challenge, and call the authentication delegate method again with the next authentication protection space. The provided credential parameter is ignored.
    ///
    /// ## Discussion
    ///
    /// The [`NSURLSessionAuthChallengeRejectProtectionSpace`](https://developer.apple.com/documentation/foundation/urlsession/authchallengedisposition/rejectprotectionspace) disposition is only appropriate in fairly unusual situations. For example, a Windows server might use both [`NSURLAuthenticationMethodNegotiate`](https://developer.apple.com/documentation/foundation/nsurlauthenticationmethodnegotiate) and [`NSURLAuthenticationMethodNTLM`](https://developer.apple.com/documentation/foundation/nsurlauthenticationmethodntlm). If your app can only handle NTLM, you would want to reject the Negotiate challenge, in order to then receive the queued NTLM challenge.
    ///
    /// However, most apps won’t face this scenario, and if you cannot provide a credential for a certain authentication method, you should usually fall back to the [`NSURLSessionAuthChallengePerformDefaultHandling`](https://developer.apple.com/documentation/foundation/urlsession/authchallengedisposition/performdefaulthandling) disposition instead.
    ///
    ///
    #[doc(alias = "NSURLSessionAuthChallengeRejectProtectionSpace")]
    pub const RejectProtectionSpace: Self = Self(3);
}

unsafe impl Encode for NSURLSessionAuthChallengeDisposition {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLSessionAuthChallengeDisposition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants indicating how a data or upload session should proceed after receiving the initial headers.
///
/// ## Overview
///
/// When a data or upload task first receives a response, it calls the  [`URLSession:dataTask:didReceiveResponse:completionHandler:`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/urlsession(_:datatask:didreceive:completionhandler:)) method of [`NSURLSessionDataDelegate`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate). Implement this method to inspect the received [`NSURLResponse`](https://developer.apple.com/documentation/foundation/urlresponse) and then call the provided completion handler. The first parameter to the completion handler is of this type, a disposition that tells the task how to proceed.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLSessionResponseDisposition(pub NSInteger);
impl NSURLSessionResponseDisposition {
    /// Cancel the load.
    ///
    /// ## Discussion
    ///
    /// Using this disposition is equivalent to calling [`cancel`](https://developer.apple.com/documentation/foundation/urlsessiontask/cancel()) on the task.
    ///
    ///
    #[doc(alias = "NSURLSessionResponseCancel")]
    pub const Cancel: Self = Self(0);
    /// Allow the load operation to continue.
    #[doc(alias = "NSURLSessionResponseAllow")]
    pub const Allow: Self = Self(1);
    /// Convert the response for this request to use a [`NSURLSessionDownloadTask`](https://developer.apple.com/documentation/foundation/urlsessiondownloadtask).
    ///
    /// ## Discussion
    ///
    /// When used with the completion handler from [`URLSession:dataTask:didReceiveResponse:completionHandler:`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/urlsession(_:datatask:didreceive:completionhandler:)), this disposition converts the data task to a download task. This will result in your delegate’s [`URLSession:dataTask:didBecomeDownloadTask:`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/urlsession(_:datatask:didbecome:)-60op5) being called to provide you with the new download task that supersedes the current task.
    ///
    ///
    #[doc(alias = "NSURLSessionResponseBecomeDownload")]
    pub const BecomeDownload: Self = Self(2);
    /// Convert the response for this request to use a [`NSURLSessionStreamTask`](https://developer.apple.com/documentation/foundation/urlsessionstreamtask).
    ///
    /// ## Discussion
    ///
    /// When used with the completion handler from [`URLSession:dataTask:didReceiveResponse:completionHandler:`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/urlsession(_:datatask:didreceive:completionhandler:)), this disposition converts the task to a stream task. This will result in your delegate’s [`URLSession:dataTask:didBecomeStreamTask:`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate/urlsession(_:datatask:didbecome:)-7nqzu) being called to provide you with the new stream task that supersedes the current task.
    ///
    ///
    #[doc(alias = "NSURLSessionResponseBecomeStream")]
    pub const BecomeStream: Self = Self(3);
}

unsafe impl Encode for NSURLSessionResponseDisposition {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLSessionResponseDisposition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A protocol that defines methods that URL session instances call on their delegates to handle session-level events, like session life cycle changes.
    ///
    /// ## Overview
    ///
    /// In addition to the methods defined in this protocol, most delegates should also implement some or all of the methods in the [`NSURLSessionTaskDelegate`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate), [`NSURLSessionDataDelegate`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate), and [`NSURLSessionDownloadDelegate`](https://developer.apple.com/documentation/foundation/urlsessiondownloaddelegate) protocols to handle task-level events. These include events like the beginning and end of individual tasks, and periodic progress updates from data or download tasks.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Your [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) object doesn’t need to have a delegate. If no delegate is assigned, a system-provided delegate is used, and you must provide a completion callback to obtain the data.
    ///
    ///
    ///
    /// </div>
    ///
    pub unsafe trait NSURLSessionDelegate: NSObjectProtocol + Send + Sync {
        #[cfg(feature = "NSError")]
        #[optional]
        #[unsafe(method(URLSession:didBecomeInvalidWithError:))]
        #[unsafe(method_family = none)]
        fn URLSession_didBecomeInvalidWithError(
            &self,
            session: &NSURLSession,
            error: Option<&NSError>,
        );

        #[cfg(all(
            feature = "NSURLAuthenticationChallenge",
            feature = "NSURLCredential",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[optional]
        #[unsafe(method(URLSession:didReceiveChallenge:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn URLSession_didReceiveChallenge_completionHandler(
            &self,
            session: &NSURLSession,
            challenge: &NSURLAuthenticationChallenge,
            completion_handler: &block2::DynBlock<
                dyn Fn(NSURLSessionAuthChallengeDisposition, *mut NSURLCredential),
            >,
        );

        #[optional]
        #[unsafe(method(URLSessionDidFinishEventsForBackgroundURLSession:))]
        #[unsafe(method_family = none)]
        fn URLSessionDidFinishEventsForBackgroundURLSession(&self, session: &NSURLSession);
    }
);

extern_protocol!(
    /// A protocol that defines methods that URL session instances call on their delegates to handle task-level events.
    ///
    /// ## Overview
    ///
    /// You use this protocol in one of two ways, depending on how you use a [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession):
    ///
    /// - If you create tasks with Swift’s `async`-`await` syntax, using methods like [`bytes(for:delegate:)`](https://developer.apple.com/documentation/foundation/urlsession/bytes(for:delegate:)) and [`data(for:delegate:)`](https://developer.apple.com/documentation/foundation/urlsession/data(for:delegate:)), you pass a `delegate` argument of this type. The delegate receives callbacks for things like task progress, while the call point awaits the completion of the task.
    ///
    /// - If you add tasks to the session with methods like [`dataTaskWithURL:`](https://developer.apple.com/documentation/foundation/urlsession/datatask(with:)-10dy7) and [`downloadTaskWithURL:`](https://developer.apple.com/documentation/foundation/urlsession/downloadtask(with:)-1onj), then you implement this protocol’s methods in a [`delegate`](https://developer.apple.com/documentation/foundation/urlsession/delegate) you set on the session. This session delegate may also implement other protocols as appropriate, like [`NSURLSessionDownloadDelegate`](https://developer.apple.com/documentation/foundation/urlsessiondownloaddelegate) and [`NSURLSessionDataDelegate`](https://developer.apple.com/documentation/foundation/urlsessiondatadelegate). You can also assign a delegate of this type directly to the task to intercept callbacks before the task delivers them to the session’s delegate.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Your [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) object doesn’t need to have a delegate. If you don’t assign a delegate, the session uses a system-provided delegate. In this case, you must provide a completion callback or use the Swift `async`-`await` methods to obtain the data.
    ///
    ///
    ///
    /// </div>
    ///
    pub unsafe trait NSURLSessionTaskDelegate: NSURLSessionDelegate {
        #[optional]
        #[unsafe(method(URLSession:didCreateTask:))]
        #[unsafe(method_family = none)]
        fn URLSession_didCreateTask(&self, session: &NSURLSession, task: &NSURLSessionTask);

        #[cfg(all(feature = "NSURLRequest", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[optional]
        #[unsafe(method(URLSession:task:willBeginDelayedRequest:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn URLSession_task_willBeginDelayedRequest_completionHandler(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
            request: &NSURLRequest,
            completion_handler: &block2::DynBlock<
                dyn Fn(NSURLSessionDelayedRequestDisposition, *mut NSURLRequest),
            >,
        );

        #[optional]
        #[unsafe(method(URLSession:taskIsWaitingForConnectivity:))]
        #[unsafe(method_family = none)]
        fn URLSession_taskIsWaitingForConnectivity(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
        );

        #[cfg(all(
            feature = "NSURLRequest",
            feature = "NSURLResponse",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[optional]
        #[unsafe(method(URLSession:task:willPerformHTTPRedirection:newRequest:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn URLSession_task_willPerformHTTPRedirection_newRequest_completionHandler(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
            response: &NSHTTPURLResponse,
            request: &NSURLRequest,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSURLRequest)>,
        );

        #[cfg(all(
            feature = "NSURLAuthenticationChallenge",
            feature = "NSURLCredential",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[optional]
        #[unsafe(method(URLSession:task:didReceiveChallenge:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn URLSession_task_didReceiveChallenge_completionHandler(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
            challenge: &NSURLAuthenticationChallenge,
            completion_handler: &block2::DynBlock<
                dyn Fn(NSURLSessionAuthChallengeDisposition, *mut NSURLCredential),
            >,
        );

        #[cfg(all(feature = "NSStream", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[optional]
        #[unsafe(method(URLSession:task:needNewBodyStream:))]
        #[unsafe(method_family = none)]
        unsafe fn URLSession_task_needNewBodyStream(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSInputStream)>,
        );

        #[cfg(all(feature = "NSStream", feature = "block2"))]
        /// Tells the delegate if a task requires a new body stream starting from the given offset. This may be
        /// necessary when resuming a failed upload task.
        ///
        /// - Parameter session: The session containing the task that needs a new body stream from the given offset.
        /// - Parameter task: The task that needs a new body stream.
        /// - Parameter offset: The starting offset required for the body stream.
        /// - Parameter completionHandler: A completion handler that your delegate method should call with the new body stream.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[optional]
        #[unsafe(method(URLSession:task:needNewBodyStreamFromOffset:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn URLSession_task_needNewBodyStreamFromOffset_completionHandler(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
            offset: i64,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSInputStream)>,
        );

        #[optional]
        #[unsafe(method(URLSession:task:didSendBodyData:totalBytesSent:totalBytesExpectedToSend:))]
        #[unsafe(method_family = none)]
        fn URLSession_task_didSendBodyData_totalBytesSent_totalBytesExpectedToSend(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
            bytes_sent: i64,
            total_bytes_sent: i64,
            total_bytes_expected_to_send: i64,
        );

        #[cfg(feature = "NSURLResponse")]
        #[optional]
        #[unsafe(method(URLSession:task:didReceiveInformationalResponse:))]
        #[unsafe(method_family = none)]
        fn URLSession_task_didReceiveInformationalResponse(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
            response: &NSHTTPURLResponse,
        );

        #[optional]
        #[unsafe(method(URLSession:task:didFinishCollectingMetrics:))]
        #[unsafe(method_family = none)]
        fn URLSession_task_didFinishCollectingMetrics(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
            metrics: &NSURLSessionTaskMetrics,
        );

        #[cfg(feature = "NSError")]
        #[optional]
        #[unsafe(method(URLSession:task:didCompleteWithError:))]
        #[unsafe(method_family = none)]
        fn URLSession_task_didCompleteWithError(
            &self,
            session: &NSURLSession,
            task: &NSURLSessionTask,
            error: Option<&NSError>,
        );
    }
);

extern_protocol!(
    /// A protocol that defines methods that URL session instances call on their delegates to handle task-level events specific to data and upload tasks.
    ///
    /// ## Overview
    ///
    /// Your session delegate should also implement the methods in the [`NSURLSessionTaskDelegate`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate) protocol to handle task-level events that are common to all task types, and methods in the [`NSURLSessionDelegate`](https://developer.apple.com/documentation/foundation/urlsessiondelegate) protocol to handle session-level events.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  A [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) object need not have a delegate. If no delegate is assigned, when you create tasks in that session, you must provide a completion handler block to obtain the data.
    ///
    /// Completion handler blocks are primarily intended as an alternative to using a custom delegate. If you create a task using a method that takes a completion handler block, the delegate methods for response and data delivery are not called.
    ///
    ///
    ///
    /// </div>
    ///
    pub unsafe trait NSURLSessionDataDelegate: NSURLSessionTaskDelegate {
        #[cfg(all(feature = "NSURLResponse", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[optional]
        #[unsafe(method(URLSession:dataTask:didReceiveResponse:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn URLSession_dataTask_didReceiveResponse_completionHandler(
            &self,
            session: &NSURLSession,
            data_task: &NSURLSessionDataTask,
            response: &NSURLResponse,
            completion_handler: &block2::DynBlock<dyn Fn(NSURLSessionResponseDisposition)>,
        );

        #[optional]
        #[unsafe(method(URLSession:dataTask:didBecomeDownloadTask:))]
        #[unsafe(method_family = none)]
        fn URLSession_dataTask_didBecomeDownloadTask(
            &self,
            session: &NSURLSession,
            data_task: &NSURLSessionDataTask,
            download_task: &NSURLSessionDownloadTask,
        );

        #[optional]
        #[unsafe(method(URLSession:dataTask:didBecomeStreamTask:))]
        #[unsafe(method_family = none)]
        fn URLSession_dataTask_didBecomeStreamTask(
            &self,
            session: &NSURLSession,
            data_task: &NSURLSessionDataTask,
            stream_task: &NSURLSessionStreamTask,
        );

        #[cfg(feature = "NSData")]
        #[optional]
        #[unsafe(method(URLSession:dataTask:didReceiveData:))]
        #[unsafe(method_family = none)]
        fn URLSession_dataTask_didReceiveData(
            &self,
            session: &NSURLSession,
            data_task: &NSURLSessionDataTask,
            data: &NSData,
        );

        #[cfg(all(feature = "NSURLCache", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[optional]
        #[unsafe(method(URLSession:dataTask:willCacheResponse:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn URLSession_dataTask_willCacheResponse_completionHandler(
            &self,
            session: &NSURLSession,
            data_task: &NSURLSessionDataTask,
            proposed_response: &NSCachedURLResponse,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSCachedURLResponse)>,
        );
    }
);

extern_protocol!(
    /// A protocol that defines methods that URL session instances call on their delegates to handle task-level events specific to download tasks.
    ///
    /// ## Overview
    ///
    /// In addition to the methods in this protocol, be sure to implement the methods in the [`NSURLSessionTaskDelegate`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate) and [`NSURLSessionDelegate`](https://developer.apple.com/documentation/foundation/urlsessiondelegate) protocols to handle events common to all task types and session-level events, respectively.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  An [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) object need not have a delegate. If no delegate is assigned, a system-provided delegate is used, and you must provide a completion callback to obtain the data.
    ///
    ///
    ///
    /// </div>
    ///
    pub unsafe trait NSURLSessionDownloadDelegate: NSURLSessionTaskDelegate {
        #[cfg(feature = "NSURL")]
        #[unsafe(method(URLSession:downloadTask:didFinishDownloadingToURL:))]
        #[unsafe(method_family = none)]
        fn URLSession_downloadTask_didFinishDownloadingToURL(
            &self,
            session: &NSURLSession,
            download_task: &NSURLSessionDownloadTask,
            location: &NSURL,
        );

        #[optional]
        #[unsafe(method(URLSession:downloadTask:didWriteData:totalBytesWritten:totalBytesExpectedToWrite:))]
        #[unsafe(method_family = none)]
        fn URLSession_downloadTask_didWriteData_totalBytesWritten_totalBytesExpectedToWrite(
            &self,
            session: &NSURLSession,
            download_task: &NSURLSessionDownloadTask,
            bytes_written: i64,
            total_bytes_written: i64,
            total_bytes_expected_to_write: i64,
        );

        #[optional]
        #[unsafe(method(URLSession:downloadTask:didResumeAtOffset:expectedTotalBytes:))]
        #[unsafe(method_family = none)]
        fn URLSession_downloadTask_didResumeAtOffset_expectedTotalBytes(
            &self,
            session: &NSURLSession,
            download_task: &NSURLSessionDownloadTask,
            file_offset: i64,
            expected_total_bytes: i64,
        );
    }
);

extern_protocol!(
    /// A protocol that defines methods that URL session instances call on their delegates to handle task-level events specific to stream tasks.
    ///
    /// ## Overview
    ///
    /// In addition to these methods, be sure to implement the methods in the [`NSURLSessionTaskDelegate`](https://developer.apple.com/documentation/foundation/urlsessiontaskdelegate) and [`NSURLSessionDelegate`](https://developer.apple.com/documentation/foundation/urlsessiondelegate) protocols to handle events common to all task types and session-level events, respectively.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    /// A [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) object need not have a delegate. If no delegate is assigned, a system-provided delegate is used, and you must provide a completion callback to obtain the data.
    ///
    ///
    ///
    /// </div>
    ///
    pub unsafe trait NSURLSessionStreamDelegate: NSURLSessionTaskDelegate {
        #[optional]
        #[unsafe(method(URLSession:readClosedForStreamTask:))]
        #[unsafe(method_family = none)]
        fn URLSession_readClosedForStreamTask(
            &self,
            session: &NSURLSession,
            stream_task: &NSURLSessionStreamTask,
        );

        #[optional]
        #[unsafe(method(URLSession:writeClosedForStreamTask:))]
        #[unsafe(method_family = none)]
        fn URLSession_writeClosedForStreamTask(
            &self,
            session: &NSURLSession,
            stream_task: &NSURLSessionStreamTask,
        );

        #[optional]
        #[unsafe(method(URLSession:betterRouteDiscoveredForStreamTask:))]
        #[unsafe(method_family = none)]
        fn URLSession_betterRouteDiscoveredForStreamTask(
            &self,
            session: &NSURLSession,
            stream_task: &NSURLSessionStreamTask,
        );

        #[cfg(feature = "NSStream")]
        #[optional]
        #[unsafe(method(URLSession:streamTask:didBecomeInputStream:outputStream:))]
        #[unsafe(method_family = none)]
        fn URLSession_streamTask_didBecomeInputStream_outputStream(
            &self,
            session: &NSURLSession,
            stream_task: &NSURLSessionStreamTask,
            input_stream: &NSInputStream,
            output_stream: &NSOutputStream,
        );
    }
);

extern_protocol!(
    /// A protocol that defines methods that URL session instances call on their delegates to handle task-level events specific to WebSocket tasks.
    pub unsafe trait NSURLSessionWebSocketDelegate: NSURLSessionTaskDelegate {
        #[cfg(feature = "NSString")]
        #[optional]
        #[unsafe(method(URLSession:webSocketTask:didOpenWithProtocol:))]
        #[unsafe(method_family = none)]
        fn URLSession_webSocketTask_didOpenWithProtocol(
            &self,
            session: &NSURLSession,
            web_socket_task: &NSURLSessionWebSocketTask,
            protocol: Option<&NSString>,
        );

        #[cfg(feature = "NSData")]
        #[optional]
        #[unsafe(method(URLSession:webSocketTask:didCloseWithCode:reason:))]
        #[unsafe(method_family = none)]
        fn URLSession_webSocketTask_didCloseWithCode_reason(
            &self,
            session: &NSURLSession,
            web_socket_task: &NSURLSessionWebSocketTask,
            close_code: NSURLSessionWebSocketCloseCode,
            reason: Option<&NSData>,
        );
    }
);

extern "C" {
    /// A key in the error dictionary that provides resume data.
    ///
    /// ## Discussion
    ///
    /// When a transfer error occurs or when you call the [`cancelByProducingResumeData:`](https://developer.apple.com/documentation/foundation/urlsessiondownloadtask/cancel(byproducingresumedata:)) method, the delegate object or completion handler gets an [`NSError`](https://developer.apple.com/documentation/foundation/nserror) object. If the transfer is resumable, that error object’s `userInfo` dictionary contains a value for this key. To resume the transfer, your app can pass that value to the [`downloadTaskWithResumeData:`](https://developer.apple.com/documentation/foundation/urlsession/downloadtask(withresumedata:)) or [`downloadTaskWithResumeData:completionHandler:`](https://developer.apple.com/documentation/foundation/urlsession/downloadtask(withresumedata:completionhandler:)) method.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSURLSessionDownloadTaskResumeData: &'static NSString;
}

extern "C" {
    /// Key in the userInfo dictionary of an NSError received during a failed upload.
    #[cfg(feature = "NSString")]
    pub static NSURLSessionUploadTaskResumeData: &'static NSString;
}

/// NSURLSessionDeprecated.
impl NSURLSessionConfiguration {
    extern_methods!(
        #[cfg(feature = "NSString")]
        #[deprecated]
        #[unsafe(method(backgroundSessionConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn backgroundSessionConfiguration(
            identifier: &NSString,
        ) -> Retained<NSURLSessionConfiguration>;
    );
}

/// The manner in which a resource is fetched.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLSessionTaskMetricsResourceFetchType(pub NSInteger);
impl NSURLSessionTaskMetricsResourceFetchType {
    /// The manner in which the resource was fetched could not be determined.
    #[doc(alias = "NSURLSessionTaskMetricsResourceFetchTypeUnknown")]
    pub const Unknown: Self = Self(0);
    /// The resource was loaded over the network.
    #[doc(alias = "NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad")]
    pub const NetworkLoad: Self = Self(1);
    /// The resource was pushed by the server to the client.
    #[doc(alias = "NSURLSessionTaskMetricsResourceFetchTypeServerPush")]
    #[deprecated = "Server push is no longer supported as of iOS 17 and aligned releases"]
    pub const ServerPush: Self = Self(2);
    /// The resource was retrieved from the local storage.
    #[doc(alias = "NSURLSessionTaskMetricsResourceFetchTypeLocalCache")]
    pub const LocalCache: Self = Self(3);
}

unsafe impl Encode for NSURLSessionTaskMetricsResourceFetchType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLSessionTaskMetricsResourceFetchType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSURLSessionTaskMetricsDomainResolutionProtocol(pub NSInteger);
impl NSURLSessionTaskMetricsDomainResolutionProtocol {
    #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolUDP")]
    pub const UDP: Self = Self(1);
    #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolTCP")]
    pub const TCP: Self = Self(2);
    #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolTLS")]
    pub const TLS: Self = Self(3);
    #[doc(alias = "NSURLSessionTaskMetricsDomainResolutionProtocolHTTPS")]
    pub const HTTPS: Self = Self(4);
}

unsafe impl Encode for NSURLSessionTaskMetricsDomainResolutionProtocol {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSURLSessionTaskMetricsDomainResolutionProtocol {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that encapsualtes the performance metrics collected by the URL Loading System during the execution of a session task.
    ///
    /// ## Overview
    ///
    /// Each [`NSURLSessionTaskTransactionMetrics`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics) object consists of a [`request`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/request) and [`response`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/response) property, corresponding to the request and response of the corresponding task. It also contains temporal metrics, starting with [`fetchStartDate`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/fetchstartdate) and ending with [`responseEndDate`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/responseenddate), as well as other characteristics like [`networkProtocolName`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/networkprotocolname) and [`resourceFetchType`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/resourcefetchtype).
    ///
    /// ### Understanding temporal metrics
    ///
    /// The figure below shows the sequence of events for a URL session task, which correspond to the temporal metrics captured by [`NSURLSessionTaskTransactionMetrics`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics).
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/e81f8ae516660414e5102a38b4db7b31/media-3162616~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/fe43fa65ab15aa2971fae2fab53e1a4f/media-3162616%402x.png 2x" />
    ///     <img alt="Diagram showing the temporal metrics for a URL session task. When a task starts, it performs a DNS lookup and then starts a connection. If the connection is encrypted, the user agent starts a TLS security handshake to secure the connection. After the connection to the server is established, the user agent requests the specified resource, and receives a response." src="https://docs-assets.developer.apple.com/published/fe43fa65ab15aa2971fae2fab53e1a4f/media-3162616%402x.png" />
    /// </picture>
    ///
    ///
    /// For all metrics with a start and end date, if an aspect of the task was not completed, then its corresponding end date metric is `nil`. This can happen if name lookup begins, but the operation either times out, fails, or the client cancels the task before the name can be resolved. In this case, the [`domainLookupEndDate`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/domainlookupenddate) property is `nil`, along with all metrics for aspects that occurred afterwards.
    ///
    /// ### Measuring tasks using iCloud Private Relay
    ///
    /// iCloud Private Relay can change the timing and sequence of events for your tasks by sending requests through a set of privacy proxies. All tasks that use iCloud Private Relay set the [`proxyConnection`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/isproxyconnection) property in their transaction metrics. In this case, the [`remoteAddress`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/remoteaddress) property contains the address of the proxy, and not the origin server.
    ///
    /// Tasks to different hosts can reuse the same transport connection, just like how tasks can already share a connection when using HTTP/2. In these cases, a proxied task may not report any [`secureConnectionStartDate`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/secureconnectionstartdate) or [`secureConnectionEndDate`](https://developer.apple.com/documentation/foundation/urlsessiontasktransactionmetrics/secureconnectionenddate).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionTaskTransactionMetrics;
);

unsafe impl Send for NSURLSessionTaskTransactionMetrics {}

unsafe impl Sync for NSURLSessionTaskTransactionMetrics {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionTaskTransactionMetrics {}
);

impl NSURLSessionTaskTransactionMetrics {
    extern_methods!(
        #[cfg(feature = "NSURLRequest")]
        #[unsafe(method(request))]
        #[unsafe(method_family = none)]
        pub fn request(&self) -> Retained<NSURLRequest>;

        #[cfg(feature = "NSURLResponse")]
        #[unsafe(method(response))]
        #[unsafe(method_family = none)]
        pub fn response(&self) -> Option<Retained<NSURLResponse>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(fetchStartDate))]
        #[unsafe(method_family = none)]
        pub fn fetchStartDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(domainLookupStartDate))]
        #[unsafe(method_family = none)]
        pub fn domainLookupStartDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(domainLookupEndDate))]
        #[unsafe(method_family = none)]
        pub fn domainLookupEndDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(connectStartDate))]
        #[unsafe(method_family = none)]
        pub fn connectStartDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(secureConnectionStartDate))]
        #[unsafe(method_family = none)]
        pub fn secureConnectionStartDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(secureConnectionEndDate))]
        #[unsafe(method_family = none)]
        pub fn secureConnectionEndDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(connectEndDate))]
        #[unsafe(method_family = none)]
        pub fn connectEndDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(requestStartDate))]
        #[unsafe(method_family = none)]
        pub fn requestStartDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(requestEndDate))]
        #[unsafe(method_family = none)]
        pub fn requestEndDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(responseStartDate))]
        #[unsafe(method_family = none)]
        pub fn responseStartDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSDate")]
        #[unsafe(method(responseEndDate))]
        #[unsafe(method_family = none)]
        pub fn responseEndDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(networkProtocolName))]
        #[unsafe(method_family = none)]
        pub fn networkProtocolName(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(isProxyConnection))]
        #[unsafe(method_family = none)]
        pub fn isProxyConnection(&self) -> bool;

        #[unsafe(method(isReusedConnection))]
        #[unsafe(method_family = none)]
        pub fn isReusedConnection(&self) -> bool;

        #[unsafe(method(resourceFetchType))]
        #[unsafe(method_family = none)]
        pub fn resourceFetchType(&self) -> NSURLSessionTaskMetricsResourceFetchType;

        #[unsafe(method(countOfRequestHeaderBytesSent))]
        #[unsafe(method_family = none)]
        pub fn countOfRequestHeaderBytesSent(&self) -> i64;

        #[unsafe(method(countOfRequestBodyBytesSent))]
        #[unsafe(method_family = none)]
        pub fn countOfRequestBodyBytesSent(&self) -> i64;

        #[unsafe(method(countOfRequestBodyBytesBeforeEncoding))]
        #[unsafe(method_family = none)]
        pub fn countOfRequestBodyBytesBeforeEncoding(&self) -> i64;

        #[unsafe(method(countOfResponseHeaderBytesReceived))]
        #[unsafe(method_family = none)]
        pub fn countOfResponseHeaderBytesReceived(&self) -> i64;

        #[unsafe(method(countOfResponseBodyBytesReceived))]
        #[unsafe(method_family = none)]
        pub fn countOfResponseBodyBytesReceived(&self) -> i64;

        #[unsafe(method(countOfResponseBodyBytesAfterDecoding))]
        #[unsafe(method_family = none)]
        pub fn countOfResponseBodyBytesAfterDecoding(&self) -> i64;

        #[cfg(feature = "NSString")]
        #[unsafe(method(localAddress))]
        #[unsafe(method_family = none)]
        pub fn localAddress(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSValue")]
        #[unsafe(method(localPort))]
        #[unsafe(method_family = none)]
        pub fn localPort(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(remoteAddress))]
        #[unsafe(method_family = none)]
        pub fn remoteAddress(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSValue")]
        #[unsafe(method(remotePort))]
        #[unsafe(method_family = none)]
        pub fn remotePort(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "NSValue")]
        #[unsafe(method(negotiatedTLSProtocolVersion))]
        #[unsafe(method_family = none)]
        pub fn negotiatedTLSProtocolVersion(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "NSValue")]
        #[unsafe(method(negotiatedTLSCipherSuite))]
        #[unsafe(method_family = none)]
        pub fn negotiatedTLSCipherSuite(&self) -> Option<Retained<NSNumber>>;

        #[unsafe(method(isCellular))]
        #[unsafe(method_family = none)]
        pub fn isCellular(&self) -> bool;

        #[unsafe(method(isExpensive))]
        #[unsafe(method_family = none)]
        pub fn isExpensive(&self) -> bool;

        #[unsafe(method(isConstrained))]
        #[unsafe(method_family = none)]
        pub fn isConstrained(&self) -> bool;

        #[unsafe(method(isMultipath))]
        #[unsafe(method_family = none)]
        pub fn isMultipath(&self) -> bool;

        #[unsafe(method(domainResolutionProtocol))]
        #[unsafe(method_family = none)]
        pub fn domainResolutionProtocol(&self) -> NSURLSessionTaskMetricsDomainResolutionProtocol;

        #[deprecated = "Not supported"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[deprecated = "Not supported"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object encapsulating the metrics for a session task.
    ///
    /// ## Overview
    ///
    /// Each [`NSURLSessionTaskMetrics`](https://developer.apple.com/documentation/foundation/urlsessiontaskmetrics) object contains the [`taskInterval`](https://developer.apple.com/documentation/foundation/urlsessiontaskmetrics/taskinterval) and [`redirectCount`](https://developer.apple.com/documentation/foundation/urlsessiontaskmetrics/redirectcount), as well as metrics for each request-and-response transaction made during the execution of the task.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSURLSessionTaskMetrics;
);

unsafe impl Send for NSURLSessionTaskMetrics {}

unsafe impl Sync for NSURLSessionTaskMetrics {}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSURLSessionTaskMetrics {}
);

impl NSURLSessionTaskMetrics {
    extern_methods!(
        #[cfg(feature = "NSArray")]
        #[unsafe(method(transactionMetrics))]
        #[unsafe(method_family = none)]
        pub fn transactionMetrics(&self) -> Retained<NSArray<NSURLSessionTaskTransactionMetrics>>;

        #[cfg(feature = "NSDateInterval")]
        #[unsafe(method(taskInterval))]
        #[unsafe(method_family = none)]
        pub fn taskInterval(&self) -> Retained<NSDateInterval>;

        #[unsafe(method(redirectCount))]
        #[unsafe(method_family = none)]
        pub fn redirectCount(&self) -> NSUInteger;

        #[deprecated = "Not supported"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[deprecated = "Not supported"]
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}
