//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// Type indicating a parameter is a pointer to an `NSPoint` structure.
#[cfg(feature = "objc2-core-foundation")]
pub type NSPointPointer = *mut NSPoint;

/// Type indicating a parameter is array of `NSPoint` structures.
#[cfg(feature = "objc2-core-foundation")]
pub type NSPointArray = *mut NSPoint;

/// Type indicating parameter is a pointer to an `NSSize` structure.
#[cfg(feature = "objc2-core-foundation")]
pub type NSSizePointer = *mut NSSize;

/// Type indicating a parameter is an array of `NSSize` structures.
#[cfg(feature = "objc2-core-foundation")]
pub type NSSizeArray = *mut NSSize;

/// Type indicating a parameter is a pointer to an `NSRect` structure.
#[cfg(feature = "objc2-core-foundation")]
pub type NSRectPointer = *mut NSRect;

/// Type indicating a parameter is array of `NSRect` structures.
#[cfg(feature = "objc2-core-foundation")]
pub type NSRectArray = *mut NSRect;

/// A description of the distance between the edges of two rectangles.
///
/// ## Overview
///
/// Edge insets describe the distance between the edges of one rectangle to a related rectangle that can be described by measuring a constant but edge-specific distance from each edge.
///
/// A common use for this structure is to describe the relationship between a view’s frame and its alignment rectangle.
///
///
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct NSEdgeInsets {
    pub top: CGFloat,
    pub left: CGFloat,
    pub bottom: CGFloat,
    pub right: CGFloat,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for NSEdgeInsets {
    const ENCODING: Encoding = Encoding::Struct(
        "NSEdgeInsets",
        &[
            <CGFloat>::ENCODING,
            <CGFloat>::ENCODING,
            <CGFloat>::ENCODING,
            <CGFloat>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for NSEdgeInsets {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Send for NSEdgeInsets {}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Sync for NSEdgeInsets {}

/// Values representing alignment operations.
///
/// ## Overview
///
/// These constants are used by the [`NSIntegralRectWithOptions`](https://developer.apple.com/documentation/foundation/nsintegralrectwithoptions(_:_:)) function and other related methods, such as [`backingAlignedRect:options:`](https://developer.apple.com/documentation/appkit/nsview/backingalignedrect(_:options:)).
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSAlignmentOptions(pub c_ulonglong);
bitflags::bitflags! {
    impl NSAlignmentOptions: c_ulonglong {
/// Specifies that alignment of the minimum X coordinate should be to the nearest inward integral value.
        #[doc(alias = "NSAlignMinXInward")]
        const AlignMinXInward = 1<<0;
/// Specifies that alignment of the minimum Y coordinate should be to the nearest inward integral value.
        #[doc(alias = "NSAlignMinYInward")]
        const AlignMinYInward = 1<<1;
/// Specifies that alignment of the maximum X coordinate should be to the nearest inward integral value.
        #[doc(alias = "NSAlignMaxXInward")]
        const AlignMaxXInward = 1<<2;
/// Specifies that alignment of the maximum X coordinate should be to the nearest inward integral value.
        #[doc(alias = "NSAlignMaxYInward")]
        const AlignMaxYInward = 1<<3;
/// Specifies that alignment of the width should be to the nearest inward integral value.
        #[doc(alias = "NSAlignWidthInward")]
        const AlignWidthInward = 1<<4;
/// Specifies that alignment of the height should be to the nearest inward integral value.
        #[doc(alias = "NSAlignHeightInward")]
        const AlignHeightInward = 1<<5;
/// Specifies that alignment of the minimum X coordinate should be to the nearest outward integral value.
        #[doc(alias = "NSAlignMinXOutward")]
        const AlignMinXOutward = 1<<8;
/// Specifies that alignment of the minimum Y coordinate should be to the nearest outward integral value.
        #[doc(alias = "NSAlignMinYOutward")]
        const AlignMinYOutward = 1<<9;
/// Specifies that alignment of the maximum X coordinate should be to the nearest outward integral value.
        #[doc(alias = "NSAlignMaxXOutward")]
        const AlignMaxXOutward = 1<<10;
/// Specifies that alignment of the maximum Y coordinate should be to the nearest outward integral value.
        #[doc(alias = "NSAlignMaxYOutward")]
        const AlignMaxYOutward = 1<<11;
/// Specifies that alignment of the width should be to the nearest outward integral value.
        #[doc(alias = "NSAlignWidthOutward")]
        const AlignWidthOutward = 1<<12;
/// Specifies that alignment of the height should be to the nearest outward integral value.
        #[doc(alias = "NSAlignHeightOutward")]
        const AlignHeightOutward = 1<<13;
/// Specifies that alignment of the minimum X coordinate should be to the nearest integral value.
        #[doc(alias = "NSAlignMinXNearest")]
        const AlignMinXNearest = 1<<16;
/// Specifies that alignment of the minimum Y coordinate should be to the nearest integral value.
        #[doc(alias = "NSAlignMinYNearest")]
        const AlignMinYNearest = 1<<17;
/// Specifies that alignment of the maximum X coordinate should be to the nearest integral value.
        #[doc(alias = "NSAlignMaxXNearest")]
        const AlignMaxXNearest = 1<<18;
/// Specifies that alignment of the maximum Y coordinate should be to the nearest integral value.
        #[doc(alias = "NSAlignMaxYNearest")]
        const AlignMaxYNearest = 1<<19;
/// Specifies that alignment of the width should be to the nearest integral value.
        #[doc(alias = "NSAlignWidthNearest")]
        const AlignWidthNearest = 1<<20;
/// Specifies that alignment of the height should be to the nearest integral value.
        #[doc(alias = "NSAlignHeightNearest")]
        const AlignHeightNearest = 1<<21;
/// This option should be included  if the rectangle is in a flipped coordinate system. This allows 0.5 to be treated in a visually consistent way.
        #[doc(alias = "NSAlignRectFlipped")]
        const AlignRectFlipped = 1<<63;
/// Aligns all edges inward. This is the same as `NSAlignMinXInward|NSAlignMaxXInward|NSAlignMinYInward|NSAlignMaxYInward`.
        #[doc(alias = "NSAlignAllEdgesInward")]
        const AlignAllEdgesInward = NSAlignmentOptions::AlignMinXInward.0|NSAlignmentOptions::AlignMaxXInward.0|NSAlignmentOptions::AlignMinYInward.0|NSAlignmentOptions::AlignMaxYInward.0;
/// Aligns all edges outwards. This is the same as `NSAlignMinXOutward|NSAlignMaxXOutward|NSAlignMinYOutward|NSAlignMaxYOutward`.
        #[doc(alias = "NSAlignAllEdgesOutward")]
        const AlignAllEdgesOutward = NSAlignmentOptions::AlignMinXOutward.0|NSAlignmentOptions::AlignMaxXOutward.0|NSAlignmentOptions::AlignMinYOutward.0|NSAlignmentOptions::AlignMaxYOutward.0;
/// Aligns all edges to the nearest value. This is the same as `NSAlignMinXNearest|NSAlignMaxXNearest|NSAlignMinYNearest|NSAlignMaxYNearest`.
        #[doc(alias = "NSAlignAllEdgesNearest")]
        const AlignAllEdgesNearest = NSAlignmentOptions::AlignMinXNearest.0|NSAlignmentOptions::AlignMaxXNearest.0|NSAlignmentOptions::AlignMinYNearest.0|NSAlignmentOptions::AlignMaxYNearest.0;
    }
}

unsafe impl Encode for NSAlignmentOptions {
    const ENCODING: Encoding = c_ulonglong::ENCODING;
}

unsafe impl RefEncode for NSAlignmentOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// An `NSPoint` structure with both x and y coordinates set to `0`.
    #[cfg(feature = "objc2-core-foundation")]
    pub static NSZeroPoint: NSPoint;
}

extern "C" {
    /// An `NSSize` structure set to `0` in both dimensions.
    #[cfg(feature = "objc2-core-foundation")]
    pub static NSZeroSize: NSSize;
}

extern "C" {
    /// An `NSRect` structure set to `0` in width and height.
    #[cfg(feature = "objc2-core-foundation")]
    pub static NSZeroRect: NSRect;
}

extern "C" {
    /// An edge insets structure with a zero inset on each edge.
    #[cfg(feature = "objc2-core-foundation")]
    pub static NSEdgeInsetsZero: NSEdgeInsets;
}

// TODO: pub fn NSMakePoint(x: CGFloat,y: CGFloat,) -> NSPoint;

// TODO: pub fn NSMakeSize(w: CGFloat,h: CGFloat,) -> NSSize;

// TODO: pub fn NSMakeRect(x: CGFloat,y: CGFloat,w: CGFloat,h: CGFloat,) -> NSRect;

// TODO: pub fn NSMaxX(a_rect: NSRect,) -> CGFloat;

// TODO: pub fn NSMaxY(a_rect: NSRect,) -> CGFloat;

// TODO: pub fn NSMidX(a_rect: NSRect,) -> CGFloat;

// TODO: pub fn NSMidY(a_rect: NSRect,) -> CGFloat;

// TODO: pub fn NSMinX(a_rect: NSRect,) -> CGFloat;

// TODO: pub fn NSMinY(a_rect: NSRect,) -> CGFloat;

// TODO: pub fn NSWidth(a_rect: NSRect,) -> CGFloat;

// TODO: pub fn NSHeight(a_rect: NSRect,) -> CGFloat;

// TODO: pub fn NSRectFromCGRect(cgrect: CGRect,) -> NSRect;

// TODO: pub fn NSRectToCGRect(nsrect: NSRect,) -> CGRect;

// TODO: pub fn NSPointFromCGPoint(cgpoint: CGPoint,) -> NSPoint;

// TODO: pub fn NSPointToCGPoint(nspoint: NSPoint,) -> CGPoint;

// TODO: pub fn NSSizeFromCGSize(cgsize: CGSize,) -> NSSize;

// TODO: pub fn NSSizeToCGSize(nssize: NSSize,) -> CGSize;

#[cfg(feature = "objc2-core-foundation")]
impl NSEdgeInsets {
    // TODO: pub fn NSEdgeInsetsMake(top: CGFloat,left: CGFloat,bottom: CGFloat,right: CGFloat,) -> NSEdgeInsets;
}

/// Returns a Boolean value that indicates whether two points are equal.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the two points `aPoint` and `bPoint` are identical, otherwise [`false`](https://developer.apple.com/documentation/swift/false).
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSEqualPoints(a_point: NSPoint, b_point: NSPoint) -> bool {
    extern "C-unwind" {
        fn NSEqualPoints(a_point: NSPoint, b_point: NSPoint) -> Bool;
    }
    unsafe { NSEqualPoints(a_point, b_point) }.as_bool()
}

/// Returns a Boolean that indicates whether two size values are equal.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if `aSize` and `bSize` are identical, otherwise [`false`](https://developer.apple.com/documentation/swift/false).
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSEqualSizes(a_size: NSSize, b_size: NSSize) -> bool {
    extern "C-unwind" {
        fn NSEqualSizes(a_size: NSSize, b_size: NSSize) -> Bool;
    }
    unsafe { NSEqualSizes(a_size, b_size) }.as_bool()
}

/// Returns a Boolean value that indicates whether the two rectangles are equal.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if `aRect` and `bRect` are identical, otherwise [`false`](https://developer.apple.com/documentation/swift/false).
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSEqualRects(a_rect: NSRect, b_rect: NSRect) -> bool {
    extern "C-unwind" {
        fn NSEqualRects(a_rect: NSRect, b_rect: NSRect) -> Bool;
    }
    unsafe { NSEqualRects(a_rect, b_rect) }.as_bool()
}

/// Returns a Boolean value that indicates whether a given rectangle is empty.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if `aRect` encloses no area at all—that is, if its width or height is 0 or negative, otherwise [`false`](https://developer.apple.com/documentation/swift/false).
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSIsEmptyRect(a_rect: NSRect) -> bool {
    extern "C-unwind" {
        fn NSIsEmptyRect(a_rect: NSRect) -> Bool;
    }
    unsafe { NSIsEmptyRect(a_rect) }.as_bool()
}

#[cfg(feature = "objc2-core-foundation")]
impl NSEdgeInsets {
    /// Returns a Boolean value that indicates whether two edge insets structures are equal.
    #[doc(alias = "NSEdgeInsetsEqual")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn equal(self, b_insets: NSEdgeInsets) -> bool {
        extern "C-unwind" {
            fn NSEdgeInsetsEqual(a_insets: NSEdgeInsets, b_insets: NSEdgeInsets) -> Bool;
        }
        unsafe { NSEdgeInsetsEqual(self, b_insets) }.as_bool()
    }
}

/// Insets a rectangle by a specified amount.
///
/// ## Return Value
///
/// A copy of `aRect`, altered by moving the two sides that are parallel to the y axis inward by `dX`, and the two sides parallel to the x axis inwards by `dY`.
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSInsetRect(a_rect: NSRect, d_x: CGFloat, d_y: CGFloat) -> NSRect {
    extern "C-unwind" {
        fn NSInsetRect(a_rect: NSRect, d_x: CGFloat, d_y: CGFloat) -> NSRect;
    }
    unsafe { NSInsetRect(a_rect, d_x, d_y) }
}

/// Adjusts the sides of a rectangle to integer values.
///
/// ## Return Value
///
/// A copy of `aRect`, expanded outward just enough to ensure that none of its four defining values (x, y, width, and height) have fractional parts. If the width or height of `aRect` is `0` or negative, this function returns a rectangle with origin at (0.0, 0.0) and with zero width and height.
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSIntegralRect(a_rect: NSRect) -> NSRect {
    extern "C-unwind" {
        fn NSIntegralRect(a_rect: NSRect) -> NSRect;
    }
    unsafe { NSIntegralRect(a_rect) }
}

/// Adjusts the sides of a rectangle to integral values using the specified options.
///
/// ## Return Value
///
/// A copy of `aRect`, modified based on the options. The options are defined in `NSAlignmentOptions`.
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSIntegralRectWithOptions(
    a_rect: NSRect,
    opts: NSAlignmentOptions,
) -> NSRect {
    extern "C-unwind" {
        fn NSIntegralRectWithOptions(a_rect: NSRect, opts: NSAlignmentOptions) -> NSRect;
    }
    unsafe { NSIntegralRectWithOptions(a_rect, opts) }
}

/// Calculates the union of two rectangles.
///
/// ## Discussion
///
/// Returns the smallest rectangle that completely encloses both `aRect` and `bRect`. If one of the rectangles has 0 (or negative) width or height, a copy of the other rectangle is returned; but if both have 0 (or negative) width or height, the returned rectangle has its origin at (0.0, 0.0) and has 0 width and height.
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSUnionRect(a_rect: NSRect, b_rect: NSRect) -> NSRect {
    extern "C-unwind" {
        fn NSUnionRect(a_rect: NSRect, b_rect: NSRect) -> NSRect;
    }
    unsafe { NSUnionRect(a_rect, b_rect) }
}

/// Calculates the intersection of two rectangles.
///
/// ## Return Value
///
/// The graphic intersection of `aRect` and `bRect`. If the two rectangles don’t overlap, the returned rectangle has its origin at (0.0, 0.0) and zero width and height (including situations where the intersection is a point or a line segment).
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSIntersectionRect(a_rect: NSRect, b_rect: NSRect) -> NSRect {
    extern "C-unwind" {
        fn NSIntersectionRect(a_rect: NSRect, b_rect: NSRect) -> NSRect;
    }
    unsafe { NSIntersectionRect(a_rect, b_rect) }
}

/// Offsets the rectangle by the specified amount.
///
/// ## Return Value
///
/// A copy of `aRect`, with its location shifted by `dX` along the x axis and by `dY` along the y axis.
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSOffsetRect(a_rect: NSRect, d_x: CGFloat, d_y: CGFloat) -> NSRect {
    extern "C-unwind" {
        fn NSOffsetRect(a_rect: NSRect, d_x: CGFloat, d_y: CGFloat) -> NSRect;
    }
    unsafe { NSOffsetRect(a_rect, d_x, d_y) }
}

extern "C-unwind" {
    /// Divides a rectangle into two new rectangles.
    ///
    /// ## Discussion
    ///
    /// Creates two rectangles—`slice` and `rem`—from `inRect`, by dividing `inRect` with a line that’s parallel to the side of `inRect` specified by `edge`. The size of `slice` is determined by `amount`, which specifies the distance from `edge`.
    ///
    /// `slice` and `rem` must not be `NULL`.
    ///
    /// For more information, see [`NSRectEdge`](https://developer.apple.com/documentation/foundation/nsrectedge).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `slice` must be a valid pointer.
    /// - `rem` must be a valid pointer.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn NSDivideRect(
        in_rect: NSRect,
        slice: NonNull<NSRect>,
        rem: NonNull<NSRect>,
        amount: CGFloat,
        edge: NSRectEdge,
    );
}

/// Returns a Boolean value that indicates whether a given point is in a given rectangle.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if `aPoint` is located within the rectangle represented by `aRect`, otherwise [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// ## Discussion
///
/// Point-in-rectangle functions generally assume that the “upper” and “left” edges of a rectangle are inside  the rectangle boundaries, while the “lower” and “right” edges are outside the boundaries. This method treats the “upper” and “left” edges of the rectangle as the ones containing the origin of the rectangle.
///
/// ### Special Considerations
///
/// The meanings of “upper” and “lower” (and “left” and “right”) are relative to the current coordinate system and the location of the rectangle. For a rectangle of positive height located in positive x and y coordinates:
///
/// - In the default macOS desktop coordinate system—where the origin is at the bottom left—the rectangle edge closest to the bottom of the screen is the “upper” edge (and is considered inside the rectangle).
///
/// - On iOS and in a flipped coordinate system in macOS desktop—where the origin is at the top left—the rectangle edge closest to the bottom of the screen is the “lower” edge (and is considered outside the rectangle).
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSPointInRect(a_point: NSPoint, a_rect: NSRect) -> bool {
    extern "C-unwind" {
        fn NSPointInRect(a_point: NSPoint, a_rect: NSRect) -> Bool;
    }
    unsafe { NSPointInRect(a_point, a_rect) }.as_bool()
}

/// Returns a Boolean value that indicates whether the point is in the specified rectangle.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the hot spot of the cursor lies inside a given rectangle, otherwise [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// ## Discussion
///
/// This method assumes an unscaled and unrotated coordinate system. Specify [`true`](https://developer.apple.com/documentation/swift/true) for `flipped` if the underlying view uses a flipped coordinate system.
///
/// Point-in-rectangle functions generally assume that the bottom edge of a rectangle is outside of the rectangle boundaries, while the upper edge is inside the boundaries. This method views `aRect` from the point of view of the user—that is, this method always treats the bottom edge of the rectangle as the one closest to the bottom edge of the user’s screen. By making this adjustment, this function ensures consistent mouse-detection behavior from the user’s perspective.
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSMouseInRect(a_point: NSPoint, a_rect: NSRect, flipped: bool) -> bool {
    extern "C-unwind" {
        fn NSMouseInRect(a_point: NSPoint, a_rect: NSRect, flipped: Bool) -> Bool;
    }
    unsafe { NSMouseInRect(a_point, a_rect, Bool::new(flipped)) }.as_bool()
}

/// Returns a Boolean value that indicates whether one rectangle completely encloses another.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if `aRect` completely encloses `bRect`. For this condition to be true, `bRect` cannot be empty, and must not extend beyond `aRect` in any direction.
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSContainsRect(a_rect: NSRect, b_rect: NSRect) -> bool {
    extern "C-unwind" {
        fn NSContainsRect(a_rect: NSRect, b_rect: NSRect) -> Bool;
    }
    unsafe { NSContainsRect(a_rect, b_rect) }.as_bool()
}

/// Returns a Boolean value that indicates whether two rectangles intersect.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if `aRect` intersects `bRect`, otherwise [`false`](https://developer.apple.com/documentation/swift/false). Returns [`false`](https://developer.apple.com/documentation/swift/false) if either `aRect` or `bRect` has a width or height that is 0.
///
///
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub extern "C-unwind" fn NSIntersectsRect(a_rect: NSRect, b_rect: NSRect) -> bool {
    extern "C-unwind" {
        fn NSIntersectsRect(a_rect: NSRect, b_rect: NSRect) -> Bool;
    }
    unsafe { NSIntersectsRect(a_rect, b_rect) }.as_bool()
}

#[cfg(feature = "NSString")]
impl NSString {
    /// Returns a string representation of a point.
    ///
    /// Parameters:
    /// - aPoint: A point structure.
    ///
    ///
    /// ## Return Value
    ///
    /// A string of the form “{a, b}”, where a and b are the x and y coordinates of `aPoint`.
    ///
    ///
    #[doc(alias = "NSStringFromPoint")]
    #[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
    #[inline]
    pub fn from_point(a_point: NSPoint) -> Retained<NSString> {
        extern "C-unwind" {
            fn NSStringFromPoint(a_point: NSPoint) -> *mut NSString;
        }
        let ret = unsafe { NSStringFromPoint(a_point) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns a string representation of a size.
    ///
    /// ## Return Value
    ///
    /// A string of the form “{a, b}”, where a and b are the width and height, respectively, of `aSize`.
    ///
    ///
    #[doc(alias = "NSStringFromSize")]
    #[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
    #[inline]
    pub fn from_size(a_size: NSSize) -> Retained<NSString> {
        extern "C-unwind" {
            fn NSStringFromSize(a_size: NSSize) -> *mut NSString;
        }
        let ret = unsafe { NSStringFromSize(a_size) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns a string representation of a rectangle.
    ///
    /// ## Discussion
    ///
    /// Returns a string of the form “{{a, b}, {c, d}}”, where a, b, c, and d are the x and y coordinates and the width and height, respectively, of `aRect`.
    ///
    ///
    #[doc(alias = "NSStringFromRect")]
    #[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
    #[inline]
    pub fn from_rect(a_rect: NSRect) -> Retained<NSString> {
        extern "C-unwind" {
            fn NSStringFromRect(a_rect: NSRect) -> *mut NSString;
        }
        let ret = unsafe { NSStringFromRect(a_rect) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// Returns a point from a text-based representation.
///
/// Parameters:
/// - aString: A string of the form “{x, y}”.
///
///
/// ## Return Value
///
/// If `aString` is of the form “{x, y}” an `NSPoint` structure that uses x and y as the x and y coordinates, in that order.
///
///
///
/// ## Discussion
///
/// If `aString` only contains a single number, it is used as the x coordinate. If `aString` does not contain any numbers, returns an `NSPoint` object whose x and y coordinates are both 0.
///
///
#[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
#[inline]
pub extern "C-unwind" fn NSPointFromString(a_string: &NSString) -> NSPoint {
    extern "C-unwind" {
        fn NSPointFromString(a_string: &NSString) -> NSPoint;
    }
    unsafe { NSPointFromString(a_string) }
}

/// Returns an `NSSize` from a text-based representation.
///
/// ## Discussion
///
/// Scans `aString` for two numbers which are used as the width and height, in that order, to create an `NSSize` struct. If `aString` only contains a single number, it is used as the width. The `aString` argument should be formatted like the output of [`NSStringFromSize`](https://developer.apple.com/documentation/foundation/nsstringfromsize(_:)), for example, `@"{10,20}"`. If `aString` does not contain any numbers, this function returns an `NSSize` struct whose width and height are both `0`.
///
///
#[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
#[inline]
pub extern "C-unwind" fn NSSizeFromString(a_string: &NSString) -> NSSize {
    extern "C-unwind" {
        fn NSSizeFromString(a_string: &NSString) -> NSSize;
    }
    unsafe { NSSizeFromString(a_string) }
}

/// Returns a rectangle from a text-based representation.
///
/// ## Discussion
///
/// Scans `aString` for four numbers which are used as the x and y coordinates and the width and height, in that order, to create an NSPoint object. If `aString` does not contain four numbers, those numbers that were scanned are used, and 0 is used for the remaining values. If `aString` does not contain any numbers, this function returns an NSRect object with a rectangle whose origin is (0, 0) and width and height are both 0.
///
///
#[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
#[inline]
pub extern "C-unwind" fn NSRectFromString(a_string: &NSString) -> NSRect {
    extern "C-unwind" {
        fn NSRectFromString(a_string: &NSString) -> NSRect;
    }
    unsafe { NSRectFromString(a_string) }
}

/// NSValueGeometryExtensions.
#[cfg(feature = "NSValue")]
impl NSValue {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(valueWithPoint:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithPoint(point: NSPoint) -> Retained<NSValue>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(valueWithSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithSize(size: NSSize) -> Retained<NSValue>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(valueWithRect:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithRect(rect: NSRect) -> Retained<NSValue>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(valueWithEdgeInsets:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithEdgeInsets(insets: NSEdgeInsets) -> Retained<NSValue>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(pointValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn pointValue(&self) -> NSPoint;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(sizeValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn sizeValue(&self) -> NSSize;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(rectValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn rectValue(&self) -> NSRect;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(edgeInsetsValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn edgeInsetsValue(&self) -> NSEdgeInsets;
    );
}

/// NSGeometryCoding.
#[cfg(feature = "NSCoder")]
impl NSCoder {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(encodePoint:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodePoint(&self, point: NSPoint);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(decodePoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodePoint(&self) -> NSPoint;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(encodeSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeSize(&self, size: NSSize);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(decodeSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeSize(&self) -> NSSize;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(encodeRect:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRect(&self, rect: NSRect);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(decodeRect))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeRect(&self) -> NSRect;
    );
}

/// NSGeometryKeyedCoding.
#[cfg(feature = "NSCoder")]
impl NSCoder {
    extern_methods!(
        #[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
        #[unsafe(method(encodePoint:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodePoint_forKey(&self, point: NSPoint, key: &NSString);

        #[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
        #[unsafe(method(encodeSize:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeSize_forKey(&self, size: NSSize, key: &NSString);

        #[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
        #[unsafe(method(encodeRect:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRect_forKey(&self, rect: NSRect, key: &NSString);

        #[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
        #[unsafe(method(decodePointForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodePointForKey(&self, key: &NSString) -> NSPoint;

        #[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
        #[unsafe(method(decodeSizeForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeSizeForKey(&self, key: &NSString) -> NSSize;

        #[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
        #[unsafe(method(decodeRectForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeRectForKey(&self, key: &NSString) -> NSRect;
    );
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `NSEdgeInsets::equal`"]
#[inline]
pub extern "C-unwind" fn NSEdgeInsetsEqual(a_insets: NSEdgeInsets, b_insets: NSEdgeInsets) -> bool {
    extern "C-unwind" {
        fn NSEdgeInsetsEqual(a_insets: NSEdgeInsets, b_insets: NSEdgeInsets) -> Bool;
    }
    unsafe { NSEdgeInsetsEqual(a_insets, b_insets) }.as_bool()
}

#[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
#[deprecated = "renamed to `NSString::from_point`"]
#[inline]
pub extern "C-unwind" fn NSStringFromPoint(a_point: NSPoint) -> Retained<NSString> {
    extern "C-unwind" {
        fn NSStringFromPoint(a_point: NSPoint) -> *mut NSString;
    }
    let ret = unsafe { NSStringFromPoint(a_point) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
#[deprecated = "renamed to `NSString::from_size`"]
#[inline]
pub extern "C-unwind" fn NSStringFromSize(a_size: NSSize) -> Retained<NSString> {
    extern "C-unwind" {
        fn NSStringFromSize(a_size: NSSize) -> *mut NSString;
    }
    let ret = unsafe { NSStringFromSize(a_size) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[cfg(all(feature = "NSString", feature = "objc2-core-foundation"))]
#[deprecated = "renamed to `NSString::from_rect`"]
#[inline]
pub extern "C-unwind" fn NSStringFromRect(a_rect: NSRect) -> Retained<NSString> {
    extern "C-unwind" {
        fn NSStringFromRect(a_rect: NSRect) -> *mut NSString;
    }
    let ret = unsafe { NSStringFromRect(a_rect) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}
