//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern "C" {
    /// The name of the exception raised by `NSKeyedArchiver` if there is a problem creating an archive.
    #[cfg(all(feature = "NSObjCRuntime", feature = "NSString"))]
    pub static NSInvalidArchiveOperationException: &'static NSExceptionName;
}

extern "C" {
    /// The name of the exception raised by `NSKeyedArchiver` if there is a problem extracting an archive.
    #[cfg(all(feature = "NSObjCRuntime", feature = "NSString"))]
    pub static NSInvalidUnarchiveOperationException: &'static NSExceptionName;
}

extern "C" {
    /// Archives created using the class method [`archivedDataWithRootObject:`](https://developer.apple.com/documentation/foundation/nskeyedarchiver/archiveddata(withrootobject:)) use this key for the root object in the hierarchy of encoded objects. The [`NSKeyedUnarchiver`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver) class method [`unarchiveObjectWithData:`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver/unarchiveobject(with:)) looks for this root key as well.
    #[cfg(feature = "NSString")]
    pub static NSKeyedArchiveRootObjectKey: &'static NSString;
}

extern_class!(
    /// An encoder that stores an object’s data to an archive referenced by keys.
    ///
    /// ## Overview
    ///
    /// [`NSKeyedArchiver`](https://developer.apple.com/documentation/foundation/nskeyedarchiver), a concrete subclass of [`NSCoder`](https://developer.apple.com/documentation/foundation/nscoder), provides a way to encode objects (and scalar values) into an architecture-independent format suitable for storage in a file. When you archive a set of objects, the archiver writes the class information and instance variables for each object to the archive. The companion class [`NSKeyedUnarchiver`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver) decodes the data in an archive and creates a set of objects equivalent to the original set.
    ///
    /// A keyed archive differs from a non-keyed archive in that all the objects and values encoded into the archive have names, or keys. When decoding a non-keyed archive, the decoder must decode values in the same order the original encoder used. When decoding a keyed archive, the decoder requests values by name, meaning it can decode values out of sequence or not at all. Keyed archives, therefore, provide better support for forward and backward compatibility.
    ///
    /// The keys given to encoded values must be unique only within the scope of the currently-encoding object. A keyed archive is hierarchical, so the keys used by object A to encode its instance variables don’t conflict with the keys used by object B. This is true even if A and B are instances of the same class. Within a single object, however, the keys used by a subclass can conflict with keys used in its superclasses.
    ///
    /// An [`NSArchiver`](https://developer.apple.com/documentation/foundation/nsarchiver) object can write the archive data to a file or to a mutable-data object (an instance of [`NSMutableData`](https://developer.apple.com/documentation/foundation/nsmutabledata)) that you provide.
    ///
    ///
    #[unsafe(super(NSCoder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSCoder")]
    pub struct NSKeyedArchiver;
);

#[cfg(feature = "NSCoder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSKeyedArchiver {}
);

#[cfg(feature = "NSCoder")]
impl NSKeyedArchiver {
    extern_methods!(
        /// Initializes the receiver for encoding an archive, optionally disabling secure coding.
        ///
        /// If
        /// `NSSecureCoding`cannot be used,
        /// `requiresSecureCoding`may be turned off here; for improved security, however,
        /// `requiresSecureCoding`should be left enabled whenever possible.
        /// `requiresSecureCoding`ensures that all encoded objects conform to
        /// `NSSecureCoding,`preventing the possibility of encoding objects which cannot be decoded later.
        ///
        /// To produce archives whose structure matches those previously encoded using
        /// `+archivedDataWithRootObject,`encode the top-level object in your archive for the
        /// `NSKeyedArchiveRootObjectKey.`
        #[unsafe(method(initRequiringSecureCoding:))]
        #[unsafe(method_family = init)]
        pub fn initRequiringSecureCoding(
            this: Allocated<Self>,
            requires_secure_coding: bool,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSData", feature = "NSError"))]
        /// Returns an
        /// `NSData`object containing the encoded form of the object graph whose root object is given, optionally disabling secure coding.
        ///
        /// If
        /// `NSSecureCoding`cannot be used,
        /// `requiresSecureCoding`may be turned off here; for improved security, however,
        /// `requiresSecureCoding`should be left enabled whenever possible.
        /// `requiresSecureCoding`ensures that all encoded objects conform to
        /// `NSSecureCoding,`preventing the possibility of encoding objects which cannot be decoded later.
        ///
        /// If the object graph cannot be encoded, returns
        /// `nil`and sets the
        /// `error`out parameter.
        ///
        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[unsafe(method(archivedDataWithRootObject:requiringSecureCoding:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn archivedDataWithRootObject_requiringSecureCoding_error(
            object: &AnyObject,
            requires_secure_coding: bool,
        ) -> Result<Retained<NSData>, Retained<NSError>>;

        /// Initialize the archiver with empty data, ready for writing.
        #[deprecated = "Use -initRequiringSecureCoding: instead"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSData")]
        #[deprecated = "Use -initRequiringSecureCoding: instead"]
        #[unsafe(method(initForWritingWithMutableData:))]
        #[unsafe(method_family = init)]
        pub fn initForWritingWithMutableData(
            this: Allocated<Self>,
            data: &NSMutableData,
        ) -> Retained<Self>;

        #[cfg(feature = "NSData")]
        /// # Safety
        ///
        /// `root_object` should be of the correct type.
        #[deprecated = "Use +archivedDataWithRootObject:requiringSecureCoding:error: instead"]
        #[unsafe(method(archivedDataWithRootObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn archivedDataWithRootObject(root_object: &AnyObject) -> Retained<NSData>;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `root_object` should be of the correct type.
        #[deprecated = "Use +archivedDataWithRootObject:requiringSecureCoding:error: and -writeToURL:options:error: instead"]
        #[unsafe(method(archiveRootObject:toFile:))]
        #[unsafe(method_family = none)]
        pub unsafe fn archiveRootObject_toFile(root_object: &AnyObject, path: &NSString) -> bool;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSKeyedArchiverDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSKeyedArchiverDelegate>>,
        );

        #[cfg(feature = "NSPropertyList")]
        #[unsafe(method(outputFormat))]
        #[unsafe(method_family = none)]
        pub fn outputFormat(&self) -> NSPropertyListFormat;

        #[cfg(feature = "NSPropertyList")]
        /// Setter for [`outputFormat`][Self::outputFormat].
        #[unsafe(method(setOutputFormat:))]
        #[unsafe(method_family = none)]
        pub fn setOutputFormat(&self, output_format: NSPropertyListFormat);

        #[cfg(feature = "NSData")]
        /// If encoding has not yet finished, then invoking this property will call finishEncoding and return the data. If you initialized the keyed archiver with a specific mutable data instance, then it will be returned from this property after finishEncoding is called.
        #[unsafe(method(encodedData))]
        #[unsafe(method_family = none)]
        pub fn encodedData(&self) -> Retained<NSData>;

        #[unsafe(method(finishEncoding))]
        #[unsafe(method_family = none)]
        pub fn finishEncoding(&self);

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `cls` probably has further requirements.
        #[unsafe(method(setClassName:forClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setClassName_forClass_class(coded_name: Option<&NSString>, cls: &AnyClass);

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `cls` probably has further requirements.
        #[unsafe(method(setClassName:forClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setClassName_forClass(&self, coded_name: Option<&NSString>, cls: &AnyClass);

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `cls` probably has further requirements.
        #[unsafe(method(classNameForClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn classNameForClass_class(cls: &AnyClass) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `cls` probably has further requirements.
        #[unsafe(method(classNameForClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn classNameForClass(&self, cls: &AnyClass) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[unsafe(method(encodeObject:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeObject_forKey(&self, object: Option<&AnyObject>, key: &NSString);

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[unsafe(method(encodeConditionalObject:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeConditionalObject_forKey(
            &self,
            object: Option<&AnyObject>,
            key: &NSString,
        );

        #[cfg(feature = "NSString")]
        #[unsafe(method(encodeBool:forKey:))]
        #[unsafe(method_family = none)]
        pub fn encodeBool_forKey(&self, value: bool, key: &NSString);

        #[cfg(feature = "NSString")]
        #[unsafe(method(encodeInt:forKey:))]
        #[unsafe(method_family = none)]
        pub fn encodeInt_forKey(&self, value: c_int, key: &NSString);

        #[cfg(feature = "NSString")]
        #[unsafe(method(encodeInt32:forKey:))]
        #[unsafe(method_family = none)]
        pub fn encodeInt32_forKey(&self, value: i32, key: &NSString);

        #[cfg(feature = "NSString")]
        #[unsafe(method(encodeInt64:forKey:))]
        #[unsafe(method_family = none)]
        pub fn encodeInt64_forKey(&self, value: i64, key: &NSString);

        #[cfg(feature = "NSString")]
        #[unsafe(method(encodeFloat:forKey:))]
        #[unsafe(method_family = none)]
        pub fn encodeFloat_forKey(&self, value: c_float, key: &NSString);

        #[cfg(feature = "NSString")]
        #[unsafe(method(encodeDouble:forKey:))]
        #[unsafe(method_family = none)]
        pub fn encodeDouble_forKey(&self, value: c_double, key: &NSString);

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `bytes` must be a valid pointer or null.
        #[unsafe(method(encodeBytes:length:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBytes_length_forKey(
            &self,
            bytes: *const u8,
            length: NSUInteger,
            key: &NSString,
        );

        #[unsafe(method(requiresSecureCoding))]
        #[unsafe(method_family = none)]
        pub fn requiresSecureCoding(&self) -> bool;

        /// Setter for [`requiresSecureCoding`][Self::requiresSecureCoding].
        #[unsafe(method(setRequiresSecureCoding:))]
        #[unsafe(method_family = none)]
        pub fn setRequiresSecureCoding(&self, requires_secure_coding: bool);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSCoder")]
impl NSKeyedArchiver {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

#[cfg(feature = "NSCoder")]
impl DefaultRetained for NSKeyedArchiver {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// A decoder that restores data from an archive referenced by keys.
    ///
    /// ## Overview
    ///
    /// [`NSKeyedUnarchiver`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver) is a concrete subclass of [`NSCoder`](https://developer.apple.com/documentation/foundation/nscoder) that defines methods for decoding a set of named objects (and scalar values) from a keyed archive. The [`NSKeyedArchiver`](https://developer.apple.com/documentation/foundation/nskeyedarchiver) class produces archives that this class can decode.
    ///
    /// The archiver creates keyed archive as a hierarchy of objects. The archiver treats each object as a namespace into which it can encode other objects. This means that an unarchiver can only decode objects encoded within the immediate scope of their parent object. Objects encoded elsewhere in the hierarchy — whether higher than, lower than, or parallel to this particular object — aren’t accessible. In this way, the keys used by a particular object to encode its instance variables need to be unique only within the scope of that object.
    ///
    /// If you invoke one of the `decode`-prefixed methods of this class using a key that does not exist in the archive, the return value indicates failure. This value varies by decoded type. For example, if a key does not exist in an archive, [`decodeBoolForKey:`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver/decodebool(forkey:)) returns [`false`](https://developer.apple.com/documentation/swift/false), [`decodeIntForKey:`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver/decodeintforkey:) returns `0`, and [`decodeObjectForKey:`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver/decodeobject(forkey:)) returns `nil`.
    ///
    /// [`NSKeyedUnarchiver`](https://developer.apple.com/documentation/foundation/nskeyedunarchiver) supports limited type coercion for numeric types. You can use any of the integer decode methods to decode a value encoded as any type of integer, whether a standard `Int` or an explicit 32-bit or 64-bit integer. Likewise, you can use the `Float`- or `Double`-returning decode methods to handle value encoded as a `Float` or `Double`. If an encoded value is too large to fit within the coerced type, the decoding method throws a [`NSRangeException`](https://developer.apple.com/documentation/foundation/nsexceptionname/rangeexception). Further, when trying to coerce a value to an incompatible type — for example decoding an `Int` as a `Float` — the decoding method throws an [`NSInvalidUnarchiveOperationException`](https://developer.apple.com/documentation/foundation/nsexceptionname/invalidunarchiveoperationexception).
    ///
    ///
    #[unsafe(super(NSCoder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSCoder")]
    pub struct NSKeyedUnarchiver;
);

#[cfg(feature = "NSCoder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSKeyedUnarchiver {}
);

#[cfg(feature = "NSCoder")]
impl NSKeyedUnarchiver {
    extern_methods!(
        #[cfg(all(feature = "NSData", feature = "NSError"))]
        /// Initializes the receiver for decoding an archive previously encoded by
        /// `NSKeyedUnarchiver.`
        /// Enables
        /// `requiresSecureCoding`by default. If
        /// `NSSecureCoding`cannot be used,
        /// `requiresSecureCoding`may be turned off manually; for improved security,
        /// `requiresSecureCoding`should be left enabled whenever possible.
        ///
        /// Sets the unarchiver's
        /// `decodingFailurePolicy`to
        /// `NSDecodingFailurePolicySetErrorAndReturn.`
        /// Returns
        /// `nil`if the given data is not valid, and sets the
        /// `error`out parameter.
        #[unsafe(method(initForReadingFromData:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initForReadingFromData_error(
            this: Allocated<Self>,
            data: &NSData,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(all(feature = "NSData", feature = "NSError"))]
        /// Decodes the root object of the given class from the given archive, previously encoded by
        /// `NSKeyedArchiver.`
        /// Enables
        /// `requiresSecureCoding`and sets the
        /// `decodingFailurePolicy`to
        /// `NSDecodingFailurePolicySetErrorAndReturn.`
        /// Returns
        /// `nil`if the given data is not valid or cannot be decoded, and sets the
        /// `error`out parameter.
        ///
        /// # Safety
        ///
        /// `cls` probably has further requirements.
        #[unsafe(method(unarchivedObjectOfClass:fromData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn unarchivedObjectOfClass_fromData_error(
            cls: &AnyClass,
            data: &NSData,
        ) -> Result<Retained<AnyObject>, Retained<NSError>>;

        #[cfg(all(feature = "NSArray", feature = "NSData", feature = "NSError"))]
        /// Decodes the
        /// `NSArray`root object from
        /// `data`which should be an
        /// `NSArray<cls>`containing the given non-collection class (no nested arrays or arrays of dictionaries, etc) from the given archive, previously encoded by
        /// `NSKeyedArchiver.`Enables
        /// `requiresSecureCoding`and sets the
        /// `decodingFailurePolicy`to
        /// `NSDecodingFailurePolicySetErrorAndReturn.`
        /// Returns
        /// `nil`if the given data is not valid or cannot be decoded, and sets the
        /// `error`out parameter.
        ///
        /// # Safety
        ///
        /// `cls` probably has further requirements.
        #[unsafe(method(unarchivedArrayOfObjectsOfClass:fromData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn unarchivedArrayOfObjectsOfClass_fromData_error(
            cls: &AnyClass,
            data: &NSData,
        ) -> Result<Retained<NSArray>, Retained<NSError>>;

        #[cfg(all(feature = "NSData", feature = "NSDictionary", feature = "NSError"))]
        /// Decodes the
        /// `NSDictionary`root object from
        /// `data`which should be an
        /// `NSDictionary<keyCls,objectCls>`with keys of type given in
        /// `keyCls`and objects of the given non-collection class
        /// `objectCls`(no nested dictionaries or other dictionaries contained in the dictionary, etc) from the given archive, previously encoded by
        /// `NSKeyedArchiver.`
        /// Enables
        /// `requiresSecureCoding`and sets the
        /// `decodingFailurePolicy`to
        /// `NSDecodingFailurePolicySetErrorAndReturn.`
        /// Returns
        /// `nil`if the given data is not valid or cannot be decoded, and sets the
        /// `error`out parameter.
        ///
        /// # Safety
        ///
        /// - `key_cls` probably has further requirements.
        /// - `value_cls` probably has further requirements.
        #[unsafe(method(unarchivedDictionaryWithKeysOfClass:objectsOfClass:fromData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn unarchivedDictionaryWithKeysOfClass_objectsOfClass_fromData_error(
            key_cls: &AnyClass,
            value_cls: &AnyClass,
            data: &NSData,
        ) -> Result<Retained<NSDictionary>, Retained<NSError>>;

        #[cfg(all(feature = "NSData", feature = "NSError", feature = "NSSet"))]
        /// Decodes the root object of one of the given classes from the given archive, previously encoded by
        /// `NSKeyedArchiver.`
        /// Enables
        /// `requiresSecureCoding`and sets the
        /// `decodingFailurePolicy`to
        /// `NSDecodingFailurePolicySetErrorAndReturn.`
        /// Returns
        /// `nil`if the given data is not valid or cannot be decoded, and sets the
        /// `error`out parameter.
        ///
        /// # Safety
        ///
        /// `classes` generic probably has further requirements.
        #[unsafe(method(unarchivedObjectOfClasses:fromData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn unarchivedObjectOfClasses_fromData_error(
            classes: &NSSet<AnyClass>,
            data: &NSData,
        ) -> Result<Retained<AnyObject>, Retained<NSError>>;

        #[cfg(all(
            feature = "NSArray",
            feature = "NSData",
            feature = "NSError",
            feature = "NSSet"
        ))]
        /// Decodes the
        /// `NSArray`root object from
        /// `data`which should be an
        /// `NSArray,`containing the given non-collection classes in
        /// `classes`(no nested arrays or arrays of dictionaries, etc) from the given archive, previously encoded by
        /// `NSKeyedArchiver.`
        /// Enables
        /// `requiresSecureCoding`and sets the
        /// `decodingFailurePolicy`to
        /// `NSDecodingFailurePolicySetErrorAndReturn.`
        /// Returns
        /// `nil`if the given data is not valid or cannot be decoded, and sets the
        /// `error`out parameter.
        ///
        /// # Safety
        ///
        /// `classes` generic probably has further requirements.
        #[unsafe(method(unarchivedArrayOfObjectsOfClasses:fromData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn unarchivedArrayOfObjectsOfClasses_fromData_error(
            classes: &NSSet<AnyClass>,
            data: &NSData,
        ) -> Result<Retained<NSArray>, Retained<NSError>>;

        #[cfg(all(
            feature = "NSData",
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSSet"
        ))]
        /// Decodes the
        /// `NSDictionary`root object from
        /// `data`which should be an
        /// `NSDictionary,`with keys of the types given in
        /// `keyClasses`and objects of the given non-collection classes in
        /// `objectClasses`(no nested dictionaries or other dictionaries contained in the dictionary, etc) from the given archive, previously encoded by
        /// `NSKeyedArchiver.`
        /// Enables
        /// `requiresSecureCoding`and sets the
        /// `decodingFailurePolicy`to
        /// `NSDecodingFailurePolicySetErrorAndReturn.`
        /// Returns
        /// `nil`if the given data is not valid or cannot be decoded, and sets the
        /// `error`out parameter.
        ///
        /// # Safety
        ///
        /// - `key_classes` generic probably has further requirements.
        /// - `value_classes` generic probably has further requirements.
        #[unsafe(method(unarchivedDictionaryWithKeysOfClasses:objectsOfClasses:fromData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn unarchivedDictionaryWithKeysOfClasses_objectsOfClasses_fromData_error(
            key_classes: &NSSet<AnyClass>,
            value_classes: &NSSet<AnyClass>,
            data: &NSData,
        ) -> Result<Retained<NSDictionary>, Retained<NSError>>;

        #[deprecated = "Use -initForReadingFromData:error: instead"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "NSData")]
        #[deprecated = "Use -initForReadingFromData:error: instead"]
        #[unsafe(method(initForReadingWithData:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initForReadingWithData(
            this: Allocated<Self>,
            data: &NSData,
        ) -> Retained<Self>;

        #[cfg(feature = "NSData")]
        #[deprecated = "Use +unarchivedObjectOfClass:fromData:error: instead"]
        #[unsafe(method(unarchiveObjectWithData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn unarchiveObjectWithData(data: &NSData) -> Option<Retained<AnyObject>>;

        #[cfg(all(feature = "NSData", feature = "NSError"))]
        #[deprecated = "Use +unarchivedObjectOfClass:fromData:error: instead"]
        #[unsafe(method(unarchiveTopLevelObjectWithData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn unarchiveTopLevelObjectWithData_error(
            data: &NSData,
        ) -> Result<Retained<AnyObject>, Retained<NSError>>;

        #[cfg(feature = "NSString")]
        #[deprecated = "Use +unarchivedObjectOfClass:fromData:error: instead"]
        #[unsafe(method(unarchiveObjectWithFile:))]
        #[unsafe(method_family = none)]
        pub unsafe fn unarchiveObjectWithFile(path: &NSString) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn NSKeyedUnarchiverDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSKeyedUnarchiverDelegate>>,
        );

        #[unsafe(method(finishDecoding))]
        #[unsafe(method_family = none)]
        pub unsafe fn finishDecoding(&self);

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `cls` probably has further requirements.
        #[unsafe(method(setClass:forClassName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setClass_forClassName_class(cls: Option<&AnyClass>, coded_name: &NSString);

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `cls` probably has further requirements.
        #[unsafe(method(setClass:forClassName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setClass_forClassName(&self, cls: Option<&AnyClass>, coded_name: &NSString);

        #[cfg(feature = "NSString")]
        #[unsafe(method(classForClassName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn classForClassName_class(coded_name: &NSString) -> Option<&'static AnyClass>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(classForClassName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn classForClassName(&self, coded_name: &NSString) -> Option<&'static AnyClass>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(containsValueForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn containsValueForKey(&self, key: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(decodeObjectForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeObjectForKey(&self, key: &NSString) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(decodeBoolForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeBoolForKey(&self, key: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(decodeIntForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeIntForKey(&self, key: &NSString) -> c_int;

        #[cfg(feature = "NSString")]
        #[unsafe(method(decodeInt32ForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeInt32ForKey(&self, key: &NSString) -> i32;

        #[cfg(feature = "NSString")]
        #[unsafe(method(decodeInt64ForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeInt64ForKey(&self, key: &NSString) -> i64;

        #[cfg(feature = "NSString")]
        #[unsafe(method(decodeFloatForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeFloatForKey(&self, key: &NSString) -> c_float;

        #[cfg(feature = "NSString")]
        #[unsafe(method(decodeDoubleForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeDoubleForKey(&self, key: &NSString) -> c_double;

        #[cfg(feature = "NSString")]
        /// # Safety
        ///
        /// `lengthp` must be a valid pointer or null.
        #[unsafe(method(decodeBytesForKey:returnedLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeBytesForKey_returnedLength(
            &self,
            key: &NSString,
            lengthp: *mut NSUInteger,
        ) -> *const u8;

        #[unsafe(method(requiresSecureCoding))]
        #[unsafe(method_family = none)]
        pub unsafe fn requiresSecureCoding(&self) -> bool;

        /// Setter for [`requiresSecureCoding`][Self::requiresSecureCoding].
        #[unsafe(method(setRequiresSecureCoding:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRequiresSecureCoding(&self, requires_secure_coding: bool);

        #[unsafe(method(decodingFailurePolicy))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodingFailurePolicy(&self) -> NSDecodingFailurePolicy;

        /// Setter for [`decodingFailurePolicy`][Self::decodingFailurePolicy].
        #[unsafe(method(setDecodingFailurePolicy:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDecodingFailurePolicy(
            &self,
            decoding_failure_policy: NSDecodingFailurePolicy,
        );
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSCoder")]
impl NSKeyedUnarchiver {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// The optional methods implemented by the delegate of a keyed archiver.
    pub unsafe trait NSKeyedArchiverDelegate: NSObjectProtocol {
        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[optional]
        #[unsafe(method(archiver:willEncodeObject:))]
        #[unsafe(method_family = none)]
        unsafe fn archiver_willEncodeObject(
            &self,
            archiver: &NSKeyedArchiver,
            object: &AnyObject,
        ) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[optional]
        #[unsafe(method(archiver:didEncodeObject:))]
        #[unsafe(method_family = none)]
        unsafe fn archiver_didEncodeObject(
            &self,
            archiver: &NSKeyedArchiver,
            object: Option<&AnyObject>,
        );

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `new_object` should be of the correct type.
        #[optional]
        #[unsafe(method(archiver:willReplaceObject:withObject:))]
        #[unsafe(method_family = none)]
        unsafe fn archiver_willReplaceObject_withObject(
            &self,
            archiver: &NSKeyedArchiver,
            object: Option<&AnyObject>,
            new_object: Option<&AnyObject>,
        );

        #[cfg(feature = "NSCoder")]
        #[optional]
        #[unsafe(method(archiverWillFinish:))]
        #[unsafe(method_family = none)]
        fn archiverWillFinish(&self, archiver: &NSKeyedArchiver);

        #[cfg(feature = "NSCoder")]
        #[optional]
        #[unsafe(method(archiverDidFinish:))]
        #[unsafe(method_family = none)]
        fn archiverDidFinish(&self, archiver: &NSKeyedArchiver);
    }
);

extern_protocol!(
    /// The optional methods implemented by the delegate of a keyed unarchiver.
    pub unsafe trait NSKeyedUnarchiverDelegate: NSObjectProtocol {
        #[cfg(all(feature = "NSArray", feature = "NSCoder", feature = "NSString"))]
        #[optional]
        #[unsafe(method(unarchiver:cannotDecodeObjectOfClassName:originalClasses:))]
        #[unsafe(method_family = none)]
        fn unarchiver_cannotDecodeObjectOfClassName_originalClasses(
            &self,
            unarchiver: &NSKeyedUnarchiver,
            name: &NSString,
            class_names: &NSArray<NSString>,
        ) -> Option<&'static AnyClass>;

        #[cfg(feature = "NSCoder")]
        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `new_object` should be of the correct type.
        #[optional]
        #[unsafe(method(unarchiver:willReplaceObject:withObject:))]
        #[unsafe(method_family = none)]
        unsafe fn unarchiver_willReplaceObject_withObject(
            &self,
            unarchiver: &NSKeyedUnarchiver,
            object: &AnyObject,
            new_object: &AnyObject,
        );

        #[cfg(feature = "NSCoder")]
        #[optional]
        #[unsafe(method(unarchiverWillFinish:))]
        #[unsafe(method_family = none)]
        fn unarchiverWillFinish(&self, unarchiver: &NSKeyedUnarchiver);

        #[cfg(feature = "NSCoder")]
        #[optional]
        #[unsafe(method(unarchiverDidFinish:))]
        #[unsafe(method_family = none)]
        fn unarchiverDidFinish(&self, unarchiver: &NSKeyedUnarchiver);
    }
);

mod private_NSObjectNSKeyedArchiverObjectSubstitution {
    pub trait Sealed {}
}

/// Category "NSKeyedArchiverObjectSubstitution" on [`NSObject`].
#[doc(alias = "NSKeyedArchiverObjectSubstitution")]
pub unsafe trait NSObjectNSKeyedArchiverObjectSubstitution:
    ClassType + Sized + private_NSObjectNSKeyedArchiverObjectSubstitution::Sealed
{
    extern_methods!(
        #[unsafe(method(classForKeyedArchiver))]
        #[unsafe(method_family = none)]
        fn classForKeyedArchiver(&self) -> Option<&'static AnyClass>;

        #[cfg(feature = "NSCoder")]
        #[unsafe(method(replacementObjectForKeyedArchiver:))]
        #[unsafe(method_family = none)]
        fn replacementObjectForKeyedArchiver(
            &self,
            archiver: &NSKeyedArchiver,
        ) -> Option<Retained<AnyObject>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(classFallbacksForKeyedArchiver))]
        #[unsafe(method_family = none)]
        fn classFallbacksForKeyedArchiver() -> Retained<NSArray<NSString>>;
    );
}

impl private_NSObjectNSKeyedArchiverObjectSubstitution::Sealed for NSObject {}
unsafe impl NSObjectNSKeyedArchiverObjectSubstitution for NSObject {}

mod private_NSObjectNSKeyedUnarchiverObjectSubstitution {
    pub trait Sealed {}
}

/// Category "NSKeyedUnarchiverObjectSubstitution" on [`NSObject`].
#[doc(alias = "NSKeyedUnarchiverObjectSubstitution")]
pub unsafe trait NSObjectNSKeyedUnarchiverObjectSubstitution:
    ClassType + Sized + private_NSObjectNSKeyedUnarchiverObjectSubstitution::Sealed
{
    extern_methods!(
        #[unsafe(method(classForKeyedUnarchiver))]
        #[unsafe(method_family = none)]
        fn classForKeyedUnarchiver() -> &'static AnyClass;
    );
}

impl private_NSObjectNSKeyedUnarchiverObjectSubstitution::Sealed for NSObject {}
unsafe impl NSObjectNSKeyedUnarchiverObjectSubstitution for NSObject {}
