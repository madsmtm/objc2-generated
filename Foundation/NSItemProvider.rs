//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// Specifications that control which categories of processes can see an item.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSItemProviderRepresentationVisibility(pub NSInteger);
impl NSItemProviderRepresentationVisibility {
    /// A representation visibility specification conferring item visibility to all processes.
    #[doc(alias = "NSItemProviderRepresentationVisibilityAll")]
    pub const All: Self = Self(0);
    /// A representation visibility specification confining item visibility to processes created by the app’s development team.
    #[doc(alias = "NSItemProviderRepresentationVisibilityTeam")]
    pub const Team: Self = Self(1);
    /// A representation visibility specification confining item visibility to the app’s app group.
    #[doc(alias = "NSItemProviderRepresentationVisibilityGroup")]
    pub const Group: Self = Self(2);
    /// A representation visibility specification confining item visibility to the app that is the source of the item.
    #[doc(alias = "NSItemProviderRepresentationVisibilityOwnProcess")]
    pub const OwnProcess: Self = Self(3);
}

unsafe impl Encode for NSItemProviderRepresentationVisibility {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSItemProviderRepresentationVisibility {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Data-access specifications that declare how to handle items.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSItemProviderFileOptions(pub NSInteger);
bitflags::bitflags! {
    impl NSItemProviderFileOptions: NSInteger {
/// A data-access specification declaring that items should open in place, rather than being copied.
        #[doc(alias = "NSItemProviderFileOptionOpenInPlace")]
        const OpenInPlace = 1;
    }
}

unsafe impl Encode for NSItemProviderFileOptions {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSItemProviderFileOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// The protocol for implementing a class to allow an item provider to retrieve data from an instance of the class.
    ///
    /// ## Overview
    ///
    /// A source app uses an object that conforms to this protocol to initialize an item provider for a copied or dragged item.
    ///
    ///
    pub unsafe trait NSItemProviderWriting: NSObjectProtocol {
        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(writableTypeIdentifiersForItemProvider))]
        #[unsafe(method_family = none)]
        fn writableTypeIdentifiersForItemProvider_class() -> Retained<NSArray<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[optional]
        #[unsafe(method(writableTypeIdentifiersForItemProvider))]
        #[unsafe(method_family = none)]
        fn writableTypeIdentifiersForItemProvider(&self) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "NSString")]
        #[optional]
        #[unsafe(method(itemProviderVisibilityForRepresentationWithTypeIdentifier:))]
        #[unsafe(method_family = none)]
        fn itemProviderVisibilityForRepresentationWithTypeIdentifier_class(
            type_identifier: &NSString,
        ) -> NSItemProviderRepresentationVisibility;

        #[cfg(feature = "NSString")]
        #[optional]
        #[unsafe(method(itemProviderVisibilityForRepresentationWithTypeIdentifier:))]
        #[unsafe(method_family = none)]
        fn itemProviderVisibilityForRepresentationWithTypeIdentifier(
            &self,
            type_identifier: &NSString,
        ) -> NSItemProviderRepresentationVisibility;

        #[cfg(all(
            feature = "NSData",
            feature = "NSError",
            feature = "NSProgress",
            feature = "NSString",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadDataWithTypeIdentifier:forItemProviderCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadDataWithTypeIdentifier_forItemProviderCompletionHandler(
            &self,
            type_identifier: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        ) -> Option<Retained<NSProgress>>;
    }
);

extern_protocol!(
    /// The protocol for implementing a class to allow an item provider to create an instance of the class.
    ///
    /// ## Overview
    ///
    /// A destination app uses an object that conforms to this protocol to consume pasted or dropped items.
    ///
    ///
    pub unsafe trait NSItemProviderReading: NSObjectProtocol {
        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(readableTypeIdentifiersForItemProvider))]
        #[unsafe(method_family = none)]
        fn readableTypeIdentifiersForItemProvider() -> Retained<NSArray<NSString>>;

        #[cfg(all(feature = "NSData", feature = "NSError", feature = "NSString"))]
        #[unsafe(method(objectWithItemProviderData:typeIdentifier:error:_))]
        #[unsafe(method_family = none)]
        fn objectWithItemProviderData_typeIdentifier_error(
            data: &NSData,
            type_identifier: &NSString,
        ) -> Result<Retained<Self>, Retained<NSError>>;
    }
);

/// A block that receives the item provider’s data.
///
/// ## Discussion
///
/// Use this block to receive data from a call to the [`loadItemForTypeIdentifier:options:completionHandler:`](https://developer.apple.com/documentation/foundation/nsitemprovider/loaditem(fortypeidentifier:options:completionhandler:)) method. This block takes the following parameters:
///
/// - item: The item to be loaded. When specifying your block, set the type of this parameter to the specific data type you want. For example, when requesting text data, you might set the type to [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) or [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring). The item provider attempts to coerce the data to the class you specify.
///
/// - error: A pointer to an error object for receiving information about any problems that occurred when loading the data.
///
///
#[cfg(all(feature = "NSError", feature = "NSObject", feature = "block2"))]
pub type NSItemProviderCompletionHandler =
    *mut block2::DynBlock<dyn Fn(*mut ProtocolObject<dyn NSSecureCoding>, *mut NSError)>;

/// A block that loads the item provider’s data and coerces it to the specified type.
///
/// ## Discussion
///
/// Use this block when registering a type-specific coercion handler with the [`registerItemForTypeIdentifier:loadHandler:`](https://developer.apple.com/documentation/foundation/nsitemprovider/registeritem(fortypeidentifier:loadhandler:)) method. The parameters for this block are as follows:
///
/// - completionHandler: The completion handler to call with the resulting data. For information about this block, see [`NSItemProviderCompletionHandler`](https://developer.apple.com/documentation/foundation/nsitemprovider/completionhandler).
///
/// - expectedValueClass: The expected class of the item being loaded. Convert the item provider’s data to this type and pass the resulting object as the first parameter of the `completionHandler` block.
///
/// - options: A dictionary with options for how to provide the requested item. For example, the dictionary may contain the pixel dimensions of a requested image. For information about the supported keys, see [Options Dictionary Key](https://developer.apple.com/documentation/foundation/options-dictionary-key).
///
/// When a client calls the [`loadItemForTypeIdentifier:options:completionHandler:`](https://developer.apple.com/documentation/foundation/nsitemprovider/loaditem(fortypeidentifier:options:completionhandler:)) method and requests the appropriate type, the item provider executes your block. In your implementation, create an object of the expected type and execute the block in the `completionHandler` parameter, passing the newly created object as the first parameter of that block. If there is an error, pass `nil` for the object and provide an appropriate [`NSError`](https://developer.apple.com/documentation/foundation/nserror) object explaining what happened.
///
/// This type of block is also used for generating preview images. In the case of a preview image, the `expectedValueClass` is always a [`NSData`](https://developer.apple.com/documentation/foundation/nsdata), [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl), [`UIImage`](https://developer.apple.com/documentation/uikit/uiimage) (in iOS), or [`NSImage`](https://developer.apple.com/documentation/appkit/nsimage) (in macOS) class.
///
///
#[cfg(all(
    feature = "NSDictionary",
    feature = "NSError",
    feature = "NSObject",
    feature = "block2"
))]
pub type NSItemProviderLoadHandler = *mut block2::DynBlock<
    dyn Fn(NSItemProviderCompletionHandler, *const AnyClass, *mut NSDictionary),
>;

extern_class!(
    /// An item provider for conveying data or a file between processes during drag-and-drop or copy-and-paste activities, or from a host app to an app extension.
    ///
    /// ## Overview
    ///
    /// Starting in iOS 11, item providers play a central role in drag and drop, and in copy and paste. They continue to play a role with app extensions.
    ///
    /// The system uses an internal queue when calling the completion blocks for the `NSItemProvider` class. When using an item provider with drag and drop, ensure that UI updates take place on the main queue as follows:
    ///
    /// ```swift
    /// DispatchQueue.main.async {
    ///     // Work that impacts the user interface.
    /// }
    /// ```
    ///
    /// ### App extension support
    ///
    /// An app extension typically encounters item providers when examining the [`attachments`](https://developer.apple.com/documentation/foundation/nsextensionitem/attachments) property of an [`NSExtensionItem`](https://developer.apple.com/documentation/foundation/nsextensionitem) object. During that examination, the extension can use the [`hasItemConformingToTypeIdentifier:`](https://developer.apple.com/documentation/foundation/nsitemprovider/hasitemconformingtotypeidentifier(_:)) method to look for data that it recognizes. Item providers use [`Uniform Type Identifiers`](https://developer.apple.com/documentation/uniformtypeidentifiers) values to identify the data they contain. After finding a type of data that your extension can use, it calls the [`loadItemForTypeIdentifier:options:completionHandler:`](https://developer.apple.com/documentation/foundation/nsitemprovider/loaditem(fortypeidentifier:options:completionhandler:)) method to load the actual data, which is delivered to the provided completion handler.
    ///
    /// You can create item providers to vend data to another process. An extension that modifies an original data item can create a new `NSItemProvider` object to send back to the host app. When creating data items, you specify your data object and the type of that object. You can optionally use the [`previewImageHandler`](https://developer.apple.com/documentation/foundation/nsitemprovider/previewimagehandler) property to generate a preview image for your data.
    ///
    /// A single item provider may use custom blocks to provide its data in many different formats. When configuring an item provider, use the [`registerItemForTypeIdentifier:loadHandler:`](https://developer.apple.com/documentation/foundation/nsitemprovider/registeritem(fortypeidentifier:loadhandler:)) method to register your blocks and the formats each one supports. When a client requests data in a particular format, the item provider executes the corresponding block, which is then responsible for coercing the data to the appropriate type and returning it to the client.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSItemProvider;
);

#[cfg(feature = "NSObject")]
extern_conformance!(
    unsafe impl NSCopying for NSItemProvider {}
);

#[cfg(feature = "NSObject")]
unsafe impl CopyingHelper for NSItemProvider {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSItemProvider {}
);

impl NSItemProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(
            feature = "NSData",
            feature = "NSError",
            feature = "NSProgress",
            feature = "NSString",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `load_handler` block must be sendable.
        #[unsafe(method(registerDataRepresentationForTypeIdentifier:visibility:loadHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerDataRepresentationForTypeIdentifier_visibility_loadHandler(
            &self,
            type_identifier: &NSString,
            visibility: NSItemProviderRepresentationVisibility,
            load_handler: &block2::DynBlock<
                dyn Fn(
                    NonNull<block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>>,
                ) -> *mut NSProgress,
            >,
        );

        #[cfg(all(
            feature = "NSError",
            feature = "NSProgress",
            feature = "NSString",
            feature = "NSURL",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `load_handler` block must be sendable.
        #[unsafe(method(registerFileRepresentationForTypeIdentifier:fileOptions:visibility:loadHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerFileRepresentationForTypeIdentifier_fileOptions_visibility_loadHandler(
            &self,
            type_identifier: &NSString,
            file_options: NSItemProviderFileOptions,
            visibility: NSItemProviderRepresentationVisibility,
            load_handler: &block2::DynBlock<
                dyn Fn(
                    NonNull<block2::DynBlock<dyn Fn(*mut NSURL, Bool, *mut NSError)>>,
                ) -> *mut NSProgress,
            >,
        );

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(registeredTypeIdentifiers))]
        #[unsafe(method_family = none)]
        pub fn registeredTypeIdentifiers(&self) -> Retained<NSArray<NSString>>;

        #[cfg(all(feature = "NSArray", feature = "NSString"))]
        #[unsafe(method(registeredTypeIdentifiersWithFileOptions:))]
        #[unsafe(method_family = none)]
        pub fn registeredTypeIdentifiersWithFileOptions(
            &self,
            file_options: NSItemProviderFileOptions,
        ) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(hasItemConformingToTypeIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn hasItemConformingToTypeIdentifier(&self, type_identifier: &NSString) -> bool;

        #[cfg(feature = "NSString")]
        #[unsafe(method(hasRepresentationConformingToTypeIdentifier:fileOptions:))]
        #[unsafe(method_family = none)]
        pub fn hasRepresentationConformingToTypeIdentifier_fileOptions(
            &self,
            type_identifier: &NSString,
            file_options: NSItemProviderFileOptions,
        ) -> bool;

        #[cfg(all(
            feature = "NSData",
            feature = "NSError",
            feature = "NSProgress",
            feature = "NSString",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadDataRepresentationForTypeIdentifier:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadDataRepresentationForTypeIdentifier_completionHandler(
            &self,
            type_identifier: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        ) -> Retained<NSProgress>;

        #[cfg(all(
            feature = "NSError",
            feature = "NSProgress",
            feature = "NSString",
            feature = "NSURL",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadFileRepresentationForTypeIdentifier:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadFileRepresentationForTypeIdentifier_completionHandler(
            &self,
            type_identifier: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSURL, *mut NSError)>,
        ) -> Retained<NSProgress>;

        #[cfg(all(
            feature = "NSError",
            feature = "NSProgress",
            feature = "NSString",
            feature = "NSURL",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadInPlaceFileRepresentationForTypeIdentifier:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadInPlaceFileRepresentationForTypeIdentifier_completionHandler(
            &self,
            type_identifier: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSURL, Bool, *mut NSError)>,
        ) -> Retained<NSProgress>;

        #[cfg(feature = "NSString")]
        #[unsafe(method(suggestedName))]
        #[unsafe(method_family = none)]
        pub fn suggestedName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSString")]
        /// Setter for [`suggestedName`][Self::suggestedName].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        #[unsafe(method(setSuggestedName:))]
        #[unsafe(method_family = none)]
        pub fn setSuggestedName(&self, suggested_name: Option<&NSString>);

        #[unsafe(method(initWithObject:))]
        #[unsafe(method_family = init)]
        pub fn initWithObject(
            this: Allocated<Self>,
            object: &ProtocolObject<dyn NSItemProviderWriting>,
        ) -> Retained<Self>;

        #[unsafe(method(registerObject:visibility:))]
        #[unsafe(method_family = none)]
        pub fn registerObject_visibility(
            &self,
            object: &ProtocolObject<dyn NSItemProviderWriting>,
            visibility: NSItemProviderRepresentationVisibility,
        );

        #[cfg(all(feature = "NSObject", feature = "NSString"))]
        /// # Safety
        ///
        /// `item` should be of the correct type.
        #[unsafe(method(initWithItem:typeIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithItem_typeIdentifier(
            this: Allocated<Self>,
            item: Option<&ProtocolObject<dyn NSSecureCoding>>,
            type_identifier: Option<&NSString>,
        ) -> Retained<Self>;

        #[cfg(feature = "NSURL")]
        /// # Safety
        ///
        /// `file_url` might not allow `None`.
        #[unsafe(method(initWithContentsOfURL:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContentsOfURL(
            this: Allocated<Self>,
            file_url: Option<&NSURL>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSObject",
            feature = "NSString",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `load_handler` must be a valid pointer.
        #[unsafe(method(registerItemForTypeIdentifier:loadHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerItemForTypeIdentifier_loadHandler(
            &self,
            type_identifier: &NSString,
            load_handler: NSItemProviderLoadHandler,
        );

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSObject",
            feature = "NSString",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// - `options` generic should be of the correct type.
        /// - `completion_handler` must be a valid pointer or null.
        #[unsafe(method(loadItemForTypeIdentifier:options:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadItemForTypeIdentifier_options_completionHandler(
            &self,
            type_identifier: &NSString,
            options: Option<&NSDictionary>,
            completion_handler: NSItemProviderCompletionHandler,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSItemProvider {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSItemProvider {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern "C" {
    /// A key provided to the options dictionary to indicate a preferred image size.
    ///
    /// ## Discussion
    ///
    /// Use this key only with the [`NSItemProvider`](https://developer.apple.com/documentation/foundation/nsitemprovider) type coercion policy. Ensure the value is an [`NSValue`](https://developer.apple.com/documentation/foundation/nsvalue) object that contains a [`CGSize`](https://developer.apple.com/documentation/corefoundation/cgsize) struct specifying the requested size, in points.
    ///
    ///
    #[cfg(feature = "NSString")]
    pub static NSItemProviderPreferredImageSizeKey: &'static NSString;
}

/// NSPreviewSupport.
impl NSItemProvider {
    extern_methods!(
        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSObject",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// The returned block must be sendable.
        #[unsafe(method(previewImageHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn previewImageHandler(&self) -> NSItemProviderLoadHandler;

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSObject",
            feature = "block2"
        ))]
        /// Setter for [`previewImageHandler`][Self::previewImageHandler].
        ///
        /// This is [copied][crate::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `preview_image_handler` must be a valid pointer or null.
        #[unsafe(method(setPreviewImageHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreviewImageHandler(
            &self,
            preview_image_handler: NSItemProviderLoadHandler,
        );

        #[cfg(all(
            feature = "NSDictionary",
            feature = "NSError",
            feature = "NSObject",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// - `options` generic should be of the correct type.
        /// - `options` might not allow `None`.
        /// - `completion_handler` must be a valid pointer.
        #[unsafe(method(loadPreviewImageWithOptions:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadPreviewImageWithOptions_completionHandler(
            &self,
            options: Option<&NSDictionary>,
            completion_handler: NSItemProviderCompletionHandler,
        );
    );
}

extern "C" {
    /// A key whose value is an item of type `kUTTypePropertyList`. The item contains an `NSDictionary` that contains the object returned by the JavaScript code to its completion function.
    #[cfg(feature = "NSString")]
    pub static NSExtensionJavaScriptPreprocessingResultsKey: Option<&'static NSString>;
}

extern "C" {
    /// A key whose value is an item of type `kUTTypePropertyList`. The item contains an `NSDictionary` that contains the arguments to be passed to a JavaScript finalize method.
    #[cfg(feature = "NSString")]
    pub static NSExtensionJavaScriptFinalizeArgumentKey: Option<&'static NSString>;
}

extern "C" {
    /// The error domain associated with the item provider.
    #[cfg(feature = "NSString")]
    pub static NSItemProviderErrorDomain: &'static NSString;
}

/// The error codes that describe problems with consuming data from an item provider.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NSItemProviderErrorCode(pub NSInteger);
impl NSItemProviderErrorCode {
    /// An error code indicating an unknown error with consuming data from an item provider.
    #[doc(alias = "NSItemProviderUnknownError")]
    pub const UnknownError: Self = Self(-1);
    /// An error code indicating that the requested data was unavailable from an item provider.
    #[doc(alias = "NSItemProviderItemUnavailableError")]
    pub const ItemUnavailableError: Self = Self(-1000);
    /// An error code indicating that type coercion to the requested class failed.
    #[doc(alias = "NSItemProviderUnexpectedValueClassError")]
    pub const UnexpectedValueClassError: Self = Self(-1100);
    /// An error code indicating that the requested data type coercion is unavailable from an item provider.
    #[doc(alias = "NSItemProviderUnavailableCoercionError")]
    pub const UnavailableCoercionError: Self = Self(-1200);
}

unsafe impl Encode for NSItemProviderErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSItemProviderErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}
