//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Statuses that PassKit uses when it adds passes to the pass library.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PKPassLibraryAddPassesStatus(pub NSInteger);
impl PKPassLibraryAddPassesStatus {
    /// A status that occurs when the user successfully adds one or more passes.
    #[doc(alias = "PKPassLibraryDidAddPasses")]
    pub const DidAddPasses: Self = Self(0);
    /// A status that occurs when the app prompts the user to review the passes.
    #[doc(alias = "PKPassLibraryShouldReviewPasses")]
    pub const ShouldReviewPasses: Self = Self(1);
    /// A status that occurs when the user cancels the addition of passes.
    #[doc(alias = "PKPassLibraryDidCancelAddPasses")]
    pub const DidCancelAddPasses: Self = Self(2);
}

unsafe impl Encode for PKPassLibraryAddPassesStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PKPassLibraryAddPassesStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The result of an attempt to suppress automatic pass presentation.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PKAutomaticPassPresentationSuppressionResult(pub NSUInteger);
impl PKAutomaticPassPresentationSuppressionResult {
    /// The device doesn’t support the suppression of automatic pass presentation.
    #[doc(alias = "PKAutomaticPassPresentationSuppressionResultNotSupported")]
    pub const NotSupported: Self = Self(0);
    /// The device is already presenting passes.
    ///
    /// ## Discussion
    ///
    /// The device is unable to suppress automatic presentation of passes.
    ///
    ///
    #[doc(alias = "PKAutomaticPassPresentationSuppressionResultAlreadyPresenting")]
    pub const AlreadyPresenting: Self = Self(1);
    /// The user prevented the suppression, or an internal error occurred.
    #[doc(alias = "PKAutomaticPassPresentationSuppressionResultDenied")]
    pub const Denied: Self = Self(2);
    /// The system canceled the suppression before calling the response handler.
    #[doc(alias = "PKAutomaticPassPresentationSuppressionResultCancelled")]
    pub const Cancelled: Self = Self(3);
    /// Suppression of automatic presentation successful.
    #[doc(alias = "PKAutomaticPassPresentationSuppressionResultSuccess")]
    pub const Success: Self = Self(4);
}

unsafe impl Encode for PKAutomaticPassPresentationSuppressionResult {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for PKAutomaticPassPresentationSuppressionResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PKPassLibraryCapability(pub NSInteger);
impl PKPassLibraryCapability {
    #[doc(alias = "PKPassLibraryCapabilityBackgroundAddPasses")]
    pub const BackgroundAddPasses: Self = Self(0);
}

unsafe impl Encode for PKPassLibraryCapability {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PKPassLibraryCapability {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PKPassLibraryAuthorizationStatus(pub NSInteger);
impl PKPassLibraryAuthorizationStatus {
    #[doc(alias = "PKPassLibraryAuthorizationStatusNotDetermined")]
    pub const NotDetermined: Self = Self(-1);
    #[doc(alias = "PKPassLibraryAuthorizationStatusDenied")]
    pub const Denied: Self = Self(0);
    #[doc(alias = "PKPassLibraryAuthorizationStatusAuthorized")]
    pub const Authorized: Self = Self(1);
    #[doc(alias = "PKPassLibraryAuthorizationStatusRestricted")]
    pub const Restricted: Self = Self(2);
}

unsafe impl Encode for PKPassLibraryAuthorizationStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PKPassLibraryAuthorizationStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A token that represents a request to suppress the automatic presentation of payment passes.
///
/// ## Discussion
///
/// You receive a suppression request token when you begin suppressing the automatic presentation of passes. Use the token to end the suppression and reenable Apple Pay.
///
///
pub type PKSuppressionRequestToken = NSUInteger;

extern_class!(
    /// Provides an interface to the user’s library of passes.
    ///
    /// ## Overview
    ///
    /// The `PKPassLibrary` isn’t thread-safe. Use instances of this class only on a single thread.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct PKPassLibrary;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for PKPassLibrary {}
);

impl PKPassLibrary {
    extern_methods!(
        #[unsafe(method(isPassLibraryAvailable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPassLibraryAvailable() -> bool;

        #[cfg(feature = "block2")]
        #[unsafe(method(requestAutomaticPassPresentationSuppressionWithResponseHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestAutomaticPassPresentationSuppressionWithResponseHandler(
            response_handler: &block2::DynBlock<
                dyn Fn(PKAutomaticPassPresentationSuppressionResult),
            >,
        ) -> PKSuppressionRequestToken;

        #[unsafe(method(endAutomaticPassPresentationSuppressionWithRequestToken:))]
        #[unsafe(method_family = none)]
        pub unsafe fn endAutomaticPassPresentationSuppressionWithRequestToken(
            request_token: PKSuppressionRequestToken,
        );

        #[unsafe(method(isSuppressingAutomaticPassPresentation))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSuppressingAutomaticPassPresentation() -> bool;

        #[deprecated = "Use -[PKPassLibrary isPaymentPassActivationAvailable] instead"]
        #[unsafe(method(isPaymentPassActivationAvailable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPaymentPassActivationAvailable_class() -> bool;

        #[deprecated = "Use -[PKPassLibrary isSecureElementPassActivationAvailable] instead"]
        #[unsafe(method(isPaymentPassActivationAvailable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPaymentPassActivationAvailable(&self) -> bool;

        #[unsafe(method(isSecureElementPassActivationAvailable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSecureElementPassActivationAvailable(&self) -> bool;

        #[cfg(all(feature = "PKObject", feature = "PKPass"))]
        #[unsafe(method(passes))]
        #[unsafe(method_family = none)]
        pub unsafe fn passes(&self) -> Retained<NSArray<PKPass>>;

        #[cfg(all(feature = "PKObject", feature = "PKPass"))]
        #[unsafe(method(passWithPassTypeIdentifier:serialNumber:))]
        #[unsafe(method_family = none)]
        pub unsafe fn passWithPassTypeIdentifier_serialNumber(
            &self,
            identifier: &NSString,
            serial_number: &NSString,
        ) -> Option<Retained<PKPass>>;

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKSecureElementPass"
        ))]
        #[unsafe(method(passesWithReaderIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn passesWithReaderIdentifier(
            &self,
            reader_identifier: &NSString,
        ) -> Retained<NSSet<PKSecureElementPass>>;

        #[cfg(all(feature = "PKObject", feature = "PKPass", feature = "PKPass_Types"))]
        #[unsafe(method(passesOfType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn passesOfType(&self, pass_type: PKPassType) -> Retained<NSArray<PKPass>>;

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKPaymentPass",
            feature = "PKSecureElementPass"
        ))]
        #[deprecated = "Use -[PKPassLibrary remoteSecureElementPasses] instead"]
        #[unsafe(method(remotePaymentPasses))]
        #[unsafe(method_family = none)]
        pub unsafe fn remotePaymentPasses(&self) -> Retained<NSArray<PKPaymentPass>>;

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKSecureElementPass"
        ))]
        #[unsafe(method(remoteSecureElementPasses))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteSecureElementPasses(&self) -> Retained<NSArray<PKSecureElementPass>>;

        #[cfg(all(feature = "PKObject", feature = "PKPass"))]
        #[unsafe(method(removePass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removePass(&self, pass: &PKPass);

        #[cfg(all(feature = "PKObject", feature = "PKPass"))]
        #[unsafe(method(containsPass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn containsPass(&self, pass: &PKPass) -> bool;

        #[cfg(all(feature = "PKObject", feature = "PKPass"))]
        #[unsafe(method(replacePassWithPass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn replacePassWithPass(&self, pass: &PKPass) -> bool;

        #[cfg(all(feature = "PKObject", feature = "PKPass", feature = "block2"))]
        #[unsafe(method(addPasses:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addPasses_withCompletionHandler(
            &self,
            passes: &NSArray<PKPass>,
            completion: Option<&block2::DynBlock<dyn Fn(PKPassLibraryAddPassesStatus)>>,
        );

        #[unsafe(method(openPaymentSetup))]
        #[unsafe(method_family = none)]
        pub unsafe fn openPaymentSetup(&self);

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKPaymentPass",
            feature = "PKSecureElementPass"
        ))]
        #[deprecated = "Use -[PKPassLibrary presentSecureElementPass:] instead"]
        #[unsafe(method(presentPaymentPass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentPaymentPass(&self, pass: &PKPaymentPass);

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKSecureElementPass"
        ))]
        #[unsafe(method(presentSecureElementPass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentSecureElementPass(&self, pass: &PKSecureElementPass);

        #[deprecated = "Use -[PKPassLibrary canAddSecureElementPassWithPrimaryAccountIdentifier] instead"]
        #[unsafe(method(canAddPaymentPassWithPrimaryAccountIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canAddPaymentPassWithPrimaryAccountIdentifier(
            &self,
            primary_account_identifier: &NSString,
        ) -> bool;

        #[unsafe(method(canAddSecureElementPassWithPrimaryAccountIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canAddSecureElementPassWithPrimaryAccountIdentifier(
            &self,
            primary_account_identifier: &NSString,
        ) -> bool;

        #[unsafe(method(canAddFelicaPass))]
        #[unsafe(method_family = none)]
        pub unsafe fn canAddFelicaPass(&self) -> bool;

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKPaymentPass",
            feature = "PKSecureElementPass",
            feature = "block2"
        ))]
        #[deprecated = "Use activateSecureElementPass:withActivationData:completion: instead"]
        #[unsafe(method(activatePaymentPass:withActivationData:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn activatePaymentPass_withActivationData_completion(
            &self,
            payment_pass: &PKPaymentPass,
            activation_data: &NSData,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, NonNull<NSError>)>>,
        );

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKPaymentPass",
            feature = "PKSecureElementPass",
            feature = "block2"
        ))]
        #[deprecated = "Use activatePaymentPass:withActivationData:completion: instead"]
        #[unsafe(method(activatePaymentPass:withActivationCode:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn activatePaymentPass_withActivationCode_completion(
            &self,
            payment_pass: &PKPaymentPass,
            activation_code: &NSString,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, NonNull<NSError>)>>,
        );

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKSecureElementPass",
            feature = "block2"
        ))]
        #[unsafe(method(activateSecureElementPass:withActivationData:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn activateSecureElementPass_withActivationData_completion(
            &self,
            secure_element_pass: &PKSecureElementPass,
            activation_data: &NSData,
            completion: Option<&block2::DynBlock<dyn Fn(Bool, *mut NSError)>>,
        );

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKSecureElementPass",
            feature = "block2"
        ))]
        #[unsafe(method(signData:withSecureElementPass:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn signData_withSecureElementPass_completion(
            &self,
            sign_data: &NSData,
            secure_element_pass: &PKSecureElementPass,
            completion: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSData, *mut NSError)>,
        );

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKSecureElementPass",
            feature = "block2"
        ))]
        #[unsafe(method(encryptedServiceProviderDataForSecureElementPass:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encryptedServiceProviderDataForSecureElementPass_completion(
            &self,
            secure_element_pass: &PKSecureElementPass,
            completion: &block2::DynBlock<dyn Fn(*mut NSDictionary, *mut NSError)>,
        );

        #[cfg(all(
            feature = "PKObject",
            feature = "PKPass",
            feature = "PKSecureElementPass",
            feature = "block2"
        ))]
        #[unsafe(method(serviceProviderDataForSecureElementPass:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn serviceProviderDataForSecureElementPass_completion(
            &self,
            secure_element_pass: &PKSecureElementPass,
            completion: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[unsafe(method(authorizationStatusForCapability:))]
        #[unsafe(method_family = none)]
        pub unsafe fn authorizationStatusForCapability(
            &self,
            capability: PKPassLibraryCapability,
        ) -> PKPassLibraryAuthorizationStatus;

        #[cfg(feature = "block2")]
        #[unsafe(method(requestAuthorizationForCapability:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestAuthorizationForCapability_completion(
            &self,
            capability: PKPassLibraryCapability,
            completion: &block2::DynBlock<dyn Fn(PKPassLibraryAuthorizationStatus)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl PKPassLibrary {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The types of notifications that the pass library posts.
// NS_TYPED_EXTENSIBLE_ENUM
pub type PKPassLibraryNotificationName = NSString;

extern "C" {
    /// A notification that PassKit posts when the pass library changes.
    ///
    /// ## Discussion
    ///
    /// PassKit posts this notification on an arbitary queue, and only does so if an instance of `PKPassLibrary` exists. The notification’s user info dictionary describes the changes. See [`PKPassLibrary`](https://developer.apple.com/documentation/passkit/pkpasslibrary) for the keys it uses.
    ///
    ///
    pub static PKPassLibraryDidChangeNotification: &'static PKPassLibraryNotificationName;
}

extern "C" {
    /// A notification that PassKit posts when it adds or removes a pass on a paired remote device.
    ///
    /// ## Discussion
    ///
    /// PassKit posts this notification on an arbitary queue, and only does so if an instance of `PKPassLibrary` exists. The notification’s user info dictionary describes the changes. See [`PKPassLibrary`](https://developer.apple.com/documentation/passkit/pkpasslibrary) for the keys it uses.
    ///
    ///
    pub static PKPassLibraryRemotePaymentPassesDidChangeNotification:
        &'static PKPassLibraryNotificationName;
}

/// The user info keys that a pass library notification uses.
// NS_TYPED_ENUM
pub type PKPassLibraryNotificationKey = NSString;

extern "C" {
    /// An array of added passes.
    pub static PKPassLibraryAddedPassesUserInfoKey: &'static PKPassLibraryNotificationKey;
}

extern "C" {
    /// An array of replaced passes.
    pub static PKPassLibraryReplacementPassesUserInfoKey: &'static PKPassLibraryNotificationKey;
}

extern "C" {
    /// An array of dictionaries that describes the removed passes.
    pub static PKPassLibraryRemovedPassInfosUserInfoKey: &'static PKPassLibraryNotificationKey;
}

extern "C" {
    /// The pass’s pass type identifier.
    pub static PKPassLibraryPassTypeIdentifierUserInfoKey: &'static PKPassLibraryNotificationKey;
}

extern "C" {
    /// The pass’s serial number.
    pub static PKPassLibrarySerialNumberUserInfoKey: &'static PKPassLibraryNotificationKey;
}

extern "C" {
    pub static PKPassLibraryRecoveredPassesUserInfoKey: &'static PKPassLibraryNotificationKey;
}
