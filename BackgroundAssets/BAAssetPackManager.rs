//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A class that manages asset packs.
    ///
    /// The first time that your code refers to the shared manager, Background Assets considers that your app is opting into automatic system management of your asset packs.
    /// - Important: When using the asset-pack manager, make sure that you also adopt the corresponding managed extension protocol. For apps that use Apple hosting, the corresponding protocol is `SKDownloaderExtension` from StoreKit. For other apps, the corresponding protocol is ``BAManagedDownloaderExtension``. Not adopting the right protocol is a programmer error.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/backgroundassets/baassetpackmanager?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct BAAssetPackManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for BAAssetPackManager {}
);

impl BAAssetPackManager {
    extern_methods!(
        /// The shared asset-pack manager.
        #[unsafe(method(sharedManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedManager() -> Retained<BAAssetPackManager>;

        #[cfg(feature = "BAManagedAssetPackDownloadDelegate")]
        /// An object that receives notifications about events that occur as an asset pack is downloaded.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn BAManagedAssetPackDownloadDelegate>>>;

        #[cfg(feature = "BAManagedAssetPackDownloadDelegate")]
        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn BAManagedAssetPackDownloadDelegate>>,
        );

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(all(feature = "BAAssetPack", feature = "block2"))]
        /// Gets the asset packs that are available to download.
        ///
        /// This method might attempt to get the latest asset-pack information from the server.
        /// - Parameter completionHandler: A block that receives the asset packs or an error if one occurs.
        #[unsafe(method(getAllAssetPacksWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAllAssetPacksWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSSet<BAAssetPack>, *mut NSError)>,
        );

        #[cfg(all(feature = "BAAssetPack", feature = "block2"))]
        /// Gets the asset pack with the specified identifier.
        ///
        /// If no asset pack with the specified identifier is found, then the block will receive an `NSError` object with ``BAManagedErrorCode/assetPackNotFound`` as its code for the `error` parameter. This method might attempt to get the latest asset-pack information from the server.
        /// - Parameters:
        /// - assetPackIdentifier: The asset pack’s identifier.
        /// - completionHandler: A block that receives the asset pack or an error if one occurs.
        #[unsafe(method(getAssetPackWithIdentifier:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAssetPackWithIdentifier_completionHandler(
            &self,
            asset_pack_identifier: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(*mut BAAssetPack, *mut NSError)>,
        );

        #[cfg(all(feature = "BAAssetPackStatus", feature = "block2"))]
        /// Gets the status of the asset pack with the specified identifier.
        ///
        /// If no asset pack with the specified identifier is found, then the block will receive an `NSError` object with ``BAManagedErrorCode/assetPackNotFound`` as its code for the `error` parameter. This method attempts to get the latest asset-pack information from the server. No updates or removals are automatically triggered.
        /// - Parameters:
        /// - assetPackIdentifier: The asset pack’s identifier.
        /// - completionHandler: A block that receives the status of the asset pack or an error if one occurs.
        #[unsafe(method(getStatusOfAssetPackWithIdentifier:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getStatusOfAssetPackWithIdentifier_completionHandler(
            &self,
            asset_pack_identifier: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(BAAssetPackStatus, *mut NSError)>,
        );

        #[cfg(all(feature = "BAAssetPack", feature = "block2"))]
        /// Ensures that the specified asset pack be available locally.
        ///
        /// This method checks if the asset pack is currently downloaded. If it isn’t, then it schedules it to be downloaded and calls the block with `nil` for the block’s `error` parameter when the download completes. It’s guaranteed that the requested asset pack will be available locally once the block is called with `nil` for its `error` parameter. If a non-`nil` value is provided to the block’s `error` parameter, then the asset pack is **not** guaranteed to be available locally. You can optionally monitor download progress by attaching a delegate object to `delegate`.
        /// - Parameters:
        /// - assetPack: The asset pack the local availability of which to ensure.
        /// - completionHandler: A block that’s called when the asset pack is available locally or that receives an error if one occurs.
        #[unsafe(method(ensureLocalAvailabilityOfAssetPack:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ensureLocalAvailabilityOfAssetPack_completionHandler(
            &self,
            asset_pack: &BAAssetPack,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Gets the latest asset-pack information from the server, updates outdated asset packs, and removes obsolete asset packs.
        /// - Parameter completionHandler: A block that receives a set of identifiers of asset packs that are being updated and a set of identifiers of removed asset packs or an error if one occurs.
        #[unsafe(method(checkForUpdatesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn checkForUpdatesWithCompletionHandler(
            &self,
            completion_handler: Option<
                &block2::DynBlock<dyn Fn(*mut NSSet<NSString>, *mut NSSet<NSString>, *mut NSError)>,
            >,
        );

        /// Gets the contents of a file at the specified relative file path.
        ///
        /// All asset packs share the same namespace, so you can treat the overall collection of downloaded asset packs as if it were a single root directory that contains all of your subdirectories and asset files, regardless of the specific asset pack in which any particular file resides. If there’s a file-path collision across multiple asset packs, then it’s undefined from which asset pack the file will be read unless you explicitly limit the search to a particular asset pack by passing a non-`nil` identifier to the `assetPackIdentifier` parameter.
        /// - Parameters:
        /// - path: The relative file path.
        /// - assetPackIdentifier: The identifier of the asset pack in which you want to search for the file or `nil` if you want to search in all asset packs.
        /// - options: Options for how to read the contents of the file into a data object.
        /// - error: A pointer to an error that will be set if an error occurs. If no file is found at `path`, then `error` will point to an `NSError` object with ``BAManagedErrorCode/fileNotFound`` as its code.
        /// - Returns: The file’s contents.
        #[unsafe(method(contentsAtPath:searchingInAssetPackWithIdentifier:options:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentsAtPath_searchingInAssetPackWithIdentifier_options_error(
            &self,
            path: &NSString,
            asset_pack_identifier: Option<&NSString>,
            options: NSDataReadingOptions,
        ) -> Result<Retained<NSData>, Retained<NSError>>;

        /// Gets the URL for the specified relative file path.
        ///
        /// All asset packs share the same namespace, so you can treat the overall collection of downloaded asset packs as if it were a single root directory that contains all of your subdirectories and asset files, regardless of the specific asset pack in which any particular file resides. Unlike ``BAAssetPackManager/contentsAtPath:searchingInAssetPackWithIdentifier:options:error:`` and ``BAAssetPackManager/fileDescriptorForPath:searchingInAssetPackWithIdentifier:error:``, this method supports retrieving entire directories—including packages—in which case it merges the corresponding slices of the shared logical directory from all downloaded asset packs that contain such slices. If there’s a file-path collision across multiple asset packs, then it’s undefined from which asset pack an individual file will be resolved.
        /// - Parameters:
        /// - path: The relative file path.
        /// - error: A pointer to an error that will be set if an error occurs.
        /// - Warning: Don’t persist the returned URL beyond the lifetime of the current process.
        /// - Warning: This method is less efficient than are ``BAAssetPackManager/contentsAtPath:searchingInAssetPackWithIdentifier:options:error:`` and ``BAAssetPackManager/fileDescriptorForPath:searchingInAssetPackWithIdentifier:error:``; use those methods instead if you can do so. In particular, this method shouldn’t be used to get the URL to the root of the shared asset-pack namespace. Don’t use this method to block the main thread.
        /// - Note: This method will return a well formed URL even if no item exists at the specified relative path in any asset pack, in which case any attempts to get its contents—whether it’s a file or a directory—will fail.
        #[unsafe(method(URLForPath:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn URLForPath_error(
            &self,
            path: &NSString,
        ) -> Result<Retained<NSURL>, Retained<NSError>>;

        #[cfg(feature = "block2")]
        /// Removes the downloaded asset pack with the specified identifier.
        /// - Parameters:
        /// - assetPackIdentifier: The identifier of the asset pack to remove.
        /// - completionHandler: A block that receives an error if one occurs.
        #[unsafe(method(removeAssetPackWithIdentifier:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAssetPackWithIdentifier_completionHandler(
            &self,
            asset_pack_identifier: &NSString,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );
    );
}
