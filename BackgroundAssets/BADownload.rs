//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Constants that indicate the state of a download.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct BADownloadState(pub NSInteger);
impl BADownloadState {
    /// A state that indicates a failed download.
    #[doc(alias = "BADownloadStateFailed")]
    pub const Failed: Self = Self(-1);
    /// A state that indicates a created download.
    #[doc(alias = "BADownloadStateCreated")]
    pub const Created: Self = Self(0);
    /// A state that indicates a download is waiting to execute.
    #[doc(alias = "BADownloadStateWaiting")]
    pub const Waiting: Self = Self(1);
    /// A state that indicates a download is in progress.
    #[doc(alias = "BADownloadStateDownloading")]
    pub const Downloading: Self = Self(2);
    /// A state that indicates a finished download.
    #[doc(alias = "BADownloadStateFinished")]
    pub const Finished: Self = Self(3);
}

unsafe impl Encode for BADownloadState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for BADownloadState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A type that determines the execution priority of a scheduled asset download.
///
/// ## Overview
///
/// Use [`BADownloaderPriority`](https://developer.apple.com/documentation/backgroundassets/badownload/priority-swift.struct) to assign an app-specific priority to a download or group of downloads. The system processes downloads with a higher priority before those with a lower priority, no matter what order you schedule them in.
///
///
/// A download's priority
///
/// The priority applied to a given download or group of downloads. This is a range from `BADownloaderPriorityMin` to `BADownloaderPriorityMax`.
/// The priority only applies to how downloads are ordered for your application. Higher priority items will be enqued for download before lower priority items regardless of order in which they are scheduled.
// NS_TYPED_EXTENSIBLE_ENUM
pub type BADownloaderPriority = NSInteger;

extern "C" {
    /// The lowest execution priority.
    /// A value that represents the lowest priority for a download.
    pub static BADownloaderPriorityMin: BADownloaderPriority;
}

extern "C" {
    /// The default execution priority.
    /// A value that represents average priority for a download.
    pub static BADownloaderPriorityDefault: BADownloaderPriority;
}

extern "C" {
    /// The highest execution priority.
    /// A value that represents the highest priority for a download.
    pub static BADownloaderPriorityMax: BADownloaderPriority;
}

extern_class!(
    /// An object that represents an in-progress or concluded asset download.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  You donâ€™t create instances of this object directly. Instead, use an object that inherits from [`BADownload`](https://developer.apple.com/documentation/backgroundassets/badownload), such as [`BAURLDownload`](https://developer.apple.com/documentation/backgroundassets/baurldownload).
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct BADownload;
);

unsafe impl Send for BADownload {}

unsafe impl Sync for BADownload {}

extern_conformance!(
    unsafe impl NSCoding for BADownload {}
);

extern_conformance!(
    unsafe impl NSCopying for BADownload {}
);

unsafe impl CopyingHelper for BADownload {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for BADownload {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for BADownload {}
);

impl BADownload {
    extern_methods!(
        /// The current state of the respresented download.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> BADownloadState;

        /// A client defined identifier that uniquely identifies this asset.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSString>;

        /// A UUID that uniquely identifies the download object.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(uniqueIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn uniqueIdentifier(&self) -> Retained<NSString>;

        /// A client set priority to try to order downloads in order of importance
        #[unsafe(method(priority))]
        #[unsafe(method_family = none)]
        pub unsafe fn priority(&self) -> BADownloaderPriority;

        /// Whether this download is essential.
        /// Essential downloads will occur while the app is being installed. Users cannot launch the app while these downloads are occurring.
        /// Essential downloads cannot be scheduled with `BADownloadManager`, they may only be scheduled from the extension with
        /// a `BAContentRequest` type of `Update` or `Install`.
        /// Essential downloads must have an accurate `fileSize` or they will fail.
        #[unsafe(method(isEssential))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEssential(&self) -> bool;

        /// Copies an existing download ensuring that it has `isEssential == false`.
        ///
        /// This serves as a convenience method for constructing a non-essential representation of an existing
        /// download. It is important to note that essential downloads can only be enqueued by
        /// the app extension during a content request. If an essential download fails, `copyAsNonEssential`
        /// can be used to create a copy with `isEssential == false` that can be re-queued with `BADownloadManager`.
        #[unsafe(method(copyAsNonEssential))]
        #[unsafe(method_family = copy)]
        pub unsafe fn copyAsNonEssential(&self) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
