//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-avf-audio")]
use objc2_avf_audio::*;
#[cfg(feature = "objc2-core-audio-types")]
use objc2_core_audio_types::*;
use objc2_foundation::*;

use crate::*;

/// Options that inform PHASE of an audio-stream buffer’s playback priority.
///
/// ## Overview
///
/// When your app provides audio buffers that PHASE plays through a [`PHASEPushStreamNode`](https://developer.apple.com/documentation/phase/phasepushstreamnode), use this structure to inform PHASE of a particular buffer’s priority.
///
/// Associate an option to a particular buffer by passing it in to the [`scheduleBuffer:atTime:options:`](https://developer.apple.com/documentation/phase/phasepushstreamnode/schedulebuffer(buffer:time:options:)) function of a [`PHASEPushStreamNode`](https://developer.apple.com/documentation/phase/phasepushstreamnode).
///
///
/// *************************************************************************************************
///
///
///
/// Options controlling buffer scheduling.
///
/// The buffer plays following any previously scheduled buffer(s).
///
/// The buffer loops indefinitely.
///
/// The buffer interrupts any buffer already playing.
///
/// The buffer interrupts any buffer already playing, at its loop point.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PHASEPushStreamBufferOptions(pub NSUInteger);
bitflags::bitflags! {
    impl PHASEPushStreamBufferOptions: NSUInteger {
/// Indicates a buffer processes after existing buffers in the queue.
        #[doc(alias = "PHASEPushStreamBufferDefault")]
        const Default = 1<<0;
/// Indicates a buffer restarts after it finishes processing.
        #[doc(alias = "PHASEPushStreamBufferLoops")]
        const Loops = 1<<1;
/// Indicates a buffer begins processing immediately.
        #[doc(alias = "PHASEPushStreamBufferInterrupts")]
        const Interrupts = 1<<2;
/// Indicates a buffer begins processing when an existing buffer loops.
        #[doc(alias = "PHASEPushStreamBufferInterruptsAtLoop")]
        const InterruptsAtLoop = 1<<3;
    }
}

unsafe impl Encode for PHASEPushStreamBufferOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for PHASEPushStreamBufferOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A status that describes the results after the app schedules a push-stream buffer.
///
/// ## Overview
///
/// A [`PHASEPushStreamNode`](https://developer.apple.com/documentation/phase/phasepushstreamnode) object provides an instance of this class to the completion closure after the app schedules a buffer by calling [`scheduleBuffer:completionCallbackType:completionHandler:`](https://developer.apple.com/documentation/phase/phasepushstreamnode/schedulebuffer(buffer:completioncallbacktype:completionhandler:)).
///
///
/// Specifies when the completion handler must be invoked.
///
/// The buffer data has been rendered by the player.
/// This does not account for any signal processing latencies downstream of the player in the engine.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct PHASEPushStreamCompletionCallbackCondition(pub NSInteger);
impl PHASEPushStreamCompletionCallbackCondition {
    /// Indicates the framework invokes the callback when the engine processes the audio for output.
    #[doc(alias = "PHASEPushStreamCompletionDataRendered")]
    pub const DataRendered: Self = Self(0);
}

unsafe impl Encode for PHASEPushStreamCompletionCallbackCondition {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASEPushStreamCompletionCallbackCondition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A base class for sound event nodes that connect to form a node hierarchy.
    ///
    /// ## Overview
    ///
    /// This class defines the base functionality for an object that, depending on the derived class’s type, either plays audio or hands off the invocation to one or more other nodes.
    ///
    /// ### Configure a Sound Event Node to Play Audio
    ///
    /// To play audio with this class, retrieve a sound-event node asset ([`PHASESoundEventNodeAsset`](https://developer.apple.com/documentation/phase/phasesoundeventnodeasset)) that generates sound events by creating and registering one of the audio-providing node definitions in [Sound Event Nodes](https://developer.apple.com/documentation/phase/sound-event-nodes). Call [`registerSoundEventAssetWithRootNode:identifier:error:`](https://developer.apple.com/documentation/phase/phaseassetregistry/registersoundeventasset(rootnode:identifier:)) and pass the node definition in the `rootNode` argument. Provide an `identifier` argument with a unique name that your app refers to later when generating a playable [`PHASESoundEvent`](https://developer.apple.com/documentation/phase/phasesoundevent).
    ///
    /// ### Configure a Node Hiearchy that Reacts to Your App’s State
    ///
    /// You can create a hierarchy of nodes that blends audio based on your app’s parameters, or plays the right audio based on your app’s state. To create the hierarchy, register one of the control nodes in [Sound Event Nodes](https://developer.apple.com/documentation/phase/sound-event-nodes) by calling [`registerSoundEventAssetWithRootNode:identifier:error:`](https://developer.apple.com/documentation/phase/phaseassetregistry/registersoundeventasset(rootnode:identifier:)), passing in a unique [`identifier`](https://developer.apple.com/documentation/phase/phasedefinition/identifier) you define for the subclass.
    ///
    /// The particular configuration you choose for a node hierarchy instructs PHASE on which audio to play, when to play it, or whether to hand off an invocation to one or more child nodes ([`children`](https://developer.apple.com/documentation/phase/phasesoundeventnodedefinition/children)).
    ///
    /// For example, if you register and invoke a [`PHASESwitchNodeDefinition`](https://developer.apple.com/documentation/phase/phaseswitchnodedefinition) that contains two child [`PHASESamplerNodeDefinition`](https://developer.apple.com/documentation/phase/phasesamplernodedefinition) objects, PHASE plays the audio of one of the child sampler nodes based on the current value of the switch node’s metaparameter. For more information, see [`metaParameters`](https://developer.apple.com/documentation/phase/phasesoundevent/metaparameters).
    ///
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// The base class for a sound event node definition.
    ///
    /// Sound event nodes are a hierarchical collection of objects that either generate or control playback of audio content in PHASE.
    /// Generator nodes produce audio. They are always leaf nodes in a node hierarchy. These include samplers and stream nodes.
    /// Control nodes set the logic for how generator nodes are selected, mixed and parameterized before downstream mixer processing.
    /// Control nodes are always parent nodes, and can be organized into hierarchies for complex sound design scenarios.
    #[unsafe(super(PHASEDefinition, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHASEDefinition")]
    pub struct PHASESoundEventNodeDefinition;
);

#[cfg(feature = "PHASEDefinition")]
extern_conformance!(
    unsafe impl NSObjectProtocol for PHASESoundEventNodeDefinition {}
);

#[cfg(feature = "PHASEDefinition")]
impl PHASESoundEventNodeDefinition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// The children of this node definition.
        #[unsafe(method(children))]
        #[unsafe(method_family = none)]
        pub unsafe fn children(&self) -> Retained<NSArray<PHASESoundEventNodeDefinition>>;
    );
}

extern_class!(
    /// A base class for nodes that provide audio data to generate sound.
    ///
    /// ## Overview
    ///
    /// This class encapsulates shared logic for subclasses that provide audio data to a mixer for sound output, namely [`PHASESamplerNodeDefinition`](https://developer.apple.com/documentation/phase/phasesamplernodedefinition) and [`PHASEPushStreamNodeDefinition`](https://developer.apple.com/documentation/phase/phasepushstreamnodedefinition).
    ///
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// An object for defining a generator node when building a sound event.
    #[unsafe(super(PHASESoundEventNodeDefinition, PHASEDefinition, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHASEDefinition")]
    pub struct PHASEGeneratorNodeDefinition;
);

#[cfg(feature = "PHASEDefinition")]
extern_conformance!(
    unsafe impl NSObjectProtocol for PHASEGeneratorNodeDefinition {}
);

#[cfg(feature = "PHASEDefinition")]
impl PHASEGeneratorNodeDefinition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "PHASETypes")]
        /// Set the generator's calibration mode and level.
        ///
        /// Parameter `calibrationMode`: The calibration mode.
        ///
        /// Parameter `level`: The level.
        ///
        /// Note: The level, including its underlying unit and range, are dependent on the calibration mode.
        #[unsafe(method(setCalibrationMode:level:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCalibrationMode_level(
            &self,
            calibration_mode: PHASECalibrationMode,
            level: c_double,
        );

        #[cfg(feature = "PHASETypes")]
        /// The generator's calibration mode. The default value is PHASECalibrationModeNone.
        #[unsafe(method(calibrationMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn calibrationMode(&self) -> PHASECalibrationMode;

        /// The generator's level. The default value is 1.
        ///
        /// Note: The level's underlying unit and range are dependent on the calibrationMode.
        #[unsafe(method(level))]
        #[unsafe(method_family = none)]
        pub unsafe fn level(&self) -> c_double;

        /// Linear rate scalar.
        ///
        /// Note: Values are clamped to the range [0.25, 4]. Default value is 1.
        #[unsafe(method(rate))]
        #[unsafe(method_family = none)]
        pub unsafe fn rate(&self) -> c_double;

        /// Setter for [`rate`][Self::rate].
        #[unsafe(method(setRate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRate(&self, rate: c_double);

        #[cfg(feature = "PHASEGroup")]
        /// The PHASEGroup object this generator should be associated with for gain and rate control.
        #[unsafe(method(group))]
        #[unsafe(method_family = none)]
        pub unsafe fn group(&self) -> Option<Retained<PHASEGroup>>;

        #[cfg(feature = "PHASEGroup")]
        /// Setter for [`group`][Self::group].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setGroup:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGroup(&self, group: Option<&PHASEGroup>);

        #[cfg(feature = "PHASEMetaParameter")]
        /// Optionally attach a metaparameter definition here to enable dynamic control of the gain during playback.
        #[unsafe(method(gainMetaParameterDefinition))]
        #[unsafe(method_family = none)]
        pub unsafe fn gainMetaParameterDefinition(
            &self,
        ) -> Option<Retained<PHASENumberMetaParameterDefinition>>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// Setter for [`gainMetaParameterDefinition`][Self::gainMetaParameterDefinition].
        #[unsafe(method(setGainMetaParameterDefinition:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGainMetaParameterDefinition(
            &self,
            gain_meta_parameter_definition: Option<&PHASENumberMetaParameterDefinition>,
        );

        #[cfg(feature = "PHASEMetaParameter")]
        /// Optionally attach a metaparameter definition here to enable dynamic control of the rate during playback.
        #[unsafe(method(rateMetaParameterDefinition))]
        #[unsafe(method_family = none)]
        pub unsafe fn rateMetaParameterDefinition(
            &self,
        ) -> Option<Retained<PHASENumberMetaParameterDefinition>>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// Setter for [`rateMetaParameterDefinition`][Self::rateMetaParameterDefinition].
        #[unsafe(method(setRateMetaParameterDefinition:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRateMetaParameterDefinition(
            &self,
            rate_meta_parameter_definition: Option<&PHASENumberMetaParameterDefinition>,
        );

        #[cfg(feature = "PHASEMixer")]
        /// The readonly property that returns the PHASEMixerDefinition this generator was created with and assigned to.
        #[unsafe(method(mixerDefinition))]
        #[unsafe(method_family = none)]
        pub unsafe fn mixerDefinition(&self) -> Retained<PHASEMixerDefinition>;
    );
}

extern_class!(
    /// A node that plays complete audio data.
    ///
    /// ## Overview
    ///
    /// Generate sound events from this node to play audio data that your app loads completely, either from disk or from memory.
    ///
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// Sampler node definition.
    ///
    /// Sampler nodes play back registered sound assets.
    #[unsafe(super(
        PHASEGeneratorNodeDefinition,
        PHASESoundEventNodeDefinition,
        PHASEDefinition,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHASEDefinition")]
    pub struct PHASESamplerNodeDefinition;
);

#[cfg(feature = "PHASEDefinition")]
extern_conformance!(
    unsafe impl NSObjectProtocol for PHASESamplerNodeDefinition {}
);

#[cfg(feature = "PHASEDefinition")]
impl PHASESamplerNodeDefinition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "PHASEMixer")]
        /// Create a sampler node definition
        ///
        /// Parameter `soundAssetIdentifier`: The identifier of the registered sound asset this sampler will play
        ///
        /// Parameter `mixerDefinition`: The mixer definition this sampler will be assigned to
        ///
        /// Parameter `identifier`: An optional custom identifier to give to this object
        ///
        /// Returns: A new PHASESamplerNodeDefinition object
        #[unsafe(method(initWithSoundAssetIdentifier:mixerDefinition:identifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSoundAssetIdentifier_mixerDefinition_identifier(
            this: Allocated<Self>,
            sound_asset_identifier: &NSString,
            mixer_definition: &PHASEMixerDefinition,
            identifier: &NSString,
        ) -> Retained<Self>;

        #[cfg(feature = "PHASEMixer")]
        /// Create a sampler node definition
        ///
        /// Parameter `soundAssetIdentifier`: The identifier of the registered sound asset this sampler will play
        ///
        /// Parameter `mixerDefinition`: The mixer definition this sampler will be assigned to
        ///
        /// Returns: A new PHASESamplerNodeDefinition object
        #[unsafe(method(initWithSoundAssetIdentifier:mixerDefinition:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSoundAssetIdentifier_mixerDefinition(
            this: Allocated<Self>,
            sound_asset_identifier: &NSString,
            mixer_definition: &PHASEMixerDefinition,
        ) -> Retained<Self>;

        /// The identifier that uniquely represents the registered sound asset this sampler will play.
        #[unsafe(method(assetIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn assetIdentifier(&self) -> Retained<NSString>;

        #[cfg(feature = "PHASETypes")]
        /// The cull option for the sampler.
        ///
        /// The default value is PHASECullOptionTerminate.
        #[unsafe(method(cullOption))]
        #[unsafe(method_family = none)]
        pub unsafe fn cullOption(&self) -> PHASECullOption;

        #[cfg(feature = "PHASETypes")]
        /// Setter for [`cullOption`][Self::cullOption].
        #[unsafe(method(setCullOption:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCullOption(&self, cull_option: PHASECullOption);

        #[cfg(feature = "PHASETypes")]
        /// The playback mode for the sampler.
        ///
        /// If the playback mode is set to PHASEPlaybackModeOneShot, you need to make sure the the audio data in the registered sound asset associated with this sampler
        /// begins and ends at zero crossings. Otherwise, you'll hear a click when beginning playback and / or ending playback.
        /// If the playback mode is set to PHASEPlaybackModeLooping, you need to make sure the audio data in the registered sound asset associated with this sampler
        /// loops smoothly from the end sample to the start sample. Please verify this during authoring. Failing to do so will result in audible clicks at loop boundaries.
        /// The default value is PHASEPlaybackModeOneShot.
        #[unsafe(method(playbackMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn playbackMode(&self) -> PHASEPlaybackMode;

        #[cfg(feature = "PHASETypes")]
        /// Setter for [`playbackMode`][Self::playbackMode].
        #[unsafe(method(setPlaybackMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPlaybackMode(&self, playback_mode: PHASEPlaybackMode);
    );
}

extern_class!(
    /// A node that plays all its children at the same time.
    ///
    /// ## Overview
    ///
    /// This node adds structure to the sound event tree while performing no conditional logic or audio playback of its own. By passing invocation to all its children at once, this class invokes the child nodes’ actions simultaneously.
    ///
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// An object for defining a container sound event node when building a sound event.
    ///
    /// A container node plays back all its children at once.
    #[unsafe(super(PHASESoundEventNodeDefinition, PHASEDefinition, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHASEDefinition")]
    pub struct PHASEContainerNodeDefinition;
);

#[cfg(feature = "PHASEDefinition")]
extern_conformance!(
    unsafe impl NSObjectProtocol for PHASEContainerNodeDefinition {}
);

#[cfg(feature = "PHASEDefinition")]
impl PHASEContainerNodeDefinition {
    extern_methods!(
        /// Create a container node definition
        ///
        /// Returns: A new PHASEContainerNodeDefinition object
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Create a container node definition
        ///
        /// Returns: A new PHASEContainerNodeDefinition object
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// Create a container node definition
        ///
        /// Parameter `identifier`: An optional custom identifier to give to this object
        ///
        /// Returns: A new PHASEContainerNodeDefinition object
        #[unsafe(method(initWithIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier(
            this: Allocated<Self>,
            identifier: &NSString,
        ) -> Retained<Self>;

        /// Add a subtree to this node
        ///
        /// Parameter `subtree`: Add a subtree of PHASESoundEventNodeDefinition nodes beneath this node.
        #[unsafe(method(addSubtree:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addSubtree(&self, subtree: &PHASESoundEventNodeDefinition);
    );
}

extern_class!(
    /// A node that smoothly fades between the audio of its child nodes.
    ///
    /// ## Overview
    ///
    /// This class defines a threshold and a numeric parameter the app increases and decreases to fade between child nodes. Each child node defines a range within the threshold in which the child node plays audio. As the app moves the blend parameter value between `0` and the threshold, the blend node plays the audio of its child nodes whose range and fade curve overlap at the current value.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/fad590e77e054d14a53b5230291c250b/media-3918862~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/aca0330112ec32cda9c94d16e6119920/media-3918862%402x.png 2x" />
    ///     <img alt="Illustration of a flowchart that represents a sound event node tree. The chart contains three boxes, which represent nodes. At left, a box labeled Blend Node extends an arrow, which points to a box in the upper right that’s labeled, Sampler Node Cobblestone Footstep. The box labeled Random Node extends another arrow, which points to a box in the lower right that’s labeled, Sampler Node Grass Footstep. A verticle bar ranges from top sampler node to the bottom sampler node to indicate the range in which both just one node actively plays audio, or both nodes actively play audio, and to what volume they play. " src="https://docs-assets.developer.apple.com/published/fad590e77e054d14a53b5230291c250b/media-3918862~dark%402x.png" />
    /// </picture>
    ///
    ///
    /// ### Play a Blend of Simultaneous Audio Data
    ///
    /// To gradually change the audio that a sound event plays, define blend thresholds and a number metaparameter that incrementally increases or decreases between the thresholds. For example, the following code sets up a sound event hierarchy containing two sampler nodes that play audio, with each one modeling a different terrain. The app sets the metaparameter value based on the value of the terrain the player stands on. When the app starts a sound event from this hierarchy, PHASE plays:
    ///
    /// - A grass footstep for terrain values between `0` and `0.33`
    ///
    /// - A cobblestone footstep for terrain values between `0.67` and `1.0`
    ///
    /// - A blend of both footstep sounds for values between `0.33` and `0.67`
    ///
    /// ```swift
    /// // Create a meta parameter definition that chooses among different terrains.
    /// let terrainBlendParameter = PHASENumberMetaParameterDefinition(
    ///     value: 0.5,
    ///     minimum: 0.0,
    ///     maximum: 1.0,
    ///     identifier: "terrain")
    ///
    /// // Create a blend node and pass in the meta parameter.
    /// let terrainBlendNode = PHASEBlendNodeDefinition(blendMetaParameterDefinition: terrainBlendParameter)
    ///
    /// // Add two samples nodes to blend between.
    /// terrainBlendNode.addRangeForInputValuesAbove(
    ///     value: 0.33,
    ///     fullGainAtValue: 1.0,
    ///     fadeCurveType: .linear,
    ///     subtree:cobblestoneSamplerNode)
    ///
    /// terrainBlendNode.addRangeForInputValuesBelow(
    ///     value: 0.67,
    ///     fullGainAtValue: 0.0,
    ///     fadeCurveType: .linear,
    ///     subtree:grassSamplerNode)
    ///
    /// // Create a sound event.
    /// var footstepEvent: PHASESoundEvent?
    /// do { footstepEvent = try PHASESoundEvent(engine: myEngine, assetIdentifier: "terrain") }
    /// catch { fatalError("Failed to create the sound event due to: \(error)") }        
    ///
    /// // Set the "terrain" metaparameter value to a midpoint that
    /// //  plays audio from both subtrees at an equal volume.
    /// guard let terrainParameter = footstepEvent?.metaParameters["terrain"] else { fatalError() }
    /// terrainParameter.value = 0.5
    ///
    /// // Play the sound and hear a mix of both terrains.
    /// footstepEvent?.start() { reason in
    /// /* Perform completion tasks. */ }
    /// ```
    ///
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// An object for defining a blend sound event node when building a sound event.
    ///
    /// A blend node blends between its children based on a numeric parameter.
    #[unsafe(super(PHASESoundEventNodeDefinition, PHASEDefinition, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHASEDefinition")]
    pub struct PHASEBlendNodeDefinition;
);

#[cfg(feature = "PHASEDefinition")]
extern_conformance!(
    unsafe impl NSObjectProtocol for PHASEBlendNodeDefinition {}
);

#[cfg(feature = "PHASEDefinition")]
impl PHASEBlendNodeDefinition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// Create a blend node definition
        ///
        /// Parameter `blendMetaParameterDefinition`: A metaparameter definition that wil be used to control the parameter of the blend node at runtime.
        ///
        /// Parameter `identifier`: An optional custom identifier to give to this object
        ///
        /// Returns: A new PHASEBlendNodeDefinition object
        #[unsafe(method(initWithBlendMetaParameterDefinition:identifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBlendMetaParameterDefinition_identifier(
            this: Allocated<Self>,
            blend_meta_parameter_definition: &PHASENumberMetaParameterDefinition,
            identifier: &NSString,
        ) -> Retained<Self>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// Create a blend node definition
        ///
        /// Parameter `blendMetaParameterDefinition`: A metaparameter definition that wil be used to control the parameter of the blend node at runtime.
        ///
        /// Returns: A new PHASEBlendNodeDefinition object
        #[unsafe(method(initWithBlendMetaParameterDefinition:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBlendMetaParameterDefinition(
            this: Allocated<Self>,
            blend_meta_parameter_definition: &PHASENumberMetaParameterDefinition,
        ) -> Retained<Self>;

        #[cfg(feature = "PHASEMixer")]
        /// Create a blend node definition
        ///
        /// Parameter `spatialMixerDefinition`: A PHASESpatialMixerDefinition that will bind the blend parameter to the distance between the source and listener.
        ///
        /// Parameter `identifier`: An optional custom identifier to give to this object
        ///
        /// Returns: A new PHASEBlendNodeDefinition object
        #[unsafe(method(initDistanceBlendWithSpatialMixerDefinition:identifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initDistanceBlendWithSpatialMixerDefinition_identifier(
            this: Allocated<Self>,
            spatial_mixer_definition: &PHASESpatialMixerDefinition,
            identifier: &NSString,
        ) -> Retained<Self>;

        #[cfg(feature = "PHASEMixer")]
        /// Create a blend node definition
        ///
        /// Parameter `spatialMixerDefinition`: A PHASESpatialMixerDefinition that will bind the blend parameter to the distance between the source and listener.
        ///
        /// Returns: A new PHASEBlendNodeDefinition object
        #[unsafe(method(initDistanceBlendWithSpatialMixerDefinition:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initDistanceBlendWithSpatialMixerDefinition(
            this: Allocated<Self>,
            spatial_mixer_definition: &PHASESpatialMixerDefinition,
        ) -> Retained<Self>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// The readonly property that returns the PHASENumberMetaParameterDefinition this blend node was created with and assigned to.
        #[unsafe(method(blendParameterDefinition))]
        #[unsafe(method_family = none)]
        pub unsafe fn blendParameterDefinition(
            &self,
        ) -> Option<Retained<PHASENumberMetaParameterDefinition>>;

        #[cfg(feature = "PHASEMixer")]
        /// The readonly property that returns the PHASESpatialMixerDefinition this blend node was created with and assigned to.
        #[unsafe(method(spatialMixerDefinitionForDistance))]
        #[unsafe(method_family = none)]
        pub unsafe fn spatialMixerDefinitionForDistance(
            &self,
        ) -> Option<Retained<PHASESpatialMixerDefinition>>;

        #[cfg(feature = "PHASETypes")]
        /// Create a blend range that is active for all values below a given threshold.
        ///
        /// Parameter `value`: The value for which the range will be active if the blend node's input value is below this threshold.
        ///
        /// Parameter `fullGainAtValue`: This value defines a threshold for which a fade curve will be applied to the gain, when the input value is between "value" and "fullGainAtValue".
        ///
        /// Parameter `fadeCurveType`: A curve type that defines which kind of fade curve to apply.
        ///
        /// Parameter `subtree`: A PHASESoundEventNodeDefinition subtree that will be active for this range.
        #[unsafe(method(addRangeForInputValuesBelow:fullGainAtValue:fadeCurveType:subtree:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRangeForInputValuesBelow_fullGainAtValue_fadeCurveType_subtree(
            &self,
            value: c_double,
            full_gain_at_value: c_double,
            fade_curve_type: PHASECurveType,
            subtree: &PHASESoundEventNodeDefinition,
        );

        #[cfg(feature = "PHASETypes")]
        /// Create a blend range that is active for all input values between lowValue and highValue
        ///
        /// Parameter `lowValue`: The lower bound for which this range is active.
        ///
        /// Parameter `highValue`: The upper bound for which this range is active.
        ///
        /// Parameter `fullGainAtLowValue`: The threshold for which a fade curve defined by lowFadeCurveType will be applied to the gain when the input value is between lowValue and fullGainAtLowValue
        ///
        /// Parameter `fullGainAtHighValue`: The threshold for which a fade curve defined by highFadeCurveType will be applied to the gain when the input value is between highValue and fullGainAtHighValue
        ///
        /// Parameter `lowFadeCurveType`: A curve type that defines which kind of fade curve to apply for the low fade range.
        ///
        /// Parameter `highFadeCurveType`: A curve type that defines which kind of fade curve to apply for the high fade range..
        ///
        /// Parameter `subtree`: A PHASESoundEventNodeDefinition subtree that will be active for this range.
        #[unsafe(method(addRangeForInputValuesBetween:highValue:fullGainAtLowValue:fullGainAtHighValue:lowFadeCurveType:highFadeCurveType:subtree:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRangeForInputValuesBetween_highValue_fullGainAtLowValue_fullGainAtHighValue_lowFadeCurveType_highFadeCurveType_subtree(
            &self,
            low_value: c_double,
            high_value: c_double,
            full_gain_at_low_value: c_double,
            full_gain_at_high_value: c_double,
            low_fade_curve_type: PHASECurveType,
            high_fade_curve_type: PHASECurveType,
            subtree: &PHASESoundEventNodeDefinition,
        );

        #[cfg(feature = "PHASETypes")]
        /// Create a blend range that is active for all values above a given threshold.
        ///
        /// Parameter `value`: The value for which the range will be active if the blend node's input value is above this threshold.
        ///
        /// Parameter `fullGainAtValue`: This value defines a threshold for which a fade curve will be applied to the gain, when the input value is between "value" and "fullGainAtValue".
        ///
        /// Parameter `fadeCurveType`: A curve type that defines which kind of fade curve to apply.
        ///
        /// Parameter `subtree`: A PHASESoundEventNodeDefinition subtree that will be active for this range.
        #[unsafe(method(addRangeForInputValuesAbove:fullGainAtValue:fadeCurveType:subtree:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRangeForInputValuesAbove_fullGainAtValue_fadeCurveType_subtree(
            &self,
            value: c_double,
            full_gain_at_value: c_double,
            fade_curve_type: PHASECurveType,
            subtree: &PHASESoundEventNodeDefinition,
        );

        #[cfg(feature = "PHASEEnvelope")]
        /// Create a blend range defined by a PHASEEnvelope object.
        ///
        /// Parameter `envelope`: The PHASEEnvelope object that defines the output gain for a range.
        ///
        /// Parameter `subtree`: A PHASESoundEventNodeDefinition subtree that will be active for this range.
        #[unsafe(method(addRangeWithEnvelope:subtree:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addRangeWithEnvelope_subtree(
            &self,
            envelope: &PHASEEnvelope,
            subtree: &PHASESoundEventNodeDefinition,
        );
    );
}

extern_class!(
    /// A node that passes invocation to only one of its child nodes.
    ///
    /// ## Overview
    ///
    /// A switch node takes a different path in a sound-event hierarchy depending on the value that the app supplies for the node’s switch metaparameter. You define the available paths ahead of time by calling [`addSubtree:switchValue:`](https://developer.apple.com/documentation/phase/phaseswitchnodedefinition/addsubtree(_:switchvalue:)) at least twice and supplying the subtree’s unique string name as the switch value. When your app invokes a sound event at runtime, PHASE checks the value of [`switchMetaParameterDefinition`](https://developer.apple.com/documentation/phase/phaseswitchnodedefinition/switchmetaparameterdefinition) to determine which path to take.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/020acb797e797cff3e3e1fa70f65278b/media-3918861~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/ca9b1fe656ec9cead83a5017abbb03c9/media-3918861%402x.png 2x" />
    ///     <img alt="Illustration of a flowchart that represents a sound event node tree. The chart contains three boxes, which represent nodes. At left, a box labeled Switch Node contains the text Input Metaparameter Terrain. An arrow flows to the right from the switch node to a box resting at the bottom of the figure that’s labeled Sampler Node Sidewalk Footstep. Another arrow flows to the right from the switch node to a box resting at the top of the figure, labeled Sampler Node Grass Footstep." src="https://docs-assets.developer.apple.com/published/ca9b1fe656ec9cead83a5017abbb03c9/media-3918861%402x.png" />
    /// </picture>
    ///
    ///
    /// ### Switch Between Mulitple Node Trees
    ///
    /// For example, the following diagram represents a node tree that plays one of three grass or sidewalk footstep sounds, depending on the app’s current state. The app sets a value for the switch-node metaparameter according to the terrain on which the player in a game currently stands.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/4b0593ddf36df3aed8e5c6fa4b3dc133/media-3918863~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/74bd2906e5c8cd42e42a2dd07e1b55be/media-3918863%402x.png 2x" />
    ///     <img alt="Illustration of a flow chart that represents a sound event node tree. At left, a box labeled Switch Node cointains the text Input Metaparameter terrain. Two arrows flow out of the node to respective boxes that are both labeled Random Node. One random node branches to two different boxes labeled Sampler Node. One sampler node contains the text Grass Footstep Variation One. The other sampler node contains the text Grass Footstep Variation Two. The other random node branches to two different boxes titled Sampler Node. One sampler node contains the text Cobblestone Footstep Variation One. The other sampler node contains the text Cobblestone Footstep Variation Two. " src="https://docs-assets.developer.apple.com/published/74bd2906e5c8cd42e42a2dd07e1b55be/media-3918863%402x.png" />
    /// </picture>
    ///
    ///
    /// The following code creates a random node subtree for each terrain type and adds each one as a subtree to the switch node.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Set up the sampler nodes for the \"grass\" group of sounds.", "let grassFootstep1 = PHASESamplerNodeDefinition(soundAssetIdentifier:\"GrassOne\" , mixerDefinition: myMixer)", "let grassFootstep2 = PHASESamplerNodeDefinition(soundAssetIdentifier:\"GrassTwo\" , mixerDefinition: myMixer)", "", "// Create a random node and assign the grass samplers to it.", "let grassRandomNode = PHASERandomNodeDefinition(identifier: \"grassRandomNode\")", "grassRandomNode.addSubtree(grassFootstep1, weight: 10)", "grassRandomNode.addSubtree(grassFootstep2, weight: 5)", "", "// Set up the sampler nodes for the \"cobblestone\" group of sounds.", "let cobblestoneFootstep1 = PHASESamplerNodeDefinition(soundAssetIdentifier: \"CobblestoneOne\", mixerDefinition: myMixer)", "let cobblestoneFootstep2 = PHASESamplerNodeDefinition(soundAssetIdentifier: \"CobblestoneTwo\", mixerDefinition: myMixer)", "", "// Create a random node and assign the cobblestone samplers to it.", "let cobblestoneRandomNode = PHASERandomNodeDefinition(identifier: \"cobblestoneRandomNode\")", "cobblestoneRandomNode.addSubtree(cobblestoneFootstep1, weight: 4)", "cobblestoneRandomNode.addSubtree(cobblestoneFootstep2, weight: 2)", "", "// Create a metaparameter definition named \"terrain\" for the sound event.", "let terrainSwitchParameter = PHASEStringMetaParameterDefinition(value: \"cobblestone\", identifier:\"terrain\")", "", "// Create a switch node and provide the metaparameter.", "let terrainSwitchNode = PHASESwitchNodeDefinition(switchMetaParameterDefinition: terrainSwitchParameter)", "", "// Add two random nodes as the metaparameter toggle options.", "terrainSwitchNode.addSubtree(cobblestoneRandomNode, switchValue: \"cobblestone\")", "terrainSwitchNode.addSubtree(grassRandomNode, switchValue: \"grass\")", "", "// Set the terrain metaparameter to play the sound event.", "var footstepEvent: PHASESoundEvent!", "do {", "    footstepEvent = try PHASESoundEvent(engine: myEngine, assetIdentifier: \"footStepEventAsset\")", "} catch { fatalError(\"Failed to create sound event.\") }", "", "// Set the terrain to grass.", "if let metaparameter = footstepEvent.metaParameters[\"terrain\"] {", "    metaparameter.value = \"grass\"", "}", "", "// Invoke the sound event and hear noise for the selected terrain.", "footstepEvent.start()"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Set up the sampler nodes for the \"grass\" group of sounds.", "PHASESamplerNodeDefinition* grassFootstep1 = [[PHASESamplerNodeDefinition alloc] ", "    initWithSoundAssetUID:@\"GrassOne\" mixerDefinition:mixNode];", "PHASESamplerNodeDefinition* grassFootstep2 = [[PHASESamplerNodeDefinition alloc] ", "    initWithSoundAssetUID:@\"GrassTwo\" mixerDefinition:mixNode];", "", "// Create a random node and assign the grass samplers to it.", "PHASERandomNodeDefinition* grassRandomNode = [[PHASERandomNodeDefinition alloc] ", "    initWithUID:@\"grassRandomNode\"];", "[grassRandomNode addSubtree:grassFootstep1 weight:@10];", "[grassRandomNode addSubtree:grassFootstep2 weight:@5];", "", "// Set up the sampler nodes for the \"cobblestone\" group of sounds.", "PHASESamplerNodeDefinition* cobblestoneFootstep1 = [[PHASESamplerNodeDefinition alloc] ", "    initWithSoundAssetUID:@\"CobblestoneOne\" mixerDefinition:mixNode];", "PHASESamplerNodeDefinition* cobblestoneFootstep2 = [[PHASESamplerNodeDefinition alloc] ", "    initWithSoundAssetUID:@\"CobblestoneTwo\" mixerDefinition:mixNode];", "", "// Create a random node and assign the cobblestone samplers to it.", "PHASERandomNodeDefinition* cobblestoneRandomNode = [[PHASERandomNodeDefinition alloc] ", "    initWithUID:@\"cobblestoneRandomNode\"];", "[cobblestoneRandomNode addSubtree:cobblestoneFootstep1 weight:@4];", "[cobblestoneRandomNode addSubtree:cobblestoneFootstep2 weight:@2];", "", "// Create a metaparameter definition named \"terrain\" for the sound event.", "PHASEStringMetaParameterDefinition terrainSwitchParameter = ", "    [[PHASEStringMetaParameterDefinition alloc] ", "        initWithValue:@\"cobblestone\" uid:@\"terrain\"];", "", "// Create a switch node and provide the metaparameter.", "PHASESwitchNodeDefinition* terrainSwitchNode = [[PHASESwitchNodeDefinition alloc] ", "    initWithSwitchMetaParameterDefinition:terrainSwitchParameter];", "", "// Add two random nodes as the metaparameter toggle options.", "[terrainSwitchNode addSubtree:cobblestoneRandomNode switchValue:@\"cobblestone\"];", "[terrainSwitchNode addSubtree:grassRandomNode switchValue:@\"grass\"];", "", "// Set the terrain metaparameter to play the sound event.", "PHASESoundEvent* footstepEvent = [[PHASESoundEvent alloc] ", "    initWithEngine:_objects->mEngine", "    registeredSoundEventNodeAssetUID:@\"footStepEventAsset\" outError:nil];", "", "// Set the terrain to grass.", "footstepEvent.metaParameters[@\"terrain\"] = @\"grass\";", "", "// Invoke the sound event and hear noise for the selected terrain.", "[footstepEvent startAndReturnError:&myError];"], metadata: None }] }] })
    /// <div class="warning">
    ///
    /// ### Tip
    ///  The [`metaParameters`](https://developer.apple.com/documentation/phase/phasesoundevent/metaparameters) objects affect only one sound event. To propagate a metaparameter change to multiple sound events, register the metaparameter globally using [`registerGlobalMetaParameter:error:`](https://developer.apple.com/documentation/phase/phaseassetregistry/registerglobalmetaparameter(metaparameterdefinition:)), and change its value through the asset registry’s [`globalMetaParameters`](https://developer.apple.com/documentation/phase/phaseassetregistry/globalmetaparameters) dictionary.
    ///
    ///
    ///
    /// </div>
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// An object for defining a switch sound event node when building a sound event.
    ///
    /// A switch node switches between its children based on a string parameter.
    #[unsafe(super(PHASESoundEventNodeDefinition, PHASEDefinition, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHASEDefinition")]
    pub struct PHASESwitchNodeDefinition;
);

#[cfg(feature = "PHASEDefinition")]
extern_conformance!(
    unsafe impl NSObjectProtocol for PHASESwitchNodeDefinition {}
);

#[cfg(feature = "PHASEDefinition")]
impl PHASESwitchNodeDefinition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// Create a switch node definition
        ///
        /// Parameter `switchMetaParameterDefinition`: A metaparameter definition that wil be used to control the parameter of the switch node at runtime.
        ///
        /// Parameter `identifier`: An optional custom identifier to give to this object
        ///
        /// Returns: A new PHASESwitchNodeDefinition object
        #[unsafe(method(initWithSwitchMetaParameterDefinition:identifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSwitchMetaParameterDefinition_identifier(
            this: Allocated<Self>,
            switch_meta_parameter_definition: &PHASEStringMetaParameterDefinition,
            identifier: &NSString,
        ) -> Retained<Self>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// Create a switch node definition
        ///
        /// Parameter `switchMetaParameterDefinition`: A metaparameter definition that wil be used to control the parameter of the switch node at runtime.
        ///
        /// Returns: A new PHASESwitchNodeDefinition object
        #[unsafe(method(initWithSwitchMetaParameterDefinition:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSwitchMetaParameterDefinition(
            this: Allocated<Self>,
            switch_meta_parameter_definition: &PHASEStringMetaParameterDefinition,
        ) -> Retained<Self>;

        /// Add a subtree to a switch node
        ///
        /// Parameter `subtree`: A PHASESoundEventNodeDefinition that will be a child node of this switch node
        ///
        /// Parameter `switchValue`: A string value that the metaparameter will use to activate this subtree
        #[unsafe(method(addSubtree:switchValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addSubtree_switchValue(
            &self,
            subtree: &PHASESoundEventNodeDefinition,
            switch_value: &NSString,
        );

        #[cfg(feature = "PHASEMetaParameter")]
        /// The readonly property that returns the PHASEMixerDefinition this sampler was created with and assigned to.
        #[unsafe(method(switchMetaParameterDefinition))]
        #[unsafe(method_family = none)]
        pub unsafe fn switchMetaParameterDefinition(
            &self,
        ) -> Retained<PHASEStringMetaParameterDefinition>;
    );
}

extern_class!(
    /// A sound event node that invokes one of its child nodes at random.
    ///
    /// ## Overview
    ///
    /// When the framework invokes a random node, it passes the invocation on to one of its children at random. The weight you choose for a child node in the [`addSubtree:weight:`](https://developer.apple.com/documentation/phase/phaserandomnodedefinition/addsubtree(_:weight:)) argument skews the node’s selection chances.
    ///
    /// ### Choose from Alternate Sounds
    ///
    /// This class can model real-world cases where an event varies slightly, such as when footsteps sound slightly different because of the unique ground composition at each step.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/d2e65cdc0965a0d56a46c3f03efd9f90/media-3918860~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/3e7605629beec5855ca52d33b3bf11de/media-3918860%402x.png 2x" />
    ///     <img alt="Illustration of a flowchart that represents a sound event node tree. The chart contains three boxes, which represent nodes. At left, a box labeled Random Node extends an arrow, which points to a box in the upper right that’s labeled Sampler Node Footstep Variation One. The box labeled Random Node extends another arrow, which points to a box in the lower right that’s labeled Sampler Node Footstep Variation Two. " src="https://docs-assets.developer.apple.com/published/d2e65cdc0965a0d56a46c3f03efd9f90/media-3918860~dark%402x.png" />
    /// </picture>
    ///
    ///
    /// The following code creates an instance of this class that selects from three different footstep sounds. The weights determine that an uncommon footstep noise plays half as frequently as the common footstep. And a third footstep noise plays 10% of the time.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Create several nodes from prior-registered footstep sound assets.", "let footstep1 = PHASESamplerNodeDefinition(", "    soundAssetIdentifier: \"footstep1\",", "    mixerDefinition: myMixer, identifier: \"footstep1\")", "let footstep2 = PHASESamplerNodeDefinition(", "    soundAssetIdentifier: \"footstep2\",", "    mixerDefinition: myMixer, identifier: \"footstep2\")", "let footstep3 = PHASESamplerNodeDefinition(", "    soundAssetIdentifier: \"footstep3\",    ", "    mixerDefinition: myMixer, identifier: \"footstep3\")", "", "// Create the random node.", "let randomNode = PHASERandomNodeDefinition(identifier: \"randomNode\")", "", "// Connect leaf nodes to the tree and set the weights. ", "randomNode.addSubtree(footstep1, weight: 10)", "randomNode.addSubtree(footstep2, weight: 5)", "randomNode.addSubtree(footstep3, weight: 1)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Create several nodes from prior-registered footstep sound assets.", "PHASESamplerNodeDefinition* footstep1 = ", "    [[PHASESamplerNodeDefinition alloc] ", "        initWithSoundAssetUID:@\"footstep1\" ", "        mixerDefinition:mixNode uid:@\"footstep1\"];", "PHASESamplerNodeDefinition* footstep2 = ", "    [[PHASESamplerNodeDefinition alloc] ", "        initWithSoundAssetUID:@\"footstep2\" ", "        mixerDefinition:mixNode uid:@\"footstep2\"];", "PHASESamplerNodeDefinition* footstep3 = ", "    [[PHASESamplerNodeDefinition alloc] ", "        initWithSoundAssetUID:@\"footstep3\" ", "        mixerDefinition:mixNode uid:@\"footstep3\"];", "", "// Create the random node.", "PHASERandomNodeDefinition* randomNode = ", "    [[PHASERandomNodeDefinition alloc] initWithUID:@\"randomNode\"];", "", "// Connect leaf nodes to the tree and set the weights. ", "[randomNode addSubtree:footstep1 weight:@10];", "[randomNode addSubtree:footstep2 weight:@5];", "[randomNode addSubtree:footstep3 weight:@1];"], metadata: None }] }] })
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// An object for defining a random sound event node when building a sound event.
    ///
    /// A random node selects one of its children based on a weighted random choice.
    #[unsafe(super(PHASESoundEventNodeDefinition, PHASEDefinition, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHASEDefinition")]
    pub struct PHASERandomNodeDefinition;
);

#[cfg(feature = "PHASEDefinition")]
extern_conformance!(
    unsafe impl NSObjectProtocol for PHASERandomNodeDefinition {}
);

#[cfg(feature = "PHASEDefinition")]
impl PHASERandomNodeDefinition {
    extern_methods!(
        /// Create a random node definition
        ///
        /// Returns: A new PHASERandomNodeDefinition object
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Create a random node definition
        ///
        /// Parameter `identifier`: An optional custom identifier to give to this object
        ///
        /// Returns: A new PHASERandomNodeDefinition object
        #[unsafe(method(initWithIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier(
            this: Allocated<Self>,
            identifier: &NSString,
        ) -> Retained<Self>;

        /// Add a subtree to a random node
        ///
        /// Parameter `subtree`: A PHASESoundEventNodeDefinition that will be a child node of this random node
        ///
        /// Parameter `weight`: The probability weight of this subtree.  Higher numbers compared to other subtree weights will increase the likelihood of being
        /// chosen. This value must be greater than or equal to 1, and is clamped otherwise.
        #[unsafe(method(addSubtree:weight:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addSubtree_weight(
            &self,
            subtree: &PHASESoundEventNodeDefinition,
            weight: &NSNumber,
        );

        /// Subtrees will not be repeated until after this random node is activated uniqueSelectionQueueLength number of times.
        #[unsafe(method(uniqueSelectionQueueLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn uniqueSelectionQueueLength(&self) -> NSInteger;

        /// Setter for [`uniqueSelectionQueueLength`][Self::uniqueSelectionQueueLength].
        #[unsafe(method(setUniqueSelectionQueueLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUniqueSelectionQueueLength(
            &self,
            unique_selection_queue_length: NSInteger,
        );
    );
}

/// Methods declared on superclass `PHASESoundEventNodeDefinition`.
#[cfg(feature = "PHASEDefinition")]
impl PHASERandomNodeDefinition {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    ///
    /// ## Overview
    ///
    /// ---
    /// The base class for stream nodes, exposing common elements.
    ///
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// The base class for stream nodes, exposing common elements.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct PHASEStreamNode;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for PHASEStreamNode {}
);

impl PHASEStreamNode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// If specified during construction, the metaparameter for controlling gain will be available here
        #[unsafe(method(gainMetaParameter))]
        #[unsafe(method_family = none)]
        pub unsafe fn gainMetaParameter(&self) -> Option<Retained<PHASENumberMetaParameter>>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// If specified during construction, the metaparameter for controlling rate/pitch will be available here
        #[unsafe(method(rateMetaParameter))]
        #[unsafe(method_family = none)]
        pub unsafe fn rateMetaParameter(&self) -> Option<Retained<PHASENumberMetaParameter>>;

        #[cfg(feature = "PHASEMixer")]
        /// The readonly property that returns the PHASEMixer this stream was created with and assigned to.
        #[unsafe(method(mixer))]
        #[unsafe(method_family = none)]
        pub unsafe fn mixer(&self) -> Retained<PHASEMixer>;

        #[cfg(feature = "objc2-avf-audio")]
        /// The readonly property that returns the AVAudioFormat that this stream was initialized with.
        #[unsafe(method(format))]
        #[unsafe(method_family = none)]
        pub unsafe fn format(&self) -> Retained<AVAudioFormat>;
    );
}

extern_class!(
    /// A node that plays a sequence of audio buffers.
    ///
    /// ## Overview
    ///
    /// Use this node to create sound events for a piecemeal audio source, for example, an audio stream that your app accesses over the network or loads from a memory-mapped file on disk.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  To create a sound event for fully-loaded audio data instead, use [`PHASESamplerNodeDefinition`](https://developer.apple.com/documentation/phase/phasesamplernodedefinition).
    ///
    ///
    ///
    /// </div>
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// An object for defining a push stream sound event node when building a sound event.
    #[unsafe(super(
        PHASEGeneratorNodeDefinition,
        PHASESoundEventNodeDefinition,
        PHASEDefinition,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHASEDefinition")]
    pub struct PHASEPushStreamNodeDefinition;
);

#[cfg(feature = "PHASEDefinition")]
extern_conformance!(
    unsafe impl NSObjectProtocol for PHASEPushStreamNodeDefinition {}
);

#[cfg(feature = "PHASEDefinition")]
impl PHASEPushStreamNodeDefinition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(all(feature = "PHASEMixer", feature = "objc2-avf-audio"))]
        /// Create a push stream node definition
        ///
        /// Parameter `mixerDefinition`: The mixer definition this stream will be assigned to
        ///
        /// Parameter `format`: The AVAudioFormat object that will define the attributes of the audio this node will accept.
        /// Only Core Audio's standard deinterleaved 32-bit floating-point formats are supported.
        ///
        /// Parameter `identifier`: An optional custom identifier to give to this object
        ///
        /// Returns: A new PHASEPushStreamNodeDefinition object
        #[unsafe(method(initWithMixerDefinition:format:identifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMixerDefinition_format_identifier(
            this: Allocated<Self>,
            mixer_definition: &PHASEMixerDefinition,
            format: &AVAudioFormat,
            identifier: &NSString,
        ) -> Retained<Self>;

        #[cfg(all(feature = "PHASEMixer", feature = "objc2-avf-audio"))]
        /// Create a push stream node definition
        ///
        /// Parameter `mixerDefinition`: The mixer definition this stream will be assigned to
        ///
        /// Parameter `format`: The AVAudioFormat object that will define the attributes of the audio this node will accept.
        /// Only Core Audio's standard deinterleaved 32-bit floating-point formats are supported.
        ///
        /// Returns: A new PHASEPushStreamNodeDefinition object
        #[unsafe(method(initWithMixerDefinition:format:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMixerDefinition_format(
            this: Allocated<Self>,
            mixer_definition: &PHASEMixerDefinition,
            format: &AVAudioFormat,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-avf-audio")]
        /// The readonly property that returns the AVAudioFormat that this stream was initialized with
        #[unsafe(method(format))]
        #[unsafe(method_family = none)]
        pub unsafe fn format(&self) -> Retained<AVAudioFormat>;

        /// Determines whether or not the engine should normalize the stream. The default value is NO.
        ///
        /// In general, clients are advised to normalize the input. Normalization is required to properly calibrate the output level.
        /// If you set this value to NO, it's advised that you do custom normalization of the audio data prior to passing the buffers to PHASE.
        #[unsafe(method(normalize))]
        #[unsafe(method_family = none)]
        pub unsafe fn normalize(&self) -> bool;

        /// Setter for [`normalize`][Self::normalize].
        #[unsafe(method(setNormalize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNormalize(&self, normalize: bool);
    );
}

extern_class!(
    /// An audio stream you manage to provide a sound buffer data.
    ///
    /// ## Overview
    ///
    /// A sound event’s [`pushStreamNodes`](https://developer.apple.com/documentation/phase/phasesoundevent/pushstreamnodes) dictionary populates with an instance of this class when PHASE invokes a  [`PHASEPushStreamNodeDefinition`](https://developer.apple.com/documentation/phase/phasepushstreamnodedefinition) in your event node tree.
    ///
    /// Your app provides the audio data that the sound event plays by calling one or more of this class’s buffer-scheduling functions, for example, [`scheduleBuffer:`](https://developer.apple.com/documentation/phase/phasepushstreamnode/schedulebuffer(buffer:)).
    ///
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// An object for addessing an instance of a stream in an executing sound event
    #[unsafe(super(PHASEStreamNode, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct PHASEPushStreamNode;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for PHASEPushStreamNode {}
);

impl PHASEPushStreamNode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// If specified during construction, the metaparameter for controlling gain will be available here
        #[unsafe(method(gainMetaParameter))]
        #[unsafe(method_family = none)]
        pub unsafe fn gainMetaParameter(&self) -> Option<Retained<PHASENumberMetaParameter>>;

        #[cfg(feature = "PHASEMetaParameter")]
        /// If specified during construction, the metaparameter for controlling rate/pitch will be available here
        #[unsafe(method(rateMetaParameter))]
        #[unsafe(method_family = none)]
        pub unsafe fn rateMetaParameter(&self) -> Option<Retained<PHASENumberMetaParameter>>;

        #[cfg(feature = "PHASEMixer")]
        /// The readonly property that returns the PHASEMixer this stream was created with and assigned to.
        #[unsafe(method(mixer))]
        #[unsafe(method_family = none)]
        pub unsafe fn mixer(&self) -> Retained<PHASEMixer>;

        #[cfg(feature = "objc2-avf-audio")]
        /// The readonly property that returns the AVAudioFormat that this stream was initialized with.
        #[unsafe(method(format))]
        #[unsafe(method_family = none)]
        pub unsafe fn format(&self) -> Retained<AVAudioFormat>;

        #[cfg(feature = "objc2-avf-audio")]
        /// Schedule a buffer for playback.
        ///
        /// Parameter `buffer`: The buffer with PCM audio data.
        ///
        /// Schedules the buffer to be played following any previously scheduled buffer(s).
        /// The buffer format must be same as format specified during player instantiation
        #[unsafe(method(scheduleBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scheduleBuffer(&self, buffer: &AVAudioPCMBuffer);

        #[cfg(all(feature = "block2", feature = "objc2-avf-audio"))]
        /// Schedule a buffer for playback.
        ///
        /// Schedules the buffer to be played following any previously scheduled buffer(s).
        /// The buffer format must be same as format specified during player instantiation
        ///
        /// Parameter `buffer`: The buffer with PCM audio data.
        ///
        /// Parameter `completionCallbackType`: Option to specify when the completion handler must be called.
        ///
        /// Parameter `completionHandler`: The completionHandler to be called as per the specified completion callback type
        /// or when the player is stopped, at which point the buffer can be recycled.
        #[unsafe(method(scheduleBuffer:completionCallbackType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scheduleBuffer_completionCallbackType_completionHandler(
            &self,
            buffer: &AVAudioPCMBuffer,
            completion_callback_type: PHASEPushStreamCompletionCallbackCondition,
            completion_handler: &block2::DynBlock<
                dyn Fn(PHASEPushStreamCompletionCallbackCondition),
            >,
        );

        #[cfg(feature = "objc2-avf-audio")]
        /// Schedule a buffer for playback at a given time.
        ///
        /// The buffer format must be same as format specified during player instantiation
        ///
        /// Parameter `buffer`: The buffer with PCM audio data.
        ///
        /// Parameter `when`: The time at which to play the buffer.
        ///
        /// Parameter `options`: Options for looping, interrupting other buffers, etc.
        #[unsafe(method(scheduleBuffer:atTime:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scheduleBuffer_atTime_options(
            &self,
            buffer: &AVAudioPCMBuffer,
            when: Option<&AVAudioTime>,
            options: PHASEPushStreamBufferOptions,
        );

        #[cfg(all(feature = "block2", feature = "objc2-avf-audio"))]
        /// Schedule a buffer for playback at a given time.
        ///
        /// The buffer format must be same as format specified during player instantiation
        ///
        /// Parameter `buffer`: The buffer with PCM audio data.
        ///
        /// Parameter `when`: The time at which to play the buffer.
        ///
        /// Parameter `options`: Options for looping, interrupting other buffers, etc.
        ///
        /// Parameter `completionCallbackType`: Option to specify when the completion handler must be called.
        ///
        /// Parameter `completionHandler`: The completionHandler to be called as per the callback type specified or when
        /// the player is stopped, at which point the buffer can be recycled.
        #[unsafe(method(scheduleBuffer:atTime:options:completionCallbackType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scheduleBuffer_atTime_options_completionCallbackType_completionHandler(
            &self,
            buffer: &AVAudioPCMBuffer,
            when: Option<&AVAudioTime>,
            options: PHASEPushStreamBufferOptions,
            completion_callback_type: PHASEPushStreamCompletionCallbackCondition,
            completion_handler: &block2::DynBlock<
                dyn Fn(PHASEPushStreamCompletionCallbackCondition),
            >,
        );
    );
}

///
/// Parameters:
/// - isSilence: The client may use this flag to indicate that the buffer it vends contains only silence. The receiver of the buffer can then use the flag as a hint as to whether the buffer needs to be processed or not. Note that because the flag is only a hint, when setting the silence flag, the originator of a buffer must also ensure that it contains silence (zeroes).
///
/// - timestamp: The HAL time at which the audio data will be rendered. If there is a sample rate conversion or time compression/expansion downstream, the sample time will not be valid.
///
/// - frameCount: The number of sample frames of audio data requested.
///
/// - outputData: The output data.
///
///
/// ## Return Value
///
/// An OSStatus result code. If an error is returned, the audio data should be assumed to be invalid.
///
///
///
/// ## Discussion
///
/// Block to supply audio data to PHASEPullStreamNode
///
/// ```text
/// The caller must supply valid buffers in outputData's mBuffers' mData and mDataByteSize.
/// mDataByteSize must be consistent with frameCount. This block may provide output in those
/// specified buffers, or it may replace the mData pointers with pointers to memory which it
/// owns and guarantees will remain valid until the next render cycle.
/// ```
///
///
/// Block to supply audio data to PHASEPullStreamNode
///
/// Parameter `isSilence`: The client may use this flag to indicate that the buffer it vends contains only silence.
/// The receiver of the buffer can then use the flag as a hint as to whether the buffer needs
/// to be processed or not.
/// Note that because the flag is only a hint, when setting the silence flag, the originator of
/// a buffer must also ensure that it contains silence (zeroes).
///
/// Parameter `timestamp`: The HAL time at which the audio data will be rendered. If there is a sample rate conversion
/// or time compression/expansion downstream, the sample time will not be valid.
///
/// Parameter `frameCount`: The number of sample frames of audio data requested.
///
/// Parameter `outputData`: The output data.
///
/// The caller must supply valid buffers in outputData's mBuffers' mData and mDataByteSize.
/// mDataByteSize must be consistent with frameCount. This block may provide output in those
/// specified buffers, or it may replace the mData pointers with pointers to memory which it
/// owns and guarantees will remain valid until the next render cycle.
///
/// Returns: An OSStatus result code. If an error is returned, the audio data should be assumed to be
/// invalid.
#[cfg(all(
    feature = "block2",
    feature = "objc2-avf-audio",
    feature = "objc2-core-audio-types"
))]
pub type PHASEPullStreamRenderBlock = *mut block2::DynBlock<
    dyn Fn(
        NonNull<Bool>,
        NonNull<AudioTimeStamp>,
        AVAudioFrameCount,
        NonNull<AudioBufferList>,
    ) -> OSStatus,
>;

extern_class!(
    ///
    /// ## Overview
    ///
    /// ---
    /// An object for defining a pull stream sound event node when building a sound event.
    ///
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// An object for defining a pull stream sound event node when building a sound event.
    #[unsafe(super(
        PHASEGeneratorNodeDefinition,
        PHASESoundEventNodeDefinition,
        PHASEDefinition,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "PHASEDefinition")]
    pub struct PHASEPullStreamNodeDefinition;
);

#[cfg(feature = "PHASEDefinition")]
extern_conformance!(
    unsafe impl NSObjectProtocol for PHASEPullStreamNodeDefinition {}
);

#[cfg(feature = "PHASEDefinition")]
impl PHASEPullStreamNodeDefinition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(all(feature = "PHASEMixer", feature = "objc2-avf-audio"))]
        /// Create a pull stream node definition
        ///
        /// Parameter `mixerDefinition`: The mixer definition this stream will be assigned to
        ///
        /// Parameter `format`: The AVAudioFormat object that will define the attributes of the audio this node will accept.
        /// Only Core Audio's standard deinterleaved 32-bit floating-point formats are supported.
        ///
        /// Parameter `identifier`: An optional custom identifier to give to this object
        ///
        /// Returns: A new PHASEPullStreamNodeDefinition object
        #[unsafe(method(initWithMixerDefinition:format:identifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMixerDefinition_format_identifier(
            this: Allocated<Self>,
            mixer_definition: &PHASEMixerDefinition,
            format: &AVAudioFormat,
            identifier: &NSString,
        ) -> Retained<Self>;

        #[cfg(all(feature = "PHASEMixer", feature = "objc2-avf-audio"))]
        /// Create a pull stream node definition
        ///
        /// Parameter `mixerDefinition`: The mixer definition this stream will be assigned to
        ///
        /// Parameter `format`: The AVAudioFormat object that will define the attributes of the audio this node will accept.
        /// Only Core Audio's standard deinterleaved 32-bit floating-point formats are supported.
        ///
        /// Returns: A new PHASEPullStreamNodeDefinition object
        #[unsafe(method(initWithMixerDefinition:format:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMixerDefinition_format(
            this: Allocated<Self>,
            mixer_definition: &PHASEMixerDefinition,
            format: &AVAudioFormat,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-avf-audio")]
        /// The readonly property that returns the AVAudioFormat that this stream was initialized with
        #[unsafe(method(format))]
        #[unsafe(method_family = none)]
        pub unsafe fn format(&self) -> Retained<AVAudioFormat>;

        /// Determines whether or not the engine should normalize the stream. The default value is NO.
        ///
        /// In general, clients are advised to normalize the input. Normalization is required to properly calibrate the output level.
        /// If you set this value to NO, it's advised that you do custom normalization of the audio data prior to passing the buffers to PHASE.
        #[unsafe(method(normalize))]
        #[unsafe(method_family = none)]
        pub unsafe fn normalize(&self) -> bool;

        /// Setter for [`normalize`][Self::normalize].
        #[unsafe(method(setNormalize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNormalize(&self, normalize: bool);
    );
}

extern_class!(
    ///
    /// ## Overview
    ///
    /// ---
    /// An object for addessing an instance of a stream in an executing sound event
    ///
    ///
    /// *************************************************************************************************
    ///
    ///
    ///
    /// An object for addessing an instance of a stream in an executing sound event
    #[unsafe(super(PHASEStreamNode, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct PHASEPullStreamNode;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for PHASEPullStreamNode {}
);

impl PHASEPullStreamNode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(all(
            feature = "block2",
            feature = "objc2-avf-audio",
            feature = "objc2-core-audio-types"
        ))]
        /// A property to set the render block callback that will render the samplesIW
        ///
        /// The renderBlock must be set before the PHASESoundEvent is prepared or started.  The callback will be called from a high priority realtime thread.
        /// Your implementation must be performant and not perform any realtime unsafe operations such as lock mutexes or allocate memory.
        ///
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        /// - The returned block's argument 4 must be a valid pointer.
        #[unsafe(method(renderBlock))]
        #[unsafe(method_family = none)]
        pub unsafe fn renderBlock(&self) -> PHASEPullStreamRenderBlock;

        #[cfg(all(
            feature = "block2",
            feature = "objc2-avf-audio",
            feature = "objc2-core-audio-types"
        ))]
        /// Setter for [`renderBlock`][Self::renderBlock].
        ///
        /// # Safety
        ///
        /// `render_block` must be a valid pointer.
        #[unsafe(method(setRenderBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRenderBlock(&self, render_block: PHASEPullStreamRenderBlock);
    );
}
