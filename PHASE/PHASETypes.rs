//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Update mode for the engine.
///
/// The engine update mode determines the rate at which the engine consumes client commands, performs internal updates, and calls any registered handlers.
/// All API calls to the engine are queued until the engine updates.
/// The engine update mode determines if the engine or the application triggers the consumption of API commands.
///
/// Note: The update mode does not affect the Audio IO Thread or rendering, in general. The Audio IO Thread always runs in the background, independent of the update mode.
///
/// The engine will internally consume client commands at a rate opaque to the client.
/// In general, automatic update mode is meant for simpler applications that just want to play sounds, without having to maintain a strict update loop.
/// Due to the fact that the engine consumes client commands at its own internal rate, the client is never guaranteed that two independent commands will synchronize.
///
/// When an application requires precise synchronization of API calls with the main update, manual mode is the best choice.
/// In this mode, clients will need to call [PHASEEngine update] periodically to process new commands, perform internal updates, and receive callbacks.
/// The rate at which the client calls update should at least match the rate at which other time-critical subsystems are updated, such graphics rendering etc.
/// API calls between calls to [PHASEEngine update] are guaranteed to be synchronized.
/// For example, the client can move two sources into place, request to start two sound events (one per source), then call [PHASEEngine update].
/// These calls will be guaranteed to be processed at the same time.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaseupdatemode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASEUpdateMode(pub NSInteger);
impl PHASEUpdateMode {
    #[doc(alias = "PHASEUpdateModeAutomatic")]
    pub const Automatic: Self = Self(0);
    #[doc(alias = "PHASEUpdateModeManual")]
    pub const Manual: Self = Self(1);
}

unsafe impl Encode for PHASEUpdateMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASEUpdateMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Rendering Mode for a PHASE Engine.
///
/// A local engine is connected to an audio device and renders audio in real-time in the application process.
/// In this mode the engine receives all its inputs from the client such as acoustic configuration.
/// Updating an engine configured with `PHASERenderingModeLocal` executes any pending API commands locally.
///
/// A client engine is connected to an audio device and renders audio in real-time in a secure process.
/// In this mode the engine receives inputs from the client and renders in a server.
/// In supported platforms this allows the server to apply privacy sensitive effects such as room virtual acoustics, low latency head-tracking and personalized Spatial Audio.
/// Updating an engine configured with `PHASERenderingModeClient` syncs any pending API commands to the server for processing.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaserenderingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASERenderingMode(pub NSInteger);
impl PHASERenderingMode {
    #[doc(alias = "PHASERenderingModeLocal")]
    pub const Local: Self = Self(0);
    #[doc(alias = "PHASERenderingModeClient")]
    pub const Client: Self = Self(1);
}

unsafe impl Encode for PHASERenderingMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASERenderingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Rendering state for sound events.
///
/// The sound event is stopped.
///
/// The sound event is playing back.
///
/// The sound event is paused.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaserenderingstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASERenderingState(pub NSInteger);
impl PHASERenderingState {
    #[doc(alias = "PHASERenderingStateStopped")]
    pub const Stopped: Self = Self(0);
    #[doc(alias = "PHASERenderingStateStarted")]
    pub const Started: Self = Self(1);
    #[doc(alias = "PHASERenderingStatePaused")]
    pub const Paused: Self = Self(2);
}

unsafe impl Encode for PHASERenderingState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASERenderingState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Spatialization mode.
///
/// Automatically select the spatialization mode based on the current output device.
///
/// Always use binaural rendering, whether playing back on headphones or speakers.
/// Note that when rendering binaural over built-in speakers, special filters are applied to achieve the expected behavior.
///
/// Always use the appropriate channel-based panning algorithm for the output layout.
/// Note that when rendering channel-based over headphones, the sound will play back in stereo.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasespatializationmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASESpatializationMode(pub NSInteger);
impl PHASESpatializationMode {
    #[doc(alias = "PHASESpatializationModeAutomatic")]
    pub const Automatic: Self = Self(0);
    #[doc(alias = "PHASESpatializationModeAlwaysUseBinaural")]
    pub const AlwaysUseBinaural: Self = Self(1);
    #[doc(alias = "PHASESpatializationModeAlwaysUseChannelBased")]
    pub const AlwaysUseChannelBased: Self = Self(2);
}

unsafe impl Encode for PHASESpatializationMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASESpatializationMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Reverb preset
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasereverbpreset?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASEReverbPreset(pub NSInteger);
impl PHASEReverbPreset {
    #[doc(alias = "PHASEReverbPresetNone")]
    pub const None: Self = Self(0x724e6f6e);
    #[doc(alias = "PHASEReverbPresetSmallRoom")]
    pub const SmallRoom: Self = Self(0x7253526d);
    #[doc(alias = "PHASEReverbPresetMediumRoom")]
    pub const MediumRoom: Self = Self(0x724d526d);
    #[doc(alias = "PHASEReverbPresetLargeRoom")]
    pub const LargeRoom: Self = Self(0x724c5231);
    #[doc(alias = "PHASEReverbPresetLargeRoom2")]
    pub const LargeRoom2: Self = Self(0x724c5232);
    #[doc(alias = "PHASEReverbPresetMediumChamber")]
    pub const MediumChamber: Self = Self(0x724d4368);
    #[doc(alias = "PHASEReverbPresetLargeChamber")]
    pub const LargeChamber: Self = Self(0x724c4368);
    #[doc(alias = "PHASEReverbPresetMediumHall")]
    pub const MediumHall: Self = Self(0x724d4831);
    #[doc(alias = "PHASEReverbPresetMediumHall2")]
    pub const MediumHall2: Self = Self(0x724d4832);
    #[doc(alias = "PHASEReverbPresetMediumHall3")]
    pub const MediumHall3: Self = Self(0x724d4833);
    #[doc(alias = "PHASEReverbPresetLargeHall")]
    pub const LargeHall: Self = Self(0x724c4831);
    #[doc(alias = "PHASEReverbPresetLargeHall2")]
    pub const LargeHall2: Self = Self(0x724c4832);
    #[doc(alias = "PHASEReverbPresetCathedral")]
    pub const Cathedral: Self = Self(0x72437468);
}

unsafe impl Encode for PHASEReverbPreset {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASEReverbPreset {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The NSErrorDomain for general PHASE errors
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaseerrordomain?language=objc)
    pub static PHASEErrorDomain: Option<&'static NSErrorDomain>;
}

/// General PHASE error codes
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaseerror?language=objc)
// NS_ERROR_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASEError(pub NSInteger);
impl PHASEError {
    #[doc(alias = "PHASEErrorInitializeFailed")]
    pub const InitializeFailed: Self = Self(0x50484561);
    #[doc(alias = "PHASEErrorInvalidObject")]
    pub const InvalidObject: Self = Self(0x50484562);
}

unsafe impl Encode for PHASEError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASEError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The NSErrorDomain for PHASE sound event errors.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasesoundeventerrordomain?language=objc)
    pub static PHASESoundEventErrorDomain: Option<&'static NSErrorDomain>;
}

/// Sound event error.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasesoundeventerror?language=objc)
// NS_ERROR_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASESoundEventError(pub NSInteger);
impl PHASESoundEventError {
    #[doc(alias = "PHASESoundEventErrorNotFound")]
    pub const NotFound: Self = Self(0x50487461);
    #[doc(alias = "PHASESoundEventErrorBadData")]
    pub const BadData: Self = Self(0x50487462);
    #[doc(alias = "PHASESoundEventErrorInvalidInstance")]
    pub const InvalidInstance: Self = Self(0x50487463);
    #[doc(alias = "PHASESoundEventErrorAPIMisuse")]
    pub const APIMisuse: Self = Self(0x50487464);
    #[doc(alias = "PHASESoundEventErrorSystemNotInitialized")]
    pub const SystemNotInitialized: Self = Self(0x50487465);
    #[doc(alias = "PHASESoundEventErrorOutOfMemory")]
    pub const OutOfMemory: Self = Self(0x50487466);
}

unsafe impl Encode for PHASESoundEventError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASESoundEventError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The NSErrorDomain for PHASE Asset errors
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaseasseterrordomain?language=objc)
    pub static PHASEAssetErrorDomain: Option<&'static NSErrorDomain>;
}

/// Asset error
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaseasseterror?language=objc)
// NS_ERROR_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASEAssetError(pub NSInteger);
impl PHASEAssetError {
    #[doc(alias = "PHASEAssetErrorFailedToLoad")]
    pub const FailedToLoad: Self = Self(0x50486161);
    #[doc(alias = "PHASEAssetErrorInvalidEngineInstance")]
    pub const InvalidEngineInstance: Self = Self(0x50486162);
    #[doc(alias = "PHASEAssetErrorBadParameters")]
    pub const BadParameters: Self = Self(0x50486163);
    #[doc(alias = "PHASEAssetErrorAlreadyExists")]
    pub const AlreadyExists: Self = Self(0x50486164);
    #[doc(alias = "PHASEAssetErrorGeneralError")]
    pub const GeneralError: Self = Self(0x50486165);
    #[doc(alias = "PHASEAssetErrorMemoryAllocation")]
    pub const MemoryAllocation: Self = Self(0x50486166);
}

unsafe impl Encode for PHASEAssetError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASEAssetError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Sound event prepare handler reason
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasesoundeventpreparehandlerreason?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASESoundEventPrepareHandlerReason(pub NSInteger);
impl PHASESoundEventPrepareHandlerReason {
    #[doc(alias = "PHASESoundEventPrepareHandlerReasonFailure")]
    pub const Failure: Self = Self(0);
    #[doc(alias = "PHASESoundEventPrepareHandlerReasonPrepared")]
    pub const Prepared: Self = Self(1);
    #[doc(alias = "PHASESoundEventPrepareHandlerReasonTerminated")]
    pub const Terminated: Self = Self(2);
}

unsafe impl Encode for PHASESoundEventPrepareHandlerReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASESoundEventPrepareHandlerReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Sound event start handler reason
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasesoundeventstarthandlerreason?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASESoundEventStartHandlerReason(pub NSInteger);
impl PHASESoundEventStartHandlerReason {
    #[doc(alias = "PHASESoundEventStartHandlerReasonFailure")]
    pub const Failure: Self = Self(0);
    #[doc(alias = "PHASESoundEventStartHandlerReasonFinishedPlaying")]
    pub const FinishedPlaying: Self = Self(1);
    #[doc(alias = "PHASESoundEventStartHandlerReasonTerminated")]
    pub const Terminated: Self = Self(2);
}

unsafe impl Encode for PHASESoundEventStartHandlerReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASESoundEventStartHandlerReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Sound event seek handler reason
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasesoundeventseekhandlerreason?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASESoundEventSeekHandlerReason(pub NSInteger);
impl PHASESoundEventSeekHandlerReason {
    #[doc(alias = "PHASESoundEventSeekHandlerReasonFailure")]
    pub const Failure: Self = Self(0);
    #[doc(alias = "PHASESoundEventSeekHandlerReasonFailureSeekAlreadyInProgress")]
    pub const FailureSeekAlreadyInProgress: Self = Self(1);
    #[doc(alias = "PHASESoundEventSeekHandlerReasonSeekSuccessful")]
    pub const SeekSuccessful: Self = Self(2);
}

unsafe impl Encode for PHASESoundEventSeekHandlerReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASESoundEventSeekHandlerReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Sound event prepare state
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasesoundeventpreparestate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASESoundEventPrepareState(pub NSInteger);
impl PHASESoundEventPrepareState {
    #[doc(alias = "PHASESoundEventPrepareStatePrepareNotStarted")]
    pub const PrepareNotStarted: Self = Self(0);
    #[doc(alias = "PHASESoundEventPrepareStatePrepareInProgress")]
    pub const PrepareInProgress: Self = Self(1);
    #[doc(alias = "PHASESoundEventPrepareStatePrepared")]
    pub const Prepared: Self = Self(2);
}

unsafe impl Encode for PHASESoundEventPrepareState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASESoundEventPrepareState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Asset types.
///
/// Determines how assets are loaded into memory and prepared for playback.
/// 'Preparing' an asset for playback may include decompression and/or format conversion,
/// depending on the type of the underlying asset data.
///
/// If the asset is on disk, it is loaded into memory and prepared for playback.
/// If the asset is in memory, it is prepared for playback.
///
/// If the asset is on disk, it is streamed from disk into memory and prepared during playback.
/// If the asset is in memory, it is streamed from memory and prepared during playback.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaseassettype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASEAssetType(pub NSInteger);
impl PHASEAssetType {
    #[doc(alias = "PHASEAssetTypeResident")]
    pub const Resident: Self = Self(0);
    #[doc(alias = "PHASEAssetTypeStreamed")]
    pub const Streamed: Self = Self(1);
}

unsafe impl Encode for PHASEAssetType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASEAssetType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Curve types.
///
/// A curve of the form y = x.
///
/// A curve of the form y = x^2.
///
/// A curve of the form y = 1 / x^2.
///
/// A curve of the form y = x^3.
///
/// A curve of the form y = 1 / x^3.
///
/// A sine curve.
///
/// An inverse sine curve.
///
/// A sigmoid curve.
/// Also known as an s-curve, slow at the ends and quick in the middle.
///
/// An inverse sigmoid curve.
/// Also known as an inverse s-curve, quick at the ends and slow in the middle.
///
/// Holds the start value for the duration of the curve.
///
/// Jumps to the end value and holds it for the duration of the curve.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasecurvetype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASECurveType(pub NSInteger);
impl PHASECurveType {
    #[doc(alias = "PHASECurveTypeLinear")]
    pub const Linear: Self = Self(0x63724c6e);
    #[doc(alias = "PHASECurveTypeSquared")]
    pub const Squared: Self = Self(0x63725371);
    #[doc(alias = "PHASECurveTypeInverseSquared")]
    pub const InverseSquared: Self = Self(0x63724951);
    #[doc(alias = "PHASECurveTypeCubed")]
    pub const Cubed: Self = Self(0x63724375);
    #[doc(alias = "PHASECurveTypeInverseCubed")]
    pub const InverseCubed: Self = Self(0x63724943);
    #[doc(alias = "PHASECurveTypeSine")]
    pub const Sine: Self = Self(0x6372536e);
    #[doc(alias = "PHASECurveTypeInverseSine")]
    pub const InverseSine: Self = Self(0x63724953);
    #[doc(alias = "PHASECurveTypeSigmoid")]
    pub const Sigmoid: Self = Self(0x63725367);
    #[doc(alias = "PHASECurveTypeInverseSigmoid")]
    pub const InverseSigmoid: Self = Self(0x63724947);
    #[doc(alias = "PHASECurveTypeHoldStartValue")]
    pub const HoldStartValue: Self = Self(0x63724853);
    #[doc(alias = "PHASECurveTypeJumpToEndValue")]
    pub const JumpToEndValue: Self = Self(0x63724a45);
}

unsafe impl Encode for PHASECurveType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASECurveType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Cull option.
///
/// Determines what the engine should do when a sound asset becomes cullable.
///
/// If cullable, the sound asset will stop. Note that this can occur before or during playback.
///
/// If cullable, the sound asset will be put to sleep. Upon waking, start playback at the beginning.
///
/// If cullable, the sound asset will be put to sleep. Upon waking, start playback at random offset.
///
/// If cullable, the sound asset will be put to sleep. Upon waking, start playback at realtime offset.
///
/// If cullable, continue playback, even if the sound is inaudible.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaseculloption?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASECullOption(pub NSInteger);
impl PHASECullOption {
    #[doc(alias = "PHASECullOptionTerminate")]
    pub const Terminate: Self = Self(0);
    #[doc(alias = "PHASECullOptionSleepWakeAtZero")]
    pub const SleepWakeAtZero: Self = Self(1);
    #[doc(alias = "PHASECullOptionSleepWakeAtRandomOffset")]
    pub const SleepWakeAtRandomOffset: Self = Self(2);
    #[doc(alias = "PHASECullOptionSleepWakeAtRealtimeOffset")]
    pub const SleepWakeAtRealtimeOffset: Self = Self(3);
    #[doc(alias = "PHASECullOptionDoNotCull")]
    pub const DoNotCull: Self = Self(4);
}

unsafe impl Encode for PHASECullOption {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASECullOption {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Playback mode.
///
/// Play the sound asset once, then stop.
///
/// Loop the sound asset indefinitely.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaseplaybackmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASEPlaybackMode(pub NSInteger);
impl PHASEPlaybackMode {
    #[doc(alias = "PHASEPlaybackModeOneShot")]
    pub const OneShot: Self = Self(0);
    #[doc(alias = "PHASEPlaybackModeLooping")]
    pub const Looping: Self = Self(1);
}

unsafe impl Encode for PHASEPlaybackMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASEPlaybackMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Normalization mode
///
/// Determines how sound assets are normalized for calibrated loudness on the output device.
///
/// Note: In general, clients are advised to normalize sound assets (and streams).
/// This will make it easier to mix the content once assigned to a generator with a specified calbration mode and level.
///
/// No normalization is applied. In this case, it's advised that the client perform custom normalization.
///
/// Dynamic Normalization is applied.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasenormalizationmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASENormalizationMode(pub NSInteger);
impl PHASENormalizationMode {
    #[doc(alias = "PHASENormalizationModeNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "PHASENormalizationModeDynamic")]
    pub const Dynamic: Self = Self(1);
}

unsafe impl Encode for PHASENormalizationMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASENormalizationMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Calibration mode.
///
/// Note: In general, clients are advised use a calibrated input mode. Setting the value to PHASECalibrationModeNone is not advised.
///
/// Linear gain with no reference (uncailbrated).
///
/// SPL relative to a device-tuned SPL (when available).
///
/// Absolute SPL. The system will hit the value 'if it can' (depending on the capabilities of the current output device).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phasecalibrationmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASECalibrationMode(pub NSInteger);
impl PHASECalibrationMode {
    #[doc(alias = "PHASECalibrationModeNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "PHASECalibrationModeRelativeSpl")]
    pub const RelativeSpl: Self = Self(1);
    #[doc(alias = "PHASECalibrationModeAbsoluteSpl")]
    pub const AbsoluteSpl: Self = Self(2);
}

unsafe impl Encode for PHASECalibrationMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for PHASECalibrationMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Automatic Head-Tracking flags.
///
/// On capable devices, listener orientation will be automatically rotated based on user's head-orientation.
///
/// On capable devices, listener position will be automatically set based on user's position.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/phase/phaseautomaticheadtrackingflags?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct PHASEAutomaticHeadTrackingFlags(pub NSUInteger);
bitflags::bitflags! {
    impl PHASEAutomaticHeadTrackingFlags: NSUInteger {
        #[doc(alias = "PHASEAutomaticHeadTrackingFlagOrientation")]
        const Orientation = 1<<0;
        #[doc(alias = "PHASEAutomaticHeadTrackingFlagPosition")]
        const Position = 1<<1;
    }
}

unsafe impl Encode for PHASEAutomaticHeadTrackingFlags {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for PHASEAutomaticHeadTrackingFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}
