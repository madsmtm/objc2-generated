//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Options for the content of a mesh buffer, used by the [`type`](https://developer.apple.com/documentation/modelio/mdlmeshbuffer/type) property and by [`MDLMeshBufferAllocator`](https://developer.apple.com/documentation/modelio/mdlmeshbufferallocator) methods for creating buffers.
/// Type of data a MDLMeshBuffer has been allocated for
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MDLMeshBufferType(pub NSUInteger);
impl MDLMeshBufferType {
    /// The buffer contains per-vertex data for one or more vertex attributes of a [`MDLMesh`](https://developer.apple.com/documentation/modelio/mdlmesh) object.
    #[doc(alias = "MDLMeshBufferTypeVertex")]
    pub const Vertex: Self = Self(1);
    /// The buffer contains index data for a [`MDLSubmesh`](https://developer.apple.com/documentation/modelio/mdlsubmesh) object.
    #[doc(alias = "MDLMeshBufferTypeIndex")]
    pub const Index: Self = Self(2);
    #[doc(alias = "MDLMeshBufferTypeCustom")]
    pub const Custom: Self = Self(3);
}

unsafe impl Encode for MDLMeshBufferType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MDLMeshBufferType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that manages access to a memory buffer used for the data storage of a Model I/O mesh.
    ///
    /// ## Overview
    ///
    /// Typically, you do not create [`MDLMeshBufferMap`](https://developer.apple.com/documentation/modelio/mdlmeshbuffermap) objects directly. Instead, you use classes supporting the [`MDLMeshBuffer`](https://developer.apple.com/documentation/modelio/mdlmeshbuffer) protocol to manage mesh buffer memory shared with a rendering technology—for example, the [`MTKMeshBuffer`](https://developer.apple.com/documentation/metalkit/mtkmeshbuffer) class for rendering with Metal. A mesh buffer object vends a [`MDLMeshBufferMap`](https://developer.apple.com/documentation/modelio/mdlmeshbuffermap) objects when you use the [`map`](https://developer.apple.com/documentation/modelio/mdlmeshbuffer/map()) method to gain temporary access to the shared memory.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  When you use a mesh buffer’s [`map`](https://developer.apple.com/documentation/modelio/mdlmeshbuffer/map()) method, the buffer remains mapped for as long as that [`MDLMeshBufferMap`](https://developer.apple.com/documentation/modelio/mdlmeshbuffermap) object exists. Mapping a buffer may impose restrictions on a system. For example, a buffer in shared GPU memory may be unavailable for rendering while mapped, causing draw calls that use the buffer to fail until the corresponding [`MDLMeshBufferMap`](https://developer.apple.com/documentation/modelio/mdlmeshbuffermap) object is deallocated.
    ///
    ///
    ///
    /// </div>
    ///
    /// Represents a reference to memory of a mapped MeshBuffer
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLMeshBufferMap;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLMeshBufferMap {}
);

impl MDLMeshBufferMap {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// Called by implementor of MDLMeshBuffer protocol to create the map
        /// and arrange for unmapping on deallocation.
        ///
        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytes:deallocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytes_deallocator(
            this: Allocated<Self>,
            bytes: NonNull<c_void>,
            deallocator: Option<&block2::DynBlock<dyn Fn()>>,
        ) -> Retained<Self>;

        /// Mutable pointer to data in a MDLMeshBuffer object.
        #[unsafe(method(bytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn bytes(&self) -> NonNull<c_void>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLMeshBufferMap {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// The general interface for managing storage of vertex and index data used in loading, processing, and rendering meshes.
    ///
    /// ## Overview
    ///
    /// Model I/O creates buffers using an allocator that you specify when loading mesh data from a file with the [`MDLAsset`](https://developer.apple.com/documentation/modelio/mdlasset) class or generating meshes with the [`MDLMesh`](https://developer.apple.com/documentation/modelio/mdlmesh) class. You can also create buffers using an allocator method such as [`newBufferWithData:type:`](https://developer.apple.com/documentation/modelio/mdlmeshbufferallocator/newbuffer(with:type:)). The allocator you choose determines the concrete class of a mesh buffer and thus its storage mechanism—for example, the MetalKit [`MTKMeshBufferAllocator`](https://developer.apple.com/documentation/metalkit/mtkmeshbufferallocator) class allocates [`MTKMeshBuffer`](https://developer.apple.com/documentation/metalkit/mtkmeshbuffer) objects, which share storage with Metal buffers for use in rendering.
    ///
    ///
    /// Used by ModelIO to represent a buffer to be filled with vertex and
    /// index data
    ///
    /// Supports deep copy of data by conforming to the NSCopying protocol
    pub unsafe trait MDLMeshBuffer: NSObjectProtocol + NSCopying {
        /// Fills buffer with data at offset
        ///
        /// Parameter `data`: Data to fill buffer with
        ///
        /// Parameter `offset`: Byte offset in buffer to begin filling data
        ///
        /// Fills data.length bytes of data.  Will not write beyond length of
        /// this buffer.
        #[unsafe(method(fillData:offset:))]
        #[unsafe(method_family = none)]
        unsafe fn fillData_offset(&self, data: &NSData, offset: NSUInteger);

        /// CPU access to buffer's memory
        ///
        /// Returns: An MDLMeshBufferMap object to read or modify a buffer's memory
        ///
        /// The buffer will remain mapped as long as the returned MDLMeshBufferMap
        /// object exists. Mapping a buffer may impose restrictions on a system.
        /// For instance,  if the implementing class maps an OpenGL buffer, that
        /// buffer may be  unavailable for rendering while mapped, and cause a
        /// draw failure.  Precautions must be taken in such cases.
        #[unsafe(method(map))]
        #[unsafe(method_family = none)]
        unsafe fn map(&self) -> Retained<MDLMeshBufferMap>;

        /// Size in bytes of the buffer allocation
        #[unsafe(method(length))]
        #[unsafe(method_family = none)]
        unsafe fn length(&self) -> NSUInteger;

        /// Allocator object used to create this buffer.
        ///
        /// This allcoator used for copy and relayout operations (such as when
        /// a new vertex descriptor is applied to a vertex buffer)
        #[unsafe(method(allocator))]
        #[unsafe(method_family = none)]
        unsafe fn allocator(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferAllocator>>;

        /// Zone from which this buffer was created
        ///
        /// This zone will be used for copy and relayout operations (such as
        /// when a new vertex descriptor is applied to a vertex buffer).  If
        /// the default zone is used this will be nil.
        #[unsafe(method(zone))]
        #[unsafe(method_family = none)]
        unsafe fn zone(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferZone>>;

        /// the intended type of the buffer
        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        unsafe fn r#type(&self) -> MDLMeshBufferType;
    }
);

extern_class!(
    /// A memory buffer that stores vertex or index data for a Model I/O mesh.
    ///
    /// ## Overview
    ///
    /// This class is the simplest concrete implementation of the [`MDLMeshBuffer`](https://developer.apple.com/documentation/modelio/mdlmeshbuffer) protocol—use this class when you need only a single data store for loading or processing mesh data. To share mesh data for other uses, use another concrete implementation of the [`MDLMeshBuffer`](https://developer.apple.com/documentation/modelio/mdlmeshbuffer) protocol—for example, the [`MTKMeshBuffer`](https://developer.apple.com/documentation/metalkit/mtkmeshbuffer) class shares mesh data with Metal buffers, ensuring that data is copied a minimal number of times between loading, processing, and rendering.If you do not specify a [`MDLMeshBufferAllocator`](https://developer.apple.com/documentation/modelio/mdlmeshbufferallocator) object for loading meshes from a file with the [`MDLAsset`](https://developer.apple.com/documentation/modelio/mdlasset) class or generating meshes with the [`MDLMesh`](https://developer.apple.com/documentation/modelio/mdlmesh) class, Model I/O uses [`MDLMeshBufferData`](https://developer.apple.com/documentation/modelio/mdlmeshbufferdata) objects to store mesh data.
    ///
    ///
    /// A CPU memory backed mesh buffer
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLMeshBufferData;
);

extern_conformance!(
    unsafe impl MDLMeshBuffer for MDLMeshBufferData {}
);

extern_conformance!(
    unsafe impl NSCopying for MDLMeshBufferData {}
);

unsafe impl CopyingHelper for MDLMeshBufferData {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLMeshBufferData {}
);

impl MDLMeshBufferData {
    extern_methods!(
        /// instantiate a new data backed mesh buffer
        ///
        /// Parameter `type`: the intended use of the buffer
        ///
        /// Parameter `length`: the size of buffer to allocate, in bytes
        #[unsafe(method(initWithType:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithType_length(
            this: Allocated<Self>,
            r#type: MDLMeshBufferType,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// instantiate a new data backed mesh buffer
        ///
        /// Parameter `type`: the intended use of the buffer
        ///
        /// Parameter `data`: the data to be used as a mesh buffer. It will be copied.
        #[unsafe(method(initWithType:data:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithType_data(
            this: Allocated<Self>,
            r#type: MDLMeshBufferType,
            data: Option<&NSData>,
        ) -> Retained<Self>;

        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Retained<NSData>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLMeshBufferData {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// The general interface for logical pools of memory used in allocation of related mesh data buffers.
    ///
    /// ## Overview
    ///
    /// The concrete type of a zone is often private—you obtain zones by creating them from a [`MDLMeshBufferAllocator`](https://developer.apple.com/documentation/modelio/mdlmeshbufferallocator) object, then use zones with allocator methods such as [`newBufferFromZone:data:type:`](https://developer.apple.com/documentation/modelio/mdlmeshbufferallocator/newbuffer(from:data:type:)) when you need to ensure that related buffers are allocated together.
    ///
    ///
    /// A reference to a logical pool of memory from which mesh buffers would
    /// be allocated
    pub unsafe trait MDLMeshBufferZone: NSObjectProtocol {
        /// Total size of memory in the zone
        #[unsafe(method(capacity))]
        #[unsafe(method_family = none)]
        unsafe fn capacity(&self) -> NSUInteger;

        /// Allocator used to create the zone
        #[unsafe(method(allocator))]
        #[unsafe(method_family = none)]
        unsafe fn allocator(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferAllocator>>;
    }
);

extern_protocol!(
    /// The general interface for managing allocation of data buffers to be used in loading, processing, and rendering meshes.
    ///
    /// ## Overview
    ///
    /// Classes adopting this protocol provide different ways of handling mesh buffer data. For example, the [`MTKMeshBufferAllocator`](https://developer.apple.com/documentation/metalkit/mtkmeshbufferallocator) class can share mesh data with Metal buffers for use in rendering.
    ///
    /// When you load meshes from a file with the [`MDLAsset`](https://developer.apple.com/documentation/modelio/mdlasset) class or generate meshes with the [`MDLMesh`](https://developer.apple.com/documentation/modelio/mdlmesh) class, you must specify an allocator. By choosing an allocator specific to how you use a mesh, you can ensure that vertex and index data for the mesh is copied and transformed a minimal number of times between loading and use.
    ///
    ///
    /// Object for allocating buffers to back vertex and index data
    ///
    /// Accepted by MDLAsset init method.  Implementor creates objects
    /// implementing MDLMeshBuffer with memory to be filled with vertex and
    /// index data during 3d file loading and parsing.
    pub unsafe trait MDLMeshBufferAllocator: NSObjectProtocol {
        /// Create a zone which can be used to allocate MDLMeshBuffer objects
        ///
        /// Parameter `capacity`: Total size in bytes of all buffers which can be created from
        /// this zone
        #[unsafe(method(newZone:))]
        #[unsafe(method_family = new)]
        unsafe fn newZone(
            &self,
            capacity: NSUInteger,
        ) -> Retained<ProtocolObject<dyn MDLMeshBufferZone>>;

        /// Create a zone which can be used to allocate MDLMeshBuffer objects
        ///
        /// Parameter `sizes`: Sizes of each buffer to be created in this zone
        ///
        /// Parameter `types`: Type of each buffer to be created in this zone. Values to be of
        /// MDLMeshBufferType
        ///
        /// Will create a zone from which MDLMeshBuffer objects can be
        /// allocated.  This will allocate a zone with enough capacity
        /// for each of the buffers with sizes and types specified even taking
        /// into any alignment restrictions necessary to use these buffers.
        #[unsafe(method(newZoneForBuffersWithSize:andType:))]
        #[unsafe(method_family = new)]
        unsafe fn newZoneForBuffersWithSize_andType(
            &self,
            sizes: &NSArray<NSNumber>,
            types: &NSArray<NSNumber>,
        ) -> Retained<ProtocolObject<dyn MDLMeshBufferZone>>;

        /// Create a buffer in a default zone
        ///
        /// Parameter `length`: Size of buffer to be created in bytes
        ///
        /// Parameter `type`: Type of data to be stored in this buffer
        #[unsafe(method(newBuffer:type:))]
        #[unsafe(method_family = new)]
        unsafe fn newBuffer_type(
            &self,
            length: NSUInteger,
            r#type: MDLMeshBufferType,
        ) -> Retained<ProtocolObject<dyn MDLMeshBuffer>>;

        /// Create a buffer in a default zone and fill with data in the supplied
        /// NSData object
        ///
        /// Parameter `data`: Memory to fill the buffer with
        ///
        /// Parameter `type`: Type of data to be stored in this buffer
        #[unsafe(method(newBufferWithData:type:))]
        #[unsafe(method_family = new)]
        unsafe fn newBufferWithData_type(
            &self,
            data: &NSData,
            r#type: MDLMeshBufferType,
        ) -> Retained<ProtocolObject<dyn MDLMeshBuffer>>;

        /// Create a buffer from a given zone with the given length
        ///
        /// Returns: An object conforming to the MDLMeshBuffer protocol.  Returns nil the
        /// buffer could not be allocated in the zone given.
        ///
        /// Parameter `zone`: Zone from which to allocate the memory
        ///
        /// Parameter `type`: Type of data to be stored in this buffer
        ///
        /// An implementing MDLMeshBufferAllocator object may increase the size
        /// of the zone if the buffer could not be allocated with the current
        /// zone size.  Alternatively the implementation may return nil if the
        /// buffer could not be allocated.
        #[unsafe(method(newBufferFromZone:length:type:))]
        #[unsafe(method_family = new)]
        unsafe fn newBufferFromZone_length_type(
            &self,
            zone: Option<&ProtocolObject<dyn MDLMeshBufferZone>>,
            length: NSUInteger,
            r#type: MDLMeshBufferType,
        ) -> Option<Retained<ProtocolObject<dyn MDLMeshBuffer>>>;

        /// Create a buffer from a given zone and fill with data in the supplied
        /// NSData object
        ///
        /// Returns: An object conforming to the MDLMeshBuffer protocol.  Returns nil the
        /// buffer could not be allocated in the given zone
        ///
        /// Parameter `zone`: Zone from which to allocate the memory
        ///
        /// Parameter `data`: Values with which to fill the buffer
        ///
        /// Parameter `type`: Type of data to be stored in this buffer
        ///
        /// An implementing MDLMeshBufferAllocator object may increase the size
        /// of the zone if the buffer could not be allocated with the current
        /// zone size. Alternatively the implementation may return nil if the
        /// buffer could not be allocated.
        #[unsafe(method(newBufferFromZone:data:type:))]
        #[unsafe(method_family = new)]
        unsafe fn newBufferFromZone_data_type(
            &self,
            zone: Option<&ProtocolObject<dyn MDLMeshBufferZone>>,
            data: &NSData,
            r#type: MDLMeshBufferType,
        ) -> Option<Retained<ProtocolObject<dyn MDLMeshBuffer>>>;
    }
);

extern_class!(
    /// A basic allocator implementation that allocates from main memory using data objects.
    ///
    /// ## Overview
    ///
    /// Model I/O uses this allocator by default if you do not specify an allocator when loading, creating, or modifying objects that require mesh buffer storage (for example, when loading an asset with the [`initWithURL:vertexDescriptor:bufferAllocator:`](https://developer.apple.com/documentation/modelio/mdlasset/init(url:vertexdescriptor:bufferallocator:)) initializer). Use this allocator only if sharing mesh buffer memory with GPU-based renderers is not a concern. To minimize data copying when rendering with Metal or OpenGL, use the [`MTKMeshBufferAllocator`](https://developer.apple.com/documentation/metalkit/mtkmeshbufferallocator) or [`GLKMeshBufferAllocator`](https://developer.apple.com/documentation/glkit/glkmeshbufferallocator) class instead.This class declares no methods or properties of its own. For the key functionality of all mesh buffer allocator objects, see [`MDLMeshBufferAllocator`](https://developer.apple.com/documentation/modelio/mdlmeshbufferallocator).
    ///
    ///
    /// An allocator to use when backing with an NSData is appropriate.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLMeshBufferDataAllocator;
);

extern_conformance!(
    unsafe impl MDLMeshBufferAllocator for MDLMeshBufferDataAllocator {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLMeshBufferDataAllocator {}
);

impl MDLMeshBufferDataAllocator {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl MDLMeshBufferDataAllocator {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A standard implementation of the [`MDLMeshBufferZone`](https://developer.apple.com/documentation/modelio/mdlmeshbufferzone) protocol.
    ///
    /// ## Overview
    ///
    /// Model I/O uses zones to ensure that related allocations—such as the multiple vertex and index buffers associated with a [`MDLMesh`](https://developer.apple.com/documentation/modelio/mdlmesh) object—use contiguous blocks of memory for optimal performance. When working with a [`MDLMeshBufferAllocator`](https://developer.apple.com/documentation/modelio/mdlmeshbufferallocator) object that does not implement its own zone management, Model I/O uses this zone class.This class declares no methods or properties of its own. For the key functionality of all mesh buffer zone objects, see [`MDLMeshBufferZone`](https://developer.apple.com/documentation/modelio/mdlmeshbufferzone).
    ///
    ///
    /// A default zone that can be use for convenience
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLMeshBufferZoneDefault;
);

extern_conformance!(
    unsafe impl MDLMeshBufferZone for MDLMeshBufferZoneDefault {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLMeshBufferZoneDefault {}
);

impl MDLMeshBufferZoneDefault {
    extern_methods!(
        #[unsafe(method(capacity))]
        #[unsafe(method_family = none)]
        pub unsafe fn capacity(&self) -> NSUInteger;

        #[unsafe(method(allocator))]
        #[unsafe(method_family = none)]
        pub unsafe fn allocator(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferAllocator>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLMeshBufferZoneDefault {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
