//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
use objc2_foundation::*;

use crate::*;

/// Options for the data size and type of texel channel values, used by the [`channelEncoding`](https://developer.apple.com/documentation/modelio/mdltexture/channelencoding) property.
/// The enoding of texel channel elements
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MDLTextureChannelEncoding(pub NSInteger);
impl MDLTextureChannelEncoding {
    /// Each channel value per texel is an 8-bit unsigned integer.
    #[doc(alias = "MDLTextureChannelEncodingUInt8")]
    pub const UInt8: Self = Self(1);
    /// Each channel value per texel is an 8-bit unsigned integer.
    #[doc(alias = "MDLTextureChannelEncodingUint8")]
    pub const Uint8: Self = Self(1);
    /// Each channel value per texel is a 16-bit unsigned integer.
    #[doc(alias = "MDLTextureChannelEncodingUInt16")]
    pub const UInt16: Self = Self(2);
    /// Each channel value per texel is a 16-bit unsigned integer.
    #[doc(alias = "MDLTextureChannelEncodingUint16")]
    pub const Uint16: Self = Self(2);
    /// Each channel value per texel is a 24-bit unsigned integer.
    #[doc(alias = "MDLTextureChannelEncodingUInt24")]
    pub const UInt24: Self = Self(3);
    /// Each channel value per texel is a 24-bit unsigned integer.
    #[doc(alias = "MDLTextureChannelEncodingUint24")]
    pub const Uint24: Self = Self(3);
    /// Each channel value per texel is a 32-bit unsigned integer.
    #[doc(alias = "MDLTextureChannelEncodingUInt32")]
    pub const UInt32: Self = Self(4);
    /// Each channel value per texel is a 32-bit unsigned integer.
    #[doc(alias = "MDLTextureChannelEncodingUint32")]
    pub const Uint32: Self = Self(4);
    /// Each channel value per texel is a 16-bit floating-point value.
    #[doc(alias = "MDLTextureChannelEncodingFloat16")]
    pub const Float16: Self = Self(0x102);
    #[doc(alias = "MDLTextureChannelEncodingFloat16SR")]
    pub const Float16SR: Self = Self(0x302);
    /// Each channel value per texel is a 32-bit floating-point value.
    #[doc(alias = "MDLTextureChannelEncodingFloat32")]
    pub const Float32: Self = Self(0x104);
}

unsafe impl Encode for MDLTextureChannelEncoding {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MDLTextureChannelEncoding {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A source of texel data to be used in rendering material surface appearances.
    ///
    /// ## Overview
    ///
    /// You use the [`MDLTexture`](https://developer.apple.com/documentation/modelio/mdltexture) class or one of its subclasses to identify, load, or create texture data, and then associate textures with materials using the [`MDLTextureSampler`](https://developer.apple.com/documentation/modelio/mdltexturesampler) and [`MDLMaterialProperty`](https://developer.apple.com/documentation/modelio/mdlmaterialproperty) classes. When you load 3D objects from an asset file (in a format that supports texturing) with the [`MDLAsset`](https://developer.apple.com/documentation/modelio/mdlasset) class, Model I/O automatically creates texture objects and material objects and associates them with the [`MDLSubmesh`](https://developer.apple.com/documentation/modelio/mdlsubmesh) objects in the asset.
    ///
    ///
    /// MDLTexture
    /// a description of texels provided by a texture object.
    ///
    ///
    /// A texture optionally generates or loads texels
    /// through an access to the data property, or one of the other
    /// properties, otherwise the texture object is a lightweight descriptor
    /// only.
    ///
    ///
    /// Texel data that will exist when referenced; it may or may not exist
    /// before
    ///
    /// texel width and height of the texture
    ///
    /// The number of bytes from the first texel in a row to the first texel
    /// in the next row. A rowStride of zero indicates that interleaved x,y
    /// addressing of texels is not possible. This might be the case if the
    /// texture was compressed in some manner, for example.
    ///
    /// The number of channels incoded in a single texel. For example, an RGB
    /// texture has 3 channels. All channels must have the same encoding.
    ///
    /// The encoding of a channel in a single texel.
    ///
    /// The texture encodes a cube map. If YES, then the layout of the cube
    /// map is deduced as a vertical strip if dimension.y is six times
    /// dimension.x. Other layouts are possible in the future.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLTexture;
);

#[cfg(feature = "MDLTypes")]
extern_conformance!(
    unsafe impl MDLNamed for MDLTexture {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLTexture {}
);

impl MDLTexture {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates a texture from a source in the main bundle named in a manner matching
        /// name.
        #[unsafe(method(textureNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed(name: &NSString) -> Option<Retained<Self>>;

        #[unsafe(method(textureNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_bundle(
            name: &NSString,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "MDLAssetResolver")]
        #[unsafe(method(textureNamed:assetResolver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_assetResolver(
            name: &NSString,
            resolver: &ProtocolObject<dyn MDLAssetResolver>,
        ) -> Option<Retained<Self>>;

        /// Creates a cube texture map image using 6 faces of the same dimensions,
        /// ordered +X,-X,+Y,-Y,+Z,-Z If the data is read back the image will be compacted
        /// into a single vertical stack where dimensions.y = 6 * dimensions.x
        /// isCube will return YES
        ///
        ///
        /// Parameter `names`: a collection of mosaiced images in a cross formation or column or row.
        /// - If 6 individual images are given they are assumed to be in order and will be
        /// loaded as is.
        /// - if 3 images of double height or width are given they will be treated as
        /// pairs of + and - in each axis, the order is must be x, then y, then z.
        /// - if 2 images of triple height or width are given they will be treates as a
        /// positive set and a negative set in the order +x, +y, +z, then -x, -y, -z.
        /// - if a single image is given it will be used without conversion if in column
        /// orientation and demosaiced in all other instances.
        #[unsafe(method(textureCubeWithImagesNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed(
            names: &NSArray<NSString>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(textureCubeWithImagesNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed_bundle(
            names: &NSArray<NSString>,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;

        /// write a texture to URL, deducing type from path extension
        #[unsafe(method(writeToURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeToURL(&self, url: &NSURL) -> bool;

        /// write a particular level of a mipped texture to URL, deducing type from path extension
        #[unsafe(method(writeToURL:level:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeToURL_level(&self, url: &NSURL, level: NSUInteger) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        /// write a texture to URL, using a specific UT type
        #[unsafe(method(writeToURL:type:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeToURL_type(&self, nsurl: &NSURL, r#type: &CFString) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        /// write a particular level of a mipped texture to URL, using a specific UT type
        #[unsafe(method(writeToURL:type:level:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeToURL_type_level(
            &self,
            nsurl: &NSURL,
            r#type: &CFString,
            level: NSUInteger,
        ) -> bool;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(imageFromTexture))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageFromTexture(&self) -> Option<Retained<CGImage>>;

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(imageFromTextureAtLevel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageFromTextureAtLevel(
            &self,
            level: NSUInteger,
        ) -> Option<Retained<CGImage>>;

        #[unsafe(method(texelDataWithTopLeftOrigin))]
        #[unsafe(method_family = none)]
        pub unsafe fn texelDataWithTopLeftOrigin(&self) -> Option<Retained<NSData>>;

        #[unsafe(method(texelDataWithBottomLeftOrigin))]
        #[unsafe(method_family = none)]
        pub unsafe fn texelDataWithBottomLeftOrigin(&self) -> Option<Retained<NSData>>;

        #[unsafe(method(texelDataWithTopLeftOriginAtMipLevel:create:))]
        #[unsafe(method_family = none)]
        pub unsafe fn texelDataWithTopLeftOriginAtMipLevel_create(
            &self,
            level: NSInteger,
            create: bool,
        ) -> Option<Retained<NSData>>;

        #[unsafe(method(texelDataWithBottomLeftOriginAtMipLevel:create:))]
        #[unsafe(method_family = none)]
        pub unsafe fn texelDataWithBottomLeftOriginAtMipLevel_create(
            &self,
            level: NSInteger,
            create: bool,
        ) -> Option<Retained<NSData>>;

        #[unsafe(method(rowStride))]
        #[unsafe(method_family = none)]
        pub unsafe fn rowStride(&self) -> NSInteger;

        #[unsafe(method(channelCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn channelCount(&self) -> NSUInteger;

        #[unsafe(method(mipLevelCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn mipLevelCount(&self) -> NSUInteger;

        #[unsafe(method(channelEncoding))]
        #[unsafe(method_family = none)]
        pub unsafe fn channelEncoding(&self) -> MDLTextureChannelEncoding;

        #[unsafe(method(isCube))]
        #[unsafe(method_family = none)]
        pub unsafe fn isCube(&self) -> bool;

        /// Setter for [`isCube`][Self::isCube].
        #[unsafe(method(setIsCube:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIsCube(&self, is_cube: bool);

        /// hasAlphaValues
        /// Can be overridden. If not overridden, hasAlpha will be NO if the texture does not
        /// have an alpha channel. It wil be YES if the texture has an alpha channel and
        /// there is at least one non-opaque texel in it.
        #[unsafe(method(hasAlphaValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasAlphaValues(&self) -> bool;

        /// Setter for [`hasAlphaValues`][Self::hasAlphaValues].
        #[unsafe(method(setHasAlphaValues:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHasAlphaValues(&self, has_alpha_values: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLTexture {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A lightweight reference to a URL from which to load texture data.
    ///
    /// ## Overview
    ///
    /// Unlike the superclass [`MDLTexture`](https://developer.apple.com/documentation/modelio/mdltexture), the [`MDLURLTexture`](https://developer.apple.com/documentation/modelio/mdlurltexture) class loads texel data from the file at that URL only when that data is first referenced, and then caches it for future use.
    ///
    ///
    /// MDLURLTexture
    /// a texture provider initialized with a URL or file path.
    ///
    /// if any of the properties of the texture, such as data, are referenced,
    /// then the texture may be loaded, otherwise, the MDLURLTexture is merely
    /// a lightweight reference to something that could be loaded
    #[unsafe(super(MDLTexture, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLURLTexture;
);

#[cfg(feature = "MDLTypes")]
extern_conformance!(
    unsafe impl MDLNamed for MDLURLTexture {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLURLTexture {}
);

impl MDLURLTexture {
    extern_methods!(
        #[unsafe(method(initWithURL:name:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_name(
            this: Allocated<Self>,
            url: &NSURL,
            name: Option<&NSString>,
        ) -> Retained<Self>;

        #[unsafe(method(URL))]
        #[unsafe(method_family = none)]
        pub unsafe fn URL(&self) -> Retained<NSURL>;

        /// Setter for [`URL`][Self::URL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setURL(&self, url: &NSURL);
    );
}

/// Methods declared on superclass `MDLTexture`.
impl MDLURLTexture {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates a texture from a source in the main bundle named in a manner matching
        /// name.
        #[unsafe(method(textureNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed(name: &NSString) -> Option<Retained<Self>>;

        #[unsafe(method(textureNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_bundle(
            name: &NSString,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "MDLAssetResolver")]
        #[unsafe(method(textureNamed:assetResolver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_assetResolver(
            name: &NSString,
            resolver: &ProtocolObject<dyn MDLAssetResolver>,
        ) -> Option<Retained<Self>>;

        /// Creates a cube texture map image using 6 faces of the same dimensions,
        /// ordered +X,-X,+Y,-Y,+Z,-Z If the data is read back the image will be compacted
        /// into a single vertical stack where dimensions.y = 6 * dimensions.x
        /// isCube will return YES
        ///
        ///
        /// Parameter `names`: a collection of mosaiced images in a cross formation or column or row.
        /// - If 6 individual images are given they are assumed to be in order and will be
        /// loaded as is.
        /// - if 3 images of double height or width are given they will be treated as
        /// pairs of + and - in each axis, the order is must be x, then y, then z.
        /// - if 2 images of triple height or width are given they will be treates as a
        /// positive set and a negative set in the order +x, +y, +z, then -x, -y, -z.
        /// - if a single image is given it will be used without conversion if in column
        /// orientation and demosaiced in all other instances.
        #[unsafe(method(textureCubeWithImagesNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed(
            names: &NSArray<NSString>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(textureCubeWithImagesNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed_bundle(
            names: &NSArray<NSString>,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLURLTexture {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A generator of texel data that creates a checkerboard pattern with two specified colors.
    ///
    /// ## Overview
    ///
    /// Like other procedural [`MDLTexture`](https://developer.apple.com/documentation/modelio/mdltexture) subclasses, the [`MDLCheckerboardTexture`](https://developer.apple.com/documentation/modelio/mdlcheckerboardtexture) class generates texel data only when that data is first referenced, and then caches it for future use.
    ///
    ///
    /// MDLCheckerboardTexture
    /// A two color checkboard with a certain number of divisions
    ///
    ///
    /// the texture will be created if data is referenced, otherwise, this
    /// object is merely a description
    #[unsafe(super(MDLTexture, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLCheckerboardTexture;
);

#[cfg(feature = "MDLTypes")]
extern_conformance!(
    unsafe impl MDLNamed for MDLCheckerboardTexture {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLCheckerboardTexture {}
);

impl MDLCheckerboardTexture {
    extern_methods!(
        #[unsafe(method(divisions))]
        #[unsafe(method_family = none)]
        pub unsafe fn divisions(&self) -> c_float;

        /// Setter for [`divisions`][Self::divisions].
        #[unsafe(method(setDivisions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDivisions(&self, divisions: c_float);

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(color1))]
        #[unsafe(method_family = none)]
        pub unsafe fn color1(&self) -> Option<Retained<CGColor>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`color1`][Self::color1].
        #[unsafe(method(setColor1:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setColor1(&self, color1: Option<&CGColor>);

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(color2))]
        #[unsafe(method_family = none)]
        pub unsafe fn color2(&self) -> Option<Retained<CGColor>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`color2`][Self::color2].
        #[unsafe(method(setColor2:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setColor2(&self, color2: Option<&CGColor>);
    );
}

/// Methods declared on superclass `MDLTexture`.
impl MDLCheckerboardTexture {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates a texture from a source in the main bundle named in a manner matching
        /// name.
        #[unsafe(method(textureNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed(name: &NSString) -> Option<Retained<Self>>;

        #[unsafe(method(textureNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_bundle(
            name: &NSString,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "MDLAssetResolver")]
        #[unsafe(method(textureNamed:assetResolver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_assetResolver(
            name: &NSString,
            resolver: &ProtocolObject<dyn MDLAssetResolver>,
        ) -> Option<Retained<Self>>;

        /// Creates a cube texture map image using 6 faces of the same dimensions,
        /// ordered +X,-X,+Y,-Y,+Z,-Z If the data is read back the image will be compacted
        /// into a single vertical stack where dimensions.y = 6 * dimensions.x
        /// isCube will return YES
        ///
        ///
        /// Parameter `names`: a collection of mosaiced images in a cross formation or column or row.
        /// - If 6 individual images are given they are assumed to be in order and will be
        /// loaded as is.
        /// - if 3 images of double height or width are given they will be treated as
        /// pairs of + and - in each axis, the order is must be x, then y, then z.
        /// - if 2 images of triple height or width are given they will be treates as a
        /// positive set and a negative set in the order +x, +y, +z, then -x, -y, -z.
        /// - if a single image is given it will be used without conversion if in column
        /// orientation and demosaiced in all other instances.
        #[unsafe(method(textureCubeWithImagesNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed(
            names: &NSArray<NSString>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(textureCubeWithImagesNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed_bundle(
            names: &NSArray<NSString>,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLCheckerboardTexture {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A generator of texel data that creates cube textures using a physically realistic simulation of the sunlit sky.
    ///
    /// ## Overview
    ///
    /// The sky textures generated by this class can can be useful as environment maps or light probes in rendering. Like other procedural [`MDLTexture`](https://developer.apple.com/documentation/modelio/mdltexture) subclasses, the [`MDLSkyCubeTexture`](https://developer.apple.com/documentation/modelio/mdlskycubetexture) class generates texel data only when that data is first referenced, and then caches it for future use.
    ///
    ///
    /// MDLSkyCubeTexture
    /// A physically realistic sky as a cube texture
    ///
    ///
    /// 1.0 is at the nadir. Use in conjunction with turbidity to give a dawn,
    /// dusk, or noon look.
    ///
    /// will impart very little color to the sky. A value of one simulates a
    /// great deal of dust and moisture in the sky, and will cause the sun's
    /// color to spread across the atmosphere.
    ///
    /// a value of one will give noon-ish saturated colors.
    ///
    /// the sky from the ground. A value of zero will yield a clear sky, a
    /// value of one will reduce the contrast of the sky, making it a bit foggy.
    ///
    ///
    /// by a color, horizonElevation is angle, in radians, below which the
    /// replacement should occur. Negative values are below the horizon.
    ///
    ///
    /// the color below the horizonElevation value blended with the w factor up to
    /// Pi/2.0 past the horizon.
    /// (e.g. w = 0.0 groundColor is applied immediatly on the horizon with no blend
    /// w = Pi/2 groundColor is linearly applied all the way to the south pole)
    /// NOTE: To maintain default behavior a simple length(groundColor) != 0 is used to determine
    /// if we want to set the ground color (e.g. black and blended immediatly
    /// on the horizon use (0.0, 0.0, 0.0, 0.0000001))
    /// 4 component treats the first 3 components as color and w as blend factor
    /// 3 component treats the first 3 components as color and 0 as blend factor
    /// 2 component treats the first component as greyscale color and y as blend factor
    /// 1 component treats the scalar component as greyscale color and 0 as blend factor
    ///
    ///
    /// tone mapping.
    ///
    ///
    ///
    ///
    ///
    /// are not compressed during tone mapping. Values between the x component
    /// and y component are compressed to the maximum brightness value during
    /// tone mapping. Values above the limit are clamped.
    ///
    ///
    /// the texture will be created if data is referenced, otherwise, this
    /// object is merely a description. All parameters have legal values between zero and one.
    #[unsafe(super(MDLTexture, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLSkyCubeTexture;
);

#[cfg(feature = "MDLTypes")]
extern_conformance!(
    unsafe impl MDLNamed for MDLSkyCubeTexture {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLSkyCubeTexture {}
);

impl MDLSkyCubeTexture {
    extern_methods!(
        /// Call updateTexture if parameters have been changed and a new sky is required.
        #[unsafe(method(updateTexture))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateTexture(&self);

        #[unsafe(method(turbidity))]
        #[unsafe(method_family = none)]
        pub unsafe fn turbidity(&self) -> c_float;

        /// Setter for [`turbidity`][Self::turbidity].
        #[unsafe(method(setTurbidity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTurbidity(&self, turbidity: c_float);

        #[unsafe(method(sunElevation))]
        #[unsafe(method_family = none)]
        pub unsafe fn sunElevation(&self) -> c_float;

        /// Setter for [`sunElevation`][Self::sunElevation].
        #[unsafe(method(setSunElevation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSunElevation(&self, sun_elevation: c_float);

        #[unsafe(method(sunAzimuth))]
        #[unsafe(method_family = none)]
        pub unsafe fn sunAzimuth(&self) -> c_float;

        /// Setter for [`sunAzimuth`][Self::sunAzimuth].
        #[unsafe(method(setSunAzimuth:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSunAzimuth(&self, sun_azimuth: c_float);

        #[unsafe(method(upperAtmosphereScattering))]
        #[unsafe(method_family = none)]
        pub unsafe fn upperAtmosphereScattering(&self) -> c_float;

        /// Setter for [`upperAtmosphereScattering`][Self::upperAtmosphereScattering].
        #[unsafe(method(setUpperAtmosphereScattering:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUpperAtmosphereScattering(&self, upper_atmosphere_scattering: c_float);

        #[unsafe(method(groundAlbedo))]
        #[unsafe(method_family = none)]
        pub unsafe fn groundAlbedo(&self) -> c_float;

        /// Setter for [`groundAlbedo`][Self::groundAlbedo].
        #[unsafe(method(setGroundAlbedo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGroundAlbedo(&self, ground_albedo: c_float);

        #[unsafe(method(horizonElevation))]
        #[unsafe(method_family = none)]
        pub unsafe fn horizonElevation(&self) -> c_float;

        /// Setter for [`horizonElevation`][Self::horizonElevation].
        #[unsafe(method(setHorizonElevation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHorizonElevation(&self, horizon_elevation: c_float);

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(groundColor))]
        #[unsafe(method_family = none)]
        pub unsafe fn groundColor(&self) -> Option<Retained<CGColor>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`groundColor`][Self::groundColor].
        #[unsafe(method(setGroundColor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGroundColor(&self, ground_color: Option<&CGColor>);

        #[unsafe(method(gamma))]
        #[unsafe(method_family = none)]
        pub unsafe fn gamma(&self) -> c_float;

        /// Setter for [`gamma`][Self::gamma].
        #[unsafe(method(setGamma:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGamma(&self, gamma: c_float);

        #[unsafe(method(exposure))]
        #[unsafe(method_family = none)]
        pub unsafe fn exposure(&self) -> c_float;

        /// Setter for [`exposure`][Self::exposure].
        #[unsafe(method(setExposure:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExposure(&self, exposure: c_float);

        #[unsafe(method(brightness))]
        #[unsafe(method_family = none)]
        pub unsafe fn brightness(&self) -> c_float;

        /// Setter for [`brightness`][Self::brightness].
        #[unsafe(method(setBrightness:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBrightness(&self, brightness: c_float);

        #[unsafe(method(contrast))]
        #[unsafe(method_family = none)]
        pub unsafe fn contrast(&self) -> c_float;

        /// Setter for [`contrast`][Self::contrast].
        #[unsafe(method(setContrast:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContrast(&self, contrast: c_float);

        #[unsafe(method(saturation))]
        #[unsafe(method_family = none)]
        pub unsafe fn saturation(&self) -> c_float;

        /// Setter for [`saturation`][Self::saturation].
        #[unsafe(method(setSaturation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSaturation(&self, saturation: c_float);
    );
}

/// Methods declared on superclass `MDLTexture`.
impl MDLSkyCubeTexture {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates a texture from a source in the main bundle named in a manner matching
        /// name.
        #[unsafe(method(textureNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed(name: &NSString) -> Option<Retained<Self>>;

        #[unsafe(method(textureNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_bundle(
            name: &NSString,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "MDLAssetResolver")]
        #[unsafe(method(textureNamed:assetResolver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_assetResolver(
            name: &NSString,
            resolver: &ProtocolObject<dyn MDLAssetResolver>,
        ) -> Option<Retained<Self>>;

        /// Creates a cube texture map image using 6 faces of the same dimensions,
        /// ordered +X,-X,+Y,-Y,+Z,-Z If the data is read back the image will be compacted
        /// into a single vertical stack where dimensions.y = 6 * dimensions.x
        /// isCube will return YES
        ///
        ///
        /// Parameter `names`: a collection of mosaiced images in a cross formation or column or row.
        /// - If 6 individual images are given they are assumed to be in order and will be
        /// loaded as is.
        /// - if 3 images of double height or width are given they will be treated as
        /// pairs of + and - in each axis, the order is must be x, then y, then z.
        /// - if 2 images of triple height or width are given they will be treates as a
        /// positive set and a negative set in the order +x, +y, +z, then -x, -y, -z.
        /// - if a single image is given it will be used without conversion if in column
        /// orientation and demosaiced in all other instances.
        #[unsafe(method(textureCubeWithImagesNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed(
            names: &NSArray<NSString>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(textureCubeWithImagesNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed_bundle(
            names: &NSArray<NSString>,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLSkyCubeTexture {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A generator of texel data that creates a gradient between two specified colors.
    ///
    /// ## Overview
    ///
    /// A MDLColorSwatchTexture object procedurally generates texel data by creating a gradient between two colors. Like other procedural [`MDLTexture`](https://developer.apple.com/documentation/modelio/mdltexture) subclasses, the [`MDLColorSwatchTexture`](https://developer.apple.com/documentation/modelio/mdlcolorswatchtexture) class generates texel data only when that data is first referenced, and caches it for future use.
    ///
    ///
    #[unsafe(super(MDLTexture, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLColorSwatchTexture;
);

#[cfg(feature = "MDLTypes")]
extern_conformance!(
    unsafe impl MDLNamed for MDLColorSwatchTexture {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLColorSwatchTexture {}
);

impl MDLColorSwatchTexture {
    extern_methods!();
}

/// Methods declared on superclass `MDLTexture`.
impl MDLColorSwatchTexture {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates a texture from a source in the main bundle named in a manner matching
        /// name.
        #[unsafe(method(textureNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed(name: &NSString) -> Option<Retained<Self>>;

        #[unsafe(method(textureNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_bundle(
            name: &NSString,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "MDLAssetResolver")]
        #[unsafe(method(textureNamed:assetResolver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_assetResolver(
            name: &NSString,
            resolver: &ProtocolObject<dyn MDLAssetResolver>,
        ) -> Option<Retained<Self>>;

        /// Creates a cube texture map image using 6 faces of the same dimensions,
        /// ordered +X,-X,+Y,-Y,+Z,-Z If the data is read back the image will be compacted
        /// into a single vertical stack where dimensions.y = 6 * dimensions.x
        /// isCube will return YES
        ///
        ///
        /// Parameter `names`: a collection of mosaiced images in a cross formation or column or row.
        /// - If 6 individual images are given they are assumed to be in order and will be
        /// loaded as is.
        /// - if 3 images of double height or width are given they will be treated as
        /// pairs of + and - in each axis, the order is must be x, then y, then z.
        /// - if 2 images of triple height or width are given they will be treates as a
        /// positive set and a negative set in the order +x, +y, +z, then -x, -y, -z.
        /// - if a single image is given it will be used without conversion if in column
        /// orientation and demosaiced in all other instances.
        #[unsafe(method(textureCubeWithImagesNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed(
            names: &NSArray<NSString>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(textureCubeWithImagesNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed_bundle(
            names: &NSArray<NSString>,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLColorSwatchTexture {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A generator of texel data that creates a field of random noise.
    ///
    /// ## Overview
    ///
    /// Like other procedural [`MDLTexture`](https://developer.apple.com/documentation/modelio/mdltexture) subclasses, the [`MDLNoiseTexture`](https://developer.apple.com/documentation/modelio/mdlnoisetexture) class generates texel data only when that data is first referenced, and then caches it for future use.
    ///
    ///
    /// MDLNoiseTexture
    /// a noise texture containing vector or scalar noise
    ///
    /// the texture will be created if data is referenced, otherwise, this
    /// object is merely a description
    #[unsafe(super(MDLTexture, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLNoiseTexture;
);

#[cfg(feature = "MDLTypes")]
extern_conformance!(
    unsafe impl MDLNamed for MDLNoiseTexture {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLNoiseTexture {}
);

impl MDLNoiseTexture {
    extern_methods!();
}

/// Methods declared on superclass `MDLTexture`.
impl MDLNoiseTexture {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates a texture from a source in the main bundle named in a manner matching
        /// name.
        #[unsafe(method(textureNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed(name: &NSString) -> Option<Retained<Self>>;

        #[unsafe(method(textureNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_bundle(
            name: &NSString,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "MDLAssetResolver")]
        #[unsafe(method(textureNamed:assetResolver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_assetResolver(
            name: &NSString,
            resolver: &ProtocolObject<dyn MDLAssetResolver>,
        ) -> Option<Retained<Self>>;

        /// Creates a cube texture map image using 6 faces of the same dimensions,
        /// ordered +X,-X,+Y,-Y,+Z,-Z If the data is read back the image will be compacted
        /// into a single vertical stack where dimensions.y = 6 * dimensions.x
        /// isCube will return YES
        ///
        ///
        /// Parameter `names`: a collection of mosaiced images in a cross formation or column or row.
        /// - If 6 individual images are given they are assumed to be in order and will be
        /// loaded as is.
        /// - if 3 images of double height or width are given they will be treated as
        /// pairs of + and - in each axis, the order is must be x, then y, then z.
        /// - if 2 images of triple height or width are given they will be treates as a
        /// positive set and a negative set in the order +x, +y, +z, then -x, -y, -z.
        /// - if a single image is given it will be used without conversion if in column
        /// orientation and demosaiced in all other instances.
        #[unsafe(method(textureCubeWithImagesNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed(
            names: &NSArray<NSString>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(textureCubeWithImagesNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed_bundle(
            names: &NSArray<NSString>,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLNoiseTexture {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A generator of texel data that computes a normal map from a supplied texture.
    ///
    /// ## Overview
    ///
    /// This class examines the shapes of contrasting areas in an input texture to generate a normal map that produces an embossed appearance when rendered with lighting. The figure below shows the normal map generated from an example texture and the effect of using this normal map with lighting in a typical renderer.
    ///
    ///
    /// ![](https://docs-assets.developer.apple.com/published/22a2beff91f68ff49c4351d0d667f98d/media-1965618%402x.png)
    ///
    ///
    /// Like other procedural [`MDLTexture`](https://developer.apple.com/documentation/modelio/mdltexture) subclasses, the [`MDLNormalMapTexture`](https://developer.apple.com/documentation/modelio/mdlnormalmaptexture) class generates texel data only when that data is first referenced, and caches it for future use.
    ///
    ///
    #[unsafe(super(MDLTexture, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLNormalMapTexture;
);

#[cfg(feature = "MDLTypes")]
extern_conformance!(
    unsafe impl MDLNamed for MDLNormalMapTexture {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLNormalMapTexture {}
);

impl MDLNormalMapTexture {
    extern_methods!(
        #[unsafe(method(initByGeneratingNormalMapWithTexture:name:smoothness:contrast:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initByGeneratingNormalMapWithTexture_name_smoothness_contrast(
            this: Allocated<Self>,
            source_texture: &MDLTexture,
            name: Option<&NSString>,
            smoothness: c_float,
            contrast: c_float,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MDLTexture`.
impl MDLNormalMapTexture {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates a texture from a source in the main bundle named in a manner matching
        /// name.
        #[unsafe(method(textureNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed(name: &NSString) -> Option<Retained<Self>>;

        #[unsafe(method(textureNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_bundle(
            name: &NSString,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "MDLAssetResolver")]
        #[unsafe(method(textureNamed:assetResolver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed_assetResolver(
            name: &NSString,
            resolver: &ProtocolObject<dyn MDLAssetResolver>,
        ) -> Option<Retained<Self>>;

        /// Creates a cube texture map image using 6 faces of the same dimensions,
        /// ordered +X,-X,+Y,-Y,+Z,-Z If the data is read back the image will be compacted
        /// into a single vertical stack where dimensions.y = 6 * dimensions.x
        /// isCube will return YES
        ///
        ///
        /// Parameter `names`: a collection of mosaiced images in a cross formation or column or row.
        /// - If 6 individual images are given they are assumed to be in order and will be
        /// loaded as is.
        /// - if 3 images of double height or width are given they will be treated as
        /// pairs of + and - in each axis, the order is must be x, then y, then z.
        /// - if 2 images of triple height or width are given they will be treates as a
        /// positive set and a negative set in the order +x, +y, +z, then -x, -y, -z.
        /// - if a single image is given it will be used without conversion if in column
        /// orientation and demosaiced in all other instances.
        #[unsafe(method(textureCubeWithImagesNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed(
            names: &NSArray<NSString>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(textureCubeWithImagesNamed:bundle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureCubeWithImagesNamed_bundle(
            names: &NSArray<NSString>,
            bundle_or_nil: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLNormalMapTexture {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
