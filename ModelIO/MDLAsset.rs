//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An indexed container for 3D objects and associated information, such as transform hierarchies, meshes, cameras, and lights.
    ///
    /// ## Overview
    ///
    /// You create a [`MDLAsset`](https://developer.apple.com/documentation/modelio/mdlasset) object by loading data from a URL, and you can export an asset to any of several file formats. To access the objects contained in an asset, use [Fast Enumeration](https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Enumeration.html#//apple_ref/doc/uid/TP40008195-CH17-SW3), the [`objectAtIndex:`](https://developer.apple.com/documentation/modelio/mdlasset/object(at:)) method, or subscripting. Each object in an asset can be the root of a hierarchy of objects. To traverse that hierarchy, use an object’s [`children`](https://developer.apple.com/documentation/modelio/mdlobject/children) property.
    ///
    /// An asset may contain timed information, such as a series of mesh morphs. In such cases, the asset’s [`frameInterval`](https://developer.apple.com/documentation/modelio/mdlasset/frameinterval) property is nonzero and the [`startTime`](https://developer.apple.com/documentation/modelio/mdlasset/starttime) and [`endTime`](https://developer.apple.com/documentation/modelio/mdlasset/endtime) properties indicate the range of sample times available in the asset data. For objects contained in the asset, you can use methods such as [`localTransformAtTime:`](https://developer.apple.com/documentation/modelio/mdltransformcomponent/localtransform(attime:)) and [`boundingBoxAtTime:`](https://developer.apple.com/documentation/modelio/mdlobject/boundingbox(attime:)) to access object properties at a specific time sample. Requesting a sample outside the time range clamps to the start or end sample. Some asset formats support continuous sampling with interpolation for times between the samples stored in the asset; other asset formats are discrete. For an asset with discrete time information, requesting a sample time that falls between the samples stored in the asset returns data for the immediately preceding time.
    ///
    ///
    /// An MDLAsset represents the contents of a model file.
    ///
    ///
    /// Each asset contains a collection of hierarchies of objects, where
    /// each object in the asset is the top level of a hierarchy. Objects
    /// include transforms, lights, cameras, and meshes.
    ///
    /// MDLAssets are typically instantiated from NSURLs that refer to a model resource.
    ///
    /// The model resource may represented timed information, for example, a series of
    /// mesh morphs. If the asset is timed, then the framerate will be non-zero, and the
    /// firstFrame and lastFrame properties will indicate the range for which sample
    /// data exists. Samples before or after that range will be clamped. Some model
    /// resource representations allow continuous sampling, others are discrete. In the
    /// discrete case, if a requested sample time is not on a discrete boundary the
    /// returned sample will be the sample exactly on the sample time, or if no such is
    /// available, the immediately preceding sample. If no time is specified for a
    /// sample, the first data will be returned.
    ///
    /// An asset's bounding box can be queried without traversing the hierarchy of
    /// objects.
    ///
    /// Fast enumeration of an MDLAsset iterates the top level objects contained within.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLAsset;
);

extern_conformance!(
    unsafe impl NSCopying for MDLAsset {}
);

unsafe impl CopyingHelper for MDLAsset {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSFastEnumeration for MDLAsset {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLAsset {}
);

impl MDLAsset {
    extern_methods!(
        /// Initialize an MDLAsset using the contents of the resource located at
        /// the indicated URL
        ///
        /// Vertex layout (i.e. vertexDescriptor) will be specified by ModelIO
        /// depending on attributes of the resource.  Buffers will be allocated
        /// using a default NSData based allocator
        ///
        /// Submeshes will be converted to triangle topology.
        #[unsafe(method(initWithURL:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL(this: Allocated<Self>, url: &NSURL) -> Retained<Self>;

        #[cfg(all(feature = "MDLMeshBuffer", feature = "MDLVertexDescriptor"))]
        /// Initialize an MDLAsset using the contents of the resource located at
        /// URL, ensuring that the asset conforms to the supplied vertexDescriptor,
        /// and buffers are allocated in the supplied allocator
        ///
        ///
        /// The default behavior is to triangulate any discovered meshes and to
        /// conform the mesh to the supplied vertexDescriptor.
        ///
        /// If nil is passed as the vertexDescriptor, then a vertexDescriptor
        /// will be created according to the attributes of the resource.
        ///
        /// If nil is passed as the bufferAllocator, buffers will be allocated
        /// using a default NSData based allocator.
        ///
        /// Submeshes will be converted to triangle topology.
        #[unsafe(method(initWithURL:vertexDescriptor:bufferAllocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_vertexDescriptor_bufferAllocator(
            this: Allocated<Self>,
            url: Option<&NSURL>,
            vertex_descriptor: Option<&MDLVertexDescriptor>,
            buffer_allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[cfg(feature = "MDLMeshBuffer")]
        /// Initialize an empty MDLAsset with a buffer allocator to be used during
        /// other operations.
        #[unsafe(method(initWithBufferAllocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBufferAllocator(
            this: Allocated<Self>,
            buffer_allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "MDLMeshBuffer", feature = "MDLVertexDescriptor"))]
        /// Same as initWithURL:vertexDescriptor:bufferAllocator: except that
        /// if preserveTopology is YES, a topology buffer might be created on the
        /// submeshes.
        ///
        ///
        /// If all faces in a submesh have the same vertex count, then the
        /// submesh will a geometry type corresponding to that vertex count.
        /// For example, if all faces have four vertices, then the geometry
        /// type will be MDLGeometryTypeQuads. If faces have a varying number
        /// of vertices, then the the submesh type will be
        /// MDLGeometryTypeVariableTopology, and a faceTopologyBuffer will be
        /// created.
        #[unsafe(method(initWithURL:vertexDescriptor:bufferAllocator:preserveTopology:error:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_vertexDescriptor_bufferAllocator_preserveTopology_error(
            this: Allocated<Self>,
            url: &NSURL,
            vertex_descriptor: Option<&MDLVertexDescriptor>,
            buffer_allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
            preserve_topology: bool,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> Retained<Self>;

        /// Export an asset to the specified URL.
        ///
        /// Returns: YES is returned if exporting proceeded successfully,
        #[unsafe(method(exportAssetToURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn exportAssetToURL(&self, url: &NSURL) -> bool;

        /// Export an asset to the specified URL.
        ///
        /// Returns: YES is returned if exporting proceeded successfully,
        #[unsafe(method(exportAssetToURL:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn exportAssetToURL_error(&self, url: &NSURL) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "MDLObject")]
        /// Return the object at the specified path, or nil if none exists there
        #[unsafe(method(objectAtPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAtPath(&self, path: &NSString) -> Retained<MDLObject>;

        /// Indicates whether MDLAsset object can be initialized with resource
        /// with the given extension
        ///
        /// Returns: YES is returned if MDLAsset is able to load and represent assets with
        /// the given extension
        #[unsafe(method(canImportFileExtension:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canImportFileExtension(extension: &NSString) -> bool;

        /// Indicates whether MDLAsset object can export asset to resource with
        /// the given extension
        ///
        /// Returns: YES is returned if MDLAsset is able is able to export assets to
        /// resources with the given extension
        #[unsafe(method(canExportFileExtension:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canExportFileExtension(extension: &NSString) -> bool;

        #[cfg(feature = "MDLObject")]
        /// Inspects an asset's hierarchy for objects of the specified class type
        ///
        /// Returns: returns an NSArray of all objects in the asset matching the requested class
        ///
        /// This can be used to get references to all MDLMesh objects, MDLLights,
        /// etc. if objectClass is not a subclass of MDLObject, an exception will be
        /// raised.
        ///
        /// # Safety
        ///
        /// `object_class` probably has further requirements.
        #[unsafe(method(childObjectsOfClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn childObjectsOfClass(
            &self,
            object_class: &AnyClass,
        ) -> Retained<NSArray<MDLObject>>;

        /// Iterates over all material properties on all materials. If they are string
        /// values or NSURL values, and can be resolved as textures, then the string
        /// and NSURL values will be replaced by MDLTextureSampler values.
        #[unsafe(method(loadTextures))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTextures(&self);

        /// Inherent frame rate of an asset
        ///
        /// If no framerate was specified by resource or resource uncapable of
        /// specifying framerate, this value defaults to 0
        #[unsafe(method(frameInterval))]
        #[unsafe(method_family = none)]
        pub unsafe fn frameInterval(&self) -> NSTimeInterval;

        /// Setter for [`frameInterval`][Self::frameInterval].
        #[unsafe(method(setFrameInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFrameInterval(&self, frame_interval: NSTimeInterval);

        /// Start time bracket of animation data
        ///
        /// If no animation data was specified by resource or resource incapable
        /// of specifying animation data, this value defaults to 0. If startTime
        /// was set explicitly, then the value of startTime will be the lesser
        /// of the set value and the animated values.
        #[unsafe(method(startTime))]
        #[unsafe(method_family = none)]
        pub unsafe fn startTime(&self) -> NSTimeInterval;

        /// Setter for [`startTime`][Self::startTime].
        #[unsafe(method(setStartTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStartTime(&self, start_time: NSTimeInterval);

        /// End time bracket of animation data
        ///
        /// If no animation data was specified by resource or resource incapable
        /// of specifying animation data, this value defaults to 0. If the
        /// endTime was set explicitly, then the value of endTime will be the
        /// greater of the set value and the animated values.
        #[unsafe(method(endTime))]
        #[unsafe(method_family = none)]
        pub unsafe fn endTime(&self) -> NSTimeInterval;

        /// Setter for [`endTime`][Self::endTime].
        #[unsafe(method(setEndTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEndTime(&self, end_time: NSTimeInterval);

        /// URL used to create the asset
        ///
        /// If the asset was not created with a URL, nil will be returned.
        #[unsafe(method(URL))]
        #[unsafe(method_family = none)]
        pub unsafe fn URL(&self) -> Option<Retained<NSURL>>;

        #[cfg(feature = "MDLAssetResolver")]
        /// Resolver asset that helps find associated files
        ///
        /// The default asset resolver is the RelativeAssetResolver
        #[unsafe(method(resolver))]
        #[unsafe(method_family = none)]
        pub unsafe fn resolver(&self) -> Option<Retained<ProtocolObject<dyn MDLAssetResolver>>>;

        #[cfg(feature = "MDLAssetResolver")]
        /// Setter for [`resolver`][Self::resolver].
        #[unsafe(method(setResolver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setResolver(&self, resolver: Option<&ProtocolObject<dyn MDLAssetResolver>>);

        #[cfg(feature = "MDLMeshBuffer")]
        /// Allocator used to create vertex and index buffers
        #[unsafe(method(bufferAllocator))]
        #[unsafe(method_family = none)]
        pub unsafe fn bufferAllocator(
            &self,
        ) -> Retained<ProtocolObject<dyn MDLMeshBufferAllocator>>;

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Vertex descriptor set upon asset initialization
        ///
        /// Will be nil if there was no descriptor set
        #[unsafe(method(vertexDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexDescriptor(&self) -> Option<Retained<MDLVertexDescriptor>>;

        #[cfg(feature = "MDLObject")]
        /// Add a top level object to an asset.
        ///
        /// If the object was already in the asset, this has no effect.
        #[unsafe(method(addObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addObject(&self, object: &MDLObject);

        #[cfg(feature = "MDLObject")]
        /// Remove a top level object from an asset.
        ///
        /// If the object not in the asset, this has no effect.
        #[unsafe(method(removeObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObject(&self, object: &MDLObject);

        /// The number of top level objects
        #[unsafe(method(count))]
        #[unsafe(method_family = none)]
        pub unsafe fn count(&self) -> NSUInteger;

        #[cfg(feature = "MDLObject")]
        /// return the indexed top level object
        #[unsafe(method(objectAtIndexedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAtIndexedSubscript(
            &self,
            index: NSUInteger,
        ) -> Option<Retained<MDLObject>>;

        #[cfg(feature = "MDLObject")]
        /// return the indexed top level object
        #[unsafe(method(objectAtIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAtIndex(&self, index: NSUInteger) -> Retained<MDLObject>;

        #[cfg(feature = "MDLTypes")]
        #[deprecated]
        #[unsafe(method(masters))]
        #[unsafe(method_family = none)]
        pub unsafe fn masters(&self) -> Retained<ProtocolObject<dyn MDLObjectContainerComponent>>;

        #[cfg(feature = "MDLTypes")]
        /// Setter for [`masters`][Self::masters].
        #[deprecated]
        #[unsafe(method(setMasters:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMasters(&self, masters: &ProtocolObject<dyn MDLObjectContainerComponent>);

        #[cfg(feature = "MDLTypes")]
        /// Original objects that can be instanced into the asset's object hierarchy
        ///
        /// See: MDLObjectContainerComponent
        #[unsafe(method(originals))]
        #[unsafe(method_family = none)]
        pub unsafe fn originals(&self)
            -> Retained<ProtocolObject<dyn MDLObjectContainerComponent>>;

        #[cfg(feature = "MDLTypes")]
        /// Setter for [`originals`][Self::originals].
        #[unsafe(method(setOriginals:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOriginals(
            &self,
            originals: &ProtocolObject<dyn MDLObjectContainerComponent>,
        );

        #[cfg(feature = "MDLTypes")]
        /// Animations that can be bound to MDLObjects (
        ///
        /// See: MDLAnimationBindComponent)
        ///
        /// See: MDLObjectContainerComponent
        #[unsafe(method(animations))]
        #[unsafe(method_family = none)]
        pub unsafe fn animations(
            &self,
        ) -> Retained<ProtocolObject<dyn MDLObjectContainerComponent>>;

        #[cfg(feature = "MDLTypes")]
        /// Setter for [`animations`][Self::animations].
        #[unsafe(method(setAnimations:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAnimations(
            &self,
            animations: &ProtocolObject<dyn MDLObjectContainerComponent>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLAsset {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Adopt this protocol to provide information for use in automatic placement of light probes around a scene.
    ///
    /// ## Overview
    ///
    /// The [`MDLAsset`](https://developer.apple.com/documentation/modelio/mdlasset) [`placeLightProbesWithDensity:heuristic:usingIrradianceDataSource:`](https://developer.apple.com/documentation/modelio/mdlasset/placelightprobes(withdensity:heuristic:using:)) method automatically creates [`MDLLightProbe`](https://developer.apple.com/documentation/modelio/mdllightprobe) objects, setting their positions and lighting parameters to provide optimal light probe coverage within a scene you define. When you use that method, you must provide an object implementing this protocol, which Model I/O queries in order to evaluate your scene.
    ///
    ///
    pub unsafe trait MDLLightProbeIrradianceDataSource: NSObjectProtocol {
        /// Spherical harmonics level used to calculate the spherical harmonics coefficients.
        #[optional]
        #[unsafe(method(sphericalHarmonicsLevel))]
        #[unsafe(method_family = none)]
        unsafe fn sphericalHarmonicsLevel(&self) -> NSUInteger;

        /// Setter for [`sphericalHarmonicsLevel`][Self::sphericalHarmonicsLevel].
        #[optional]
        #[unsafe(method(setSphericalHarmonicsLevel:))]
        #[unsafe(method_family = none)]
        unsafe fn setSphericalHarmonicsLevel(&self, spherical_harmonics_level: NSUInteger);
    }
);

/// MDLLightBaking.
///
/// Given a light probe density, method places light probes in the scene according to the
/// passed in placement heuristic type. The higher the density, the greater the number of
/// light probes placed in the scene.
///
/// Using the placement heuristic MDLProbePlacementUniformGrid places the light probes in the
/// scene as a uniform grid. The placement heuristic MDLProbePlacementIrradianceDistribution
/// places the light probes in areas of greatest irradiance change.
impl MDLAsset {
    extern_methods!(
        #[cfg(all(feature = "MDLLight", feature = "MDLObject", feature = "MDLTypes"))]
        #[unsafe(method(placeLightProbesWithDensity:heuristic:usingIrradianceDataSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn placeLightProbesWithDensity_heuristic_usingIrradianceDataSource(
            value: c_float,
            r#type: MDLProbePlacement,
            data_source: &ProtocolObject<dyn MDLLightProbeIrradianceDataSource>,
        ) -> Retained<NSArray<MDLLightProbe>>;
    );
}
