//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
use objc2_foundation::*;

use crate::*;

/// Options for the shape and style of illumination provided by a light, used by the [`lightType`](https://developer.apple.com/documentation/modelio/mdllight/lighttype) property.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MDLLightType(pub NSUInteger);
impl MDLLightType {
    /// The type of the light is unknown or has not been initialized.
    #[doc(alias = "MDLLightTypeUnknown")]
    pub const Unknown: Self = Self(0);
    /// The light source should illuminate a scene evenly regardless of position or direction.
    #[doc(alias = "MDLLightTypeAmbient")]
    pub const Ambient: Self = Self(1);
    /// The light source illuminates a scene from a uniform direction regardless of its position.
    #[doc(alias = "MDLLightTypeDirectional")]
    pub const Directional: Self = Self(2);
    /// The light source illuminates a scene from a specific position and direction.
    #[doc(alias = "MDLLightTypeSpot")]
    pub const Spot: Self = Self(3);
    /// The light source illuminates a scene in all directions from a specific position.
    #[doc(alias = "MDLLightTypePoint")]
    pub const Point: Self = Self(4);
    /// The light source illuminates a scene in all directions from an area in the shape of a line.
    ///
    /// ## Discussion
    ///
    /// This light type is exclusive to the [`MDLAreaLight`](https://developer.apple.com/documentation/modelio/mdlarealight) class.
    ///
    ///
    #[doc(alias = "MDLLightTypeLinear")]
    pub const Linear: Self = Self(5);
    /// The light source illuminates a scene in all directions from an area in the shape of a disc.
    ///
    /// ## Discussion
    ///
    /// This light type is exclusive to the [`MDLAreaLight`](https://developer.apple.com/documentation/modelio/mdlarealight) class.
    ///
    ///
    #[doc(alias = "MDLLightTypeDiscArea")]
    pub const DiscArea: Self = Self(6);
    /// The light source illuminates a scene in all directions from an area in the shape of a rectangle.
    ///
    /// ## Discussion
    ///
    /// This light type is exclusive to the [`MDLAreaLight`](https://developer.apple.com/documentation/modelio/mdlarealight) class.
    ///
    ///
    #[doc(alias = "MDLLightTypeRectangularArea")]
    pub const RectangularArea: Self = Self(7);
    /// The light source illuminates a scene in all directions from an area in the shape of a superellipse.
    ///
    /// ## Discussion
    ///
    /// A superellipse is a two-dimensional curve that varies in shape between a four-point star, diamond, circle, or rounded rectangle depending on additional parameters. This light type is exclusive to the [`MDLAreaLight`](https://developer.apple.com/documentation/modelio/mdlarealight) class.
    ///
    ///
    #[doc(alias = "MDLLightTypeSuperElliptical")]
    pub const SuperElliptical: Self = Self(8);
    /// The illumination from the light is determined by a photometric profile.
    ///
    /// ## Discussion
    ///
    /// This light type is exclusive to the [`MDLPhotometricLight`](https://developer.apple.com/documentation/modelio/mdlphotometriclight) class.
    ///
    ///
    #[doc(alias = "MDLLightTypePhotometric")]
    pub const Photometric: Self = Self(9);
    /// The illumination from the light is determined by texture images representing a sample of a scene at a specific point.
    ///
    /// ## Discussion
    ///
    /// This light type is exclusive to the [`MDLLightProbe`](https://developer.apple.com/documentation/modelio/mdllightprobe) class.
    ///
    ///
    #[doc(alias = "MDLLightTypeProbe")]
    pub const Probe: Self = Self(10);
    /// The illumination from the light is determined by texture images representing a sample of the surrounding environment for a scene.
    #[doc(alias = "MDLLightTypeEnvironment")]
    pub const Environment: Self = Self(11);
}

unsafe impl Encode for MDLLightType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MDLLightType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The abstract superclass for objects that describe light sources in a scene.
    ///
    /// ## Overview
    ///
    /// When you load lights from an asset file using the [`MDLAsset`](https://developer.apple.com/documentation/modelio/mdlasset) class or create lights when building an asset for export, you use one or more of the concrete subclasses [`MDLPhysicallyPlausibleLight`](https://developer.apple.com/documentation/modelio/mdlphysicallyplausiblelight), [`MDLAreaLight`](https://developer.apple.com/documentation/modelio/mdlarealight), [`MDLPhotometricLight`](https://developer.apple.com/documentation/modelio/mdlphotometriclight), or [`MDLLightProbe`](https://developer.apple.com/documentation/modelio/mdllightprobe).
    ///
    ///
    #[unsafe(super(MDLObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MDLObject")]
    pub struct MDLLight;
);

#[cfg(all(feature = "MDLObject", feature = "MDLTypes"))]
extern_conformance!(
    unsafe impl MDLNamed for MDLLight {}
);

#[cfg(feature = "MDLObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for MDLLight {}
);

#[cfg(feature = "MDLObject")]
impl MDLLight {
    extern_methods!(
        #[unsafe(method(lightType))]
        #[unsafe(method_family = none)]
        pub unsafe fn lightType(&self) -> MDLLightType;

        /// Setter for [`lightType`][Self::lightType].
        #[unsafe(method(setLightType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLightType(&self, light_type: MDLLightType);

        #[unsafe(method(colorSpace))]
        #[unsafe(method_family = none)]
        pub unsafe fn colorSpace(&self) -> Retained<NSString>;

        /// Setter for [`colorSpace`][Self::colorSpace].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setColorSpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setColorSpace(&self, color_space: &NSString);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "MDLObject")]
impl MDLLight {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A light source for use in shading models based on real-world physics.
    /// A light with characteristics representing plausible real world lights
    ///
    ///
    ///
    ///
    ///
    /// quadratically attenuates to zero.
    ///
    /// light is maximally bright.
    #[unsafe(super(MDLLight, MDLObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MDLObject")]
    pub struct MDLPhysicallyPlausibleLight;
);

#[cfg(all(feature = "MDLObject", feature = "MDLTypes"))]
extern_conformance!(
    unsafe impl MDLNamed for MDLPhysicallyPlausibleLight {}
);

#[cfg(feature = "MDLObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for MDLPhysicallyPlausibleLight {}
);

#[cfg(feature = "MDLObject")]
impl MDLPhysicallyPlausibleLight {
    extern_methods!(
        /// Light color specified by color temperature, in degrees Kelvin
        ///
        /// default color is 6500K, cool daylight.
        #[unsafe(method(setColorByTemperature:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setColorByTemperature(&self, temperature: c_float);

        #[cfg(feature = "objc2-core-graphics")]
        #[unsafe(method(color))]
        #[unsafe(method_family = none)]
        pub unsafe fn color(&self) -> Option<Retained<CGColor>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// Setter for [`color`][Self::color].
        #[unsafe(method(setColor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setColor(&self, color: Option<&CGColor>);

        #[unsafe(method(lumens))]
        #[unsafe(method_family = none)]
        pub unsafe fn lumens(&self) -> c_float;

        /// Setter for [`lumens`][Self::lumens].
        #[unsafe(method(setLumens:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLumens(&self, lumens: c_float);

        #[unsafe(method(innerConeAngle))]
        #[unsafe(method_family = none)]
        pub unsafe fn innerConeAngle(&self) -> c_float;

        /// Setter for [`innerConeAngle`][Self::innerConeAngle].
        #[unsafe(method(setInnerConeAngle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInnerConeAngle(&self, inner_cone_angle: c_float);

        #[unsafe(method(outerConeAngle))]
        #[unsafe(method_family = none)]
        pub unsafe fn outerConeAngle(&self) -> c_float;

        /// Setter for [`outerConeAngle`][Self::outerConeAngle].
        #[unsafe(method(setOuterConeAngle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOuterConeAngle(&self, outer_cone_angle: c_float);

        #[unsafe(method(attenuationStartDistance))]
        #[unsafe(method_family = none)]
        pub unsafe fn attenuationStartDistance(&self) -> c_float;

        /// Setter for [`attenuationStartDistance`][Self::attenuationStartDistance].
        #[unsafe(method(setAttenuationStartDistance:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAttenuationStartDistance(&self, attenuation_start_distance: c_float);

        #[unsafe(method(attenuationEndDistance))]
        #[unsafe(method_family = none)]
        pub unsafe fn attenuationEndDistance(&self) -> c_float;

        /// Setter for [`attenuationEndDistance`][Self::attenuationEndDistance].
        #[unsafe(method(setAttenuationEndDistance:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAttenuationEndDistance(&self, attenuation_end_distance: c_float);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "MDLObject")]
impl MDLPhysicallyPlausibleLight {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A light source that illuminates a 3D scene from an area with a specific shape.
    ///
    /// ## Overview
    ///
    /// Unlike other light sources that illuminate a scene from a single point or direction, an area light has a specific shape. The shape of an area light is a two-dimensional figure in the xy-plane of the light’s local coordinate space, and its illumination is directed in the negative z-axis direction (spreading out from that direction according to the inherited [`innerConeAngle`](https://developer.apple.com/documentation/modelio/mdlphysicallyplausiblelight/innerconeangle) and [`outerConeAngle`](https://developer.apple.com/documentation/modelio/mdlphysicallyplausiblelight/outerconeangle) properties).
    ///
    /// Both the [`MDLAreaLight`](https://developer.apple.com/documentation/modelio/mdlarealight) and [`MDLPhotometricLight`](https://developer.apple.com/documentation/modelio/mdlphotometriclight) classes can describe lights with interesting shapes. An area light offers a simpler design that can be implemented with better rendering performance, and a photometric light offers design that better models real-world light fixtures at the cost of higher computational complexity.
    ///
    ///
    #[unsafe(super(MDLPhysicallyPlausibleLight, MDLLight, MDLObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MDLObject")]
    pub struct MDLAreaLight;
);

#[cfg(all(feature = "MDLObject", feature = "MDLTypes"))]
extern_conformance!(
    unsafe impl MDLNamed for MDLAreaLight {}
);

#[cfg(feature = "MDLObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for MDLAreaLight {}
);

#[cfg(feature = "MDLObject")]
impl MDLAreaLight {
    extern_methods!(
        #[unsafe(method(areaRadius))]
        #[unsafe(method_family = none)]
        pub unsafe fn areaRadius(&self) -> c_float;

        /// Setter for [`areaRadius`][Self::areaRadius].
        #[unsafe(method(setAreaRadius:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAreaRadius(&self, area_radius: c_float);

        #[unsafe(method(aspect))]
        #[unsafe(method_family = none)]
        pub unsafe fn aspect(&self) -> c_float;

        /// Setter for [`aspect`][Self::aspect].
        #[unsafe(method(setAspect:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAspect(&self, aspect: c_float);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "MDLObject")]
impl MDLAreaLight {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A light source whose shape, direction, and intensity of illumination are determined by a photometric profile.
    ///
    /// ## Overview
    ///
    /// You create a photometric light from a file in the IES format, containing physical measurements of a light source. Many manufacturers of real-world light fixtures publish such files describing the lighting characteristics of their products. This photometry data measures the light web surrounding a light source—measurements of the light’s intensity in all directions around the source.The [`MDLPhotometricLight`](https://developer.apple.com/documentation/modelio/mdlphotometriclight) provides two ways to interpret a light web:
    ///
    /// - As a cube map texture. Use the [`generateCubemapFromLight:`](https://developer.apple.com/documentation/modelio/mdlphotometriclight/generatecubemap(fromlight:)) method to generate a texture, then use the [`lightCubeMap`](https://developer.apple.com/documentation/modelio/mdlphotometriclight/lightcubemap) property to access the texture. In this texture, each texel represents the light’s intensity in the direction from the cube’s center to the texel’s position on the cube.
    ///
    /// - **As spherical harmonics.** Use the [`generateSphericalHarmonicsFromLight:`](https://developer.apple.com/documentation/modelio/mdlphotometriclight/generatesphericalharmonics(fromlight:)) method to generate a set of spherical harmonic coefficients, and then use the [`sphericalHarmonicsLevel`](https://developer.apple.com/documentation/modelio/mdlphotometriclight/sphericalharmonicslevel) and [`sphericalHarmonicsCoefficients`](https://developer.apple.com/documentation/modelio/mdlphotometriclight/sphericalharmonicscoefficients) properties to access these coefficients. Spherical harmonic coefficients provide a more compact representation of the same information as the cube map texture, so you can use them during shading without the performance cost of a texture lookup.
    ///
    /// Both the [`MDLPhotometricLight`](https://developer.apple.com/documentation/modelio/mdlphotometriclight) and [`MDLAreaLight`](https://developer.apple.com/documentation/modelio/mdlarealight) classes can describe lights with interesting shapes—an area light offers a simpler design that can be implemented with better rendering performance, and a photometric light offers design that better models real-world light fixtures at the cost of higher computational complexity.
    ///
    ///
    /// A light created from measurements at various angles.
    ///
    ///
    /// learn the intensity of the light in that direction.
    ///
    /// used to calculate the spherical harmonics coefficients
    ///
    /// calculated by generateSphericalHarmonicsFromLight:
    #[unsafe(super(MDLPhysicallyPlausibleLight, MDLLight, MDLObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MDLObject")]
    pub struct MDLPhotometricLight;
);

#[cfg(all(feature = "MDLObject", feature = "MDLTypes"))]
extern_conformance!(
    unsafe impl MDLNamed for MDLPhotometricLight {}
);

#[cfg(feature = "MDLObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for MDLPhotometricLight {}
);

#[cfg(feature = "MDLObject")]
impl MDLPhotometricLight {
    extern_methods!(
        #[unsafe(method(initWithIESProfile:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIESProfile(
            this: Allocated<Self>,
            url: &NSURL,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(generateSphericalHarmonicsFromLight:))]
        #[unsafe(method_family = none)]
        pub unsafe fn generateSphericalHarmonicsFromLight(
            &self,
            spherical_harmonics_level: NSUInteger,
        );

        #[unsafe(method(generateCubemapFromLight:))]
        #[unsafe(method_family = none)]
        pub unsafe fn generateCubemapFromLight(&self, texture_size: NSUInteger);

        #[cfg(feature = "MDLTexture")]
        /// Generate an IES compliant MDLTexture
        /// 1D when the number of horizontal angles is one and the innerConeAngle is
        /// <
        /// 180
        /// 2D when the previous statement fails and innerConeAngle
        /// <
        /// 89
        /// 3D in all other cases
        /// the parameter textureSize is the size in pixels of the texture image. For a size of N,
        /// 1D generates an Nx1 image, 2D generates an NxN image, 3D generates an Nx(N*6) image (i.e. cubemap).
        #[unsafe(method(generateTexture:))]
        #[unsafe(method_family = none)]
        pub unsafe fn generateTexture(&self, texture_size: NSUInteger) -> Retained<MDLTexture>;

        #[cfg(feature = "MDLTexture")]
        #[unsafe(method(lightCubeMap))]
        #[unsafe(method_family = none)]
        pub unsafe fn lightCubeMap(&self) -> Option<Retained<MDLTexture>>;

        #[unsafe(method(sphericalHarmonicsLevel))]
        #[unsafe(method_family = none)]
        pub unsafe fn sphericalHarmonicsLevel(&self) -> NSUInteger;

        #[unsafe(method(sphericalHarmonicsCoefficients))]
        #[unsafe(method_family = none)]
        pub unsafe fn sphericalHarmonicsCoefficients(&self) -> Option<Retained<NSData>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "MDLObject")]
impl MDLPhotometricLight {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A light source described in terms of the variations in color and intensity of its illumination in all directions.
    ///
    /// ## Overview
    ///
    /// A light probe represents this variation either as a cube map texture or as a set of spherical harmonic coefficients. In addition to describing such light sources, the [`MDLLightProbe`](https://developer.apple.com/documentation/modelio/mdllightprobe) class provides methods for generating light probe textures based on the contents of a scene and for generating spherical harmonic coefficients from a texture.
    ///
    /// A light probe consists of two cube map textures, where each texel represents the color and intensity of light in a particular direction from the cube’s center:
    ///
    /// - The [`reflectiveTexture`](https://developer.apple.com/documentation/modelio/mdllightprobe/reflectivetexture) cube map, also known as an _environment map_, contains a rendering of a scene as viewed from the light probe’s position. A renderer can use this texture to create reflections on surfaces with metallic materials.
    ///
    /// - The [`irradianceTexture`](https://developer.apple.com/documentation/modelio/mdllightprobe/irradiancetexture) cube map contains samples of the total light arriving at the light probe’s position from every direction. A renderer can use this texture to create diffuse lighting effects. You can derive an irradiance map from an environment map with methods on the [`MDLTexture`](https://developer.apple.com/documentation/modelio/mdltexture) class, or when creating a light probe with the [`lightProbeWithTextureSize:forLocation:lightsToConsider:objectsToConsider:reflectiveCubemap:irradianceCubemap:`](https://developer.apple.com/documentation/modelio/mdllightprobe/init(texturesize:forlocation:lightstoconsider:objectstoconsider:reflectivecubemap:irradiancecubemap:)) method.
    ///
    /// Using cube map textures for light-probe-based rendering offers great visual fidelity, but adversely affects performance due to the cost of texture lookups during rendering. In addition, a cube map texture often contains more detail than is necessary for lighting. A set of spherical harmonic coefficients can represent the same information with less detail, and can be used in shader calculations with much less performance cost. To use spherical harmonics, call the [`generateSphericalHarmonicsFromIrradiance:`](https://developer.apple.com/documentation/modelio/mdllightprobe/generatesphericalharmonics(fromirradiance:)) method, then access the generated data in the [`sphericalHarmonicsCoefficients`](https://developer.apple.com/documentation/modelio/mdllightprobe/sphericalharmonicscoefficients) property.
    ///
    ///
    #[unsafe(super(MDLLight, MDLObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MDLObject")]
    pub struct MDLLightProbe;
);

#[cfg(all(feature = "MDLObject", feature = "MDLTypes"))]
extern_conformance!(
    unsafe impl MDLNamed for MDLLightProbe {}
);

#[cfg(feature = "MDLObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for MDLLightProbe {}
);

#[cfg(feature = "MDLObject")]
impl MDLLightProbe {
    extern_methods!(
        #[cfg(feature = "MDLTexture")]
        #[unsafe(method(initWithReflectiveTexture:irradianceTexture:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithReflectiveTexture_irradianceTexture(
            this: Allocated<Self>,
            reflective_texture: Option<&MDLTexture>,
            irradiance_texture: Option<&MDLTexture>,
        ) -> Retained<Self>;

        #[unsafe(method(generateSphericalHarmonicsFromIrradiance:))]
        #[unsafe(method_family = none)]
        pub unsafe fn generateSphericalHarmonicsFromIrradiance(
            &self,
            spherical_harmonics_level: NSUInteger,
        );

        #[cfg(feature = "MDLTexture")]
        #[unsafe(method(reflectiveTexture))]
        #[unsafe(method_family = none)]
        pub unsafe fn reflectiveTexture(&self) -> Option<Retained<MDLTexture>>;

        #[cfg(feature = "MDLTexture")]
        #[unsafe(method(irradianceTexture))]
        #[unsafe(method_family = none)]
        pub unsafe fn irradianceTexture(&self) -> Option<Retained<MDLTexture>>;

        #[unsafe(method(sphericalHarmonicsLevel))]
        #[unsafe(method_family = none)]
        pub unsafe fn sphericalHarmonicsLevel(&self) -> NSUInteger;

        #[unsafe(method(sphericalHarmonicsCoefficients))]
        #[unsafe(method_family = none)]
        pub unsafe fn sphericalHarmonicsCoefficients(&self) -> Option<Retained<NSData>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "MDLObject")]
impl MDLLightProbe {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// MDLLightBaking.
#[cfg(feature = "MDLObject")]
impl MDLLightProbe {
    extern_methods!(
        #[cfg(all(feature = "MDLTexture", feature = "MDLTransform"))]
        #[unsafe(method(lightProbeWithTextureSize:forLocation:lightsToConsider:objectsToConsider:reflectiveCubemap:irradianceCubemap:))]
        #[unsafe(method_family = none)]
        pub unsafe fn lightProbeWithTextureSize_forLocation_lightsToConsider_objectsToConsider_reflectiveCubemap_irradianceCubemap(
            texture_size: NSInteger,
            transform: &MDLTransform,
            lights_to_consider: &NSArray<MDLLight>,
            objects_to_consider: &NSArray<MDLObject>,
            reflective_cubemap: Option<&MDLTexture>,
            irradiance_cubemap: Option<&MDLTexture>,
        ) -> Option<Retained<MDLLightProbe>>;
    );
}
