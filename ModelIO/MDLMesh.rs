//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// convenience object to quickly access vertex attribute data
    ///
    /// created by MDLMesh's vertexAttributeData selector
    /// Setting values on this object has no effect on the
    /// underlying objects.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlvertexattributedata?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MDLVertexAttributeData;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MDLVertexAttributeData {}
);

impl MDLVertexAttributeData {
    extern_methods!(
        #[cfg(feature = "MDLMeshBuffer")]
        #[unsafe(method(map))]
        #[unsafe(method_family = none)]
        pub unsafe fn map(&self) -> Retained<MDLMeshBufferMap>;

        #[cfg(feature = "MDLMeshBuffer")]
        /// Setter for [`map`][Self::map].
        #[unsafe(method(setMap:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMap(&self, map: &MDLMeshBufferMap);

        #[unsafe(method(dataStart))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataStart(&self) -> NonNull<c_void>;

        /// Setter for [`dataStart`][Self::dataStart].
        ///
        /// # Safety
        ///
        /// `data_start` must be a valid pointer.
        #[unsafe(method(setDataStart:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDataStart(&self, data_start: NonNull<c_void>);

        #[unsafe(method(stride))]
        #[unsafe(method_family = none)]
        pub unsafe fn stride(&self) -> NSUInteger;

        /// Setter for [`stride`][Self::stride].
        #[unsafe(method(setStride:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStride(&self, stride: NSUInteger);

        #[cfg(feature = "MDLVertexDescriptor")]
        #[unsafe(method(format))]
        #[unsafe(method_family = none)]
        pub unsafe fn format(&self) -> MDLVertexFormat;

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Setter for [`format`][Self::format].
        #[unsafe(method(setFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFormat(&self, format: MDLVertexFormat);

        #[unsafe(method(bufferSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn bufferSize(&self) -> NSUInteger;

        /// Setter for [`bufferSize`][Self::bufferSize].
        #[unsafe(method(setBufferSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBufferSize(&self, buffer_size: NSUInteger);
    );
}

/// Methods declared on superclass `NSObject`.
impl MDLVertexAttributeData {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A vertex buffer with info to interpret vertex data
    ///
    /// Includes a collection of submeshs which have indexbuffer and
    /// material information
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/modelio/mdlmesh?language=objc)
    #[unsafe(super(MDLObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "MDLObject")]
    pub struct MDLMesh;
);

#[cfg(all(feature = "MDLObject", feature = "MDLTypes"))]
extern_conformance!(
    unsafe impl MDLNamed for MDLMesh {}
);

#[cfg(feature = "MDLObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for MDLMesh {}
);

#[cfg(feature = "MDLObject")]
impl MDLMesh {
    extern_methods!(
        #[cfg(feature = "MDLMeshBuffer")]
        /// Initialize a mesh with an allocator
        ///
        /// Returns: An empty mesh
        #[unsafe(method(initWithBufferAllocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBufferAllocator(
            this: Allocated<Self>,
            buffer_allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "MDLMeshBuffer",
            feature = "MDLSubmesh",
            feature = "MDLVertexDescriptor"
        ))]
        /// Initialize object with a vertex buffer and a collection of submeshes
        ///
        /// Returns: Initialized mesh or nil if descriptor's layout array does not describe
        /// a single buffer
        ///
        /// Parameter `vertexBuffer`: MDLMeshBuffer object containing all vertex data for the mesh
        ///
        /// Parameter `vertexCount`: Number of vertices in the vertexBuffer
        ///
        /// Parameter `descriptor`: VertexDescriptor specifying how to interpret vertex data
        ///
        /// Parameter `submeshes`: Array of submeshes with index buffers referencing vertex data
        /// and/or materials to be applied to mesh
        #[unsafe(method(initWithVertexBuffer:vertexCount:descriptor:submeshes:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithVertexBuffer_vertexCount_descriptor_submeshes(
            this: Allocated<Self>,
            vertex_buffer: &ProtocolObject<dyn MDLMeshBuffer>,
            vertex_count: NSUInteger,
            descriptor: &MDLVertexDescriptor,
            submeshes: &NSArray<MDLSubmesh>,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "MDLMeshBuffer",
            feature = "MDLSubmesh",
            feature = "MDLVertexDescriptor"
        ))]
        /// Initialize object with an array of vertex buffers (Structure of
        /// Arrays) and a collection of submeshes
        ///
        /// Returns: Initialized mesh or nil if descriptor's layout array is incompatible
        /// with vertexBuffers array
        ///
        /// Parameter `vertexCount`: Number of vertices in vertexBuffers
        ///
        /// Parameter `descriptor`: VertexDescriptor specifying how to interpret vertex data
        ///
        /// Parameter `submeshes`: Array of submeshes with index buffers referencing vertex data
        /// and/or materials to be applied to mesh
        ///
        /// Allows initialization with the layout of the vertexBuffers in a
        /// structure-of-arrays form, in other words, non-interleaved vertex attributes
        #[unsafe(method(initWithVertexBuffers:vertexCount:descriptor:submeshes:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithVertexBuffers_vertexCount_descriptor_submeshes(
            this: Allocated<Self>,
            vertex_buffers: &NSArray<ProtocolObject<dyn MDLMeshBuffer>>,
            vertex_count: NSUInteger,
            descriptor: &MDLVertexDescriptor,
            submeshes: &NSArray<MDLSubmesh>,
        ) -> Retained<Self>;

        /// convenience selector to get quick access to vertex attribute data
        ///
        /// the vertex buffer will remain mapped until the MDLVertexAttributeData
        /// is freed.
        #[unsafe(method(vertexAttributeDataForAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexAttributeDataForAttributeNamed(
            &self,
            name: &NSString,
        ) -> Option<Retained<MDLVertexAttributeData>>;

        #[cfg(feature = "MDLVertexDescriptor")]
        /// convenience selector to get quick access to vertex attribute data
        /// reformatted to the requested format if necessary.
        ///
        /// If the desired format has less elements than the source attribute
        /// elements, excess elements will be discarded. If the desired format
        /// has more elements than the source attribute, then the destination
        /// elements will be set to zero.
        /// The vertex buffer will remain mapped until the MDLVertexAttributeData
        /// is freed.
        #[unsafe(method(vertexAttributeDataForAttributeNamed:asFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexAttributeDataForAttributeNamed_asFormat(
            &self,
            name: &NSString,
            format: MDLVertexFormat,
        ) -> Option<Retained<MDLVertexAttributeData>>;

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Immutable vertex descriptor for interpreting data in vertexBuffers
        ///
        /// Setting this applies the new layout in 'vertexBuffers' thus is a
        /// heavyweight operation as structured copies of almost all vertex
        /// buffer data could be made.  Additionally, if the new vertexDescriptor
        /// does not have an attribute in the original vertexDescriptor, that
        /// attribute will be deleted.  If the original vertexDescriptor does
        /// not have an attribute in the new vertexDescriptor, the data for the
        /// added attribute set as the added attribute's initializationValue
        /// property.
        ///
        /// The allocator associated with each original meshbuffer is used to
        /// reallocate the corresponding resultant meshbuffer.
        #[unsafe(method(vertexDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexDescriptor(&self) -> Retained<MDLVertexDescriptor>;

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Setter for [`vertexDescriptor`][Self::vertexDescriptor].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setVertexDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVertexDescriptor(&self, vertex_descriptor: &MDLVertexDescriptor);

        /// Number of vertices in the vertexBuffers
        ///
        /// The size of vertex data in each buffer can be computed by multiplying
        /// this value with the stride of the buffer in the vertexDescriptor's
        /// layout
        #[unsafe(method(vertexCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexCount(&self) -> NSUInteger;

        /// Setter for [`vertexCount`][Self::vertexCount].
        #[unsafe(method(setVertexCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVertexCount(&self, vertex_count: NSUInteger);

        #[cfg(feature = "MDLMeshBuffer")]
        /// Array of buffers containing vertex data
        ///
        /// The vertex buffers in this array are indexed by the vertex descriptor.
        #[unsafe(method(vertexBuffers))]
        #[unsafe(method_family = none)]
        pub unsafe fn vertexBuffers(&self) -> Retained<NSArray<ProtocolObject<dyn MDLMeshBuffer>>>;

        #[cfg(feature = "MDLMeshBuffer")]
        /// Setter for [`vertexBuffers`][Self::vertexBuffers].
        #[unsafe(method(setVertexBuffers:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVertexBuffers(
            &self,
            vertex_buffers: &NSArray<ProtocolObject<dyn MDLMeshBuffer>>,
        );

        #[cfg(feature = "MDLSubmesh")]
        /// Array of submeshes containing an indexbuffer referencing the vertex
        /// data and material to be applied when the mesh is rendered
        #[unsafe(method(submeshes))]
        #[unsafe(method_family = none)]
        pub unsafe fn submeshes(&self) -> Option<Retained<NSMutableArray<MDLSubmesh>>>;

        #[cfg(feature = "MDLSubmesh")]
        /// Setter for [`submeshes`][Self::submeshes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSubmeshes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSubmeshes(&self, submeshes: Option<&NSMutableArray<MDLSubmesh>>);

        #[cfg(feature = "MDLMeshBuffer")]
        /// allocator used to allocate contained mesh buffers
        #[unsafe(method(allocator))]
        #[unsafe(method_family = none)]
        pub unsafe fn allocator(&self) -> Retained<ProtocolObject<dyn MDLMeshBufferAllocator>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "MDLObject")]
impl MDLMesh {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Modifiers.
#[cfg(feature = "MDLObject")]
impl MDLMesh {
    extern_methods!(
        #[cfg(feature = "MDLVertexDescriptor")]
        /// Convenience method to add an attribute
        ///
        /// The mesh's allocator will be used to create storage for the new
        /// attribute.
        #[unsafe(method(addAttributeWithName:format:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAttributeWithName_format(&self, name: &NSString, format: MDLVertexFormat);

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Create a new vertex attribute including an associated buffer with
        /// a copy of the supplied data, and update the vertex descriptor accordingly
        ///
        /// Parameter `name`: The name the attribute can be found by
        ///
        /// Parameter `format`: Format of the data, such as MDLVertexFormatFloat3
        ///
        /// Parameter `type`: The usage of the attribute, such as MDLVertexAttributePosition
        ///
        /// Parameter `data`: Object containing the data to be used in the new vertex buffer
        ///
        /// Parameter `stride`: The increment in bytes from the start of one data entry to
        /// the next.
        #[unsafe(method(addAttributeWithName:format:type:data:stride:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAttributeWithName_format_type_data_stride(
            &self,
            name: &NSString,
            format: MDLVertexFormat,
            r#type: &NSString,
            data: &NSData,
            stride: NSInteger,
        );

        #[cfg(feature = "MDLVertexDescriptor")]
        /// Create a new vertex attribute including an associated buffer with
        /// a copy of the supplied data, and update the vertex descriptor accordingly
        ///
        /// Parameter `name`: The name the attribute can be found by
        ///
        /// Parameter `format`: Format of the data, such as MDLVertexFormatFloat3
        ///
        /// Parameter `type`: The usage of the attribute, such as MDLVertexAttributePosition
        ///
        /// Parameter `data`: Object containing the data to be used in the new vertex buffer
        ///
        /// Parameter `stride`: The increment in bytes from the start of one data entry to
        /// the next.
        ///
        /// Parameter `time`: The time the attribute is to be invoked at.
        ///
        /// Adding an attribute, such as position data, at multiple times will
        /// result in attributes being created for each of those times.
        /// Attributes corresponding to multiple times can be retrieved from
        /// the vertex descriptor.
        #[unsafe(method(addAttributeWithName:format:type:data:stride:time:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAttributeWithName_format_type_data_stride_time(
            &self,
            name: &NSString,
            format: MDLVertexFormat,
            r#type: &NSString,
            data: &NSData,
            stride: NSInteger,
            time: NSTimeInterval,
        );

        /// Calculate and add vertex normal data
        ///
        /// Parameter `attributeName`: Name is the attribute name of vertex normal attribute.  If nil, vertex normals
        /// will be added with the MDLVertexAttributeNormal name string
        ///
        /// Parameter `creaseThreshold`: Threshold of the dot product between the 2 triangles after which
        /// their face normal will be smoothed out. Therefore, a threshold of 0 will
        /// smooth everything and a threshold of 1 won't smooth anything.
        ///
        /// Uses the attribute named MDLVertexAttributePosition to calculate
        /// vertex normals. If the mesh does not have an attribute with
        /// 'attributeName', it will be added, otherwise the attribute name will
        /// be overwritten with vertex normal data. 'vertexDescriptor' will be
        /// updated to reflect the new attribute.
        #[unsafe(method(addNormalsWithAttributeNamed:creaseThreshold:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addNormalsWithAttributeNamed_creaseThreshold(
            &self,
            attribute_name: Option<&NSString>,
            crease_threshold: c_float,
        );

        /// Create a shader basis where the tangent and bitangent span the uv -> object space transform
        ///
        /// Parameter `textureCoordinateAttributeName`: Name of texture coordinates to use in calculations
        ///
        /// Parameter `tangentAttributeName`: Name of vertex tangent attribute.
        ///
        /// Parameter `bitangentAttributeName`: Name of vertex bitangent attribute.
        ///
        /// Uses the attribute named MDLVertexAttributePosition and
        /// textureCoordinateAttributeName to calculate tangent and bitangent
        /// attributes. The mesh's vertexDescriptor will be updated to reflect
        /// the new attributes if necessary. The basis may not be orthogonal; to gaurantee an orthogonal
        /// tangent basis please use addOrthTanBasisForTextureCoordinateAttibuteNamed selector.
        #[unsafe(method(addTangentBasisForTextureCoordinateAttributeNamed:tangentAttributeNamed:bitangentAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTangentBasisForTextureCoordinateAttributeNamed_tangentAttributeNamed_bitangentAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
            tangent_attribute_name: &NSString,
            bitangent_attribute_name: Option<&NSString>,
        );

        /// Create tangents which are orthogonal to the normal
        ///
        /// Parameter `textureCoordinateAttributeName`: texture coordinates to use in calculations
        ///
        /// Parameter `normalAttributeName`: normals to use in calculations
        ///
        /// Parameter `tangentAttributeName`: Name of a four component vertex tangent attribute.
        ///
        /// Uses the attribute named MDLVertexAttributePosition and
        /// textureCoordinateAttributeName and the specified normals to calculate
        /// tangent information. The mesh's vertexDescriptor will be updated to
        /// reflect the new attribute if necessary.
        /// Note that this method does NOT produce a T.w component which is used in B = (N x T) * T.w
        /// Please use addOrthTanBasisForTextureCoordinateAttributeNamed.
        #[unsafe(method(addTangentBasisForTextureCoordinateAttributeNamed:normalAttributeNamed:tangentAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTangentBasisForTextureCoordinateAttributeNamed_normalAttributeNamed_tangentAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
            normal_attribute_name: &NSString,
            tangent_attribute_name: &NSString,
        );

        #[unsafe(method(addOrthTanBasisForTextureCoordinateAttributeNamed:normalAttributeNamed:tangentAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addOrthTanBasisForTextureCoordinateAttributeNamed_normalAttributeNamed_tangentAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
            normal_attribute_name: &NSString,
            tangent_attribute_name: &NSString,
        );

        /// Creates texture coordinates by unwrapping the mesh
        ///
        /// Parameter `textureCoordinateAttributeName`: texture coordinates to modify or create
        ///
        /// Uses the attribute named MDLVertexAttributePosition and if available,
        /// the attribute named MDLVertexAttributeNormal to calculate texture coordinates
        #[unsafe(method(addUnwrappedTextureCoordinatesForAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addUnwrappedTextureCoordinatesForAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
        );

        /// Flips texture coordinates by performing the operation (u,v) = (u, 1-v)
        ///
        /// Parameter `textureCoordinateAttributeName`: texture coordinates to modify
        ///
        /// Many application generate model files with texture coordinate mapping
        /// assuming a bottom left bitmap origin. It can be more convenient to
        /// have texture coordinates corresponding to an upper left bitmap origin.
        /// This selector will perform the flip operation if the requested texture
        /// coordinate attribute exists on the mesh. An exception will be raised if
        /// the attribute cannot be found
        #[unsafe(method(flipTextureCoordinatesInAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn flipTextureCoordinatesInAttributeNamed(
            &self,
            texture_coordinate_attribute_name: &NSString,
        );

        /// Deindexes the vertex array
        ///
        /// If any vertices are shared on multiple faces, duplicate those
        /// vertices so faces do not share vertices. The vertex buffer and index
        /// buffers on submeshes may grow to accomadate any vertices added.
        #[deprecated]
        #[unsafe(method(makeVerticesUnique))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeVerticesUnique(&self);

        /// Deindexes the vertex array
        ///
        /// If any vertices are shared on multiple faces, duplicate those
        /// vertices so faces do not share vertices. The vertex buffer and index
        /// buffers on submeshes may grow to accomadate any vertices added.
        #[unsafe(method(makeVerticesUniqueAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeVerticesUniqueAndReturnError(&self) -> Result<(), Retained<NSError>>;

        /// replace existing attribute data with new attribute data retaining
        /// the format of the replacement data.
        ///
        /// If the specified attribute does not already exist, it will be
        /// created.
        #[unsafe(method(replaceAttributeNamed:withData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn replaceAttributeNamed_withData(
            &self,
            name: &NSString,
            new_data: &MDLVertexAttributeData,
        );

        /// update existing attribute data with new attribute data retaining
        /// the format of the existing data.
        ///
        /// If the specified attribute does not already exist, it will be
        /// created with the same format as the newData.
        #[unsafe(method(updateAttributeNamed:withData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateAttributeNamed_withData(
            &self,
            name: &NSString,
            new_data: &MDLVertexAttributeData,
        );

        /// remove an attribute
        ///
        /// if the named attribute does not exist, nothing happens.
        #[unsafe(method(removeAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAttributeNamed(&self, name: &NSString);
    );
}

/// Generators.
#[cfg(feature = "MDLObject")]
impl MDLMesh {
    extern_methods!(
        #[cfg(feature = "MDLMeshBuffer")]
        /// Factory method that generates a subdivided mesh from a source mesh
        ///
        /// Parameter `mesh`: Mesh from which to generate a subdivided mesh
        ///
        /// Parameter `submeshIndex`: Index of submesh in Mesh's submesh array from which to
        /// generate a subdivided mesh
        ///
        /// Parameter `subdivisionLevels`: The number of levels to subdivide mesh
        ///
        /// Subdivision levels over four are likely to generate more triangles
        /// than can be reasonably displayed. Index and vertex data will use
        /// the same allocator used for the source mesh. Loading an asset
        /// using the topology preservation flag set to YES will result in the
        /// best subdivision results.
        ///
        /// Returns: Returns a mesh subdivided to index level, unless subdivision is
        /// impossible.
        #[unsafe(method(initMeshBySubdividingMesh:submeshIndex:subdivisionLevels:allocator:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initMeshBySubdividingMesh_submeshIndex_subdivisionLevels_allocator(
            this: Allocated<Self>,
            mesh: &MDLMesh,
            submesh_index: c_int,
            subdivision_levels: c_uint,
            allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[cfg(all(feature = "MDLMeshBuffer", feature = "MDLTypes"))]
        #[unsafe(method(newIcosahedronWithRadius:inwardNormals:geometryType:allocator:))]
        #[unsafe(method_family = new)]
        pub unsafe fn newIcosahedronWithRadius_inwardNormals_geometryType_allocator(
            radius: c_float,
            inward_normals: bool,
            geometry_type: MDLGeometryType,
            allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[cfg(feature = "MDLMeshBuffer")]
        #[unsafe(method(newIcosahedronWithRadius:inwardNormals:allocator:))]
        #[unsafe(method_family = new)]
        pub unsafe fn newIcosahedronWithRadius_inwardNormals_allocator(
            radius: c_float,
            inward_normals: bool,
            allocator: Option<&ProtocolObject<dyn MDLMeshBufferAllocator>>,
        ) -> Retained<Self>;

        #[unsafe(method(newSubdividedMesh:submeshIndex:subdivisionLevels:))]
        #[unsafe(method_family = new)]
        pub unsafe fn newSubdividedMesh_submeshIndex_subdivisionLevels(
            mesh: &MDLMesh,
            submesh_index: NSUInteger,
            subdivision_levels: NSUInteger,
        ) -> Option<Retained<Self>>;
    );
}

/// MDLLightBaking.
#[cfg(feature = "MDLObject")]
impl MDLMesh {
    extern_methods!(
        /// Creates an Ambient Occlusion texture, returns true upon success, false
        /// upon failure
        ///
        /// Parameter `bakeQuality`: Float between 0 and 1 that defines quality of the bake process.
        /// 0 is of lower quality but bakes faster and uses less memory, where 1 is
        /// of higher quality.
        ///
        /// Parameter `attenuationFactor`: Float between 0 to 1 that defines how to attenuate the
        /// AO value. 0 doesn't change it, and at 1, all AO values are white except
        /// if they are originally completely black. Quadratic attenuation in between.
        ///
        /// Parameter `objectsToConsider`: NSArray of MDLMeshes containing the objects to raytrace
        /// against
        ///
        /// Parameter `vertexAttributeName`: NSString of the MDLVertexAttribute where the vertex
        /// texture UVs will be stored. Creates it if it doesn't exist, otherwise
        /// overwrites current values.
        ///
        /// Parameter `materialPropertyName`: NSString of the MDLMaterialProperty that will store
        /// the texture in the Mesh.
        ///
        /// Returns: Success or failure of the baking process.
        #[unsafe(method(generateAmbientOcclusionTextureWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn generateAmbientOcclusionTextureWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed_materialPropertyNamed(
            &self,
            bake_quality: c_float,
            attenuation_factor: c_float,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
            material_property_name: &NSString,
        ) -> bool;

        #[unsafe(method(generateAmbientOcclusionVertexColorsWithRaysPerSample:attenuationFactor:objectsToConsider:vertexAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn generateAmbientOcclusionVertexColorsWithRaysPerSample_attenuationFactor_objectsToConsider_vertexAttributeNamed(
            &self,
            rays_per_sample: NSInteger,
            attenuation_factor: c_float,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
        ) -> bool;

        #[unsafe(method(generateAmbientOcclusionVertexColorsWithQuality:attenuationFactor:objectsToConsider:vertexAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn generateAmbientOcclusionVertexColorsWithQuality_attenuationFactor_objectsToConsider_vertexAttributeNamed(
            &self,
            bake_quality: c_float,
            attenuation_factor: c_float,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
        ) -> bool;

        #[cfg(feature = "MDLLight")]
        #[unsafe(method(generateLightMapTextureWithQuality:lightsToConsider:objectsToConsider:vertexAttributeNamed:materialPropertyNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn generateLightMapTextureWithQuality_lightsToConsider_objectsToConsider_vertexAttributeNamed_materialPropertyNamed(
            &self,
            bake_quality: c_float,
            lights_to_consider: &NSArray<MDLLight>,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
            material_property_name: &NSString,
        ) -> bool;

        #[cfg(feature = "MDLLight")]
        #[unsafe(method(generateLightMapVertexColorsWithLightsToConsider:objectsToConsider:vertexAttributeNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn generateLightMapVertexColorsWithLightsToConsider_objectsToConsider_vertexAttributeNamed(
            &self,
            lights_to_consider: &NSArray<MDLLight>,
            objects_to_consider: &NSArray<MDLObject>,
            vertex_attribute_name: &NSString,
        ) -> bool;
    );
}
