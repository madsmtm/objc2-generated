//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// Type of a reference to DASession instances.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/dasession?language=objc)
#[doc(alias = "DASessionRef")]
#[repr(C)]
pub struct DASession {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl DASession {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__DASession"> for DASession {}
);

unsafe impl ConcreteType for DASession {
    /// Returns the type identifier of all DASession instances.
    #[doc(alias = "DASessionGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn DASessionGetTypeID() -> CFTypeID;
        }
        unsafe { DASessionGetTypeID() }
    }
}

impl DASession {
    /// Creates a new session.
    ///
    /// Returns: A reference to a new DASession.
    ///
    /// The caller of this function receives a reference to the returned object.  The
    /// caller also implicitly retains the object and is responsible for releasing it.
    #[doc(alias = "DASessionCreate")]
    #[inline]
    pub unsafe fn new(allocator: Option<&CFAllocator>) -> Option<CFRetained<DASession>> {
        extern "C-unwind" {
            fn DASessionCreate(allocator: Option<&CFAllocator>) -> Option<NonNull<DASession>>;
        }
        let ret = unsafe { DASessionCreate(allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Schedules the session on a run loop.
    ///
    /// Parameter `session`: The session which is being scheduled.
    ///
    /// Parameter `runLoop`: The run loop on which the session should be scheduled.
    ///
    /// Parameter `runLoopMode`: The run loop mode in which the session should be scheduled.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "DASessionScheduleWithRunLoop")]
    #[inline]
    pub unsafe fn schedule_with_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn DASessionScheduleWithRunLoop(
                session: &DASession,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { DASessionScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Unschedules the session from a run loop.
    ///
    /// Parameter `session`: The session which is being unscheduled.
    ///
    /// Parameter `runLoop`: The run loop on which the session is scheduled.
    ///
    /// Parameter `runLoopMode`: The run loop mode in which the session is scheduled.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "DASessionUnscheduleFromRunLoop")]
    #[inline]
    pub unsafe fn unschedule_from_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn DASessionUnscheduleFromRunLoop(
                session: &DASession,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { DASessionUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Schedules the session on a dispatch queue.
    ///
    /// Parameter `session`: The session which is being scheduled.
    ///
    /// Parameter `queue`: The dispatch queue on which the session should be scheduled.  Pass NULL to unschedule.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "DASessionSetDispatchQueue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_dispatch_queue(&self, queue: Option<&DispatchQueue>) {
        extern "C-unwind" {
            fn DASessionSetDispatchQueue(session: &DASession, queue: Option<&DispatchQueue>);
        }
        unsafe { DASessionSetDispatchQueue(self, queue) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/daapprovalsessionref?language=objc)
#[doc(alias = "DAApprovalSessionRef")]
#[repr(C)]
pub struct DAApprovalSession {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl DAApprovalSession {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__DASession"> for DAApprovalSession {}
);

unsafe impl ConcreteType for DAApprovalSession {
    #[doc(alias = "DAApprovalSessionGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn DAApprovalSessionGetTypeID() -> CFTypeID;
        }
        unsafe { DAApprovalSessionGetTypeID() }
    }
}

impl DAApprovalSession {
    #[doc(alias = "DAApprovalSessionCreate")]
    #[inline]
    pub unsafe fn new(allocator: Option<&CFAllocator>) -> Option<CFRetained<DAApprovalSession>> {
        extern "C-unwind" {
            fn DAApprovalSessionCreate(
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<DAApprovalSession>>;
        }
        let ret = unsafe { DAApprovalSessionCreate(allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "DAApprovalSessionScheduleWithRunLoop")]
    #[inline]
    pub unsafe fn schedule_with_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn DAApprovalSessionScheduleWithRunLoop(
                session: &DAApprovalSession,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { DAApprovalSessionScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }

    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "DAApprovalSessionUnscheduleFromRunLoop")]
    #[inline]
    pub unsafe fn unschedule_from_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn DAApprovalSessionUnscheduleFromRunLoop(
                session: &DAApprovalSession,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { DAApprovalSessionUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }
}

#[deprecated = "renamed to `DASession::new`"]
#[inline]
pub unsafe extern "C-unwind" fn DASessionCreate(
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<DASession>> {
    extern "C-unwind" {
        fn DASessionCreate(allocator: Option<&CFAllocator>) -> Option<NonNull<DASession>>;
    }
    let ret = unsafe { DASessionCreate(allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `DASession::schedule_with_run_loop`"]
    pub fn DASessionScheduleWithRunLoop(
        session: &DASession,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `DASession::unschedule_from_run_loop`"]
    pub fn DASessionUnscheduleFromRunLoop(
        session: &DASession,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `DASession::set_dispatch_queue`"]
    pub fn DASessionSetDispatchQueue(session: &DASession, queue: Option<&DispatchQueue>);
}

#[deprecated = "renamed to `DAApprovalSession::new`"]
#[inline]
pub unsafe extern "C-unwind" fn DAApprovalSessionCreate(
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<DAApprovalSession>> {
    extern "C-unwind" {
        fn DAApprovalSessionCreate(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<DAApprovalSession>>;
    }
    let ret = unsafe { DAApprovalSessionCreate(allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `DAApprovalSession::schedule_with_run_loop`"]
    pub fn DAApprovalSessionScheduleWithRunLoop(
        session: &DAApprovalSession,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `DAApprovalSession::unschedule_from_run_loop`"]
    pub fn DAApprovalSessionUnscheduleFromRunLoop(
        session: &DAApprovalSession,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}
