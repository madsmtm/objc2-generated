//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionvolumekindkey?language=objc)
    pub static kDADiskDescriptionVolumeKindKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionvolumemountablekey?language=objc)
    pub static kDADiskDescriptionVolumeMountableKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionvolumenamekey?language=objc)
    pub static kDADiskDescriptionVolumeNameKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionvolumenetworkkey?language=objc)
    pub static kDADiskDescriptionVolumeNetworkKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionvolumepathkey?language=objc)
    pub static kDADiskDescriptionVolumePathKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionvolumetypekey?language=objc)
    pub static kDADiskDescriptionVolumeTypeKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionvolumeuuidkey?language=objc)
    pub static kDADiskDescriptionVolumeUUIDKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediablocksizekey?language=objc)
    pub static kDADiskDescriptionMediaBlockSizeKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediabsdmajorkey?language=objc)
    pub static kDADiskDescriptionMediaBSDMajorKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediabsdminorkey?language=objc)
    pub static kDADiskDescriptionMediaBSDMinorKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediabsdnamekey?language=objc)
    pub static kDADiskDescriptionMediaBSDNameKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediabsdunitkey?language=objc)
    pub static kDADiskDescriptionMediaBSDUnitKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediacontentkey?language=objc)
    pub static kDADiskDescriptionMediaContentKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediaejectablekey?language=objc)
    pub static kDADiskDescriptionMediaEjectableKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediaiconkey?language=objc)
    pub static kDADiskDescriptionMediaIconKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediakindkey?language=objc)
    pub static kDADiskDescriptionMediaKindKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmedialeafkey?language=objc)
    pub static kDADiskDescriptionMediaLeafKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmedianamekey?language=objc)
    pub static kDADiskDescriptionMediaNameKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediapathkey?language=objc)
    pub static kDADiskDescriptionMediaPathKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediaremovablekey?language=objc)
    pub static kDADiskDescriptionMediaRemovableKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediasizekey?language=objc)
    pub static kDADiskDescriptionMediaSizeKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediatypekey?language=objc)
    pub static kDADiskDescriptionMediaTypeKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediauuidkey?language=objc)
    pub static kDADiskDescriptionMediaUUIDKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediawholekey?language=objc)
    pub static kDADiskDescriptionMediaWholeKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediawritablekey?language=objc)
    pub static kDADiskDescriptionMediaWritableKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediaencryptedkey?language=objc)
    pub static kDADiskDescriptionMediaEncryptedKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionmediaencryptiondetailkey?language=objc)
    pub static kDADiskDescriptionMediaEncryptionDetailKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptiondeviceguidkey?language=objc)
    pub static kDADiskDescriptionDeviceGUIDKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptiondeviceinternalkey?language=objc)
    pub static kDADiskDescriptionDeviceInternalKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptiondevicemodelkey?language=objc)
    pub static kDADiskDescriptionDeviceModelKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptiondevicepathkey?language=objc)
    pub static kDADiskDescriptionDevicePathKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptiondeviceprotocolkey?language=objc)
    pub static kDADiskDescriptionDeviceProtocolKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptiondevicerevisionkey?language=objc)
    pub static kDADiskDescriptionDeviceRevisionKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptiondeviceunitkey?language=objc)
    pub static kDADiskDescriptionDeviceUnitKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptiondevicevendorkey?language=objc)
    pub static kDADiskDescriptionDeviceVendorKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptiondevicetdmlockedkey?language=objc)
    pub static kDADiskDescriptionDeviceTDMLockedKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionbusnamekey?language=objc)
    pub static kDADiskDescriptionBusNameKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionbuspathkey?language=objc)
    pub static kDADiskDescriptionBusPathKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionfskitprefix?language=objc)
    pub static kDADiskDescriptionFSKitPrefix: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/kdadiskdescriptionrepairrunningkey?language=objc)
    pub static kDADiskDescriptionRepairRunningKey: &'static CFString;
}

/// Type of a reference to DADisk instances.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/diskarbitration/dadisk?language=objc)
#[repr(C)]
pub struct DADisk {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl DADisk {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__DADisk"> for DADisk {}
);

unsafe impl ConcreteType for DADisk {
    /// Returns the type identifier of all DADisk instances.
    #[doc(alias = "DADiskGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn DADiskGetTypeID() -> CFTypeID;
        }
        unsafe { DADiskGetTypeID() }
    }
}

impl DADisk {
    /// Creates a new disk object.
    ///
    /// Parameter `allocator`: The allocator object to be used to allocate memory.
    ///
    /// Parameter `session`: The DASession in which to contact Disk Arbitration.
    ///
    /// Parameter `name`: The BSD device name.
    ///
    /// Returns: A reference to a new DADisk.
    ///
    /// The caller of this function receives a reference to the returned object.  The
    /// caller also implicitly retains the object and is responsible for releasing it
    /// with CFRelease().
    #[doc(alias = "DADiskCreateFromBSDName")]
    #[cfg(feature = "DASession")]
    #[inline]
    pub unsafe fn from_bsd_name(
        allocator: Option<&CFAllocator>,
        session: &DASession,
        name: NonNull<c_char>,
    ) -> Option<CFRetained<DADisk>> {
        extern "C-unwind" {
            fn DADiskCreateFromBSDName(
                allocator: Option<&CFAllocator>,
                session: &DASession,
                name: NonNull<c_char>,
            ) -> Option<NonNull<DADisk>>;
        }
        let ret = unsafe { DADiskCreateFromBSDName(allocator, session, name) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a new disk object.
    ///
    /// Parameter `allocator`: The allocator object to be used to allocate memory.
    ///
    /// Parameter `session`: The DASession in which to contact Disk Arbitration.
    ///
    /// Parameter `path`: The BSD mount point.
    ///
    /// Returns: A reference to a new DADisk.
    ///
    /// The caller of this function receives a reference to the returned object.  The
    /// caller also implicitly retains the object and is responsible for releasing it
    /// with CFRelease().
    #[doc(alias = "DADiskCreateFromVolumePath")]
    #[cfg(feature = "DASession")]
    #[inline]
    pub unsafe fn from_volume_path(
        allocator: Option<&CFAllocator>,
        session: &DASession,
        path: &CFURL,
    ) -> Option<CFRetained<DADisk>> {
        extern "C-unwind" {
            fn DADiskCreateFromVolumePath(
                allocator: Option<&CFAllocator>,
                session: &DASession,
                path: &CFURL,
            ) -> Option<NonNull<DADisk>>;
        }
        let ret = unsafe { DADiskCreateFromVolumePath(allocator, session, path) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Obtains the BSD device name for the specified disk.
    ///
    /// Parameter `disk`: The DADisk for which to obtain the BSD device name.
    ///
    /// Returns: The disk's BSD device name.
    ///
    /// The BSD device name can be used with opendev() to open the BSD device.
    #[doc(alias = "DADiskGetBSDName")]
    #[inline]
    pub unsafe fn bsd_name(self: &DADisk) -> *const c_char {
        extern "C-unwind" {
            fn DADiskGetBSDName(disk: &DADisk) -> *const c_char;
        }
        unsafe { DADiskGetBSDName(self) }
    }

    /// Obtains the Disk Arbitration description of the specified disk.
    ///
    /// Parameter `disk`: The DADisk for which to obtain the Disk Arbitration description.
    ///
    /// Returns: The disk's Disk Arbitration description.
    ///
    /// This function will contact Disk Arbitration to acquire the latest description
    /// of the specified disk, unless this function is called on a disk object passed
    /// within the context of a registered callback, in which case the description is
    /// current as of that callback event.
    ///
    /// The caller of this function receives a reference to the returned object.  The
    /// caller also implicitly retains the object and is responsible for releasing it
    /// with CFRelease().
    #[doc(alias = "DADiskCopyDescription")]
    #[inline]
    pub unsafe fn description(self: &DADisk) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn DADiskCopyDescription(disk: &DADisk) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { DADiskCopyDescription(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Obtain the associated whole disk object for the specified disk.
    ///
    /// Parameter `disk`: The disk object.
    ///
    /// Returns: The disk's associated whole disk object.
    ///
    /// The caller of this function receives a reference to the returned object.  The
    /// caller also implicitly retains the object and is responsible for releasing it
    /// with CFRelease().
    #[doc(alias = "DADiskCopyWholeDisk")]
    #[inline]
    pub unsafe fn whole_disk(self: &DADisk) -> Option<CFRetained<DADisk>> {
        extern "C-unwind" {
            fn DADiskCopyWholeDisk(disk: &DADisk) -> Option<NonNull<DADisk>>;
        }
        let ret = unsafe { DADiskCopyWholeDisk(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

#[cfg(feature = "DASession")]
#[deprecated = "renamed to `DADisk::from_bsd_name`"]
#[inline]
pub unsafe extern "C-unwind" fn DADiskCreateFromBSDName(
    allocator: Option<&CFAllocator>,
    session: &DASession,
    name: NonNull<c_char>,
) -> Option<CFRetained<DADisk>> {
    extern "C-unwind" {
        fn DADiskCreateFromBSDName(
            allocator: Option<&CFAllocator>,
            session: &DASession,
            name: NonNull<c_char>,
        ) -> Option<NonNull<DADisk>>;
    }
    let ret = unsafe { DADiskCreateFromBSDName(allocator, session, name) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "DASession")]
#[deprecated = "renamed to `DADisk::from_volume_path`"]
#[inline]
pub unsafe extern "C-unwind" fn DADiskCreateFromVolumePath(
    allocator: Option<&CFAllocator>,
    session: &DASession,
    path: &CFURL,
) -> Option<CFRetained<DADisk>> {
    extern "C-unwind" {
        fn DADiskCreateFromVolumePath(
            allocator: Option<&CFAllocator>,
            session: &DASession,
            path: &CFURL,
        ) -> Option<NonNull<DADisk>>;
    }
    let ret = unsafe { DADiskCreateFromVolumePath(allocator, session, path) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `DADisk::bsd_name`"]
    pub fn DADiskGetBSDName(disk: &DADisk) -> *const c_char;
}

#[deprecated = "renamed to `DADisk::description`"]
#[inline]
pub unsafe extern "C-unwind" fn DADiskCopyDescription(
    disk: &DADisk,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn DADiskCopyDescription(disk: &DADisk) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { DADiskCopyDescription(disk) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `DADisk::whole_disk`"]
#[inline]
pub unsafe extern "C-unwind" fn DADiskCopyWholeDisk(disk: &DADisk) -> Option<CFRetained<DADisk>> {
    extern "C-unwind" {
        fn DADiskCopyWholeDisk(disk: &DADisk) -> Option<NonNull<DADisk>>;
    }
    let ret = unsafe { DADiskCopyWholeDisk(disk) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
