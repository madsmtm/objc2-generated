//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// The scope where all the operations defined in this block get control-dependency operations.
///
/// - Returns: A valid tensor with the results forwarded to the return of `controlDependency` call.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshadersgraph/mpsgraphcontrolflowdependencyblock?language=objc)
#[cfg(all(
    feature = "MPSGraphCore",
    feature = "MPSGraphTensor",
    feature = "block2"
))]
pub type MPSGraphControlFlowDependencyBlock =
    *mut block2::DynBlock<dyn Fn() -> NonNull<NSArray<MPSGraphTensor>>>;

/// A block of operations executed under either the if or else condition.
///
/// - Returns: Tensors returned by user. If not empty, the user must define both the then and else blocks,
/// both should have the same number of arguments, and each corresponding argument should have the same element types.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshadersgraph/mpsgraphifthenelseblock?language=objc)
#[cfg(all(
    feature = "MPSGraphCore",
    feature = "MPSGraphTensor",
    feature = "block2"
))]
pub type MPSGraphIfThenElseBlock =
    *mut block2::DynBlock<dyn Fn() -> NonNull<NSArray<MPSGraphTensor>>>;

/// The block that executes before the condition evaluates for each iteration.
///
/// - Parameters:
/// - inputTensors: Input tensors to the `whileConditionBlock`, for the first iteration will be same as initialInputs passed to the while loop.
/// - resultTensors: A valid `MPSGraphTensor` array with results forwarded to after block or returned from the while loop depending on the predicate tensor. It will be empty and the caller block should fill it up before returning.
/// - Returns: Tensor MUST be set and have a single scalar value, used to decide between executing the body block or returning from the while loop.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshadersgraph/mpsgraphwhilebeforeblock?language=objc)
#[cfg(all(
    feature = "MPSGraphCore",
    feature = "MPSGraphTensor",
    feature = "block2"
))]
pub type MPSGraphWhileBeforeBlock = *mut block2::DynBlock<
    dyn Fn(
        NonNull<NSArray<MPSGraphTensor>>,
        NonNull<NSMutableArray<MPSGraphTensor>>,
    ) -> NonNull<MPSGraphTensor>,
>;

/// The block that executes after the condition evaluates for each iteration.
///
/// - Parameters:
/// - bodyBlockArguments: Inputs to the body of the while loop passed by the condition block return, and should be the same element types as the return of the while loop.
/// - Returns: A valid `MPSGraphTensor` array with results forwarded to the condition block.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshadersgraph/mpsgraphwhileafterblock?language=objc)
#[cfg(all(
    feature = "MPSGraphCore",
    feature = "MPSGraphTensor",
    feature = "block2"
))]
pub type MPSGraphWhileAfterBlock = *mut block2::DynBlock<
    dyn Fn(NonNull<NSArray<MPSGraphTensor>>) -> NonNull<NSArray<MPSGraphTensor>>,
>;

/// A block for the body in the for loop.
///
/// - Parameters:
/// - index: The for loop index per iteration, it is a scalar tensor.
/// - iterationArguments: Arguments for this iteration, with the same count and corresponding element types as `initialIterationArguments` and return types of the `for` loop.
/// - Returns: A valid MPSGraphTensor array with same count and corresponding element types as `initialIterationArguments` and return types of the `for` loop.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshadersgraph/mpsgraphforloopbodyblock?language=objc)
#[cfg(all(
    feature = "MPSGraphCore",
    feature = "MPSGraphTensor",
    feature = "block2"
))]
pub type MPSGraphForLoopBodyBlock = *mut block2::DynBlock<
    dyn Fn(
        NonNull<MPSGraphTensor>,
        NonNull<NSArray<MPSGraphTensor>>,
    ) -> NonNull<NSArray<MPSGraphTensor>>,
>;

/// MPSGraphControlFlowOps.
#[cfg(all(feature = "MPSGraph", feature = "MPSGraphCore"))]
impl MPSGraph {
    extern_methods!(
        #[cfg(all(
            feature = "MPSGraphOperation",
            feature = "MPSGraphTensor",
            feature = "block2"
        ))]
        /// Runs the graph for the given feeds and returns the target tensor values, ensuring all target operations also executed.
        ///
        /// This call blocks until execution has completed.
        ///
        /// - Parameters:
        /// - operations: Operations maked as control dependency for all ops created inside the dependent block
        /// - dependentBlock: MPSGraphControlFlowDependencyBlock which is provided by caller to create dependent ops
        /// - name: name of scope
        /// - Returns: A valid MPSGraphTensor array with results returned from dependentBlock forwarded
        ///
        /// # Safety
        ///
        /// `dependent_block` must be a valid pointer.
        #[unsafe(method(controlDependencyWithOperations:dependentBlock:name:))]
        #[unsafe(method_family = none)]
        pub unsafe fn controlDependencyWithOperations_dependentBlock_name(
            &self,
            operations: &NSArray<MPSGraphOperation>,
            dependent_block: MPSGraphControlFlowDependencyBlock,
            name: Option<&NSString>,
        ) -> Retained<NSArray<MPSGraphTensor>>;

        #[cfg(all(feature = "MPSGraphTensor", feature = "block2"))]
        /// Adds an if-then-else operation to the graph.
        ///
        /// - Parameters:
        /// - predicateTensor: Tensor must have a single scalar value, used to decide between then/else branches
        /// - thenBlock: If predicate is true operations in this block are executed
        /// - elseBlock: If predicate is false operations in this block are executed
        /// - name: name of operation
        /// - Returns: results If no error, the tensors returned by user. If not empty, user must define both then/else block,
        /// both should have same number of arguments and each corresponding argument should have same elementTypes.
        ///
        /// # Safety
        ///
        /// - `then_block` must be a valid pointer.
        /// - `else_block` must be a valid pointer or null.
        #[unsafe(method(ifWithPredicateTensor:thenBlock:elseBlock:name:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ifWithPredicateTensor_thenBlock_elseBlock_name(
            &self,
            predicate_tensor: &MPSGraphTensor,
            then_block: MPSGraphIfThenElseBlock,
            else_block: MPSGraphIfThenElseBlock,
            name: Option<&NSString>,
        ) -> Retained<NSArray<MPSGraphTensor>>;

        #[cfg(all(feature = "MPSGraphTensor", feature = "block2"))]
        /// Adds a while loop operation.
        ///
        /// - Parameters:
        /// - initialInputs: inputTensors to the `beforeBlock`, for the 1st iteration will be same as initialInputs passed to the while loop.
        /// - before: `beforeBlock`, this will be run first and then call the `afterBlock` with results or return results from the loop.
        /// - after: `afterBlock`, this will execute after the condition evaluation.
        /// - name: name of operation.
        /// - Returns: A valid MPSGraphTensor array with results returned from the conditionBlock depending on the predicate tensor.
        ///
        /// # Safety
        ///
        /// - `before` must be a valid pointer.
        /// - `after` must be a valid pointer.
        #[unsafe(method(whileWithInitialInputs:before:after:name:))]
        #[unsafe(method_family = none)]
        pub unsafe fn whileWithInitialInputs_before_after_name(
            &self,
            initial_inputs: &NSArray<MPSGraphTensor>,
            before: MPSGraphWhileBeforeBlock,
            after: MPSGraphWhileAfterBlock,
            name: Option<&NSString>,
        ) -> Retained<NSArray<MPSGraphTensor>>;

        #[cfg(all(feature = "MPSGraphTensor", feature = "block2"))]
        /// Adds a for loop operation, The lower and upper bounds specify a half-open range: the range includes the lower bound but does not include the upper bound.
        ///
        /// - Parameters:
        /// - lowerBound: Lower bound value of the loop, this is a scalar tensor, this is the index the loop will start with.
        /// - upperBound: Upper bound value of the loop, this is a scalar tensor.
        /// - step: Step value of the loop, this is a scalar tensor and must be positive.
        /// - initialBodyArguments: initial set of iteration arguments passed to the bodyBlock of the for loop.
        /// - body: This block will execute the body of the for loop.
        /// - name: name of operation.
        /// - Returns: A valid `MPSGraphTensor` array with same count and corresponding element types as `initialIterationArguments` and return types of the for loop.
        ///
        /// # Safety
        ///
        /// `body` must be a valid pointer.
        #[unsafe(method(forLoopWithLowerBound:upperBound:step:initialBodyArguments:body:name:))]
        #[unsafe(method_family = none)]
        pub unsafe fn forLoopWithLowerBound_upperBound_step_initialBodyArguments_body_name(
            &self,
            lower_bound: &MPSGraphTensor,
            upper_bound: &MPSGraphTensor,
            step: &MPSGraphTensor,
            initial_body_arguments: &NSArray<MPSGraphTensor>,
            body: MPSGraphForLoopBodyBlock,
            name: Option<&NSString>,
        ) -> Retained<NSArray<MPSGraphTensor>>;

        #[cfg(all(feature = "MPSGraphTensor", feature = "block2"))]
        /// Adds a for loop operation, with a specific number of iterations.
        ///
        /// - Parameters:
        /// - numberOfIterations: tensor with number of iterations the loop will execute
        /// - initialBodyArguments: initial set of iteration arguments passed to the bodyBlock of the for loop
        /// - body: bodyBlock, this will execute the body of the for loop, index will go from 0 to numberOfIterations-1
        /// - name: name of operation
        /// - Returns: A valid MPSGraphTensor array with same count and corresponding elementTypes as initialIterationArguments and return types of the for loop
        ///
        /// # Safety
        ///
        /// `body` must be a valid pointer.
        #[unsafe(method(forLoopWithNumberOfIterations:initialBodyArguments:body:name:))]
        #[unsafe(method_family = none)]
        pub unsafe fn forLoopWithNumberOfIterations_initialBodyArguments_body_name(
            &self,
            number_of_iterations: &MPSGraphTensor,
            initial_body_arguments: &NSArray<MPSGraphTensor>,
            body: MPSGraphForLoopBodyBlock,
            name: Option<&NSString>,
        ) -> Retained<NSArray<MPSGraphTensor>>;
    );
}
