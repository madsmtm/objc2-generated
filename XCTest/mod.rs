// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "XCTest", kind = "framework")]
extern "C" {}

use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-app-kit")]
#[cfg(target_os = "macos")]
use objc2_app_kit::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-xc-ui-automation")]
use objc2_xc_ui_automation::*;

use crate::*;

extern "C" {
    /// Domain for errors provided by the XCTest framework.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctesterrordomain?language=objc)
    pub static XCTestErrorDomain: &'static NSErrorDomain;
}

/// Error codes used with errors in the XCTestErrorDomain.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctesterrorcode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct XCTestErrorCode(pub NSInteger);
impl XCTestErrorCode {
    #[doc(alias = "XCTestErrorCodeTimeoutWhileWaiting")]
    pub const TimeoutWhileWaiting: Self = Self(0);
    #[doc(alias = "XCTestErrorCodeFailureWhileWaiting")]
    pub const FailureWhileWaiting: Self = Self(1);
}

unsafe impl Encode for XCTestErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for XCTestErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An abstract base class for testing. XCTestCase and XCTestSuite extend XCTest to provide
    /// for creating, managing, and executing tests. Most developers will not need to subclass
    /// XCTest directly.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctest?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTest;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTest {}
);

impl XCTest {
    extern_methods!(
        /// Number of test cases. Must be overridden by subclasses.
        #[unsafe(method(testCaseCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn testCaseCount(&self) -> NSUInteger;

        /// Test's name. Must be overridden by subclasses.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Retained<NSString>;

        /// The XCTestRun subclass that will be instantiated when the test is run to hold
        /// the test's results. Must be overridden by subclasses.
        #[unsafe(method(testRunClass))]
        #[unsafe(method_family = none)]
        pub unsafe fn testRunClass(&self) -> Option<&'static AnyClass>;

        /// The test run object that executed the test, an instance of testRunClass. If the test has not yet been run, this will be nil.
        #[unsafe(method(testRun))]
        #[unsafe(method_family = none)]
        pub unsafe fn testRun(&self) -> Option<Retained<XCTestRun>>;

        /// The method through which tests are executed. Must be overridden by subclasses.
        #[unsafe(method(performTest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performTest(&self, run: &XCTestRun);

        /// Creates an instance of the testRunClass and passes it as a parameter to -performTest:.
        #[unsafe(method(runTest))]
        #[unsafe(method_family = none)]
        pub unsafe fn runTest(&self);

        #[cfg(feature = "block2")]
        /// Asynchronous set up method called before the invocation of each test method in the class.
        /// This method is called before invoking `setUpWithError`, `setUp`, and the test method.
        ///
        ///
        /// Parameter `completion`: A block which must be called to signal completion of set up.
        /// May be called asynchronously. If the block's `error` argument is non-nil, the specified error
        /// is recorded as a thrown error issue.
        #[unsafe(method(setUpWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUpWithCompletionHandler(
            &self,
            completion: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// This method is called before invoking `setUp` and the test method.
        #[unsafe(method(setUpWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUpWithError(&self) -> Result<(), Retained<NSError>>;

        /// Setup method called before the invocation of each test method in the class.
        #[unsafe(method(setUp))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUp(&self);

        /// Teardown method called after the invocation of each test method in the class.
        #[unsafe(method(tearDown))]
        #[unsafe(method_family = none)]
        pub unsafe fn tearDown(&self);

        /// This method is called after invoking the test method (if applicable) and
        /// `tearDown`.
        #[unsafe(method(tearDownWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn tearDownWithError(&self) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "block2")]
        /// Asynchronous tear down method called after invoking the test method.
        /// This method is called after invoking the test method (if applicable), `tearDown`, and
        /// `tearDownWithError`.
        ///
        ///
        /// Parameter `completion`: A block which must be called to signal completion of tear down.
        /// May be called asynchronously. If the block's `error` argument is non-nil, the specified error
        /// is recorded as a thrown error issue.
        #[unsafe(method(tearDownWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tearDownWithCompletionHandler(
            &self,
            completion: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTest {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/_xctestcaseinterruptionexception?language=objc)
    #[unsafe(super(NSException, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct _XCTestCaseInterruptionException;
);

extern_conformance!(
    unsafe impl NSCoding for _XCTestCaseInterruptionException {}
);

extern_conformance!(
    unsafe impl NSCopying for _XCTestCaseInterruptionException {}
);

unsafe impl CopyingHelper for _XCTestCaseInterruptionException {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for _XCTestCaseInterruptionException {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for _XCTestCaseInterruptionException {}
);

impl _XCTestCaseInterruptionException {
    extern_methods!();
}

/// Methods declared on superclass `NSException`.
impl _XCTestCaseInterruptionException {
    extern_methods!(
        #[unsafe(method(initWithName:reason:userInfo:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName_reason_userInfo(
            this: Allocated<Self>,
            a_name: &NSExceptionName,
            a_reason: Option<&NSString>,
            a_user_info: Option<&NSDictionary>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl _XCTestCaseInterruptionException {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

#[inline]
pub(crate) unsafe extern "C-unwind" fn _XCTPreformattedFailureHandler(
    test: Option<&XCTestCase>,
    expected: bool,
    file_path: &NSString,
    line_number: NSUInteger,
    condition: &NSString,
    message: &NSString,
) {
    extern "C-unwind" {
        fn _XCTPreformattedFailureHandler(
            test: Option<&XCTestCase>,
            expected: Bool,
            file_path: &NSString,
            line_number: NSUInteger,
            condition: &NSString,
            message: &NSString,
        );
    }
    unsafe {
        _XCTPreformattedFailureHandler(
            test,
            Bool::new(expected),
            file_path,
            line_number,
            condition,
            message,
        )
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/xctest/_xctassertiontype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct _XCTAssertionType(pub NSUInteger);
impl _XCTAssertionType {
    #[doc(alias = "_XCTAssertion_Fail")]
    pub const Fail: Self = Self(0);
    #[doc(alias = "_XCTAssertion_Nil")]
    pub const Nil: Self = Self(1);
    #[doc(alias = "_XCTAssertion_NotNil")]
    pub const NotNil: Self = Self(2);
    #[doc(alias = "_XCTAssertion_EqualObjects")]
    pub const EqualObjects: Self = Self(3);
    #[doc(alias = "_XCTAssertion_NotEqualObjects")]
    pub const NotEqualObjects: Self = Self(4);
    #[doc(alias = "_XCTAssertion_Equal")]
    pub const Equal: Self = Self(5);
    #[doc(alias = "_XCTAssertion_NotEqual")]
    pub const NotEqual: Self = Self(6);
    #[doc(alias = "_XCTAssertion_EqualWithAccuracy")]
    pub const EqualWithAccuracy: Self = Self(7);
    #[doc(alias = "_XCTAssertion_NotEqualWithAccuracy")]
    pub const NotEqualWithAccuracy: Self = Self(8);
    #[doc(alias = "_XCTAssertion_GreaterThan")]
    pub const GreaterThan: Self = Self(9);
    #[doc(alias = "_XCTAssertion_GreaterThanOrEqual")]
    pub const GreaterThanOrEqual: Self = Self(10);
    #[doc(alias = "_XCTAssertion_LessThan")]
    pub const LessThan: Self = Self(11);
    #[doc(alias = "_XCTAssertion_LessThanOrEqual")]
    pub const LessThanOrEqual: Self = Self(12);
    #[doc(alias = "_XCTAssertion_True")]
    pub const True: Self = Self(13);
    #[doc(alias = "_XCTAssertion_False")]
    pub const False: Self = Self(14);
    #[doc(alias = "_XCTAssertion_Throws")]
    pub const Throws: Self = Self(15);
    #[doc(alias = "_XCTAssertion_ThrowsSpecific")]
    pub const ThrowsSpecific: Self = Self(16);
    #[doc(alias = "_XCTAssertion_ThrowsSpecificNamed")]
    pub const ThrowsSpecificNamed: Self = Self(17);
    #[doc(alias = "_XCTAssertion_NoThrow")]
    pub const NoThrow: Self = Self(18);
    #[doc(alias = "_XCTAssertion_NoThrowSpecific")]
    pub const NoThrowSpecific: Self = Self(19);
    #[doc(alias = "_XCTAssertion_NoThrowSpecificNamed")]
    pub const NoThrowSpecificNamed: Self = Self(20);
    #[doc(alias = "_XCTAssertion_Unwrap")]
    pub const Unwrap: Self = Self(21);
    #[doc(alias = "_XCTAssertion_Identical")]
    pub const Identical: Self = Self(22);
    #[doc(alias = "_XCTAssertion_NotIdentical")]
    pub const NotIdentical: Self = Self(23);
}

unsafe impl Encode for _XCTAssertionType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for _XCTAssertionType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[inline]
pub(crate) unsafe extern "C-unwind" fn _XCTFailureFormat(
    assertion_type: _XCTAssertionType,
    format_index: NSUInteger,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn _XCTFailureFormat(
            assertion_type: _XCTAssertionType,
            format_index: NSUInteger,
        ) -> *mut NSString;
    }
    let ret = unsafe { _XCTFailureFormat(assertion_type, format_index) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[inline]
pub(crate) unsafe extern "C-unwind" fn _XCTDescriptionForValue(
    value: &NSValue,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn _XCTDescriptionForValue(value: &NSValue) -> *mut NSString;
    }
    let ret = unsafe { _XCTDescriptionForValue(value) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[inline]
pub(crate) unsafe extern "C-unwind" fn _XCTGetCurrentExceptionReasonWithFallback(
    fallback: Option<&NSString>,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn _XCTGetCurrentExceptionReasonWithFallback(fallback: Option<&NSString>) -> *mut NSString;
    }
    let ret = unsafe { _XCTGetCurrentExceptionReasonWithFallback(fallback) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

extern_protocol!(
    /// Represents a test activity.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctactivity?language=objc)
    pub unsafe trait XCTActivity: NSObjectProtocol {
        /// Human-readable name of the activity, given at creation time.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        unsafe fn name(&self) -> Retained<NSString>;

        /// Adds an attachment which is always kept by Xcode, regardless of the test result.
        /// Thread-safe, attachments can be added from any thread, are reported in the order they are added.
        #[unsafe(method(addAttachment:))]
        #[unsafe(method_family = none)]
        unsafe fn addAttachment(&self, attachment: &XCTAttachment);
    }
);

extern_class!(
    /// XCTestCase is a concrete subclass of XCTest that should be the override point for
    /// most developers creating tests for their projects. A test case subclass can have
    /// multiple test methods and supports setup and tear down that executes for every test
    /// method as well as class level setup and tear down.
    ///
    /// To define a test case:
    ///
    /// • Create a subclass of XCTestCase.
    /// • Implement -test methods.
    /// • Optionally define instance variables or properties that store the state of the test.
    /// • Optionally initialize state by overriding -setUp
    /// • Optionally clean-up after a test by overriding -tearDown.
    ///
    /// Test methods are instance methods meeting these requirements:
    /// • accepting no parameters
    /// • returning no value
    /// • prefixed with 'test'
    ///
    /// For example:
    ///
    /// - (void)testSomething;
    ///
    /// Test methods are automatically recognized as test cases by the XCTest framework.
    /// Each XCTestCase subclass's defaultTestSuite is a XCTestSuite which includes these
    /// tests. Test method implementations usually contain assertions that must be verified
    /// for the test to pass, for example:
    ///
    /// ```text
    ///
    ///     @interface MathTest : XCTestCase
    ///
    ///     @property float f1;
    ///     @property float f2;
    ///
    ///     @end
    ///
    ///     @implementation MathTest
    ///
    ///     - (void)setUp
    ///     {
    ///         self.f1 = 2.0;
    ///         self.f2 = 3.0;
    ///     }
    ///
    ///     - (void)testAddition
    ///     {
    ///         XCTAssertTrue(f1 + f2 == 5.0);
    ///     }
    ///
    ///     @end
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestcase?language=objc)
    #[unsafe(super(XCTest, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTestCase;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestCase {}
);

impl XCTestCase {
    extern_methods!(
        #[unsafe(method(testCaseWithInvocation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testCaseWithInvocation(invocation: Option<&NSInvocation>) -> Retained<Self>;

        #[unsafe(method(initWithInvocation:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithInvocation(
            this: Allocated<Self>,
            invocation: Option<&NSInvocation>,
        ) -> Retained<Self>;

        #[unsafe(method(testCaseWithSelector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testCaseWithSelector(selector: Sel) -> Option<Retained<Self>>;

        #[unsafe(method(initWithSelector:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSelector(this: Allocated<Self>, selector: Sel) -> Retained<Self>;

        /// The invocation used when this test is run.
        #[unsafe(method(invocation))]
        #[unsafe(method_family = none)]
        pub unsafe fn invocation(&self) -> Option<Retained<NSInvocation>>;

        /// Setter for [`invocation`][Self::invocation].
        #[unsafe(method(setInvocation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInvocation(&self, invocation: Option<&NSInvocation>);

        /// Invoking a test performs its setUp, invocation, and tearDown. In general this
        /// should not be called directly.
        #[unsafe(method(invokeTest))]
        #[unsafe(method_family = none)]
        pub unsafe fn invokeTest(&self);

        /// Determines whether the test method continues execution after an XCTAssert fails.
        ///
        /// By default, this property is YES, meaning the test method will complete regardless of how many
        /// XCTAssert failures occur. Setting this to NO causes the test method to end execution immediately
        /// after the first failure occurs, but does not affect remaining test methods in the suite.
        ///
        /// If XCTAssert failures in the test method indicate problems with state or determinism, additional
        /// failures may be not be helpful information. Setting `continueAfterFailure` to NO can reduce the
        /// noise in the test report for these kinds of tests.
        #[unsafe(method(continueAfterFailure))]
        #[unsafe(method_family = none)]
        pub unsafe fn continueAfterFailure(&self) -> bool;

        /// Setter for [`continueAfterFailure`][Self::continueAfterFailure].
        #[unsafe(method(setContinueAfterFailure:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContinueAfterFailure(&self, continue_after_failure: bool);

        /// Records a failure or other issue in the execution of the test and is used by all test assertions.
        /// Overrides of this method should call super unless they wish to suppress the issue.
        /// Super can be invoked with a different issue object.
        ///
        ///
        /// Parameter `issue`: Object with all details related to the issue.
        #[unsafe(method(recordIssue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordIssue(&self, issue: &XCTIssue);

        /// Invocations for each test method in the test case.
        #[unsafe(method(testInvocations))]
        #[unsafe(method_family = none)]
        pub unsafe fn testInvocations() -> Retained<NSArray<NSInvocation>>;

        #[cfg(feature = "block2")]
        /// Registers a block to be run at the end of a test.
        ///
        /// Teardown blocks are executed after the current test method has returned but before
        /// -tearDown is invoked.
        ///
        /// Registered blocks are run on the main thread but can be registered from any thread.
        /// They are guaranteed to run only once, in LIFO order, and are executed serially. You
        /// may register blocks during -setUp, but you may *not* register blocks during -tearDown
        /// or from other teardown blocks.
        ///
        ///
        /// Parameter `block`: A block to enqueue for future execution.
        #[unsafe(method(addTeardownBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTeardownBlock(&self, block: &block2::DynBlock<dyn Fn()>);

        #[cfg(feature = "block2")]
        /// Registers an async block to be run at the end of a test.
        ///
        /// Teardown blocks are executed after the current test method has returned but before
        /// -tearDown is invoked.
        ///
        /// Registered blocks are run on the main thread but can be registered from any thread.
        /// They are guaranteed to run only once, in LIFO order, and are executed serially. You
        /// may register blocks during -setUp, but you may *not* register blocks during -tearDown
        /// or from other teardown blocks.
        ///
        ///
        /// Parameter `block`: An async block to enqueue for future execution. The completion handler
        /// passed to this block must be invoked for test execution to continue. Invoking the completion
        /// handler with a non-nil NSError will cause an XCTIssue to be recorded representing the error.
        #[unsafe(method(addAsyncTeardownBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAsyncTeardownBlock(
            &self,
            block: &block2::DynBlock<dyn Fn(NonNull<block2::DynBlock<dyn Fn(*mut NSError)>>)>,
        );

        /// If test timeouts are enabled, this property represents the amount of time the test would like to be given to run.
        /// If the test exceeds its allowance, Xcode will capture a spindump of the process and then restart it
        /// so that test execution can continue on with the next test. The test that timed out will be marked
        /// as a failure, and the spindump will be attached to the test in Xcode's test report.
        ///
        /// Note that the value you supply will be rounded up to the nearest minute value. Also note that a test
        /// may be given less time than the value you specify if the -maximum-test-execution-time-allowance
        /// option is passed to xcodebuild.
        ///
        /// The default value is 10 minutes.
        #[unsafe(method(executionTimeAllowance))]
        #[unsafe(method_family = none)]
        pub unsafe fn executionTimeAllowance(&self) -> NSTimeInterval;

        /// Setter for [`executionTimeAllowance`][Self::executionTimeAllowance].
        #[unsafe(method(setExecutionTimeAllowance:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExecutionTimeAllowance(&self, execution_time_allowance: NSTimeInterval);
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTestCase {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// XCTestSuiteExtensions.
impl XCTestCase {
    extern_methods!(
        /// Returns a test suite containing test cases for all of the tests in the class.
        #[unsafe(method(defaultTestSuite))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultTestSuite() -> Retained<XCTestSuite>;

        /// Suite-level setup method called before the class begins to run any of its test methods or their associated
        /// per-instance setUp methods.
        #[unsafe(method(setUp))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUp();

        /// Suite-level teardown method called after the class has finished running all of its test methods and their
        /// associated per-instance tearDown methods and teardown blocks.
        #[unsafe(method(tearDown))]
        #[unsafe(method_family = none)]
        pub unsafe fn tearDown();
    );
}

/// XCTActivity.
///
/// XCTestCase conforms to XCTActivity, allowing test attachments to be added directly from test methods.
///
/// See XCTAttachment.h for details on how to create attachments. Once created, they can be added directly to XCTestCase:
///
///
/// ```text
///  
///      - (void)testFoo
///      {
///          XCTAttachment *attachment = ...
///          [self addAttachment:attachment];
///      }
///  
/// ```
impl XCTestCase {
    extern_methods!();
}

extern_conformance!(
    unsafe impl XCTActivity for XCTestCase {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctperformancemetric?language=objc)
// NS_TYPED_EXTENSIBLE_ENUM
pub type XCTPerformanceMetric = NSString;

extern "C" {
    /// Records wall clock time in seconds between startMeasuring/stopMeasuring.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctperformancemetric_wallclocktime?language=objc)
    pub static XCTPerformanceMetric_WallClockTime: &'static XCTPerformanceMetric;
}

/// XCTPerformanceAnalysis.
///
/// Interface extension for measure related API.
impl XCTestCase {
    extern_methods!(
        /// The names of the performance metrics to measure when invoking -measureBlock:. Returns XCTPerformanceMetric_WallClockTime by default. Subclasses can override this to change the behavior of -measureBlock:
        #[unsafe(method(defaultPerformanceMetrics))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultPerformanceMetrics() -> Retained<NSArray<XCTPerformanceMetric>>;

        #[cfg(feature = "block2")]
        /// Call from a test method to measure resources (+defaultPerformanceMetrics) used by the
        /// block in the current process.
        ///
        /// - (void)testPerformanceOfMyFunction {
        ///
        /// [self measureBlock:^{
        /// // Do that thing you want to measure.
        /// MyFunction();
        /// }];
        /// }
        ///
        ///
        /// Parameter `block`: A block whose performance to measure.
        #[unsafe(method(measureBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn measureBlock(&self, block: &block2::DynBlock<dyn Fn() + '_>);

        #[cfg(feature = "block2")]
        /// Call from a test method to measure resources (XCTPerformanceMetrics) used by the
        /// block in the current process. Each metric will be measured across calls to the block.
        /// The number of times the block will be called is undefined and may change in the
        /// future. For one example of why, as long as the requested performance metrics do
        /// not interfere with each other the API will measure all metrics across the same
        /// calls to the block. If the performance metrics may interfere the API will measure
        /// them separately.
        ///
        /// - (void)testMyFunction2_WallClockTime {
        /// [self measureMetrics:[self class].defaultPerformanceMetrics automaticallyStartMeasuring:NO forBlock:^{
        ///
        /// // Do setup work that needs to be done for every iteration but you don't want to measure before the call to -startMeasuring
        /// SetupSomething();
        /// [self startMeasuring];
        ///
        /// // Do that thing you want to measure.
        /// MyFunction();
        /// [self stopMeasuring];
        ///
        /// // Do teardown work that needs to be done for every iteration but you don't want to measure after the call to -stopMeasuring
        /// TeardownSomething();
        /// }];
        /// }
        ///
        /// Caveats:
        /// • If YES was passed for automaticallyStartMeasuring and -startMeasuring is called
        /// anyway, the test will fail.
        /// • If NO was passed for automaticallyStartMeasuring then -startMeasuring must be
        /// called once and only once before the end of the block or the test will fail.
        /// • If -stopMeasuring is called multiple times during the block the test will fail.
        ///
        ///
        /// Parameter `metrics`: An array of NSStrings (XCTPerformanceMetrics) to measure. Providing an unrecognized string is a test failure.
        ///
        ///
        /// Parameter `automaticallyStartMeasuring`: If NO, XCTestCase will not take any measurements until -startMeasuring is called.
        ///
        ///
        /// Parameter `block`: A block whose performance to measure.
        #[unsafe(method(measureMetrics:automaticallyStartMeasuring:forBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn measureMetrics_automaticallyStartMeasuring_forBlock(
            &self,
            metrics: &NSArray<XCTPerformanceMetric>,
            automatically_start_measuring: bool,
            block: &block2::DynBlock<dyn Fn() + '_>,
        );

        /// Call this from within a measure block to set the beginning of the critical section.
        /// Measurement of metrics will start at this point.
        #[unsafe(method(startMeasuring))]
        #[unsafe(method_family = none)]
        pub unsafe fn startMeasuring(&self);

        /// Call this from within a measure block to set the ending of the critical section.
        /// Measurement of metrics will stop at this point.
        #[unsafe(method(stopMeasuring))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopMeasuring(&self);

        /// A collection of metrics to be taken by default when -measureBlock or -measureWithOptions:block: is called.
        #[unsafe(method(defaultMetrics))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultMetrics() -> Retained<NSArray<ProtocolObject<dyn XCTMetric>>>;

        /// Collection of configurable settings to change how measurements are taken.
        #[unsafe(method(defaultMeasureOptions))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultMeasureOptions() -> Retained<XCTMeasureOptions>;

        #[cfg(feature = "block2")]
        /// Measures the block using the provided metrics and the default options from your XCTestCase class.
        ///
        ///
        /// Parameter `metrics`: A non-empty array of objects which adopt the XCTMetric protocol, describing the set of metrics to measure.
        ///
        /// Parameter `block`: The block to be measured.
        #[unsafe(method(measureWithMetrics:block:))]
        #[unsafe(method_family = none)]
        pub unsafe fn measureWithMetrics_block(
            &self,
            metrics: &NSArray<ProtocolObject<dyn XCTMetric>>,
            block: &block2::DynBlock<dyn Fn() + '_>,
        );

        #[cfg(feature = "block2")]
        /// Measures the block using the default metrics from your XCTestCase class and the provided options.
        ///
        ///
        /// Parameter `options`: An object describing the options to use when measuring the block, such as the number of times the block should be executed.
        ///
        /// Parameter `block`: The block to be measured.
        ///
        ///
        /// See also: XCTMeasureOptions
        #[unsafe(method(measureWithOptions:block:))]
        #[unsafe(method_family = none)]
        pub unsafe fn measureWithOptions_block(
            &self,
            options: &XCTMeasureOptions,
            block: &block2::DynBlock<dyn Fn() + '_>,
        );

        #[cfg(feature = "block2")]
        /// Measures the block using the provided metrics and options.
        ///
        ///
        /// Parameter `metrics`: A non-empty array of objects which adopt the XCTMetric protocol, describing the set of metrics to measure.
        ///
        /// Parameter `options`: An object describing the options to use when measuring the block, such as the number of times the block should be executed.
        ///
        /// Parameter `block`: The block to be measured.
        #[unsafe(method(measureWithMetrics:options:block:))]
        #[unsafe(method_family = none)]
        pub unsafe fn measureWithMetrics_options_block(
            &self,
            metrics: &NSArray<ProtocolObject<dyn XCTMetric>>,
            options: &XCTMeasureOptions,
            block: &block2::DynBlock<dyn Fn() + '_>,
        );
    );
}

/// XCTDeprecated.
impl XCTestCase {
    extern_methods!(
        /// Records a failure in the execution of the test.
        ///
        /// This method is deprecated and has been replaced by the `-recordIssue:` method and XCTIssue class, which
        /// provide greater flexibility for recording issues that arise during testing. Overriding this method in an XCTestCase subclass and
        /// modifying its arguments before calling `super` may cause information about the failure to be lost and is not recommended.
        /// Instead, override `-recordIssue:` and pass `super` a modified XCTIssue.
        ///
        ///
        /// Parameter `description`: The description of the failure being recorded. When replacing usage of this deprecated API,
        /// this can be represented using the `compactDescription` property on XCTIssue.
        ///
        ///
        /// Parameter `filePath`: The file path to the source file where the failure being recorded was encountered.
        /// When replacing usage of this deprecated API, this can be specified using an XCTSourceCodeLocation instance
        /// associated with an XCTIssue via its `sourceCodeContext` property.
        ///
        ///
        /// Parameter `lineNumber`: The line number in the source file at filePath where the failure being recorded
        /// was encountered. When replacing usage of this deprecated API, this can be specified using an XCTSourceCodeLocation
        /// instance associated with an XCTIssue via its `sourceCodeContext` property.
        ///
        ///
        /// Parameter `expected`: NO if the failure being recorded was the result of an uncaught exception, YES if it was the result
        /// of a failed assertion or any other reason. When replacing usage of this deprecated API, the representation using XCTIssue may vary.
        /// A NO value may be specified using the issue type `XCTIssueTypeUncaughtException`, and a YES value may be represented
        /// using a different issue type such as `XCTIssueTypeAssertionFailure` combined with other properties on XCTIssue.
        #[deprecated]
        #[unsafe(method(recordFailureWithDescription:inFile:atLine:expected:))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordFailureWithDescription_inFile_atLine_expected(
            &self,
            description: &NSString,
            file_path: &NSString,
            line_number: NSUInteger,
            expected: bool,
        );
    );
}

extern_class!(
    /// A test run collects information about the execution of a test. Failures in explicit
    /// test assertions are classified as "expected", while failures from unrelated or
    /// uncaught exceptions are classified as "unexpected".
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestrun?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTestRun;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestRun {}
);

impl XCTestRun {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Class factory method for the XCTestRun class.
        ///
        ///
        /// Parameter `test`: An XCTest instance.
        ///
        ///
        /// Returns: A test run for the provided test.
        #[unsafe(method(testRunWithTest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testRunWithTest(test: &XCTest) -> Retained<Self>;

        /// Designated initializer for the XCTestRun class.
        ///
        ///
        /// Parameter `test`: An XCTest instance.
        ///
        ///
        /// Returns: A test run for the provided test.
        #[unsafe(method(initWithTest:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTest(this: Allocated<Self>, test: &XCTest) -> Retained<Self>;

        /// The test instance provided when the test run was initialized.
        #[unsafe(method(test))]
        #[unsafe(method_family = none)]
        pub unsafe fn test(&self) -> Retained<XCTest>;

        /// Start a test run. Must not be called more than once.
        #[unsafe(method(start))]
        #[unsafe(method_family = none)]
        pub unsafe fn start(&self);

        /// Stop a test run. Must not be called unless the run has been started. Must not be called more than once.
        #[unsafe(method(stop))]
        #[unsafe(method_family = none)]
        pub unsafe fn stop(&self);

        /// The time at which the test run was started, or nil.
        #[unsafe(method(startDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn startDate(&self) -> Option<Retained<NSDate>>;

        /// The time at which the test run was stopped, or nil.
        #[unsafe(method(stopDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopDate(&self) -> Option<Retained<NSDate>>;

        /// The number of seconds that elapsed between when the run was started and when it was stopped.
        #[unsafe(method(totalDuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn totalDuration(&self) -> NSTimeInterval;

        /// The number of seconds that elapsed between when the run was started and when it was stopped.
        #[unsafe(method(testDuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn testDuration(&self) -> NSTimeInterval;

        /// The number of tests in the run.
        #[unsafe(method(testCaseCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn testCaseCount(&self) -> NSUInteger;

        /// The number of test executions recorded during the run.
        #[unsafe(method(executionCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn executionCount(&self) -> NSUInteger;

        /// The number of test skips recorded during the run.
        #[unsafe(method(skipCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn skipCount(&self) -> NSUInteger;

        /// The number of test failures recorded during the run.
        #[unsafe(method(failureCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn failureCount(&self) -> NSUInteger;

        /// The number of uncaught exceptions recorded during the run.
        #[unsafe(method(unexpectedExceptionCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn unexpectedExceptionCount(&self) -> NSUInteger;

        /// The total number of test failures and uncaught exceptions recorded during the run.
        #[unsafe(method(totalFailureCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn totalFailureCount(&self) -> NSUInteger;

        /// YES if all tests in the run completed their execution without recording any failures, otherwise NO.
        #[unsafe(method(hasSucceeded))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasSucceeded(&self) -> bool;

        /// YES if the test was skipped, otherwise NO.
        #[unsafe(method(hasBeenSkipped))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasBeenSkipped(&self) -> bool;

        /// Records a failure or other  issue in the execution of the test and is used by all test assertions.
        /// Overrides of this method should call super unless they wish to suppress the issue.
        /// Super can be invoked with a different issue object.
        ///
        ///
        /// Parameter `issue`: Object with all details related to the issue.
        #[unsafe(method(recordIssue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordIssue(&self, issue: &XCTIssue);
    );
}

/// XCTDeprecated.
impl XCTestRun {
    extern_methods!(
        /// Records a failure in the execution of the test for this test run. Must not be called
        /// unless the run has been started. Must not be called if the test run has been stopped.
        ///
        /// This method is deprecated and has been replaced by the `-recordIssue:` method and XCTIssue class, which
        /// provide greater flexibility for recording issues that arise during testing. Overriding this method in an XCTestRun subclass and
        /// modifying its arguments before calling `super` may cause information about the failure to be lost and is not recommended.
        /// Instead, override `-recordIssue:` and pass `super` a modified XCTIssue.
        ///
        ///
        /// Parameter `description`: The description of the failure being recorded. When replacing usage of this deprecated API,
        /// this can be represented using the `compactDescription` property on XCTIssue.
        ///
        ///
        /// Parameter `filePath`: The file path to the source file where the failure being recorded was encountered
        /// or nil if unknown. When replacing usage of this deprecated API, this can be specified using an XCTSourceCodeLocation instance
        /// associated with an XCTIssue via its `sourceCodeContext` property.
        ///
        ///
        /// Parameter `lineNumber`: The line number in the source file at filePath where the failure being recorded
        /// was encountered or 0 if unknown. When replacing usage of this deprecated API, this can be specified using an
        /// XCTSourceCodeLocation instance associated with an XCTIssue via its `sourceCodeContext` property.
        ///
        ///
        /// Parameter `expected`: NO if the failure being recorded was the result of an uncaught exception, YES if it was the result
        /// of a failed assertion or any other reason. When replacing usage of this deprecated API, the representation using XCTIssue may vary.
        /// A NO value may be specified using the issue type `XCTIssueTypeUncaughtException`, and a YES value may be represented
        /// using a different issue type such as `XCTIssueTypeAssertionFailure` combined with other properties on XCTIssue.
        #[deprecated]
        #[unsafe(method(recordFailureWithDescription:inFile:atLine:expected:))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordFailureWithDescription_inFile_atLine_expected(
            &self,
            description: &NSString,
            file_path: Option<&NSString>,
            line_number: NSUInteger,
            expected: bool,
        );
    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestcaserun?language=objc)
    #[unsafe(super(XCTestRun, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTestCaseRun;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestCaseRun {}
);

impl XCTestCaseRun {
    extern_methods!(
        #[deprecated]
        #[unsafe(method(recordFailureInTest:withDescription:inFile:atLine:expected:))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordFailureInTest_withDescription_inFile_atLine_expected(
            &self,
            test_case: &XCTestCase,
            description: &NSString,
            file_path: &NSString,
            line_number: NSUInteger,
            expected: bool,
        );
    );
}

/// Methods declared on superclass `XCTestRun`.
impl XCTestCaseRun {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Class factory method for the XCTestRun class.
        ///
        ///
        /// Parameter `test`: An XCTest instance.
        ///
        ///
        /// Returns: A test run for the provided test.
        #[unsafe(method(testRunWithTest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testRunWithTest(test: &XCTest) -> Retained<Self>;

        /// Designated initializer for the XCTestRun class.
        ///
        ///
        /// Parameter `test`: An XCTest instance.
        ///
        ///
        /// Returns: A test run for the provided test.
        #[unsafe(method(initWithTest:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTest(this: Allocated<Self>, test: &XCTest) -> Retained<Self>;
    );
}

extern_class!(
    /// XCTestObserver is deprecated.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestobserver?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated]
    pub struct XCTestObserver;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestObserver {}
);

impl XCTestObserver {
    extern_methods!(
        #[unsafe(method(startObserving))]
        #[unsafe(method_family = none)]
        pub unsafe fn startObserving(&self);

        #[unsafe(method(stopObserving))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopObserving(&self);

        #[unsafe(method(testSuiteDidStart:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testSuiteDidStart(&self, test_run: Option<&XCTestRun>);

        #[unsafe(method(testSuiteDidStop:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testSuiteDidStop(&self, test_run: Option<&XCTestRun>);

        #[unsafe(method(testCaseDidStart:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testCaseDidStart(&self, test_run: Option<&XCTestRun>);

        #[unsafe(method(testCaseDidStop:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testCaseDidStop(&self, test_run: Option<&XCTestRun>);

        #[unsafe(method(testCaseDidFail:withDescription:inFile:atLine:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testCaseDidFail_withDescription_inFile_atLine(
            &self,
            test_run: Option<&XCTestRun>,
            description: Option<&NSString>,
            file_path: Option<&NSString>,
            line_number: NSUInteger,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTestObserver {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern "C" {
    /// XCTestObserverClassKey is deprecated and ignored.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestobserverclasskey?language=objc)
    #[deprecated]
    pub static XCTestObserverClassKey: Option<&'static NSString>;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestlog?language=objc)
    #[unsafe(super(XCTestObserver, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated]
    pub struct XCTestLog;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestLog {}
);

impl XCTestLog {
    extern_methods!(
        #[unsafe(method(logFileHandle))]
        #[unsafe(method_family = none)]
        pub unsafe fn logFileHandle(&self) -> Option<Retained<NSFileHandle>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTestLog {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Objects conforming to XCTestObservation can register to be notified of the progress of test runs. See XCTestObservationCenter
    /// for details on registration.
    ///
    /// Progress events are delivered in the following sequence:
    ///
    /// -testBundleWillStart:                            // exactly once per test bundle
    /// -testSuiteWillStart:                        // exactly once per test suite
    /// -testCaseWillStart:                     // exactly once per test case
    /// -testCase:didRecordIssue:               // zero or more times per test case, any time between test case start and finish
    /// -testCaseDidFinish:                     // exactly once per test case
    /// -testSuite:didRecordIssue:                  // zero or more times per test suite, any time between test suite start and finish
    /// -testSuiteDidFinish:                        // exactly once per test suite
    /// -testBundleDidFinish:                            // exactly once per test bundle
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestobservation?language=objc)
    pub unsafe trait XCTestObservation: NSObjectProtocol {
        /// Sent immediately before tests begin as a hook for any pre-testing setup.
        ///
        ///
        /// Parameter `testBundle`: The bundle containing the tests that were executed.
        #[optional]
        #[unsafe(method(testBundleWillStart:))]
        #[unsafe(method_family = none)]
        unsafe fn testBundleWillStart(&self, test_bundle: &NSBundle);

        /// Sent immediately after all tests have finished as a hook for any post-testing activity. The test process will generally
        /// exit after this method returns, so if there is long running and/or asynchronous work to be done after testing, be sure
        /// to implement this method in a way that it blocks until all such activity is complete.
        ///
        ///
        /// Parameter `testBundle`: The bundle containing the tests that were executed.
        #[optional]
        #[unsafe(method(testBundleDidFinish:))]
        #[unsafe(method_family = none)]
        unsafe fn testBundleDidFinish(&self, test_bundle: &NSBundle);

        /// Sent when a test suite starts executing.
        ///
        ///
        /// Parameter `testSuite`: The test suite that started. Additional information can be retrieved from the associated XCTestRun.
        #[optional]
        #[unsafe(method(testSuiteWillStart:))]
        #[unsafe(method_family = none)]
        unsafe fn testSuiteWillStart(&self, test_suite: &XCTestSuite);

        /// Sent when a test suite reports an issue. Suite issues are most commonly reported during suite-level setup and teardown
        /// whereas issues during tests are reported for the test case alone and are not reported as suite issues.
        ///
        ///
        /// Parameter `testSuite`: The test suite that recorded the issue.
        ///
        /// Parameter `issue`: Object with all details related to the issue.
        #[optional]
        #[unsafe(method(testSuite:didRecordIssue:))]
        #[unsafe(method_family = none)]
        unsafe fn testSuite_didRecordIssue(&self, test_suite: &XCTestSuite, issue: &XCTIssue);

        /// Sent when a test suite records an expected failure.
        ///
        ///
        /// Parameter `testSuite`: The test suite that recorded the expected failure.
        ///
        /// Parameter `expectedFailure`: Object with all details related to the expected failure, including the suppressed issue.
        #[optional]
        #[unsafe(method(testSuite:didRecordExpectedFailure:))]
        #[unsafe(method_family = none)]
        unsafe fn testSuite_didRecordExpectedFailure(
            &self,
            test_suite: &XCTestSuite,
            expected_failure: &XCTExpectedFailure,
        );

        /// Sent when a test suite finishes executing.
        ///
        ///
        /// Parameter `testSuite`: The test suite that finished. Additional information can be retrieved from the associated XCTestRun.
        #[optional]
        #[unsafe(method(testSuiteDidFinish:))]
        #[unsafe(method_family = none)]
        unsafe fn testSuiteDidFinish(&self, test_suite: &XCTestSuite);

        /// Sent when a test case starts executing.
        ///
        ///
        /// Parameter `testCase`: The test case that started. Additional information can be retrieved from the associated XCTestRun.
        #[optional]
        #[unsafe(method(testCaseWillStart:))]
        #[unsafe(method_family = none)]
        unsafe fn testCaseWillStart(&self, test_case: &XCTestCase);

        /// Sent when a test case reports an issue.
        ///
        ///
        /// Parameter `testCase`: The test case that recorded the issue.
        ///
        /// Parameter `issue`: Object with all details related to the issue.
        #[optional]
        #[unsafe(method(testCase:didRecordIssue:))]
        #[unsafe(method_family = none)]
        unsafe fn testCase_didRecordIssue(&self, test_case: &XCTestCase, issue: &XCTIssue);

        /// Sent when a test case records an expected failure.
        ///
        ///
        /// Parameter `testCase`: The test case that recorded the expected failure.
        ///
        /// Parameter `expectedFailure`: Object with all details related to the expected failure, including the suppressed issue.
        #[optional]
        #[unsafe(method(testCase:didRecordExpectedFailure:))]
        #[unsafe(method_family = none)]
        unsafe fn testCase_didRecordExpectedFailure(
            &self,
            test_case: &XCTestCase,
            expected_failure: &XCTExpectedFailure,
        );

        /// Sent when a test case finishes executing.
        ///
        ///
        /// Parameter `testCase`: The test case that finished. Additional information can be retrieved from the associated XCTestRun.
        #[optional]
        #[unsafe(method(testCaseDidFinish:))]
        #[unsafe(method_family = none)]
        unsafe fn testCaseDidFinish(&self, test_case: &XCTestCase);

        /// Sent when a test suite reports a failure. Suite failures are most commonly reported during suite-level setup and teardown
        /// whereas failures during tests are reported for the test case alone and are not reported as suite failures.
        ///
        /// This method is deprecated and replaced by the `-testSuite:didRecordIssue:` method whose XCTIssue parameter provides greater flexibility
        /// for describing issues that arise during testing. If the receiver of this method also responds to `-testSuite:didRecordIssue:`, that method
        /// is called instead and this will not be called.
        ///
        ///
        /// Parameter `testSuite`: The test suite that failed. Additional information can be retrieved from the associated XCTestRun.
        ///
        ///
        /// Parameter `description`: A textual description of the failure. When replacing usage of this deprecated API, this can
        /// be obtained using the `compactDescription` property on XCTIssue.
        ///
        ///
        /// Parameter `filePath`: The path of file where the failure occurred or nil if unknown. When replacing usage of this deprecated API, this
        /// can be obtained using the XCTSourceCodeLocation instance associated with an XCTIssue via its `sourceCodeContext` property
        ///
        ///
        /// Parameter `lineNumber`: The line where the failure was reported or 0 if unknown. When replacing usage of this deprecated API, this
        /// can be obtained using the XCTSourceCodeLocation instance associated with an XCTIssue via its `sourceCodeContext` property
        #[deprecated]
        #[optional]
        #[unsafe(method(testSuite:didFailWithDescription:inFile:atLine:))]
        #[unsafe(method_family = none)]
        unsafe fn testSuite_didFailWithDescription_inFile_atLine(
            &self,
            test_suite: &XCTestSuite,
            description: &NSString,
            file_path: Option<&NSString>,
            line_number: NSUInteger,
        );

        /// Sent when a test case reports a failure.
        ///
        /// This method is deprecated and replaced by the `-testCase:didRecordIssue:` method whose XCTIssue parameter provides greater flexibility
        /// for describing issues that arise during testing. If the receiver of this method also responds to `-testCase:didRecordIssue:`, that method
        /// is called instead and this will not be called.
        ///
        ///
        /// Parameter `testCase`: The test case that failed. Additional information can be retrieved from the associated XCTestRun.
        ///
        ///
        /// Parameter `description`: A textual description of the failure. When replacing usage of this deprecated API, this can
        /// be obtained using the `compactDescription` property on XCTIssue.
        ///
        ///
        /// Parameter `filePath`: The path of file where the failure occurred or nil if unknown. When replacing usage of this deprecated API, this
        /// can be obtained using the XCTSourceCodeLocation instance associated with an XCTIssue via its `sourceCodeContext` property
        ///
        ///
        /// Parameter `lineNumber`: The line where the failure was reported or 0 if unknown. When replacing usage of this deprecated API, this
        /// can be obtained using the XCTSourceCodeLocation instance associated with an XCTIssue via its `sourceCodeContext` property
        #[deprecated]
        #[optional]
        #[unsafe(method(testCase:didFailWithDescription:inFile:atLine:))]
        #[unsafe(method_family = none)]
        unsafe fn testCase_didFailWithDescription_inFile_atLine(
            &self,
            test_case: &XCTestCase,
            description: &NSString,
            file_path: Option<&NSString>,
            line_number: NSUInteger,
        );
    }
);

extern_class!(
    /// The XCTestObservationCenter distributes information about the progress of test runs to registered
    /// observers. Observers can be any object conforming to the XCTestObservation protocol.
    ///
    /// If an NSPrincipalClass is declared in the test bundle's Info.plist, XCTest automatically creates a
    /// single instance of that class when the test bundle is loaded. This instance provides a means to register
    /// observers or do other pretesting global set up.
    ///
    /// Observers must be registered manually. The NSPrincipalClass instance is not automatically
    /// registered as an observer even if the class conforms to
    /// <XCTestObservation
    /// >.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestobservationcenter?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTestObservationCenter;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestObservationCenter {}
);

impl XCTestObservationCenter {
    extern_methods!(
        /// Returns: The shared XCTestObservationCenter singleton instance.
        #[unsafe(method(sharedTestObservationCenter))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedTestObservationCenter() -> Retained<XCTestObservationCenter>;

        /// Register an object conforming to XCTestObservation as an observer for the current test session. Observers may be added
        /// at any time, but will not receive events that occurred before they were registered. The observation center maintains a strong
        /// reference to observers.
        ///
        /// Events may be delivered to observers in any order - given observers A and B, A may be notified of a test failure before
        /// or after B. Any ordering dependencies or serialization requirements must be managed by clients.
        #[unsafe(method(addTestObserver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTestObserver(&self, test_observer: &ProtocolObject<dyn XCTestObservation>);

        /// Unregister an object conforming to XCTestObservation as an observer for the current test session.
        #[unsafe(method(removeTestObserver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTestObserver(
            &self,
            test_observer: &ProtocolObject<dyn XCTestObservation>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTestObservationCenter {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern "C-unwind" {
    #[deprecated]
    pub fn XCTSelfTestMain() -> c_int;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestprobe?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated]
    pub struct XCTestProbe;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestProbe {}
);

impl XCTestProbe {
    extern_methods!(
        #[unsafe(method(isTesting))]
        #[unsafe(method_family = none)]
        pub unsafe fn isTesting() -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTestProbe {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestedunitpath?language=objc)
    #[deprecated]
    pub static XCTestedUnitPath: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestscopekey?language=objc)
    #[deprecated]
    pub static XCTestScopeKey: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestscopeall?language=objc)
    #[deprecated]
    pub static XCTestScopeAll: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestscopenone?language=objc)
    #[deprecated]
    pub static XCTestScopeNone: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestscopeself?language=objc)
    #[deprecated]
    pub static XCTestScopeSelf: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctesttoolkey?language=objc)
    #[deprecated]
    pub static XCTestToolKey: Option<&'static NSString>;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/_xctskipfailureexception?language=objc)
    #[unsafe(super(NSException, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct _XCTSkipFailureException;
);

extern_conformance!(
    unsafe impl NSCoding for _XCTSkipFailureException {}
);

extern_conformance!(
    unsafe impl NSCopying for _XCTSkipFailureException {}
);

unsafe impl CopyingHelper for _XCTSkipFailureException {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for _XCTSkipFailureException {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for _XCTSkipFailureException {}
);

impl _XCTSkipFailureException {
    extern_methods!();
}

/// Methods declared on superclass `NSException`.
impl _XCTSkipFailureException {
    extern_methods!(
        #[unsafe(method(initWithName:reason:userInfo:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName_reason_userInfo(
            this: Allocated<Self>,
            a_name: &NSExceptionName,
            a_reason: Option<&NSString>,
            a_user_info: Option<&NSDictionary>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl _XCTSkipFailureException {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A concrete subclass of XCTest, XCTestSuite is a collection of test cases. Suites
    /// are usually managed by the IDE, but XCTestSuite also provides API for dynamic test
    /// and suite management:
    ///
    /// ```text
    ///
    ///     XCTestSuite *suite = [XCTestSuite testSuiteWithName:@"My tests"];
    ///     [suite addTest:[MathTest testCaseWithSelector:@selector(testAdd)]];
    ///     [suite addTest:[MathTest testCaseWithSelector:@selector(testDivideByZero)]];
    ///
    /// ```
    ///
    /// Alternatively, a test suite can extract the tests to be run automatically. To do so,
    /// pass the class of your test case class to the suite's constructor:
    ///
    /// ```text
    ///
    ///     XCTestSuite *suite = [XCTestSuite testSuiteForTestCaseClass:[MathTest class]];
    ///
    /// ```
    ///
    /// This creates a suite with all the methods starting with "test" that take no arguments.
    /// Also, a test suite of all the test cases found in the runtime can be created automatically:
    ///
    /// ```text
    ///
    ///     XCTestSuite *suite = XCTestSuite.defaultTestSuite;
    ///
    /// ```
    ///
    /// This creates a suite of suites with all the XCTestCase subclasses methods that start
    /// with "test" and take no arguments.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestsuite?language=objc)
    #[unsafe(super(XCTest, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTestSuite;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestSuite {}
);

impl XCTestSuite {
    extern_methods!(
        #[unsafe(method(defaultTestSuite))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultTestSuite() -> Retained<XCTestSuite>;

        #[unsafe(method(testSuiteForBundlePath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testSuiteForBundlePath(bundle_path: &NSString) -> Retained<Self>;

        #[unsafe(method(testSuiteForTestCaseWithName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testSuiteForTestCaseWithName(name: &NSString) -> Retained<Self>;

        #[unsafe(method(testSuiteForTestCaseClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testSuiteForTestCaseClass(test_case_class: &AnyClass) -> Retained<Self>;

        #[unsafe(method(testSuiteWithName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testSuiteWithName(name: &NSString) -> Retained<Self>;

        #[unsafe(method(initWithName:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName(this: Allocated<Self>, name: &NSString) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(addTest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTest(&self, test: &XCTest);

        #[unsafe(method(tests))]
        #[unsafe(method_family = none)]
        pub unsafe fn tests(&self) -> Retained<NSArray<XCTest>>;
    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestsuiterun?language=objc)
    #[unsafe(super(XCTestRun, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTestSuiteRun;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestSuiteRun {}
);

impl XCTestSuiteRun {
    extern_methods!(
        #[unsafe(method(testRuns))]
        #[unsafe(method_family = none)]
        pub unsafe fn testRuns(&self) -> Retained<NSArray<XCTestRun>>;

        #[unsafe(method(addTestRun:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTestRun(&self, test_run: &XCTestRun);
    );
}

/// Methods declared on superclass `XCTestRun`.
impl XCTestSuiteRun {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Class factory method for the XCTestRun class.
        ///
        ///
        /// Parameter `test`: An XCTest instance.
        ///
        ///
        /// Returns: A test run for the provided test.
        #[unsafe(method(testRunWithTest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn testRunWithTest(test: &XCTest) -> Retained<Self>;

        /// Designated initializer for the XCTestRun class.
        ///
        ///
        /// Parameter `test`: An XCTest instance.
        ///
        ///
        /// Returns: A test run for the provided test.
        #[unsafe(method(initWithTest:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTest(this: Allocated<Self>, test: &XCTest) -> Retained<Self>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctattachmentlifetime?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct XCTAttachmentLifetime(pub NSInteger);
impl XCTAttachmentLifetime {
    #[doc(alias = "XCTAttachmentLifetimeKeepAlways")]
    pub const KeepAlways: Self = Self(0);
    #[doc(alias = "XCTAttachmentLifetimeDeleteOnSuccess")]
    pub const DeleteOnSuccess: Self = Self(1);
}

unsafe impl Encode for XCTAttachmentLifetime {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for XCTAttachmentLifetime {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Represents the concept of data attached to an XCTActivity. Allows reporting more context about the test run
    /// for debugging, such as screenshots, log files, and configuration dictionaries.
    ///
    /// Each attachment must be added to an activity to be handed off to XCTest. There are two ways to get an activity:
    /// 1. XCTestCase conforms to the XCTActivity protocol, attachments can be added to it directly.
    /// 2. Create a nested activity with +[XCTContext runActivityNamed:block:], the parameter inside the block is a new activity to which attachments can be added.
    ///
    /// Once you have an XCTActivity-conforming object:
    /// • Create a new XCTAttachment with one of the initializers provided.
    /// • Optionally customize the attachment's `lifetime`, `name` and `userInfo` properties.
    /// • Add the attachment to the activity with -[XCTActivity addAttachment:].
    ///
    ///
    /// ```text
    ///  
    ///     - (void)testFoo
    ///     {
    ///         // ...
    ///         NSString *logs = ...
    ///         XCTAttachment *attachment = [XCTAttachment attachmentWithString:logs];
    ///         attachment.name = @"Build logs";
    ///         [self addAttachment:attachment];
    ///     }
    ///
    ///     - (void)testNestedFoo
    ///     {
    ///         // ...
    ///         [XCTContext runActivityNamed:@"Collect logs" block:^(id<XCTActivity> activity){
    ///             NSString *logs = ...
    ///             XCTAttachment *attachment = [XCTAttachment attachmentWithString:logs];
    ///             attachment.name = @"Build logs";
    ///             [activity addAttachment:attachment];
    ///         }];
    ///     }
    ///  
    /// ```
    ///
    /// Attachments have the default lifetime of .deleteOnSuccess, which means they are deleted when
    /// their test passes. This ensures attachments are only kept when test fails. To override this
    /// behavior, change the value of the `lifetime` property to .keepAlways before adding it to an activity.
    ///
    ///
    /// ```text
    ///  
    ///      - (void)testImportantAttachment
    ///      {
    ///          XCTAttachment *attachment = ...
    ///          attachment.lifetime = XCTAttachmentLifetimeKeepAlways;
    ///          [self addAttachment:attachment];
    ///      }
    ///  
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctattachment?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTAttachment;
);

extern_conformance!(
    unsafe impl NSCoding for XCTAttachment {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTAttachment {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for XCTAttachment {}
);

impl XCTAttachment {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithUniformTypeIdentifier:name:payload:userInfo:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUniformTypeIdentifier_name_payload_userInfo(
            this: Allocated<Self>,
            identifier: Option<&NSString>,
            name: Option<&NSString>,
            payload: Option<&NSData>,
            user_info: Option<&NSDictionary>,
        ) -> Retained<Self>;

        #[unsafe(method(attachmentWithUniformTypeIdentifier:name:payload:userInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithUniformTypeIdentifier_name_payload_userInfo(
            identifier: Option<&NSString>,
            name: Option<&NSString>,
            payload: Option<&NSData>,
            user_info: Option<&NSDictionary>,
        ) -> Retained<Self>;

        /// Uniform Type Identifier of the payload data.
        /// Examples: "public.png", "public.jpeg", "public.plain-text", "public.data", "com.apple.xml-property-list".
        #[unsafe(method(uniformTypeIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn uniformTypeIdentifier(&self) -> Retained<NSString>;

        /// Attachment name.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Option<Retained<NSString>>;

        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        /// Container for additional metadata, such as pixel density with images.
        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInfo(&self) -> Option<Retained<NSDictionary>>;

        /// Setter for [`userInfo`][Self::userInfo].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setUserInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUserInfo(&self, user_info: Option<&NSDictionary>);

        #[unsafe(method(lifetime))]
        #[unsafe(method_family = none)]
        pub unsafe fn lifetime(&self) -> XCTAttachmentLifetime;

        /// Setter for [`lifetime`][Self::lifetime].
        #[unsafe(method(setLifetime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLifetime(&self, lifetime: XCTAttachmentLifetime);
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctimagequality?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct XCTImageQuality(pub NSInteger);
impl XCTImageQuality {
    #[doc(alias = "XCTImageQualityOriginal")]
    pub const Original: Self = Self(0);
    #[doc(alias = "XCTImageQualityMedium")]
    pub const Medium: Self = Self(1);
    #[doc(alias = "XCTImageQualityLow")]
    pub const Low: Self = Self(2);
}

unsafe impl Encode for XCTImageQuality {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for XCTImageQuality {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// ConvenienceInitializers.
impl XCTAttachment {
    extern_methods!(
        /// Creates a new data attachment (type "public.data") with the specified payload.
        #[unsafe(method(attachmentWithData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithData(payload: &NSData) -> Retained<Self>;

        /// Creates a new attachment with the specified payload and type.
        #[unsafe(method(attachmentWithData:uniformTypeIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithData_uniformTypeIdentifier(
            payload: &NSData,
            identifier: &NSString,
        ) -> Retained<Self>;

        /// Creates a new plain UTF-8 encoded text attachment (type "public.plain-text") with the specified string.
        #[unsafe(method(attachmentWithString:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithString(string: &NSString) -> Retained<Self>;

        /// Creates an attachment with an object that can be encoded with NSSecureCoding.
        /// Defaults to type "public.data".
        #[unsafe(method(attachmentWithArchivableObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithArchivableObject(
            object: &ProtocolObject<dyn NSSecureCoding>,
        ) -> Retained<Self>;

        /// Creates an attachment with an object that can be encoded with NSSecureCoding and type.
        #[unsafe(method(attachmentWithArchivableObject:uniformTypeIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithArchivableObject_uniformTypeIdentifier(
            object: &ProtocolObject<dyn NSSecureCoding>,
            identifier: &NSString,
        ) -> Retained<Self>;

        /// Creates an attachment with an object that can be encoded into an XML property list.
        #[unsafe(method(attachmentWithPlistObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithPlistObject(object: &AnyObject) -> Retained<Self>;

        /// Creates an attachment with an existing file on disk. Attachment's uniform type identifier is inferred from the file extension.
        /// If no type can be inferred from the extension, fallback is "public.data".
        ///
        /// Note: Only works for files, not directories.
        #[unsafe(method(attachmentWithContentsOfFileAtURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithContentsOfFileAtURL(url: &NSURL) -> Retained<Self>;

        /// Creates an attachment with an existing file on disk and type.
        ///
        /// Note: Only works for files, not directories.
        #[unsafe(method(attachmentWithContentsOfFileAtURL:uniformTypeIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithContentsOfFileAtURL_uniformTypeIdentifier(
            url: &NSURL,
            identifier: &NSString,
        ) -> Retained<Self>;

        /// Creates an attachment with an existing directory on disk. Automatically zips the directory, the content type is "public.zip-archive".
        #[unsafe(method(attachmentWithCompressedContentsOfDirectoryAtURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithCompressedContentsOfDirectoryAtURL(
            url: &NSURL,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-app-kit")]
        #[cfg(target_os = "macos")]
        #[unsafe(method(attachmentWithImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithImage(image: &NSImage) -> Retained<Self>;

        #[cfg(feature = "objc2-app-kit")]
        #[cfg(target_os = "macos")]
        #[unsafe(method(attachmentWithImage:quality:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithImage_quality(
            image: &NSImage,
            quality: XCTImageQuality,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctcontext?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTContext;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTContext {}
);

impl XCTContext {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// Call to create a named activity around the block.
        /// Can be used to group low level actions, such as typing and tapping, into high level
        /// tasks, such as filling of a form in a UI test.
        ///
        /// ```text
        ///  
        ///  - (void)testSignUpFlow {
        ///      XCUIElement *form = ...
        ///      [XCTContext runActivityNamed:@"Fill in account information" block:^{
        ///          [form.textFields[@"Email"] typeText:@"john.appleseed@icloud.com"];
        ///          [form.secureTextFields[@"New Password"] typeText:@"myPassword"];
        ///      }];
        ///      [XCTContext runActivityNamed:@"Create account" block:^{
        ///          XCUIElement *submit = form.buttons[@"Create"];
        ///          XCTAssert(submit.isEnabled);
        ///          [submit tap];
        ///      }];
        ///  }
        ///  
        /// ```
        ///
        /// Such test would result in an activity hierarchy of:
        ///
        /// ```text
        ///  
        ///  - Fill in account information
        ///      - Type "john.appleseed@icloud.com" into "Email"
        ///      - Type "myPassword" into "New Password"
        ///  - Create account
        ///      - Tap "Create"
        ///  
        /// ```
        ///
        /// Must be called from the main thread.
        ///
        ///
        /// Parameter `name`: A string that will help identify the activity.
        ///
        ///
        /// Parameter `block`: A block whose contents are wrapped in the new activity.
        #[unsafe(method(runActivityNamed:block:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runActivityNamed_block(
            name: &NSString,
            block: &block2::DynBlock<dyn Fn(NonNull<ProtocolObject<dyn XCTActivity>>) + '_>,
        );
    );
}

extern "C-unwind" {
    /// Declares that the test is expected to fail at some point beyond the call. This can be used to both document and
    /// suppress a known issue when immediate resolution is not possible. Issues caught by XCTExpectFailure do not
    /// impact the aggregate results of the test suites which own them.
    ///
    /// This function may be invoked repeatedly and has stack semantics. Failures are associated with the closest
    /// matching expected failure and the stack is cleaned up by the test after it runs. If a failure is expected
    /// but none is recorded, a distinct failure for the unmatched expected failure will be recorded instead.
    ///
    /// Threading considerations: when XCTExpectFailure is called on the test's primary thread it will match against
    /// any issue recorded on any thread. When XCTExpectFailure is called on any other thread, it will only match
    /// against issues recorded on the same thread.
    ///
    ///
    /// Parameter `failureReason`: Explanation of the issue being suppressed. If it contains
    /// a URL, that URL can be extracted and presented as a link in reporting UI (Xcode and CI).
    pub fn XCTExpectFailure(failure_reason: Option<&NSString>);
}

extern "C-unwind" {
    /// Like XCTExpectFailure, but takes an options object that can be used to customize the behavior.
    ///
    ///
    /// Parameter `options`: The options can include a custom issue matching block as well as the ability to
    /// disable "strict" behavior, which relaxes the requirement that a call to XCTExpectFailure must be matched
    /// against at least one recorded issue.
    pub fn XCTExpectFailureWithOptions(
        failure_reason: Option<&NSString>,
        options: &XCTExpectedFailureOptions,
    );
}

extern "C-unwind" {
    /// Like XCTExpectFailure, but limits the scope in which issues are matched.
    ///
    ///
    /// Parameter `failingBlock`: The scope of code in which the failure is expected. Note that this will only
    /// match against failures in that scope on the same thread; failures in dispatch callouts or other code
    /// running on a different thread will not be matched.
    #[cfg(feature = "block2")]
    pub fn XCTExpectFailureInBlock(
        failure_reason: Option<&NSString>,
        failing_block: &block2::DynBlock<dyn Fn()>,
    );
}

extern "C-unwind" {
    /// Like XCTExpectFailure, but takes an options object that can be used to customize the behavior and
    /// limits the scope in which issues are matched.
    #[cfg(feature = "block2")]
    pub fn XCTExpectFailureWithOptionsInBlock(
        failure_reason: Option<&NSString>,
        options: &XCTExpectedFailureOptions,
        failing_block: &block2::DynBlock<dyn Fn()>,
    );
}

extern_class!(
    /// Describes the rules for matching issues to expected failures and other behaviors related to
    /// expected failure handling.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctexpectedfailureoptions?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTExpectedFailureOptions;
);

extern_conformance!(
    unsafe impl NSCoding for XCTExpectedFailureOptions {}
);

extern_conformance!(
    unsafe impl NSCopying for XCTExpectedFailureOptions {}
);

unsafe impl CopyingHelper for XCTExpectedFailureOptions {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTExpectedFailureOptions {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for XCTExpectedFailureOptions {}
);

impl XCTExpectedFailureOptions {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// An optional filter can be used to determine whether or not an issue recorded inside an expected
        /// failure block should be matched to the expected failure. Issues that are not matched to an expected
        /// failure will be recorded as normal issues (real test failures). By default the filter is nil and
        /// all issues are matched.
        #[unsafe(method(issueMatcher))]
        #[unsafe(method_family = none)]
        pub unsafe fn issueMatcher(
            &self,
        ) -> NonNull<block2::DynBlock<dyn Fn(NonNull<XCTIssue>) -> Bool>>;

        #[cfg(feature = "block2")]
        /// Setter for [`issueMatcher`][Self::issueMatcher].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIssueMatcher:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIssueMatcher(
            &self,
            issue_matcher: &block2::DynBlock<dyn Fn(NonNull<XCTIssue>) -> Bool>,
        );

        /// For expected failures that only occur under certain circumstances, this flag can be used to
        /// disable the expected failure. In the closure-based variants of XCTExpectFailure, the failing block
        /// will be executed normally. Defaults to YES/true.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);

        /// If true (the default) and no issue is matched to the expected failure, then an issue will be
        /// recorded for the unmatched expected failure itself.
        #[unsafe(method(isStrict))]
        #[unsafe(method_family = none)]
        pub unsafe fn isStrict(&self) -> bool;

        /// Setter for [`isStrict`][Self::isStrict].
        #[unsafe(method(setStrict:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStrict(&self, strict: bool);

        /// Convenience factory method which returns a new instance of XCTExpectedFailureOptions that has `isStrict` set to NO, with every other value set to its default.
        #[unsafe(method(nonStrictOptions))]
        #[unsafe(method_family = none)]
        pub unsafe fn nonStrictOptions() -> Retained<XCTExpectedFailureOptions>;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTExpectedFailureOptions {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Contains the details about a single instance of an expected failure, including the failure
    /// reason and the underlying issue that was recorded.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctexpectedfailure?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTExpectedFailure;
);

extern_conformance!(
    unsafe impl NSCoding for XCTExpectedFailure {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTExpectedFailure {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for XCTExpectedFailure {}
);

impl XCTExpectedFailure {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// Explanation of the problem requiring the issue to be suppressed.
        #[unsafe(method(failureReason))]
        #[unsafe(method_family = none)]
        pub unsafe fn failureReason(&self) -> Option<Retained<NSString>>;

        /// The issue being suppressed.
        #[unsafe(method(issue))]
        #[unsafe(method_family = none)]
        pub unsafe fn issue(&self) -> Retained<XCTIssue>;
    );
}

/// Types of failures and other issues that can be reported for tests.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctissuetype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct XCTIssueType(pub NSInteger);
impl XCTIssueType {
    /// Issue raised by a failed XCTAssert or related API.
    #[doc(alias = "XCTIssueTypeAssertionFailure")]
    pub const AssertionFailure: Self = Self(0);
    /// Issue raised by the test throwing an error in Swift. This could also occur if an Objective C test is implemented in the form `- (BOOL)testFoo:(NSError **)outError` and returns NO with a non-nil out error.
    #[doc(alias = "XCTIssueTypeThrownError")]
    pub const ThrownError: Self = Self(1);
    /// Code in the test throws and does not catch an exception, Objective C, C++, or other.
    #[doc(alias = "XCTIssueTypeUncaughtException")]
    pub const UncaughtException: Self = Self(2);
    /// One of the XCTestCase(measure:) family of APIs detected a performance regression.
    #[doc(alias = "XCTIssueTypePerformanceRegression")]
    pub const PerformanceRegression: Self = Self(3);
    /// One of the framework APIs failed internally. For example, XCUIApplication was unable to launch or terminate an app or XCUIElementQuery was unable to complete a query.
    #[doc(alias = "XCTIssueTypeSystem")]
    pub const System: Self = Self(4);
    /// Issue raised when XCTExpectFailure is used but no matching issue is recorded.
    #[doc(alias = "XCTIssueTypeUnmatchedExpectedFailure")]
    pub const UnmatchedExpectedFailure: Self = Self(5);
}

unsafe impl Encode for XCTIssueType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for XCTIssueType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Encapsulates all data concerning a test failure or other issue.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctissue?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTIssue;
);

extern_conformance!(
    unsafe impl NSCoding for XCTIssue {}
);

extern_conformance!(
    unsafe impl NSCopying for XCTIssue {}
);

unsafe impl CopyingHelper for XCTIssue {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSMutableCopying for XCTIssue {}
);

unsafe impl MutableCopyingHelper for XCTIssue {
    type Result = XCTMutableIssue;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTIssue {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for XCTIssue {}
);

impl XCTIssue {
    extern_methods!(
        #[unsafe(method(initWithType:compactDescription:detailedDescription:sourceCodeContext:associatedError:attachments:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithType_compactDescription_detailedDescription_sourceCodeContext_associatedError_attachments(
            this: Allocated<Self>,
            r#type: XCTIssueType,
            compact_description: &NSString,
            detailed_description: Option<&NSString>,
            source_code_context: &XCTSourceCodeContext,
            associated_error: Option<&NSError>,
            attachments: &NSArray<XCTAttachment>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithType:compactDescription:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithType_compactDescription(
            this: Allocated<Self>,
            r#type: XCTIssueType,
            compact_description: &NSString,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// The type of the issue.
        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        pub unsafe fn r#type(&self) -> XCTIssueType;

        /// A concise description of the issue, expected to be free of transient data and suitable for use in test run
        /// summaries and for aggregation of results across multiple test runs.
        #[unsafe(method(compactDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn compactDescription(&self) -> Retained<NSString>;

        /// A detailed description of the issue designed to help diagnose the issue. May include transient data such as
        /// numbers, object identifiers, timestamps, etc.
        #[unsafe(method(detailedDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn detailedDescription(&self) -> Option<Retained<NSString>>;

        /// The source code location (file and line number) and the call stack associated with the issue.
        #[unsafe(method(sourceCodeContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceCodeContext(&self) -> Retained<XCTSourceCodeContext>;

        /// Error associated with the issue.
        #[unsafe(method(associatedError))]
        #[unsafe(method_family = none)]
        pub unsafe fn associatedError(&self) -> Option<Retained<NSError>>;

        /// All attachments associated with the issue.
        #[unsafe(method(attachments))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachments(&self) -> Retained<NSArray<XCTAttachment>>;
    );
}

extern_class!(
    /// Mutable variant of XCTIssue, suitable for modifying by overrides in the reporting chain.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctmutableissue?language=objc)
    #[unsafe(super(XCTIssue, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTMutableIssue;
);

extern_conformance!(
    unsafe impl NSCoding for XCTMutableIssue {}
);

extern_conformance!(
    unsafe impl NSCopying for XCTMutableIssue {}
);

unsafe impl CopyingHelper for XCTMutableIssue {
    type Result = XCTIssue;
}

extern_conformance!(
    unsafe impl NSMutableCopying for XCTMutableIssue {}
);

unsafe impl MutableCopyingHelper for XCTMutableIssue {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTMutableIssue {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for XCTMutableIssue {}
);

impl XCTMutableIssue {
    extern_methods!(
        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        pub unsafe fn r#type(&self) -> XCTIssueType;

        /// Setter for [`type`][Self::type].
        #[unsafe(method(setType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setType(&self, r#type: XCTIssueType);

        #[unsafe(method(compactDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn compactDescription(&self) -> Retained<NSString>;

        /// Setter for [`compactDescription`][Self::compactDescription].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCompactDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCompactDescription(&self, compact_description: &NSString);

        #[unsafe(method(detailedDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn detailedDescription(&self) -> Option<Retained<NSString>>;

        /// Setter for [`detailedDescription`][Self::detailedDescription].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDetailedDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDetailedDescription(&self, detailed_description: Option<&NSString>);

        #[unsafe(method(sourceCodeContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceCodeContext(&self) -> Retained<XCTSourceCodeContext>;

        /// Setter for [`sourceCodeContext`][Self::sourceCodeContext].
        #[unsafe(method(setSourceCodeContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSourceCodeContext(&self, source_code_context: &XCTSourceCodeContext);

        #[unsafe(method(associatedError))]
        #[unsafe(method_family = none)]
        pub unsafe fn associatedError(&self) -> Option<Retained<NSError>>;

        /// Setter for [`associatedError`][Self::associatedError].
        #[unsafe(method(setAssociatedError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAssociatedError(&self, associated_error: Option<&NSError>);

        #[unsafe(method(attachments))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachments(&self) -> Retained<NSArray<XCTAttachment>>;

        /// Setter for [`attachments`][Self::attachments].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAttachments:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAttachments(&self, attachments: &NSArray<XCTAttachment>);

        /// Add an attachment to this issue.
        #[unsafe(method(addAttachment:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addAttachment(&self, attachment: &XCTAttachment);
    );
}

/// Methods declared on superclass `XCTIssue`.
impl XCTMutableIssue {
    extern_methods!(
        #[unsafe(method(initWithType:compactDescription:detailedDescription:sourceCodeContext:associatedError:attachments:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithType_compactDescription_detailedDescription_sourceCodeContext_associatedError_attachments(
            this: Allocated<Self>,
            r#type: XCTIssueType,
            compact_description: &NSString,
            detailed_description: Option<&NSString>,
            source_code_context: &XCTSourceCodeContext,
            associated_error: Option<&NSError>,
            attachments: &NSArray<XCTAttachment>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithType:compactDescription:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithType_compactDescription(
            this: Allocated<Self>,
            r#type: XCTIssueType,
            compact_description: &NSString,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctmeasurementinvocationoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct XCTMeasurementInvocationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl XCTMeasurementInvocationOptions: NSUInteger {
        #[doc(alias = "XCTMeasurementInvocationNone")]
        const None = 0;
        #[doc(alias = "XCTMeasurementInvocationManuallyStart")]
        const ManuallyStart = 1<<0;
        #[doc(alias = "XCTMeasurementInvocationManuallyStop")]
        const ManuallyStop = 1<<1;
    }
}

unsafe impl Encode for XCTMeasurementInvocationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for XCTMeasurementInvocationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Collection of options which configures behavior when passed into the -[XCTMeasure measure*] APIs.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctmeasureoptions?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTMeasureOptions;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTMeasureOptions {}
);

impl XCTMeasureOptions {
    extern_methods!(
        /// Builds a set of recommended default options for measuring.
        ///
        ///
        /// Returns: An object which represents a set of default configuration options for measuring.
        #[unsafe(method(defaultOptions))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultOptions() -> Retained<XCTMeasureOptions>;

        /// Set of options which configure how measurements are taken. The default option is XCTMeasurementInvocationNone.
        #[unsafe(method(invocationOptions))]
        #[unsafe(method_family = none)]
        pub unsafe fn invocationOptions(&self) -> XCTMeasurementInvocationOptions;

        /// Setter for [`invocationOptions`][Self::invocationOptions].
        #[unsafe(method(setInvocationOptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInvocationOptions(
            &self,
            invocation_options: XCTMeasurementInvocationOptions,
        );

        /// The number of times the block being measured should be invoked. The default value is 5.
        /// Note that the block is actually invoked `iterationCount` + 1 times, and the first iteration
        /// is discarded. This is done to reduce the chance that the first iteration will be an outlier.
        #[unsafe(method(iterationCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn iterationCount(&self) -> NSUInteger;

        /// Setter for [`iterationCount`][Self::iterationCount].
        #[unsafe(method(setIterationCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIterationCount(&self, iteration_count: NSUInteger);
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTMeasureOptions {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/xctest/xctperformancemeasurementpolarity?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct XCTPerformanceMeasurementPolarity(pub NSInteger);
impl XCTPerformanceMeasurementPolarity {
    /// Represents measurements where smaller values are considered "better".
    #[doc(alias = "XCTPerformanceMeasurementPolarityPrefersSmaller")]
    pub const PrefersSmaller: Self = Self(-1);
    /// Represents measurements which do not have a meaningful polarity. Suitable for situations where neither smaller nor larger values are considered "better".
    #[doc(alias = "XCTPerformanceMeasurementPolarityUnspecified")]
    pub const Unspecified: Self = Self(0);
    /// Represents measurements where larger values are considered "better".
    #[doc(alias = "XCTPerformanceMeasurementPolarityPrefersLarger")]
    pub const PrefersLarger: Self = Self(1);
}

unsafe impl Encode for XCTPerformanceMeasurementPolarity {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for XCTPerformanceMeasurementPolarity {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Encapsulates timestamps at various levels
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctperformancemeasurementtimestamp?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTPerformanceMeasurementTimestamp;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTPerformanceMeasurementTimestamp {}
);

impl XCTPerformanceMeasurementTimestamp {
    extern_methods!(
        /// The timestamp recorded using mach_absolute_time().
        #[unsafe(method(absoluteTime))]
        #[unsafe(method_family = none)]
        pub unsafe fn absoluteTime(&self) -> u64;

        /// Nanoseconds since an arbitrary point, does not increment while the system is asleep.
        #[unsafe(method(absoluteTimeNanoSeconds))]
        #[unsafe(method_family = none)]
        pub unsafe fn absoluteTimeNanoSeconds(&self) -> u64;

        /// The timestamp recorded using an NSDate.
        #[unsafe(method(date))]
        #[unsafe(method_family = none)]
        pub unsafe fn date(&self) -> Retained<NSDate>;

        /// Initializes an object with the given mach absolute time and NSDate instance.
        #[unsafe(method(initWithAbsoluteTime:date:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAbsoluteTime_date(
            this: Allocated<Self>,
            absolute_time: u64,
            date: &NSDate,
        ) -> Retained<Self>;

        /// Initializes an object which represents a timestamp at the current time.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTPerformanceMeasurementTimestamp {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Contains the data acquired from a single metric being measured for an individual iteration.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctperformancemeasurement?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTPerformanceMeasurement;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTPerformanceMeasurement {}
);

impl XCTPerformanceMeasurement {
    extern_methods!(
        /// A unique identifier for this measurement such as "com.apple.XCTPerformanceMetric_WallClockTime".
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSString>;

        /// The human-readable name for this measurement, such as "Wall Clock Time".
        #[unsafe(method(displayName))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayName(&self) -> Retained<NSString>;

        /// The value of the measurement.
        #[unsafe(method(value))]
        #[unsafe(method_family = none)]
        pub unsafe fn value(&self) -> Retained<NSMeasurement>;

        /// The double value of the measurement.
        #[unsafe(method(doubleValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn doubleValue(&self) -> c_double;

        /// A string describing the unit the value is in.
        #[unsafe(method(unitSymbol))]
        #[unsafe(method_family = none)]
        pub unsafe fn unitSymbol(&self) -> Retained<NSString>;

        /// An enum value representing in which direction measurements should be compared against their baselines.
        #[unsafe(method(polarity))]
        #[unsafe(method_family = none)]
        pub unsafe fn polarity(&self) -> XCTPerformanceMeasurementPolarity;

        /// Initializes an object which encapsulates the measurement for a metric during a single iteration.
        ///
        ///
        /// Parameter `identifier`: A unique identifier for this measurement such as "com.apple.XCTPerformanceMetric_WallClockTime".
        ///
        /// Parameter `displayName`: A human-readable name for this measurement, such as "Wall Clock Time".
        ///
        /// Parameter `value`: The value of the measurement.
        #[unsafe(method(initWithIdentifier:displayName:value:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier_displayName_value(
            this: Allocated<Self>,
            identifier: &NSString,
            display_name: &NSString,
            value: &NSMeasurement,
        ) -> Retained<Self>;

        /// Initializes an object which encapsulates the measurement for a metric during a single iteration.
        ///
        ///
        /// Parameter `identifier`: A unique identifier for this measurement such as "com.apple.XCTPerformanceMetric_WallClockTime".
        ///
        /// Parameter `displayName`: A human-readable name for this measurement, such as "Wall Clock Time".
        ///
        /// Parameter `doubleValue`: The double value of the measurement.
        ///
        /// Parameter `unitSymbol`: A string describing the unit the value is in.
        #[unsafe(method(initWithIdentifier:displayName:doubleValue:unitSymbol:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier_displayName_doubleValue_unitSymbol(
            this: Allocated<Self>,
            identifier: &NSString,
            display_name: &NSString,
            double_value: c_double,
            unit_symbol: &NSString,
        ) -> Retained<Self>;

        /// Initializes an object which encapsulates the measurement for a metric during a single iteration.
        ///
        ///
        /// Parameter `identifier`: A unique identifier for this measurement such as "com.apple.XCTPerformanceMetric_WallClockTime".
        ///
        /// Parameter `displayName`: A human-readable name for this measurement, such as "Wall Clock Time".
        ///
        /// Parameter `value`: The value of the measurement.
        ///
        /// Parameter `polarity`: An enum value representing in which direction measurements should be compared against their baselines.
        #[unsafe(method(initWithIdentifier:displayName:value:polarity:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier_displayName_value_polarity(
            this: Allocated<Self>,
            identifier: &NSString,
            display_name: &NSString,
            value: &NSMeasurement,
            polarity: XCTPerformanceMeasurementPolarity,
        ) -> Retained<Self>;

        /// Initializes an object which encapsulates the measurement for a metric during a single iteration.
        ///
        ///
        /// Parameter `identifier`: A unique identifier for this measurement such as "com.apple.XCTPerformanceMetric_WallClockTime".
        ///
        /// Parameter `displayName`: A human-readable name for this measurement, such as "Wall Clock Time".
        ///
        /// Parameter `doubleValue`: The double value of the measurement.
        ///
        /// Parameter `unitSymbol`: A string describing the unit the value is in.
        ///
        /// Parameter `polarity`: An enum value representing in which direction measurements should be compared against their baselines.
        #[unsafe(method(initWithIdentifier:displayName:doubleValue:unitSymbol:polarity:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier_displayName_doubleValue_unitSymbol_polarity(
            this: Allocated<Self>,
            identifier: &NSString,
            display_name: &NSString,
            double_value: c_double,
            unit_symbol: &NSString,
            polarity: XCTPerformanceMeasurementPolarity,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Defines a protocol which may be used with the -measureWithMetrics* methods on XCTestCase.
    ///
    ///
    /// Classes conforming to XCTMetric must also adopt NSCopying, as a unique metric instance is copied for each iteration.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctmetric?language=objc)
    pub unsafe trait XCTMetric: NSCopying + NSObjectProtocol {
        /// Report measurements for the iteration that started and ended at the specified times.
        ///
        ///
        /// Called after -didStopMeasuring has been invoked and when XCTest is ready to gather
        /// the measurements that were collected. You can truncate the data accumulated to be as
        /// accurate as possible with the start and end times.
        #[unsafe(method(reportMeasurementsFromStartTime:toEndTime:error:_))]
        #[unsafe(method_family = none)]
        unsafe fn reportMeasurementsFromStartTime_toEndTime_error(
            &self,
            start_time: &XCTPerformanceMeasurementTimestamp,
            end_time: &XCTPerformanceMeasurementTimestamp,
        ) -> Result<Retained<NSArray<XCTPerformanceMeasurement>>, Retained<NSError>>;

        /// Called every iteration just before the measure block is about to be invoked.
        /// You should begin measuring when this is called.
        #[optional]
        #[unsafe(method(willBeginMeasuring))]
        #[unsafe(method_family = none)]
        unsafe fn willBeginMeasuring(&self);

        /// Called after the measure block's invocation. You should stop measuring when
        /// this is called.
        #[optional]
        #[unsafe(method(didStopMeasuring))]
        #[unsafe(method_family = none)]
        unsafe fn didStopMeasuring(&self);
    }
);

extern_class!(
    /// A metric which gathers monotonic time data.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctclockmetric?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTClockMetric;
);

extern_conformance!(
    unsafe impl NSCopying for XCTClockMetric {}
);

unsafe impl CopyingHelper for XCTClockMetric {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTClockMetric {}
);

extern_conformance!(
    unsafe impl XCTMetric for XCTClockMetric {}
);

impl XCTClockMetric {
    extern_methods!(
        /// Initializes a metric which is recommended for measuring time.
        ///
        ///
        /// Returns: A new instance of a metric which will measure time.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTClockMetric {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A metric which measures timestamp data gathered from os_signposts.
    /// If the interval being measured is an animation os_signpost interval then the following
    /// data will also be gathered:
    /// - frame rate (fps)
    /// - frame count
    /// - number of hitches
    /// - hitch total time duration (ms)
    /// - hitch time ratio (ms per s)
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctossignpostmetric?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTOSSignpostMetric;
);

extern_conformance!(
    unsafe impl NSCopying for XCTOSSignpostMetric {}
);

unsafe impl CopyingHelper for XCTOSSignpostMetric {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTOSSignpostMetric {}
);

extern_conformance!(
    unsafe impl XCTMetric for XCTOSSignpostMetric {}
);

impl XCTOSSignpostMetric {
    extern_methods!(
        /// Initializes a metric which describes a custom signpost.
        ///
        ///
        /// Parameter `subsystem`: The subsystem of the target signpost.
        ///
        /// Parameter `category`: The category of the target signpost.
        ///
        /// Parameter `name`: The name of the target signpost.
        ///
        /// Returns: A signpost metric describing the target signpost.
        #[unsafe(method(initWithSubsystem:category:name:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSubsystem_category_name(
            this: Allocated<Self>,
            subsystem: &NSString,
            category: &NSString,
            name: &NSString,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// XCTBuiltinOSSignposts.
///
/// Interface extension describing OS Signposts that are instrumented by the OS.
impl XCTOSSignpostMetric {
    extern_methods!(
        /// The XCTOSSignpostMetric object covering application launch
        #[deprecated = "Use XCTApplicationLaunchMetric instead"]
        #[unsafe(method(applicationLaunchMetric))]
        #[unsafe(method_family = none)]
        pub unsafe fn applicationLaunchMetric() -> Retained<XCTOSSignpostMetric>;

        /// The XCTMetric object covering navigation transitions between views
        #[unsafe(method(navigationTransitionMetric))]
        #[unsafe(method_family = none)]
        pub unsafe fn navigationTransitionMetric() -> Retained<ProtocolObject<dyn XCTMetric>>;

        /// The XCTMetric object covering custom navigation transitions between views
        #[unsafe(method(customNavigationTransitionMetric))]
        #[unsafe(method_family = none)]
        pub unsafe fn customNavigationTransitionMetric() -> Retained<ProtocolObject<dyn XCTMetric>>;

        /// The XCTMetric object covering both the scroll and deceleration animations
        #[unsafe(method(scrollingAndDecelerationMetric))]
        #[unsafe(method_family = none)]
        pub unsafe fn scrollingAndDecelerationMetric() -> Retained<ProtocolObject<dyn XCTMetric>>;

        /// The XCTMetric object covering scroll deceleration animations
        #[deprecated]
        #[unsafe(method(scrollDecelerationMetric))]
        #[unsafe(method_family = none)]
        pub unsafe fn scrollDecelerationMetric() -> Retained<ProtocolObject<dyn XCTMetric>>;

        /// The XCTMetric object covering scroll dragging animations
        #[deprecated]
        #[unsafe(method(scrollDraggingMetric))]
        #[unsafe(method_family = none)]
        pub unsafe fn scrollDraggingMetric() -> Retained<ProtocolObject<dyn XCTMetric>>;
    );
}

extern_class!(
    /// A metric which measures application launch durations.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctapplicationlaunchmetric?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTApplicationLaunchMetric;
);

extern_conformance!(
    unsafe impl NSCopying for XCTApplicationLaunchMetric {}
);

unsafe impl CopyingHelper for XCTApplicationLaunchMetric {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTApplicationLaunchMetric {}
);

extern_conformance!(
    unsafe impl XCTMetric for XCTApplicationLaunchMetric {}
);

impl XCTApplicationLaunchMetric {
    extern_methods!(
        /// Initializes an application launch metric that measures the amount of time an
        /// application takes to display its first frame to screen.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Initializes an application launch metric that measures the amount of time it takes
        /// for an application to display its first frame to screen and for its main thread to be
        /// ready to accept user input.
        ///
        ///
        /// Parameter `waitUntilResponsive`: Specifies the end of the application launch
        /// interval to be when the application's main thread is responsive to user input.
        #[unsafe(method(initWithWaitUntilResponsive:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithWaitUntilResponsive(
            this: Allocated<Self>,
            wait_until_responsive: bool,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTApplicationLaunchMetric {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A metric which measures instructions retired and time utilization of the CPU.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctcpumetric?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTCPUMetric;
);

extern_conformance!(
    unsafe impl NSCopying for XCTCPUMetric {}
);

unsafe impl CopyingHelper for XCTCPUMetric {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTCPUMetric {}
);

extern_conformance!(
    unsafe impl XCTMetric for XCTCPUMetric {}
);

impl XCTCPUMetric {
    extern_methods!(
        /// Creates a metric which will observe CPU activity for the thread that executes
        /// the block being measured. For single-threaded workloads, this provides greater
        /// precision and lower variance than -init.
        ///
        ///
        /// Note: The Thread under test is defined as the thread which will perform the execution of the work provided to the -[XCTestCase measure*] API.
        ///
        ///
        /// Returns: An initialized metric.
        #[unsafe(method(initLimitingToCurrentThread:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initLimitingToCurrentThread(
            this: Allocated<Self>,
            limit_to_current_thread: bool,
        ) -> Retained<Self>;

        /// Creates a metric that will target the current process.
        ///
        ///
        /// Returns: An initialized metric.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTCPUMetric {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A metric which measures utilization of physical memory.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctmemorymetric?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTMemoryMetric;
);

extern_conformance!(
    unsafe impl NSCopying for XCTMemoryMetric {}
);

unsafe impl CopyingHelper for XCTMemoryMetric {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTMemoryMetric {}
);

extern_conformance!(
    unsafe impl XCTMetric for XCTMemoryMetric {}
);

impl XCTMemoryMetric {
    extern_methods!(
        /// Creates a metric that will target the current process.
        ///
        ///
        /// Returns: An initialized metric.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTMemoryMetric {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A metric which measures utilization of the file storage media.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctstoragemetric?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTStorageMetric;
);

extern_conformance!(
    unsafe impl NSCopying for XCTStorageMetric {}
);

unsafe impl CopyingHelper for XCTStorageMetric {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTStorageMetric {}
);

extern_conformance!(
    unsafe impl XCTMetric for XCTStorageMetric {}
);

impl XCTStorageMetric {
    extern_methods!(
        /// Creates a metric that will target the current process.
        ///
        ///
        /// Returns: An initialized metric.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTStorageMetric {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Contains a file URL and line number representing a distinct location in source code related to a run of a test.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctsourcecodelocation?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTSourceCodeLocation;
);

extern_conformance!(
    unsafe impl NSCoding for XCTSourceCodeLocation {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTSourceCodeLocation {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for XCTSourceCodeLocation {}
);

impl XCTSourceCodeLocation {
    extern_methods!(
        #[unsafe(method(initWithFileURL:lineNumber:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithFileURL_lineNumber(
            this: Allocated<Self>,
            file_url: &NSURL,
            line_number: NSInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithFilePath:lineNumber:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithFilePath_lineNumber(
            this: Allocated<Self>,
            file_path: &NSString,
            line_number: NSInteger,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(fileURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileURL(&self) -> Retained<NSURL>;

        #[unsafe(method(lineNumber))]
        #[unsafe(method_family = none)]
        pub unsafe fn lineNumber(&self) -> NSInteger;
    );
}

extern_class!(
    /// Contains symbolication information for a given frame in a call stack.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctsourcecodesymbolinfo?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTSourceCodeSymbolInfo;
);

extern_conformance!(
    unsafe impl NSCoding for XCTSourceCodeSymbolInfo {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTSourceCodeSymbolInfo {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for XCTSourceCodeSymbolInfo {}
);

impl XCTSourceCodeSymbolInfo {
    extern_methods!(
        #[unsafe(method(initWithImageName:symbolName:location:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithImageName_symbolName_location(
            this: Allocated<Self>,
            image_name: &NSString,
            symbol_name: &NSString,
            location: Option<&XCTSourceCodeLocation>,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(imageName))]
        #[unsafe(method_family = none)]
        pub unsafe fn imageName(&self) -> Retained<NSString>;

        #[unsafe(method(symbolName))]
        #[unsafe(method_family = none)]
        pub unsafe fn symbolName(&self) -> Retained<NSString>;

        #[unsafe(method(location))]
        #[unsafe(method_family = none)]
        pub unsafe fn location(&self) -> Option<Retained<XCTSourceCodeLocation>>;
    );
}

extern_class!(
    /// Represents a single frame in a call stack and supports retrieval of symbol information for the address.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctsourcecodeframe?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTSourceCodeFrame;
);

extern_conformance!(
    unsafe impl NSCoding for XCTSourceCodeFrame {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTSourceCodeFrame {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for XCTSourceCodeFrame {}
);

impl XCTSourceCodeFrame {
    extern_methods!(
        #[unsafe(method(initWithAddress:symbolInfo:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAddress_symbolInfo(
            this: Allocated<Self>,
            address: u64,
            symbol_info: Option<&XCTSourceCodeSymbolInfo>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithAddress:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAddress(this: Allocated<Self>, address: u64) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(address))]
        #[unsafe(method_family = none)]
        pub unsafe fn address(&self) -> u64;

        #[unsafe(method(symbolInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn symbolInfo(&self) -> Option<Retained<XCTSourceCodeSymbolInfo>>;

        /// Error previously returned for symbolication attempt. This is not serialized when the frame is encoded.
        #[unsafe(method(symbolicationError))]
        #[unsafe(method_family = none)]
        pub unsafe fn symbolicationError(&self) -> Option<Retained<NSError>>;

        /// method -symbolInfoWithError:
        /// Attempts to get symbol information for the address. This can fail if required symbol data is not available. Only
        /// one attempt will be made and the error will be stored and returned for future requests.
        #[unsafe(method(symbolInfoWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn symbolInfoWithError(
            &self,
        ) -> Result<Retained<XCTSourceCodeSymbolInfo>, Retained<NSError>>;
    );
}

extern_class!(
    /// Call stack and optional specific location - which may or may not be also included in the call stack
    /// providing context around a point of execution in a test.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctsourcecodecontext?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTSourceCodeContext;
);

extern_conformance!(
    unsafe impl NSCoding for XCTSourceCodeContext {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTSourceCodeContext {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for XCTSourceCodeContext {}
);

impl XCTSourceCodeContext {
    extern_methods!(
        #[unsafe(method(initWithCallStack:location:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCallStack_location(
            this: Allocated<Self>,
            call_stack: &NSArray<XCTSourceCodeFrame>,
            location: Option<&XCTSourceCodeLocation>,
        ) -> Retained<Self>;

        /// The call stack addresses could be those from NSThread.callStackReturnAddresses,
        /// NSException.callStackReturnAddresses, or another source.
        #[unsafe(method(initWithCallStackAddresses:location:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCallStackAddresses_location(
            this: Allocated<Self>,
            call_stack_addresses: &NSArray<NSNumber>,
            location: Option<&XCTSourceCodeLocation>,
        ) -> Retained<Self>;

        /// Initializes a new instance with call stack derived from NSThread.callStackReturnAddresses and the specified location.
        #[unsafe(method(initWithLocation:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithLocation(
            this: Allocated<Self>,
            location: Option<&XCTSourceCodeLocation>,
        ) -> Retained<Self>;

        /// Initializes a new instance with call stack derived from NSThread.callStackReturnAddresses and a nil location.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(callStack))]
        #[unsafe(method_family = none)]
        pub unsafe fn callStack(&self) -> Retained<NSArray<XCTSourceCodeFrame>>;

        #[unsafe(method(location))]
        #[unsafe(method_family = none)]
        pub unsafe fn location(&self) -> Option<Retained<XCTSourceCodeLocation>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTSourceCodeContext {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Values returned by a waiter when it completes, times out, or is interrupted due to another waiter
/// higher in the call stack timing out.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctwaiterresult?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct XCTWaiterResult(pub NSInteger);
impl XCTWaiterResult {
    #[doc(alias = "XCTWaiterResultCompleted")]
    pub const Completed: Self = Self(1);
    #[doc(alias = "XCTWaiterResultTimedOut")]
    pub const TimedOut: Self = Self(2);
    #[doc(alias = "XCTWaiterResultIncorrectOrder")]
    pub const IncorrectOrder: Self = Self(3);
    #[doc(alias = "XCTWaiterResultInvertedFulfillment")]
    pub const InvertedFulfillment: Self = Self(4);
    #[doc(alias = "XCTWaiterResultInterrupted")]
    pub const Interrupted: Self = Self(5);
}

unsafe impl Encode for XCTWaiterResult {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for XCTWaiterResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Manages waiting - pausing the current execution context - for an array of XCTestExpectations. Waiters
    /// can be used with or without a delegate to respond to events such as completion, timeout, or invalid
    /// expectation fulfillment. XCTestCase conforms to the delegate protocol and will automatically report
    /// timeouts and other unexpected events as test failures.
    ///
    /// Waiters can be used without a delegate or any association with a test case instance. This allows test
    /// support libraries to provide convenience methods for waiting without having to pass test cases through
    /// those APIs.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctwaiter?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTWaiter;
);

unsafe impl Send for XCTWaiter {}

unsafe impl Sync for XCTWaiter {}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTWaiter {}
);

impl XCTWaiter {
    extern_methods!(
        /// Creates a new waiter with the specified delegate.
        #[unsafe(method(initWithDelegate:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDelegate(
            this: Allocated<Self>,
            delegate: Option<&ProtocolObject<dyn XCTWaiterDelegate>>,
        ) -> Retained<Self>;

        /// The waiter delegate will be called with various events described in
        /// <XCTWaiterDelegate
        /// >.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn XCTWaiterDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn XCTWaiterDelegate>>);

        /// Returns an array containing the expectations that were fulfilled, in that order, up until the waiter
        /// stopped waiting. Expectations fulfilled after the waiter stopped waiting will not be in the array.
        /// The array will be empty until the waiter has started waiting, even if expectations have already been
        /// fulfilled. If a waiter is used to wait multiple times, this array will contain all of the
        /// fulfilled expectations from each wait operation.
        #[unsafe(method(fulfilledExpectations))]
        #[unsafe(method_family = none)]
        pub unsafe fn fulfilledExpectations(&self) -> Retained<NSArray<XCTestExpectation>>;

        /// Waits on a group of expectations indefinitely.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// The test will continue to run until
        /// _expectations_are fulfilled or the
        /// test reaches its execution time allowance.
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        /// Enabling test timeouts is recommended when using this method to prevent a
        /// runaway expectation from hanging the test.
        ///
        ///
        /// Returns: A value describing the outcome of waiting for
        /// _expectations._
        #[unsafe(method(waitForExpectations:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations(
            &self,
            expectations: &NSArray<XCTestExpectation>,
        ) -> XCTWaiterResult;

        /// Waits on a group of expectations for up to the specified timeout.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// Parameter `seconds`: The number of seconds within which all expectations must be fulfilled.
        ///
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        ///
        /// Returns: A value describing the outcome of waiting for
        /// _expectations._
        #[unsafe(method(waitForExpectations:timeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_timeout(
            &self,
            expectations: &NSArray<XCTestExpectation>,
            seconds: NSTimeInterval,
        ) -> XCTWaiterResult;

        /// Waits on a group of expectations indefinitely, optionally enforcing their
        /// order of fulfillment.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// Parameter `enforceOrderOfFulfillment`: If
        /// `YES,`the expectations specified by the
        /// _expectations_parameter must
        /// be satisfied in the order they appear in the array.
        ///
        ///
        /// The test will continue to run until
        /// _expectations_are fulfilled or the
        /// test reaches its execution time allowance.
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        /// Enabling test timeouts is recommended when using this method to prevent a
        /// runaway expectation from hanging the test.
        ///
        ///
        /// Returns: A value describing the outcome of waiting for
        /// _expectations._
        #[unsafe(method(waitForExpectations:enforceOrder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_enforceOrder(
            &self,
            expectations: &NSArray<XCTestExpectation>,
            enforce_order_of_fulfillment: bool,
        ) -> XCTWaiterResult;

        /// Waits on a group of expectations for up to the specified timeout, optionally
        /// enforcing their order of fulfillment.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// Parameter `seconds`: The number of seconds within which all expectations must be fulfilled.
        ///
        ///
        /// Parameter `enforceOrderOfFulfillment`: If
        /// `YES,`the expectations specified by the
        /// _expectations_parameter must
        /// be satisfied in the order they appear in the array.
        ///
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        ///
        /// Returns: A value describing the outcome of waiting for
        /// _expectations._
        #[unsafe(method(waitForExpectations:timeout:enforceOrder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_timeout_enforceOrder(
            &self,
            expectations: &NSArray<XCTestExpectation>,
            seconds: NSTimeInterval,
            enforce_order_of_fulfillment: bool,
        ) -> XCTWaiterResult;

        /// Creates a waiter that waits on a group of expectations indefinitely.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// The test will continue to run until
        /// _expectations_are fulfilled or the
        /// test reaches its execution time allowance.
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        /// Enabling test timeouts is recommended when using this method to prevent a
        /// runaway expectation from hanging the test.
        ///
        /// The waiter is discarded when the wait completes.
        ///
        ///
        /// Returns: A value describing the outcome of waiting for
        /// _expectations._
        #[must_use]
        #[unsafe(method(waitForExpectations:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_class(
            expectations: &NSArray<XCTestExpectation>,
        ) -> XCTWaiterResult;

        /// Creates a waiter that waits on a group of expectations for up to the
        /// specified timeout.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// Parameter `seconds`: The number of seconds within which all expectations must be fulfilled.
        ///
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        /// The waiter is discarded when the wait completes.
        ///
        ///
        /// Returns: A value describing the outcome of waiting for
        /// _expectations._
        #[must_use]
        #[unsafe(method(waitForExpectations:timeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_timeout_class(
            expectations: &NSArray<XCTestExpectation>,
            seconds: NSTimeInterval,
        ) -> XCTWaiterResult;

        /// Creates a waiter that waits on a group of expectations indefinitely,
        /// optionally enforcing their order of fulfillment.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// Parameter `enforceOrderOfFulfillment`: If
        /// `YES,`the expectations specified by the
        /// _expectations_parameter must
        /// be satisfied in the order they appear in the array.
        ///
        ///
        /// The test will continue to run until
        /// _expectations_are fulfilled or the
        /// test reaches its execution time allowance.
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        /// Enabling test timeouts is recommended when using this method to prevent a
        /// runaway expectation from hanging the test.
        ///
        /// The waiter is discarded when the wait completes.
        ///
        ///
        /// Returns: A value describing the outcome of waiting for
        /// _expectations._
        #[must_use]
        #[unsafe(method(waitForExpectations:enforceOrder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_enforceOrder_class(
            expectations: &NSArray<XCTestExpectation>,
            enforce_order_of_fulfillment: bool,
        ) -> XCTWaiterResult;

        /// Creates a waiter that waits on a group of expectations for up to the
        /// specified timeout, optionally enforcing their order of fulfillment.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// Parameter `seconds`: The number of seconds within which all expectations must be fulfilled.
        ///
        ///
        /// Parameter `enforceOrderOfFulfillment`: If
        /// `YES,`the expectations specified by the
        /// _expectations_parameter must
        /// be satisfied in the order they appear in the array.
        ///
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        /// The waiter is discarded when the wait completes.
        ///
        ///
        /// Returns: A value describing the outcome of waiting for
        /// _expectations._
        #[must_use]
        #[unsafe(method(waitForExpectations:timeout:enforceOrder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_timeout_enforceOrder_class(
            expectations: &NSArray<XCTestExpectation>,
            seconds: NSTimeInterval,
            enforce_order_of_fulfillment: bool,
        ) -> XCTWaiterResult;
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTWaiter {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Events are reported to the waiter's delegate via these methods. XCTestCase conforms to the delegate
    /// protocol and will automatically report timeouts and other unexpected events as test failures.
    ///
    ///
    /// Note: These methods are invoked on an arbitrary queue.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctwaiterdelegate?language=objc)
    pub unsafe trait XCTWaiterDelegate: NSObjectProtocol {
        /// Invoked when not all waited on expectations are fulfilled during the timeout period. If the delegate
        /// is an XCTestCase instance, this will be reported as a test failure.
        #[optional]
        #[unsafe(method(waiter:didTimeoutWithUnfulfilledExpectations:))]
        #[unsafe(method_family = none)]
        unsafe fn waiter_didTimeoutWithUnfulfilledExpectations(
            &self,
            waiter: &XCTWaiter,
            unfulfilled_expectations: &NSArray<XCTestExpectation>,
        );

        /// Invoked when the -wait call has specified that fulfillment order should be enforced and an expectation
        /// has been fulfilled in the wrong order. If the delegate is an XCTestCase instance, this will be reported
        /// as a test failure.
        #[optional]
        #[unsafe(method(waiter:fulfillmentDidViolateOrderingConstraintsForExpectation:requiredExpectation:))]
        #[unsafe(method_family = none)]
        unsafe fn waiter_fulfillmentDidViolateOrderingConstraintsForExpectation_requiredExpectation(
            &self,
            waiter: &XCTWaiter,
            expectation: &XCTestExpectation,
            required_expectation: &XCTestExpectation,
        );

        /// Invoked when an expectation marked as inverted (/see inverted) is fulfilled. If the delegate is an
        /// XCTestCase instance, this will be reported as a test failure.
        #[optional]
        #[unsafe(method(waiter:didFulfillInvertedExpectation:))]
        #[unsafe(method_family = none)]
        unsafe fn waiter_didFulfillInvertedExpectation(
            &self,
            waiter: &XCTWaiter,
            expectation: &XCTestExpectation,
        );

        /// Invoked when the waiter is interrupted prior to its expectations being fulfilled or timing out.
        /// This occurs when an "outer" waiter times out, resulting in any waiters nested inside it being
        /// interrupted to allow the call stack to quickly unwind.
        #[optional]
        #[unsafe(method(nestedWaiter:wasInterruptedByTimedOutWaiter:))]
        #[unsafe(method_family = none)]
        unsafe fn nestedWaiter_wasInterruptedByTimedOutWaiter(
            &self,
            waiter: &XCTWaiter,
            outer_waiter: &XCTWaiter,
        );
    }
);

extern_class!(
    /// Expectations represent specific conditions in asynchronous testing.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctestexpectation?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTestExpectation;
);

unsafe impl Send for XCTestExpectation {}

unsafe impl Sync for XCTestExpectation {}

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTestExpectation {}
);

impl XCTestExpectation {
    extern_methods!(
        /// Designated initializer, requires a nonnull description of the condition the expectation is checking.
        #[unsafe(method(initWithDescription:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDescription(
            this: Allocated<Self>,
            expectation_description: &NSString,
        ) -> Retained<Self>;

        /// The human readable string used to describe the expectation in log output and test reports.
        #[unsafe(method(expectationDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectationDescription(&self) -> Retained<NSString>;

        /// Setter for [`expectationDescription`][Self::expectationDescription].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExpectationDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExpectationDescription(&self, expectation_description: &NSString);

        /// If an expectation is set to have inverted behavior, then fulfilling it will have a similar effect that
        /// failing to fulfill a conventional expectation has, as handled by the waiter and its delegate. Furthermore,
        /// waiters that wait on an inverted expectation will allow the full timeout to elapse and not report
        /// timeout to the delegate if it is not fulfilled.
        #[unsafe(method(isInverted))]
        #[unsafe(method_family = none)]
        pub unsafe fn isInverted(&self) -> bool;

        /// Setter for [`isInverted`][Self::isInverted].
        #[unsafe(method(setInverted:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInverted(&self, inverted: bool);

        /// The expectedFulfillmentCount is the number of times -fulfill must be called on the expectation in order for it
        /// to report complete fulfillment to its waiter. By default, expectations have an expectedFufillmentCount of 1.
        /// This value must be greater than 0 and is not meaningful if combined with
        /// @
        /// inverted.
        #[unsafe(method(expectedFulfillmentCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectedFulfillmentCount(&self) -> NSUInteger;

        /// Setter for [`expectedFulfillmentCount`][Self::expectedFulfillmentCount].
        #[unsafe(method(setExpectedFulfillmentCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExpectedFulfillmentCount(&self, expected_fulfillment_count: NSUInteger);

        /// If set, calls to fulfill() after the expectation has already been fulfilled - exceeding the fulfillment
        /// count - will raise. This is the legacy behavior of expectations created through APIs on XCTestCase
        /// but is not enabled for expectations created using XCTestExpectation initializers.
        #[unsafe(method(assertForOverFulfill))]
        #[unsafe(method_family = none)]
        pub unsafe fn assertForOverFulfill(&self) -> bool;

        /// Setter for [`assertForOverFulfill`][Self::assertForOverFulfill].
        #[unsafe(method(setAssertForOverFulfill:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAssertForOverFulfill(&self, assert_for_over_fulfill: bool);

        /// Call -fulfill to mark an expectation as having been met. It's an error to call -fulfill on an
        /// expectation more times than its `expectedFulfillmentCount` value specifies, or when the test case
        /// that vended the expectation has already completed. If `assertForOverFulfill` is set when either
        /// of these occur, -fulfill will raise an exception.
        #[unsafe(method(fulfill))]
        #[unsafe(method_family = none)]
        pub unsafe fn fulfill(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl XCTestExpectation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// A block to be invoked when a change is observed for the keyPath of the observed object.
///
///
/// Parameter `observedObject`: The observed object, provided to avoid block capture issues.
///
///
/// Parameter `change`: The KVO change dictionary.
///
///
/// Returns: Return YES if the expectation is fulfilled, NO if it is not.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xckeyvalueobservingexpectationhandler?language=objc)
#[cfg(feature = "block2")]
pub type XCKeyValueObservingExpectationHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<AnyObject>, NonNull<NSDictionary>) -> Bool>;

extern_class!(
    /// Expectation subclass for waiting on a condition defined Key Value Observation of a key path for an object.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctkvoexpectation?language=objc)
    #[unsafe(super(XCTestExpectation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTKVOExpectation;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTKVOExpectation {}
);

impl XCTKVOExpectation {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithDescription:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDescription(
            this: Allocated<Self>,
            expectation_description: &NSString,
        ) -> Retained<Self>;

        /// Initializes an expectation that is fulfilled when a key value coding compliant change is made such
        /// that the specified key path of the observed object has the expected value.
        #[unsafe(method(initWithKeyPath:object:expectedValue:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithKeyPath_object_expectedValue_options(
            this: Allocated<Self>,
            key_path: &NSString,
            object: &AnyObject,
            expected_value: Option<&AnyObject>,
            options: NSKeyValueObservingOptions,
        ) -> Retained<Self>;

        /// Initializes an expectation that is fulfilled when a key value coding compliant change is made such
        /// that the specified key path of the observed object has the expected value. The NSKeyValueObservingOptions
        /// passed for this initializer include NSKeyValueObservingOptionInitial, so the object/key path will be
        /// checked immediately. The options also include NSKeyValueObservingOptionNew and NSKeyValueObservingOptionOld,
        /// so if a handler is used the change dictionary passed to it will contain NSKeyValueChangeNewKey and
        /// NSKeyValueChangeOldKey entries.
        #[unsafe(method(initWithKeyPath:object:expectedValue:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithKeyPath_object_expectedValue(
            this: Allocated<Self>,
            key_path: &NSString,
            object: &AnyObject,
            expected_value: Option<&AnyObject>,
        ) -> Retained<Self>;

        /// Convenience initializer that is fulfilled by any change to the specified key path of the observed object.
        /// The NSKeyValueObservingOptions passed for this initializer do not include NSKeyValueObservingOptionInitial
        /// since there is no value to check. If that behavior is desired in conjunction with a handler, use the
        /// designated initializer. The options do include NSKeyValueObservingOptionNew and NSKeyValueObservingOptionOld,
        /// so if a handler is used the change dictionary passed to it will contain NSKeyValueChangeNewKey and
        /// NSKeyValueChangeOldKey entries.
        #[unsafe(method(initWithKeyPath:object:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithKeyPath_object(
            this: Allocated<Self>,
            key_path: &NSString,
            object: &AnyObject,
        ) -> Retained<Self>;

        /// Returns the key path that is being monitored for the KVO change.
        #[unsafe(method(keyPath))]
        #[unsafe(method_family = none)]
        pub unsafe fn keyPath(&self) -> Retained<NSString>;

        /// Returns the object that is being monitored for the KVO change.
        #[unsafe(method(observedObject))]
        #[unsafe(method_family = none)]
        pub unsafe fn observedObject(&self) -> Retained<AnyObject>;

        /// Returns the value that the expectation is waiting for the observed object/key path to have.
        #[unsafe(method(expectedValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectedValue(&self) -> Option<Retained<AnyObject>>;

        /// The KVO options used when the expectation registered for observation.
        #[unsafe(method(options))]
        #[unsafe(method_family = none)]
        pub unsafe fn options(&self) -> NSKeyValueObservingOptions;

        #[cfg(feature = "block2")]
        /// Allows the caller to install a special handler to do custom evaluation of the change to the value
        /// of the object/key path. If a handler is set, expectedValue will be ignored.
        #[unsafe(method(handler))]
        #[unsafe(method_family = none)]
        pub unsafe fn handler(&self) -> XCKeyValueObservingExpectationHandler;

        #[cfg(feature = "block2")]
        /// Setter for [`handler`][Self::handler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHandler(&self, handler: XCKeyValueObservingExpectationHandler);
    );
}

/// A block to be invoked when a notification matching the specified name is observed
/// from the object.
///
///
/// Parameter `notification`: The notification object.
///
///
/// Returns: Return YES if the expectation is fulfilled, NO if it is not.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xcnotificationexpectationhandler?language=objc)
#[cfg(feature = "block2")]
pub type XCNotificationExpectationHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<NSNotification>) -> Bool>;

extern_class!(
    /// Expectation subclass for waiting on a condition defined by an NSNotification.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctnsnotificationexpectation?language=objc)
    #[unsafe(super(XCTestExpectation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTNSNotificationExpectation;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTNSNotificationExpectation {}
);

impl XCTNSNotificationExpectation {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithDescription:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDescription(
            this: Allocated<Self>,
            expectation_description: &NSString,
        ) -> Retained<Self>;

        /// Initializes an expectation that waits for an NSNotification to be posted by an optional object from
        /// a given notification center.
        #[unsafe(method(initWithName:object:notificationCenter:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName_object_notificationCenter(
            this: Allocated<Self>,
            notification_name: &NSNotificationName,
            object: Option<&AnyObject>,
            notification_center: &NSNotificationCenter,
        ) -> Retained<Self>;

        /// Initializes an expectation that waits for an NSNotification to be posted by an optional object from
        /// the default notification center.
        #[unsafe(method(initWithName:object:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName_object(
            this: Allocated<Self>,
            notification_name: &NSNotificationName,
            object: Option<&AnyObject>,
        ) -> Retained<Self>;

        /// Initializes an expectation that waits for an NSNotification to be posted by any object from
        /// the default notification center.
        #[unsafe(method(initWithName:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName(
            this: Allocated<Self>,
            notification_name: &NSNotificationName,
        ) -> Retained<Self>;

        /// Returns the name of the notification being waited on.
        #[unsafe(method(notificationName))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationName(&self) -> Retained<NSNotificationName>;

        /// Returns the object that will post the notification.
        #[unsafe(method(observedObject))]
        #[unsafe(method_family = none)]
        pub unsafe fn observedObject(&self) -> Option<Retained<AnyObject>>;

        /// Returns the notification center that is being used.
        #[unsafe(method(notificationCenter))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationCenter(&self) -> Retained<NSNotificationCenter>;

        #[cfg(feature = "block2")]
        /// Allows the caller to install a special handler to do custom evaluation of received notifications
        /// matching the specified object and notification center.
        #[unsafe(method(handler))]
        #[unsafe(method_family = none)]
        pub unsafe fn handler(&self) -> XCNotificationExpectationHandler;

        #[cfg(feature = "block2")]
        /// Setter for [`handler`][Self::handler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHandler(&self, handler: XCNotificationExpectationHandler);
    );
}

/// Handler called when evaluating the predicate against the object returns true. If the handler is not
/// provided the first successful evaluation will fulfill the expectation. If provided, the handler will
/// be queried each time the notification is received to determine whether the expectation should be fulfilled
/// or not.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xcpredicateexpectationhandler?language=objc)
#[cfg(feature = "block2")]
pub type XCPredicateExpectationHandler = *mut block2::DynBlock<dyn Fn() -> Bool>;

extern_class!(
    /// Expectation subclass for waiting on a condition defined by an NSPredicate and an object.
    ///
    /// When an instance of this class is used from Swift and is awaited using
    /// `fulfillment(of:)`rather than
    /// `wait(for:),`XCTest evaluates the associated predicate on the main actor.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctnspredicateexpectation?language=objc)
    #[unsafe(super(XCTestExpectation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTNSPredicateExpectation;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTNSPredicateExpectation {}
);

impl XCTNSPredicateExpectation {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithDescription:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDescription(
            this: Allocated<Self>,
            expectation_description: &NSString,
        ) -> Retained<Self>;

        /// Initializes an expectation that waits for a predicate to evaluate as true with the provided object.
        ///
        /// When an instance of this class is used from Swift and is awaited using
        /// `fulfillment(of:)`rather than
        /// `wait(for:),`XCTest evaluates
        /// _predicate_on the main actor.
        #[unsafe(method(initWithPredicate:object:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPredicate_object(
            this: Allocated<Self>,
            predicate: &NSPredicate,
            object: Option<&AnyObject>,
        ) -> Retained<Self>;

        /// Returns the predicate used by the expectation.
        #[unsafe(method(predicate))]
        #[unsafe(method_family = none)]
        pub unsafe fn predicate(&self) -> Retained<NSPredicate>;

        /// Returns the object against which the predicate is evaluated.
        #[unsafe(method(object))]
        #[unsafe(method_family = none)]
        pub unsafe fn object(&self) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "block2")]
        /// Allows the caller to install a special handler to do custom evaluation of predicate and its object.
        #[unsafe(method(handler))]
        #[unsafe(method_family = none)]
        pub unsafe fn handler(&self) -> XCPredicateExpectationHandler;

        #[cfg(feature = "block2")]
        /// Setter for [`handler`][Self::handler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHandler(&self, handler: XCPredicateExpectationHandler);

        /// Unavailable on this class; XCTNSPredicateExpectation repeatedly evaluates its predicate until it becomes
        /// true. Once the predicate has become true, it is expected to remain true and will not be evaluated again.
        /// Setting expectedFulfillmentCount has no impact on fulfillment of the expectation.
        #[unsafe(method(expectedFulfillmentCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectedFulfillmentCount(&self) -> NSUInteger;

        /// Setter for [`expectedFulfillmentCount`][Self::expectedFulfillmentCount].
        #[unsafe(method(setExpectedFulfillmentCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExpectedFulfillmentCount(&self, expected_fulfillment_count: NSUInteger);
    );
}

/// A block to be invoked when a call to -waitForExpectationsWithTimeout:handler: times out or has
/// had all associated expectations fulfilled.
///
///
/// Parameter `error`: If the wait timed out or a failure was raised while waiting, the error's code
/// will specify the type of failure. Otherwise error will be nil.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xcwaitcompletionhandler?language=objc)
#[cfg(feature = "block2")]
pub type XCWaitCompletionHandler = *mut block2::DynBlock<dyn Fn(*mut NSError)>;

/// AsynchronousTesting.
///
/// This category introduces support for asynchronous testing in XCTestCase. The mechanism
/// allows you to specify one or more "expectations" that will occur asynchronously
/// as a result of actions in the test. Once all expectations have been set, a "wait"
/// API is called that will block execution of subsequent test code until all expected
/// conditions have been fulfilled or a timeout occurs.
impl XCTestCase {
    extern_methods!(
        /// Parameter `description`: This string will be displayed in the test log to help diagnose failures.
        ///
        ///
        /// Creates and returns an expectation associated with the test case.
        #[must_use]
        #[unsafe(method(expectationWithDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectationWithDescription(
            &self,
            description: &NSString,
        ) -> Retained<XCTestExpectation>;

        #[cfg(feature = "block2")]
        /// Parameter `timeout`: The amount of time within which all expectations must be fulfilled.
        ///
        ///
        /// Parameter `handler`: If provided, the handler will be invoked both on timeout or fulfillment of all
        /// expectations. Timeout is always treated as a test failure.
        ///
        ///
        /// -waitForExpectationsWithTimeout:handler: creates a point of synchronization in the flow of a
        /// test. Only one -waitForExpectationsWithTimeout:handler: can be active at any given time, but
        /// multiple discrete sequences of { expectations -> wait } can be chained together.
        ///
        /// -waitForExpectationsWithTimeout:handler: runs the run loop while handling events until all expectations
        /// are fulfilled or the timeout is reached. Clients should not manipulate the run
        /// loop while using this API.
        #[unsafe(method(waitForExpectationsWithTimeout:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectationsWithTimeout_handler(
            &self,
            timeout: NSTimeInterval,
            handler: XCWaitCompletionHandler,
            mtm: MainThreadMarker,
        );

        /// Waits on a group of expectations indefinitely.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// The test will continue to run until
        /// _expectations_are fulfilled or the
        /// test reaches its execution time allowance.
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        /// Enabling test timeouts is recommended when using this method to prevent a
        /// runaway expectation from hanging the test.
        #[unsafe(method(waitForExpectations:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations(&self, expectations: &NSArray<XCTestExpectation>);

        /// Waits on a group of expectations for up to the specified timeout.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// Parameter `seconds`: The number of seconds within which all expectations must be fulfilled.
        ///
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        #[unsafe(method(waitForExpectations:timeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_timeout(
            &self,
            expectations: &NSArray<XCTestExpectation>,
            seconds: NSTimeInterval,
        );

        /// Waits on a group of expectations indefinitely, optionally enforcing their
        /// order of fulfillment.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// Parameter `enforceOrderOfFulfillment`: If
        /// `YES,`the expectations specified by the
        /// _expectations_parameter must
        /// be satisfied in the order they appear in the array.
        ///
        ///
        /// The test will continue to run until
        /// _expectations_are fulfilled or the
        /// test reaches its execution time allowance.
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        ///
        /// Enabling test timeouts is recommended when using this method to prevent a
        /// runaway expectation from hanging the test.
        #[unsafe(method(waitForExpectations:enforceOrder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_enforceOrder(
            &self,
            expectations: &NSArray<XCTestExpectation>,
            enforce_order_of_fulfillment: bool,
        );

        /// Waits on a group of expectations for up to the specified timeout, optionally
        /// enforcing their order of fulfillment.
        ///
        ///
        /// Parameter `expectations`: An array of expectations that must be fulfilled.
        ///
        ///
        /// Parameter `seconds`: The number of seconds within which all expectations must be fulfilled.
        ///
        ///
        /// Parameter `enforceOrderOfFulfillment`: If
        /// `YES,`the expectations specified by the
        /// _expectations_parameter must
        /// be satisfied in the order they appear in the array.
        ///
        ///
        /// Expectations can only appear in the list once. This method may return
        /// early based on fulfillment of the provided expectations.
        #[unsafe(method(waitForExpectations:timeout:enforceOrder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn waitForExpectations_timeout_enforceOrder(
            &self,
            expectations: &NSArray<XCTestExpectation>,
            seconds: NSTimeInterval,
            enforce_order_of_fulfillment: bool,
        );

        /// A convenience method for asynchronous tests that use Key Value Observing to detect changes
        /// to values on an object. This variant takes an expected value and observes changes on the object
        /// until the keyPath's value matches the expected value using -[NSObject isEqual:]. If
        /// other comparisons are needed, use the variant below that takes a handler block.
        ///
        ///
        /// Parameter `objectToObserve`: The object to observe.
        ///
        ///
        /// Parameter `keyPath`: The key path to observe.
        ///
        ///
        /// Parameter `expectedValue`: Expected value of the keyPath for the object. The expectation will fulfill itself when the
        /// keyPath is equal, as tested using -[NSObject isEqual:]. If nil, the expectation will be
        /// fulfilled by the first change to the key path of the observed object.
        ///
        ///
        /// Returns: Creates and returns an expectation associated with the test case.
        #[unsafe(method(keyValueObservingExpectationForObject:keyPath:expectedValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn keyValueObservingExpectationForObject_keyPath_expectedValue(
            &self,
            object_to_observe: &AnyObject,
            key_path: &NSString,
            expected_value: Option<&AnyObject>,
        ) -> Retained<XCTestExpectation>;

        #[cfg(feature = "block2")]
        /// Variant of the convenience for tests that use Key Value Observing. Takes a handler
        /// block instead of an expected value. Every KVO change will run the handler block until
        /// it returns YES (or the wait times out). Returning YES from the block will fulfill the
        /// expectation. XCTAssert and related APIs can be used in the block to report a failure.
        ///
        ///
        /// Parameter `objectToObserve`: The object to observe.
        ///
        ///
        /// Parameter `keyPath`: The key path to observe.
        ///
        ///
        /// Parameter `handler`: Optional handler, /see XCKeyValueObservingExpectationHandler. If not provided, the expectation will
        /// be fulfilled by the first change to the key path of the observed object.
        ///
        ///
        /// Returns: Creates and returns an expectation associated with the test case.
        #[unsafe(method(keyValueObservingExpectationForObject:keyPath:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn keyValueObservingExpectationForObject_keyPath_handler(
            &self,
            object_to_observe: &AnyObject,
            key_path: &NSString,
            handler: XCKeyValueObservingExpectationHandler,
        ) -> Retained<XCTestExpectation>;

        #[cfg(feature = "block2")]
        /// A convenience method for asynchronous tests that observe NSNotifications from the default
        /// NSNotificationCenter.
        ///
        ///
        /// Parameter `notificationName`: The notification to register for.
        ///
        ///
        /// Parameter `objectToObserve`: The object to observe.
        ///
        ///
        /// Parameter `handler`: Optional handler, /see XCNotificationExpectationHandler. If not provided, the expectation
        /// will be fulfilled by the first notification matching the specified name from the
        /// observed object.
        ///
        ///
        /// Returns: Creates and returns an expectation associated with the test case.
        #[unsafe(method(expectationForNotification:object:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectationForNotification_object_handler(
            &self,
            notification_name: &NSNotificationName,
            object_to_observe: Option<&AnyObject>,
            handler: XCNotificationExpectationHandler,
        ) -> Retained<XCTestExpectation>;

        #[cfg(feature = "block2")]
        /// A convenience method for asynchronous tests that observe NSNotifications from a specific
        /// NSNotificationCenter.
        ///
        ///
        /// Parameter `notificationName`: The notification to register for.
        ///
        ///
        /// Parameter `objectToObserve`: The object to observe.
        ///
        ///
        /// Parameter `notificationCenter`: The notification center from which to observe the notification.
        ///
        ///
        /// Parameter `handler`: Optional handler, /see XCNotificationExpectationHandler. If not provided, the expectation
        /// will be fulfilled by the first notification matching the specified name from the
        /// observed object.
        ///
        ///
        /// Returns: Creates and returns an expectation associated with the test case.
        #[unsafe(method(expectationForNotification:object:notificationCenter:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectationForNotification_object_notificationCenter_handler(
            &self,
            notification_name: &NSNotificationName,
            object_to_observe: Option<&AnyObject>,
            notification_center: &NSNotificationCenter,
            handler: XCNotificationExpectationHandler,
        ) -> Retained<XCTestExpectation>;

        #[cfg(feature = "block2")]
        /// Creates an expectation that is fulfilled if the predicate returns true when evaluated with the given
        /// object. The expectation periodically evaluates the predicate and also may use notifications or other
        /// events to optimistically re-evaluate.
        ///
        /// When the resulting expectation is used from Swift and is awaited using
        /// `fulfillment(of:)`rather
        /// than
        /// `wait(for:),`XCTest evaluates
        /// _predicate_on the main actor.
        #[unsafe(method(expectationForPredicate:evaluatedWithObject:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectationForPredicate_evaluatedWithObject_handler(
            &self,
            predicate: &NSPredicate,
            object: Option<&AnyObject>,
            handler: XCPredicateExpectationHandler,
        ) -> Retained<XCTestExpectation>;
    );
}

extern_conformance!(
    unsafe impl XCTWaiterDelegate for XCTestCase {}
);

/// Handler called when the expectation has received the Darwin notification. If the handler is not
/// provided the first posting of the notification will fulfill the expectation. If provided, the handler
/// will be queried each time the notification is received to determine whether the expectation should
/// be fulfilled or not. This allows the caller to check Darwin state variables or perform other logic
/// beyond simply verifying that the notification has been posted.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctdarwinnotificationexpectationhandler?language=objc)
#[cfg(feature = "block2")]
pub type XCTDarwinNotificationExpectationHandler = *mut block2::DynBlock<dyn Fn() -> Bool>;

extern_class!(
    /// Expectation subclass for waiting on a condition defined by a Darwin notification. The notification
    /// which may be posted in the same process or by other processes. Be aware that Darwin notifications
    /// may be coalesced when posted in quick succession, so be careful especially when using the
    /// `expectedFulfillmentCount` property with this class.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/xctest/xctdarwinnotificationexpectation?language=objc)
    #[unsafe(super(XCTestExpectation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct XCTDarwinNotificationExpectation;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for XCTDarwinNotificationExpectation {}
);

impl XCTDarwinNotificationExpectation {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithDescription:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDescription(
            this: Allocated<Self>,
            expectation_description: &NSString,
        ) -> Retained<Self>;

        /// Initializes an expectation that waits for a Darwin notification to be posted.
        #[unsafe(method(initWithNotificationName:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithNotificationName(
            this: Allocated<Self>,
            notification_name: &NSString,
        ) -> Retained<Self>;

        /// Returns the value of the notification name that was provided to the initializer.
        #[unsafe(method(notificationName))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationName(&self) -> Retained<NSString>;

        #[cfg(feature = "block2")]
        /// Allows the caller to install a special handler to do custom evaluation when the notification is posted.
        #[unsafe(method(handler))]
        #[unsafe(method_family = none)]
        pub unsafe fn handler(&self) -> XCTDarwinNotificationExpectationHandler;

        #[cfg(feature = "block2")]
        /// Setter for [`handler`][Self::handler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHandler(&self, handler: XCTDarwinNotificationExpectationHandler);
    );
}

/// XCUIScreenshot_ConvenienceInitializers.
impl XCTAttachment {
    extern_methods!(
        #[cfg(feature = "objc2-xc-ui-automation")]
        /// Creates an attachment with a screenshot and the specified quality.
        #[unsafe(method(attachmentWithScreenshot:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithScreenshot(screenshot: &XCUIScreenshot) -> Retained<Self>;

        #[cfg(feature = "objc2-xc-ui-automation")]
        /// Creates an attachment with a screenshot and the specified quality.
        #[unsafe(method(attachmentWithScreenshot:quality:))]
        #[unsafe(method_family = none)]
        pub unsafe fn attachmentWithScreenshot_quality(
            screenshot: &XCUIScreenshot,
            quality: XCTImageQuality,
        ) -> Retained<Self>;
    );
}

/// XCUIApplication_LaunchTesting.
impl XCTestCase {
    extern_methods!(
        /// Determines whether the tests in this class should run multiple times, once for each of the target application's UI configurations.
        ///
        /// Returns false by default. If overridden in a UI test subclass to return true, each test in that
        /// class will run multiple times, once for each supported UI configuration of the default target application.
        ///
        /// Supported UI configurations are detected by Xcode according to the settings of the default target app
        /// for the UI test target and may include:
        ///
        /// - Appearances (e.g. light mode, dark mode)
        /// - Orientations (e.g. portrait, landscape)
        /// - Localizations (e.g. en_US, zh_CN)
        ///
        /// Given the above example, one UI configuration would be {dark mode, landscape, en_US}, another would be
        /// {light mode, portrait, zh_CN}, and so forth. The number of combinations determines the number of times each
        /// test will run. The UI configuration is used automatically when calling `XCUIApplication.launch()` in each test.
        #[unsafe(method(runsForEachTargetApplicationUIConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn runsForEachTargetApplicationUIConfiguration() -> bool;
    );
}

/// XCUIInterruptionMonitoring.
impl XCTestCase {
    extern_methods!(
        #[cfg(all(feature = "block2", feature = "objc2-xc-ui-automation"))]
        /// Adds a monitor to the test. Monitors are automatically removed at the end of the test or can be manually removed using -removeUIInterruptionMonitor:.
        /// Monitors are invoked in the reverse order in which they are added until one of the monitors returns true, indicating that it has handled the interruption.
        ///
        ///
        /// Parameter `handlerDescription`: Explanation of the behavior and purpose of this monitor, mainly used for debugging and analysis.
        ///
        ///
        /// Parameter `handler`: Handler block for asynchronous, non-deterministic interrupting UI such as alerts and other dialogs. Handlers should return true if they handled the UI, false if they did not.
        /// The handler is passed an XCUIElement representing the top level UI element for the alert.
        ///
        ///
        /// Returns: Returns an opaque token that can be used to remove the monitor.
        ///
        ///
        /// A "UI interruption" is any element which unexpectedly blocks access to an element with which a UI test is trying to interact. Interrupting elements are most commonly alerts,
        /// dialogs, or other windows, but can be of other types as well. Interruptions are unexpected or at least not deterministic: the appearance of an alert in direct response to
        /// a test action such as clicking a button is not an interruption and should not be handled using a UI interruption monitor. Instead, it's simply part of the UI and should be
        /// found using standard queries and interacted with using standard event methods. Note that some interruptions are part of the app's own UI, others are presented on
        /// behalf of system apps and services, so queries for these elements must be constructed with the right process at their root.
        ///
        /// Use a UI interruption monitor for alerts that appear unexpectedly or with non-deterministic timing. Monitors are not invoked simply by the appearance of an alert or similar
        /// UI, they are called when the presence of such UI interferes with actions the test is attempting to take. For example, consider the following sequence:
        ///
        /// - test taps button
        /// - app displays confirmation dialog
        ///
        /// In this case, the dialog that is presented can be anticipated by the test, so a UI interruption monitor should not be used. Instead, the sequence should look like:
        ///
        /// - test taps button
        /// - test constructs an XCUIElement for the dialog and uses XCUIElement.waitForExistence(timeout:) to wait for it to appear
        /// - app displays confirmation dialog
        /// - test synthesizes a tap for the appropriate button in the dialog
        /// - test continues execution
        ///
        /// There was no UI interruption in this example because every step was deterministic and known in advance. Note the use of XCUIElement.waitForExistence(timeout:) to deal with
        /// asynchronous delays in the display of the dialog.
        ///
        /// By contrast, consider the next sequence, where use of a UI interruption monitor is the correct solution:
        ///
        /// - test launches app
        /// - app initiates asynchronous network request
        /// - test interacts with app
        /// - network request completes, app decides to display a dialog to the user
        /// - dialog appears just as the test is about to tap on a button
        /// - the appearance of the dialog is not deterministic
        /// - the test can anticipate that the dialog might be displayed at some point, but not when
        /// - accordingly, the test has installed a UI interruption monitor that knows how to handle the network response dialog
        /// - when XCTest computes a hit point for the button, it discovers the dialog and treats it as "interrupting UI"
        /// - the previously installed UI interruption monitor is invoked
        /// - it handles the dialog
        /// - XCTest computes the hit point for the button and synthesizes the requested tap event
        /// - test execution continues...
        ///
        /// Monitors can be designed to be general or specific in how they handle interruptions. The simplest general approach might simply attempt to cancel/dismiss/close
        /// any interrupting dialog/alert/window without consideration for its contents or purpose. A more specific monitor might make decisions based on the UI and contents
        /// of the interruption. Tests may install multiple monitors, which will be invoked in reverse order of installation. If a more specific monitor wishes to be skipped for a
        /// given interruption, its handler can simply return false - the next monitor will be invoked, and so on, until one of them returns true, signifying that it has handled
        /// the interruption. In some cases, a default monitor may handle interruptions.
        #[unsafe(method(addUIInterruptionMonitorWithDescription:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addUIInterruptionMonitorWithDescription_handler(
            &self,
            handler_description: &NSString,
            handler: &block2::DynBlock<dyn Fn(NonNull<XCUIElement>) -> Bool>,
        ) -> Retained<ProtocolObject<dyn NSObjectProtocol>>;

        /// Removes a monitor using the token provided when it was added.
        ///
        ///
        /// Parameter `monitor`: The token representing the monitor returned from the call to addUIInterruptionMonitorWithDescription:handler: where it was registered.
        #[unsafe(method(removeUIInterruptionMonitor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeUIInterruptionMonitor(
            &self,
            monitor: &ProtocolObject<dyn NSObjectProtocol>,
        );
    );
}

/// UIAutomation.
impl XCTCPUMetric {
    extern_methods!(
        #[cfg(feature = "objc2-xc-ui-automation")]
        /// Creates a metric which will target the process described by the XCUIApplication instance.
        ///
        ///
        /// Parameter `application`: An instance of XCUIApplication which will be targeted to gather measurements.
        ///
        ///
        /// Returns: An initialized metric.
        #[unsafe(method(initWithApplication:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithApplication(
            this: Allocated<Self>,
            application: &XCUIApplication,
        ) -> Retained<Self>;
    );
}

/// UIAutomation.
impl XCTMemoryMetric {
    extern_methods!(
        #[cfg(feature = "objc2-xc-ui-automation")]
        /// Creates a metric which will target the process described by the XCUIApplication instance.
        ///
        ///
        /// Parameter `application`: An instance of XCUIApplication which will be targeted to gather measurements.
        ///
        ///
        /// Returns: An initialized metric.
        #[unsafe(method(initWithApplication:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithApplication(
            this: Allocated<Self>,
            application: &XCUIApplication,
        ) -> Retained<Self>;
    );
}

/// UIAutomation.
impl XCTStorageMetric {
    extern_methods!(
        #[cfg(feature = "objc2-xc-ui-automation")]
        /// Creates a metric which will target the process described by the XCUIApplication instance.
        ///
        ///
        /// Parameter `application`: An instance of XCUIApplication which will be targeted to gather measurements.
        ///
        ///
        /// Returns: An initialized metric.
        #[unsafe(method(initWithApplication:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithApplication(
            this: Allocated<Self>,
            application: &XCUIApplication,
        ) -> Retained<Self>;
    );
}
