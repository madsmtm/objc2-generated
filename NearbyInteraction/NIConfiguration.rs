//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A type used to uniquely discover and identify a device in a nearby interaction session.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/nearbyinteraction/nidiscoverytoken?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NIDiscoveryToken;
);

extern_conformance!(
    unsafe impl NSCoding for NIDiscoveryToken {}
);

extern_conformance!(
    unsafe impl NSCopying for NIDiscoveryToken {}
);

unsafe impl CopyingHelper for NIDiscoveryToken {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NIDiscoveryToken {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NIDiscoveryToken {}
);

impl NIDiscoveryToken {
    extern_methods!(
        #[cfg(feature = "NIDeviceCapability")]
        /// Get the protocol that describes nearby interaction capabilities of the device that generated this token.
        ///
        /// Detailed description on the capability protocol is in NIDeviceCapability.h.
        #[unsafe(method(deviceCapabilities))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceCapabilities(&self)
            -> Retained<ProtocolObject<dyn NIDeviceCapability>>;

        /// Unavailable
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object to describe and configure parameters to be used in a nearby interaction session.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/nearbyinteraction/niconfiguration?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NIConfiguration;
);

extern_conformance!(
    unsafe impl NSCoding for NIConfiguration {}
);

extern_conformance!(
    unsafe impl NSCopying for NIConfiguration {}
);

unsafe impl CopyingHelper for NIConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NIConfiguration {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NIConfiguration {}
);

impl NIConfiguration {
    extern_methods!(
        /// Unavailable
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object to describe and configure parameters to be used in a nearby interaction session for mutual relative positional measurements.
    ///
    /// Devices engaged in a session run with an NINearbyPeerConfiguration are able to continuously generate positional measurements relative to one another.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/nearbyinteraction/ninearbypeerconfiguration?language=objc)
    #[unsafe(super(NIConfiguration, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NINearbyPeerConfiguration;
);

extern_conformance!(
    unsafe impl NSCoding for NINearbyPeerConfiguration {}
);

extern_conformance!(
    unsafe impl NSCopying for NINearbyPeerConfiguration {}
);

unsafe impl CopyingHelper for NINearbyPeerConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NINearbyPeerConfiguration {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NINearbyPeerConfiguration {}
);

impl NINearbyPeerConfiguration {
    extern_methods!(
        /// The discovery token identifying the peer device for this session configuration.
        #[unsafe(method(peerDiscoveryToken))]
        #[unsafe(method_family = none)]
        pub unsafe fn peerDiscoveryToken(&self) -> Retained<NIDiscoveryToken>;

        /// Initializes a new configuration with the provided peer token.
        ///
        /// Parameter `peerToken`: A discovery token received from the peer for this session.
        #[unsafe(method(initWithPeerToken:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPeerToken(
            this: Allocated<Self>,
            peer_token: &NIDiscoveryToken,
        ) -> Retained<Self>;

        /// Enables camera assistance during the NISession run with this configuration
        ///
        /// :
        /// If true, optionally call setARSession: on the NISession before calling runWithConfiguration:
        /// If true and setARSession: is not called, an ARSession will automatically be created
        /// If true and the platform does not support camera assistance, the NISession will generate an error when runWithConfiguration: is called
        ///
        /// Note: : Check supportsCameraAssistance property in NIDeviceCapability returned from deviceCapabilities properties on NISession
        #[unsafe(method(isCameraAssistanceEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isCameraAssistanceEnabled(&self) -> bool;

        /// Setter for [`isCameraAssistanceEnabled`][Self::isCameraAssistanceEnabled].
        #[unsafe(method(setCameraAssistanceEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCameraAssistanceEnabled(&self, camera_assistance_enabled: bool);

        /// If both peers are capable, enables extended distance measurement for the NISession that runs with this configuration
        ///
        /// :
        /// If true, the NISession will use extended distance measurement capabilities while ranging with a peer that is also capable of extended distance measurement
        /// This property is compatible with the cameraAssistanceEnabled property
        ///
        /// Note: : Check supportsExtendedDistanceMeasurement property from deviceCapabilities properties on NISession and the deviceCapabilities property on the NIDiscoveryToken generated by the peer device to understand mutual capabilities
        #[unsafe(method(isExtendedDistanceMeasurementEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isExtendedDistanceMeasurementEnabled(&self) -> bool;

        /// Setter for [`isExtendedDistanceMeasurementEnabled`][Self::isExtendedDistanceMeasurementEnabled].
        #[unsafe(method(setExtendedDistanceMeasurementEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExtendedDistanceMeasurementEnabled(
            &self,
            extended_distance_measurement_enabled: bool,
        );

        /// Unavailable
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A session configuration that enables interaction with supported accessories.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/nearbyinteraction/ninearbyaccessoryconfiguration?language=objc)
    #[unsafe(super(NIConfiguration, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NINearbyAccessoryConfiguration;
);

extern_conformance!(
    unsafe impl NSCoding for NINearbyAccessoryConfiguration {}
);

extern_conformance!(
    unsafe impl NSCopying for NINearbyAccessoryConfiguration {}
);

unsafe impl CopyingHelper for NINearbyAccessoryConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NINearbyAccessoryConfiguration {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NINearbyAccessoryConfiguration {}
);

impl NINearbyAccessoryConfiguration {
    extern_methods!(
        /// The discovery token identifying the accessory device for this session configuration.
        ///
        /// NINearbyObject updates for this accessory will contain this discovery token.
        #[unsafe(method(accessoryDiscoveryToken))]
        #[unsafe(method_family = none)]
        pub unsafe fn accessoryDiscoveryToken(&self) -> Retained<NIDiscoveryToken>;

        /// Enables camera assistance during the NISession run with this configuration
        ///
        /// :
        /// If YES, optionally call -setARSession: on the NISession before calling -runWithConfiguration:
        /// If YES and setARSession: is not called, an ARSession will automatically be created
        /// If YES  and the platform does not support camera assistance, the NISession will generate an error when runWithConfiguration: is called
        ///
        /// Note: : Check supportsCameraAssistance property in NIDeviceCapability returned from deviceCapabilities properties on NISession
        #[unsafe(method(isCameraAssistanceEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isCameraAssistanceEnabled(&self) -> bool;

        /// Setter for [`isCameraAssistanceEnabled`][Self::isCameraAssistanceEnabled].
        #[unsafe(method(setCameraAssistanceEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCameraAssistanceEnabled(&self, camera_assistance_enabled: bool);

        /// Create a new nearby accessory configuration using data received from the accessory.
        ///
        /// Parameter `data`: Configuration data received from the accessory.
        ///
        /// Parameter `error`: An optional out error parameter that will be populated with an error if the provided data is invalid or unsupported.
        #[unsafe(method(initWithData:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData_error(
            this: Allocated<Self>,
            data: &NSData,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        /// Create a new nearby accessory configuration for an accessory that is also a paired Bluetooth device
        ///
        ///
        /// Parameter `accessoryData`: Configuration data received from the accessory
        ///
        /// Parameter `bluetoothPeerIdentifier`: The accessory's Bluetooth identifier
        ///
        /// Parameter `error`: An optional out error parameter that will be populated with an error if the provided inputs are invalid or unsupported.
        ///
        ///
        /// The accessory must be a Bluetooth LE peripheral that is paired, actively connected, and implements the Nearby Interaction Service and Accessory Configuration Characteristic.
        #[unsafe(method(initWithAccessoryData:bluetoothPeerIdentifier:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAccessoryData_bluetoothPeerIdentifier_error(
            this: Allocated<Self>,
            accessory_data: &NSData,
            identifier: &NSUUID,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        /// Unavailable
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A session configuration that enables UWB Down Link Time Difference of Arrival(DL-TDoA) ranging with nearby anchors.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/nearbyinteraction/nidltdoaconfiguration?language=objc)
    #[unsafe(super(NIConfiguration, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NIDLTDOAConfiguration;
);

unsafe impl Send for NIDLTDOAConfiguration {}

unsafe impl Sync for NIDLTDOAConfiguration {}

extern_conformance!(
    unsafe impl NSCoding for NIDLTDOAConfiguration {}
);

extern_conformance!(
    unsafe impl NSCopying for NIDLTDOAConfiguration {}
);

unsafe impl CopyingHelper for NIDLTDOAConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NIDLTDOAConfiguration {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NIDLTDOAConfiguration {}
);

impl NIDLTDOAConfiguration {
    extern_methods!(
        /// A unique identifier for a network supporting UWB Down Link Time Difference of Arrival(DL-TDoA).
        #[unsafe(method(networkIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn networkIdentifier(&self) -> NSInteger;

        /// Setter for [`networkIdentifier`][Self::networkIdentifier].
        #[unsafe(method(setNetworkIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNetworkIdentifier(&self, network_identifier: NSInteger);

        /// Initializes a new configuration with a network identifier
        #[unsafe(method(initWithNetworkIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithNetworkIdentifier(
            this: Allocated<Self>,
            network_identifier: NSInteger,
        ) -> Retained<Self>;

        /// Unavailable
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
