//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-ar-kit")]
#[cfg(target_os = "ios")]
use objc2_ar_kit::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An object that identifies a unique connection between two peer devices.
    ///
    /// ## Overview
    ///
    /// This class represents the central mechanism to interact with nearby objects, for example, a peer Apple device or third-party accessory. After creating an [`NISession`](https://developer.apple.com/documentation/nearbyinteraction/nisession) for a nearby object, the app interacts with the object by receiving [`NISessionDelegate`](https://developer.apple.com/documentation/nearbyinteraction/nisessiondelegate) callbacks.
    ///
    /// One session represents an interaction between the user and a single nearby object. To interact with multiple nearby objects, create a separate session for each.
    ///
    /// For more information, see [Initiating and maintaining a session](https://developer.apple.com/documentation/nearbyinteraction/initiating-and-maintaining-a-session).
    ///
    ///
    /// Nearby interaction session.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NISession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NISession {}
);

impl NISession {
    extern_methods!(
        /// Whether or not this device is capable of participating in a nearby interaction session.
        #[deprecated]
        #[unsafe(method(isSupported))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSupported() -> bool;

        #[cfg(feature = "NIDeviceCapability")]
        /// Get the protocol that describes nearby interaction capabilities on this device.
        ///
        /// Detailed description on the capability protocol is in NIDeviceCapability.h.
        #[unsafe(method(deviceCapabilities))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceCapabilities() -> Retained<ProtocolObject<dyn NIDeviceCapability>>;

        /// A delegate for receiving NISession updates.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NISessionDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NISessionDelegate>>);

        #[cfg(feature = "dispatch2")]
        /// The dispatch queue on which the delegate calls are performed.
        ///
        /// If not provided or nil, delegate calls will be performed on the main queue.
        #[unsafe(method(delegateQueue))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegateQueue(&self) -> Option<Retained<DispatchQueue>>;

        #[cfg(feature = "dispatch2")]
        /// Setter for [`delegateQueue`][Self::delegateQueue].
        ///
        /// # Safety
        ///
        /// `delegate_queue` possibly has additional threading requirements.
        #[unsafe(method(setDelegateQueue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegateQueue(&self, delegate_queue: Option<&DispatchQueue>);

        #[cfg(feature = "NIConfiguration")]
        /// A unique nearby interaction identifier for this session.
        ///
        ///
        /// Copy this discoveryToken and share it with a peer device.
        /// The discoveryToken is unique to this device and this session.
        #[unsafe(method(discoveryToken))]
        #[unsafe(method_family = none)]
        pub unsafe fn discoveryToken(&self) -> Option<Retained<NIDiscoveryToken>>;

        #[cfg(feature = "NIConfiguration")]
        /// The nearby interaction configuration currently being used by the session.
        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn configuration(&self) -> Option<Retained<NIConfiguration>>;

        #[cfg(feature = "NIConfiguration")]
        /// Start a nearby interaction session.
        ///
        /// Parameter `configuration`: Nearby interaction configuration for this session.
        /// Both devices must call -runWithConfiguration: with a valid configuration identifying the other device in order to receive nearby object updates.
        #[unsafe(method(runWithConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runWithConfiguration(&self, configuration: &NIConfiguration);

        /// Pause an ongoing nearby interaction session.
        ///
        /// Paused sessions may be restarted by calling -runWithConfiguration:. The same local discoveryToken will be used.
        #[unsafe(method(pause))]
        #[unsafe(method_family = none)]
        pub unsafe fn pause(&self);

        /// Invalidate an ongoing nearby interaction session.
        ///
        /// Invalidate sessions you wish to terminate and do not intend to restart. A peer device in a nearby interaction session will receive a callback to -didRemoveNearbyObject:withReason: some time after a call to invalidate (see NINearbyObjectRemovalReason).
        /// calling -runWithConfiguration: after invalidation will result in an error.
        #[unsafe(method(invalidate))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidate(&self);

        #[cfg(feature = "objc2-ar-kit")]
        #[cfg(target_os = "ios")]
        /// Provide an ARSession object for use with the NISession
        ///
        /// Parameter `session`: The ARSession to use for camera assistance
        ///
        /// If not provided, an ARSession will be created automatically if the cameraAssistanceEnabled property on the configuration is YES
        ///
        /// The developer is responsible for running the ARSession if provided.
        ///
        /// If the ARConfiguration used to run the session is not compatible with the NISession, the NISession will invalidate with error
        ///
        /// If the platform does not support camera assistance or an ARSession is provided without enabling cameraAssistanceEnabled property in the NIConfiguration, the NISession will invalidate with error (see NIError.h)
        #[unsafe(method(setARSession:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setARSession(&self, session: &ARSession);
    );
}

/// Methods declared on superclass `NSObject`.
impl NISession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The reason a session removed a nearby object.
///
/// ## Overview
///
/// Each case is a possible value of the `reason` argument to the delegate’s [`session:didRemoveNearbyObjects:withReason:`](https://developer.apple.com/documentation/nearbyinteraction/nisessiondelegate/session(_:didremove:reason:)) callback.
///
///
/// Reasons to remove a nearby object.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NINearbyObjectRemovalReason(pub NSInteger);
impl NINearbyObjectRemovalReason {
    /// NI timed out the session.
    ///
    /// ## Discussion
    ///
    /// The framework times out a session if the peer user closes the app, or if too much time passes in a suspended state (see [`sessionWasSuspended:`](https://developer.apple.com/documentation/nearbyinteraction/nisessiondelegate/sessionwassuspended(_:))). NI may also time out a session to save device resources.
    ///
    /// An app must watch for timed-out peers. If the app wishes to continue interaction with a timed-out peer device, the app must begin a new session.
    ///
    ///
    /// The system has not received new activity from this object for over the allowed period.
    #[doc(alias = "NINearbyObjectRemovalReasonTimeout")]
    pub const Timeout: Self = Self(0);
    /// The peer ended the session.
    ///
    /// ## Discussion
    ///
    /// The framework provides this removal reason when the peer app calls [`invalidate`](https://developer.apple.com/documentation/nearbyinteraction/nisession/invalidate()).
    ///
    ///
    /// The peer device has signaled that it will no longer participate in the session.
    /// This removal reason is delivered on a best effort basis and is not guaranteed to be received.
    #[doc(alias = "NINearbyObjectRemovalReasonPeerEnded")]
    pub const PeerEnded: Self = Self(1);
}

unsafe impl Encode for NINearbyObjectRemovalReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NINearbyObjectRemovalReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Expose algorithm state to make it possible for apps to coach users.
/// Expose algorithm state to make it possible for apps to coach users.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NIAlgorithmConvergenceStatus(pub NSInteger);
impl NIAlgorithmConvergenceStatus {
    /// An indication that the framework is unsure of the Camera Assistance status.
    ///
    /// ## Discussion
    ///
    /// Look to a subsequent call to [`session(_:didUpdateAlgorithmConvergence:for:)`](https://developer.apple.com/documentation/nearbyinteraction/nisessiondelegate/session(_:didupdatealgorithmconvergence:for:)) and check for a more definitive algorithm-convergence status.
    ///
    ///
    /// Algorithm convergence status is unknown.
    #[doc(alias = "NIAlgorithmConvergenceStatusUnknown")]
    pub const Unknown: Self = Self(0);
    /// A status that indicates the framework’s Camera Assistance feature requires action from the user.
    ///
    /// ## Discussion
    ///
    /// In this state, the framework needs more information about the user’s physical environment before setting [`horizontalAngle`](https://developer.apple.com/documentation/nearbyinteraction/ninearbyobject/horizontalangle-9ibky) and/or [`verticalDirectionEstimate`](https://developer.apple.com/documentation/nearbyinteraction/ninearbyobject/verticaldirectionestimate-swift.property).
    ///
    /// Look to the reasons array of the `convergence` object provided by  [`session(_:didUpdateAlgorithmConvergence:for:)`](https://developer.apple.com/documentation/nearbyinteraction/nisessiondelegate/session(_:didupdatealgorithmconvergence:for:)) for more information on the cause. Each reason indicates a specific action the user can do to provide ARKit with the necessary camera data to support Nearby Interaction’s Camera Assistance.
    ///
    ///
    /// Algorithm is not converged.
    #[doc(alias = "NIAlgorithmConvergenceStatusNotConverged")]
    pub const NotConverged: Self = Self(1);
    /// A status that indicates the framework’s Camera Assistance feature is operational.
    ///
    /// ## Discussion
    ///
    /// In this state, the app doesn’t need to coach the user and receives all the benefits of Camera Assistance as described in [`isCameraAssistanceEnabled`](https://developer.apple.com/documentation/nearbyinteraction/ninearbypeerconfiguration/iscameraassistanceenabled).
    ///
    ///
    /// Algorithm is converged.
    #[doc(alias = "NIAlgorithmConvergenceStatusConverged")]
    pub const Converged: Self = Self(2);
}

unsafe impl Encode for NIAlgorithmConvergenceStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NIAlgorithmConvergenceStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that provides the state and reason for user coaching recommendations.
    ///
    /// ## Overview
    ///
    /// This class conveys the current state of the framework’s Camera Assistance feature when you turn on [`cameraAssistanceEnabled`](https://developer.apple.com/documentation/nearbyinteraction/ninearbypeerconfiguration/iscameraassistanceenabled). When the status indicates that user action is required to achieve the highest-quality results, instances of this class identify specific actions the user can do to help. To improve the status, the app needs to coach the user such as by presenting instructional text. The information you provide tells the user, for example, where and at what speed to pan the device around the environment.
    ///
    /// To listen for the convergence status, implement [`session:didUpdateAlgorithmConvergence:forObject:`](https://developer.apple.com/documentation/nearbyinteraction/nisessiondelegate/session(_:didupdatealgorithmconvergence:for:)).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NIAlgorithmConvergence;
);

extern_conformance!(
    unsafe impl NSCoding for NIAlgorithmConvergence {}
);

extern_conformance!(
    unsafe impl NSCopying for NIAlgorithmConvergence {}
);

unsafe impl CopyingHelper for NIAlgorithmConvergence {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NIAlgorithmConvergence {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NIAlgorithmConvergence {}
);

impl NIAlgorithmConvergence {
    extern_methods!(
        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        pub unsafe fn status(&self) -> NIAlgorithmConvergenceStatus;

        #[cfg(feature = "NIAlgorithmConvergenceStatusReason")]
        #[unsafe(method(reasons))]
        #[unsafe(method_family = none)]
        pub unsafe fn reasons(&self) -> Retained<NSArray<NIAlgorithmConvergenceStatusReason>>;

        /// Unavailable
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// An object that monitors and reacts to session updates.
    ///
    /// ## Overview
    ///
    /// Assign a delegate that Nearby Interaction can use to notify your app of important events that occur during the session life cycle.
    ///
    ///
    /// Delegate for nearby interaction session updates.
    pub unsafe trait NISessionDelegate: NSObjectProtocol {
        #[cfg(feature = "NINearbyObject")]
        /// This is called when new updates about nearby objects are available.
        ///
        /// Parameter `session`: The nearby interaction session being run.
        ///
        /// Parameter `nearbyObjects`: The nearby objects that have been updated.
        #[optional]
        #[unsafe(method(session:didUpdateNearbyObjects:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didUpdateNearbyObjects(
            &self,
            session: &NISession,
            nearby_objects: &NSArray<NINearbyObject>,
        );

        #[cfg(feature = "NINearbyObject")]
        /// This is called when the system is no longer attempting to interact with some nearby objects.
        ///
        /// The system was unable to interact with a peer device for some time, or the peer device signaled that it is leaving the session. After this callback is received, the session with the peer is no longer active. To retry interacting with the peer, issue a new call to -runWithConfiguration:.
        ///
        /// Parameter `session`: The nearby interaction session that removed the nearby object(s).
        ///
        /// Parameter `nearbyObjects`: The nearby objects that were removed.
        ///
        /// Parameter `reason`: The reason the nearby object(s) were removed.  All objects in nearbyObjects are removed for the same reason. If multiple nearby objects are removed for different reasons, -didRemoveNearbyObjects:reason: will be called multiple times.
        #[optional]
        #[unsafe(method(session:didRemoveNearbyObjects:withReason:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didRemoveNearbyObjects_withReason(
            &self,
            session: &NISession,
            nearby_objects: &NSArray<NINearbyObject>,
            reason: NINearbyObjectRemovalReason,
        );

        /// This is called when a session is suspended.
        ///
        /// A session will be suspended in various app and system scenarios.
        /// A suspended session may be run again only after -sessionSuspensionEnded: has been called.  Restart a session by issuing a new call to -runWithConfiguration:.
        ///
        /// Parameter `session`: The nearby interaction session that was suspended.
        #[optional]
        #[unsafe(method(sessionWasSuspended:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionWasSuspended(&self, session: &NISession);

        /// This is called when a session may be resumed.
        ///
        /// Parameter `session`: The nearby interaction session that was suspended.
        #[optional]
        #[unsafe(method(sessionSuspensionEnded:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionSuspensionEnded(&self, session: &NISession);

        /// This is called when a session is invalidated.
        ///
        /// Parameter `session`: The session that has become invalid. Your app should discard any references it has to this session.
        ///
        /// Parameter `error`: The error indicating the reason for invalidation of the session (see NIError.h).
        #[optional]
        #[unsafe(method(session:didInvalidateWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didInvalidateWithError(&self, session: &NISession, error: &NSError);

        #[cfg(feature = "NINearbyObject")]
        /// Provides configuration data that needs to be shared with the accessory.
        ///
        /// Note: Shareable configuration data is only provided when running an NINearbyAccessoryConfiguration.
        ///
        /// After invoking this callback, the session will go into a special preparedness state for a limited amount of time.
        /// The interaction on the accessory must start within this time window. If activity is not detected from the accessory, the session will call
        /// the -[session:didRemoveNearbyObjects:reason:] delegate callback. To restart the session, coordinate with the accessory and call -[runWithConfiguration] again.
        ///
        /// Parameter `session`: The session which produced the configuration data.
        ///
        /// Parameter `shareableConfigurationData`: The configuration data that needs to be shared with the accessory.
        ///
        /// Parameter `object`: A representation of the accessory as a NINearbyObject. The discoveryToken property will be equal to the one in the configuration used to run the session.
        #[optional]
        #[unsafe(method(session:didGenerateShareableConfigurationData:forObject:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didGenerateShareableConfigurationData_forObject(
            &self,
            session: &NISession,
            shareable_configuration_data: &NSData,
            object: &NINearbyObject,
        );

        #[cfg(feature = "NINearbyObject")]
        /// Called when the algorithm state is updated for a specific nearby object.
        ///
        /// Parameter `session`: the session interacting with this object.
        ///
        /// Parameter `convergence`: the algoriothm convergence context of the estimator for the session or nearby object
        ///
        /// Parameter `object`: which nearby object this state was updated, if null, applies to the entire session
        #[optional]
        #[unsafe(method(session:didUpdateAlgorithmConvergence:forObject:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didUpdateAlgorithmConvergence_forObject(
            &self,
            session: &NISession,
            convergence: &NIAlgorithmConvergence,
            object: Option<&NINearbyObject>,
        );

        #[cfg(feature = "NIDLTDOAMeasurement")]
        /// This is called when new updates about DL-TDOA measurement are available.
        ///
        ///
        /// Note: this will only be called after successfully running an NISession with an NIDLTDOAConfiguration.
        ///
        ///
        /// Parameter `session`: The session that updated NI DL-TDOA measurement.
        ///
        /// Parameter `measurements`: The measurements update from a NI DL-TDOA session
        #[optional]
        #[unsafe(method(session:didUpdateDLTDOAMeasurements:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didUpdateDLTDOAMeasurements(
            &self,
            session: &NISession,
            measurements: &NSArray<NIDLTDOAMeasurement>,
        );

        /// The delegate may implement this method to be informed that the session started running.
        ///
        ///
        /// Parameter `session`: The session which started running
        ///
        ///
        /// a call to -runWithConfiguration: will result in one of the following outcomes:
        /// 1. The session successfully starts running. This delegate callback will be subsequently invoked.
        /// 2. Resources are not ready, and the session is immediately suspended. This delegate callback will not be invoked.
        /// 3. An error is encountered, and the session is immediately invalidated. This delegate callback will not be invoked.
        ///
        /// This delegate method provides a way to monitor #1.
        /// Note that #2 and #3 can be monitored by other delegate methods such as -sessionWasSuspended: and -session:didInvalidateWithError:
        #[optional]
        #[unsafe(method(sessionDidStartRunning:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionDidStartRunning(&self, session: &NISession);
    }
);
