//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
#[cfg(feature = "objc2-core-video")]
use objc2_core_video::*;

use crate::*;

/// A reference to a VideoToolbox compression session.
///
/// ## Overview
///
/// A compression session supports the compression of a sequence of video frames. The session is a reference-counted CoreFoundation (CF) object.
///
///
/// A reference to a Video Toolbox Compression Session.
///
/// A compression session supports the compression of a sequence of video frames.
/// The session reference is a reference-counted CF object.
/// To create a compression session, call VTCompressionSessionCreate;
/// then you can optionally configure the session using VTSessionSetProperty;
/// then to encode frames, call VTCompressionSessionEncodeFrame.
/// To force completion of some or all pending frames, call VTCompressionSessionCompleteFrames.
/// When you are done with the session, you should call VTCompressionSessionInvalidate
/// to tear it down and CFRelease to release your object reference.
#[doc(alias = "VTCompressionSessionRef")]
#[repr(C)]
pub struct VTCompressionSession {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl VTCompressionSession {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueVTCompressionSession"> for VTCompressionSession {}
);

/// A callback for the system to invoke when it’s finished compressing a frame.
///
/// Parameters:
/// - outputCallbackRefCon: The callback’s reference value.
///
/// - sourceFrameRefCon: The frame’s reference value, copied from the `sourceFrameRefCon` argument to [`VTCompressionSessionEncodeFrame`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessionencodeframe(_:imagebuffer:presentationtimestamp:duration:frameproperties:sourceframerefcon:infoflagsout:)).
///
/// - status: `noErr` if compression was successful; an error code if compression wasn’t successful.
///
/// - infoFlags: Contains information about the encode operation.
///
/// The [`kVTEncodeInfo_Asynchronous`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/asynchronous) bit may be set if the encode ran asynchronously.
///
/// The [`kVTEncodeInfo_FrameDropped`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/framedropped) bit may be set if the frame was dropped.
///
/// - sampleBuffer: Contains the compressed frame if compression was successful and the frame wasn’t dropped; otherwise, `NULL`.
///
///
/// ## Discussion
///
/// When you create a compression session, you pass in a callback function to be called for compressed frames.  This function is called in decode order (which is not necessarily the same as display order).
///
///
/// Prototype for callback invoked when frame compression is complete.
///
/// When you create a compression session, you pass in a callback function to be called
/// for compressed frames.  This function will be called in decode order (which is not
/// necessarily the same as display order).
///
/// Parameter `outputCallbackRefCon`: The callback's reference value.
///
/// Parameter `sourceFrameRefCon`: The frame's reference value, copied from the sourceFrameRefCon argument to
/// VTCompressionSessionEncodeFrame.
///
/// Parameter `status`: noErr if compression was successful; an error code if compression was not successful.
///
/// Parameter `infoFlags`: Contains information about the encode operation.
/// The kVTEncodeInfo_Asynchronous bit may be set if the encode ran asynchronously.
/// The kVTEncodeInfo_FrameDropped bit may be set if the frame was dropped.
///
/// Parameter `sampleBuffer`: Contains the compressed frame, if compression was successful and the frame was not dropped;
/// otherwise, NULL.
#[cfg(all(feature = "VTErrors", feature = "objc2-core-media"))]
pub type VTCompressionOutputCallback = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        *mut c_void,
        OSStatus,
        VTEncodeInfoFlags,
        *mut CMSampleBuffer,
    ),
>;

extern "C" {
    /// A key that indicates a particular video encoder to use.
    ///
    /// ## Discussion
    ///
    /// To specify a particular video encoder when creating a compression session, pass an encoder specification doc://com.apple.documentation/documentation/corefoundation/cfdictionary-rum containing this key and the encoder ID as its value. You can get the encoder ID string from the `kVTVideoEncoderList_EncoderID` entry in the array returned by [`VTCopyVideoEncoderList`](https://developer.apple.com/documentation/videotoolbox/vtcopyvideoencoderlist(_:_:)).
    ///
    ///
    /// Specifies a particular video encoder by its ID string.
    ///
    /// To specify a particular video encoder when creating a compression session, pass an
    /// encoderSpecification CFDictionary containing this key and the EncoderID as its value.
    /// The EncoderID CFString may be obtained from the kVTVideoEncoderList_EncoderID entry in
    /// the array returned by VTCopyVideoEncoderList.
    pub static kVTVideoEncoderSpecification_EncoderID: &'static CFString;
}

impl VTCompressionSession {
    /// Creates an object that compresses video frames.
    ///
    /// Parameters:
    /// - allocator: An allocator for the session. Pass `NULL` to use the default allocator.
    ///
    /// - width: The pixel width of video frames.
    ///
    /// - height: The pixel height of video frames.
    ///
    /// - codecType: The codec type.
    ///
    /// - encoderSpecification: A video encoder to use. Pass `NULL` to let VideoToolbox choose an encoder.
    ///
    /// - sourceImageBufferAttributes: Required attributes for source pixel buffers, used when creating a pixel buffer pool for source frames. If you don’t want VideoToolbox to create one for you, pass `NULL`.
    ///
    /// Using pixel buffers not allocated by VideoToolbox increases the chance that you’ll have to copy image data.
    ///
    /// - compressedDataAllocator: An allocator for the compressed data. Pass `NULL` to use the default allocator.
    ///
    /// In MacOS 10.12 and later, using a `compressedDataAllocator` may trigger an extra buffer copy.
    ///
    /// - outputCallback: The callback to invoke with compressed frames. The system may call this function asynchronously, on a different thread from the one that calls [`VTCompressionSessionEncodeFrame`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessionencodeframe(_:imagebuffer:presentationtimestamp:duration:frameproperties:sourceframerefcon:infoflagsout:)).
    ///
    /// Pass `NULL` only if you’ll be calling [`VTCompressionSessionEncodeFrameWithOutputHandler`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessionencodeframe(_:imagebuffer:presentationtimestamp:duration:frameproperties:infoflagsout:outputhandler:)) for encoding frames.
    ///
    /// - outputCallbackRefCon: Client-defined reference value for the output callback.
    ///
    /// - compressionSessionOut: A pointer to a variable to receive the new compression session.
    ///
    ///
    /// ## Discussion
    ///
    /// The session outputs compressed frames through the output callback.
    ///
    ///
    /// Creates a session for compressing video frames.
    ///
    /// Compressed frames will be emitted through calls to outputCallback.
    ///
    /// Parameter `allocator`: An allocator for the session.  Pass NULL to use the default allocator.
    ///
    /// Parameter `width`: The width of frames, in pixels.
    /// If the video encoder cannot support the provided width and height it may change them.
    ///
    /// Parameter `height`: The height of frames in pixels.
    ///
    /// Parameter `codecType`: The codec type.
    ///
    /// Parameter `encoderSpecification`: Specifies a particular video encoder that must be used.
    /// Pass NULL to let the video toolbox choose a encoder.
    ///
    /// Parameter `sourceImageBufferAttributes`: Required attributes for source pixel buffers, used when creating a pixel buffer pool
    /// for source frames.  If you do not want the Video Toolbox to create one for you, pass NULL.
    /// (Using pixel buffers not allocated by the Video Toolbox may increase the chance that
    /// it will be necessary to copy image data.)
    ///
    /// Parameter `compressedDataAllocator`: An allocator for the compressed data.  Pass NULL to use the default allocator.
    /// Note: on MacOS 10.12 and later, using a compressedDataAllocator may trigger an extra buffer copy.
    ///
    /// Parameter `outputCallback`: The callback to be called with compressed frames.
    /// This function may be called asynchronously, on a different thread from the one that calls VTCompressionSessionEncodeFrame.
    /// Pass NULL if and only if you will be calling VTCompressionSessionEncodeFrameWithOutputHandler for encoding frames.
    ///
    /// Parameter `outputCallbackRefCon`: Client-defined reference value for the output callback.
    ///
    /// Parameter `compressionSessionOut`: Points to a variable to receive the new compression session.
    ///
    /// # Safety
    ///
    /// - `encoder_specification` generic must be of the correct type.
    /// - `encoder_specification` generic must be of the correct type.
    /// - `source_image_buffer_attributes` generic must be of the correct type.
    /// - `source_image_buffer_attributes` generic must be of the correct type.
    /// - `output_callback` must be implemented correctly.
    /// - `output_callback_ref_con` must be a valid pointer or null.
    /// - `compression_session_out` must be a valid pointer.
    #[doc(alias = "VTCompressionSessionCreate")]
    #[cfg(all(feature = "VTErrors", feature = "objc2-core-media"))]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        width: i32,
        height: i32,
        codec_type: CMVideoCodecType,
        encoder_specification: Option<&CFDictionary>,
        source_image_buffer_attributes: Option<&CFDictionary>,
        compressed_data_allocator: Option<&CFAllocator>,
        output_callback: VTCompressionOutputCallback,
        output_callback_ref_con: *mut c_void,
        compression_session_out: NonNull<*mut VTCompressionSession>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionCreate(
                allocator: Option<&CFAllocator>,
                width: i32,
                height: i32,
                codec_type: CMVideoCodecType,
                encoder_specification: Option<&CFDictionary>,
                source_image_buffer_attributes: Option<&CFDictionary>,
                compressed_data_allocator: Option<&CFAllocator>,
                output_callback: VTCompressionOutputCallback,
                output_callback_ref_con: *mut c_void,
                compression_session_out: NonNull<*mut VTCompressionSession>,
            ) -> OSStatus;
        }
        unsafe {
            VTCompressionSessionCreate(
                allocator,
                width,
                height,
                codec_type,
                encoder_specification,
                source_image_buffer_attributes,
                compressed_data_allocator,
                output_callback,
                output_callback_ref_con,
                compression_session_out,
            )
        }
    }

    /// Tears down a compression session.
    ///
    /// Parameters:
    /// - session: The compression session to invalidate.
    ///
    ///
    /// ## Discussion
    ///
    /// When you finish using a compression session you created, call `VTCompressionSessionInvalidate` to tear it down, and then call [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) to release its memory.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  A compression session is automatically invalidated when its retain count reaches zero, but because sessions may be retained by multiple parties, it’s hard to predict when this will happen.  Calling `VTCompressionSessionInvalidate` ensures a deterministic, orderly teardown.
    ///
    ///
    ///
    /// </div>
    ///
    /// Tears down a compression session.
    ///
    /// When you are done with a compression session you created, call VTCompressionSessionInvalidate
    /// to tear it down and then CFRelease to release your object reference.
    /// When a compression session's retain count reaches zero, it is automatically invalidated, but
    /// since sessions may be retained by multiple parties, it can be hard to predict when this will happen.
    /// Calling VTCompressionSessionInvalidate ensures a deterministic, orderly teardown.
    #[doc(alias = "VTCompressionSessionInvalidate")]
    #[inline]
    pub unsafe fn invalidate(&self) {
        extern "C-unwind" {
            fn VTCompressionSessionInvalidate(session: &VTCompressionSession);
        }
        unsafe { VTCompressionSessionInvalidate(self) }
    }
}

unsafe impl ConcreteType for VTCompressionSession {
    /// Retrieves the Core Foundation type identifier for the compression session.
    ///
    /// ## Return Value
    ///
    /// The [`CFTypeID`](https://developer.apple.com/documentation/corefoundation/cftypeid) of the compression session object.
    ///
    ///
    /// Returns the CFTypeID for compression sessions.
    #[doc(alias = "VTCompressionSessionGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn VTCompressionSessionGetTypeID() -> CFTypeID;
        }
        unsafe { VTCompressionSessionGetTypeID() }
    }
}

impl VTCompressionSession {
    /// Returns a pool that provides ideal source pixel buffers for a compression session.
    ///
    /// Parameters:
    /// - session: The compression session.
    ///
    ///
    /// ## Return Value
    ///
    /// A configured pixel buffer pool.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The compression session creates this pixel buffer pool based on the compressor’s pixel buffer attributes and any pixel buffer attributes passed in to [`VTCompressionSessionCreate`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessioncreate(allocator:width:height:codectype:encoderspecification:imagebufferattributes:compresseddataallocator:outputcallback:refcon:compressionsessionout:)).  If the source pixel buffer attributes and the compressor pixel buffer attributes cannot be reconciled, the pool is based on the source pixel buffer attributes, and VideoToolbox converts each [`CVImageBufferRef`](https://developer.apple.com/documentation/corevideo/cvimagebuffer) internally.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Clients can call this function once and retain the resulting pool, but the call is cheap enough that it’s ok to call it once per frame.  If a change of session properties causes the compressor’s pixel buffer attributes to change, it’s possible that this function might return a different pool.
    ///
    ///
    ///
    /// </div>
    ///
    /// Returns a pool that can provide ideal source pixel buffers for a compression session.
    ///
    /// The compression session creates this pixel buffer pool based on
    /// the compressor's pixel buffer attributes and any pixel buffer
    /// attributes passed in to VTCompressionSessionCreate.  If the
    /// source pixel buffer attributes and the compressor pixel buffer
    /// attributes cannot be reconciled, the pool is based on the source
    /// pixel buffer attributes and the Video Toolbox converts each CVImageBuffer
    /// internally.
    /// <BR
    /// >
    /// While clients can call VTCompressionSessionGetPixelBufferPool once
    /// and retain the resulting pool, the call is cheap enough that it's OK
    /// to call it once per frame.  If a change of session properties causes
    /// the compressor's pixel buffer attributes to change, it's possible that
    /// VTCompressionSessionGetPixelBufferPool might return a different pool.
    #[doc(alias = "VTCompressionSessionGetPixelBufferPool")]
    #[cfg(feature = "objc2-core-video")]
    #[inline]
    pub unsafe fn pixel_buffer_pool(&self) -> Option<CFRetained<CVPixelBufferPool>> {
        extern "C-unwind" {
            fn VTCompressionSessionGetPixelBufferPool(
                session: &VTCompressionSession,
            ) -> Option<NonNull<CVPixelBufferPool>>;
        }
        let ret = unsafe { VTCompressionSessionGetPixelBufferPool(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Enables the encoder to perform any necessary resource allocation before the encoder begins encoding frames (optional).
    ///
    /// Parameters:
    /// - session: The compression session.
    ///
    ///
    /// ## Discussion
    ///
    /// If this function isn’t called, any necessary resources are allocated on the first [`VTCompressionSessionEncodeFrame`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessionencodeframe(_:imagebuffer:presentationtimestamp:duration:frameproperties:sourceframerefcon:infoflagsout:)) call.
    ///
    /// Subsequent calls to this function have no effect.
    ///
    ///
    /// You can optionally call this function to provide the encoder with an opportunity to perform
    /// any necessary resource allocation before it begins encoding frames.
    ///
    /// This optional call can be used to provide the encoder an opportunity to allocate
    /// any resources necessary before it begins encoding frames.  If this isn't called, any
    /// necessary resources will be allocated on the first VTCompressionSessionEncodeFrame call.
    /// Extra calls to this function will have no effect.
    ///
    /// Parameter `session`: The compression session.
    #[doc(alias = "VTCompressionSessionPrepareToEncodeFrames")]
    #[inline]
    pub unsafe fn prepare_to_encode_frames(&self) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionPrepareToEncodeFrames(
                session: &VTCompressionSession,
            ) -> OSStatus;
        }
        unsafe { VTCompressionSessionPrepareToEncodeFrames(self) }
    }

    /// Presents frames to the compression session.
    ///
    /// Parameters:
    /// - session: The compression session.
    ///
    /// - imageBuffer: A Core Video image buffer ([`CVImageBufferRef`](https://developer.apple.com/documentation/corevideo/cvimagebuffer)) containing a video frame to be compressed. The buffer must have a nonzero reference count.
    ///
    /// - presentationTimeStamp: The presentation timestamp for this frame, to be attached to the sample buffer. Each presentation timestamp passed to a session must be greater than the previous one.
    ///
    /// - duration: The presentation duration for this frame, to be attached to the sample buffer. If you do not have duration information, pass [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid).
    ///
    /// - frameProperties: Key/value pairs specifying additional properties for encoding this frame. Note that some session properties may also be changed between frames. Such changes affect subsequently encoded frames.
    ///
    /// - sourceFrameRefcon: Your reference value for the frame, which will be passed to the output callback function.
    ///
    /// - infoFlagsOut: A pointer to a `VTEncodeInfoFlags` to receive information about the encode operation.
    ///
    /// The [`kVTEncodeInfo_Asynchronous`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/asynchronous) bit may be set if the encode is (or was) running asynchronously.
    ///
    /// The [`kVTEncodeInfo_FrameDropped`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/framedropped) bit may be set if the frame was dropped (synchronously).
    ///
    /// Pass `NULL` if you do not want to receive this information.
    ///
    ///
    /// ## Discussion
    ///
    /// Encoded frames may or may not be output before the function returns. The client should not modify the pixel data after making this call. The session and/or encoder retains the image buffer as long as necessary.
    ///
    ///
    /// Call this function to present frames to the compression session.
    /// Encoded frames may or may not be output before the function returns.
    ///
    /// The client should not modify the pixel data after making this call.
    /// The session and/or encoder will retain the image buffer as long as necessary.
    ///
    /// Parameter `session`: The compression session.
    ///
    /// Parameter `imageBuffer`: A CVImageBuffer containing a video frame to be compressed.
    /// Must have a nonzero reference count.
    ///
    /// Parameter `presentationTimeStamp`: The presentation timestamp for this frame, to be attached to the sample buffer.
    /// Each presentation timestamp passed to a session must be greater than the previous one.
    ///
    /// Parameter `duration`: The presentation duration for this frame, to be attached to the sample buffer.
    /// If you do not have duration information, pass kCMTimeInvalid.
    ///
    /// Parameter `frameProperties`: Contains key/value pairs specifying additional properties for encoding this frame.
    /// Note that some session properties may also be changed between frames.
    /// Such changes have effect on subsequently encoded frames.
    ///
    /// Parameter `sourceFrameRefcon`: Your reference value for the frame, which will be passed to the output callback function.
    ///
    /// Parameter `infoFlagsOut`: Points to a VTEncodeInfoFlags to receive information about the encode operation.
    /// The kVTEncodeInfo_Asynchronous bit may be set if the encode is (or was) running
    /// asynchronously.
    /// The kVTEncodeInfo_FrameDropped bit may be set if the frame was dropped (synchronously).
    /// Pass NULL if you do not want to receive this information.
    ///
    /// # Safety
    ///
    /// - `frame_properties` generic must be of the correct type.
    /// - `frame_properties` generic must be of the correct type.
    /// - `source_frame_refcon` must be a valid pointer or null.
    /// - `info_flags_out` must be a valid pointer or null.
    #[doc(alias = "VTCompressionSessionEncodeFrame")]
    #[cfg(all(
        feature = "VTErrors",
        feature = "objc2-core-media",
        feature = "objc2-core-video"
    ))]
    #[inline]
    pub unsafe fn encode_frame(
        &self,
        image_buffer: &CVImageBuffer,
        presentation_time_stamp: CMTime,
        duration: CMTime,
        frame_properties: Option<&CFDictionary>,
        source_frame_refcon: *mut c_void,
        info_flags_out: *mut VTEncodeInfoFlags,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionEncodeFrame(
                session: &VTCompressionSession,
                image_buffer: &CVImageBuffer,
                presentation_time_stamp: CMTime,
                duration: CMTime,
                frame_properties: Option<&CFDictionary>,
                source_frame_refcon: *mut c_void,
                info_flags_out: *mut VTEncodeInfoFlags,
            ) -> OSStatus;
        }
        unsafe {
            VTCompressionSessionEncodeFrame(
                self,
                image_buffer,
                presentation_time_stamp,
                duration,
                frame_properties,
                source_frame_refcon,
                info_flags_out,
            )
        }
    }
}

/// A callback for the system to invoke when it’s finished compressing a frame.
///
/// Parameters:
/// - status: `noErr` if compression was successful; an error code if compression was not successful.
///
/// - infoFlags: Contains information about the encode operation.
///
/// The [`kVTEncodeInfo_Asynchronous`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/asynchronous) bit may be set if the encode ran asynchronously.
///
/// The [`kVTEncodeInfo_FrameDropped`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/framedropped) bit may be set if the frame was dropped.
///
/// - sampleBuffer: Contains the compressed frame if compression was successful and the frame was not dropped; otherwise, `NULL`.
///
///
/// ## Discussion
///
/// When you encode a frame, you pass in a callback block to be called for that compressed frame.  This block is called in decode order (which is not necessarily the same as display order).
///
///
/// Prototype for block invoked when frame compression is complete.
///
/// When you encode a frame, you pass in a callback block to be called
/// for that compressed frame.  This block will be called in decode order (which is not
/// necessarily the same as display order).
///
/// Parameter `status`: noErr if compression was successful; an error code if compression was not successful.
///
/// Parameter `infoFlags`: Contains information about the encode operation.
/// The kVTEncodeInfo_Asynchronous bit may be set if the encode ran asynchronously.
/// The kVTEncodeInfo_FrameDropped bit may be set if the frame was dropped.
///
/// Parameter `sampleBuffer`: Contains the compressed frame, if compression was successful and the frame was not dropped;
/// otherwise, NULL.
#[cfg(all(feature = "VTErrors", feature = "block2", feature = "objc2-core-media"))]
pub type VTCompressionOutputHandler =
    *mut block2::DynBlock<dyn Fn(OSStatus, VTEncodeInfoFlags, *mut CMSampleBuffer)>;

impl VTCompressionSession {
    /// Presents frames to the compression session and invokes the output callback when compression is complete.
    ///
    /// Parameters:
    /// - session: The compression session.
    ///
    /// - imageBuffer: A Core Video image buffer ([`CVImageBufferRef`](https://developer.apple.com/documentation/corevideo/cvimagebuffer)) containing a video frame to be compressed. The buffer must have a nonzero reference count.
    ///
    /// - presentationTimeStamp: The presentation timestamp for this frame, to be attached to the sample buffer. Each presentation timestamp passed to a session must be greater than the previous one.
    ///
    /// - duration: The presentation duration for this frame, to be attached to the sample buffer. If you do not have duration information, pass [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid).
    ///
    /// - frameProperties: Key/value pairs specifying additional properties for encoding this frame. Note that some session properties may also be changed between frames. Such changes affect subsequently encoded frames.
    ///
    /// - infoFlagsOut: A pointer to a `VTEncodeInfoFlags` to receive information about the encode operation.
    ///
    /// The [`kVTEncodeInfo_Asynchronous`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/asynchronous) bit may be set if the encode is (or was) running asynchronously.
    ///
    /// The [`kVTEncodeInfo_FrameDropped`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/framedropped) bit may be set if the frame was dropped (synchronously).
    ///
    /// Pass `NULL` if you do not want to receive this information.
    ///
    /// - outputHandler: The block to be called when encoding the frame is completed. This block may be called asynchronously, on a different thread from the one that calls `VTCompressionSessionEncodeFrameWithOutputHandler`.
    ///
    ///
    /// ## Discussion
    ///
    /// Encoded frames may or may not be output before the function returns. The client should not modify the pixel data after making this call. The session and/or encoder retains the image buffer as long as necessary.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  This function cannot be called with a session created with a [`VTCompressionOutputCallback`](https://developer.apple.com/documentation/videotoolbox/vtcompressionoutputcallback).
    ///
    ///
    ///
    /// </div>
    ///
    /// Call this function to present frames to the compression session.
    /// Encoded frames may or may not be output before the function returns.
    ///
    /// The client should not modify the pixel data after making this call.
    /// The session and/or encoder will retain the image buffer as long as necessary.
    /// Cannot be called with a session created with a VTCompressionOutputCallback.
    ///
    /// Parameter `session`: The compression session.
    ///
    /// Parameter `imageBuffer`: A CVImageBuffer containing a video frame to be compressed.
    /// Must have a nonzero reference count.
    ///
    /// Parameter `presentationTimeStamp`: The presentation timestamp for this frame, to be attached to the sample buffer.
    /// Each presentation timestamp passed to a session must be greater than the previous one.
    ///
    /// Parameter `duration`: The presentation duration for this frame, to be attached to the sample buffer.
    /// If you do not have duration information, pass kCMTimeInvalid.
    ///
    /// Parameter `frameProperties`: Contains key/value pairs specifying additional properties for encoding this frame.
    /// Note that some session properties may also be changed between frames.
    /// Such changes have effect on subsequently encoded frames.
    ///
    /// Parameter `infoFlagsOut`: Points to a VTEncodeInfoFlags to receive information about the encode operation.
    /// The kVTEncodeInfo_Asynchronous bit may be set if the encode is (or was) running
    /// asynchronously.
    /// The kVTEncodeInfo_FrameDropped bit may be set if the frame was dropped (synchronously).
    /// Pass NULL if you do not want to receive this information.
    ///
    /// Parameter `outputHandler`: The block to be called when encoding the frame is completed.
    /// This block may be called asynchronously, on a different thread from the one that calls VTCompressionSessionEncodeFrameWithOutputHandler.
    ///
    /// # Safety
    ///
    /// - `frame_properties` generic must be of the correct type.
    /// - `frame_properties` generic must be of the correct type.
    /// - `info_flags_out` must be a valid pointer or null.
    /// - `output_handler` must be a valid pointer.
    #[doc(alias = "VTCompressionSessionEncodeFrameWithOutputHandler")]
    #[cfg(all(
        feature = "VTErrors",
        feature = "block2",
        feature = "objc2-core-media",
        feature = "objc2-core-video"
    ))]
    #[inline]
    pub unsafe fn encode_frame_with_output_handler(
        &self,
        image_buffer: &CVImageBuffer,
        presentation_time_stamp: CMTime,
        duration: CMTime,
        frame_properties: Option<&CFDictionary>,
        info_flags_out: *mut VTEncodeInfoFlags,
        output_handler: VTCompressionOutputHandler,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionEncodeFrameWithOutputHandler(
                session: &VTCompressionSession,
                image_buffer: &CVImageBuffer,
                presentation_time_stamp: CMTime,
                duration: CMTime,
                frame_properties: Option<&CFDictionary>,
                info_flags_out: *mut VTEncodeInfoFlags,
                output_handler: VTCompressionOutputHandler,
            ) -> OSStatus;
        }
        unsafe {
            VTCompressionSessionEncodeFrameWithOutputHandler(
                self,
                image_buffer,
                presentation_time_stamp,
                duration,
                frame_properties,
                info_flags_out,
                output_handler,
            )
        }
    }

    /// Forces the compression session to complete the encoding of frames.
    ///
    /// Parameters:
    /// - session: The compression session.
    ///
    /// - completeUntilPresentationTimeStamp: The timestamp at which to complete frame encoding.
    ///
    ///
    /// ## Discussion
    ///
    /// If `completeUntilPresentationTimeStamp` is numeric, frames with presentation timestamps up to and including this timestamp are emitted before the function returns.
    ///
    /// If `completeUntilPresentationTimeStamp` is non-numeric, all pending frames are emitted before the function returns.
    ///
    ///
    /// Forces the compression session to complete encoding frames.
    ///
    /// If completeUntilPresentationTimeStamp is numeric, frames with presentation timestamps
    /// up to and including this timestamp will be emitted before the function returns.
    /// If completeUntilPresentationTimeStamp is non-numeric, all pending frames
    /// will be emitted before the function returns.
    #[doc(alias = "VTCompressionSessionCompleteFrames")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn complete_frames(
        &self,
        complete_until_presentation_time_stamp: CMTime,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionCompleteFrames(
                session: &VTCompressionSession,
                complete_until_presentation_time_stamp: CMTime,
            ) -> OSStatus;
        }
        unsafe { VTCompressionSessionCompleteFrames(self, complete_until_presentation_time_stamp) }
    }
}

/// Returns a Boolean value that indicates whether the system supports MV-HEVC encoding.
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the system supports MV-HEVC encoding; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
///
///
///
/// ## Discussion
///
/// A return value of [`true`](https://developer.apple.com/documentation/swift/true) doesn’t guarantee that encoding resources are available at all times.
///
///
/// Indicates whether the current system supports stereo MV-HEVC encode.
///
/// This call returning true does not guarantee that encode resources will be available at all times.
#[inline]
pub unsafe extern "C-unwind" fn VTIsStereoMVHEVCEncodeSupported() -> bool {
    extern "C-unwind" {
        fn VTIsStereoMVHEVCEncodeSupported() -> Boolean;
    }
    let ret = unsafe { VTIsStereoMVHEVCEncodeSupported() };
    ret != 0
}

impl VTCompressionSession {
    /// Passes a multi-image frame to a compression session for encoding.
    ///
    /// Parameters:
    /// - session: The compression session.
    ///
    /// - taggedBufferGroup: A [`CMTaggedBufferGroupRef`](https://developer.apple.com/documentation/coremedia/cmtaggedbuffergroupref) that contains the multiple images for a video frame to compress.
    ///
    /// - presentationTimeStamp: The presentation timestamp for this frame to attach to the sample buffer. Each presentation timestamp that you pass to a session must be greater than the previous one.
    ///
    /// - duration: The presentation duration for this frame to attach to the sample buffer. If you don’t have duration information, pass [`invalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid).
    ///
    /// - frameProperties: A dictionary that specifies additional properties for encoding this frame. Some session properties may also change between frames, which affect subsequently encoded frames.
    ///
    /// - sourceFrameRefcon: Your reference value for the frame, which the system passes to the output callback function.
    ///
    /// - infoFlagsOut: Points to a [`VTEncodeInfoFlags`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags) value to receive information about the encode operation.
    ///
    /// The system sets the [`asynchronous`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/asynchronous) flag if the encode runs asynchronously.
    ///
    /// The system sets the [`frameDropped`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/framedropped) flag if the encoding process dropped a frame (synchronously).
    ///
    /// Pass `NULL` if you don’t want to receive this information.
    ///
    ///
    /// ## Return Value
    ///
    /// An `OSStatus` value that indicates the result of the operation.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The system doesn’t guarantee that encoded frames be output before the function returns. The session and encoder retain the image buffer as long as necessary.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Don’t modify the pixel data after making this call.
    ///
    ///
    ///
    /// </div>
    ///
    /// Call this function to present a multi-image frame to the compression session.
    /// Encoded frames may or may not be output before the function returns.
    ///
    /// The client should not modify the pixel data after making this call.
    /// The session and/or encoder will retain the image buffer as long as necessary.
    ///
    /// Parameter `session`: The compression session.
    ///
    /// Parameter `taggedBufferGroup`: A CMTaggedBufferGroup containing the multiple images for a video frame to be compressed.
    ///
    /// Parameter `presentationTimeStamp`: The presentation timestamp for this frame, to be attached to the sample buffer.
    /// Each presentation timestamp passed to a session must be greater than the previous one.
    ///
    /// Parameter `duration`: The presentation duration for this frame, to be attached to the sample buffer.
    /// If you do not have duration information, pass kCMTimeInvalid.
    ///
    /// Parameter `frameProperties`: Contains key/value pairs specifying additional properties for encoding this frame.
    /// Note that some session properties may also be changed between frames.
    /// Such changes have effect on subsequently encoded frames.
    ///
    /// Parameter `sourceFrameRefcon`: Your reference value for the frame, which will be passed to the output callback function.
    ///
    /// Parameter `infoFlagsOut`: Points to a VTEncodeInfoFlags to receive information about the encode operation.
    /// The kVTEncodeInfo_Asynchronous bit may be set if the encode is (or was) running
    /// asynchronously.
    /// The kVTEncodeInfo_FrameDropped bit may be set if the frame was dropped (synchronously).
    /// Pass NULL if you do not want to receive this information.
    ///
    /// # Safety
    ///
    /// - `frame_properties` generic must be of the correct type.
    /// - `frame_properties` generic must be of the correct type.
    /// - `source_frame_refcon` must be a valid pointer or null.
    /// - `info_flags_out` must be a valid pointer or null.
    #[doc(alias = "VTCompressionSessionEncodeMultiImageFrame")]
    #[cfg(all(feature = "VTErrors", feature = "objc2-core-media"))]
    #[inline]
    pub unsafe fn encode_multi_image_frame(
        &self,
        tagged_buffer_group: &CMTaggedBufferGroup,
        presentation_time_stamp: CMTime,
        duration: CMTime,
        frame_properties: Option<&CFDictionary>,
        source_frame_refcon: *mut c_void,
        info_flags_out: *mut VTEncodeInfoFlags,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionEncodeMultiImageFrame(
                session: &VTCompressionSession,
                tagged_buffer_group: &CMTaggedBufferGroup,
                presentation_time_stamp: CMTime,
                duration: CMTime,
                frame_properties: Option<&CFDictionary>,
                source_frame_refcon: *mut c_void,
                info_flags_out: *mut VTEncodeInfoFlags,
            ) -> OSStatus;
        }
        unsafe {
            VTCompressionSessionEncodeMultiImageFrame(
                self,
                tagged_buffer_group,
                presentation_time_stamp,
                duration,
                frame_properties,
                source_frame_refcon,
                info_flags_out,
            )
        }
    }

    /// Passes a multi-image frame to a compression session for encoding and provides a callback to handle the output.
    ///
    /// Parameters:
    /// - session: The compression session.
    ///
    /// - taggedBufferGroup: A [`CMTaggedBufferGroupRef`](https://developer.apple.com/documentation/coremedia/cmtaggedbuffergroupref) that contains the multiple images for a video frame to compress.
    ///
    /// - presentationTimeStamp: The presentation timestamp for this frame to attach to the sample buffer. Each presentation timestamp that you pass to a session must be greater than the previous one.
    ///
    /// - duration: The presentation duration for this frame to attach to the sample buffer. Pass a value of [`invalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid) if you don’t have duration information.
    ///
    /// - frameProperties: A dictionary that specifies additional properties for encoding this frame. Some session properties may also change between frames, which affect subsequently encoded frames.
    ///
    /// - infoFlagsOut: Points to a [`VTEncodeInfoFlags`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags) value to receive information about the encode operation.
    ///
    /// The system sets the [`asynchronous`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/asynchronous) flag if the encode runs asynchronously.
    ///
    /// The system sets the [`frameDropped`](https://developer.apple.com/documentation/videotoolbox/vtencodeinfoflags/framedropped) flag if the encoding process dropped a frame (synchronously).
    ///
    /// Pass `NULL` if you don’t want to receive this information.
    ///
    /// - outputHandler: A callback the system invokes when it completes encoding a frame.
    ///
    /// The system may invoke this callback asynchronously, on a different thread from the one that calls [`VTCompressionSessionEncodeMultiImageFrameWithOutputHandler`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessionencodemultiimageframewithoutputhandler).
    ///
    ///
    /// ## Return Value
    ///
    /// An `OSStatus` value that indicates the result of the operation.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The system doesn’t guarantee that encoded frames be output before the function returns. The session and encoder retain the image buffer as long as necessary.
    ///
    /// You can’t call this function on a session created with a [`VTCompressionOutputCallback`](https://developer.apple.com/documentation/videotoolbox/vtcompressionoutputcallback).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Don’t modify the pixel data after making this call.
    ///
    ///
    ///
    /// </div>
    ///
    /// Call this function to present a multi-image frame to the compression session.
    /// Encoded frames may or may not be output before the function returns.
    ///
    /// The client should not modify the pixel data after making this call.
    /// The session and/or encoder will retain the image buffer as long as necessary.
    /// Cannot be called with a session created with a VTCompressionOutputCallback.
    ///
    /// Parameter `session`: The compression session.
    ///
    /// Parameter `taggedBufferGroup`: A CMTaggedBufferGroup containing the multiple images for a video frame to be compressed.
    ///
    /// Parameter `presentationTimeStamp`: The presentation timestamp for this frame, to be attached to the sample buffer.
    /// Each presentation timestamp passed to a session must be greater than the previous one.
    ///
    /// Parameter `duration`: The presentation duration for this frame, to be attached to the sample buffer.
    /// If you do not have duration information, pass kCMTimeInvalid.
    ///
    /// Parameter `frameProperties`: Contains key/value pairs specifying additional properties for encoding this frame.
    /// Note that some session properties may also be changed between frames.
    /// Such changes have effect on subsequently encoded frames.
    ///
    /// Parameter `infoFlagsOut`: Points to a VTEncodeInfoFlags to receive information about the encode operation.
    /// The kVTEncodeInfo_Asynchronous bit may be set if the encode is (or was) running
    /// asynchronously.
    /// The kVTEncodeInfo_FrameDropped bit may be set if the frame was dropped (synchronously).
    /// Pass NULL if you do not want to receive this information.
    ///
    /// Parameter `outputHandler`: The block to be called when encoding the frame is completed.
    /// This block may be called asynchronously, on a different thread from the one that calls VTCompressionSessionEncodeMultiImageFrameWithOutputHandler.
    ///
    /// # Safety
    ///
    /// - `frame_properties` generic must be of the correct type.
    /// - `frame_properties` generic must be of the correct type.
    /// - `info_flags_out` must be a valid pointer or null.
    /// - `output_handler` must be a valid pointer.
    #[doc(alias = "VTCompressionSessionEncodeMultiImageFrameWithOutputHandler")]
    #[cfg(all(feature = "VTErrors", feature = "block2", feature = "objc2-core-media"))]
    #[inline]
    pub unsafe fn encode_multi_image_frame_with_output_handler(
        &self,
        tagged_buffer_group: &CMTaggedBufferGroup,
        presentation_time_stamp: CMTime,
        duration: CMTime,
        frame_properties: Option<&CFDictionary>,
        info_flags_out: *mut VTEncodeInfoFlags,
        output_handler: VTCompressionOutputHandler,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionEncodeMultiImageFrameWithOutputHandler(
                session: &VTCompressionSession,
                tagged_buffer_group: &CMTaggedBufferGroup,
                presentation_time_stamp: CMTime,
                duration: CMTime,
                frame_properties: Option<&CFDictionary>,
                info_flags_out: *mut VTEncodeInfoFlags,
                output_handler: VTCompressionOutputHandler,
            ) -> OSStatus;
        }
        unsafe {
            VTCompressionSessionEncodeMultiImageFrameWithOutputHandler(
                self,
                tagged_buffer_group,
                presentation_time_stamp,
                duration,
                frame_properties,
                info_flags_out,
                output_handler,
            )
        }
    }
}

/// Flags to pass to a compression session.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct VTCompressionSessionOptionFlags(pub u32);
bitflags::bitflags! {
    impl VTCompressionSessionOptionFlags: u32 {
/// A flag that indicates the last pass in a multi-pass compression session.
        #[doc(alias = "kVTCompressionSessionBeginFinalPass")]
        const BeginFinalPass = 1<<0;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for VTCompressionSessionOptionFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for VTCompressionSessionOptionFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl VTCompressionSession {
    /// Marks the start of a specific compression pass.
    ///
    /// Parameters:
    /// - session: A compression session.
    ///
    /// - beginPassFlags: Pass [`kVTCompressionSessionBeginFinalPass`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessionoptionflags/beginfinalpass) to inform the encoder that the pass must be the final pass.
    ///
    /// - reserved: A reserved value.
    ///
    ///
    /// ## Discussion
    ///
    /// During multipass encoding, this function must be called before [`VTCompressionSessionEncodeFrame`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessionencodeframe(_:imagebuffer:presentationtimestamp:duration:frameproperties:sourceframerefcon:infoflagsout:)).
    ///
    /// It’s an error to call this function when multipass encoding is not enabled by setting [`kVTCompressionPropertyKey_MultiPassStorage`](https://developer.apple.com/documentation/videotoolbox/kvtcompressionpropertykey_multipassstorage).
    ///
    ///
    /// Call to announce the start of a specific compression pass.
    ///
    /// During multi-pass encoding, this function must be called before VTCompressionSessionEncodeFrame.
    /// It is an error to call this function when multi-pass encoding has not been enabled by setting kVTCompressionPropertyKey_MultiPassStorage.
    ///
    /// Parameter `beginPassFlags`: Pass kVTCompressionSessionBeginFinalPass to inform the encoder that the pass must be the final pass.
    ///
    /// # Safety
    ///
    /// `reserved` must be a valid pointer or null.
    #[doc(alias = "VTCompressionSessionBeginPass")]
    #[inline]
    pub unsafe fn begin_pass(
        &self,
        begin_pass_flags: VTCompressionSessionOptionFlags,
        reserved: *mut u32,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionBeginPass(
                session: &VTCompressionSession,
                begin_pass_flags: VTCompressionSessionOptionFlags,
                reserved: *mut u32,
            ) -> OSStatus;
        }
        unsafe { VTCompressionSessionBeginPass(self, begin_pass_flags, reserved) }
    }

    /// Marks the end of a compression pass.
    ///
    /// Parameters:
    /// - session: The compression session.
    ///
    /// - furtherPassesRequestedOut: A pointer to a Boolean that is set to [`true`](https://developer.apple.com/documentation/swift/true) if the video encoder requests to perform another pass, [`false`](https://developer.apple.com/documentation/swift/false) otherwise. You may pass `NULL` to indicate that the client is certain to use this as the final pass, in which case the video encoder can skip that evaluation step.
    ///
    /// - reserved: Reserved for future use and not currently used. Pass `NULL` for this argument.
    ///
    ///
    /// ## Discussion
    ///
    /// This function can take a long time, because the video encoder may perform significant processing between passes. You indicate with the `furtherPassesRequestedOut` argument whether the video encoder is requesting another pass.  There is no particular limit on the number of passes the video encoder may request, but the client is free to disregard this request and use the last-emitted set of frames.
    ///
    /// It’s an error to call this function when multi-pass encoding has not been enabled by setting [`kVTCompressionPropertyKey_MultiPassStorage`](https://developer.apple.com/documentation/videotoolbox/kvtcompressionpropertykey_multipassstorage).
    ///
    ///
    /// Call to announce the end of a pass.
    ///
    /// VTCompressionSessionEndPass can take a long time, since the video encoder may perform significant processing between passes.
    /// VTCompressionSessionEndPass will indicate via the furtherPassesRequestedOut argument whether the video encoder would like to perform another pass.  There is no particular bound on the number of passes the video encoder may request, but the client is free to disregard this request and use the last-emitted set of frames.
    /// It is an error to call this function when multi-pass encoding has not been enabled by setting kVTCompressionPropertyKey_MultiPassStorage.
    ///
    /// Parameter `furtherPassesRequestedOut`: Points to a Boolean that will be set to true if the video encoder would like to perform another pass, false otherwise.
    /// You may pass NULL to indicate that the client is certain to use this as the final pass, in which case the video encoder can skip that evaluation step.
    ///
    /// # Safety
    ///
    /// - `further_passes_requested_out` must be a valid pointer or null.
    /// - `reserved` must be a valid pointer or null.
    #[doc(alias = "VTCompressionSessionEndPass")]
    #[inline]
    pub unsafe fn end_pass(
        &self,
        further_passes_requested_out: *mut Boolean,
        reserved: *mut u32,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionEndPass(
                session: &VTCompressionSession,
                further_passes_requested_out: *mut Boolean,
                reserved: *mut u32,
            ) -> OSStatus;
        }
        unsafe { VTCompressionSessionEndPass(self, further_passes_requested_out, reserved) }
    }

    /// Retrieves the time ranges for the next pass.
    ///
    /// Parameters:
    /// - session: The compression session.
    ///
    /// - timeRangeCountOut: A pointer to the item count ([`CMItemCount`](https://developer.apple.com/documentation/coremedia/cmitemcount)) to receive the number of `CMTimeRanges`.
    ///
    /// - timeRangeArrayOut: A pointer to a C array of `CMTimeRanges`. The storage for this array belongs to the compression session and should not be modified.The pointer is valid until the next call to [`VTCompressionSessionEndPass`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessionendpass(_:furtherpassesrequestedout:_:)), or until the compression session is invalidated or finalized.
    ///
    ///
    /// ## Discussion
    ///
    /// If [`VTCompressionSessionEndPass`](https://developer.apple.com/documentation/videotoolbox/vtcompressionsessionendpass(_:furtherpassesrequestedout:_:)) sets `furtherPassesRequestedOut` to [`true`](https://developer.apple.com/documentation/swift/true), call this function to find out the time ranges for the next pass.  Source frames outside these time ranges should be skipped. Each time range includes any frame at its start time and does not include any frame at its end time.
    ///
    /// It’s an error to call this function when multipass encoding has not been enabled by setting [`kVTCompressionPropertyKey_MultiPassStorage`](https://developer.apple.com/documentation/videotoolbox/kvtcompressionpropertykey_multipassstorage), or when `VTCompressionSessionEndPass` did not set f`urtherPassesRequestedOut` to [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    ///
    /// Retrieves the time ranges for the next pass.
    ///
    /// If VTCompressionSessionEndPass sets *furtherPassesRequestedOut to true, call VTCompressionSessionGetTimeRangesForNextPass to find out the time ranges for the next pass.  Source frames outside these time ranges should be skipped.
    /// Each time range is considered to include any frame at its start time and not to include any frame at its end time.
    /// It is an error to call this function when multi-pass encoding has not been enabled by setting kVTCompressionPropertyKey_MultiPassStorage, or when VTCompressionSessionEndPass did not set *furtherPassesRequestedOut to true.
    ///
    /// Parameter `timeRangeCountOut`: Points to a CMItemCount to receive the number of CMTimeRanges.
    ///
    /// Parameter `timeRangeArrayOut`: Points to a const CMTimeRange * to receive a pointer to a C array of CMTimeRanges.
    /// The storage for this array belongs to the VTCompressionSession and should not be modified.
    /// The pointer will be valid until the next call to VTCompressionSessionEndPass, or until the VTCompressionSession is invalidated or finalized.
    ///
    /// # Safety
    ///
    /// - `time_range_count_out` must be a valid pointer.
    /// - `time_range_array_out` must be a valid pointer.
    #[doc(alias = "VTCompressionSessionGetTimeRangesForNextPass")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn time_ranges_for_next_pass(
        &self,
        time_range_count_out: NonNull<CMItemCount>,
        time_range_array_out: NonNull<*const CMTimeRange>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTCompressionSessionGetTimeRangesForNextPass(
                session: &VTCompressionSession,
                time_range_count_out: NonNull<CMItemCount>,
                time_range_array_out: NonNull<*const CMTimeRange>,
            ) -> OSStatus;
        }
        unsafe {
            VTCompressionSessionGetTimeRangesForNextPass(
                self,
                time_range_count_out,
                time_range_array_out,
            )
        }
    }
}

extern "C-unwind" {
    #[cfg(all(feature = "VTErrors", feature = "objc2-core-media"))]
    #[deprecated = "renamed to `VTCompressionSession::create`"]
    pub fn VTCompressionSessionCreate(
        allocator: Option<&CFAllocator>,
        width: i32,
        height: i32,
        codec_type: CMVideoCodecType,
        encoder_specification: Option<&CFDictionary>,
        source_image_buffer_attributes: Option<&CFDictionary>,
        compressed_data_allocator: Option<&CFAllocator>,
        output_callback: VTCompressionOutputCallback,
        output_callback_ref_con: *mut c_void,
        compression_session_out: NonNull<*mut VTCompressionSession>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTCompressionSession::invalidate`"]
    pub fn VTCompressionSessionInvalidate(session: &VTCompressionSession);
}

#[cfg(feature = "objc2-core-video")]
#[deprecated = "renamed to `VTCompressionSession::pixel_buffer_pool`"]
#[inline]
pub unsafe extern "C-unwind" fn VTCompressionSessionGetPixelBufferPool(
    session: &VTCompressionSession,
) -> Option<CFRetained<CVPixelBufferPool>> {
    extern "C-unwind" {
        fn VTCompressionSessionGetPixelBufferPool(
            session: &VTCompressionSession,
        ) -> Option<NonNull<CVPixelBufferPool>>;
    }
    let ret = unsafe { VTCompressionSessionGetPixelBufferPool(session) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTCompressionSession::prepare_to_encode_frames`"]
    pub fn VTCompressionSessionPrepareToEncodeFrames(session: &VTCompressionSession) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "VTErrors",
        feature = "objc2-core-media",
        feature = "objc2-core-video"
    ))]
    #[deprecated = "renamed to `VTCompressionSession::encode_frame`"]
    pub fn VTCompressionSessionEncodeFrame(
        session: &VTCompressionSession,
        image_buffer: &CVImageBuffer,
        presentation_time_stamp: CMTime,
        duration: CMTime,
        frame_properties: Option<&CFDictionary>,
        source_frame_refcon: *mut c_void,
        info_flags_out: *mut VTEncodeInfoFlags,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(
        feature = "VTErrors",
        feature = "block2",
        feature = "objc2-core-media",
        feature = "objc2-core-video"
    ))]
    #[deprecated = "renamed to `VTCompressionSession::encode_frame_with_output_handler`"]
    pub fn VTCompressionSessionEncodeFrameWithOutputHandler(
        session: &VTCompressionSession,
        image_buffer: &CVImageBuffer,
        presentation_time_stamp: CMTime,
        duration: CMTime,
        frame_properties: Option<&CFDictionary>,
        info_flags_out: *mut VTEncodeInfoFlags,
        output_handler: VTCompressionOutputHandler,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTCompressionSession::complete_frames`"]
    pub fn VTCompressionSessionCompleteFrames(
        session: &VTCompressionSession,
        complete_until_presentation_time_stamp: CMTime,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "VTErrors", feature = "objc2-core-media"))]
    #[deprecated = "renamed to `VTCompressionSession::encode_multi_image_frame`"]
    pub fn VTCompressionSessionEncodeMultiImageFrame(
        session: &VTCompressionSession,
        tagged_buffer_group: &CMTaggedBufferGroup,
        presentation_time_stamp: CMTime,
        duration: CMTime,
        frame_properties: Option<&CFDictionary>,
        source_frame_refcon: *mut c_void,
        info_flags_out: *mut VTEncodeInfoFlags,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "VTErrors", feature = "block2", feature = "objc2-core-media"))]
    #[deprecated = "renamed to `VTCompressionSession::encode_multi_image_frame_with_output_handler`"]
    pub fn VTCompressionSessionEncodeMultiImageFrameWithOutputHandler(
        session: &VTCompressionSession,
        tagged_buffer_group: &CMTaggedBufferGroup,
        presentation_time_stamp: CMTime,
        duration: CMTime,
        frame_properties: Option<&CFDictionary>,
        info_flags_out: *mut VTEncodeInfoFlags,
        output_handler: VTCompressionOutputHandler,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTCompressionSession::begin_pass`"]
    pub fn VTCompressionSessionBeginPass(
        session: &VTCompressionSession,
        begin_pass_flags: VTCompressionSessionOptionFlags,
        reserved: *mut u32,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTCompressionSession::end_pass`"]
    pub fn VTCompressionSessionEndPass(
        session: &VTCompressionSession,
        further_passes_requested_out: *mut Boolean,
        reserved: *mut u32,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTCompressionSession::time_ranges_for_next_pass`"]
    pub fn VTCompressionSessionGetTimeRangesForNextPass(
        session: &VTCompressionSession,
        time_range_count_out: NonNull<CMItemCount>,
        time_range_array_out: NonNull<*const CMTimeRange>,
    ) -> OSStatus;
}
