//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-video")]
use objc2_core_video::*;

use crate::*;

/// A reference to a Video Toolbox Pixel Transfer Session.
///
/// A pixel transfer session supports the copying and/or conversion of
/// images from source CVPixelBuffers to destination CVPixelBuffers.
/// The session reference is a reference-counted CF object.
/// To create a pixel transfer session, call VTPixelTransferSessionCreate;
/// then you can optionally configure the session using VTSessionSetProperty;
/// then to transfer pixels, call VTPixelTransferSessionTransferImage.
/// When you are done with the session, you should call VTPixelTransferSessionInvalidate
/// to tear it down and CFRelease to release your object reference.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/videotoolbox/vtpixeltransfersession?language=objc)
#[repr(C)]
pub struct VTPixelTransferSession {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl VTPixelTransferSession {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueVTPixelTransferSession"> for VTPixelTransferSession {}
);

impl VTPixelTransferSession {
    /// Creates a session for transferring images between CVPixelBuffers.
    ///
    /// The function creates a session for transferring images between CVPixelBuffers.
    ///
    /// Parameter `allocator`: An allocator for the session.  Pass NULL to use the default allocator.
    ///
    /// Parameter `pixelTransferSessionOut`: Points to a variable to receive the new pixel transfer session.
    ///
    /// # Safety
    ///
    /// `pixel_transfer_session_out` must be a valid pointer.
    #[doc(alias = "VTPixelTransferSessionCreate")]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        pixel_transfer_session_out: NonNull<*mut VTPixelTransferSession>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTPixelTransferSessionCreate(
                allocator: Option<&CFAllocator>,
                pixel_transfer_session_out: NonNull<*mut VTPixelTransferSession>,
            ) -> OSStatus;
        }
        unsafe { VTPixelTransferSessionCreate(allocator, pixel_transfer_session_out) }
    }

    /// Tears down a pixel transfer session.
    ///
    /// When you are done with a pixel transfer session you created, call VTPixelTransferSessionInvalidate
    /// to tear it down and then CFRelease to release your object reference.
    /// When a pixel transfer session's retain count reaches zero, it is automatically invalidated, but
    /// since sessions may be retained by multiple parties, it can be hard to predict when this will happen.
    /// Calling VTPixelTransferSessionInvalidate ensures a deterministic, orderly teardown.
    #[doc(alias = "VTPixelTransferSessionInvalidate")]
    #[inline]
    pub unsafe fn invalidate(&self) {
        extern "C-unwind" {
            fn VTPixelTransferSessionInvalidate(session: &VTPixelTransferSession);
        }
        unsafe { VTPixelTransferSessionInvalidate(self) }
    }
}

unsafe impl ConcreteType for VTPixelTransferSession {
    /// Returns the CFTypeID for pixel transfer sessions.
    #[doc(alias = "VTPixelTransferSessionGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn VTPixelTransferSessionGetTypeID() -> CFTypeID;
        }
        unsafe { VTPixelTransferSessionGetTypeID() }
    }
}

impl VTPixelTransferSession {
    /// Copies and/or converts an image from one pixel buffer to another.
    ///
    /// By default, the full width and height of sourceBuffer are scaled to the full
    /// width and height of destinationBuffer.
    /// By default, all existing attachments on destinationBuffer are removed and new attachments
    /// are set describing the transferred image.  Unrecognised attachments on sourceBuffer will
    /// be propagated to destinationBuffer.
    /// Some properties will modify this behaviour; see VTPixelTransferProperties.h for more details.
    ///
    /// Parameter `session`: The pixel transfer session.
    ///
    /// Parameter `sourceBuffer`: The source buffer.
    ///
    /// Parameter `destinationBuffer`: The destination buffer.
    ///
    /// Returns: If the transfer was successful, noErr; otherwise an error code, such as kVTPixelTransferNotSupportedErr.
    #[doc(alias = "VTPixelTransferSessionTransferImage")]
    #[cfg(feature = "objc2-core-video")]
    #[inline]
    pub unsafe fn transfer_image(
        &self,
        source_buffer: &CVPixelBuffer,
        destination_buffer: &CVPixelBuffer,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTPixelTransferSessionTransferImage(
                session: &VTPixelTransferSession,
                source_buffer: &CVPixelBuffer,
                destination_buffer: &CVPixelBuffer,
            ) -> OSStatus;
        }
        unsafe { VTPixelTransferSessionTransferImage(self, source_buffer, destination_buffer) }
    }
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTPixelTransferSession::create`"]
    pub fn VTPixelTransferSessionCreate(
        allocator: Option<&CFAllocator>,
        pixel_transfer_session_out: NonNull<*mut VTPixelTransferSession>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTPixelTransferSession::invalidate`"]
    pub fn VTPixelTransferSessionInvalidate(session: &VTPixelTransferSession);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-video")]
    #[deprecated = "renamed to `VTPixelTransferSession::transfer_image`"]
    pub fn VTPixelTransferSessionTransferImage(
        session: &VTPixelTransferSession,
        source_buffer: &CVPixelBuffer,
        destination_buffer: &CVPixelBuffer,
    ) -> OSStatus;
}
