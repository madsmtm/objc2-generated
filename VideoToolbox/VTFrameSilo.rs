//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;

use crate::*;

/// An object that stores a large number of sample buffers, as produced by a multipass compression session.
/// A VTFrameSilo stores a large number of sample buffers, as produced by a multi-pass compression session.
///
/// The sample buffers are ordered by decode timestamp.
/// A VTFrameSilo starts out empty and is populated by calls to VTFrameSiloAddSampleBuffer to add sample buffers in ascending decode order.
/// After the first full pass, additional passes may be performed to replace sample buffers.
/// Each such pass must begin with a call to VTFrameSiloSetTimeRangesForNextPass, which takes a list of time ranges.
/// Samples in these time ranges are deleted, and calls to VTFrameSiloAddSampleBuffer can then be made to provide replacements.
/// Call VTFrameSiloCallFunctionForEachSampleBuffer or VTFrameSiloCallBlockForEachSampleBuffer to retrieve sample buffers.
/// The VTFrameSilo may write sample buffers and data to the backing file between addition and retrieval;
/// do not expect to get identical object pointers back.
#[doc(alias = "VTFrameSiloRef")]
#[repr(C)]
pub struct VTFrameSilo {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl VTFrameSilo {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueVTFrameSilo"> for VTFrameSilo {}
);

unsafe impl ConcreteType for VTFrameSilo {
    /// Retrieves the Core Foundation type identifier for the frame silo object.
    ///
    /// ## Return Value
    ///
    /// The `CFTypeID` of the frame silo object.
    ///
    ///
    #[doc(alias = "VTFrameSiloGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn VTFrameSiloGetTypeID() -> CFTypeID;
        }
        unsafe { VTFrameSiloGetTypeID() }
    }
}

impl VTFrameSilo {
    /// Creates a frame silo object using a temporary file.
    ///
    /// Parameters:
    /// - allocator: An allocator for the frame silo.  Pass `NULL` to use the default allocator.
    ///
    /// - fileURL: The URL of the backing file for the `VTFrameSilo` object. If you pass `NULL` for `fileURL`, VideoToolbox will pick a unique temporary file name.
    ///
    /// - timeRange: The valid time range for the frame silo. Must be valid for progress reporting.
    ///
    /// - options: Reserved, pass `NULL`.
    ///
    /// - frameSiloOut: Points to a [`VTFrameSiloRef`](https://developer.apple.com/documentation/videotoolbox/vtframesilo) to receive the newly created object. Call `CFRelease` to release your retain on the created VTFrameSilo object when you are done with it.
    ///
    ///
    /// ## Discussion
    ///
    /// You can use the returned frame silo object to gather frames produced by multipass encoding.
    ///
    /// Call [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) to release the frame silo object when you are done with it.
    ///
    ///
    /// Creates a VTFrameSilo object using a temporary file.
    ///
    /// The returned VTFrameSilo object may be used to gather frames produced by multi-pass encoding.
    ///
    /// Parameter `fileURL`: Specifies where to put the backing file for the VTFrameSilo object.
    /// If you pass NULL for fileURL, the video toolbox will pick a unique temporary file name.
    ///
    /// Parameter `options`: Reserved, pass NULL.
    ///
    /// Parameter `timeRange`: The valid time range for the frame silo. Must be valid for progress reporting.
    ///
    /// Parameter `frameSiloOut`: Points to a VTFrameSiloRef to receive the newly created object.
    /// Call CFRelease to release your retain on the created VTFrameSilo object when you are done with it.
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    /// - `frame_silo_out` must be a valid pointer.
    #[doc(alias = "VTFrameSiloCreate")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
        time_range: CMTimeRange,
        options: Option<&CFDictionary>,
        frame_silo_out: NonNull<*mut VTFrameSilo>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloCreate(
                allocator: Option<&CFAllocator>,
                file_url: Option<&CFURL>,
                time_range: CMTimeRange,
                options: Option<&CFDictionary>,
                frame_silo_out: NonNull<*mut VTFrameSilo>,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloCreate(allocator, file_url, time_range, options, frame_silo_out) }
    }

    /// Adds a sample buffer to a frame silo object.
    ///
    /// Parameters:
    /// - silo: The frame silo object.
    ///
    /// - sampleBuffer: The sample buffer to add to the frame silo.
    ///
    ///
    /// ## Return Value
    ///
    /// `kVTFrameSiloInvalidTimeRangeErr` if an attempt is made to add a sample buffer with an inappropriate decode timestamp.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Within each pass, sample buffers must have strictly increasing decode timestamps. Passes after the first pass begin with a call to [`VTFrameSiloSetTimeRangesForNextPass`](https://developer.apple.com/documentation/videotoolbox/vtframesilosettimerangesfornextpass(_:timerangecount:timerangearray:)).
    ///
    /// After a call to [`VTFrameSiloSetTimeRangesForNextPass`](https://developer.apple.com/documentation/videotoolbox/vtframesilosettimerangesfornextpass(_:timerangecount:timerangearray:)), sample buffer decode timestamps must also be within the stated time ranges. Note that time ranges are considered to contain their start times but not their end times.
    ///
    ///
    /// Adds a sample buffer to a VTFrameSilo object.
    ///
    /// Within each pass, sample buffers must have strictly increasing decode timestamps.
    /// Passes after the first pass are begun with a call to VTFrameSiloSetTimeRangesForNextPass.
    /// After a call to VTFrameSiloSetTimeRangesForNextPass, sample buffer decode timestamps must also be within
    /// the stated time ranges.
    /// Note that CMTimeRanges are considered to contain their start times but not their end times.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeStampErr if an attempt is made to add a sample buffer with an inappropriate decode timestamp.
    #[doc(alias = "VTFrameSiloAddSampleBuffer")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn add_sample_buffer(&self, sample_buffer: &CMSampleBuffer) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloAddSampleBuffer(
                silo: &VTFrameSilo,
                sample_buffer: &CMSampleBuffer,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloAddSampleBuffer(self, sample_buffer) }
    }

    /// Begins a new pass of samples to be added to a frame silo object.
    ///
    /// Parameters:
    /// - silo: The frame silo object.
    ///
    /// - timeRangeCount: The count of time ranges in `timeRangeArray`.
    ///
    /// - timeRangeArray: The array of `CMTimeRange` structs.
    ///
    ///
    /// ## Return Value
    ///
    /// `kVTFrameSiloInvalidTimeRangeErr` if any time ranges are non-numeric, overlap, or are not in ascending order.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Previously added sample buffers with decode timestamps within the time ranges are deleted from the frame silo object.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Itâ€™s not necessary to call this function before adding sample buffers for the first pass.
    ///
    ///
    ///
    /// </div>
    ///
    /// Begins a new pass of samples to be added to a VTFrameSilo object.
    ///
    /// Previously-added sample buffers with decode timestamps within the time ranges will be deleted from the VTFrameSilo.
    /// It is not necessary to call VTFrameSiloSetTimeRangesForNextPass before adding the first pass' sample buffers.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeRangeErr if any time ranges are non-numeric, overlap or are not in ascending order.
    ///
    /// # Safety
    ///
    /// `time_range_array` must be a valid pointer.
    #[doc(alias = "VTFrameSiloSetTimeRangesForNextPass")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn set_time_ranges_for_next_pass(
        &self,
        time_range_count: CMItemCount,
        time_range_array: NonNull<CMTimeRange>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloSetTimeRangesForNextPass(
                silo: &VTFrameSilo,
                time_range_count: CMItemCount,
                time_range_array: NonNull<CMTimeRange>,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloSetTimeRangesForNextPass(self, time_range_count, time_range_array) }
    }

    /// Gets the progress of the current pass.
    ///
    /// Parameters:
    /// - silo: The frame silo object.
    ///
    /// - progressOut: Upon return, contains the progress of the current pass.
    ///
    ///
    /// ## Return Value
    ///
    /// `kVTFrameSiloInvalidTimeRangeErr` if any time ranges are non-numeric, overlap or are not in ascending order.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Calculates the current progress based on the most recent sample buffer added and the current pass time ranges.
    ///
    ///
    /// Gets the progress of the current pass.
    ///
    /// Calculates the current progress based on the most recent sample buffer added and the current pass time ranges.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeRangeErr if any time ranges are non-numeric, overlap or are not in ascending order.
    ///
    /// # Safety
    ///
    /// `progress_out` must be a valid pointer.
    #[doc(alias = "VTFrameSiloGetProgressOfCurrentPass")]
    #[inline]
    pub unsafe fn progress_of_current_pass(&self, progress_out: NonNull<f32>) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloGetProgressOfCurrentPass(
                silo: &VTFrameSilo,
                progress_out: NonNull<f32>,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloGetProgressOfCurrentPass(self, progress_out) }
    }

    /// Retrieves sample buffers from a frame silo object.
    ///
    /// Parameters:
    /// - silo: The frame silo object.
    ///
    /// - timeRange: The decode time range of the sample buffers to retrieve. Pass `kCMTimeRangeInvalid` to retrieve all sample buffers from the `VTFrameSilo.`
    ///
    /// - refcon: A reference value.
    ///
    /// - callback: A function to be called, in decode order, with each sample buffer that was added. To abort iteration early, return a nonzero status. The `VTFrameSilo` object may write sample buffers and data to the backing file between addition and retrieval;  do not expect to get identical object pointers back.
    ///
    ///
    /// ## Return Value
    ///
    /// `kVTFrameSiloInvalidTimeRangeErr` if any time ranges are non-numeric, overlap, or are not in ascending order. Returns any nonzero status returned by the callback function.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You call this function to retrieve sample buffers at the end of a multipass compression session.
    ///
    ///
    /// Retrieves sample buffers from a VTFrameSilo object.
    ///
    /// You call this function to retrieve sample buffers at the end of a multi-pass compression session.
    ///
    /// Parameter `timeRange`: The decode time range of sample buffers to retrieve.
    /// Pass kCMTimeRangeInvalid to retrieve all sample buffers from the VTFrameSilo.
    ///
    /// Parameter `callback`: A function to be called, in decode order, with each sample buffer that was added.
    /// To abort iteration early, return a nonzero status.
    /// The VTFrameSilo may write sample buffers and data to the backing file between addition and retrieval;
    /// do not expect to get identical object pointers back.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeRangeErr if any time ranges are non-numeric, overlap or are not in ascending order.
    /// Returns any nonzero status returned by the callback function.
    ///
    /// # Safety
    ///
    /// - `refcon` must be a valid pointer or null.
    /// - `callback` must be implemented correctly.
    #[doc(alias = "VTFrameSiloCallFunctionForEachSampleBuffer")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn call_function_for_each_sample_buffer(
        &self,
        time_range: CMTimeRange,
        refcon: *mut c_void,
        callback: unsafe extern "C-unwind" fn(*mut c_void, NonNull<CMSampleBuffer>) -> OSStatus,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloCallFunctionForEachSampleBuffer(
                silo: &VTFrameSilo,
                time_range: CMTimeRange,
                refcon: *mut c_void,
                callback: unsafe extern "C-unwind" fn(
                    *mut c_void,
                    NonNull<CMSampleBuffer>,
                ) -> OSStatus,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloCallFunctionForEachSampleBuffer(self, time_range, refcon, callback) }
    }

    /// Retrieves sample buffers from a frame silo object.
    ///
    /// Parameters:
    /// - silo: The frame silo object.
    ///
    /// - timeRange: The decode time range of sample buffers to retrieve. Pass `kCMTimeRangeInvalid` to retrieve all sample buffers from the `VTFrameSilo`.
    ///
    /// - handler: A block to be called, in decode order, with each sample buffer that was added. To abort iteration early, return a nonzero status. The `VTFrameSilo` object may write sample buffers and data to the backing file between addition and retrieval;  do not expect to get identical object pointers back.
    ///
    ///
    /// ## Return Value
    ///
    /// `kVTFrameSiloInvalidTimeRangeErr` if any time ranges are non-numeric, overlap, or are not in ascending order. Returns any nonzero status returned by the handler block.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You call this function to retrieve sample buffers at the end of a multipass compression session.
    ///
    ///
    /// Retrieves sample buffers from a VTFrameSilo object.
    ///
    /// You call this function to retrieve sample buffers at the end of a multi-pass compression session.
    ///
    /// Parameter `timeRange`: The decode time range of sample buffers to retrieve.
    /// Pass kCMTimeRangeInvalid to retrieve all sample buffers from the VTFrameSilo.
    ///
    /// Parameter `handler`: A block to be called, in decode order, with each sample buffer that was added.
    /// To abort iteration early, return a nonzero status.
    /// The VTFrameSilo may write sample buffers and data to the backing file between addition and retrieval;
    /// do not expect to get identical object pointers back.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeRangeErr if any time ranges are non-numeric, overlap or are not in ascending order.
    /// Returns any nonzero status returned by the handler block.
    #[doc(alias = "VTFrameSiloCallBlockForEachSampleBuffer")]
    #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
    #[inline]
    pub unsafe fn call_block_for_each_sample_buffer(
        &self,
        time_range: CMTimeRange,
        handler: &block2::DynBlock<dyn Fn(NonNull<CMSampleBuffer>) -> OSStatus>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloCallBlockForEachSampleBuffer(
                silo: &VTFrameSilo,
                time_range: CMTimeRange,
                handler: &block2::DynBlock<dyn Fn(NonNull<CMSampleBuffer>) -> OSStatus>,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloCallBlockForEachSampleBuffer(self, time_range, handler) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTFrameSilo::create`"]
    pub fn VTFrameSiloCreate(
        allocator: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
        time_range: CMTimeRange,
        options: Option<&CFDictionary>,
        frame_silo_out: NonNull<*mut VTFrameSilo>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTFrameSilo::add_sample_buffer`"]
    pub fn VTFrameSiloAddSampleBuffer(
        silo: &VTFrameSilo,
        sample_buffer: &CMSampleBuffer,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTFrameSilo::set_time_ranges_for_next_pass`"]
    pub fn VTFrameSiloSetTimeRangesForNextPass(
        silo: &VTFrameSilo,
        time_range_count: CMItemCount,
        time_range_array: NonNull<CMTimeRange>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTFrameSilo::progress_of_current_pass`"]
    pub fn VTFrameSiloGetProgressOfCurrentPass(
        silo: &VTFrameSilo,
        progress_out: NonNull<f32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTFrameSilo::call_function_for_each_sample_buffer`"]
    pub fn VTFrameSiloCallFunctionForEachSampleBuffer(
        silo: &VTFrameSilo,
        time_range: CMTimeRange,
        refcon: *mut c_void,
        callback: unsafe extern "C-unwind" fn(*mut c_void, NonNull<CMSampleBuffer>) -> OSStatus,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
    #[deprecated = "renamed to `VTFrameSilo::call_block_for_each_sample_buffer`"]
    pub fn VTFrameSiloCallBlockForEachSampleBuffer(
        silo: &VTFrameSilo,
        time_range: CMTimeRange,
        handler: &block2::DynBlock<dyn Fn(NonNull<CMSampleBuffer>) -> OSStatus>,
    ) -> OSStatus;
}
