//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;

use crate::*;

/// A VTFrameSilo stores a large number of sample buffers, as produced by a multi-pass compression session.
///
/// The sample buffers are ordered by decode timestamp.
/// A VTFrameSilo starts out empty and is populated by calls to VTFrameSiloAddSampleBuffer to add sample buffers in ascending decode order.
/// After the first full pass, additional passes may be performed to replace sample buffers.
/// Each such pass must begin with a call to VTFrameSiloSetTimeRangesForNextPass, which takes a list of time ranges.
/// Samples in these time ranges are deleted, and calls to VTFrameSiloAddSampleBuffer can then be made to provide replacements.
/// Call VTFrameSiloCallFunctionForEachSampleBuffer or VTFrameSiloCallBlockForEachSampleBuffer to retrieve sample buffers.
/// The VTFrameSilo may write sample buffers and data to the backing file between addition and retrieval;
/// do not expect to get identical object pointers back.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/videotoolbox/vtframesilo?language=objc)
#[repr(C)]
pub struct VTFrameSilo {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl VTFrameSilo {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueVTFrameSilo"> for VTFrameSilo {}
);

unsafe impl ConcreteType for VTFrameSilo {
    #[doc(alias = "VTFrameSiloGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn VTFrameSiloGetTypeID() -> CFTypeID;
        }
        unsafe { VTFrameSiloGetTypeID() }
    }
}

impl VTFrameSilo {
    /// Creates a VTFrameSilo object using a temporary file.
    ///
    /// The returned VTFrameSilo object may be used to gather frames produced by multi-pass encoding.
    ///
    /// Parameter `fileURL`: Specifies where to put the backing file for the VTFrameSilo object.
    /// If you pass NULL for fileURL, the video toolbox will pick a unique temporary file name.
    ///
    /// Parameter `options`: Reserved, pass NULL.
    ///
    /// Parameter `timeRange`: The valid time range for the frame silo. Must be valid for progress reporting.
    ///
    /// Parameter `frameSiloOut`: Points to a VTFrameSiloRef to receive the newly created object.
    /// Call CFRelease to release your retain on the created VTFrameSilo object when you are done with it.
    ///
    /// # Safety
    ///
    /// - `options` generics must be of the correct type.
    /// - `frame_silo_out` must be a valid pointer.
    #[doc(alias = "VTFrameSiloCreate")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
        time_range: CMTimeRange,
        options: Option<&CFDictionary>,
        frame_silo_out: NonNull<*mut VTFrameSilo>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloCreate(
                allocator: Option<&CFAllocator>,
                file_url: Option<&CFURL>,
                time_range: CMTimeRange,
                options: Option<&CFDictionary>,
                frame_silo_out: NonNull<*mut VTFrameSilo>,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloCreate(allocator, file_url, time_range, options, frame_silo_out) }
    }

    /// Adds a sample buffer to a VTFrameSilo object.
    ///
    /// Within each pass, sample buffers must have strictly increasing decode timestamps.
    /// Passes after the first pass are begun with a call to VTFrameSiloSetTimeRangesForNextPass.
    /// After a call to VTFrameSiloSetTimeRangesForNextPass, sample buffer decode timestamps must also be within
    /// the stated time ranges.
    /// Note that CMTimeRanges are considered to contain their start times but not their end times.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeStampErr if an attempt is made to add a sample buffer with an inappropriate decode timestamp.
    #[doc(alias = "VTFrameSiloAddSampleBuffer")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn add_sample_buffer(&self, sample_buffer: &CMSampleBuffer) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloAddSampleBuffer(
                silo: &VTFrameSilo,
                sample_buffer: &CMSampleBuffer,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloAddSampleBuffer(self, sample_buffer) }
    }

    /// Begins a new pass of samples to be added to a VTFrameSilo object.
    ///
    /// Previously-added sample buffers with decode timestamps within the time ranges will be deleted from the VTFrameSilo.
    /// It is not necessary to call VTFrameSiloSetTimeRangesForNextPass before adding the first pass' sample buffers.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeRangeErr if any time ranges are non-numeric, overlap or are not in ascending order.
    ///
    /// # Safety
    ///
    /// `time_range_array` must be a valid pointer.
    #[doc(alias = "VTFrameSiloSetTimeRangesForNextPass")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn set_time_ranges_for_next_pass(
        &self,
        time_range_count: CMItemCount,
        time_range_array: NonNull<CMTimeRange>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloSetTimeRangesForNextPass(
                silo: &VTFrameSilo,
                time_range_count: CMItemCount,
                time_range_array: NonNull<CMTimeRange>,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloSetTimeRangesForNextPass(self, time_range_count, time_range_array) }
    }

    /// Gets the progress of the current pass.
    ///
    /// Calculates the current progress based on the most recent sample buffer added and the current pass time ranges.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeRangeErr if any time ranges are non-numeric, overlap or are not in ascending order.
    ///
    /// # Safety
    ///
    /// `progress_out` must be a valid pointer.
    #[doc(alias = "VTFrameSiloGetProgressOfCurrentPass")]
    #[inline]
    pub unsafe fn progress_of_current_pass(&self, progress_out: NonNull<f32>) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloGetProgressOfCurrentPass(
                silo: &VTFrameSilo,
                progress_out: NonNull<f32>,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloGetProgressOfCurrentPass(self, progress_out) }
    }

    /// Retrieves sample buffers from a VTFrameSilo object.
    ///
    /// You call this function to retrieve sample buffers at the end of a multi-pass compression session.
    ///
    /// Parameter `timeRange`: The decode time range of sample buffers to retrieve.
    /// Pass kCMTimeRangeInvalid to retrieve all sample buffers from the VTFrameSilo.
    ///
    /// Parameter `callback`: A function to be called, in decode order, with each sample buffer that was added.
    /// To abort iteration early, return a nonzero status.
    /// The VTFrameSilo may write sample buffers and data to the backing file between addition and retrieval;
    /// do not expect to get identical object pointers back.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeRangeErr if any time ranges are non-numeric, overlap or are not in ascending order.
    /// Returns any nonzero status returned by the callback function.
    ///
    /// # Safety
    ///
    /// - `refcon` must be a valid pointer or null.
    /// - `callback` must be implemented correctly.
    #[doc(alias = "VTFrameSiloCallFunctionForEachSampleBuffer")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn call_function_for_each_sample_buffer(
        &self,
        time_range: CMTimeRange,
        refcon: *mut c_void,
        callback: unsafe extern "C-unwind" fn(*mut c_void, NonNull<CMSampleBuffer>) -> OSStatus,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloCallFunctionForEachSampleBuffer(
                silo: &VTFrameSilo,
                time_range: CMTimeRange,
                refcon: *mut c_void,
                callback: unsafe extern "C-unwind" fn(
                    *mut c_void,
                    NonNull<CMSampleBuffer>,
                ) -> OSStatus,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloCallFunctionForEachSampleBuffer(self, time_range, refcon, callback) }
    }

    /// Retrieves sample buffers from a VTFrameSilo object.
    ///
    /// You call this function to retrieve sample buffers at the end of a multi-pass compression session.
    ///
    /// Parameter `timeRange`: The decode time range of sample buffers to retrieve.
    /// Pass kCMTimeRangeInvalid to retrieve all sample buffers from the VTFrameSilo.
    ///
    /// Parameter `handler`: A block to be called, in decode order, with each sample buffer that was added.
    /// To abort iteration early, return a nonzero status.
    /// The VTFrameSilo may write sample buffers and data to the backing file between addition and retrieval;
    /// do not expect to get identical object pointers back.
    ///
    /// Returns: Returns kVTFrameSiloInvalidTimeRangeErr if any time ranges are non-numeric, overlap or are not in ascending order.
    /// Returns any nonzero status returned by the handler block.
    #[doc(alias = "VTFrameSiloCallBlockForEachSampleBuffer")]
    #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
    #[inline]
    pub unsafe fn call_block_for_each_sample_buffer(
        &self,
        time_range: CMTimeRange,
        handler: &block2::DynBlock<dyn Fn(NonNull<CMSampleBuffer>) -> OSStatus>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTFrameSiloCallBlockForEachSampleBuffer(
                silo: &VTFrameSilo,
                time_range: CMTimeRange,
                handler: &block2::DynBlock<dyn Fn(NonNull<CMSampleBuffer>) -> OSStatus>,
            ) -> OSStatus;
        }
        unsafe { VTFrameSiloCallBlockForEachSampleBuffer(self, time_range, handler) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTFrameSilo::create`"]
    pub fn VTFrameSiloCreate(
        allocator: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
        time_range: CMTimeRange,
        options: Option<&CFDictionary>,
        frame_silo_out: NonNull<*mut VTFrameSilo>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTFrameSilo::add_sample_buffer`"]
    pub fn VTFrameSiloAddSampleBuffer(
        silo: &VTFrameSilo,
        sample_buffer: &CMSampleBuffer,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTFrameSilo::set_time_ranges_for_next_pass`"]
    pub fn VTFrameSiloSetTimeRangesForNextPass(
        silo: &VTFrameSilo,
        time_range_count: CMItemCount,
        time_range_array: NonNull<CMTimeRange>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTFrameSilo::progress_of_current_pass`"]
    pub fn VTFrameSiloGetProgressOfCurrentPass(
        silo: &VTFrameSilo,
        progress_out: NonNull<f32>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTFrameSilo::call_function_for_each_sample_buffer`"]
    pub fn VTFrameSiloCallFunctionForEachSampleBuffer(
        silo: &VTFrameSilo,
        time_range: CMTimeRange,
        refcon: *mut c_void,
        callback: unsafe extern "C-unwind" fn(*mut c_void, NonNull<CMSampleBuffer>) -> OSStatus,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
    #[deprecated = "renamed to `VTFrameSilo::call_block_for_each_sample_buffer`"]
    pub fn VTFrameSiloCallBlockForEachSampleBuffer(
        silo: &VTFrameSilo,
        time_range: CMTimeRange,
        handler: &block2::DynBlock<dyn Fn(NonNull<CMSampleBuffer>) -> OSStatus>,
    ) -> OSStatus;
}
