//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

pub const kVTPropertyNotSupportedErr: OSStatus = -12900;
pub const kVTPropertyReadOnlyErr: OSStatus = -12901;
pub const kVTParameterErr: OSStatus = -12902;
pub const kVTInvalidSessionErr: OSStatus = -12903;
pub const kVTAllocationFailedErr: OSStatus = -12904;
pub const kVTPixelTransferNotSupportedErr: OSStatus = -12905;
pub const kVTCouldNotFindVideoDecoderErr: OSStatus = -12906;
pub const kVTCouldNotCreateInstanceErr: OSStatus = -12907;
pub const kVTCouldNotFindVideoEncoderErr: OSStatus = -12908;
pub const kVTVideoDecoderBadDataErr: OSStatus = -12909;
pub const kVTVideoDecoderUnsupportedDataFormatErr: OSStatus = -12910;
pub const kVTVideoDecoderMalfunctionErr: OSStatus = -12911;
pub const kVTVideoEncoderMalfunctionErr: OSStatus = -12912;
pub const kVTVideoDecoderNotAvailableNowErr: OSStatus = -12913;
pub const kVTImageRotationNotSupportedErr: OSStatus = -12914;
pub const kVTPixelRotationNotSupportedErr: OSStatus = -12914;
pub const kVTVideoEncoderNotAvailableNowErr: OSStatus = -12915;
pub const kVTFormatDescriptionChangeNotSupportedErr: OSStatus = -12916;
pub const kVTInsufficientSourceColorDataErr: OSStatus = -12917;
pub const kVTCouldNotCreateColorCorrectionDataErr: OSStatus = -12918;
pub const kVTColorSyncTransformConvertFailedErr: OSStatus = -12919;
pub const kVTVideoDecoderAuthorizationErr: OSStatus = -12210;
pub const kVTVideoEncoderAuthorizationErr: OSStatus = -12211;
pub const kVTColorCorrectionPixelTransferFailedErr: OSStatus = -12212;
pub const kVTMultiPassStorageIdentifierMismatchErr: OSStatus = -12213;
pub const kVTMultiPassStorageInvalidErr: OSStatus = -12214;
pub const kVTFrameSiloInvalidTimeStampErr: OSStatus = -12215;
pub const kVTFrameSiloInvalidTimeRangeErr: OSStatus = -12216;
pub const kVTCouldNotFindTemporalFilterErr: OSStatus = -12217;
pub const kVTPixelTransferNotPermittedErr: OSStatus = -12218;
pub const kVTColorCorrectionImageRotationFailedErr: OSStatus = -12219;
pub const kVTVideoDecoderRemovedErr: OSStatus = -17690;
pub const kVTSessionMalfunctionErr: OSStatus = -17691;
pub const kVTVideoDecoderNeedsRosettaErr: OSStatus = -17692;
pub const kVTVideoEncoderNeedsRosettaErr: OSStatus = -17693;
pub const kVTVideoDecoderReferenceMissingErr: OSStatus = -17694;
pub const kVTVideoDecoderCallbackMessagingErr: OSStatus = -17695;
pub const kVTVideoDecoderUnknownErr: OSStatus = -17696;
pub const kVTExtensionDisabledErr: OSStatus = -17697;
pub const kVTVideoEncoderMVHEVCVideoLayerIDsMismatchErr: OSStatus = -17698;
pub const kVTCouldNotOutputTaggedBufferGroupErr: OSStatus = -17699;
pub const kVTCouldNotFindExtensionErr: OSStatus = -19510;
pub const kVTExtensionConflictErr: OSStatus = -19511;
pub const kVTVideoEncoderAutoWhiteBalanceNotLockedErr: OSStatus = -19512;

/// Flags to pass to a decompression session and the video decoder.
/// Directives for the decompression session and the video decoder, passed into
/// decodeFlags parameter of VTDecompressionSessionDecodeFrame.
///
///
/// With the kVTDecodeFrame_EnableAsynchronousDecompression bit clear, the video decoder
/// is compelled to emit every frame before it returns.  With the bit set, the decoder may
/// process frames asynchronously, but it is not compelled to do so.
///
/// A hint to the decompression session and video decoder that a CVImageBuffer should not
/// be emitted for this frame.  NULL will be returned instead.
///
/// A hint to the video decoder that it would be OK to use a low-power mode that can not decode faster than 1x realtime.
///
/// With the kVTDecodeFrame_EnableTemporalProcessing bit clear, the video decoder should emit
/// every frame once that frame's decoding is done -- frames may not be delayed indefinitely.  With
/// the bit set, it is legal for the decoder to delay frames indefinitely -- at least
/// until VTDecompressionSessionFinishDelayedFrames or VTDecompressionSessionInvalidate is called.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct VTDecodeFrameFlags(pub u32);
bitflags::bitflags! {
    impl VTDecodeFrameFlags: u32 {
/// A flag that indicates to enable asynchronous decompression.
///
/// ## Discussion
///
/// With this bit cleared, the video decoder emits every frame before it returns. With the bit set, the decoder may process frames asynchronously, but it’s not compelled to do so.
///
///
#[doc(alias = "kVTDecodeFrame_EnableAsynchronousDecompression")]
        const Frame_EnableAsynchronousDecompression = 1<<0;
/// A flag that provides a hint to the decompression session and video decoder not to return a frame.
///
/// ## Discussion
///
/// This flag indicates to return NULL for this frame instead of a [`CVImageBuffer`](https://developer.apple.com/documentation/corevideo/cvimagebuffer).
///
///
#[doc(alias = "kVTDecodeFrame_DoNotOutputFrame")]
        const Frame_DoNotOutputFrame = 1<<1;
/// A flag that provides a hint to the video decoder that it’s ok to use a low-power mode that can’t decode faster than realtime.
#[doc(alias = "kVTDecodeFrame_1xRealTimePlayback")]
        const Frame_1xRealTimePlayback = 1<<2;
/// A flag that indicates to enable temporal processing.
///
/// ## Discussion
///
/// With this bit cleared, the video decoder should emit every frame once that frame’s decoding is done–frames may not be delayed indefinitely.  With the bit set, it is legal for the decoder to delay frames indefinitely–at least until [`VTDecompressionSessionFinishDelayedFrames(_:)`](https://developer.apple.com/documentation/videotoolbox/vtdecompressionsessionfinishdelayedframes(_:)) or [`VTDecompressionSessionInvalidate(_:)`](https://developer.apple.com/documentation/videotoolbox/vtdecompressionsessioninvalidate(_:)) is called.
///
///
#[doc(alias = "kVTDecodeFrame_EnableTemporalProcessing")]
        const Frame_EnableTemporalProcessing = 1<<3;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for VTDecodeFrameFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for VTDecodeFrameFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags that provide information about the status of a decode operation.
/// Informational status for decoding -- non-error flags
///
///
/// The kVTDecodeInfo_Asynchronous bit may be set if the decode ran asynchronously.
///
/// The kVTDecodeInfo_FrameDropped bit may be set if the frame was dropped.
///
/// If the kVTDecodeInfo_ImageBufferModifiable bit is set, it is safe for the client to modify the imageBuffer.
///
/// The kVTDecodeInfo_SkippedLeadingFrameDropped may be set if a leading frame after a sync frame is dropped.
/// This can happen when a seek to a sync frame is initiated and, due to frame reordering, there are leading
/// frames following the sync frame that cannot be decoded due to missing references.  Dropping these frames
/// has no impact to playback since the non-decodeable frames will not be rendered.
/// If kVTDecodeInfo_SkippedLeadingFrameDropped is set, kVTDecodeInfo_FrameDropped will also be set.
///
/// The kVTDecodeInfo_FrameInterrupted bit may be set if the frame was decoded successfully but the decoded
/// content was not provided in the output callback. When this bit is set, the imageBuffer provided to the output
/// handler may either be NULL or contain only black pixels.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct VTDecodeInfoFlags(pub u32);
bitflags::bitflags! {
    impl VTDecodeInfoFlags: u32 {
/// A flag that indicates the decode operation ran asynchronously.
        #[doc(alias = "kVTDecodeInfo_Asynchronous")]
        const Asynchronous = 1<<0;
/// A flag that indicates the decode operation dropped a frame.
        #[doc(alias = "kVTDecodeInfo_FrameDropped")]
        const FrameDropped = 1<<1;
/// A flag that indicates the image buffer is safe to modify.
        #[doc(alias = "kVTDecodeInfo_ImageBufferModifiable")]
        const ImageBufferModifiable = 1<<2;
/// A flag that indicates whether the decode process skips leading frames after dropping a synchronization frame.
///
/// ## Discussion
///
/// This condition occurs when you performs a seek to a sync frame, and due to frame reordering, there are leading frames following the sync frame that the system can’t decode due to missing references. Dropping these frames has no impact on playback because the nondecodeable frames won’t render.
///
/// If the system sets this flag, it sets the [`kVTDecodeInfo_FrameDropped`](https://developer.apple.com/documentation/videotoolbox/vtdecodeinfoflags/framedropped) flag as well.
///
///
        #[doc(alias = "kVTDecodeInfo_SkippedLeadingFrameDropped")]
        const SkippedLeadingFrameDropped = 1<<3;
        #[doc(alias = "kVTDecodeInfo_FrameInterrupted")]
        const FrameInterrupted = 1<<4;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for VTDecodeInfoFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for VTDecodeInfoFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags that indicate encoder state.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct VTEncodeInfoFlags(pub u32);
bitflags::bitflags! {
    impl VTEncodeInfoFlags: u32 {
/// A flag that indicates that an encode operation ran asynchronously.
        #[doc(alias = "kVTEncodeInfo_Asynchronous")]
        const Asynchronous = 1<<0;
/// A flag that indicates that a frame dropped during encoding.
        #[doc(alias = "kVTEncodeInfo_FrameDropped")]
        const FrameDropped = 1<<1;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for VTEncodeInfoFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for VTEncodeInfoFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}
