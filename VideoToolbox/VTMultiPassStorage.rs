//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;

use crate::*;

/// An object for storing information for each frame of a multipass compression session.
///
/// ## Overview
///
/// The multipass storage object is a reference-counted CoreFoundation (CF) type. The data stored in the multipass storage object is private to the video encoder.
///
///
/// A mechanism for storing information for each frame of a multi-pass compression session.
///
/// VTMultiPassStorageRef is a CF type, so call CFRelease and CFRetain to manage objects of this type.
/// The data stored in the VTMultiPassStorage is private to the video encoder.
#[doc(alias = "VTMultiPassStorageRef")]
#[repr(C)]
pub struct VTMultiPassStorage {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl VTMultiPassStorage {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueVTMultiPassStorage"> for VTMultiPassStorage {}
);

unsafe impl ConcreteType for VTMultiPassStorage {
    /// Retrieves the Core Foundation type identifier for the multipass storage object.
    ///
    /// ## Return Value
    ///
    /// The `CFTypeID` of the multipass storage object.
    ///
    ///
    #[doc(alias = "VTMultiPassStorageGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn VTMultiPassStorageGetTypeID() -> CFTypeID;
        }
        unsafe { VTMultiPassStorageGetTypeID() }
    }
}

impl VTMultiPassStorage {
    /// Creates a multipass storage object using a temporary file.
    ///
    /// Parameters:
    /// - allocator: An allocator for the session.  Pass `NULL` to use the default allocator.
    ///
    /// - fileURL: Specifies where to put the backing file for the multipass storage object. If you pass `NULL` for `fileURL`, the video toolbox will pick a unique temporary file name.
    ///
    /// - timeRange: Gives a hint to the multipass storage about valid time stamps for data. You can pass `kCMTimeRangeInvalid` if you do not want to provide a time range hint.
    ///
    /// - options: If the file did not exist when the storage was created, the file will be deleted when the multipass storage object is finalized, unless you set the [`kVTMultiPassStorageCreationOption_DoNotDelete`](https://developer.apple.com/documentation/videotoolbox/kvtmultipassstoragecreationoption_donotdelete) option to [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) in the `options` dictionary.
    ///
    /// - multiPassStorageOut: A pointer to the newly created multipass storage object.
    ///
    ///
    /// ## Discussion
    ///
    /// You can use the multipass storage object to perform multipass encoding; see [`kVTCompressionPropertyKey_MultiPassStorage`](https://developer.apple.com/documentation/videotoolbox/kvtcompressionpropertykey_multipassstorage).
    ///
    /// Call [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease) to release the multipass storage object when you are done with it.
    ///
    ///
    /// Creates a VTMultiPassStorage object using a temporary file.
    ///
    /// The returned VTMultiPassStorage object may be used to perform multi-pass encoding; see kVTCompressionPropertyKey_MultiPassStorage.
    /// Call CFRelease to release your retain on the created VTMultiPassStorage object when you are done with it.
    ///
    /// Parameter `fileURL`: Specifies where to put the backing file for the VTMultiPassStorage object.
    /// If you pass NULL for fileURL, the video toolbox will pick a unique temporary file name.
    ///
    /// Parameter `timeRange`: Gives a hint to the multi pass storage about valid time stamps for data.
    ///
    /// Parameter `options`: If the file did not exist when the storage was created, the file will be deleted when the VTMultiPassStorage object is finalized, unless you set the kVTMultiPassStorageCreationOption_DoNotDelete option to kCFBooleanTrue in the options dictionary.
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    /// - `multi_pass_storage_out` must be a valid pointer.
    #[doc(alias = "VTMultiPassStorageCreate")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
        time_range: CMTimeRange,
        options: Option<&CFDictionary>,
        multi_pass_storage_out: NonNull<*mut VTMultiPassStorage>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTMultiPassStorageCreate(
                allocator: Option<&CFAllocator>,
                file_url: Option<&CFURL>,
                time_range: CMTimeRange,
                options: Option<&CFDictionary>,
                multi_pass_storage_out: NonNull<*mut VTMultiPassStorage>,
            ) -> OSStatus;
        }
        unsafe {
            VTMultiPassStorageCreate(
                allocator,
                file_url,
                time_range,
                options,
                multi_pass_storage_out,
            )
        }
    }
}

extern "C" {
    /// Indicates that the multipass storage object’s backing store should not be deleted when finalized.
    ///
    /// ## Discussion
    ///
    /// If the backing store file did not exist when the storage was created, the file will be deleted when the multipass storage object is finalized, unless you set this option to [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) in the options dictionary.
    ///
    ///
    pub static kVTMultiPassStorageCreationOption_DoNotDelete: &'static CFString;
}

impl VTMultiPassStorage {
    /// Ensures that any pending data is written to the multipass storage file and closes the file.
    ///
    /// Parameters:
    /// - multiPassStorage: The multipass storage object to close.
    ///
    ///
    /// ## Discussion
    ///
    /// After this function is called, all functions on the multipass storage object fail. It’s still necessary to release the object by calling [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease).
    ///
    ///
    /// Ensures that any pending data is written to the multipass storage file and closes the file.
    ///
    /// After this function is called, all methods on the multipass storage object will fail.
    /// It is still necessary to release the object by calling CFRelease.
    #[doc(alias = "VTMultiPassStorageClose")]
    #[inline]
    pub unsafe fn close(&self) -> OSStatus {
        extern "C-unwind" {
            fn VTMultiPassStorageClose(multi_pass_storage: &VTMultiPassStorage) -> OSStatus;
        }
        unsafe { VTMultiPassStorageClose(self) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTMultiPassStorage::create`"]
    pub fn VTMultiPassStorageCreate(
        allocator: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
        time_range: CMTimeRange,
        options: Option<&CFDictionary>,
        multi_pass_storage_out: NonNull<*mut VTMultiPassStorage>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTMultiPassStorage::close`"]
    pub fn VTMultiPassStorageClose(multi_pass_storage: &VTMultiPassStorage) -> OSStatus;
}
