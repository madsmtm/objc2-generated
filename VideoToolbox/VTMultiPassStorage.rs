//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;

use crate::*;

/// A mechanism for storing information for each frame of a multi-pass compression session.
///
/// VTMultiPassStorageRef is a CF type, so call CFRelease and CFRetain to manage objects of this type.
/// The data stored in the VTMultiPassStorage is private to the video encoder.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/videotoolbox/vtmultipassstorage?language=objc)
#[doc(alias = "VTMultiPassStorageRef")]
#[repr(C)]
pub struct VTMultiPassStorage {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl VTMultiPassStorage {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueVTMultiPassStorage"> for VTMultiPassStorage {}
);

unsafe impl ConcreteType for VTMultiPassStorage {
    #[doc(alias = "VTMultiPassStorageGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn VTMultiPassStorageGetTypeID() -> CFTypeID;
        }
        unsafe { VTMultiPassStorageGetTypeID() }
    }
}

impl VTMultiPassStorage {
    /// Creates a VTMultiPassStorage object using a temporary file.
    ///
    /// The returned VTMultiPassStorage object may be used to perform multi-pass encoding; see kVTCompressionPropertyKey_MultiPassStorage.
    /// Call CFRelease to release your retain on the created VTMultiPassStorage object when you are done with it.
    ///
    /// Parameter `fileURL`: Specifies where to put the backing file for the VTMultiPassStorage object.
    /// If you pass NULL for fileURL, the video toolbox will pick a unique temporary file name.
    ///
    /// Parameter `timeRange`: Gives a hint to the multi pass storage about valid time stamps for data.
    ///
    /// Parameter `options`: If the file did not exist when the storage was created, the file will be deleted when the VTMultiPassStorage object is finalized, unless you set the kVTMultiPassStorageCreationOption_DoNotDelete option to kCFBooleanTrue in the options dictionary.
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    /// - `multi_pass_storage_out` must be a valid pointer.
    #[doc(alias = "VTMultiPassStorageCreate")]
    #[cfg(feature = "objc2-core-media")]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
        time_range: CMTimeRange,
        options: Option<&CFDictionary>,
        multi_pass_storage_out: NonNull<*mut VTMultiPassStorage>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn VTMultiPassStorageCreate(
                allocator: Option<&CFAllocator>,
                file_url: Option<&CFURL>,
                time_range: CMTimeRange,
                options: Option<&CFDictionary>,
                multi_pass_storage_out: NonNull<*mut VTMultiPassStorage>,
            ) -> OSStatus;
        }
        unsafe {
            VTMultiPassStorageCreate(
                allocator,
                file_url,
                time_range,
                options,
                multi_pass_storage_out,
            )
        }
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/videotoolbox/kvtmultipassstoragecreationoption_donotdelete?language=objc)
    pub static kVTMultiPassStorageCreationOption_DoNotDelete: &'static CFString;
}

impl VTMultiPassStorage {
    /// Ensures that any pending data is written to the multipass storage file and closes the file.
    ///
    /// After this function is called, all methods on the multipass storage object will fail.
    /// It is still necessary to release the object by calling CFRelease.
    #[doc(alias = "VTMultiPassStorageClose")]
    #[inline]
    pub unsafe fn close(&self) -> OSStatus {
        extern "C-unwind" {
            fn VTMultiPassStorageClose(multi_pass_storage: &VTMultiPassStorage) -> OSStatus;
        }
        unsafe { VTMultiPassStorageClose(self) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-media")]
    #[deprecated = "renamed to `VTMultiPassStorage::create`"]
    pub fn VTMultiPassStorageCreate(
        allocator: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
        time_range: CMTimeRange,
        options: Option<&CFDictionary>,
        multi_pass_storage_out: NonNull<*mut VTMultiPassStorage>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `VTMultiPassStorage::close`"]
    pub fn VTMultiPassStorageClose(multi_pass_storage: &VTMultiPassStorage) -> OSStatus;
}
