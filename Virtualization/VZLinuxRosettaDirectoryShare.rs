//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Constants that describe the availability and installation status of Rosetta.
/// Availability of Rosetta support for Linux binaries.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct VZLinuxRosettaAvailability(pub NSInteger);
impl VZLinuxRosettaAvailability {
    /// The current hardware or software configuration doesn’t support Rosetta.
    ///
    /// ## Discussion
    ///
    /// This error can occur if the host’s version of macOS doesn’t support Rosetta, such as macOS 12 or earlier, or if the underlying Mac computer doesn’t support Rosetta, such as an Intel-based Mac computer.
    ///
    ///
    /// Rosetta support for Linux binaries is not available on the host system.
    #[doc(alias = "VZLinuxRosettaAvailabilityNotSupported")]
    pub const NotSupported: Self = Self(0);
    /// Rosetta isn’t installed.
    /// Rosetta support for Linux binaries is not installed on the host system.
    #[doc(alias = "VZLinuxRosettaAvailabilityNotInstalled")]
    pub const NotInstalled: Self = Self(1);
    /// Rosetta is available on the host system.
    /// Rosetta support for Linux is installed on the host system.
    #[doc(alias = "VZLinuxRosettaAvailabilityInstalled")]
    pub const Installed: Self = Self(2);
}

unsafe impl Encode for VZLinuxRosettaAvailability {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for VZLinuxRosettaAvailability {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The Linux directory share for Rosetta.
    ///
    /// ## Overview
    ///
    /// This directory share exposes the Rosetta directory from the host file system to the guest. The example below shows the process of creating a [`VZVirtualMachineConfiguration`](https://developer.apple.com/documentation/virtualization/vzvirtualmachineconfiguration), and then associating the Rosetta directory share with the VM configuration.
    ///
    /// ```swift
    /// let tag = "EXAMPLE_TAG"  
    /// let configuration = VZVirtualMachineConfiguration()
    /// do {
    ///     try let validationError = VZVirtioFileSystemDeviceConfiguration.validateTag(tag)
    ///     let rosettaDirectoryShare = try VZLinuxRosettaDirectoryShare()
    ///     let fileSystemDevice = VZVirtioFileSystemDeviceConfiguration(tag: tag)
    ///     fileSystemDevice.share = rosettaDirectoryShare
    ///
    ///     configuration.directorySharingDevices = [ fileSystemDevice ]
    /// } catch VZError.invalidVirtualMachineConfiguration {
    ///     // Rosetta is unavailable.
    /// }
    /// ```
    ///
    /// For complete instructions on installing Rosetta see [Running Intel Binaries in Linux VMs with Rosetta](https://developer.apple.com/documentation/virtualization/running-intel-binaries-in-linux-vms-with-rosetta), which includes additional information about checking for Rosetta availability, mounting the directory share, and registering the Rosetta runtime binary to run Intel binaries in a guest VM.
    ///
    /// For information on using a custom kernel to enhance Rosetta performance, see [Accelerating the performance of Rosetta](https://developer.apple.com/documentation/virtualization/accelerating-the-performance-of-rosetta).
    ///
    ///
    /// Directory share to enable Rosetta support for Linux binaries.
    ///
    /// This directory share exposes Rosetta within a shared directory in the guest. Linux can use it to translate x86_64 binaries.
    ///
    /// See: VZDirectorySharingDeviceConfiguration
    ///
    /// See: VZSharedDirectory
    #[unsafe(super(VZDirectoryShare, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "VZDirectoryShare")]
    pub struct VZLinuxRosettaDirectoryShare;
);

#[cfg(feature = "VZDirectoryShare")]
extern_conformance!(
    unsafe impl NSObjectProtocol for VZLinuxRosettaDirectoryShare {}
);

#[cfg(feature = "VZDirectoryShare")]
impl VZLinuxRosettaDirectoryShare {
    extern_methods!(
        /// Initialize a Rosetta directory share if Rosetta support for Linux binaries is installed.
        ///
        /// Parameter `error`: Error object to store the error, if an error exists.
        ///
        /// The call returns an error if Rosetta is not available for a directory share. To install Rosetta support, use +[VZLinuxRosettaDirectoryShare installRosettaIfNeeded:].
        ///
        /// See: +[VZLinuxRosettaDirectoryShare installRosettaIfNeeded:]
        #[unsafe(method(initWithError:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithError(
            this: Allocated<Self>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "block2")]
        /// Download and install Rosetta support for Linux binaries if necessary.
        ///
        /// Parameter `completionHandler`: The completion handler gets called with a valid error on failure and a nil error on success. It will also be invoked on an arbitrary queue.
        ///
        /// The call prompts the user through the download and install flow for Rosetta. This call is successful if the error is nil.
        ///
        /// See: +[VZLinuxRosettaDirectoryShare availability]
        #[unsafe(method(installRosettaWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn installRosettaWithCompletionHandler(
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "VZLinuxRosettaCachingOptions")]
        /// Enable translation caching and configure the socket communication type for Rosetta.
        #[unsafe(method(options))]
        #[unsafe(method_family = none)]
        pub unsafe fn options(&self) -> Option<Retained<VZLinuxRosettaCachingOptions>>;

        #[cfg(feature = "VZLinuxRosettaCachingOptions")]
        /// Setter for [`options`][Self::options].
        #[unsafe(method(setOptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOptions(&self, options: Option<&VZLinuxRosettaCachingOptions>);

        /// Check the availability of Rosetta support for the directory share.
        #[unsafe(method(availability))]
        #[unsafe(method_family = none)]
        pub unsafe fn availability() -> VZLinuxRosettaAvailability;
    );
}

/// Methods declared on superclass `VZDirectoryShare`.
#[cfg(feature = "VZDirectoryShare")]
impl VZLinuxRosettaDirectoryShare {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}
