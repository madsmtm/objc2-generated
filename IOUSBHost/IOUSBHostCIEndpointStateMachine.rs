//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The object representing the state of a user-mode USB host controller endpoint
    ///
    /// This class assists with tracking internal state transitions of a user-mode USB host controller endpoint, and parses IOUSBHostCIMessage command
    /// structures to update state and generate properly formatted command responses.  Clients should create an IOUSBHostCIEndpointStateMachine in
    /// response to an IOUSBHostCIMessageTypeEndpointCreate command, and then use the provided interfaces to identify and process commands,
    /// doorbells, and transfer structures for the endpoint.  The IOUSBHostCIEndpointStateMachine should be destroyed in response to an
    /// IOUSBHostCIMessageTypeEndpointDestroy command.
    ///
    /// Endpoint state is controlled by IOUSBHostCIMessage structures representing commands and transfer completions, and IOUSBHostCIDoorbell messages.
    /// Only an endpoint in the IOUSBHostCIEndpointStateActive state may inspect transfer structures, read or modify IO buffers, and generate transfer completions.
    ///
    /// IOUSBHostCIEndpointStateMachine does not provide any concurrency protection, the client is responsible for necessary serialization.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostciendpointstatemachine?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct IOUSBHostCIEndpointStateMachine;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for IOUSBHostCIEndpointStateMachine {}
);

impl IOUSBHostCIEndpointStateMachine {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(
            feature = "IOUSBHostControllerInterface",
            feature = "IOUSBHostControllerInterfaceDefinitions"
        ))]
        /// Initializes an IOUSBHostCIEndpointStateMachine object
        ///
        /// The IOUSBHostCIEndpointStateMachine defaults to the IOUSBHostCIEndpointStatePaused state.
        ///
        /// Parameter `interface`: IOUSBHostControllerInterface which will be used to send command responses.
        ///
        /// Parameter `command`: IOUSBHostCIMessage with type IOUSBHostCIMessageTypeEndpointCreate
        ///
        /// Returns: IOUSBHostCIEndpointStateMachine instance, to be released by the caller.
        ///
        /// # Safety
        ///
        /// `command` must be a valid pointer.
        #[unsafe(method(initWithInterface:command:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithInterface_command_error(
            this: Allocated<Self>,
            interface: &IOUSBHostControllerInterface,
            command: NonNull<IOUSBHostCIMessage>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Inspect an IOUSBHostCIMessage command
        ///
        /// The IOUSBHostCIMessage command is inspected to determine if it is handled by this state machine and is appropriate for the current state.
        ///
        /// Parameter `command`: IOUSBHostCIMessage command structure received from the kernel driver.
        ///
        /// Returns: BOOL YES if the command is targeting this endpoint, and can be handled in the current state
        /// BOOL NO if the command does not target this endpoint, or cannot be handled in the current state
        ///
        /// # Safety
        ///
        /// `command` must be a valid pointer.
        #[unsafe(method(inspectCommand:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn inspectCommand_error(
            &self,
            command: NonNull<IOUSBHostCIMessage>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Advance the state machine and respond to an IOUSBHostCIMessage command
        ///
        /// If the command passes inspectCommand and the client indicates the command was processed successfully, endpointState is updated and
        /// a properly formatted command response message is sent to the kernel driver.  If the client indicates the command was not processed successfully,
        /// endpointState is not updated but a properly formatted command response message is sent to the kernel driver.
        ///
        /// Parameter `command`: IOUSBHostCIMessage command structure received from the kernel driver.
        ///
        /// Parameter `status`: IOUSBHostCIMessageStatus reported by the user-mode USB host controller implementation for the command response.
        ///
        /// Returns: BOOL YES if the command response was sent to the kernel driver
        /// BOOL NO if the command response was not sent to the kernel driver
        ///
        /// # Safety
        ///
        /// `command` must be a valid pointer.
        #[unsafe(method(respondToCommand:status:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn respondToCommand_status_error(
            &self,
            command: NonNull<IOUSBHostCIMessage>,
            status: IOUSBHostCIMessageStatus,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Advance the state machine and process an IOUSBHostCIDoorbell message
        ///
        /// The IOUSBHostCIDoorbell is inspected to determine if it is handled by this state machine and is appropriate for the current state.  If successful,
        /// the client should check for an IOUSBHostCIEndpointStateActive endpointState and a currentTransferMessage with IOUSBHostCIMessageControlValid set to determine
        /// if more IOUSBHostCIMessages should be processed.
        ///
        /// Parameter `doorbell`: IOUSBHostCIDoorbell message received from the kernel driver.
        ///
        /// Returns: BOOL YES if the doorbell is targeting this endpoint and can be handled in the current state.
        /// BOOL NO is the doorbell does not target this endpoint or cannot be handled in the current state.
        #[unsafe(method(processDoorbell:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn processDoorbell_error(
            &self,
            doorbell: IOUSBHostCIDoorbell,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Send an IOUSBHostCIMessage representing a transfer completion to the kernel, and advance the state machine
        ///
        /// When a client has processed an IOUSBHostCIMessage representing a transfer, the result is reported to the kernel by another IOUSBHostCIMessage.  If successful,
        /// this object will use controllerInterface's enqueueInterrupt interface to send a properly formatted IOUSBHostCIMessage to the kernel with
        /// IOUSBHostCITransferCompletionMessageData1TransferStructure populated with currentTransferMessage's virtual address, and endpointState and currentTransferMessage
        /// are updated.  After a successful call, the client should check for an IOUSBHostCIEndpointStateActive endpointState and a currentTransferMessage with IOUSBHostCIMessageControlValid
        /// set to determine if more IOUSBHostCIMessages should be processed.
        ///
        /// Parameter `message`: pointer to the IOUSBHostCIMessage which generated this tranafer completion message.  This must match currentTransferMessage to be successful.
        ///
        /// Parameter `status`: IOUSBHostCIMessageStatus
        ///
        /// Parameter `transferLength`: The number of bytes transferred for the specified transfer structure.
        ///
        /// # Safety
        ///
        /// `message` must be a valid pointer.
        #[unsafe(method(enqueueTransferCompletionForMessage:status:transferLength:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueTransferCompletionForMessage_status_transferLength_error(
            &self,
            message: NonNull<IOUSBHostCIMessage>,
            status: IOUSBHostCIMessageStatus,
            transfer_length: NSUInteger,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        #[unsafe(method(endpointState))]
        #[unsafe(method_family = none)]
        pub unsafe fn endpointState(&self) -> IOUSBHostCIEndpointState;

        #[unsafe(method(deviceAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceAddress(&self) -> NSUInteger;

        #[unsafe(method(endpointAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn endpointAddress(&self) -> NSUInteger;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        #[unsafe(method(currentTransferMessage))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentTransferMessage(&self) -> NonNull<IOUSBHostCIMessage>;

        #[cfg(feature = "IOUSBHostControllerInterface")]
        #[unsafe(method(controllerInterface))]
        #[unsafe(method_family = none)]
        pub unsafe fn controllerInterface(&self) -> Retained<IOUSBHostControllerInterface>;
    );
}

/// Methods declared on superclass `NSObject`.
impl IOUSBHostCIEndpointStateMachine {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
