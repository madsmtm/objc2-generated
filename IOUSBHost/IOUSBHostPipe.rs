//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-io-kit")]
use objc2_io_kit::*;

use crate::*;

extern_class!(
    /// The IOUSBHostIOSource representing a USB endpoint
    ///
    /// This class provides functionality to transfer data across USB.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostpipe?language=objc)
    #[unsafe(super(IOUSBHostIOSource, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "IOUSBHostIOSource")]
    pub struct IOUSBHostPipe;
);

#[cfg(feature = "IOUSBHostIOSource")]
extern_conformance!(
    unsafe impl NSObjectProtocol for IOUSBHostPipe {}
);

#[cfg(feature = "IOUSBHostIOSource")]
impl IOUSBHostPipe {
    extern_methods!(
        #[cfg(feature = "objc2-io-kit")]
        /// Retrieve the Original descriptor used when creating the pipe.
        ///
        /// Returns: IOUSBHostIOSourceDescriptors pointer
        #[unsafe(method(originalDescriptors))]
        #[unsafe(method_family = none)]
        pub unsafe fn originalDescriptors(&self) -> NonNull<IOUSBHostIOSourceDescriptors>;

        #[cfg(feature = "objc2-io-kit")]
        /// Retrieve the current descriptor controlling the endpoint.
        ///
        /// Returns: IOUSBHostIOSourceDescriptors pointer
        #[unsafe(method(descriptors))]
        #[unsafe(method_family = none)]
        pub unsafe fn descriptors(&self) -> NonNull<IOUSBHostIOSourceDescriptors>;

        #[cfg(feature = "objc2-io-kit")]
        /// Adjust behavior of periodic endpoints to consume a different amount of bus bandwidth
        ///
        /// Periodic (interrupt and isochronous) endpoints reserve bus bandwidth when they are
        /// created, which takes into account max packet size, burst size, and the endpoint
        /// service interval.  If a function driver knows the endpoint will not use all of the
        /// allocated bandwidth, the
        /// <code>
        /// adjustPolicy
        /// </code>
        /// method may be used to reduce the
        /// bandwidth reserved for the endpoint.  The original endpoint descriptors should be
        /// copied and modified to adjust max packet size, mult, burst, and interval, and then
        /// passed to
        /// <code>
        /// adjustPolicy
        /// </code>
        /// .  The altered descriptors must pass
        /// <code>
        /// validateEndpointDescriptor(...)
        /// </code>
        /// from the kernel for policy changes to be
        /// processed.
        ///
        /// Parameter `descriptors`: Reference to an IOUSBHostIOSourceDescriptors describing the
        /// new endpoint policy
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `descriptors` must be a valid pointer.
        #[unsafe(method(adjustPipeWithDescriptors:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn adjustPipeWithDescriptors_error(
            &self,
            descriptors: NonNull<IOUSBHostIOSourceDescriptors>,
        ) -> Result<(), Retained<NSError>>;

        /// Retrieve the current idle suspend timeout.
        /// See
        ///
        /// ```text
        ///  setIdleTimeout
        /// ```
        ///
        ///
        /// Returns: The amount of time after all pipes are idle to wait before
        /// suspending the device,
        #[unsafe(method(idleTimeout))]
        #[unsafe(method_family = none)]
        pub unsafe fn idleTimeout(&self) -> NSTimeInterval;

        /// Sets the desired idle suspend timeout for the interface
        ///
        /// Once the interface is considered idle, it will defer electrical suspend of the
        /// device for the specified duration.
        ///
        /// Parameter `idleTimeout`: The amount of time after all pipes are idle to
        /// wait before suspending the device.
        ///
        /// Returns: YES on success. An IOReturn error code will be reported on failure.
        #[unsafe(method(setIdleTimeout:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdleTimeout_error(
            &self,
            idle_timeout: NSTimeInterval,
        ) -> Result<(), Retained<NSError>>;

        /// Clear the halt condition of the pipe.
        ///
        /// When a bulk or interrupt USB endpoint encounters any IO error other than a timeout,
        /// it transitions to a Halted state which must be cleared to perform additional IO on
        /// the endpoint.  This method will clear the halted condition for the endpoint,
        /// including sending a CLEAR_TT_BUFFER control request  (USB 2.0 11.24.2.3) to an
        /// intermediate hub if required.  All pending IO on the endpoint will be aborted, and
        /// the data toggle for the endpoint will also be reset. ClearStall is not required for
        /// control endpoints.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(clearStallWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn clearStallWithError(&self) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Send a request on a control endpoint
        ///
        /// This method will send a synchronous request on a control endpoint, and will not
        /// return until the request is complete.
        ///
        /// Parameter `request`: IOUSBDeviceRequest structure.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `bytesTransferred`: An NSUInteger reference which will be updated with the byte count
        /// of the completed data phase.
        ///
        /// Parameter `completionTimeout`: Timeout of the request.  If 0, the request will never timeout.
        /// The default value is IOUSBHostDefaultControlCompletionTimeout.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `bytes_transferred` must be a valid pointer or null.
        #[unsafe(method(sendControlRequest:data:bytesTransferred:completionTimeout:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendControlRequest_data_bytesTransferred_completionTimeout_error(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            bytes_transferred: *mut NSUInteger,
            completion_timeout: NSTimeInterval,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Send a request on a control endpoint
        ///
        /// This method will send a synchronous request on a control endpoint, and will not
        /// return until the request is complete.
        ///
        /// Parameter `request`: IOUSBDeviceRequest structure.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `bytesTransferred`: An NSUInteger reference which will be updated with the byte count
        /// of the completed data phase.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `bytes_transferred` must be a valid pointer or null.
        #[unsafe(method(sendControlRequest:data:bytesTransferred:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendControlRequest_data_bytesTransferred_error(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            bytes_transferred: *mut NSUInteger,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Send a request on a control endpoint
        ///
        /// This method will send a synchronous request on a control endpoint, and will not
        /// return until the request is complete.
        ///
        /// Parameter `request`: IOUSBDeviceRequest structure.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(sendControlRequest:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendControlRequest_error(
            &self,
            request: IOUSBDeviceRequest,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "objc2-io-kit"
        ))]
        /// Enqueue a request on a control endpoint
        ///
        /// This method will enqueue an asynchronous request on a control endpoint.
        /// If successful, the provided completion routine will be called to report the status
        /// of the completed IO. Completions will be serviced in the
        /// IOUSBHostCompletionHandler on the IOUSBHostInterface's dispatch queue.
        ///
        /// Parameter `request`: Reference IOUSBDeviceRequest structure.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `completionTimeout`: Timeout of the request.  If 0, the request will
        /// never timeout. The default value is IOUSBHostDefaultControlCompletionTimeout.
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(enqueueControlRequest:data:completionTimeout:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueControlRequest_data_completionTimeout_error_completionHandler(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            completion_timeout: NSTimeInterval,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "objc2-io-kit"
        ))]
        /// Enqueue a request on a control endpoint
        ///
        /// This method will enqueue an asynchronous request on a control endpoint.
        /// If successful, the provided completion routine will be called to report the status
        /// of the completed IO. Completions will be serviced in the
        /// IOUSBHostCompletionHandler on the IOUSBHostInterface's dispatch queue.
        ///
        /// Parameter `request`: Reference IOUSBDeviceRequest structure.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(enqueueControlRequest:data:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueControlRequest_data_error_completionHandler(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "objc2-io-kit"
        ))]
        /// Enqueue a request on a control endpoint
        ///
        /// This method will enqueue an asynchronous request on a control endpoint.
        /// If successful, the provided completion routine will be called to report the status
        /// of the completed IO. Completions will be serviced in the
        /// IOUSBHostCompletionHandler on the IOUSBHostInterface's dispatch queue.
        ///
        /// Parameter `request`: Reference IOUSBDeviceRequest structure.
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(enqueueControlRequest:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueControlRequest_error_completionHandler(
            &self,
            request: IOUSBDeviceRequest,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Abort pending I/O requests.
        ///
        /// This method will abort all pending I/O requests.  If
        /// <code>
        /// option
        /// </code>
        /// includes
        /// <code>
        /// IOUSBHostAbortOptionSynchronous
        /// </code>
        /// , this method will block any new IO
        /// requests unless they are submitted from an aborted IO's completion routine.
        ///
        /// Parameter `option`: IOUSBHostAbortOption by default IOUSBHostAbortOptionSynchronous is used
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(abortWithOption:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn abortWithOption_error(
            &self,
            option: IOUSBHostAbortOption,
        ) -> Result<(), Retained<NSError>>;

        /// Abort pending I/O requests.
        ///
        /// This method will abort all pending I/O requests.  If
        /// <code>
        /// option
        /// </code>
        /// includes
        /// <code>
        /// IOUSBHostAbortOptionSynchronous
        /// </code>
        /// , this method will block any new IO
        /// requests unless they are submitted from an aborted IO's completion routine.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(abortWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn abortWithError(&self) -> Result<(), Retained<NSError>>;

        /// Send an IO request on the source
        ///
        /// This method will send a synchronous request on the IO source, and will not return
        /// until the request is complete.
        ///
        /// Parameter `data`: An NSMutableData* containing the buffer to use for the transfer. nil will send a zero length packet.
        ///
        /// Parameter `bytesTransferred`: NSUInteger pointer which will be updated with the bytes transferred
        /// during the request
        ///
        /// Parameter `completionTimeout`: Timeout of the request.  If 0, the request will never timeout.
        /// Must be 0 for interrupt pipes and streams.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `bytes_transferred` must be a valid pointer or null.
        #[unsafe(method(sendIORequestWithData:bytesTransferred:completionTimeout:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendIORequestWithData_bytesTransferred_completionTimeout_error(
            &self,
            data: Option<&NSMutableData>,
            bytes_transferred: *mut NSUInteger,
            completion_timeout: NSTimeInterval,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "IOUSBHostDefinitions", feature = "block2"))]
        /// Enqueue an IO request on the source
        ///
        /// This method is used to issue an asynchronous I/O request on a bulk or interrupt
        /// pipe.
        ///
        /// Parameter `data`: An NSMutableData* containing the buffer to use for the transfer. nil will send a zero length packet.
        ///
        /// Parameter `completionTimeout`: Timeout of the request.  If 0, the request will never timeout.
        /// Must be 0 for interrupt pipes and streams.
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(enqueueIORequestWithData:completionTimeout:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueIORequestWithData_completionTimeout_error_completionHandler(
            &self,
            data: Option<&NSMutableData>,
            completion_timeout: NSTimeInterval,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Send a request on an isochronous endpoint
        ///
        /// This method is used to issue isochronous requests.  The caller allocates and
        /// initializes  an array of IOUSBHostIsochronousFrame structures, which is used to
        /// describe the frames that will be transferred.  See
        ///
        /// ```text
        ///  IOUSBHostIsochronousFrame
        /// ```
        ///
        /// for information regarding structure
        /// initialization requirements and usage.
        ///
        /// Parameter `data`: An NSMutableData* to be used as the backing store for the I/O.
        ///
        /// Parameter `frameList`: Pointer first element in an IOUSBHostIsochronousFrame array.  The array
        /// must contain at least frameListCount elements.
        ///
        /// Parameter `frameListCount`: Number of elements in
        /// <code>
        /// frameList
        /// </code>
        /// .
        ///
        /// Parameter `firstFrameNumber`: Frame number which this request should begin on.  The current frame
        /// number can be queried via
        /// <code>
        /// [IOUSBHostObject getFrameNumber]
        /// </code>
        /// If 0, the transfer will start on the next available frame (XHCI only).
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `frame_list` must be a valid pointer.
        #[deprecated]
        #[unsafe(method(sendIORequestWithData:frameList:frameListCount:firstFrameNumber:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendIORequestWithData_frameList_frameListCount_firstFrameNumber_error(
            &self,
            data: &NSMutableData,
            frame_list: NonNull<IOUSBHostIsochronousFrame>,
            frame_list_count: NSUInteger,
            first_frame_number: u64,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "IOUSBHostDefinitions", feature = "block2"))]
        /// Send a request on an isochronous endpoint
        ///
        /// This method is used to issue isochronous requests.  The caller allocates and
        /// initializes an array of IOUSBHostIsochronousFrame structures, which is used to
        /// describe the frames that will be transferred.  See
        ///
        /// ```text
        ///  IOUSBHostIsochronousFrame
        /// ```
        ///
        /// for information regarding structure
        /// initialization requirements and usage.
        ///
        /// Parameter `data`: An NSMutableData* to be used as the backing store for the I/O.
        ///
        /// Parameter `frameList`: Pointer first element in an IOUSBHostIsochronousFrame array.  The array
        /// must contain at least frameListCount elements.
        ///
        /// Parameter `frameListCount`: Number of elements in
        /// <code>
        /// frameList
        /// </code>
        /// .
        ///
        /// Parameter `firstFrameNumber`: Frame number which this request should begin on.  The current frame
        /// number can be queried via
        /// <code>
        /// [IOUSBHostObject frameNumberWithTime]
        /// </code>
        /// If 0, the transfer will start on the next available frame (XHCI only).
        ///
        /// Parameter `completionHandler`: an IOUSBHostIsochronousCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// - `frame_list` must be a valid pointer.
        /// - `completion_handler` must be a valid pointer or null.
        #[deprecated]
        #[unsafe(method(enqueueIORequestWithData:frameList:frameListCount:firstFrameNumber:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueIORequestWithData_frameList_frameListCount_firstFrameNumber_error_completionHandler(
            &self,
            data: &NSMutableData,
            frame_list: NonNull<IOUSBHostIsochronousFrame>,
            frame_list_count: NSUInteger,
            first_frame_number: u64,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostIsochronousCompletionHandler,
        ) -> bool;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Send a request on an isochronous endpoint
        ///
        /// This method is used to issue isochronous requests. The caller allocates and
        /// initializes an array of IOUSBHostIsochronousTransaction structures, which is used to
        /// describe the frames that will be transferred. See
        ///
        /// ```text
        ///  IOUSBHostIsochronousTransaction
        /// ```
        ///
        /// for information regarding structure
        /// initialization requirements and usage.
        ///
        /// Parameter `data`: An NSMutableData* to be used as the backing store for the I/O.
        ///
        /// Parameter `transactionList`: Pointer to the first element in an IOUSBHostIsochronousTransaction
        /// array.  The array must contain at least transactionListCount elements.
        ///
        /// Parameter `transactionListCount`: Number of elements in
        /// <code>
        /// transactionList
        /// </code>
        /// .
        ///
        /// Parameter `firstFrameNumber`: Frame number which this request should begin on.  The current frame
        /// number can be queried via
        /// <code>
        /// [IOUSBHostObject getFrameNumber]
        /// </code>
        /// If 0, the transfer will start on the next available frame (XHCI only).
        ///
        /// Parameter `options`: Flags that specify additional behavior for every transaction in this transfer.
        /// See
        ///
        /// ```text
        ///  IOUSBHostIsochronousTransferOptions
        /// ```
        ///
        /// for more details.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `transaction_list` must be a valid pointer.
        #[unsafe(method(sendIORequestWithData:transactionList:transactionListCount:firstFrameNumber:options:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendIORequestWithData_transactionList_transactionListCount_firstFrameNumber_options_error(
            &self,
            data: &NSMutableData,
            transaction_list: NonNull<IOUSBHostIsochronousTransaction>,
            transaction_list_count: NSUInteger,
            first_frame_number: u64,
            options: IOUSBHostIsochronousTransferOptions,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "IOUSBHostDefinitions", feature = "block2"))]
        /// Send a request on an isochronous endpoint
        ///
        /// This method is used to issue isochronous requests.  The caller allocates and
        /// initializes an array of IOUSBHostIsochronousTransaction structures, which is used to
        /// describe the frames that will be transferred. See
        ///
        /// ```text
        ///  IOUSBHostIsochronousTransaction
        /// ```
        ///
        /// for information regarding structure
        /// initialization requirements and usage.
        ///
        /// Parameter `data`: An NSMutableData* to be used as the backing store for the I/O.
        ///
        /// Parameter `transactionList`: Pointer to the first element in an IOUSBHostIsochronousTransaction
        /// array.  The array must contain at least transactionListCount elements.
        ///
        /// Parameter `transactionListCount`: Number of elements in
        /// <code>
        /// transactionList
        /// </code>
        /// .
        ///
        /// Parameter `firstFrameNumber`: Frame number which this request should begin on.  The current frame
        /// number can be queried via
        /// <code>
        /// [IOUSBHostObject frameNumberWithTime]
        /// </code>
        /// If 0, the transfer will start on the next available frame (XHCI only).
        ///
        /// Parameter `options`: Flags that specify additional behavior for every transaction in this transfer.
        ///
        /// Parameter `completionHandler`: an IOUSBHostIsochronousTransactionCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// - `transaction_list` must be a valid pointer.
        /// - `completion_handler` must be a valid pointer or null.
        #[unsafe(method(enqueueIORequestWithData:transactionList:transactionListCount:firstFrameNumber:options:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueIORequestWithData_transactionList_transactionListCount_firstFrameNumber_options_error_completionHandler(
            &self,
            data: &NSMutableData,
            transaction_list: NonNull<IOUSBHostIsochronousTransaction>,
            transaction_list_count: NSUInteger,
            first_frame_number: u64,
            options: IOUSBHostIsochronousTransferOptions,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostIsochronousTransactionCompletionHandler,
        ) -> bool;

        /// Enable streams for the IOUSBHostPipe
        ///
        /// This method changes the operational mode of the IOUSBHostPipe to allow streaming
        /// endpoint transfers, and must be called before copyStream will return any
        /// IOUSBHostStream objects.
        ///
        /// Returns: YES on success, an An IOReturn error will be returned if the pipe, device, or
        /// underlying host controller does not support streams.
        #[unsafe(method(enableStreamsWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn enableStreamsWithError(&self) -> Result<(), Retained<NSError>>;

        /// Disable streams for the IOUSBHostPipe
        ///
        /// This method changes the operational mode of the IOUSBHostPipe to disable streaming
        /// endpoint transfers.  Calling this method will synchronously abort any outstanding
        /// calls on existing IOUSBHostStream objects, and therefore all stream contexts should
        /// first be set as non-active on the device via an out-of-band (class-defined)
        /// mechanism (USB 3.1 8.12.1.4).
        ///
        /// Returns: YES on success,  An IOReturn error will be returned if streams were not enabled for
        /// this IOUSBHostPipe.
        #[unsafe(method(disableStreamsWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn disableStreamsWithError(&self) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostStream")]
        /// Return the stream associated with
        /// <code>
        /// streamID
        /// </code>
        ///
        /// This method will return the stream associated with
        /// <code>
        /// streamID
        /// </code>
        /// .
        /// The caller must release the IOUSBHostStream when finished using it.
        /// <code>
        /// [IOUSBHostPipe enableStreams]
        /// </code>
        /// must be called before this
        /// method will return a stream object.
        ///
        /// Parameter `streamID`: Stream ID in the range of 1 to
        /// <code>
        /// max
        /// </code>
        /// , where
        /// <code>
        /// max
        /// </code>
        /// can be retrieved by calling
        /// <code>
        /// getEndpointMaxStreams
        /// </code>
        /// with
        /// the endpoint descriptors.
        ///
        /// Returns: Pointer to an IOUSBHostStream object or nil. nil may be returned if either the
        /// device or the underlying host controller do not support that stream ID.
        #[unsafe(method(copyStreamWithStreamID:error:_))]
        #[unsafe(method_family = copy)]
        pub unsafe fn copyStreamWithStreamID_error(
            &self,
            stream_id: NSUInteger,
        ) -> Result<Retained<IOUSBHostStream>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `IOUSBHostIOSource`.
#[cfg(feature = "IOUSBHostIOSource")]
impl IOUSBHostPipe {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "IOUSBHostIOSource")]
impl IOUSBHostPipe {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
