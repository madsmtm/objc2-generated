//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-io-kit")]
use objc2_io_kit::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostinteresthandler?language=objc)
#[cfg(feature = "block2")]
pub type IOUSBHostInterestHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<IOUSBHostObject>, u32, *mut c_void)>;

extern_class!(
    /// The Abstract class IOUSBHostDevice and IOUSBHostInterface derive from.
    ///
    /// Defines common methods that are shared between IOUSBHostDevice and IOUSBHostInterface including instance
    /// management.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostobject?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct IOUSBHostObject;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for IOUSBHostObject {}
);

impl IOUSBHostObject {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "dispatch2",
            feature = "objc2-io-kit"
        ))]
        /// Initializes IOUSBHostObject object along with user client
        ///
        /// If the io_service_t is not found nil will be returned. If an IOUSBHostDevice or
        /// IOUSBHostInterface user client is already created, nil will be returned.
        /// Upon creation, exclusive ownership of the IOService will be established. When done
        /// using the object destroy must be called on the object.
        ///
        /// Parameter `ioService`: io_service_t of the IOUSBHostDevice or IOUSBHostInterface
        /// the user client is for. The IOUSBHostObject will keep a reference to the io_service_t
        /// and release it after the IOUSBHostObject has been released.
        ///
        /// Parameter `options`: IOUSBHostObjectInitOptions. Default value is IOUSBHostObjectInitOptionsNone
        ///
        /// Parameter `queue`: A serial queue that all asynchronous io will be serviced. By
        /// default a serial queue will be created on behalf of the client. Setting
        /// a queue will create a dispatch source event handler for the target queue to service
        /// all underlying io.
        ///
        /// Parameter `interestHandler`: IOUSBHostInterestHandler a generalInterest IOService handler. This is
        /// to handle underlying service state changes such as termination. See
        /// IOServiceAddInterestNotification in IOKitLib for more details. All notifications will be serviced
        /// on an internal serial queue separate from the IO queue.
        ///
        /// Returns: An IOUSBHostDevice or IOUSBHostInterface. The object is to be released by the caller.
        /// An IOReturn error code will be reported on failure.
        ///
        /// # Safety
        ///
        /// - `queue` possibly has additional threading requirements.
        /// - `interest_handler` must be a valid pointer or null.
        #[unsafe(method(initWithIOService:options:queue:error:interestHandler:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIOService_options_queue_error_interestHandler(
            this: Allocated<Self>,
            io_service: io_service_t,
            options: IOUSBHostObjectInitOptions,
            queue: Option<&DispatchQueue>,
            error: Option<&mut Option<Retained<NSError>>>,
            interest_handler: IOUSBHostInterestHandler,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "block2", feature = "dispatch2", feature = "objc2-io-kit"))]
        /// Initializes IOUSBHostObject object along with user client
        ///
        /// This method should be called from either IOUSBHostDevice or IOUSBHostInterface.
        /// If the io_service_t is not found nil will be returned. If an IOUSBHostDevice or
        /// IOUSBHostInterface user client is already created, nil will be returned.
        /// Upon creation, exclusive ownership of the IOService will be established. When done
        /// using the object destroy must be called on the object.
        ///
        /// Parameter `ioService`: io_service_t of the IOUSBHostDevice or IOUSBHostInterface
        /// the user client is for. The IOUSBHostObject will keep a reference to the io_service_t
        /// and release it after the IOUSBHostObject has been released.
        ///
        /// Parameter `queue`: A serial queue that all asynchronous io will be serviced. By
        /// default a serial queue will be created on behalf of the client. Setting
        /// a queue will create a dispatch source event handler for the target queue to service
        /// all underlying io.
        ///
        /// Parameter `interestHandler`: IOUSBHostInterestHandler a generalInterest IOService handler. This is
        /// to handle underlying service state changes such as termination. See
        /// IOServiceAddInterestNotification in IOKitLib for more details. All notifications will be serviced
        /// on an internal serial queue separate from the IO queue.
        ///
        /// Returns: An IOUSBHostDevice or IOUSBHostInterface. The object is to be released by the caller.
        /// An IOReturn error code will be reported on failure.
        ///
        /// # Safety
        ///
        /// - `queue` possibly has additional threading requirements.
        /// - `interest_handler` must be a valid pointer or null.
        #[unsafe(method(initWithIOService:queue:error:interestHandler:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIOService_queue_error_interestHandler(
            this: Allocated<Self>,
            io_service: io_service_t,
            queue: Option<&DispatchQueue>,
            error: Option<&mut Option<Retained<NSError>>>,
            interest_handler: IOUSBHostInterestHandler,
        ) -> Option<Retained<Self>>;

        /// Removes underlying allocations of the IOUSBHostObject object along with user client
        ///
        /// When the IOUSBHostObject is no longer needed, destroy must be called. This will destroy
        /// the connection with the user client and de-register interest on the service. If the object
        /// is free'd destroy will be called automatically. Calling destroy multiple times has no effect.
        #[unsafe(method(destroy))]
        #[unsafe(method_family = none)]
        pub unsafe fn destroy(&self);

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Removes underlying allocations of the IOUSBHostObject object along with user client
        ///
        /// Extends
        /// <code>
        /// destroy
        /// </code>
        /// to take an options to modify the destroy behavior.  Currently only the
        /// <code>
        /// IOUSBHostObjectDestroyOptionsDeviceSurrender
        /// </code>
        /// is defined to support surrendering ownersip of
        /// the kernel service.  To be used when accepting the
        /// <code>
        /// kUSBHostMessageDeviceIsRequestingClose
        /// </code>
        /// message.
        #[unsafe(method(destroyWithOptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn destroyWithOptions(&self, options: IOUSBHostObjectDestroyOptions);

        #[cfg(feature = "objc2-io-kit")]
        /// Retrieve the IOUSBHostObject's io_service_t.
        #[unsafe(method(ioService))]
        #[unsafe(method_family = none)]
        pub unsafe fn ioService(&self) -> io_service_t;

        #[cfg(feature = "dispatch2")]
        /// The dispatch queue that all asynchronous io will be serviced.
        #[unsafe(method(queue))]
        #[unsafe(method_family = none)]
        pub unsafe fn queue(&self) -> Retained<DispatchQueue>;

        #[cfg(feature = "objc2-io-kit")]
        /// Send a request on the default control endpoint
        ///
        /// This method will send a synchronous request on the default control endpoint, and
        /// will not return until the request is complete.
        ///
        /// Parameter `request`: IOUSBDeviceRequest structure.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `bytesTransferred`: Optional NSUInteger reference which will be updated with the byte
        /// count of the completed data phase.
        ///
        /// Parameter `completionTimeout`: Timeout of the request. If 0, the request will never timeout. By
        /// default this value is IOUSBHostDefaultControlCompletionTimeout.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        ///
        /// # Safety
        ///
        /// `bytes_transferred` must be a valid pointer or null.
        #[unsafe(method(sendDeviceRequest:data:bytesTransferred:completionTimeout:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDeviceRequest_data_bytesTransferred_completionTimeout_error(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            bytes_transferred: *mut NSUInteger,
            completion_timeout: NSTimeInterval,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Send a request on the default control endpoint
        ///
        /// This method will send a synchronous request on the default control endpoint, and
        /// will not return until the request is complete.
        ///
        /// Parameter `request`: IOUSBDeviceRequest structure.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `bytesTransferred`: Optional NSUInteger reference which will be updated with the byte
        /// count of the completed data phase.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        ///
        /// # Safety
        ///
        /// `bytes_transferred` must be a valid pointer or null.
        #[unsafe(method(sendDeviceRequest:data:bytesTransferred:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDeviceRequest_data_bytesTransferred_error(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            bytes_transferred: *mut NSUInteger,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Send a request on the default control endpoint
        ///
        /// This method will send a synchronous request on the default control endpoint, and
        /// will not return until the request is complete.
        ///
        /// Parameter `request`: IOUSBDeviceRequest structure.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        #[unsafe(method(sendDeviceRequest:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDeviceRequest_error(
            &self,
            request: IOUSBDeviceRequest,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "objc2-io-kit"
        ))]
        /// Enqueue a request on the default control endpoint
        ///
        /// This method will enqueue an asynchronous request on the default control endpoint.
        /// If successful, the provided completionHandler will be called to report the status
        /// of the completed IO.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `completionTimeout`: Timeout of the request. If 0, the request will never timeout. By
        /// default this value is IOUSBHostDefaultControlCompletionTimeout
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(enqueueDeviceRequest:data:completionTimeout:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueDeviceRequest_data_completionTimeout_error_completionHandler(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            completion_timeout: NSTimeInterval,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "objc2-io-kit"
        ))]
        /// Enqueue a request on the default control endpoint
        ///
        /// This method will enqueue an asynchronous request on the default control endpoint.
        /// If successful, the provided completionHandler will be called to report the status
        /// of the completed IO.
        ///
        /// Parameter `data`: An NSMutableData* defining the memory to use for the request's data phase.
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(enqueueDeviceRequest:data:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueDeviceRequest_data_error_completionHandler(
            &self,
            request: IOUSBDeviceRequest,
            data: Option<&NSMutableData>,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "objc2-io-kit"
        ))]
        /// Enqueue a request on the default control endpoint
        ///
        /// This method will enqueue an asynchronous request on the default control endpoint.
        /// If successful, the provided completionHandler will be called to report the status
        /// of the completed IO.
        /// default this value is IOUSBHostDefaultControlCompletionTimeout
        ///
        /// Parameter `completionHandler`: an IOUSBHostCompletionHandler
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(enqueueDeviceRequest:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueDeviceRequest_error_completionHandler(
            &self,
            request: IOUSBDeviceRequest,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Abort device requests
        ///
        /// This method will abort any requests made via the
        ///
        /// ```text
        ///  sendDeviceRequest
        /// ```
        ///
        /// and
        ///
        /// ```text
        ///  enqueueDeviceRequest
        /// ```
        ///
        /// methods.
        ///
        /// Parameter `option`: IOUSBHostAbortOption by default IOUSBHostAbortOptionSynchronous is used
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(abortDeviceRequestsWithOption:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn abortDeviceRequestsWithOption_error(
            &self,
            option: IOUSBHostAbortOption,
        ) -> Result<(), Retained<NSError>>;

        /// Abort device requests
        ///
        /// This method will abort any requests made via the
        ///
        /// ```text
        ///  sendDeviceRequest
        /// ```
        ///
        /// and
        ///
        /// ```text
        ///  enqueueDeviceRequest
        /// ```
        ///
        /// methods.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(abortDeviceRequestsWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn abortDeviceRequestsWithError(&self) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Retrieve a descriptor from the cache or the device
        ///
        /// This method will search the descriptor cache for the descriptor that matches the
        /// input arguments.  If the descriptor is not in the cache, a GET_DESCRIPTOR control
        /// request (USB 2.0 9.4.3) will be issued to retrieve the descriptor from the device.
        /// If the device request is successful, the retrieved descriptor will be added to the
        /// cache.
        ///
        /// Parameter `type`: <code>
        /// bDescriptorType
        /// </code>
        /// of the descriptor to find.
        ///
        /// Parameter `length`: Reference to a NSUInteger which will be updated with the length of the
        /// descriptor. As input, used as
        /// <code>
        /// wLength
        /// </code>
        /// when fetching variable-length
        /// configuration or BOS descriptors, or when fetching nonstandard descriptor types.
        ///
        /// Parameter `index`: Descriptor index value.  Low byte of
        /// <code>
        /// wValue
        /// </code>
        /// of the SET_DESCRIPTOR
        /// control request (USB 2.0 9.4.8). By default the value is 0
        ///
        /// Parameter `languageID`: Descriptor language ID.
        /// <code>
        /// wIndex
        /// </code>
        /// of the SET_DESCRIPTOR
        /// control request (USB 2.0 9.4.8).  By default the value is 0
        ///
        /// Parameter `requestType`: tDeviceRequestType to be used for a GET_DESCRIPTOR control request.
        /// By default the value is IOUSBRequestTypeStandard
        ///
        /// Parameter `requestRecipient`: tDeviceRequestRecipient to be used for a GET_DESCRIPTOR control
        /// request. By default the value is IOUSBRequestRecipientDevice
        ///
        /// Returns: Pointer to the cached descriptor if found, otherwise nil. An IOReturn error code
        /// will be reported on failure.
        ///
        /// # Safety
        ///
        /// `length` must be a valid pointer.
        #[unsafe(method(descriptorWithType:length:index:languageID:requestType:requestRecipient:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn descriptorWithType_length_index_languageID_requestType_requestRecipient_error(
            &self,
            r#type: tIOUSBDescriptorType,
            length: NonNull<NSUInteger>,
            index: NSUInteger,
            language_id: NSUInteger,
            request_type: tIOUSBDeviceRequestTypeValue,
            request_recipient: tIOUSBDeviceRequestRecipientValue,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> *const IOUSBDescriptor;

        #[cfg(feature = "objc2-io-kit")]
        /// Retrieve a descriptor from the cache or the device
        ///
        /// This method will search the descriptor cache for the descriptor that matches the
        /// input arguments.  If the descriptor is not in the cache, a GET_DESCRIPTOR control
        /// request (USB 2.0 9.4.3) will be issued to retrieve the descriptor from the device.
        /// If the device request is successful, the retrieved descriptor will be added to the
        /// cache.
        ///
        /// Parameter `type`: <code>
        /// bDescriptorType
        /// </code>
        /// of the descriptor to find.
        ///
        /// Parameter `length`: Reference to a NSUInteger which will be updated with the length of the
        /// descriptor. As input, used as
        /// <code>
        /// wLength
        /// </code>
        /// when fetching variable-length
        /// configuration or BOS descriptors, or when fetching nonstandard descriptor types.
        ///
        /// Parameter `index`: Descriptor index value.  Low byte of
        /// <code>
        /// wValue
        /// </code>
        /// of the SET_DESCRIPTOR
        /// control request (USB 2.0 9.4.8). By default the value is 0
        ///
        /// Parameter `languageID`: Descriptor language ID.
        /// <code>
        /// wIndex
        /// </code>
        /// of the SET_DESCRIPTOR
        /// control request (USB 2.0 9.4.8).  By default the value is 0
        ///
        /// Returns: Pointer to the cached descriptor if found, otherwise nil. An IOReturn error code
        /// will be reported on failure.
        ///
        /// # Safety
        ///
        /// `length` must be a valid pointer.
        #[unsafe(method(descriptorWithType:length:index:languageID:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn descriptorWithType_length_index_languageID_error(
            &self,
            r#type: tIOUSBDescriptorType,
            length: NonNull<NSUInteger>,
            index: NSUInteger,
            language_id: NSUInteger,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> *const IOUSBDescriptor;

        #[cfg(feature = "objc2-io-kit")]
        /// Retrieve a descriptor from the cache or the device
        ///
        /// This method will search the descriptor cache for the descriptor that matches the
        /// input arguments.  If the descriptor is not in the cache, a GET_DESCRIPTOR control
        /// request (USB 2.0 9.4.3) will be issued to retrieve the descriptor from the device.
        /// If the device request is successful, the retrieved descriptor will be added to the
        /// cache.
        ///
        /// Parameter `type`: <code>
        /// bDescriptorType
        /// </code>
        /// of the descriptor to find.
        ///
        /// Parameter `length`: Reference to a NSUInteger which will be updated with the length of the
        /// descriptor. As input, used as
        /// <code>
        /// wLength
        /// </code>
        /// when fetching variable-length
        /// configuration or BOS descriptors, or when fetching nonstandard descriptor types.
        /// By default the value is 0
        ///
        /// Returns: Pointer to the cached descriptor if found, otherwise nil. An IOReturn error code
        /// will be reported on failure.
        ///
        /// # Safety
        ///
        /// `length` must be a valid pointer.
        #[unsafe(method(descriptorWithType:length:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn descriptorWithType_length_error(
            &self,
            r#type: tIOUSBDescriptorType,
            length: NonNull<NSUInteger>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> *const IOUSBDescriptor;

        #[cfg(feature = "objc2-io-kit")]
        /// Return the device descriptor
        ///
        /// This method uses descriptorWithType to retrieve the device descriptor.
        ///
        /// Returns: Pointer to the device descriptor.
        #[unsafe(method(deviceDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceDescriptor(&self) -> *const IOUSBDeviceDescriptor;

        #[cfg(feature = "objc2-io-kit")]
        /// Return the capability descriptors of the device
        ///
        /// This method uses descriptorWithType to return the device's BOS descriptors
        ///
        /// Returns: Pointer to the BOS descriptor if found, otherwise nil.
        #[unsafe(method(capabilityDescriptors))]
        #[unsafe(method_family = none)]
        pub unsafe fn capabilityDescriptors(&self) -> *const IOUSBBOSDescriptor;

        #[cfg(feature = "objc2-io-kit")]
        /// Return the configuration descriptor at a specified index
        ///
        /// This method uses descriptorWithType to retrieve the configuration descriptor.
        ///
        /// Parameter `index`: Descriptor index value
        ///
        /// Returns: Pointer of the configuration descriptor if found, otherwise nil. An IOReturn error
        /// code will be reported on failure.
        #[unsafe(method(configurationDescriptorWithIndex:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn configurationDescriptorWithIndex_error(
            &self,
            index: NSUInteger,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> *const IOUSBConfigurationDescriptor;

        #[cfg(feature = "objc2-io-kit")]
        /// Return the configuration descriptor with a specified value
        ///
        /// This method uses descriptorWithType to search for a configuration descriptor with a
        /// specific
        /// <code>
        /// bConfigurationValue
        /// </code>
        /// field.
        ///
        /// Parameter `configurationValue`: Value to match
        ///
        /// Returns: Pointer of the configuration descriptor if found, otherwise nil. An IOReturn error
        /// code will be reported on failure.
        #[unsafe(method(configurationDescriptorWithConfigurationValue:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn configurationDescriptorWithConfigurationValue_error(
            &self,
            configuration_value: NSUInteger,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> *const IOUSBConfigurationDescriptor;

        /// Returns the string from a string descriptor
        ///
        /// This method uses descriptorWithType to retrieve the string descriptor.
        ///
        /// Parameter `index`: Descriptor index value.  Low byte of
        /// <code>
        /// wValue
        /// </code>
        /// of the
        /// SET_DESCRIPTOR control request (USB 2.0 9.4.8).
        ///
        /// Parameter `languageID`: Descriptor language ID.
        /// <code>
        /// wIndex
        /// </code>
        /// of the SET_DESCRIPTOR
        /// control request (USB 2.0 9.4.8). By default this value is kLanguageIDEnglishUS
        ///
        /// Returns: NSString reference to string from descriptor, an IOReturn error code will be reported on
        /// failure.
        #[unsafe(method(stringWithIndex:languageID:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithIndex_languageID_error(
            &self,
            index: NSUInteger,
            language_id: NSUInteger,
        ) -> Result<Retained<NSString>, Retained<NSError>>;

        /// Returns the string from a string descriptor
        ///
        /// This method uses descriptorWithType to retrieve the string descriptor.
        ///
        /// Parameter `index`: Descriptor index value.  Low byte of
        /// <code>
        /// wValue
        /// </code>
        /// of the
        /// SET_DESCRIPTOR control request (USB 2.0 9.4.8).
        ///
        /// Returns: NSString reference to string from descriptor, an IOReturn error code will be reported on
        /// failure.
        #[unsafe(method(stringWithIndex:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringWithIndex_error(
            &self,
            index: NSUInteger,
        ) -> Result<Retained<NSString>, Retained<NSError>>;

        /// Retrieve the current address of the device.
        #[unsafe(method(deviceAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceAddress(&self) -> NSUInteger;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Return the current frame number of the USB controller
        ///
        /// This method will return the current frame number of the USB controller,
        /// omitting micro frame.  This is most useful for scheduling future isochronous
        /// requests.
        ///
        /// Parameter `time`: If not nil, this will be updated with the current system time
        ///
        /// Returns: The current frame number
        ///
        /// # Safety
        ///
        /// `time` must be a valid pointer or null.
        #[unsafe(method(frameNumberWithTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn frameNumberWithTime(&self, time: *mut IOUSBHostTime) -> u64;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Return the current microframe number of the USB controller
        ///
        /// This method will return the current microframe number of the USB controller.
        /// This is most useful for scheduling future isochronous requests.
        ///
        /// Parameter `time`: If not nil, this will be updated with system time associated with the microframe.
        ///
        /// Returns: The current microframe number. Returns 0 on failure, with NSError populated with the IOReturn error code.
        ///
        /// # Safety
        ///
        /// `time` must be a valid pointer or null.
        #[unsafe(method(currentMicroframeWithTime:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentMicroframeWithTime_error(
            &self,
            time: *mut IOUSBHostTime,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> u64;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Return a recent microframe number of the USB controller
        ///
        /// This method will return a recent microframe number of the USB controller.
        /// This is most useful for scheduling future isochronous requests.
        ///
        /// Parameter `time`: If not nil, this will be updated with system time associated with the microframe.
        ///
        /// Returns: A recent microframe number. Returns 0 on failure, with NSError populated with the IOReturn error code.
        ///
        /// # Safety
        ///
        /// `time` must be a valid pointer or null.
        #[unsafe(method(referenceMicroframeWithTime:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn referenceMicroframeWithTime_error(
            &self,
            time: *mut IOUSBHostTime,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> u64;

        /// Allocate a buffer to be used for I/O
        ///
        /// This method will allocate and map an IOBufferMemoryDescriptor optimized for use
        /// by the underlying controller hardware. A buffer allocated by this method will not
        /// be bounced to perform DMA operations.
        /// Because the NSMutableData is backed by kernel memory, the length and capacity are
        /// not mutable. Any changes to the length or capacity will cause an exception to be
        /// thrown.
        ///
        /// Parameter `capacity`: Size of the buffer to allocate
        ///
        /// Returns: NSMutableData of memory mapped to user space of an IOBufferMemoryDescriptor if successful,
        /// otherwise nil. An IOReturn error code will be reported on failure. The result is
        /// to be released by the caller
        #[unsafe(method(ioDataWithCapacity:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn ioDataWithCapacity_error(
            &self,
            capacity: NSUInteger,
        ) -> Result<Retained<NSMutableData>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl IOUSBHostObject {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
