//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-io-kit")]
use objc2_io_kit::*;

use crate::*;

extern_class!(
    /// The class for accessing USB-related services.
    ///
    /// ## Overview
    ///
    /// Use this class to create pipes, retrieve descriptors, send device requests, and enable power savings. Create an instance of the class with [`initWithIOService:options:queue:error:interestHandler:`](https://developer.apple.com/documentation/iousbhost/iousbhostobject/initwithioservice:options:queue:error:interesthandler:).
    ///
    ///
    /// The IOUSBHostObject representing a USB interface
    ///
    /// This class provides functionality to send control requests to the default control endpoint, as well as
    /// create IOUSBHostPipe objects to transfer data.
    #[unsafe(super(IOUSBHostObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "IOUSBHostObject")]
    pub struct IOUSBHostInterface;
);

#[cfg(feature = "IOUSBHostObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for IOUSBHostInterface {}
);

#[cfg(feature = "IOUSBHostObject")]
impl IOUSBHostInterface {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        /// Creates a matching dictionary for an IOUSBHostInterface to be passed into
        /// IOServiceGetMatchingService
        ///
        /// Parameter `vendorID`: NSNumber representation of device vendorID
        ///
        /// Parameter `productID`: NSNumber representation of device productID
        ///
        /// Parameter `bcdDevice`: NSNumber representation of device release number
        ///
        /// Parameter `interfaceNumber`: NSNumber representation of interface number
        ///
        /// Parameter `configurationValue`: NSNumber representation of the device's configurationValue
        ///
        /// Parameter `interfaceClass`: NSNumber representation of interface class
        ///
        /// Parameter `interfaceSubclass`: NSNumber representation of interface subclass
        ///
        /// Parameter `interfaceProtocol`: NSNumber representation of interface protocol
        ///
        /// Parameter `speed`: NSNumber representation of device speed
        ///
        /// Parameter `productIDArray`: NSArray of NSNumbers representing all productIDs interested in.
        /// If used do not specify the NSNumber productID field
        ///
        /// Returns: CFMutableDictionaryRef to be used with IOService matching methods. To be released
        /// by caller.
        ///
        /// # Safety
        ///
        /// - `product_id_array` generic should be of the correct type.
        /// - The returned generic must be of the correct type.
        /// - The returned generic must be of the correct type.
        #[unsafe(method(createMatchingDictionaryWithVendorID:productID:bcdDevice:interfaceNumber:configurationValue:interfaceClass:interfaceSubclass:interfaceProtocol:speed:productIDArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createMatchingDictionaryWithVendorID_productID_bcdDevice_interfaceNumber_configurationValue_interfaceClass_interfaceSubclass_interfaceProtocol_speed_productIDArray(
            vendor_id: Option<&NSNumber>,
            product_id: Option<&NSNumber>,
            bcd_device: Option<&NSNumber>,
            interface_number: Option<&NSNumber>,
            configuration_value: Option<&NSNumber>,
            interface_class: Option<&NSNumber>,
            interface_subclass: Option<&NSNumber>,
            interface_protocol: Option<&NSNumber>,
            speed: Option<&NSNumber>,
            product_id_array: Option<&NSArray>,
        ) -> Retained<CFMutableDictionary>;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "dispatch2",
            feature = "objc2-io-kit"
        ))]
        /// Initializes IOUSBHostInterface object along with user client
        ///
        /// See IOUSBHostObject for documentation.
        ///
        /// # Safety
        ///
        /// - `queue` possibly has additional threading requirements.
        /// - `interest_handler` must be a valid pointer or null.
        #[unsafe(method(initWithIOService:options:queue:error:interestHandler:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIOService_options_queue_error_interestHandler(
            this: Allocated<Self>,
            io_service: io_service_t,
            options: IOUSBHostObjectInitOptions,
            queue: Option<&DispatchQueue>,
            error: Option<&mut Option<Retained<NSError>>>,
            interest_handler: IOUSBHostInterestHandler,
        ) -> Option<Retained<Self>>;

        /// Retrieve the current idle suspend timeout.
        /// See
        ///
        /// ```text
        ///  setIdleTimeout
        /// ```
        ///
        ///
        /// Returns: The amount of time after all pipes are idle to wait before
        /// suspending the device,
        #[unsafe(method(idleTimeout))]
        #[unsafe(method_family = none)]
        pub unsafe fn idleTimeout(&self) -> NSTimeInterval;

        /// Sets the desired idle suspend timeout for the interface
        ///
        /// Once the interface is considered idle, it will defer electrical suspend of the
        /// device for the specified duration.
        ///
        /// Parameter `idleTimeout`: The amount of time after all pipes are idle to
        /// wait before suspending the device.
        ///
        /// Returns: YES on success. An IOReturn error code will be reported on failure.
        #[unsafe(method(setIdleTimeout:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdleTimeout_error(
            &self,
            idle_timeout: NSTimeInterval,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Retrieve the configuration descriptor associated with this interface
        ///
        /// Returns: IOUSBConfigurationDescriptor pointer
        #[unsafe(method(configurationDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn configurationDescriptor(&self) -> NonNull<IOUSBConfigurationDescriptor>;

        #[cfg(feature = "objc2-io-kit")]
        /// Retrieve the interface descriptor associated with this interface.
        ///
        /// Returns: IOUSBInterfaceDescriptor pointer
        #[unsafe(method(interfaceDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn interfaceDescriptor(&self) -> NonNull<IOUSBInterfaceDescriptor>;

        /// Select an alternate setting for this interface
        ///
        /// This method is used to select an alternate setting for the interface. All pending IO
        /// on the interface's pipes will be aborted, and the open pipes will be closed. The
        /// IOUSBHostPipe objects already created will no longer be valid. The new alternate
        /// setting will be selected via SET_INTERFACE control request (USB 2.0 9.4.10).
        ///
        /// Parameter `alternateSetting`: Alternate interface number to activate
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        #[unsafe(method(selectAlternateSetting:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn selectAlternateSetting_error(
            &self,
            alternate_setting: NSUInteger,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "IOUSBHostIOSource", feature = "IOUSBHostPipe"))]
        /// Return the pipe whose
        /// <code>
        /// bEndpointAddress
        /// </code>
        /// matches
        /// <code>
        /// address
        /// </code>
        ///
        /// This method will return the pipe whose
        /// <code>
        /// bEndpointAddress
        /// </code>
        /// matches
        /// <code>
        /// address
        /// </code>
        /// . If the pipe is returned successfully, it will maintain
        /// a reference to the IOUSBHostInterface.
        ///
        /// Parameter `address`: Endpoint address of the pipe
        ///
        /// Returns: Pointer to an IOUSBHostPipe object or nil. The IOUSBHostPipe is to be released by the caller.
        /// An IOReturn error code will be reported on failure.
        #[unsafe(method(copyPipeWithAddress:error:_))]
        #[unsafe(method_family = copy)]
        pub unsafe fn copyPipeWithAddress_error(
            &self,
            address: NSUInteger,
        ) -> Result<Retained<IOUSBHostPipe>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `IOUSBHostObject`.
#[cfg(feature = "IOUSBHostObject")]
impl IOUSBHostInterface {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "block2", feature = "dispatch2", feature = "objc2-io-kit"))]
        /// Initializes IOUSBHostObject object along with user client
        ///
        /// This method should be called from either IOUSBHostDevice or IOUSBHostInterface.
        /// If the io_service_t is not found nil will be returned. If an IOUSBHostDevice or
        /// IOUSBHostInterface user client is already created, nil will be returned.
        /// Upon creation, exclusive ownership of the IOService will be established. When done
        /// using the object destroy must be called on the object.
        ///
        /// Parameter `ioService`: io_service_t of the IOUSBHostDevice or IOUSBHostInterface
        /// the user client is for. The IOUSBHostObject will keep a reference to the io_service_t
        /// and release it after the IOUSBHostObject has been released.
        ///
        /// Parameter `queue`: A serial queue that all asynchronous io will be serviced. By
        /// default a serial queue will be created on behalf of the client. Setting
        /// a queue will create a dispatch source event handler for the target queue to service
        /// all underlying io.
        ///
        /// Parameter `interestHandler`: IOUSBHostInterestHandler a generalInterest IOService handler. This is
        /// to handle underlying service state changes such as termination. See
        /// IOServiceAddInterestNotification in IOKitLib for more details. All notifications will be serviced
        /// on an internal serial queue separate from the IO queue.
        ///
        /// Returns: An IOUSBHostDevice or IOUSBHostInterface. The object is to be released by the caller.
        /// An IOReturn error code will be reported on failure.
        ///
        /// # Safety
        ///
        /// - `queue` possibly has additional threading requirements.
        /// - `interest_handler` must be a valid pointer or null.
        #[unsafe(method(initWithIOService:queue:error:interestHandler:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIOService_queue_error_interestHandler(
            this: Allocated<Self>,
            io_service: io_service_t,
            queue: Option<&DispatchQueue>,
            error: Option<&mut Option<Retained<NSError>>>,
            interest_handler: IOUSBHostInterestHandler,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "IOUSBHostObject")]
impl IOUSBHostInterface {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
