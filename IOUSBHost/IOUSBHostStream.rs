//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhoststream?language=objc)
    #[unsafe(super(IOUSBHostIOSource, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "IOUSBHostIOSource")]
    pub struct IOUSBHostStream;
);

#[cfg(feature = "IOUSBHostIOSource")]
extern_conformance!(
    unsafe impl NSObjectProtocol for IOUSBHostStream {}
);

#[cfg(feature = "IOUSBHostIOSource")]
impl IOUSBHostStream {
    extern_methods!(
        #[cfg(feature = "IOUSBHostPipe")]
        /// Returns the IOUSBHostPipe this stream was created from
        ///
        /// Returns: IOUSBHostPipe pointer
        #[unsafe(method(hostPipe))]
        #[unsafe(method_family = none)]
        pub unsafe fn hostPipe(&self) -> Retained<IOUSBHostPipe>;

        /// Returns streamID associated with this IOUSBHostStream.
        ///
        /// Returns: streamID
        #[unsafe(method(streamID))]
        #[unsafe(method_family = none)]
        pub unsafe fn streamID(&self) -> NSUInteger;

        #[cfg(feature = "IOUSBHostDefinitions")]
        /// Abort pending I/O requests.
        ///
        /// A stream context must be set as non-active on the device via an out-of-band
        /// (class-defined) mechanism before this method is called (USB 3.1 8.12.1.4).
        /// A non-active stream will not be selected by the device to become the current
        /// stream on the endpoint.
        ///
        /// Parameter `option`: IOUSBHostAbortOption by default IOUSBHostAbortOptionSynchronous is used
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(abortWithOption:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn abortWithOption_error(
            &self,
            option: IOUSBHostAbortOption,
        ) -> Result<(), Retained<NSError>>;

        /// Abort pending I/O requests.
        ///
        /// A stream context must be set as non-active on the device via an out-of-band
        /// (class-defined) mechanism before this method is called (USB 3.1 8.12.1.4).
        /// A non-active stream will not be selected by the device to become the current
        /// stream on the endpoint.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        #[unsafe(method(abortWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn abortWithError(&self) -> Result<(), Retained<NSError>>;

        /// Send an IO request on the source
        ///
        /// This method will send a synchronous request on the IO source, and will not return
        /// until the request is complete. CompletionTimeouts are not applicable to streams.
        ///
        /// Parameter `data`: NSData* pointer containing the buffer to use for the transfer
        ///
        /// Parameter `bytesTransferred`: NSUInteger reference which will be updated with the bytes
        /// transferred during the request
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `bytes_transferred` must be a valid pointer or null.
        #[unsafe(method(sendIORequestWithData:bytesTransferred:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendIORequestWithData_bytesTransferred_error(
            &self,
            data: Option<&NSMutableData>,
            bytes_transferred: *mut NSUInteger,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "IOUSBHostDefinitions", feature = "block2"))]
        /// Enqueue an IO request on the source
        ///
        /// This method is used to issue an asynchronous I/O request on the IO source.
        /// CompletionTimeouts are not applicable to streams.
        ///
        /// Parameter `data`: pointer containing the buffer to use for the transfer
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure
        ///
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(enqueueIORequestWithData:error:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueIORequestWithData_error_completionHandler(
            &self,
            data: Option<&NSMutableData>,
            error: Option<&mut Option<Retained<NSError>>>,
            completion_handler: IOUSBHostCompletionHandler,
        ) -> bool;
    );
}

/// Methods declared on superclass `IOUSBHostIOSource`.
#[cfg(feature = "IOUSBHostIOSource")]
impl IOUSBHostStream {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "IOUSBHostIOSource")]
impl IOUSBHostStream {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
