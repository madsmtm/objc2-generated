//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The object representing the state of a user-mode USB host controller
    ///
    /// This class assists with tracking internal state transitions of a user-mode USB host controller, and parses IOUSBHostCIMessage command
    /// structures to update state and generate properly formatted command responses.
    ///
    /// IOUSBHostCIControllerStateMachine does not provide any concurrency protection, the client is responsible for necessary serialization.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostcicontrollerstatemachine?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct IOUSBHostCIControllerStateMachine;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for IOUSBHostCIControllerStateMachine {}
);

impl IOUSBHostCIControllerStateMachine {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "IOUSBHostControllerInterface")]
        /// Initializes an IOUSBHostCIControllerStateMachine object
        ///
        /// The IOUSBHostCIControllerStateMachine defaults to the IOUSBHostCIControllerStateOff state.
        ///
        /// Parameter `interface`: IOUSBHostControllerInterface which will be used to send command responses.
        ///
        /// Returns: IOUSBHostCIControllerStateMachine instance, to be released by the caller.
        #[unsafe(method(initWithInterface:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithInterface_error(
            this: Allocated<Self>,
            interface: &IOUSBHostControllerInterface,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Inspect an IOUSBHostCIMessage command
        ///
        /// The IOUSBHostCIMessage command is inspected to determine if it is handled by the state machine, and
        /// is appropriate for the current state.
        ///
        /// Parameter `command`: IOUSBHostCIMessage command structure received from the kernel driver.
        ///
        /// Returns: BOOL YES if the command is targeting a controller, and can be handled in the current state
        /// BOOL NO if the command does not target a controller, or cannot be handled in the current state
        ///
        /// # Safety
        ///
        /// `command` must be a valid pointer.
        #[unsafe(method(inspectCommand:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn inspectCommand_error(
            &self,
            command: NonNull<IOUSBHostCIMessage>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Advance the state machine and respond to an IOUSBHostCIMessage command
        ///
        /// If the command passes inspectCommand and the client indicates the command was processed successfully, the state machine is
        /// advanced, and a properly formatted command response message is sent to the kernel driver.  If the client indicates the command was
        /// not processed successfully, the state machine is not advanced but a properly formatted command response message is sent to the kernel
        /// driver.
        ///
        /// Parameter `command`: IOUSBHostCIMessage command structure received from the kernel driver.
        ///
        /// Parameter `status`: IOUSBHostCIMessageStatus reported by the user-mode USB host controller implementation for the command response.
        ///
        /// Returns: BOOL YES if the command response was sent to the kernel driver
        /// BOOL NO if the command response was not sent to the kernel driver
        ///
        /// # Safety
        ///
        /// `command` must be a valid pointer.
        #[unsafe(method(respondToCommand:status:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn respondToCommand_status_error(
            &self,
            command: NonNull<IOUSBHostCIMessage>,
            status: IOUSBHostCIMessageStatus,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Advance the state machine and respond to an IOUSBHostCIMessageTypeControllerFrameNumber command
        ///
        /// If the command passes inspectCommand and the client indicates the command was processed successfully, enqueueUpdatedFrame:timestamp:error
        /// is called with the supplied parameters, and a properly formatted command response message is sent to the kernel driver.  If the client
        /// indicates the command was not processed successfully, enqueueUpdatedFrame:timestamp:error is not called but a properly formatted
        /// command response message is sent to the kernel driver.
        ///
        /// Parameter `command`: IOUSBHostCIMessage command structure received from the kernel driver.  The Type field must be IOUSBHostCIMessageTypeControllerFrameNumber
        ///
        /// Parameter `status`: IOUSBHostCIMessageStatus reported by the user-mode USB host controller implementation for the command response.
        ///
        /// Parameter `frame`: uint64_t containing the number of 1ms frames that have elapsed since the controller began counting frames
        ///
        /// Parameter `timestamp`: uint64_t containing the mach_absolute_time() correlated to the beginning of the frameNumber
        ///
        /// Returns: BOOL YES if the command response was sent to the kernel driver
        /// BOOL NO if the command response was not sent to the kernel driver
        ///
        /// # Safety
        ///
        /// `command` must be a valid pointer.
        #[unsafe(method(respondToCommand:status:frame:timestamp:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn respondToCommand_status_frame_timestamp_error(
            &self,
            command: NonNull<IOUSBHostCIMessage>,
            status: IOUSBHostCIMessageStatus,
            frame: u64,
            timestamp: u64,
        ) -> Result<(), Retained<NSError>>;

        /// Enqueue frame and timestamp messages for delivery to the kernel driver
        ///
        /// If the controller interface is in the IOUSBHostCIControllerStateActive state, messages with the type IOUSBHostCIMessageTypeFrameNumberUpdate and
        /// IOUSBHostCIMessageTypeFrameTimestampUpdate will be generated using the provided inputs, and enqueued for delivery to the kernel driver.
        /// The frame and timestamp information provided effectively measure the duration of the controller's 1ms frame in terms of system time.  A 1% frame duration
        /// variation is permitted.  A larger frame duration variation will result in a IOUSBHostCIExceptionTypeFrameUpdateError.
        ///
        /// Parameter `frame`: uint64_t containing the number of 1ms frames that have elapsed since the controller began counting frames
        ///
        /// Parameter `timestamp`: uint64_t containing the mach_absolute_time() correlated to the beginning of the frameNumber
        ///
        /// Returns: BOOL YES if the messages were enqueued for delivery to the kernel.
        /// BOOL NO if the messages were not enqueued for delivery to the kernel.
        #[unsafe(method(enqueueUpdatedFrame:timestamp:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueUpdatedFrame_timestamp_error(
            &self,
            frame: u64,
            timestamp: u64,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        #[unsafe(method(controllerState))]
        #[unsafe(method_family = none)]
        pub unsafe fn controllerState(&self) -> IOUSBHostCIControllerState;

        #[cfg(feature = "IOUSBHostControllerInterface")]
        #[unsafe(method(controllerInterface))]
        #[unsafe(method_family = none)]
        pub unsafe fn controllerInterface(&self) -> Retained<IOUSBHostControllerInterface>;
    );
}

/// Methods declared on superclass `NSObject`.
impl IOUSBHostCIControllerStateMachine {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
