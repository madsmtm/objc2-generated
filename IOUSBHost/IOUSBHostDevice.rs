//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-io-kit")]
use objc2_io_kit::*;

use crate::*;

extern_class!(
    /// The class that claims and configures devices, retrieves descriptors, and sends device requests.
    ///
    /// ## Overview
    ///
    /// This class enables management of the device state, including sending control requests to the default endpoint 0, configuring the device, and resetting the device. The interest handler also allows monitoring of the device state. The client creates the class and initializes it with [`initWithIOService:options:queue:error:interestHandler:`](https://developer.apple.com/documentation/iousbhost/iousbhostobject/initwithioservice:options:queue:error:interesthandler:).
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  To prevent other drivers from changing the state of your device, maintain an [`IOUSBHostDevice`](https://developer.apple.com/documentation/kernel/iousbhostdevice) object until you no longer need control over the device.
    ///
    ///
    ///
    /// </div>
    ///
    /// The IOUSBHostObject representing a USB device
    ///
    /// This class provides functionality to send control requests to the default control endpoint
    #[unsafe(super(IOUSBHostObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "IOUSBHostObject")]
    pub struct IOUSBHostDevice;
);

#[cfg(feature = "IOUSBHostObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for IOUSBHostDevice {}
);

#[cfg(feature = "IOUSBHostObject")]
impl IOUSBHostDevice {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        /// Creates a matching dictionary for an IOUSBHostDevice to be passed into
        /// IOServiceGetMatchingService
        ///
        /// Parameter `vendorID`: NSNumber representation of device vendorID
        ///
        /// Parameter `productID`: NSNumber representation of device productID
        ///
        /// Parameter `bcdDevice`: NSNumber representation of device release number
        ///
        /// Parameter `deviceClass`: NSNumber representation of device class
        ///
        /// Parameter `deviceSubclass`: NSNumber representation of device subclass
        ///
        /// Parameter `deviceProtocol`: NSNumber representation of device protocol
        ///
        /// Parameter `speed`: NSNumber representation of device speed
        ///
        /// Parameter `productIDArray`: NSArray of NSNumbers representing all productIDs interested in.
        /// If used do not specify the NSNumber productID field
        ///
        /// Returns: CFMutableDictionaryRef to be used with IOService matching methods. To be released by
        /// caller.
        ///
        /// # Safety
        ///
        /// - `product_id_array` generic should be of the correct type.
        /// - The returned generic must be of the correct type.
        /// - The returned generic must be of the correct type.
        #[unsafe(method(createMatchingDictionaryWithVendorID:productID:bcdDevice:deviceClass:deviceSubclass:deviceProtocol:speed:productIDArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createMatchingDictionaryWithVendorID_productID_bcdDevice_deviceClass_deviceSubclass_deviceProtocol_speed_productIDArray(
            vendor_id: Option<&NSNumber>,
            product_id: Option<&NSNumber>,
            bcd_device: Option<&NSNumber>,
            device_class: Option<&NSNumber>,
            device_subclass: Option<&NSNumber>,
            device_protocol: Option<&NSNumber>,
            speed: Option<&NSNumber>,
            product_id_array: Option<&NSArray>,
        ) -> Retained<CFMutableDictionary>;

        /// Select a new configuration for the device
        ///
        /// This method will select a new configuration for a device. If the device was
        /// previously configured all child interfaces will be terminated prior to setting
        /// the new configuration.  This method will send the SET_CONFIGURATION control request
        /// (USB 2.0 9.4.7) to the device. The interfaces will be registered for matching by
        /// default. After the completion of this call, the interfaces are not guaranteed
        /// to be immediately available.
        ///
        /// Parameter `value`: Configuration value to select
        ///
        /// Parameter `matchInterfaces`: If YES, any interfaces within the new configuration will be
        /// registered for matching. By default this is set to YES.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        #[unsafe(method(configureWithValue:matchInterfaces:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn configureWithValue_matchInterfaces_error(
            &self,
            value: NSUInteger,
            match_interfaces: bool,
        ) -> Result<(), Retained<NSError>>;

        /// Select a new configuration for the device
        ///
        /// This method will select a new configuration for a device.  If the device was
        /// previously configured all child interfaces will be terminated prior to setting
        /// the new configuration.  This method will send the SET_CONFIGURATION control request
        /// (USB 2.0 9.4.7) to the device. The interfaces will be registered for matching by
        /// default. After the completion of this call, the interfaces are not guaranteed
        /// to be immediately available.
        ///
        /// Parameter `value`: Configuration value to select
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        #[unsafe(method(configureWithValue:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn configureWithValue_error(
            &self,
            value: NSUInteger,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-io-kit")]
        /// Return the currently selected configuration descriptor
        ///
        /// This method uses descriptorWithType to return the configuration descriptor currently
        /// selected after a successful setConfiguration call
        ///
        /// Returns: Pointer to the configuration descriptor if found, or nil if the device is not
        /// configured
        #[unsafe(method(configurationDescriptor))]
        #[unsafe(method_family = none)]
        pub unsafe fn configurationDescriptor(&self) -> *const IOUSBConfigurationDescriptor;

        /// Terminate the device and attempt to reenumerate it
        ///
        /// This function will reset and attempt to reenumerate the USB device.
        /// The current IOUSBHostDevice object and all of its children will be terminated.
        /// A new IOUSBHostDevice IOService object will be created and registered if the reset
        /// is successful and the previous object has finished terminating. The framework IOUSBHostDevice
        /// will no longer have a valid connection with IOService userclient after the call returns
        /// successfully. A new framework client will need to be created to use the re-enumerated device.
        ///
        /// Returns: YES on success, an IOReturn error code will be reported on failure.
        #[unsafe(method(resetWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn resetWithError(&self) -> Result<(), Retained<NSError>>;
    );
}

/// Methods declared on superclass `IOUSBHostObject`.
#[cfg(feature = "IOUSBHostObject")]
impl IOUSBHostDevice {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(
            feature = "IOUSBHostDefinitions",
            feature = "block2",
            feature = "dispatch2",
            feature = "objc2-io-kit"
        ))]
        /// Initializes IOUSBHostObject object along with user client
        ///
        /// If the io_service_t is not found nil will be returned. If an IOUSBHostDevice or
        /// IOUSBHostInterface user client is already created, nil will be returned.
        /// Upon creation, exclusive ownership of the IOService will be established. When done
        /// using the object destroy must be called on the object.
        ///
        /// Parameter `ioService`: io_service_t of the IOUSBHostDevice or IOUSBHostInterface
        /// the user client is for. The IOUSBHostObject will keep a reference to the io_service_t
        /// and release it after the IOUSBHostObject has been released.
        ///
        /// Parameter `options`: IOUSBHostObjectInitOptions. Default value is IOUSBHostObjectInitOptionsNone
        ///
        /// Parameter `queue`: A serial queue that all asynchronous io will be serviced. By
        /// default a serial queue will be created on behalf of the client. Setting
        /// a queue will create a dispatch source event handler for the target queue to service
        /// all underlying io.
        ///
        /// Parameter `interestHandler`: IOUSBHostInterestHandler a generalInterest IOService handler. This is
        /// to handle underlying service state changes such as termination. See
        /// IOServiceAddInterestNotification in IOKitLib for more details. All notifications will be serviced
        /// on an internal serial queue separate from the IO queue.
        ///
        /// Returns: An IOUSBHostDevice or IOUSBHostInterface. The object is to be released by the caller.
        /// An IOReturn error code will be reported on failure.
        ///
        /// # Safety
        ///
        /// - `queue` possibly has additional threading requirements.
        /// - `interest_handler` must be a valid pointer or null.
        #[unsafe(method(initWithIOService:options:queue:error:interestHandler:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIOService_options_queue_error_interestHandler(
            this: Allocated<Self>,
            io_service: io_service_t,
            options: IOUSBHostObjectInitOptions,
            queue: Option<&DispatchQueue>,
            error: Option<&mut Option<Retained<NSError>>>,
            interest_handler: IOUSBHostInterestHandler,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "block2", feature = "dispatch2", feature = "objc2-io-kit"))]
        /// Initializes IOUSBHostObject object along with user client
        ///
        /// This method should be called from either IOUSBHostDevice or IOUSBHostInterface.
        /// If the io_service_t is not found nil will be returned. If an IOUSBHostDevice or
        /// IOUSBHostInterface user client is already created, nil will be returned.
        /// Upon creation, exclusive ownership of the IOService will be established. When done
        /// using the object destroy must be called on the object.
        ///
        /// Parameter `ioService`: io_service_t of the IOUSBHostDevice or IOUSBHostInterface
        /// the user client is for. The IOUSBHostObject will keep a reference to the io_service_t
        /// and release it after the IOUSBHostObject has been released.
        ///
        /// Parameter `queue`: A serial queue that all asynchronous io will be serviced. By
        /// default a serial queue will be created on behalf of the client. Setting
        /// a queue will create a dispatch source event handler for the target queue to service
        /// all underlying io.
        ///
        /// Parameter `interestHandler`: IOUSBHostInterestHandler a generalInterest IOService handler. This is
        /// to handle underlying service state changes such as termination. See
        /// IOServiceAddInterestNotification in IOKitLib for more details. All notifications will be serviced
        /// on an internal serial queue separate from the IO queue.
        ///
        /// Returns: An IOUSBHostDevice or IOUSBHostInterface. The object is to be released by the caller.
        /// An IOReturn error code will be reported on failure.
        ///
        /// # Safety
        ///
        /// - `queue` possibly has additional threading requirements.
        /// - `interest_handler` must be a valid pointer or null.
        #[unsafe(method(initWithIOService:queue:error:interestHandler:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIOService_queue_error_interestHandler(
            this: Allocated<Self>,
            io_service: io_service_t,
            queue: Option<&DispatchQueue>,
            error: Option<&mut Option<Retained<NSError>>>,
            interest_handler: IOUSBHostInterestHandler,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "IOUSBHostObject")]
impl IOUSBHostDevice {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
