//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-io-kit")]
use objc2_io_kit::*;

use crate::*;

/// Client-supplied block to handle IOUSBHostCIMessage structures representing controller, port, device, or endpoint commands
///
/// The kernel driver controls the state of the client's USB services via commands that target the controller, port, device, or endpoint.  The command response
/// must be received by the kernel driver before a new command will be sent.
///
/// Commands with a type targeting the controller (IOUSBHostCIMessageTypeController*) should be processed by the IOUSBHostCIControllerStateMachine
/// available via the IOUSBHostControllerInterface's controllerStateMachine property.
///
/// Commands with a type targeting the root ports (IOUSBHostCIMessageTypePort*) should be processed by the IOUSBHostCIPortStateMachines
/// available via the getPortStateMachineForCommand interface.
///
/// Commands with a type targeting a device (IOUSBHostCIMessageTypeDevice*) should be processed by a client-created IOUSBHostCIDeviceStateMachine.
///
/// Commands with a type targeting an endpoint (IOUSBHostCIMessageTypeEndpoint*) should be processed by a client-created IOUSBHostCIEndpointStateMachine.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostcontrollerinterfacecommandhandler?language=objc)
#[cfg(all(
    feature = "IOUSBHostControllerInterfaceDefinitions",
    feature = "block2"
))]
pub type IOUSBHostControllerInterfaceCommandHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<IOUSBHostControllerInterface>, IOUSBHostCIMessage)>;

/// Client-supplied block to handle IOUSBHostCIDoorbell messages
///
/// The kernel driver sends IOUSBHostCIDoorbell messages to notify the client that transfer structures for specific endpoints have been updated.  Doorbell messages
/// should be processed by a client-created IOUSBHostCIEndpointStateMachine.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostcontrollerinterfacedoorbellhandler?language=objc)
#[cfg(all(
    feature = "IOUSBHostControllerInterfaceDefinitions",
    feature = "block2"
))]
pub type IOUSBHostControllerInterfaceDoorbellHandler = *mut block2::DynBlock<
    dyn Fn(NonNull<IOUSBHostControllerInterface>, NonNull<IOUSBHostCIDoorbell>, u32),
>;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostcontrollerinterface?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct IOUSBHostControllerInterface;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for IOUSBHostControllerInterface {}
);

impl IOUSBHostControllerInterface {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(
            feature = "IOUSBHostControllerInterfaceDefinitions",
            feature = "block2",
            feature = "dispatch2",
            feature = "objc2-io-kit"
        ))]
        /// Initializes IOUSBHostControllerInterface object along with a user client
        ///
        /// If the user client cannot be created, nil will be returned.
        /// When done using the object, destroy must be called on the object.
        ///
        /// Parameter `capabilities`: NSData containing an array of IOUSBHostCIMessage structures.  The first must have an IOUSBHostCIMessageControlType of IOUSBHostCIMessageTypeControllerCapabilities,
        /// followed by at least one message with an IOUSBHostCIMessageControlType of IOUSBHostCIMessageTypePortCapabilities.
        ///
        /// Parameter `queue`: A serial queue to service asynchronous operations. If nil, a serial queue will be created on behalf of the client.
        ///
        /// Parameter `interruptRateHz`: NSUInteger representing the rate in Hz at which interrupts will be delivered to the kernel driver.
        /// A value ot 0 will send all interrupts to the kernel immediately.
        ///
        /// Parameter `commandHandler`: IOUSBHostControllerInterfaceCommandHandler used to process IOUSBHostCIMessage messages sent by the kernel driver.
        ///
        /// Parameter `doorbellHandler`: IOUSBHostControllerInterfaceDoorbellHandler used to process IOUSBHostCIDoorbell values sent by the kernel driver.
        ///
        /// Parameter `interestHandler`: IOServiceInterestCallback used to process service state changes such as termination. See IOServiceAddInterestNotification
        /// in IOKitLib for more details. All notifications will be serviced on an internal serial queue separate from command and doorbell handlers.
        ///
        /// Returns: An IOUSBHostControllerInterface. The object is to be released by the caller.
        ///
        /// # Safety
        ///
        /// - `command_handler` must be a valid pointer.
        /// - `doorbell_handler` must be a valid pointer.
        /// - `interest_handler` must be implemented correctly.
        #[unsafe(method(initWithCapabilities:queue:interruptRateHz:error:commandHandler:doorbellHandler:interestHandler:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCapabilities_queue_interruptRateHz_error_commandHandler_doorbellHandler_interestHandler(
            this: Allocated<Self>,
            capabilities: &NSData,
            queue: Option<&DispatchQueue>,
            interrupt_rate_hz: NSUInteger,
            error: Option<&mut Option<Retained<NSError>>>,
            command_handler: IOUSBHostControllerInterfaceCommandHandler,
            doorbell_handler: IOUSBHostControllerInterfaceDoorbellHandler,
            interest_handler: IOServiceInterestCallback,
        ) -> Option<Retained<Self>>;

        /// Removes underlying allocations of the IOUSBHostControllerInterface object along with user client
        ///
        /// When the IOUSBHostControllerInterface is no longer needed, destroy must be called. This will destroy
        /// the connection with the user client and de-register interest on the service. If the object
        /// is freed, destroy will be called automatically. Calling destroy multiple times has no effect.
        #[unsafe(method(destroy))]
        #[unsafe(method_family = none)]
        pub unsafe fn destroy(&self);

        #[cfg(feature = "dispatch2")]
        /// The dispatch queue for asynchronous operations.
        #[unsafe(method(queue))]
        #[unsafe(method_family = none)]
        pub unsafe fn queue(&self) -> Retained<DispatchQueue>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Enqueue an interrupt for delivery to the kernel service
        ///
        /// This method enqueues one interrupt message for delivery to the kernel service.  interruptRateHz is used to determine when the interrupt message is
        /// delivered to the kernel service.
        ///
        /// Parameter `interrupt`: An IOUSBHostCIMessage structure representing an interrupt message
        ///
        /// # Safety
        ///
        /// `interrupt` must be a valid pointer.
        #[unsafe(method(enqueueInterrupt:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueInterrupt_error(
            &self,
            interrupt: NonNull<IOUSBHostCIMessage>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Enqueue an interrupt for delivery to the kernel service
        ///
        /// This method enqueues one interrupt message for delivery to the kernel service.
        ///
        /// Parameter `interrupt`: An IOUSBHostCIMessage structure representing an interrupt message
        ///
        /// Parameter `expedite`: Bool NO to use interruptRateHz to determine when the interrupt message is delivered to the kernel service. Bool YES if interruptRateHz
        /// should be ignored, sending the message to the kernel driver at the next opportunity while maintaining in-order delivery of all interrupt messages.
        ///
        /// # Safety
        ///
        /// `interrupt` must be a valid pointer.
        #[unsafe(method(enqueueInterrupt:expedite:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueInterrupt_expedite_error(
            &self,
            interrupt: NonNull<IOUSBHostCIMessage>,
            expedite: bool,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Enqueue interrupts for delivery to the kernel service
        ///
        /// This method enqueues one or more interrupt messages for delivery to the kernel service.   interruptRateHz is used to determine when the interrupt message is
        /// delivered to the kernel service.
        ///
        /// Parameter `interrupts`: An IOUSBHostCIMessage structure representing one or more interrupt messages
        ///
        /// Parameter `count`: The number of interrupt messages represented by the interrupts parameter
        ///
        /// # Safety
        ///
        /// `interrupts` must be a valid pointer.
        #[unsafe(method(enqueueInterrupts:count:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueInterrupts_count_error(
            &self,
            interrupts: NonNull<IOUSBHostCIMessage>,
            count: NSUInteger,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Enqueue interrupts for delivery to the kernel service
        ///
        /// This method enqueues one or more interrupt messages for delivery to the kernel service.   interruptRateHz is used to determine when the interrupt message is
        /// delivered to the kernel service.
        ///
        /// Parameter `interrupts`: An IOUSBHostCIMessage structure representing one or more interrupt messages
        ///
        /// Parameter `count`: The number of interrupt messages represented by the interrupts parameter
        ///
        /// Parameter `expedite`: Bool NO to use interruptRateHz to determine when the interrupt message is delivered to the kernel service. Bool YES if interruptRateHz
        /// should be ignored, sending the message to the kernel driver at the next opportunity while maintaining in-order delivery of all interrupt messages.
        ///
        /// # Safety
        ///
        /// `interrupts` must be a valid pointer.
        #[unsafe(method(enqueueInterrupts:count:expedite:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueInterrupts_count_expedite_error(
            &self,
            interrupts: NonNull<IOUSBHostCIMessage>,
            count: NSUInteger,
            expedite: bool,
        ) -> Result<(), Retained<NSError>>;

        /// The interrupt moderation rate for sending interrupt messages to the kernel driver
        ///
        /// interruptRateHz will cause submitted interrupt messages to be batched together and submitted to the kernel
        /// at the specified rate.  A value ot 0 will deliver all interrupts to the kernel driver as soon as possible.
        #[unsafe(method(interruptRateHz))]
        #[unsafe(method_family = none)]
        pub unsafe fn interruptRateHz(&self) -> NSUInteger;

        /// Setter for [`interruptRateHz`][Self::interruptRateHz].
        #[unsafe(method(setInterruptRateHz:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInterruptRateHz(&self, interrupt_rate_hz: NSUInteger);

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// # Safety
        ///
        /// `message` must be a valid pointer.
        #[unsafe(method(descriptionForMessage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn descriptionForMessage(
            &self,
            message: NonNull<IOUSBHostCIMessage>,
        ) -> Retained<NSString>;

        #[cfg(feature = "IOUSBHostCIControllerStateMachine")]
        #[unsafe(method(controllerStateMachine))]
        #[unsafe(method_family = none)]
        pub unsafe fn controllerStateMachine(&self) -> Retained<IOUSBHostCIControllerStateMachine>;

        #[cfg(all(
            feature = "IOUSBHostCIPortStateMachine",
            feature = "IOUSBHostControllerInterfaceDefinitions"
        ))]
        /// # Safety
        ///
        /// `command` must be a valid pointer.
        #[unsafe(method(getPortStateMachineForCommand:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn getPortStateMachineForCommand_error(
            &self,
            command: NonNull<IOUSBHostCIMessage>,
        ) -> Result<Retained<IOUSBHostCIPortStateMachine>, Retained<NSError>>;

        #[cfg(feature = "IOUSBHostCIPortStateMachine")]
        #[unsafe(method(getPortStateMachineForPort:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn getPortStateMachineForPort_error(
            &self,
            port: NSUInteger,
        ) -> Result<Retained<IOUSBHostCIPortStateMachine>, Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// The capabilities structure passed in during initialization
        ///
        /// The capabilities passed into the initializer can be retrieved for reference.
        #[unsafe(method(capabilities))]
        #[unsafe(method_family = none)]
        pub unsafe fn capabilities(&self) -> NonNull<IOUSBHostCIMessage>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Retrieve a port capabilities structure passed in during initialization
        #[unsafe(method(capabilitiesForPort:))]
        #[unsafe(method_family = none)]
        pub unsafe fn capabilitiesForPort(&self, port: NSUInteger) -> NonNull<IOUSBHostCIMessage>;

        /// A UUID used to identify the host controller interface in this process and the kernel
        #[unsafe(method(uuid))]
        #[unsafe(method_family = none)]
        pub unsafe fn uuid(&self) -> Retained<NSUUID>;
    );
}

/// Methods declared on superclass `NSObject`.
impl IOUSBHostControllerInterface {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
