//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The object representing the state of a user-mode USB host controller root port
    ///
    /// This class assists with tracking internal state transitions of a user-mode USB host controller root port, and parses IOUSBHostCIMessage command
    /// structures to update state and generate properly formatted command responses.
    ///
    /// IOUSBHostCIPortStateMachine does not provide any concurrency protection, the client is responsible for necessary serialization.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iousbhost/iousbhostciportstatemachine?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct IOUSBHostCIPortStateMachine;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for IOUSBHostCIPortStateMachine {}
);

impl IOUSBHostCIPortStateMachine {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "IOUSBHostControllerInterface")]
        /// Initializes an IOUSBHostCIPortStateMachine object
        ///
        /// The IOUSBHostCIPortStateMachine defaults to the IOUSBHostCIPortStateOff state.
        ///
        /// Parameter `interface`: IOUSBHostControllerInterface which will be used to send command responses.
        ///
        /// Parameter `portNumber`: NSUInteger for the root port number tracked by this instance
        ///
        /// Returns: IOUSBHostCIPortStateMachine instance, to be released by the caller.
        #[unsafe(method(initWithInterface:portNumber:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithInterface_portNumber_error(
            this: Allocated<Self>,
            interface: &IOUSBHostControllerInterface,
            port_number: NSUInteger,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Inspect an IOUSBHostCIMessage command
        ///
        /// The IOUSBHostCIMessage command is inspected to determine if it is handled by the state machine, and
        /// is appropriate for the current state.
        ///
        /// Parameter `command`: IOUSBHostCIMessage command structure received from the kernel driver.
        ///
        /// Returns: BOOL YES if the command is targeting a controller, and can be handled in the current state
        /// BOOL NO if the command does not target a controller, or cannot be handled in the current state
        ///
        /// # Safety
        ///
        /// `command` must be a valid pointer.
        #[unsafe(method(inspectCommand:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn inspectCommand_error(
            &self,
            command: NonNull<IOUSBHostCIMessage>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        /// Advance the state machine and respond to an IOUSBHostCIMessage command
        ///
        /// If the command passes inspectCommand and the client indicates the command was processed successfully, the state machine is
        /// advanced, and a properly formatted command response message is sent to the kernel driver.  If the client indicates the command was
        /// not processed successfully, the state machine is not advanced but a properly formatted command response message is sent to the kernel
        /// driver.
        ///
        /// Parameter `command`: IOUSBHostCIMessage command structure received from the kernel driver.
        ///
        /// Parameter `status`: IOUSBHostCIMessageStatus reported by the user-mode USB host controller implementation for the command response.
        ///
        /// Returns: BOOL YES if the command response was sent to the kernel driver
        /// BOOL NO if the command response was not sent to the kernel driver
        ///
        /// # Safety
        ///
        /// `command` must be a valid pointer.
        #[unsafe(method(respondToCommand:status:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn respondToCommand_status_error(
            &self,
            command: NonNull<IOUSBHostCIMessage>,
            status: IOUSBHostCIMessageStatus,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(portNumber))]
        #[unsafe(method_family = none)]
        pub unsafe fn portNumber(&self) -> NSUInteger;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        #[unsafe(method(portState))]
        #[unsafe(method_family = none)]
        pub unsafe fn portState(&self) -> IOUSBHostCIPortState;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        #[unsafe(method(portStatus))]
        #[unsafe(method_family = none)]
        pub unsafe fn portStatus(&self) -> IOUSBHostCIPortStatus;

        #[cfg(feature = "IOUSBHostControllerInterface")]
        #[unsafe(method(controllerInterface))]
        #[unsafe(method_family = none)]
        pub unsafe fn controllerInterface(&self) -> Retained<IOUSBHostControllerInterface>;

        /// Set the powered state of the port
        ///
        /// Before a port can be used, it must be powered on via a IOUSBHostCIMessageTypePortPowerOn command.  As part of successfully processing this command
        /// the powered property must be set to YES.  Similarly, successful processing of the IOUSBHostCIMessageTypePortPowerOff command must set the powered
        /// property to NO.
        #[unsafe(method(powered))]
        #[unsafe(method_family = none)]
        pub unsafe fn powered(&self) -> bool;

        /// Setter for [`powered`][Self::powered].
        #[unsafe(method(setPowered:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPowered(&self, powered: bool);

        /// Set the connection state of the port
        ///
        /// The connected property cannot be set for an unpowered port, and will read back as NO, just at IOUSBHostCIPortStatusConnected in the port status will always
        /// read as 0.  For a powered port, writing to the connected property will set IOUSBHostCIPortStatusConnected to match the provided value, and if the
        /// new value is different from the previous value an IOUSBHostCIMessageTypePortEvent message will be sent to the kernel with IOUSBHostCIPortStatusConnectChange
        /// set.
        #[unsafe(method(connected))]
        #[unsafe(method_family = none)]
        pub unsafe fn connected(&self) -> bool;

        /// Setter for [`connected`][Self::connected].
        #[unsafe(method(setConnected:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConnected(&self, connected: bool);

        /// Set the overcurrent state of the port
        ///
        /// The overcurrent property cannot be set for an unpowered port, and will read back as NO, just as IOUSBHostCIPortStatusOvercurrent in the port status will always
        /// read as 0.  For a powered port, writing to the overcurrent property will set IOUSBHostCIPortStatusOvercurrent to match the provided value, and if the
        /// new value is different from the previous value an IOUSBHostCIMessageTypePortEvent message will be sent to the kernel with IOUSBHostCIPortStatusOvercurrentChange
        /// set.
        #[unsafe(method(overcurrent))]
        #[unsafe(method_family = none)]
        pub unsafe fn overcurrent(&self) -> bool;

        /// Setter for [`overcurrent`][Self::overcurrent].
        #[unsafe(method(setOvercurrent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOvercurrent(&self, overcurrent: bool);

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        #[unsafe(method(updateLinkState:speed:inhibitLinkStateChange:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateLinkState_speed_inhibitLinkStateChange_error(
            &self,
            link_state: IOUSBHostCILinkState,
            speed: IOUSBHostCIDeviceSpeed,
            inhibit_link_state_change: bool,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        #[unsafe(method(linkState))]
        #[unsafe(method_family = none)]
        pub unsafe fn linkState(&self) -> IOUSBHostCILinkState;

        #[cfg(feature = "IOUSBHostControllerInterfaceDefinitions")]
        #[unsafe(method(speed))]
        #[unsafe(method_family = none)]
        pub unsafe fn speed(&self) -> IOUSBHostCIDeviceSpeed;
    );
}

/// Methods declared on superclass `NSObject`.
impl IOUSBHostCIPortStateMachine {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
