//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
use objc2_ui_kit::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/browserenginekit/bedirectionaltextrange?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct BEDirectionalTextRange {
    pub offset: NSInteger,
    pub length: NSInteger,
}

unsafe impl Encode for BEDirectionalTextRange {
    const ENCODING: Encoding =
        Encoding::Struct("?", &[<NSInteger>::ENCODING, <NSInteger>::ENCODING]);
}

unsafe impl RefEncode for BEDirectionalTextRange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/browserenginekit/betextreplacementoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct BETextReplacementOptions(pub NSUInteger);
bitflags::bitflags! {
    impl BETextReplacementOptions: NSUInteger {
        #[doc(alias = "BETextReplacementOptionsNone")]
        const None = 0;
        #[doc(alias = "BETextReplacementOptionsAddUnderline")]
        const AddUnderline = 1<<0;
    }
}

unsafe impl Encode for BETextReplacementOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for BETextReplacementOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/browserenginekit/bekeymodifierflags?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct BEKeyModifierFlags(pub NSInteger);
impl BEKeyModifierFlags {
    #[doc(alias = "BEKeyModifierFlagNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "BEKeyModifierFlagShift")]
    pub const Shift: Self = Self(1);
    #[doc(alias = "BEKeyModifierFlagCapsLock")]
    pub const CapsLock: Self = Self(2);
}

unsafe impl Encode for BEKeyModifierFlags {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for BEKeyModifierFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/browserenginekit/berespondereditactions?language=objc)
    pub unsafe trait BEResponderEditActions: UIResponderStandardEditActions {
        /// Shares the selected content.
        /// See corresponding share methods in BETextInteraction.
        #[optional]
        #[unsafe(method(share:))]
        #[unsafe(method_family = none)]
        unsafe fn share(&self, sender: Option<&AnyObject>);

        /// Adds a text replacement shortcut to the keyboard dictionary.
        /// See corresponding shortcut methods in BETextInteraction.
        #[optional]
        #[unsafe(method(addShortcut:))]
        #[unsafe(method_family = none)]
        unsafe fn addShortcut(&self, sender: Option<&AnyObject>);

        /// Presents a dictionary definition for the selected content.
        /// See corresponding dictionary methods in BETextInteraction.
        #[optional]
        #[unsafe(method(lookup:))]
        #[unsafe(method_family = none)]
        unsafe fn lookup(&self, sender: Option<&AnyObject>);

        /// Performs a find for the selected content
        /// See find related methods in UIResponderStandardEditActions
        #[optional]
        #[unsafe(method(findSelected:))]
        #[unsafe(method_family = none)]
        unsafe fn findSelected(&self, sender: Option<&AnyObject>);

        /// Shows the replacements for the selected content.
        /// See corresponding replacement methods in BETextInteraction.
        #[optional]
        #[unsafe(method(promptForReplace:))]
        #[unsafe(method_family = none)]
        unsafe fn promptForReplace(&self, sender: Option<&AnyObject>);

        /// Inserts the selected replacement for the selected content.
        /// See corresponding replacement methods in BETextInputDelegate
        #[optional]
        #[unsafe(method(replace:))]
        #[unsafe(method_family = none)]
        unsafe fn replace(&self, sender: Option<&AnyObject>);

        /// Presents a translation view for the selected content.
        /// See corresponding translation methods in BETextInteraction.
        #[optional]
        #[unsafe(method(translate:))]
        #[unsafe(method_family = none)]
        unsafe fn translate(&self, sender: Option<&AnyObject>);

        /// Converts the selected content between traditional and simplified Chinese
        /// See corresponding transliteration methods in BETextInteraction.
        #[optional]
        #[unsafe(method(transliterateChinese:))]
        #[unsafe(method_family = none)]
        unsafe fn transliterateChinese(&self, sender: Option<&AnyObject>);
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/browserenginekit/betextselectiondirectionnavigation?language=objc)
    pub unsafe trait BETextSelectionDirectionNavigation {
        /// Moves the cursor in the specified directions, such as in response to an arrow key press.
        #[unsafe(method(moveInLayoutDirection:))]
        #[unsafe(method_family = none)]
        unsafe fn moveInLayoutDirection(&self, direction: UITextLayoutDirection);

        /// Extends text selection in the specified directions, such as in response to an arrow key press while shift is held.
        #[unsafe(method(extendInLayoutDirection:))]
        #[unsafe(method_family = none)]
        unsafe fn extendInLayoutDirection(&self, direction: UITextLayoutDirection);

        /// Moves the cursor in the specified directions by granularity, in response to different key combinations:
        ///
        /// Option + left/right = word
        /// Option + up/down = paragraph
        /// Command + left/right = line
        /// Command + up/down = document
        #[unsafe(method(moveInStorageDirection:byGranularity:))]
        #[unsafe(method_family = none)]
        unsafe fn moveInStorageDirection_byGranularity(
            &self,
            direction: UITextStorageDirection,
            granularity: UITextGranularity,
        );

        /// Moves the selection in the specified directions by granularity, in response to different key combinations:
        ///
        /// word = shift + option + left/right
        /// paragraph = shift + option + up/down
        /// line = shift + command + left/right
        /// document = shift + command + up/down
        #[unsafe(method(extendInStorageDirection:byGranularity:))]
        #[unsafe(method_family = none)]
        unsafe fn extendInStorageDirection_byGranularity(
            &self,
            direction: UITextStorageDirection,
            granularity: UITextGranularity,
        );
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/browserenginekit/beextendedtextinputtraits?language=objc)
    pub unsafe trait BEExtendedTextInputTraits: UITextInputTraits {
        /// Represents whether the active web input field is a single line document
        #[optional]
        #[unsafe(method(isSingleLineDocument))]
        #[unsafe(method_family = none)]
        unsafe fn isSingleLineDocument(&self) -> bool;

        /// Disables the learning of new words and corrections and prevents their addition into the keyboard lexicon
        #[optional]
        #[unsafe(method(isTypingAdaptationEnabled))]
        #[unsafe(method_family = none)]
        unsafe fn isTypingAdaptationEnabled(&self) -> bool;

        /// Customizes the color of the text cursor at the insertion point
        #[optional]
        #[unsafe(method(insertionPointColor))]
        #[unsafe(method_family = none)]
        unsafe fn insertionPointColor(&self) -> Option<Retained<UIColor>>;

        /// Customizes the color of the selection handles
        #[optional]
        #[unsafe(method(selectionHandleColor))]
        #[unsafe(method_family = none)]
        unsafe fn selectionHandleColor(&self) -> Option<Retained<UIColor>>;

        /// Customizes the color of the selection highlight rect
        #[optional]
        #[unsafe(method(selectionHighlightColor))]
        #[unsafe(method_family = none)]
        unsafe fn selectionHighlightColor(&self) -> Option<Retained<UIColor>>;
    }
);

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/browserenginekit/betextinput?language=objc)
    pub unsafe trait BETextInput:
        UIKeyInput + BETextSelectionDirectionNavigation + BEResponderEditActions
    {
        #[cfg(feature = "BETextInputDelegate")]
        /// A system-provided input delegate is assigned when the system is interested in input changes.
        #[unsafe(method(asyncInputDelegate))]
        #[unsafe(method_family = none)]
        unsafe fn asyncInputDelegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn BETextInputDelegate>>>;

        #[cfg(feature = "BETextInputDelegate")]
        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`asyncInputDelegate`][Self::asyncInputDelegate].
        #[unsafe(method(setAsyncInputDelegate:))]
        #[unsafe(method_family = none)]
        unsafe fn setAsyncInputDelegate(
            &self,
            async_input_delegate: Option<&ProtocolObject<dyn BETextInputDelegate>>,
        );

        /// Returns whether text related actions, such those included in UIResponderStandardEditActions, can be handled
        #[unsafe(method(canPerformAction:withSender:))]
        #[unsafe(method_family = none)]
        unsafe fn canPerformAction_withSender(
            &self,
            action: Sel,
            sender: Option<&AnyObject>,
        ) -> bool;

        /// Reflects the ability to modify text
        #[unsafe(method(isEditable))]
        #[unsafe(method_family = none)]
        unsafe fn isEditable(&self) -> bool;

        #[cfg(all(feature = "BEKeyEntry", feature = "block2"))]
        /// Delegates the handling for each stage of a key event (key down, press, up) and allows the BETextInput object to indicate whether it should prevent default system behaviors.
        #[unsafe(method(handleKeyEntry:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn handleKeyEntry_withCompletionHandler(
            &self,
            entry: &BEKeyEntry,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<BEKeyEntry>, Bool)>,
        );

        /// Indicates a transition in shift state
        #[unsafe(method(shiftKeyStateChangedFromState:toState:))]
        #[unsafe(method_family = none)]
        unsafe fn shiftKeyStateChangedFromState_toState(
            &self,
            old_state: BEKeyModifierFlags,
            new_state: BEKeyModifierFlags,
        );

        /// Returns the text in the specified range.
        #[unsafe(method(textInRange:))]
        #[unsafe(method_family = none)]
        unsafe fn textInRange(&self, range: &UITextRange) -> Option<Retained<NSString>>;

        /// Returns the number of UTF-16 characters between one text position and another text position.
        #[unsafe(method(offsetFromPosition:toPosition:))]
        #[unsafe(method_family = none)]
        unsafe fn offsetFromPosition_toPosition(
            &self,
            from: &UITextPosition,
            to_position: &UITextPosition,
        ) -> NSInteger;

        /// Sets the base writing direction for a specified range of text in a document.
        #[unsafe(method(setBaseWritingDirection:forRange:))]
        #[unsafe(method_family = none)]
        unsafe fn setBaseWritingDirection_forRange(
            &self,
            writing_direction: NSWritingDirection,
            range: &UITextRange,
        );

        /// Deletes text by the specified direction and granularity.  Current supported combinations include:
        ///
        /// character backward  = delete
        /// character forward = delete-forward
        /// word backward = option + delete
        /// word forward = option + delete-forward
        /// line end = cmd + delete
        /// line start = cmd + delete-forward
        /// paragraph  end = ctrl + K
        /// paragraph start = ctrl + fn + K
        ///
        /// (On Apple keyboards, the delete-forward key is a combination of fn + delete)
        #[unsafe(method(deleteInDirection:toGranularity:))]
        #[unsafe(method_family = none)]
        unsafe fn deleteInDirection_toGranularity(
            &self,
            direction: UITextStorageDirection,
            granularity: UITextGranularity,
        );

        /// Transposes the characters on either side of the caret in response to the key command, ctrl + T
        #[unsafe(method(transposeCharactersAroundSelection))]
        #[unsafe(method_family = none)]
        unsafe fn transposeCharactersAroundSelection(&self);

        #[cfg(feature = "block2")]
        /// Replace the specified text preceding the current selection.
        ///
        /// Completion handler should be invoked with the rects representing the replacementText.  If the replaceText
        /// could not be completed succesfully, such as when the originalText no longer matches the current text, then
        /// the completion handler should be invoked with an empty array.
        #[unsafe(method(replaceText:withText:options:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn replaceText_withText_options_completionHandler(
            &self,
            original_text: &NSString,
            replacement_text: &NSString,
            options: BETextReplacementOptions,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<UITextSelectionRect>>)>,
        );

        #[cfg(all(feature = "BETextDocumentContext", feature = "block2"))]
        /// Invoked by the system to gather context around the current selection.  Clients should generally include the setence
        /// that contains the current selection and include the previous sentence if the current selection is at a boundary.
        #[unsafe(method(requestTextContextForAutocorrectionWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn requestTextContextForAutocorrectionWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<BETextDocumentContext>)>,
        );

        #[cfg(feature = "block2")]
        /// Invoked by the system to gather context for the presentation of various text related UI's.
        /// Completion handler should be invoked with the `UITextSelectionRect`s for the substring nearest to the caret
        /// that matches the given `input`
        #[unsafe(method(requestTextRectsForString:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn requestTextRectsForString_withCompletionHandler(
            &self,
            input: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<UITextSelectionRect>>)>,
        );

        /// Controls whether the edit menu is allowed to be presented or should be suppressed.
        #[unsafe(method(automaticallyPresentEditMenu))]
        #[unsafe(method_family = none)]
        unsafe fn automaticallyPresentEditMenu(&self) -> bool;

        #[cfg(feature = "block2")]
        /// Invoked by the system to gather context, including the client's preference for how the edit menu should be positioned
        /// relative to the selected text.
        #[unsafe(method(requestPreferredArrowDirectionForEditMenuWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn requestPreferredArrowDirectionForEditMenuWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(UIEditMenuArrowDirection)>,
        );

        /// Invoked by the system when it is about to present an edit menu with an animator.
        #[unsafe(method(systemWillPresentEditMenuWithAnimator:))]
        #[unsafe(method_family = none)]
        unsafe fn systemWillPresentEditMenuWithAnimator(
            &self,
            animator: &ProtocolObject<dyn UIEditMenuInteractionAnimating>,
        );

        /// Invoked by the system when it is about to dismiss an edit menu with an animator.
        #[unsafe(method(systemWillDismissEditMenuWithAnimator:))]
        #[unsafe(method_family = none)]
        unsafe fn systemWillDismissEditMenuWithAnimator(
            &self,
            animator: &ProtocolObject<dyn UIEditMenuInteractionAnimating>,
        );

        /// Object from which the BEExtendedTextInputTraits will be gathered.
        #[unsafe(method(extendedTextInputTraits))]
        #[unsafe(method_family = none)]
        unsafe fn extendedTextInputTraits(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn BEExtendedTextInputTraits>>>;

        /// Returns a dictionary containing NSAttributedString keys represeting appearance customizations.
        ///
        /// For example, text styling information influence the appearance of a correction rect.
        #[unsafe(method(textStylingAtPosition:inDirection:))]
        #[unsafe(method_family = none)]
        unsafe fn textStylingAtPosition_inDirection(
            &self,
            position: &UITextPosition,
            direction: UITextStorageDirection,
        ) -> Option<Retained<NSDictionary<NSAttributedStringKey, AnyObject>>>;

        /// Returns whether replacement should be allowed for an editable element.
        ///
        /// For example, replacement shouldn't be allowed in password fields or when the selected text
        /// is only consists of whitespace.
        #[unsafe(method(isReplaceAllowed))]
        #[unsafe(method_family = none)]
        unsafe fn isReplaceAllowed(&self) -> bool;

        /// Replaces the specified `text` with `replacementText`
        ///
        /// 1. If there is a nonzero length current selection, then replace text with replacementText.
        /// 2. If there is zero length current selection, then replace the matching word before the selection
        /// 3. If the zero length selection is at the start of the element, then replace the matching word after the selection
        #[unsafe(method(replaceSelectedText:withText:))]
        #[unsafe(method_family = none)]
        unsafe fn replaceSelectedText_withText(&self, text: &NSString, replacement_text: &NSString);

        #[cfg(all(feature = "BETextSelectionTypes", feature = "objc2-core-foundation"))]
        /// Indicates the `point` the text interaction gesture is tracking has changed
        ///
        /// Indicate to the system the change was handled by invoking:
        /// -[BETextInteraction selectionChangedWithGestureAtPoint:gesture:state:flags:]
        #[unsafe(method(updateCurrentSelectionTo:fromGesture:inState:))]
        #[unsafe(method_family = none)]
        unsafe fn updateCurrentSelectionTo_fromGesture_inState(
            &self,
            point: CGPoint,
            gesture_type: BEGestureType,
            state: UIGestureRecognizerState,
        );

        #[cfg(all(feature = "BETextSelectionTypes", feature = "objc2-core-foundation"))]
        /// Indicates the selection should change to contain the text between the
        /// `from` and `to` points.
        ///
        /// For example, see the keyboard's trackpad selection gesture explained in
        /// "Turn the onscreen keyboard into a trackpad" guide on support.apple.com
        #[unsafe(method(setSelectionFromPoint:toPoint:gesture:state:))]
        #[unsafe(method_family = none)]
        unsafe fn setSelectionFromPoint_toPoint_gesture_state(
            &self,
            from: CGPoint,
            to: CGPoint,
            gesture: BEGestureType,
            state: UIGestureRecognizerState,
        );

        #[cfg(all(feature = "BETextSelectionTypes", feature = "objc2-core-foundation"))]
        /// Adjusts the selection's start or end boundary specified by `boundaryIsStart` to the `point`
        ///
        /// For example, the selection's boundary would be adjusted when the user moves the selection handles
        ///
        /// Indicate to the system that the change was handled by invoking:
        /// -[BETextInteraction selectionBoundaryAdjustedToPoint:touchPhase:flags:]
        #[unsafe(method(adjustSelectionBoundaryToPoint:touchPhase:baseIsStart:flags:))]
        #[unsafe(method_family = none)]
        unsafe fn adjustSelectionBoundaryToPoint_touchPhase_baseIsStart_flags(
            &self,
            point: CGPoint,
            touch: BESelectionTouchPhase,
            boundary_is_start: bool,
            flags: BESelectionFlags,
        );

        #[cfg(all(feature = "BETextSelectionTypes", feature = "objc2-core-foundation"))]
        /// Returns whether a gesture with the given `gestureType` should begin for the given `point`
        #[unsafe(method(textInteractionGesture:shouldBeginAtPoint:))]
        #[unsafe(method_family = none)]
        unsafe fn textInteractionGesture_shouldBeginAtPoint(
            &self,
            gesture_type: BEGestureType,
            point: CGPoint,
        ) -> bool;

        /// If different than the text input view, one can return a container view here for selection views
        /// that draw _below_ text. Includes the selection highlight view. If this is unimplemented or nil
        /// is returned, views are to be installed onto the text input view.
        #[optional]
        #[unsafe(method(selectionContainerViewBelowText))]
        #[unsafe(method_family = none)]
        unsafe fn selectionContainerViewBelowText(&self) -> Option<Retained<UIView>>;

        /// If different than the text input view, one can return a container view here for selection views
        /// that draw _above_ text. Includes selection range adjustment handles. If this is unimplemented
        /// or nil is returned, views are to be installed onto the text input view.
        #[optional]
        #[unsafe(method(selectionContainerViewAboveText))]
        #[unsafe(method_family = none)]
        unsafe fn selectionContainerViewAboveText(&self) -> Option<Retained<UIView>>;

        /// String representing the selected text.
        #[unsafe(method(selectedText))]
        #[unsafe(method_family = none)]
        unsafe fn selectedText(&self) -> Option<Retained<NSString>>;

        /// Range representing the selected text.
        ///
        /// Text may have a selection, either zero-length (a caret) or ranged.
        /// Editing operations are always performed on the text from this selection.  nil corresponds to no selection.
        #[unsafe(method(selectedTextRange))]
        #[unsafe(method_family = none)]
        unsafe fn selectedTextRange(&self) -> Option<Retained<UITextRange>>;

        /// Setter for [`selectedTextRange`][Self::selectedTextRange].
        #[unsafe(method(setSelectedTextRange:))]
        #[unsafe(method_family = none)]
        unsafe fn setSelectedTextRange(&self, selected_text_range: Option<&UITextRange>);

        /// Represents whether the current selection is at the beginning of the document
        #[unsafe(method(isSelectionAtDocumentStart))]
        #[unsafe(method_family = none)]
        unsafe fn isSelectionAtDocumentStart(&self) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        /// Returns a rectangle to draw the caret at a specified insertion point.
        #[unsafe(method(caretRectForPosition:))]
        #[unsafe(method_family = none)]
        unsafe fn caretRectForPosition(&self, position: &UITextPosition) -> CGRect;

        /// Returns an array of selection rects corresponding to the range of text.
        #[unsafe(method(selectionRectsForRange:))]
        #[unsafe(method_family = none)]
        unsafe fn selectionRectsForRange(
            &self,
            range: &UITextRange,
        ) -> Retained<NSArray<UITextSelectionRect>>;

        /// Selects a word with autocorrect replacement suggestions when it is tapped
        #[unsafe(method(selectWordForReplacement))]
        #[unsafe(method_family = none)]
        unsafe fn selectWordForReplacement(&self);

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        /// Adjusts the selection from current text position to include text at the given `point`.
        ///
        /// For example, while holding shift, click a point in a text document and the current selection should adjust to include
        /// all the text up to that point.
        #[unsafe(method(updateSelectionWithExtentPoint:boundary:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn updateSelectionWithExtentPoint_boundary_completionHandler(
            &self,
            point: CGPoint,
            granularity: UITextGranularity,
            completion_handler: &block2::DynBlock<dyn Fn(Bool)>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        /// Updates the selection to text contained within the specified `granularity` at the given `point`
        #[unsafe(method(selectTextInGranularity:atPoint:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn selectTextInGranularity_atPoint_completionHandler(
            &self,
            granularity: UITextGranularity,
            point: CGPoint,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        /// Sets the selection caret to the given point
        #[unsafe(method(selectPositionAtPoint:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn selectPositionAtPoint_completionHandler(
            &self,
            point: CGPoint,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(
            feature = "BETextDocumentContext",
            feature = "BETextDocumentRequest",
            feature = "block2",
            feature = "objc2-core-foundation"
        ))]
        /// Sets the selection caret to the given point.  Also includes a convenience document context request.
        #[unsafe(method(selectPositionAtPoint:withContextRequest:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn selectPositionAtPoint_withContextRequest_completionHandler(
            &self,
            point: CGPoint,
            request: &BETextDocumentRequest,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<BETextDocumentContext>)>,
        );

        #[cfg(feature = "block2")]
        /// Adjusts the selection by the moving the selected range by the given `range`, in character granularity units.
        ///
        /// The start of the current selection is moved by `range.offset` characters, and the length of the selection
        /// is modified by `range.length` characters. For instance, if the current selection is the word "world" in
        /// "Hello world" and the `range` is `{ -6, -2 }`, the selected text after adjustment will be "Hel".
        #[unsafe(method(adjustSelectionByRange:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn adjustSelectionByRange_completionHandler(
            &self,
            range: BEDirectionalTextRange,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        /// Adjusts the current selection by `offset` in character granularity units
        #[unsafe(method(moveByOffset:))]
        #[unsafe(method_family = none)]
        unsafe fn moveByOffset(&self, offset: NSInteger);

        #[cfg(feature = "block2")]
        /// Moves the caret to relative to the current position in the `direction` to the given `granularity`.
        /// The `direction` is "forward" or "backward" in accordance with the directionality of the language.
        ///
        /// This method is invoked only when -[BETextInput textInteractionGesture:shouldBeginAtPoint:] returns YES.
        #[unsafe(method(moveSelectionAtBoundary:inStorageDirection:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn moveSelectionAtBoundary_inStorageDirection_completionHandler(
            &self,
            granularity: UITextGranularity,
            direction: UITextStorageDirection,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        /// Indicates the edit menu is being shown at the given location in the text input view's
        /// coordinate space.
        ///
        /// The completion handler takes a BOOL indicating whether or not the menu
        /// should be shown, a string representing the text context around the updated selection range
        /// (generally encompassing the paragraph that contains the selection range) as well as the
        /// range of the updated selection, relative to the paragraph context.
        #[unsafe(method(selectTextForEditMenuWithLocationInView:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn selectTextForEditMenuWithLocationInView_completionHandler(
            &self,
            location_in_view: CGPoint,
            completion_handler: &block2::DynBlock<dyn Fn(Bool, *mut NSString, NSRange)>,
        );

        /// String for the text that has been marked as part of an active input session
        #[unsafe(method(markedText))]
        #[unsafe(method_family = none)]
        unsafe fn markedText(&self) -> Option<Retained<NSString>>;

        /// Attributed string for the text that has been marked as part of an active input session
        #[unsafe(method(attributedMarkedText))]
        #[unsafe(method_family = none)]
        unsafe fn attributedMarkedText(&self) -> Option<Retained<NSAttributedString>>;

        /// Range representing the position of the markedText.
        ///
        /// If text can be selected, it can be marked. Marked text represents provisionally
        /// inserted text that has yet to be confirmed by the user.  It requires unique visual
        /// treatment in its display.  If there is any marked text, the selection, whether a
        /// caret or an extended range, always resides within.
        ///
        /// Setting marked text either replaces the existing marked text or, if none is present,
        /// inserts it from the current selection.
        ///
        /// Return nil if no marked text
        #[unsafe(method(markedTextRange))]
        #[unsafe(method_family = none)]
        unsafe fn markedTextRange(&self) -> Option<Retained<UITextRange>>;

        /// Indicates whether there any text is currently marked as part of an active input session
        #[unsafe(method(hasMarkedText))]
        #[unsafe(method_family = none)]
        unsafe fn hasMarkedText(&self) -> bool;

        /// Inserts the provided text and marks it to indicate that it is part of an active input session.
        #[unsafe(method(setMarkedText:selectedRange:))]
        #[unsafe(method_family = none)]
        unsafe fn setMarkedText_selectedRange(
            &self,
            marked_text: Option<&NSString>,
            selected_range: NSRange,
        );

        /// Inserts the provided styled text and marks it to indicate that it is part of an active input session.
        #[unsafe(method(setAttributedMarkedText:selectedRange:))]
        #[unsafe(method_family = none)]
        unsafe fn setAttributedMarkedText_selectedRange(
            &self,
            marked_text: Option<&NSAttributedString>,
            selected_range: NSRange,
        );

        /// Unmarks the currently marked text
        #[unsafe(method(unmarkText))]
        #[unsafe(method_family = none)]
        unsafe fn unmarkText(&self);

        #[cfg(feature = "objc2-core-foundation")]
        /// Returns whether a point should be considered "near" the marked text.
        /// Used to determine whether text interaction gestures near marked text should begin.
        ///
        /// For example, text interaction gestures may considered "near" if they are within 66 points.
        #[unsafe(method(isPointNearMarkedText:))]
        #[unsafe(method_family = none)]
        unsafe fn isPointNearMarkedText(&self, point: CGPoint) -> bool;

        #[cfg(all(
            feature = "BETextDocumentContext",
            feature = "BETextDocumentRequest",
            feature = "block2"
        ))]
        /// Gathers context about the current document for the system
        #[unsafe(method(requestDocumentContext:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn requestDocumentContext_completionHandler(
            &self,
            request: &BETextDocumentRequest,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<BETextDocumentContext>)>,
        );

        /// Indicates the system is about to insert the final dictation result.
        #[unsafe(method(willInsertFinalDictationResult))]
        #[unsafe(method_family = none)]
        unsafe fn willInsertFinalDictationResult(&self);

        /// Inserts/replaces text for a dictation.
        #[unsafe(method(replaceDictatedText:withText:))]
        #[unsafe(method_family = none)]
        unsafe fn replaceDictatedText_withText(&self, old_text: &NSString, new_text: &NSString);

        /// Indicates system has inserted the final dictation result
        #[unsafe(method(didInsertFinalDictationResult))]
        #[unsafe(method_family = none)]
        unsafe fn didInsertFinalDictationResult(&self);

        #[cfg(feature = "BETextAlternatives")]
        /// Returns the text alternatives that are available to the text input object.
        #[unsafe(method(alternativesForSelectedText))]
        #[unsafe(method_family = none)]
        unsafe fn alternativesForSelectedText(
            &self,
        ) -> Option<Retained<NSArray<BETextAlternatives>>>;

        #[cfg(feature = "BETextAlternatives")]
        /// Adds text alternatives to the text input object for the current selection
        #[unsafe(method(addTextAlternatives:))]
        #[unsafe(method_family = none)]
        unsafe fn addTextAlternatives(&self, alternatives: &BETextAlternatives);

        #[cfg(feature = "BETextAlternatives")]
        /// Inserts the given `text` or one of it's alternative texts available on `alternatives`
        #[unsafe(method(insertTextAlternatives:))]
        #[unsafe(method_family = none)]
        unsafe fn insertTextAlternatives(&self, alternatives: &BETextAlternatives);

        /// Removes text alternatives from the text input object for the current selection
        #[optional]
        #[unsafe(method(removeTextAlternatives))]
        #[unsafe(method_family = none)]
        unsafe fn removeTextAlternatives(&self);

        #[cfg(all(feature = "block2", feature = "objc2-core-foundation"))]
        /// Inserts a placeholder object to reserve visual space during text input.
        /// If `size.height` is less than or equal to zero, then the placeholder is inline and line height.
        /// If `size.height` is greather than zero, then the placeholder is treated as a paragraph of height `size.height`.
        #[unsafe(method(insertTextPlaceholderWithSize:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn insertTextPlaceholderWithSize_completionHandler(
            &self,
            size: CGSize,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<UITextPlaceholder>)>,
        );

        #[cfg(feature = "block2")]
        /// Removes a placeholder object from the text input view.
        #[unsafe(method(removeTextPlaceholder:willInsertText:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn removeTextPlaceholder_willInsertText_completionHandler(
            &self,
            placeholder: &UITextPlaceholder,
            will_insert_text: bool,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(feature = "BETextSuggestion")]
        /// Inserts a `textSuggestion` in response to a user suggestion selection
        #[unsafe(method(insertTextSuggestion:))]
        #[unsafe(method_family = none)]
        unsafe fn insertTextSuggestion(&self, text_suggestion: &BETextSuggestion);

        /// An affiliated view that provides a coordinate system for all geometric values in this protocol.
        #[unsafe(method(textInputView))]
        #[unsafe(method_family = none)]
        unsafe fn textInputView(&self) -> Retained<UIView>;

        #[cfg(feature = "objc2-core-foundation")]
        /// Returns a rect representing the bounds of the first line of marked text, if marked text is set.
        ///
        /// Otherwise, this returns a rect representing the bounds of the last word at or before the insertion point.
        #[unsafe(method(textFirstRect))]
        #[unsafe(method_family = none)]
        unsafe fn textFirstRect(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Returns a rect representing the bounds of the last line of marked text, if marked text is set.
        ///
        /// Otherwise, this returns a rect representing the bounds of the last word at or before the insertion point.
        /// This may have the same value of `textFirstRect`, but can differ in cases such as a word that spans two lines.
        #[unsafe(method(textLastRect))]
        #[unsafe(method_family = none)]
        unsafe fn textLastRect(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Rect used to place UI (such as selection handles) in a location that isn't obscurred by app UI.
        ///
        /// Must return a rect in `textInputView`'s coordinate space.
        #[unsafe(method(unobscuredContentRect))]
        #[unsafe(method_family = none)]
        unsafe fn unobscuredContentRect(&self) -> CGRect;

        /// View representing the web content that is agnostic of zoom state.
        /// Used to draw zoom agnostic system UI elements, such as the selection handles
        #[unsafe(method(unscaledView))]
        #[unsafe(method_family = none)]
        unsafe fn unscaledView(&self) -> Retained<UIView>;

        #[cfg(feature = "objc2-core-foundation")]
        /// Rect representing the bounds of editable elements, used to ensure and UI don't overflow outside them
        #[unsafe(method(selectionClipRect))]
        #[unsafe(method_family = none)]
        unsafe fn selectionClipRect(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Indicates autoscrolling has been triggered by a text interaction gesture.
        ///
        /// Called repeatedly during range adjustment gestures, or when placing the text cursor.
        ///
        /// The given point is in the coordinate space of the `textInputView`.
        #[unsafe(method(autoscrollToPoint:))]
        #[unsafe(method_family = none)]
        unsafe fn autoscrollToPoint(&self, point: CGPoint);

        /// Indicates autoscrolling is complete.
        ///
        /// There will be no more calls into`autoscrollToPoint` until a text interaction gesture starts autoscrolling.
        #[unsafe(method(cancelAutoscroll))]
        #[unsafe(method_family = none)]
        unsafe fn cancelAutoscroll(&self);

        /// Called when the user has requested the keyboard to dismiss itself.
        #[optional]
        #[unsafe(method(keyboardWillDismiss))]
        #[unsafe(method_family = none)]
        unsafe fn keyboardWillDismiss(&self);
    }
);
