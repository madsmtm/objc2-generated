//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_ui_kit::*;

use crate::*;

extern_class!(
    /// An object that represents a running GPU extension process.
    ///
    /// The system guarantees that the extension process has launched by the time the initializer methods return.
    /// If the extension process exits, the system calls ``interruptionHandler``. There can only be one extension process per
    /// host browser. The first time this type is initialized, a  process will be launched. If a extension process is all ready
    /// running, the returned object will represent the already running process.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/browserenginekit/berenderingprocess?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct BERenderingProcess;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for BERenderingProcess {}
);

impl BERenderingProcess {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// Asynchronously finds an existing extension process or launches one.
        ///
        /// This initializer finds an existing extension rendering process. If itâ€™s unable to find an
        /// existing process, it launches a new extension process.
        ///
        /// - Parameters:
        /// - `interruptionHandler` : A block that is called if the extension process terminates.
        /// - `completion` : A block called with a new ``BERenderingProcess`` when the extension process has
        /// launched or with an error.
        #[unsafe(method(renderingProcessWithInterruptionHandler:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn renderingProcessWithInterruptionHandler_completion(
            interruption_handler: &block2::DynBlock<dyn Fn()>,
            completion: &block2::DynBlock<dyn Fn(*mut BERenderingProcess, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Asynchronously launches a rendering extension process.
        ///
        /// This initializer launches a new rendering extension process with the provided bundle identifier.
        ///
        /// - Parameters:
        /// - `bundleID` : The bundle identifier of the rendering extension process to launch.
        /// - `interruptionHandler` : A block that is called if the extension process terminates.
        /// - `completion` : A block called with a new ``BERenderingProcess`` when the extension process has
        /// launched or with an error.
        #[unsafe(method(renderingProcessWithBundleID:interruptionHandler:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn renderingProcessWithBundleID_interruptionHandler_completion(
            bundle_id: &NSString,
            interruption_handler: &block2::DynBlock<dyn Fn()>,
            completion: &block2::DynBlock<dyn Fn(*mut BERenderingProcess, *mut NSError)>,
        );

        /// Stops the extension process.
        ///
        /// When you call this method, you tell the system your app no longer needs this extension process.
        /// If this is the last connection from the host process to the extension process, the system terminates
        /// the extension process.
        #[unsafe(method(invalidate))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidate(&self);

        /// attach the created interaction to a view to express that the content of that view is directly related to the working of this process.
        /// therefore, if the view is considered visible by the system then this process must also be considered to be visible.
        /// do not attempt to set an interaction on multiple views as interactions track their views - instead create a new interaction for each view that you want to propogate visibility to this process.
        #[unsafe(method(createVisibilityPropagationInteraction))]
        #[unsafe(method_family = none)]
        pub unsafe fn createVisibilityPropagationInteraction(
            &self,
            mtm: MainThreadMarker,
        ) -> Retained<ProtocolObject<dyn UIInteraction>>;
    );
}

/// BEExtensionProcessConformance.
impl BERenderingProcess {
    extern_methods!();
}

#[cfg(feature = "BEExtensionProcess")]
extern_conformance!(
    unsafe impl BEExtensionProcess for BERenderingProcess {}
);
