//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An object that represents a running network extension process.
    ///
    /// The system guarantees that the extension process has launched by the time the initializer methods return.
    /// If the extension process exits, the system calls ``interruptionHandler``. There can only be one extension process per
    /// host browser. The first time this type is initialized, a  process will be launched. If a extension process is all ready
    /// running, the returned object will represent the already running process.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/browserenginekit/benetworkingprocess?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct BENetworkingProcess;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for BENetworkingProcess {}
);

impl BENetworkingProcess {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// Asynchronously finds an existing network extension process or launches a one.
        ///
        /// This initializer finds an existing networking extension process. If itâ€™s unable to find an
        /// existing process, it launches a new extension process.
        ///
        /// - Parameters:
        /// - `interruptionHandler` : A block that is called if the extension process terminates.
        /// - `completion` : A block called with a new ``BENetworkingProcess`` when the extension process has
        /// launched or with an error.
        #[unsafe(method(networkProcessWithInterruptionHandler:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn networkProcessWithInterruptionHandler_completion(
            interruption_handler: &block2::DynBlock<dyn Fn()>,
            completion: &block2::DynBlock<dyn Fn(*mut BENetworkingProcess, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Asynchronously launches a network extension process.
        ///
        /// This initializer launches a new network extension process with the provided bundle identifier.
        ///
        /// - Parameters:
        /// - `bundleID` : The bundle identifier of the network extension process to launch.
        /// - `interruptionHandler` : A block that is called if the extension process terminates.
        /// - `completion` : A block called with a new ``BENetworkingProcess`` when the extension process has
        /// launched or with an error.
        #[unsafe(method(networkProcessWithBundleID:interruptionHandler:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn networkProcessWithBundleID_interruptionHandler_completion(
            bundle_id: &NSString,
            interruption_handler: &block2::DynBlock<dyn Fn()>,
            completion: &block2::DynBlock<dyn Fn(*mut BENetworkingProcess, *mut NSError)>,
        );

        /// Stops the extension process.
        ///
        /// When you call this method, you tell the system your app no longer needs this extension process.
        /// The system will terminate the extension process.
        #[unsafe(method(invalidate))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidate(&self);
    );
}

/// BEExtensionProcessConformance.
impl BENetworkingProcess {
    extern_methods!();
}

#[cfg(feature = "BEExtensionProcess")]
extern_conformance!(
    unsafe impl BEExtensionProcess for BENetworkingProcess {}
);
