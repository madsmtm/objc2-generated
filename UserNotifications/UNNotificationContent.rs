//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// A protocol the system uses to provide context relevant to user notifications.
    ///
    /// ## Overview
    ///
    /// The system allows only objects in the Apple SDK that conform to `UNNotificationContentProviding`. The system ignores objects outside of the Apple SDK that your app conforms to `UNNotificationContentProviding`.
    ///
    ///
    pub unsafe trait UNNotificationContentProviding: NSObjectProtocol {}
);

/// Constants that indicate the importance and delivery timing of a notification.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct UNNotificationInterruptionLevel(pub NSUInteger);
impl UNNotificationInterruptionLevel {
    /// The system adds the notification to the notification list without lighting up the screen or playing a sound.
    #[doc(alias = "UNNotificationInterruptionLevelPassive")]
    pub const Passive: Self = Self(0);
    /// The system presents the notification immediately, lights up the screen, and can play a sound.
    ///
    /// ## Discussion
    ///
    /// This is the default interruption level. Active notifications won’t break through system notification controls.
    ///
    ///
    #[doc(alias = "UNNotificationInterruptionLevelActive")]
    pub const Active: Self = Self(1);
    /// The system presents the notification immediately, lights up the screen, can play a sound, and breaks through system notification controls.
    ///
    /// ## Discussion
    ///
    /// Time Sensitive notifications are similar to active notifications, but can break through system controls such as Notification Summary and Focus. The user can turn off the ability for time sensitive notification interruptions.
    ///
    ///
    #[doc(alias = "UNNotificationInterruptionLevelTimeSensitive")]
    pub const TimeSensitive: Self = Self(2);
    /// The system presents the notification immediately, lights up the screen, and bypasses the mute switch to play a sound.
    ///
    /// ## Discussion
    ///
    /// This interruption level requires an approved entitlement. The system always presents this notification, even when Do Not Disturb is active. If your app doesn’t assign a sound to this notification, the system uses the default critical alert sound.
    ///
    ///
    #[doc(alias = "UNNotificationInterruptionLevelCritical")]
    pub const Critical: Self = Self(3);
}

unsafe impl Encode for UNNotificationInterruptionLevel {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for UNNotificationInterruptionLevel {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The uneditable content of a notification.
    ///
    /// ## Overview
    ///
    /// A [`UNNotificationContent`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent) object contains the data associated with a notification. When your app receives a notification, the associated [`UNNotificationRequest`](https://developer.apple.com/documentation/usernotifications/unnotificationrequest) object contains an object of this type with the content that your app received. Use the content object to get the details of the notification, including the type of notification that the system delivered, any custom data you stored in the [`userInfo`](https://developer.apple.com/documentation/usernotifications/unnotificationcontent/userinfo) dictionary before scheduling the notification, and any attachments.
    ///
    /// Don’t create instances of this class directly. For remote notifications, the system derives the contents of this object from the JSON payload that your server sends to the APNS server. For local notifications, create a [`UNMutableNotificationContent`](https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent) object, and configure the contents of that object instead.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UNNotificationContent;
);

extern_conformance!(
    unsafe impl NSCoding for UNNotificationContent {}
);

extern_conformance!(
    unsafe impl NSCopying for UNNotificationContent {}
);

unsafe impl CopyingHelper for UNNotificationContent {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSMutableCopying for UNNotificationContent {}
);

unsafe impl MutableCopyingHelper for UNNotificationContent {
    type Result = UNMutableNotificationContent;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UNNotificationContent {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for UNNotificationContent {}
);

impl UNNotificationContent {
    extern_methods!(
        #[cfg(feature = "UNNotificationAttachment")]
        #[unsafe(method(attachments))]
        #[unsafe(method_family = none)]
        pub fn attachments(&self) -> Retained<NSArray<UNNotificationAttachment>>;

        #[unsafe(method(badge))]
        #[unsafe(method_family = none)]
        pub fn badge(&self) -> Option<Retained<NSNumber>>;

        #[unsafe(method(body))]
        #[unsafe(method_family = none)]
        pub fn body(&self) -> Retained<NSString>;

        #[unsafe(method(categoryIdentifier))]
        #[unsafe(method_family = none)]
        pub fn categoryIdentifier(&self) -> Retained<NSString>;

        #[unsafe(method(launchImageName))]
        #[unsafe(method_family = none)]
        pub fn launchImageName(&self) -> Retained<NSString>;

        #[cfg(feature = "UNNotificationSound")]
        #[unsafe(method(sound))]
        #[unsafe(method_family = none)]
        pub fn sound(&self) -> Option<Retained<UNNotificationSound>>;

        #[unsafe(method(subtitle))]
        #[unsafe(method_family = none)]
        pub fn subtitle(&self) -> Retained<NSString>;

        #[unsafe(method(threadIdentifier))]
        #[unsafe(method_family = none)]
        pub fn threadIdentifier(&self) -> Retained<NSString>;

        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub fn title(&self) -> Retained<NSString>;

        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub fn userInfo(&self) -> Retained<NSDictionary>;

        /// The argument to be inserted in the summary for this notification.
        #[deprecated = "summaryArgument is ignored"]
        #[unsafe(method(summaryArgument))]
        #[unsafe(method_family = none)]
        pub fn summaryArgument(&self) -> Retained<NSString>;

        /// A number that indicates how many items in the summary are represented in the summary.
        /// For example if a podcast app sends one notification for 3 new episodes in a show,
        /// the argument should be the name of the show and the count should be 3.
        /// Default is 1 and cannot be 0.
        #[deprecated = "summaryArgumentCount is ignored"]
        #[unsafe(method(summaryArgumentCount))]
        #[unsafe(method_family = none)]
        pub fn summaryArgumentCount(&self) -> NSUInteger;

        #[unsafe(method(targetContentIdentifier))]
        #[unsafe(method_family = none)]
        pub fn targetContentIdentifier(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(interruptionLevel))]
        #[unsafe(method_family = none)]
        pub fn interruptionLevel(&self) -> UNNotificationInterruptionLevel;

        #[unsafe(method(relevanceScore))]
        #[unsafe(method_family = none)]
        pub fn relevanceScore(&self) -> c_double;

        #[unsafe(method(filterCriteria))]
        #[unsafe(method_family = none)]
        pub fn filterCriteria(&self) -> Option<Retained<NSString>>;

        /// Contextualizes your UNNotificationContent object with other Apple SDK objects conforming to UNNotificationContentProviding. This will specialize the notification and decorate its look and behavior accordingly. For example, the notification will be treated as a message with an avatar and be promoted to the top of notification center if the object passed in is a valid INSendMessageIntent
        /// <UNNotificationContentProviding
        /// >. This throws an error with a UNErrorCode found in UNError.h if the UNNotificationContentProviding object is invalid. A valid UNNotificationContent result should not be mutated and be passed directly to UNUserNotificationCenter.
        ///
        /// This should be called in the UNNotificationServiceExtension in didReceiveNotificationRequest:withContentHandler: and the returned UNNotificationContent should be passed to the contentHandler for incoming push notifications.
        #[unsafe(method(contentByUpdatingWithProvider:error:_))]
        #[unsafe(method_family = none)]
        pub fn contentByUpdatingWithProvider_error(
            &self,
            provider: &ProtocolObject<dyn UNNotificationContentProviding>,
        ) -> Result<Retained<UNNotificationContent>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UNNotificationContent {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for UNNotificationContent {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// The editable content for a notification.
    ///
    /// ## Overview
    ///
    /// Create a [`UNMutableNotificationContent`](https://developer.apple.com/documentation/usernotifications/unmutablenotificationcontent) object when you want to specify the payload for a local notification. Specifically, use this object to specify the title and message for an alert, the sound to play, or the value to assign to your app’s badge. You might also provide details about how the system handles the notification. For example, you can specify a custom launch image and a thread identifier for visually grouping related notifications.
    ///
    /// After creating your content object, assign it to a [`UNNotificationRequest`](https://developer.apple.com/documentation/usernotifications/unnotificationrequest) object, add a trigger condition, and schedule your notification. The trigger condition defines when the system delivers the notification to the user. Listing 1 shows the scheduling of a local notification that displays an alert and plays a sound after a delay of five seconds. Store the strings for the alert’s title and body in the app’s `Localizable.strings` file.
    ///
    /// Listing 1. Creating the content for a local notification
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Configure the notification's payload.", "let content = UNMutableNotificationContent()", "content.title = NSString.localizedUserNotificationString(forKey: \"Hello!\", arguments: nil)", "content.body = NSString.localizedUserNotificationString(forKey: \"Hello_message_body\", arguments: nil)", "content.sound = UNNotificationSound.default", " ", "// Deliver the notification in five seconds.", "let trigger = UNTimeIntervalNotificationTrigger(timeInterval: 5, repeats: false)", "let request = UNNotificationRequest(identifier: \"FiveSecond\", content: content, trigger: trigger) // Schedule the notification.", "let center = UNUserNotificationCenter.current()", "center.add(request) { (error : Error?) in", "     if let theError = error {", "         // Handle any errors", "     }", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Configure the notification's payload.", "UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];", "content.title = [NSString localizedUserNotificationStringForKey:@\"Hello!\" arguments:nil];", "content.body = [NSString localizedUserNotificationStringForKey:@\"Hello_message_body\" arguments:nil];", "content.sound = [UNNotificationSound defaultSound];", " ", "// Deliver the notification in five seconds.", "UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger", "            triggerWithTimeInterval:5 repeats:NO];", "UNNotificationRequest* request = [UNNotificationRequest requestWithIdentifier:@\"FiveSecond\"", "            content:content trigger:trigger];", " ", "// Schedule the notification.", "UNUserNotificationCenter* center = [UNUserNotificationCenter currentNotificationCenter];", "[center addNotificationRequest:request];"], metadata: None }] }] })
    /// <div class="warning">
    ///
    /// ### Note
    ///  Local notifications always result in user interactions, and the system ignores any interactions for which your app isn’t authorized. For information about how to request authorization for user interactions, see [Asking permission to use notifications](https://developer.apple.com/documentation/usernotifications/asking-permission-to-use-notifications).
    ///
    ///
    ///
    /// </div>
    /// ### Localizing the Alert Strings
    ///
    /// Localize the strings you display in a notification alert for the current user. Although you can use the [`NSLocalizedString`](https://developer.apple.com/documentation/foundation/nslocalizedstring) macros to load strings from your app’s resource files, a better option is to specify your string using the [`localizedUserNotificationStringForKey:arguments:`](https://developer.apple.com/documentation/foundation/nsstring/localizedusernotificationstring(forkey:arguments:)) method of [`NSString`](https://developer.apple.com/documentation/foundation/nsstring). The [`localizedUserNotificationStringForKey:arguments:`](https://developer.apple.com/documentation/foundation/nsstring/localizedusernotificationstring(forkey:arguments:)) method delays the loading of the localized string until the system delivers the notification. If the user changes the language setting before the system delivers a notification, the system updates the alert text to the user’s current language instead of the language in use when the system scheduled the notification.
    ///
    ///
    #[unsafe(super(UNNotificationContent, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UNMutableNotificationContent;
);

extern_conformance!(
    unsafe impl NSCoding for UNMutableNotificationContent {}
);

extern_conformance!(
    unsafe impl NSCopying for UNMutableNotificationContent {}
);

unsafe impl CopyingHelper for UNMutableNotificationContent {
    type Result = UNNotificationContent;
}

extern_conformance!(
    unsafe impl NSMutableCopying for UNMutableNotificationContent {}
);

unsafe impl MutableCopyingHelper for UNMutableNotificationContent {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UNMutableNotificationContent {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for UNMutableNotificationContent {}
);

impl UNMutableNotificationContent {
    extern_methods!(
        #[cfg(feature = "UNNotificationAttachment")]
        #[unsafe(method(attachments))]
        #[unsafe(method_family = none)]
        pub fn attachments(&self) -> Retained<NSArray<UNNotificationAttachment>>;

        #[cfg(feature = "UNNotificationAttachment")]
        /// Setter for [`attachments`][Self::attachments].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAttachments:))]
        #[unsafe(method_family = none)]
        pub fn setAttachments(&self, attachments: &NSArray<UNNotificationAttachment>);

        #[unsafe(method(badge))]
        #[unsafe(method_family = none)]
        pub fn badge(&self) -> Option<Retained<NSNumber>>;

        /// Setter for [`badge`][Self::badge].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBadge:))]
        #[unsafe(method_family = none)]
        pub fn setBadge(&self, badge: Option<&NSNumber>);

        #[unsafe(method(body))]
        #[unsafe(method_family = none)]
        pub fn body(&self) -> Retained<NSString>;

        /// Setter for [`body`][Self::body].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBody:))]
        #[unsafe(method_family = none)]
        pub fn setBody(&self, body: &NSString);

        #[unsafe(method(categoryIdentifier))]
        #[unsafe(method_family = none)]
        pub fn categoryIdentifier(&self) -> Retained<NSString>;

        /// Setter for [`categoryIdentifier`][Self::categoryIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCategoryIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setCategoryIdentifier(&self, category_identifier: &NSString);

        #[unsafe(method(launchImageName))]
        #[unsafe(method_family = none)]
        pub fn launchImageName(&self) -> Retained<NSString>;

        /// Setter for [`launchImageName`][Self::launchImageName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLaunchImageName:))]
        #[unsafe(method_family = none)]
        pub fn setLaunchImageName(&self, launch_image_name: &NSString);

        #[cfg(feature = "UNNotificationSound")]
        #[unsafe(method(sound))]
        #[unsafe(method_family = none)]
        pub fn sound(&self) -> Option<Retained<UNNotificationSound>>;

        #[cfg(feature = "UNNotificationSound")]
        /// Setter for [`sound`][Self::sound].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSound:))]
        #[unsafe(method_family = none)]
        pub fn setSound(&self, sound: Option<&UNNotificationSound>);

        #[unsafe(method(subtitle))]
        #[unsafe(method_family = none)]
        pub fn subtitle(&self) -> Retained<NSString>;

        /// Setter for [`subtitle`][Self::subtitle].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSubtitle:))]
        #[unsafe(method_family = none)]
        pub fn setSubtitle(&self, subtitle: &NSString);

        #[unsafe(method(threadIdentifier))]
        #[unsafe(method_family = none)]
        pub fn threadIdentifier(&self) -> Retained<NSString>;

        /// Setter for [`threadIdentifier`][Self::threadIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setThreadIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setThreadIdentifier(&self, thread_identifier: &NSString);

        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub fn title(&self) -> Retained<NSString>;

        /// Setter for [`title`][Self::title].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTitle:))]
        #[unsafe(method_family = none)]
        pub fn setTitle(&self, title: &NSString);

        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub fn userInfo(&self) -> Retained<NSDictionary>;

        /// Setter for [`userInfo`][Self::userInfo].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[unsafe(method(setUserInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUserInfo(&self, user_info: &NSDictionary);

        /// The argument to be inserted in the summary for this notification.
        #[deprecated = "summaryArgument is ignored"]
        #[unsafe(method(summaryArgument))]
        #[unsafe(method_family = none)]
        pub fn summaryArgument(&self) -> Retained<NSString>;

        /// Setter for [`summaryArgument`][Self::summaryArgument].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[deprecated = "summaryArgument is ignored"]
        #[unsafe(method(setSummaryArgument:))]
        #[unsafe(method_family = none)]
        pub fn setSummaryArgument(&self, summary_argument: &NSString);

        /// A number that indicates how many items in the summary are represented in the summary.
        /// For example if a podcast app sends one notification for 3 new episodes in a show,
        /// the argument should be the name of the show and the count should be 3.
        /// Default is 1 and cannot be 0.
        #[deprecated = "summaryArgumentCount is ignored"]
        #[unsafe(method(summaryArgumentCount))]
        #[unsafe(method_family = none)]
        pub fn summaryArgumentCount(&self) -> NSUInteger;

        /// Setter for [`summaryArgumentCount`][Self::summaryArgumentCount].
        #[deprecated = "summaryArgumentCount is ignored"]
        #[unsafe(method(setSummaryArgumentCount:))]
        #[unsafe(method_family = none)]
        pub fn setSummaryArgumentCount(&self, summary_argument_count: NSUInteger);

        #[unsafe(method(targetContentIdentifier))]
        #[unsafe(method_family = none)]
        pub fn targetContentIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`targetContentIdentifier`][Self::targetContentIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTargetContentIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setTargetContentIdentifier(&self, target_content_identifier: Option<&NSString>);

        #[unsafe(method(interruptionLevel))]
        #[unsafe(method_family = none)]
        pub fn interruptionLevel(&self) -> UNNotificationInterruptionLevel;

        /// Setter for [`interruptionLevel`][Self::interruptionLevel].
        #[unsafe(method(setInterruptionLevel:))]
        #[unsafe(method_family = none)]
        pub fn setInterruptionLevel(&self, interruption_level: UNNotificationInterruptionLevel);

        #[unsafe(method(relevanceScore))]
        #[unsafe(method_family = none)]
        pub fn relevanceScore(&self) -> c_double;

        /// Setter for [`relevanceScore`][Self::relevanceScore].
        #[unsafe(method(setRelevanceScore:))]
        #[unsafe(method_family = none)]
        pub fn setRelevanceScore(&self, relevance_score: c_double);

        #[unsafe(method(filterCriteria))]
        #[unsafe(method_family = none)]
        pub fn filterCriteria(&self) -> Option<Retained<NSString>>;

        /// Setter for [`filterCriteria`][Self::filterCriteria].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFilterCriteria:))]
        #[unsafe(method_family = none)]
        pub fn setFilterCriteria(&self, filter_criteria: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl UNMutableNotificationContent {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for UNMutableNotificationContent {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
