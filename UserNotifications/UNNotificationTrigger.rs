//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-location")]
use objc2_core_location::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The common behavior for subclasses that trigger the delivery of a local or remote notification.
    ///
    /// ## Overview
    ///
    /// The [`UNNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unnotificationtrigger) class is an abstract class for representing an event that triggers the delivery of a notification. You don’t create instances of this class directly. Instead, you instantiate the concrete subclass that defines the trigger condition you want for your notification. You then assign the resulting object to the [`UNNotificationRequest`](https://developer.apple.com/documentation/usernotifications/unnotificationrequest) object that you use to schedule your notification.
    ///
    /// Concrete trigger classes include the following:
    ///
    /// - [`UNTimeIntervalNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/untimeintervalnotificationtrigger)
    ///
    /// - [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger)
    ///
    /// - [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger)
    ///
    /// - [`UNPushNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unpushnotificationtrigger)
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UNNotificationTrigger;
);

extern_conformance!(
    unsafe impl NSCoding for UNNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSCopying for UNNotificationTrigger {}
);

unsafe impl CopyingHelper for UNNotificationTrigger {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UNNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for UNNotificationTrigger {}
);

impl UNNotificationTrigger {
    extern_methods!(
        #[unsafe(method(repeats))]
        #[unsafe(method_family = none)]
        pub fn repeats(&self) -> bool;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UNNotificationTrigger {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A trigger condition that indicates Apple Push Notification Service (APNs) has sent the notification.
    ///
    /// ## Overview
    ///
    /// You don’t create instances of this class yourself. The system creates [`UNPushNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unpushnotificationtrigger) objects and associates them with requests that originated from Apple Push Notification service. You encounter instances of this class when managing your app’s delivered notification requests, which store an object of this type in their [`trigger`](https://developer.apple.com/documentation/usernotifications/unnotificationrequest/trigger) property.
    ///
    ///
    #[unsafe(super(UNNotificationTrigger, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UNPushNotificationTrigger;
);

extern_conformance!(
    unsafe impl NSCoding for UNPushNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSCopying for UNPushNotificationTrigger {}
);

unsafe impl CopyingHelper for UNPushNotificationTrigger {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UNPushNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for UNPushNotificationTrigger {}
);

impl UNPushNotificationTrigger {
    extern_methods!();
}

/// Methods declared on superclass `UNNotificationTrigger`.
impl UNPushNotificationTrigger {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UNPushNotificationTrigger {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A trigger condition that causes the system to deliver a notification after the amount of time you specify elapses.
    ///
    /// ## Overview
    ///
    /// Create a [`UNTimeIntervalNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/untimeintervalnotificationtrigger) object when you want to schedule the delivery of a local notification after the number of seconds you specify elapses. You use this type of trigger to implement timers.
    ///
    /// Listing 1 creates a trigger that delivers its notification one time after 30 minutes have elapsed.
    ///
    /// Listing 1. Creating a trigger that fires in 30 minutes
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Fire in 30 minutes (60 seconds times 30)", "let trigger = UNTimeIntervalNotificationTrigger(timeInterval: (30*60), repeats: false)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Fire in 30 minutes (60 seconds times 30)", "UNTimeIntervalNotificationTrigger* trigger = [UNTimeIntervalNotificationTrigger", "                     triggerWithTimeInterval:(30*60) repeats: NO];"], metadata: None }] }] })
    ///
    #[unsafe(super(UNNotificationTrigger, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UNTimeIntervalNotificationTrigger;
);

extern_conformance!(
    unsafe impl NSCoding for UNTimeIntervalNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSCopying for UNTimeIntervalNotificationTrigger {}
);

unsafe impl CopyingHelper for UNTimeIntervalNotificationTrigger {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UNTimeIntervalNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for UNTimeIntervalNotificationTrigger {}
);

impl UNTimeIntervalNotificationTrigger {
    extern_methods!(
        #[unsafe(method(timeInterval))]
        #[unsafe(method_family = none)]
        pub fn timeInterval(&self) -> NSTimeInterval;

        #[unsafe(method(triggerWithTimeInterval:repeats:))]
        #[unsafe(method_family = none)]
        pub fn triggerWithTimeInterval_repeats(
            time_interval: NSTimeInterval,
            repeats: bool,
        ) -> Retained<Self>;

        #[unsafe(method(nextTriggerDate))]
        #[unsafe(method_family = none)]
        pub fn nextTriggerDate(&self) -> Option<Retained<NSDate>>;
    );
}

/// Methods declared on superclass `UNNotificationTrigger`.
impl UNTimeIntervalNotificationTrigger {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UNTimeIntervalNotificationTrigger {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A trigger condition that causes a notification the system delivers at a specific date and time.
    ///
    /// ## Overview
    ///
    /// Create a [`UNCalendarNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/uncalendarnotificationtrigger) object when you want to schedule the delivery of a local notification at the date and time you specify. You use an [`NSDateComponents`](https://developer.apple.com/documentation/foundation/nsdatecomponents) object to specify only the time values that you want the system to use to determine the matching date and time.
    ///
    /// Listing 1 creates a trigger that delivers its notification every morning at 8:30. The repeating behavior is achieved by specifying `true` for the `repeats` parameter when creating the trigger.
    ///
    /// Listing 1. Creating a trigger that repeats at a specific time
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["var date = DateComponents()", "date.hour = 8", "date.minute = 30 ", "let trigger = UNCalendarNotificationTrigger(dateMatching: date, repeats: true)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSDateComponents* date = [[NSDateComponents alloc] init];", "date.hour = 8;", "date.minute = 30; ", "UNCalendarNotificationTrigger* trigger = [UNCalendarNotificationTrigger", "                     triggerWithDateMatchingComponents:date repeats:YES];"], metadata: None }] }] })
    ///
    #[unsafe(super(UNNotificationTrigger, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UNCalendarNotificationTrigger;
);

extern_conformance!(
    unsafe impl NSCoding for UNCalendarNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSCopying for UNCalendarNotificationTrigger {}
);

unsafe impl CopyingHelper for UNCalendarNotificationTrigger {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UNCalendarNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for UNCalendarNotificationTrigger {}
);

impl UNCalendarNotificationTrigger {
    extern_methods!(
        #[unsafe(method(dateComponents))]
        #[unsafe(method_family = none)]
        pub fn dateComponents(&self) -> Retained<NSDateComponents>;

        #[unsafe(method(triggerWithDateMatchingComponents:repeats:))]
        #[unsafe(method_family = none)]
        pub fn triggerWithDateMatchingComponents_repeats(
            date_components: &NSDateComponents,
            repeats: bool,
        ) -> Retained<Self>;

        #[unsafe(method(nextTriggerDate))]
        #[unsafe(method_family = none)]
        pub fn nextTriggerDate(&self) -> Option<Retained<NSDate>>;
    );
}

/// Methods declared on superclass `UNNotificationTrigger`.
impl UNCalendarNotificationTrigger {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UNCalendarNotificationTrigger {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A trigger condition that causes the system to deliver a notification when the user’s device enters or exits a geographic region you specify.
    ///
    /// ## Overview
    ///
    /// Create a [`UNLocationNotificationTrigger`](https://developer.apple.com/documentation/usernotifications/unlocationnotificationtrigger) object when you want to schedule the delivery of a local notification when the device enters or leaves a specific geographic region. The system limits the number of location-based triggers that it schedules at the same time.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Before scheduling any notifications using this trigger, your app must have authorization to use Core Location and must have when-in-use permissions. (Because the system actually monitors the regions, you don’t need to request always permissions for your app). For information about how to request authorization, see [Requesting authorization to use location services](https://developer.apple.com/documentation/corelocation/requesting-authorization-to-use-location-services).
    ///
    ///
    ///
    /// </div>
    /// When configuring the region, use the [`notifyOnEntry`](https://developer.apple.com/documentation/corelocation/clregion/notifyonentry) and [`notifyOnExit`](https://developer.apple.com/documentation/corelocation/clregion/notifyonexit) properties to specify whether you want the system to deliver notifications on entry, on exit, or both. Listing 1 shows the creation of a trigger that fires only once when the user’s device enters a circular region with a 2-kilometer radius.
    ///
    /// Listing 1. Creating a location-based trigger
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let center = CLLocationCoordinate2D(latitude: 37.335400, longitude: -122.009201)", "let region = CLCircularRegion(center: center, radius: 2000.0, identifier: \"Headquarters\")", "region.notifyOnEntry = true", "region.notifyOnExit = false", "let trigger = UNLocationNotificationTrigger(region: region, repeats: false)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["CLLocationCoordinate2D center = CLLocationCoordinate2DMake(37.335400, -122.009201);", "", "CLCircularRegion* region = [[CLCircularRegion alloc] initWithCenter:center", "         isn’t  radius:2000.0 identifier:@\"Headquarters\"];", "region.notifyOnEntry = YES;", "region.notifyOnExit = NO;", "", "UNLocationNotificationTrigger* trigger = [UNLocationNotificationTrigger", "                 triggerWithRegion:region repeats:NO];"], metadata: None }] }] })
    /// The system doesn’t immediately trigger region-based notifications when the edge of the boundary is crossed. The system applies heuristics to ensure that the boundary crossing represents a deliberate event and isn’t the result of spurious location data. For more information about the heuristics, see [Monitoring the user’s proximity to geographic regions](https://developer.apple.com/documentation/corelocation/monitoring-the-user-s-proximity-to-geographic-regions).
    ///
    ///
    #[unsafe(super(UNNotificationTrigger, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct UNLocationNotificationTrigger;
);

extern_conformance!(
    unsafe impl NSCoding for UNLocationNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSCopying for UNLocationNotificationTrigger {}
);

unsafe impl CopyingHelper for UNLocationNotificationTrigger {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for UNLocationNotificationTrigger {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for UNLocationNotificationTrigger {}
);

impl UNLocationNotificationTrigger {
    extern_methods!(
        #[cfg(feature = "objc2-core-location")]
        #[unsafe(method(region))]
        #[unsafe(method_family = none)]
        pub fn region(&self) -> Retained<CLRegion>;

        #[cfg(feature = "objc2-core-location")]
        #[unsafe(method(triggerWithRegion:repeats:))]
        #[unsafe(method_family = none)]
        pub fn triggerWithRegion_repeats(region: &CLRegion, repeats: bool) -> Retained<Self>;
    );
}

/// Methods declared on superclass `UNNotificationTrigger`.
impl UNLocationNotificationTrigger {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl UNLocationNotificationTrigger {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
