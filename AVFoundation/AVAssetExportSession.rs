//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetlowquality?language=objc)
    pub static AVAssetExportPresetLowQuality: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetmediumquality?language=objc)
    pub static AVAssetExportPresetMediumQuality: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresethighestquality?language=objc)
    pub static AVAssetExportPresetHighestQuality: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresethevchighestquality?language=objc)
    pub static AVAssetExportPresetHEVCHighestQuality: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresethevchighestqualitywithalpha?language=objc)
    pub static AVAssetExportPresetHEVCHighestQualityWithAlpha: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpreset640x480?language=objc)
    pub static AVAssetExportPreset640x480: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpreset960x540?language=objc)
    pub static AVAssetExportPreset960x540: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpreset1280x720?language=objc)
    pub static AVAssetExportPreset1280x720: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpreset1920x1080?language=objc)
    pub static AVAssetExportPreset1920x1080: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpreset3840x2160?language=objc)
    pub static AVAssetExportPreset3840x2160: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresethevc1920x1080?language=objc)
    pub static AVAssetExportPresetHEVC1920x1080: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresethevc1920x1080withalpha?language=objc)
    pub static AVAssetExportPresetHEVC1920x1080WithAlpha: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresethevc3840x2160?language=objc)
    pub static AVAssetExportPresetHEVC3840x2160: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresethevc3840x2160withalpha?language=objc)
    pub static AVAssetExportPresetHEVC3840x2160WithAlpha: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresethevc4320x2160?language=objc)
    pub static AVAssetExportPresetHEVC4320x2160: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresethevc7680x4320?language=objc)
    pub static AVAssetExportPresetHEVC7680x4320: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetmvhevc960x960?language=objc)
    pub static AVAssetExportPresetMVHEVC960x960: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetmvhevc1440x1440?language=objc)
    pub static AVAssetExportPresetMVHEVC1440x1440: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetmvhevc4320x4320?language=objc)
    pub static AVAssetExportPresetMVHEVC4320x4320: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetmvhevc7680x7680?language=objc)
    pub static AVAssetExportPresetMVHEVC7680x7680: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetapplem4a?language=objc)
    pub static AVAssetExportPresetAppleM4A: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetpassthrough?language=objc)
    pub static AVAssetExportPresetPassthrough: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetappleprores422lpcm?language=objc)
    pub static AVAssetExportPresetAppleProRes422LPCM: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetappleprores4444lpcm?language=objc)
    pub static AVAssetExportPresetAppleProRes4444LPCM: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetapplem4vcellular?language=objc)
    pub static AVAssetExportPresetAppleM4VCellular: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetapplem4vipod?language=objc)
    pub static AVAssetExportPresetAppleM4ViPod: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetapplem4v480psd?language=objc)
    pub static AVAssetExportPresetAppleM4V480pSD: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetapplem4vappletv?language=objc)
    pub static AVAssetExportPresetAppleM4VAppleTV: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetapplem4vwifi?language=objc)
    pub static AVAssetExportPresetAppleM4VWiFi: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetapplem4v720phd?language=objc)
    pub static AVAssetExportPresetAppleM4V720pHD: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportpresetapplem4v1080phd?language=objc)
    pub static AVAssetExportPresetAppleM4V1080pHD: &'static NSString;
}

/// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportsessionstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVAssetExportSessionStatus(pub NSInteger);
impl AVAssetExportSessionStatus {
    #[doc(alias = "AVAssetExportSessionStatusUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "AVAssetExportSessionStatusWaiting")]
    pub const Waiting: Self = Self(1);
    #[doc(alias = "AVAssetExportSessionStatusExporting")]
    pub const Exporting: Self = Self(2);
    #[doc(alias = "AVAssetExportSessionStatusCompleted")]
    pub const Completed: Self = Self(3);
    #[doc(alias = "AVAssetExportSessionStatusFailed")]
    pub const Failed: Self = Self(4);
    #[doc(alias = "AVAssetExportSessionStatusCancelled")]
    pub const Cancelled: Self = Self(5);
}

unsafe impl Encode for AVAssetExportSessionStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVAssetExportSessionStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A bitfield type that specifies output handling policies for alternate tracks in a track group.
///
///
///
/// No specific processing directives are applied to alternate tracks.  The output is produced without regard to alternate track group assignments in the original asset.
///
///
/// Preserve alternate tracks via pass-through.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassettrackgroupoutputhandling?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVAssetTrackGroupOutputHandling(pub NSUInteger);
bitflags::bitflags! {
    impl AVAssetTrackGroupOutputHandling: NSUInteger {
        #[doc(alias = "AVAssetTrackGroupOutputHandlingNone")]
        const None = 0;
        #[doc(alias = "AVAssetTrackGroupOutputHandlingPreserveAlternateTracks")]
        const PreserveAlternateTracks = 1<<0;
        #[doc(alias = "AVAssetTrackGroupOutputHandlingDefaultPolicy")]
        const DefaultPolicy = AVAssetTrackGroupOutputHandling::None.0;
    }
}

unsafe impl Encode for AVAssetTrackGroupOutputHandling {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for AVAssetTrackGroupOutputHandling {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An AVAssetExportSession creates a new timed media resource from the contents of an
    /// existing AVAsset in the form described by a specified export preset.
    ///
    ///
    /// Prior to initializing an instance of AVAssetExportSession, you can invoke
    /// +allExportPresets to obtain the complete list of presets available. Use
    /// +exportPresetsCompatibleWithAsset: to obtain a list of presets that are compatible
    /// with a specific AVAsset.
    ///
    /// To configure an export, initialize an AVAssetExportSession with an AVAsset that contains
    /// the source media, an AVAssetExportPreset, the output file type, (a UTI string from
    /// those defined in AVMediaFormat.h) and the output URL.
    ///
    /// After configuration is complete, invoke exportAsynchronouslyWithCompletionHandler:
    /// to start the export process. This method returns immediately; the export is performed
    /// asynchronously. Invoke the -progress method to check on the progress. Note that in
    /// some cases, depending on the capabilities of the device, when multiple exports are
    /// attempted at the same time some may be queued until others have been completed. When
    /// this happens, the status of a queued export will indicate that it's "waiting".
    ///
    /// Whether the export fails, completes, or is cancelled, the completion handler you
    /// supply to -exportAsynchronouslyWithCompletionHandler: will be called. Upon
    /// completion, the status property indicates whether the export has completed
    /// successfully. If it has failed, the value of the error property supplies additional
    /// information about the reason for the failure.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetexportsession?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVAssetExportSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for AVAssetExportSession {}
);

impl AVAssetExportSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "AVAsset")]
        /// Returns an instance of AVAssetExportSession for the specified source asset and preset.
        ///
        /// Parameter `asset`: An AVAsset object that is intended to be exported.
        ///
        /// Parameter `presetName`: An NSString specifying the name of the preset template for the export.
        ///
        /// Returns: An instance of AVAssetExportSession.
        ///
        /// If the specified asset belongs to a mutable subclass of AVAsset, AVMutableComposition or AVMutableMovie, the results of any export-related operation are undefined if you mutate the asset after the operation commences. These operations include but are not limited to: 1) testing the compatibility of export presets with the asset, 2) calculating the maximum duration or estimated length of the output file, and 3) the export operation itself.
        #[unsafe(method(exportSessionWithAsset:presetName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn exportSessionWithAsset_presetName(
            asset: &AVAsset,
            preset_name: &NSString,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "AVAsset")]
        /// Initialize an AVAssetExportSession with the specified preset and set the source to the contents of the asset.
        ///
        /// Parameter `asset`: An AVAsset object that is intended to be exported.
        ///
        /// Parameter `presetName`: An NSString specifying the name of the preset template for the export.
        ///
        /// Returns: Returns the initialized AVAssetExportSession.
        ///
        /// If the specified asset belongs to a mutable subclass of AVAsset, AVMutableComposition or AVMutableMovie, the results of any export-related operation are undefined if you mutate the asset after the operation commences. These operations include but are not limited to: 1) testing the compatibility of export presets with the asset, 2) calculating the maximum duration or estimated length of the output file, and 3) the export operation itself.
        #[unsafe(method(initWithAsset:presetName:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAsset_presetName(
            this: Allocated<Self>,
            asset: &AVAsset,
            preset_name: &NSString,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(presetName))]
        #[unsafe(method_family = none)]
        pub unsafe fn presetName(&self) -> Retained<NSString>;

        #[cfg(feature = "AVAsset")]
        #[unsafe(method(asset))]
        #[unsafe(method_family = none)]
        pub unsafe fn asset(&self) -> Retained<AVAsset>;

        #[cfg(feature = "AVMediaFormat")]
        #[unsafe(method(outputFileType))]
        #[unsafe(method_family = none)]
        pub unsafe fn outputFileType(&self) -> Option<Retained<AVFileType>>;

        #[cfg(feature = "AVMediaFormat")]
        /// Setter for [`outputFileType`][Self::outputFileType].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setOutputFileType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOutputFileType(&self, output_file_type: Option<&AVFileType>);

        #[unsafe(method(outputURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn outputURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`outputURL`][Self::outputURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setOutputURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOutputURL(&self, output_url: Option<&NSURL>);

        #[unsafe(method(shouldOptimizeForNetworkUse))]
        #[unsafe(method_family = none)]
        pub unsafe fn shouldOptimizeForNetworkUse(&self) -> bool;

        /// Setter for [`shouldOptimizeForNetworkUse`][Self::shouldOptimizeForNetworkUse].
        #[unsafe(method(setShouldOptimizeForNetworkUse:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setShouldOptimizeForNetworkUse(&self, should_optimize_for_network_use: bool);

        /// Determines whether or not parallelization can be employed in the export.
        ///
        /// On select platforms, there may be opportunities to expedite the export by using additional resources in parallel.
        /// If set to YES, export parallelization will be enabled, only if parallelization requirements are met.  There will
        /// be no error signaled if export parallelization is not achievable, and instead the export will proceed as normal
        /// (without parallelization).
        /// If set to NO, export parallelization will not be used.
        #[unsafe(method(allowsParallelizedExport))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsParallelizedExport(&self) -> bool;

        /// Setter for [`allowsParallelizedExport`][Self::allowsParallelizedExport].
        #[unsafe(method(setAllowsParallelizedExport:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsParallelizedExport(&self, allows_parallelized_export: bool);

        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        pub unsafe fn status(&self) -> AVAssetExportSessionStatus;

        #[unsafe(method(error))]
        #[unsafe(method_family = none)]
        pub unsafe fn error(&self) -> Option<Retained<NSError>>;

        #[cfg(feature = "block2")]
        /// Starts the asynchronous execution of an export session.
        ///
        /// Parameter `handler`: If internal preparation for export fails, the handler will be invoked synchronously.
        /// The handler may also be called asynchronously after -exportAsynchronouslyWithCompletionHandler: returns,
        /// in the following cases:
        /// 1) if a failure occurs during the export, including failures of loading, re-encoding, or writing media data to the output,
        /// 2) if -cancelExport is invoked,
        /// 3) if export session succeeds, having completely written its output to the outputURL.
        /// In each case, AVAssetExportSession.status will signal the terminal state of the asset reader, and if a failure occurs, the NSError
        /// that describes the failure can be obtained from the error property.
        ///
        /// Initiates an asynchronous export operation and returns immediately.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(exportAsynchronouslyWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn exportAsynchronouslyWithCompletionHandler(
            &self,
            handler: &block2::DynBlock<dyn Fn()>,
        );

        #[unsafe(method(progress))]
        #[unsafe(method_family = none)]
        pub unsafe fn progress(&self) -> c_float;

        /// Cancels the execution of an export session.
        ///
        /// Cancel can be invoked when the export is running.
        #[unsafe(method(cancelExport))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelExport(&self);
    );
}

/// AVAssetExportSessionPresets.
impl AVAssetExportSession {
    extern_methods!(
        /// Returns all available export preset names.
        ///
        /// Returns an array of NSStrings with the names of all available presets. Note that not all presets are
        /// compatible with all AVAssets.
        ///
        /// Returns: An NSArray containing an NSString for each of the available preset names.
        #[unsafe(method(allExportPresets))]
        #[unsafe(method_family = none)]
        pub unsafe fn allExportPresets() -> Retained<NSArray<NSString>>;

        #[cfg(feature = "AVAsset")]
        /// Returns only the identifiers compatible with the given AVAsset object.
        ///
        /// Not all export presets are compatible with all AVAssets. For example an video only asset is not compatible with an audio only preset.
        /// This method returns only the identifiers for presets that will be compatible with the given asset.
        /// A client should pass in an AVAsset that is ready to be exported.
        /// In order to ensure that the setup and running of an export operation will succeed using a given preset no significant changes
        /// (such as adding or deleting tracks) should be made to the asset between retrieving compatible identifiers and performing the export operation.
        /// This method will access the tracks property of the AVAsset to build the returned NSArray.  To avoid blocking the calling thread,
        /// the tracks property should be loaded using the AVAsynchronousKeyValueLoading protocol before calling this method.
        ///
        /// Parameter `asset`: An AVAsset object that is intended to be exported.
        ///
        /// Returns: An NSArray containing NSString values for the identifiers of compatible export types.
        /// The array is a complete list of the valid identifiers that can be used as arguments to
        /// initWithAsset:presetName: with the specified asset.
        #[deprecated]
        #[unsafe(method(exportPresetsCompatibleWithAsset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn exportPresetsCompatibleWithAsset(
            asset: &AVAsset,
        ) -> Retained<NSArray<NSString>>;

        #[cfg(all(feature = "AVAsset", feature = "AVMediaFormat", feature = "block2"))]
        /// Performs an inspection on the compatibility of an export preset, AVAsset and output file type.  Calls the completion handler with YES if
        /// the arguments are compatible; NO otherwise.
        ///
        /// Not all export presets are compatible with all AVAssets and file types.  This method can be used to query compatibility.
        /// In order to ensure that the setup and running of an export operation will succeed using a given preset no significant changes
        /// (such as adding or deleting tracks) should be made to the asset between retrieving compatible identifiers and performing the export operation.
        ///
        /// Parameter `presetName`: An NSString specifying the name of the preset template for the export.
        ///
        /// Parameter `asset`: An AVAsset object that is intended to be exported.
        ///
        /// Parameter `outputFileType`: An AVFileType indicating a file type to check; or nil, to query whether there are any compatible types.
        ///
        /// Parameter `handler`: A block called with the compatibility result.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(determineCompatibilityOfExportPreset:withAsset:outputFileType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn determineCompatibilityOfExportPreset_withAsset_outputFileType_completionHandler(
            preset_name: &NSString,
            asset: &AVAsset,
            output_file_type: Option<&AVFileType>,
            handler: &block2::DynBlock<dyn Fn(Bool)>,
        );
    );
}

/// AVAssetExportSessionFileTypes.
impl AVAssetExportSession {
    extern_methods!(
        #[cfg(feature = "AVMediaFormat")]
        #[unsafe(method(supportedFileTypes))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedFileTypes(&self) -> Retained<NSArray<AVFileType>>;

        #[cfg(all(feature = "AVMediaFormat", feature = "block2"))]
        /// Performs an inspection on the AVAsset and Preset the object was initialized with to determine a list of file types the ExportSession can write.
        ///
        /// Parameter `handler`: Called when the inspection completes with an array of file types the ExportSession can write.  Note that this may have a count of zero.
        ///
        /// This method is different than the supportedFileTypes property in that it performs an inspection of the AVAsset in order to determine its compatibility with each of the session's supported file types.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(determineCompatibleFileTypesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn determineCompatibleFileTypesWithCompletionHandler(
            &self,
            handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<AVFileType>>)>,
        );
    );
}

/// AVAssetExportSessionDurationAndLength.
impl AVAssetExportSession {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        #[unsafe(method(timeRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn timeRange(&self) -> CMTimeRange;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`timeRange`][Self::timeRange].
        #[unsafe(method(setTimeRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimeRange(&self, time_range: CMTimeRange);

        #[cfg(feature = "objc2-core-media")]
        #[deprecated = "Use estimateMaximumDurationWithCompletionHandler: instead"]
        #[unsafe(method(maxDuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxDuration(&self) -> CMTime;

        #[deprecated = "Use estimateOutputFileLengthWithCompletionHandler: instead"]
        #[unsafe(method(estimatedOutputFileLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn estimatedOutputFileLength(&self) -> c_longlong;

        #[unsafe(method(fileLengthLimit))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileLengthLimit(&self) -> c_longlong;

        /// Setter for [`fileLengthLimit`][Self::fileLengthLimit].
        #[unsafe(method(setFileLengthLimit:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFileLengthLimit(&self, file_length_limit: c_longlong);

        #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
        /// Starts the asynchronous execution of estimating the maximum duration of the export based on the asset, preset, and fileLengthLimit associated with the export session.
        ///
        /// If fileLengthLimit is not set on the export session, fileLengthLimit will be assumed to be the maximum file size specified by the preset (if any); else infinite.
        ///
        /// Parameter `handler`: A block called with the estimated maximum duration, or kCMTimeInvalid if an error occurs.  The error parameter will be non-nil if an error occurs.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(estimateMaximumDurationWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn estimateMaximumDurationWithCompletionHandler(
            &self,
            handler: &block2::DynBlock<dyn Fn(CMTime, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Starts the asynchronous execution of estimating the output file length of the export based on the asset, preset, and timeRange associated with the export session.
        ///
        /// If timeRange is not set on the export session, timeRange will be assumed to be the full time range of the asset.
        ///
        /// Parameter `handler`: A block called with the estimated output file length in bytes, if it can be determined; 0 otherwise.  The error parameter will be non-nil if an error occurs.
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(estimateOutputFileLengthWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn estimateOutputFileLengthWithCompletionHandler(
            &self,
            handler: &block2::DynBlock<dyn Fn(i64, *mut NSError)>,
        );
    );
}

/// AVAssetExportSessionMetadata.
impl AVAssetExportSession {
    extern_methods!(
        #[cfg(feature = "AVMetadataItem")]
        #[unsafe(method(metadata))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadata(&self) -> Option<Retained<NSArray<AVMetadataItem>>>;

        #[cfg(feature = "AVMetadataItem")]
        /// Setter for [`metadata`][Self::metadata].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMetadata:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMetadata(&self, metadata: Option<&NSArray<AVMetadataItem>>);

        #[cfg(feature = "AVMetadataItem")]
        #[unsafe(method(metadataItemFilter))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItemFilter(&self) -> Option<Retained<AVMetadataItemFilter>>;

        #[cfg(feature = "AVMetadataItem")]
        /// Setter for [`metadataItemFilter`][Self::metadataItemFilter].
        #[unsafe(method(setMetadataItemFilter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMetadataItemFilter(
            &self,
            metadata_item_filter: Option<&AVMetadataItemFilter>,
        );
    );
}

/// AVAssetExportSessionMediaProcessing.
impl AVAssetExportSession {
    extern_methods!(
        #[cfg(feature = "AVAudioProcessingSettings")]
        #[unsafe(method(audioTimePitchAlgorithm))]
        #[unsafe(method_family = none)]
        pub unsafe fn audioTimePitchAlgorithm(&self) -> Retained<AVAudioTimePitchAlgorithm>;

        #[cfg(feature = "AVAudioProcessingSettings")]
        /// Setter for [`audioTimePitchAlgorithm`][Self::audioTimePitchAlgorithm].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAudioTimePitchAlgorithm:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAudioTimePitchAlgorithm(
            &self,
            audio_time_pitch_algorithm: &AVAudioTimePitchAlgorithm,
        );

        #[cfg(feature = "AVAudioMix")]
        #[unsafe(method(audioMix))]
        #[unsafe(method_family = none)]
        pub unsafe fn audioMix(&self) -> Option<Retained<AVAudioMix>>;

        #[cfg(feature = "AVAudioMix")]
        /// Setter for [`audioMix`][Self::audioMix].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAudioMix:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAudioMix(&self, audio_mix: Option<&AVAudioMix>);

        #[cfg(feature = "AVVideoComposition")]
        #[unsafe(method(videoComposition))]
        #[unsafe(method_family = none)]
        pub unsafe fn videoComposition(&self) -> Option<Retained<AVVideoComposition>>;

        #[cfg(feature = "AVVideoComposition")]
        /// Setter for [`videoComposition`][Self::videoComposition].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setVideoComposition:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVideoComposition(&self, video_composition: Option<&AVVideoComposition>);

        #[cfg(feature = "AVVideoCompositing")]
        #[unsafe(method(customVideoCompositor))]
        #[unsafe(method_family = none)]
        pub unsafe fn customVideoCompositor(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn AVVideoCompositing>>>;

        /// Defines export policy for handling alternate audio tracks
        ///
        ///
        /// Specifies the handling of audio tracks that are members of the same alternate track group corresponding to an exported audio track in the source asset.
        /// If no audio track group is present, the value of this property has no effect.
        /// If necessary, use the trackGroups property of AVAsset to determine whether any audio track groups are present.
        /// The AVAudioMix property is not allowed to be used when also specifying alternate track output handling.  An exception will be thrown if both are specified.
        #[unsafe(method(audioTrackGroupHandling))]
        #[unsafe(method_family = none)]
        pub unsafe fn audioTrackGroupHandling(&self) -> AVAssetTrackGroupOutputHandling;

        /// Setter for [`audioTrackGroupHandling`][Self::audioTrackGroupHandling].
        #[unsafe(method(setAudioTrackGroupHandling:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAudioTrackGroupHandling(
            &self,
            audio_track_group_handling: AVAssetTrackGroupOutputHandling,
        );
    );
}

/// AVAssetExportSessionMultipass.
impl AVAssetExportSession {
    extern_methods!(
        /// Determines whether the export session can perform multiple passes over the source media to achieve better results.
        ///
        ///
        /// When the value for this property is YES, the export session can produce higher quality results at the expense of longer export times.  Setting this property to YES may also require the export session to write temporary data to disk during the export.  To control the location of temporary data, use the property directoryForTemporaryFiles.
        ///
        /// The default value is NO.  Not all export session configurations can benefit from performing multiple passes over the source media.  In these cases, setting this property to YES has no effect.
        ///
        /// This property cannot be set after the export has started.
        #[unsafe(method(canPerformMultiplePassesOverSourceMediaData))]
        #[unsafe(method_family = none)]
        pub unsafe fn canPerformMultiplePassesOverSourceMediaData(&self) -> bool;

        /// Setter for [`canPerformMultiplePassesOverSourceMediaData`][Self::canPerformMultiplePassesOverSourceMediaData].
        #[unsafe(method(setCanPerformMultiplePassesOverSourceMediaData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCanPerformMultiplePassesOverSourceMediaData(
            &self,
            can_perform_multiple_passes_over_source_media_data: bool,
        );

        /// Specifies a directory that is suitable for containing temporary files generated during the export process
        ///
        ///
        /// AVAssetExportSession may need to write temporary files when configured in certain ways, such as when canPerformMultiplePassesOverSourceMediaData is set to YES.  This property can be used to control where in the filesystem those temporary files are created.  All temporary files will be deleted when the export is completed, is canceled, or fails.
        ///
        /// When the value of this property is nil, the export session will choose a suitable location when writing temporary files.  The default value is nil.
        ///
        /// This property cannot be set after the export has started.  The export will fail if the URL points to a location that is not a directory, does not exist, is not on the local file system, or if a file cannot be created in this directory (for example, due to insufficient permissions or sandboxing restrictions).
        #[unsafe(method(directoryForTemporaryFiles))]
        #[unsafe(method_family = none)]
        pub unsafe fn directoryForTemporaryFiles(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`directoryForTemporaryFiles`][Self::directoryForTemporaryFiles].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDirectoryForTemporaryFiles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDirectoryForTemporaryFiles(
            &self,
            directory_for_temporary_files: Option<&NSURL>,
        );
    );
}
