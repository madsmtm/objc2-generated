//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplecursor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVSampleCursor;
);

unsafe impl Send for AVSampleCursor {}

unsafe impl Sync for AVSampleCursor {}

extern_conformance!(
    unsafe impl NSCopying for AVSampleCursor {}
);

unsafe impl CopyingHelper for AVSampleCursor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVSampleCursor {}
);

impl AVSampleCursor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// Moves the cursor a given number of samples in decode order.
        ///
        /// Parameter `stepCount`: The number of samples to move across. If positive, step forward this many samples. If negative, step backward (-stepCount) samples.
        ///
        /// Returns: The number of samples the cursor traversed. If the beginning or the end of the sample sequence was reached before the requested number of samples was traversed, the absolute value of the result will be less than the absolute value of stepCount.
        #[unsafe(method(stepInDecodeOrderByCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stepInDecodeOrderByCount(&self, step_count: i64) -> i64;

        /// Moves the cursor a given number of samples in presentation order.
        ///
        /// Parameter `stepCount`: The number of samples to move across. If positive, step forward this many samples. If negative, step backward (-stepCount) samples.
        ///
        /// Returns: The number of samples the cursor traversed. If the beginning or the end of the sample sequence was reached before the requested number of samples was traversed, the absolute value of the result will be less than the absolute value of stepCount.
        #[unsafe(method(stepInPresentationOrderByCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stepInPresentationOrderByCount(&self, step_count: i64) -> i64;

        #[cfg(feature = "objc2-core-media")]
        /// Moves the cursor by a given deltaTime on the decode timeline.
        ///
        /// Parameter `deltaDecodeTime`: The amount of time to move in the decode timeline.
        ///
        /// Parameter `outWasPinned`: If the beginning or the end of the sample sequence was reached before the requested deltaDecodeTime was traversed, the BOOL value at the address specified by outWasPinned will be set to YES. May be NULL if this information isn't desired.
        ///
        /// Returns: The amount of time the cursor was moved along the decode timeline. Because sample cursors snap to sample boundaries when stepped, this value may not be equal to deltaDecodeTime even if the cursor was not pinned.
        #[unsafe(method(stepByDecodeTime:wasPinned:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stepByDecodeTime_wasPinned(
            &self,
            delta_decode_time: CMTime,
            out_was_pinned: *mut Bool,
        ) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// Moves the cursor by a given deltaTime on the presentation timeline.
        ///
        /// Parameter `deltaPresentationTime`: The amount of time to move in the presentation timeline.
        ///
        /// Parameter `outWasPinned`: If the beginning or the end of the sample sequence was reached before the requested deltaPresentationTime was traversed, the BOOL value at the address specified by outWasPinned will be set to YES. May be NULL if this information isn't desired.
        ///
        /// Returns: The amount of time the cursor was moved along the presentation timeline. Because sample cursors snap to sample boundaries when stepped, this value may not be equal to deltaPresentationTime even if the cursor was not pinned.
        #[unsafe(method(stepByPresentationTime:wasPinned:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stepByPresentationTime_wasPinned(
            &self,
            delta_presentation_time: CMTime,
            out_was_pinned: *mut Bool,
        ) -> CMTime;
    );
}

/// AVSampleCursorTemporalPosition.
impl AVSampleCursor {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// The presentation timestamp (PTS) of the sample at the current position of the cursor.
        ///
        /// This property is not atomic.
        #[unsafe(method(presentationTimeStamp))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentationTimeStamp(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// The decode timestamp (DTS) of the sample at the current position of the cursor.
        ///
        /// This property is not atomic.
        #[unsafe(method(decodeTimeStamp))]
        #[unsafe(method_family = none)]
        pub unsafe fn decodeTimeStamp(&self) -> CMTime;

        /// Compares the relative positions of two AVSampleCursors.
        ///
        /// Parameter `cursor`: An instance of AVSampleCursor with which to compare positions.
        ///
        /// Returns: kCFCompareLessThan, kCFCompareEqualTo or kCFCompareGreaterThan, depending on whether the receiver points at a sample before, the same as, or after the sample pointed to by the specified AVSampleCursor.
        ///
        /// If the receiver and cursor reference different sequences of samples, as when they're created by different instances of AVAssetTrack, results are undefined.
        #[unsafe(method(comparePositionInDecodeOrderWithPositionOfCursor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn comparePositionInDecodeOrderWithPositionOfCursor(
            &self,
            cursor: &AVSampleCursor,
        ) -> NSComparisonResult;

        /// This method tests a boundary in the reordering from decode order to presentation order, determining whether it's possible for any sample earlier in decode order than the sample at the position of the receiver can have a presentation timestamp later than that of the specified sample cursor.
        ///
        /// Parameter `cursor`: An instance of AVSampleCursor with which to test the sample reordering boundary.
        ///
        /// Returns: YES if it's possible for any sample earlier in decode order than the sample at the position of the receiver can have a presentation timestamp later than that of the specified sample cursor.
        ///
        /// If the receiver and cursor reference different sequences of samples, as when they're created by different instances of AVAssetTrack, results are undefined.
        #[unsafe(method(samplesWithEarlierDecodeTimeStampsMayHaveLaterPresentationTimeStampsThanCursor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn samplesWithEarlierDecodeTimeStampsMayHaveLaterPresentationTimeStampsThanCursor(
            &self,
            cursor: &AVSampleCursor,
        ) -> bool;

        /// This method tests a boundary in the reordering from decode order to presentation order, determining whether it's possible for any sample later in decode order than the sample at the position of the receiver can have a presentation timestamp earlier than that of the specified sample cursor.
        ///
        /// Parameter `cursor`: An instance of AVSampleCursor with which to test the sample reordering boundary.
        ///
        /// Returns: YES if it's possible for any sample later in decode order than the sample at the position of the receiver can have a presentation timestamp earlier than that of the specified sample cursor.
        ///
        /// If the receiver and cursor reference different sequences of samples, as when they're created by different instances of AVAssetTrack, results are undefined.
        #[unsafe(method(samplesWithLaterDecodeTimeStampsMayHaveEarlierPresentationTimeStampsThanCursor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn samplesWithLaterDecodeTimeStampsMayHaveEarlierPresentationTimeStampsThanCursor(
            &self,
            cursor: &AVSampleCursor,
        ) -> bool;
    );
}

/// A struct for describing attributes of a media sample for consideration when resynchronizing a decoder.
/// Field: sampleIsFullSync
/// Indicates whether the sample is a full sync sample, also known as an Instantaneous Decoder Refresh sample, and is sufficient in itself to completely resynchronize a decoder.
/// Field: sampleIsPartialSync
/// Indicates whether the sample is a partial sync sample.
/// Field: sampleIsDroppable
/// Indicates whether the sample is droppable.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplecursorsyncinfo?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AVSampleCursorSyncInfo {
    pub sampleIsFullSync: Bool,
    pub sampleIsPartialSync: Bool,
    pub sampleIsDroppable: Bool,
}

unsafe impl Encode for AVSampleCursorSyncInfo {
    const ENCODING: Encoding =
        Encoding::Struct("?", &[<Bool>::ENCODING, <Bool>::ENCODING, <Bool>::ENCODING]);
}

unsafe impl RefEncode for AVSampleCursorSyncInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A struct for describing dependencies between a media sample and other media samples in the same sample sequence.
/// Field: sampleIndicatesWhetherItHasDependentSamples
/// Indicates whether the presence or absence of other samples that are dependent on the sample is known.
/// Field: sampleHasDependentSamples
/// If sampleIndicatesWhetherItHasDependentSamples is YES, indicates whether the sample has dependent samples.
/// Field: sampleIndicatesWhetherItDependsOnOthers
/// Indicates whether the sample's independency from other samples or dependency on other samples is known.
/// Field: sampleDependsOnOthers
/// If sampleIndicatesWhetherItDependsOnOthers is YES, indicates whether the sample depends on other media samples.
/// Field: sampleIndicatesWhetherItHasRedundantCoding
/// Indicates whether the presence of redundant coding of the sample is known.
/// Field: sampleHasRedundantCoding
/// If sampleIndicatesWhetherItHasRedundantCoding is YES, indicates whether the sample has redundant coding.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplecursordependencyinfo?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AVSampleCursorDependencyInfo {
    pub sampleIndicatesWhetherItHasDependentSamples: Bool,
    pub sampleHasDependentSamples: Bool,
    pub sampleIndicatesWhetherItDependsOnOthers: Bool,
    pub sampleDependsOnOthers: Bool,
    pub sampleIndicatesWhetherItHasRedundantCoding: Bool,
    pub sampleHasRedundantCoding: Bool,
}

unsafe impl Encode for AVSampleCursorDependencyInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <Bool>::ENCODING,
            <Bool>::ENCODING,
            <Bool>::ENCODING,
            <Bool>::ENCODING,
            <Bool>::ENCODING,
            <Bool>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for AVSampleCursorDependencyInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A struct for describing the independent decodability of audio samples
/// Field: audioSampleIsIndependentlyDecodable
/// Indicates whether the sample is independently decodable.  Will be YES for Immediate Playout Frames (IPFs) and Independent Frames (IFs).
/// Field: audioSamplePacketRefreshCount
/// If audioSampleIsIndependentlyDecodable is YES, indicates how many samples, starting at this sample, must be fed to the decoder to achieve full decoder refresh.  Will be zero for Immediate Playout Frames (IPFs).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplecursoraudiodependencyinfo?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AVSampleCursorAudioDependencyInfo {
    pub audioSampleIsIndependentlyDecodable: Bool,
    pub audioSamplePacketRefreshCount: NSInteger,
}

unsafe impl Encode for AVSampleCursorAudioDependencyInfo {
    const ENCODING: Encoding = Encoding::Struct("?", &[<Bool>::ENCODING, <NSInteger>::ENCODING]);
}

unsafe impl RefEncode for AVSampleCursorAudioDependencyInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// AVSampleCursorCurrentSampleInfo.
impl AVSampleCursor {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// Indicates the decode duration of the sample at the receiver's current position.
        ///
        /// If the receiver must be advanced past its current position in order to determine the decode duration of the current sample, the value of currentSampleDuration is equal to kCMTimeIndefinite. This can occur with streaming formats such as MPEG-2 transport streams.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentSampleDuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentSampleDuration(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// Provides the format description of the sample at the receiver's current position.
        #[unsafe(method(copyCurrentSampleFormatDescription))]
        #[unsafe(method_family = copy)]
        pub unsafe fn copyCurrentSampleFormatDescription(&self) -> Retained<CMFormatDescription>;

        /// Provides information about the current sample for consideration when resynchronizing a decoder, as when scrubbing.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentSampleSyncInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentSampleSyncInfo(&self) -> AVSampleCursorSyncInfo;

        /// Provides information about dependencies between a media sample and other media samples in the same sample sequence, if known.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentSampleDependencyInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentSampleDependencyInfo(&self) -> AVSampleCursorDependencyInfo;

        /// Provides a dictionary containing dependency related sample buffer attachments, if known.  See kCMSampleAttachmentKey_... in CoreMedia/CMSampleBuffer.h.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentSampleDependencyAttachments))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentSampleDependencyAttachments(&self) -> Option<Retained<NSDictionary>>;

        /// Provides information about the independent decodability of an audio sample.
        ///
        /// In order to position a sample cursor at the first sample that the audio decoder requires for a full refresh, you will need to walk it back from
        /// the current sample until you find a sample that is independently decodable, and whose audioSamplePacketRefreshCount is greater than or equal to
        /// the number of steps back you have taken.  This implies that if the current sample (before this walk) is independently decodable, with an
        /// audioSampleRefreshCount of zero, no walk is required.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentSampleAudioDependencyInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentSampleAudioDependencyInfo(&self) -> AVSampleCursorAudioDependencyInfo;

        /// Count of samples prior to the current sample, in decode order, that the decoder requires in order to achieve fully coherent output at the current decode time, as after a seek. Zero will be returned if no samples are required for decoder refresh or if the track does not contain this information.
        ///
        /// Some sample sequences that do not indicate sample dependencies may instead indicate that in order for a specific sample to be decoded with all available accuracy, samples prior to that sample in decode order must be decoded before the specific sample is decoded.
        ///
        /// In order to position a sample cursor at the first sample that the decoder requires for a full refresh, you can use code like the following:
        ///
        /// NSInteger samplesPriorToCurrentSampleToFeedToDecoder = [mySampleCursor samplesRequiredForDecoderRefresh];
        /// AVSampleCursor *cursorForObtainingRefreshSamples = [mySampleCursor copy];
        /// [cursorForObtainingRefreshSamples stepInDecodeOrderByCount: -samplesPriorToCurrentSampleToFeedToDecoder ];
        ///
        /// // cursorForObtainingRefreshSamples is now positioned at the first sample that must be provided to the decoder
        /// // in order to decode the sample at the position of mySampleCursor in full
        ///
        /// This property is not atomic.
        #[unsafe(method(samplesRequiredForDecoderRefresh))]
        #[unsafe(method_family = none)]
        pub unsafe fn samplesRequiredForDecoderRefresh(&self) -> NSInteger;
    );
}

/// A struct for indicating the offset and length of storage occupied by a media sample or its chunk.
/// Field: offset
/// The offset of the first byte of storage occupied by a media sample or its chunk.
/// Field: length
/// The count of bytes of storage occupied by a media sample or its chunk.
///
/// Like NSRange, but rangier.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplecursorstoragerange?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AVSampleCursorStorageRange {
    pub offset: i64,
    pub length: i64,
}

unsafe impl Encode for AVSampleCursorStorageRange {
    const ENCODING: Encoding = Encoding::Struct("?", &[<i64>::ENCODING, <i64>::ENCODING]);
}

unsafe impl RefEncode for AVSampleCursorStorageRange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Provides information about a chunk of media samples.
/// Field: chunkSampleCount
/// The count of media samples in the chunk.
/// Field: chunkHasUniformSampleSizes
/// YES if all of the samples in the chunk occupy the same number of bytes in storage.
/// Field: currentChunkHasUniformSampleDurations
/// YES if all of the samples in the chunk have the same duration.
/// Field: currentChunkHasUniformFormatDescriptions
/// YES if all of the samples in the chunk have the same format description.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplecursorchunkinfo?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AVSampleCursorChunkInfo {
    pub chunkSampleCount: i64,
    pub chunkHasUniformSampleSizes: Bool,
    pub chunkHasUniformSampleDurations: Bool,
    pub chunkHasUniformFormatDescriptions: Bool,
}

unsafe impl Encode for AVSampleCursorChunkInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <i64>::ENCODING,
            <Bool>::ENCODING,
            <Bool>::ENCODING,
            <Bool>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for AVSampleCursorChunkInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// AVSampleCursorSampleStorageInfo.
impl AVSampleCursor {
    extern_methods!(
        /// The URL of the storage container of the current sample, as well as other samples that are intended to be loaded in the same operation as a "chunk".
        ///
        /// May be nil; if nil, the storage location of the chunk is the URL of the sample cursor's track's asset, if it has one.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentChunkStorageURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentChunkStorageURL(&self) -> Option<Retained<NSURL>>;

        /// The offset and length of samples in currentChunkStorageURL that are intended to be loaded together with the current sample as a "chunk".
        ///
        /// If the current chunk isn't stored contiguously in its storage container, currentChunkStorageRange.offset will be -1. In such cases you can use AVSampleBufferGenerator to obtain the sample data.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentChunkStorageRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentChunkStorageRange(&self) -> AVSampleCursorStorageRange;

        /// Provides information about the "chunk" of samples to which the current sample belongs. If the media format that defines the sequence of samples does not signal "chunking" of samples in any way, each sample will be considered by the receiver as belonging to a chunk of one sample only.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentChunkInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentChunkInfo(&self) -> AVSampleCursorChunkInfo;

        /// The index of the current sample within the chunk to which it belongs.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentSampleIndexInChunk))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentSampleIndexInChunk(&self) -> i64;

        /// The offset and length of the current sample in currentChunkStorageURL.
        ///
        /// If the current sample isn't stored contiguously in its storage container, currentSampleStorageRange.offset will be -1. In such cases you can use AVSampleBufferGenerator to obtain the sample data.
        ///
        /// This property is not atomic.
        #[unsafe(method(currentSampleStorageRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentSampleStorageRange(&self) -> AVSampleCursorStorageRange;
    );
}
