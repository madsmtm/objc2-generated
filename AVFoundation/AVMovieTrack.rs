//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmovietrack?language=objc)
    #[unsafe(super(AVAssetTrack, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AVAssetTrack")]
    pub struct AVMovieTrack;
);

#[cfg(all(feature = "AVAssetTrack", feature = "AVAsynchronousKeyValueLoading"))]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVMovieTrack {}
);

#[cfg(feature = "AVAssetTrack")]
extern_conformance!(
    unsafe impl NSCopying for AVMovieTrack {}
);

#[cfg(feature = "AVAssetTrack")]
unsafe impl CopyingHelper for AVMovieTrack {
    type Result = Self;
}

#[cfg(feature = "AVAssetTrack")]
extern_conformance!(
    unsafe impl NSObjectProtocol for AVMovieTrack {}
);

#[cfg(feature = "AVAssetTrack")]
impl AVMovieTrack {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// A CMTimeRange indicating the range of presentation times for the track's media.
        #[unsafe(method(mediaPresentationTimeRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaPresentationTimeRange(&self) -> CMTimeRange;

        #[cfg(feature = "objc2-core-media")]
        /// A CMTimeRange indicating the range of decode times for the track's media.
        #[unsafe(method(mediaDecodeTimeRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaDecodeTimeRange(&self) -> CMTimeRange;

        #[unsafe(method(alternateGroupID))]
        #[unsafe(method_family = none)]
        pub unsafe fn alternateGroupID(&self) -> NSInteger;
    );
}

/// Methods declared on superclass `AVAssetTrack`.
#[cfg(feature = "AVAssetTrack")]
impl AVMovieTrack {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVMovieTrackMediaDataStorage.
#[cfg(feature = "AVAssetTrack")]
impl AVMovieTrack {
    extern_methods!(
        #[cfg(feature = "AVMovie")]
        /// The storage container for media data added to a track.
        ///
        /// The value of this property is an AVMediaDataStorage object that indicates the location at which media data inserted or appended to the track will be written.
        #[unsafe(method(mediaDataStorage))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaDataStorage(&self) -> Option<Retained<AVMediaDataStorage>>;
    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmutablemovietrack?language=objc)
    #[unsafe(super(AVMovieTrack, AVAssetTrack, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AVAssetTrack")]
    pub struct AVMutableMovieTrack;
);

#[cfg(all(feature = "AVAssetTrack", feature = "AVAsynchronousKeyValueLoading"))]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVMutableMovieTrack {}
);

#[cfg(feature = "AVAssetTrack")]
extern_conformance!(
    unsafe impl NSCopying for AVMutableMovieTrack {}
);

#[cfg(feature = "AVAssetTrack")]
unsafe impl CopyingHelper for AVMutableMovieTrack {
    type Result = Self;
}

#[cfg(feature = "AVAssetTrack")]
extern_conformance!(
    unsafe impl NSObjectProtocol for AVMutableMovieTrack {}
);

#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        #[cfg(feature = "AVMovie")]
        /// The storage container for media data added to a track.
        ///
        /// The value of this property is an AVMediaDataStorage object that indicates the location at which media data inserted or appended to the track will be written.
        #[unsafe(method(mediaDataStorage))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaDataStorage(&self) -> Option<Retained<AVMediaDataStorage>>;

        #[cfg(feature = "AVMovie")]
        /// Setter for [`mediaDataStorage`][Self::mediaDataStorage].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMediaDataStorage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMediaDataStorage(&self, media_data_storage: Option<&AVMediaDataStorage>);

        /// For file types that support writing sample references, such as QuickTime Movie files, specifies the base URL that sample references are relative to; may be nil.
        ///
        /// If the value of this property can be resolved as an absolute URL, the sample locations written to the file when appending sample references to this track will be relative to this URL. The URL must point to a location contained by any common parent directory of the locations that will be referenced. For example, setting the sampleReferenceBaseURL property to "file:///Users/johnappleseed/Movies/" and appending sample buffers that refer to "file:///Users/johnappleseed/Movies/data/movie1.mov" will cause the sample reference "data/movie1.mov" to be written to the movie file.
        ///
        /// If the value of the property cannot be resolved as an absolute URL or if it points to a location that is not contained by any common parent directory of the locations that will be referenced, the location will be written unmodified.
        ///
        /// The default value is nil, which means that the location will be written unmodified.
        #[unsafe(method(sampleReferenceBaseURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn sampleReferenceBaseURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`sampleReferenceBaseURL`][Self::sampleReferenceBaseURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSampleReferenceBaseURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSampleReferenceBaseURL(&self, sample_reference_base_url: Option<&NSURL>);

        /// A BOOL value indicating whether the track is enabled by default for presentation.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);

        /// An integer indicating the track as a member of a particular alternate group.
        #[unsafe(method(alternateGroupID))]
        #[unsafe(method_family = none)]
        pub unsafe fn alternateGroupID(&self) -> NSInteger;

        /// Setter for [`alternateGroupID`][Self::alternateGroupID].
        #[unsafe(method(setAlternateGroupID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAlternateGroupID(&self, alternate_group_id: NSInteger);

        /// Whether a track has been modified.
        ///
        /// The value of this property is a BOOL that indicates whether the AVMutableMovieTrack object has been modified since it was created, was last written, or had its modified state cleared via a call to setModified:NO.
        #[unsafe(method(isModified))]
        #[unsafe(method_family = none)]
        pub unsafe fn isModified(&self) -> bool;

        /// Setter for [`isModified`][Self::isModified].
        #[unsafe(method(setModified:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setModified(&self, modified: bool);

        /// Whether a track contains protected content.
        ///
        /// The value of this property is a BOOL that indicates whether the track contains protected content.
        #[unsafe(method(hasProtectedContent))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasProtectedContent(&self) -> bool;

        #[cfg(feature = "objc2-core-media")]
        /// For file types that contain a 'moov' atom, such as QuickTime Movie files, specifies the time scale of the track's media.
        ///
        /// The default media time scale is 0.
        ///
        /// This property should be set on a new empty track before any edits are performed on the track.
        #[unsafe(method(timescale))]
        #[unsafe(method_family = none)]
        pub unsafe fn timescale(&self) -> CMTimeScale;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`timescale`][Self::timescale].
        #[unsafe(method(setTimescale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimescale(&self, timescale: CMTimeScale);
    );
}

/// Methods declared on superclass `AVAssetTrack`.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVMutableMovieTrackLanguageProperties.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        /// The language associated with the track.
        ///
        /// The value of this property is an ISO 639-2/T language code indicating the language associated with the track; may be nil if no language is indicated.
        #[unsafe(method(languageCode))]
        #[unsafe(method_family = none)]
        pub unsafe fn languageCode(&self) -> Option<Retained<NSString>>;

        /// Setter for [`languageCode`][Self::languageCode].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLanguageCode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLanguageCode(&self, language_code: Option<&NSString>);

        /// The language tag associated with the track.
        ///
        /// The value of this property is an IETF BCP 47 (RFC 4646) language identifier indicating the language tag associated with the track; may be nil if no language tag is indicated.
        #[unsafe(method(extendedLanguageTag))]
        #[unsafe(method_family = none)]
        pub unsafe fn extendedLanguageTag(&self) -> Option<Retained<NSString>>;

        /// Setter for [`extendedLanguageTag`][Self::extendedLanguageTag].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExtendedLanguageTag:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExtendedLanguageTag(&self, extended_language_tag: Option<&NSString>);
    );
}

/// AVMutableMovieTrackVisualProperties.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        /// A CGSize indicating the dimensions at which the visual media data of the track should be displayed.
        #[unsafe(method(naturalSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn naturalSize(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`naturalSize`][Self::naturalSize].
        #[unsafe(method(setNaturalSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNaturalSize(&self, natural_size: CGSize);

        #[cfg(feature = "objc2-core-foundation")]
        /// A CGAffineTransform indicating the transform specified in the track's storage container as the preferred transformation of the visual media data for display purposes; the value is often but not always CGAffineTransformIdentity.
        #[unsafe(method(preferredTransform))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredTransform(&self) -> CGAffineTransform;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`preferredTransform`][Self::preferredTransform].
        #[unsafe(method(setPreferredTransform:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredTransform(&self, preferred_transform: CGAffineTransform);

        /// The layer level of the visual media data of the track.
        #[unsafe(method(layer))]
        #[unsafe(method_family = none)]
        pub unsafe fn layer(&self) -> NSInteger;

        /// Setter for [`layer`][Self::layer].
        #[unsafe(method(setLayer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLayer(&self, layer: NSInteger);

        #[cfg(feature = "objc2-core-foundation")]
        /// A CGSize indicating the clean aperture dimensions of the track.
        #[unsafe(method(cleanApertureDimensions))]
        #[unsafe(method_family = none)]
        pub unsafe fn cleanApertureDimensions(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`cleanApertureDimensions`][Self::cleanApertureDimensions].
        #[unsafe(method(setCleanApertureDimensions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCleanApertureDimensions(&self, clean_aperture_dimensions: CGSize);

        #[cfg(feature = "objc2-core-foundation")]
        /// A CGSize indicating the production aperture dimensions of the track.
        #[unsafe(method(productionApertureDimensions))]
        #[unsafe(method_family = none)]
        pub unsafe fn productionApertureDimensions(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`productionApertureDimensions`][Self::productionApertureDimensions].
        #[unsafe(method(setProductionApertureDimensions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProductionApertureDimensions(
            &self,
            production_aperture_dimensions: CGSize,
        );

        #[cfg(feature = "objc2-core-foundation")]
        /// A CGSize indicating the dimensions encoded pixels dimensions of the track.
        #[unsafe(method(encodedPixelsDimensions))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodedPixelsDimensions(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`encodedPixelsDimensions`][Self::encodedPixelsDimensions].
        #[unsafe(method(setEncodedPixelsDimensions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEncodedPixelsDimensions(&self, encoded_pixels_dimensions: CGSize);
    );
}

/// AVMutableMovieTrackAudibleProperties.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        /// The preferred volume of the audible media data of the track; often but not always 1.0.
        #[unsafe(method(preferredVolume))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredVolume(&self) -> c_float;

        /// Setter for [`preferredVolume`][Self::preferredVolume].
        #[unsafe(method(setPreferredVolume:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredVolume(&self, preferred_volume: c_float);
    );
}

/// AVMutableMovieTrackChunkProperties.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        /// For file types that support media chunk sizes, the maximum size (in bytes) to be used for each chunk of sample data written to the file.
        ///
        /// The total size of the samples in a chunk will be no larger than this preferred chunk size, or the size of a single sample if the sample is larger than this preferred chunk size.
        ///
        /// The default media chunk size is 1024 * 1024 bytes. It is an error to set a negative chunk size.
        #[unsafe(method(preferredMediaChunkSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredMediaChunkSize(&self) -> NSInteger;

        /// Setter for [`preferredMediaChunkSize`][Self::preferredMediaChunkSize].
        #[unsafe(method(setPreferredMediaChunkSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredMediaChunkSize(&self, preferred_media_chunk_size: NSInteger);

        #[cfg(feature = "objc2-core-media")]
        /// For file types that support media chunk durations, the maximum duration to be used for each chunk of sample data written to the file.
        ///
        ///
        /// The total duration of the samples in a chunk will be no greater than this preferred chunk duration, or the duration of a single sample if the sample's duration is greater than this preferred chunk duration.
        ///
        /// The default media chunk duration is 1.0 second. It is an error to set a chunk duration that is negative or non-numeric.
        #[unsafe(method(preferredMediaChunkDuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredMediaChunkDuration(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`preferredMediaChunkDuration`][Self::preferredMediaChunkDuration].
        #[unsafe(method(setPreferredMediaChunkDuration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredMediaChunkDuration(&self, preferred_media_chunk_duration: CMTime);

        /// For file types that support media chunk alignment, the boundary for media chunk alignment (in bytes).
        ///
        ///
        /// The default value is 0, which means that no padding should be used to achieve chunk alignment. It is an error to set a negative value for chunk alignment.
        #[unsafe(method(preferredMediaChunkAlignment))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredMediaChunkAlignment(&self) -> NSInteger;

        /// Setter for [`preferredMediaChunkAlignment`][Self::preferredMediaChunkAlignment].
        #[unsafe(method(setPreferredMediaChunkAlignment:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredMediaChunkAlignment(
            &self,
            preferred_media_chunk_alignment: NSInteger,
        );
    );
}

/// AVMutableMovieTrackTrackLevelEditing.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// Inserts a portion of an AVAssetTrack object into the target movie.
        ///
        /// Parameter `timeRange`: The time range from the track from which media is to be inserted.
        ///
        /// Parameter `track`: An AVAssetTrack object indicating the source of the inserted media. Only AVAssetTracks of AVURLAssets and AVCompositions are supported.
        /// Must not be nil.
        ///
        /// Parameter `startTime`: The time in the target track at which the media is to be inserted.
        ///
        /// Parameter `copySampleData`: A BOOL value that indicates whether sample data is to be copied from the source to the destination during edits.
        /// If YES, the sample data is written to the file specified by the track property mediaDataStorage if non-nil,
        /// or else by the movie property defaultMediaDataStorage if non-nil; if both are nil, the method will fail and return NO.
        /// If NO, sample data will not be written and sample references to the samples in their original container will be added
        /// as necessary. Note that in this case, this method will fail if the original samples are fragmented.
        ///
        /// Parameter `outError`: If the insertion fails, describes the nature of the failure.
        ///
        /// Returns: A BOOL value that indicates the success of the insertion.
        #[unsafe(method(insertTimeRange:ofTrack:atTime:copySampleData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertTimeRange_ofTrack_atTime_copySampleData_error(
            &self,
            time_range: CMTimeRange,
            track: &AVAssetTrack,
            start_time: CMTime,
            copy_sample_data: bool,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-core-media")]
        /// Adds an empty time range to the target track.
        ///
        /// Parameter `timeRange`: The time range to be made empty. Note that you cannot add empty time ranges to the end of a track.
        #[unsafe(method(insertEmptyTimeRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertEmptyTimeRange(&self, time_range: CMTimeRange);

        #[cfg(feature = "objc2-core-media")]
        /// Removes a specified time range from a track.
        ///
        /// Parameter `timeRange`: The time range to be removed.
        #[unsafe(method(removeTimeRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTimeRange(&self, time_range: CMTimeRange);

        #[cfg(feature = "objc2-core-media")]
        /// Changes the duration of a time range of a track.
        ///
        /// Parameter `timeRange`: The time range to be scaled.
        ///
        /// Parameter `duration`: The new duration of the time range.
        #[unsafe(method(scaleTimeRange:toDuration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scaleTimeRange_toDuration(&self, time_range: CMTimeRange, duration: CMTime);
    );
}

/// AVMutableMovieTrackMetadataEditing.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        #[cfg(feature = "AVMetadataItem")]
        /// A collection of metadata stored by the track.
        ///
        /// The value of this property is an array of AVMetadataItem objects representing the collection of metadata stored by the track.
        #[unsafe(method(metadata))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadata(&self) -> Retained<NSArray<AVMetadataItem>>;

        #[cfg(feature = "AVMetadataItem")]
        /// Setter for [`metadata`][Self::metadata].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMetadata:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMetadata(&self, metadata: &NSArray<AVMetadataItem>);
    );
}

/// AVMutableMovieTrackTrackAssociations.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        /// Establishes a track association of a specific type between two tracks.
        ///
        /// Parameter `movieTrack`: An AVMovieTrack object that is to be associated with the receiver.
        ///
        /// Parameter `trackAssociationType`: The type of track association to add between the receiver and the specified movieTrack (for instance, AVTrackAssociationTypeChapterList).
        ///
        /// This method throws an exception if the movie track belongs to a different movie.
        #[unsafe(method(addTrackAssociationToTrack:type:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTrackAssociationToTrack_type(
            &self,
            movie_track: &AVMovieTrack,
            track_association_type: &AVTrackAssociationType,
        );

        /// Removes a track association of a specific type between two tracks.
        ///
        /// Parameter `movieTrack`: An AVMovieTrack object that is associated with the receiver.
        ///
        /// Parameter `trackAssociationType`: The type of track association to remove between the receiver and the specified movieTrack (for instance, AVTrackAssociationTypeChapterList).
        ///
        /// This method throws an exception if the movie track belongs to a different movie.
        #[unsafe(method(removeTrackAssociationToTrack:type:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTrackAssociationToTrack_type(
            &self,
            movie_track: &AVMovieTrack,
            track_association_type: &AVTrackAssociationType,
        );
    );
}

/// AVMutableMovieTrackFormatDescriptions.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// Replaces one of the receiver's format descriptions with another format description
        ///
        /// Parameter `formatDescription`: A CMFormatDescription occurring in the array returned by the -formatDescriptions method.
        ///
        /// Parameter `newFormatDescription`: A CMFormatDescription to replace the specified format description.
        ///
        /// You can use this method to make surgical changes to a track's format descriptions, such as adding format description extensions to a format description or changing the audio channel layout of an audio track. You should note that a format description can have extensions of type kCMFormatDescriptionExtension_VerbatimSampleDescription and kCMFormatDescriptionExtension_VerbatimISOSampleEntry; if you modify a copy of a format description, you should delete those extensions from the copy or your changes might be ignored.
        ///
        /// This method throws an exception if the media type of the new format description does not match the media type of the receiver.
        #[unsafe(method(replaceFormatDescription:withFormatDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn replaceFormatDescription_withFormatDescription(
            &self,
            format_description: &CMFormatDescription,
            new_format_description: &CMFormatDescription,
        );
    );
}

/// AVMutableMovieTrackSampleLevelEditing.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// Appends sample data to a media file and adds sample references for the added data to a track's media sample tables.
        ///
        /// Parameter `sampleBuffer`: The CMSampleBuffer to be appended; this may be obtained from an instance of AVAssetReader.
        ///
        /// Parameter `outDecodeTime`: A pointer to a CMTime structure to receive the decode time in the media of the first sample appended from the sample buffer. Pass NULL if you do not need this information.
        ///
        /// Parameter `outPresentationTime`: A pointer to a CMTime structure to receive the presentation time in the media of the first sample appended from the sample buffer. Pass NULL if you do not need this information.
        ///
        /// Parameter `outError`: If the appending fails, describes the nature of the failure. For example, if the device containing the track's media data storage is full, AVErrorDiskFull is returned.
        ///
        /// Returns: A BOOL value indicating the success of the operation.
        ///
        /// If the sample buffer carries sample data, the sample data is written to the container specified by the track property mediaDataStorage if non-nil,
        /// or else by the movie property defaultMediaDataStorage if non-nil, and sample references will be appended to the track's media.
        /// If both media data storage properties are nil, the method will fail and return NO.
        /// If the sample buffer carries sample references only, sample data will not be written and sample references to the samples in their
        /// original container will be appended to the track's media as necessary.
        ///
        /// Note regarding sample timing: in a track's media, the first sample's decode timestamp must always be zero.
        /// For an audio track, each sample buffer's duration is used as the sample decode duration.
        /// For other track types, difference between a sample's decode timestamp and the following
        /// sample's decode timestamp is used as the first sample's decode duration, so as to preserve the relative timing.
        ///
        /// Note that this method does not modify the track's sourceTimeMappings but only appends sample references and sample data to the track's media.
        /// To make the new samples appear in the track's timeline, invoke -insertMediaTimeRange:intoTimeRange:.
        /// You can retrieve the mediaPresentationTimeRange property before and after appending a sequence of samples,
        /// using CMTimeRangeGetEnd on each to calculate the media TimeRange for -insertMediaTimeRange:intoTimeRange:.
        ///
        /// It's safe for multiple threads to call this method on different tracks at once.
        ///
        /// This method throws an exception for any of the following reasons:
        /// - the sample buffer's media type does not match the track's media type
        /// - the sample buffer contains image buffers (must contain encoded video)
        /// - the sample buffer contains caption groups (must contain encoded media data)
        ///
        /// # Safety
        ///
        /// - `out_decode_time` must be a valid pointer or null.
        /// - `out_presentation_time` must be a valid pointer or null.
        #[unsafe(method(appendSampleBuffer:decodeTime:presentationTime:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn appendSampleBuffer_decodeTime_presentationTime_error(
            &self,
            sample_buffer: &CMSampleBuffer,
            out_decode_time: *mut CMTime,
            out_presentation_time: *mut CMTime,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-core-media")]
        /// Inserts a reference to a media time range into a track.
        ///
        /// Parameter `mediaTimeRange`: The presentation time range of the media to be inserted.
        ///
        /// Parameter `trackTimeRange`: The time range of the track into which the media is to be inserted.
        ///
        /// Returns: A BOOL value indicating the success of the operation.
        ///
        /// Use this method after you have appended samples or sample references to a track's media.
        ///
        /// To specify that the media time range be played at its natural rate, pass mediaTimeRange.duration == trackTimeRange.duration;
        /// otherwise, the ratio between these is used to determine the playback rate.
        ///
        /// Pass kCMTimeInvalid for trackTimeRange.start to indicate that the segment should be appended to the end of the track.
        #[unsafe(method(insertMediaTimeRange:intoTimeRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertMediaTimeRange_intoTimeRange(
            &self,
            media_time_range: CMTimeRange,
            track_time_range: CMTimeRange,
        ) -> bool;
    );
}

extern "C" {
    /// Posted when the timeRange of an AVFragmentedMovieTrack changes while the associated instance of AVFragmentedMovie is being minded by an AVFragmentedMovieMinder, but only for changes that occur after the status of the value of
    /// "
    /// timeRange" has reached AVKeyValueStatusLoaded.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedmovietracktimerangedidchangenotification?language=objc)
    pub static AVFragmentedMovieTrackTimeRangeDidChangeNotification: &'static NSString;
}

extern "C" {
    /// Posted when the array of segments of an AVFragmentedMovieTrack changes while the associated instance of AVFragmentedMovie is being minded by an AVFragmentedMovieMinder, but only for changes that occur after the status of the value of
    /// "
    /// segments" has reached AVKeyValueStatusLoaded.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedmovietracksegmentsdidchangenotification?language=objc)
    pub static AVFragmentedMovieTrackSegmentsDidChangeNotification: &'static NSString;
}

extern "C" {
    /// This notification name has been deprecated. Use either AVFragmentedMovieTrackTimeRangeDidChangeNotification or AVFragmentedMovieTrackSegmentsDidChangeNotification instead; in either case, you can assume that timing changes to fragmented tracks result in changes to the total length of the sample data used by the track.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedmovietracktotalsampledatalengthdidchangenotification?language=objc)
    #[deprecated = "Upon receipt of either AVFragmentedMovieTrackTimeRangeDidChangeNotification or AVFragmentedMovieTrackSegmentsDidChangeNotification, you can assume that the sender's totalSampleDataLength has changed."]
    pub static AVFragmentedMovieTrackTotalSampleDataLengthDidChangeNotification: &'static NSString;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedmovietrack?language=objc)
    #[unsafe(super(AVMovieTrack, AVAssetTrack, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AVAssetTrack")]
    pub struct AVFragmentedMovieTrack;
);

#[cfg(feature = "AVAssetTrack")]
unsafe impl Send for AVFragmentedMovieTrack {}

#[cfg(feature = "AVAssetTrack")]
unsafe impl Sync for AVFragmentedMovieTrack {}

#[cfg(all(feature = "AVAssetTrack", feature = "AVAsynchronousKeyValueLoading"))]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVFragmentedMovieTrack {}
);

#[cfg(feature = "AVAssetTrack")]
extern_conformance!(
    unsafe impl NSCopying for AVFragmentedMovieTrack {}
);

#[cfg(feature = "AVAssetTrack")]
unsafe impl CopyingHelper for AVFragmentedMovieTrack {
    type Result = Self;
}

#[cfg(feature = "AVAssetTrack")]
extern_conformance!(
    unsafe impl NSObjectProtocol for AVFragmentedMovieTrack {}
);

#[cfg(feature = "AVAssetTrack")]
impl AVFragmentedMovieTrack {
    extern_methods!();
}

/// Methods declared on superclass `AVAssetTrack`.
#[cfg(feature = "AVAssetTrack")]
impl AVFragmentedMovieTrack {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// SynchronousTrackInterface.
///
/// Redeclarations of async-only AVAssetTrack interfaces to allow synchronous usage in the synchronous subclass.
///
/// See AVAssetTrack's interface for more information about these interfaces.
#[cfg(feature = "AVAssetTrack")]
impl AVMutableMovieTrack {
    extern_methods!(
        #[cfg(feature = "AVMediaFormat")]
        #[unsafe(method(hasMediaCharacteristic:))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasMediaCharacteristic(
            &self,
            media_characteristic: &AVMediaCharacteristic,
        ) -> bool;

        #[cfg(all(feature = "AVAssetTrackSegment", feature = "objc2-core-media"))]
        #[unsafe(method(segmentForTrackTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn segmentForTrackTime(
            &self,
            track_time: CMTime,
        ) -> Option<Retained<AVAssetTrackSegment>>;

        #[cfg(feature = "objc2-core-media")]
        #[unsafe(method(samplePresentationTimeForTrackTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn samplePresentationTimeForTrackTime(&self, track_time: CMTime) -> CMTime;

        #[cfg(all(feature = "AVMetadataFormat", feature = "AVMetadataItem"))]
        #[unsafe(method(metadataForFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataForFormat(
            &self,
            format: &AVMetadataFormat,
        ) -> Retained<NSArray<AVMetadataItem>>;

        #[unsafe(method(associatedTracksOfType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn associatedTracksOfType(
            &self,
            track_association_type: &AVTrackAssociationType,
        ) -> Retained<NSArray<AVAssetTrack>>;
    );
}
