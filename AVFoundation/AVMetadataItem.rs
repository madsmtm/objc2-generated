//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A metadata item for an audiovisual asset or one of its tracks.
    ///
    /// ## Overview
    ///
    /// To effectively use `AVMetadataItem`, you need to understand how [`AVFoundation`](https://developer.apple.com/documentation/avfoundation) organizes metadata. To simplify finding and filtering metadata items, the framework groups related metadata into key spaces:
    ///
    /// - **Format-specific key spaces.** The framework defines several format-specific key spaces. They roughly correlate to a particular container or file format, such as QuickTime (QuickTime metadata and user data) or MP3 (ID3). However, a single asset may contain metadata values across multiple key spaces. To retrieve an asset’s complete collection of format-specific metadata, you use its [`metadata`](https://developer.apple.com/documentation/avfoundation/avasset/metadata) property.
    ///
    /// - **Common key space.** There are several common metadata values, such as a movie’s creation date or description, that can exist across multiple key spaces. To help normalize access to this common metadata, the framework provides a common key space that gives access to a limited set of metadata values common to several key spaces. This makes it easy to retrieve commonly used metadata without concern for the specific format. To retrieve an asset’s collection of common metadata, you use its [`commonMetadata`](https://developer.apple.com/documentation/avfoundation/avasset/commonmetadata) property.
    ///
    /// Metadata items have keys that accord with the specification of the container format from which they’re drawn. Full details of the metadata formats, metadata keys, and metadata key spaces supported by AVFoundation are available in [`AVMetadataKeySpace`](https://developer.apple.com/documentation/avfoundation/avmetadatakeyspace) and [`AVMetadataKey`](https://developer.apple.com/documentation/avfoundation/avmetadatakey).
    ///
    /// To load values of a metadata item when you access them for the first time, use the methods from the [`AVAsynchronousKeyValueLoading`](https://developer.apple.com/documentation/avfoundation/avasynchronouskeyvalueloading) protocol. The [`AVAsset`](https://developer.apple.com/documentation/avfoundation/avasset) class and other classes in turn provide their metadata as needed so that you can obtain objects from those arrays without incurring overhead for items you don’t inspect.
    ///
    /// To filter arrays of metadata items, you use the methods of this class. For example, you can filter by key and key space, by locale, and by preferred language.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVMetadataItem;
);

#[cfg(feature = "AVAsynchronousKeyValueLoading")]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVMetadataItem {}
);

extern_conformance!(
    unsafe impl NSCopying for AVMetadataItem {}
);

unsafe impl CopyingHelper for AVMetadataItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSMutableCopying for AVMetadataItem {}
);

unsafe impl MutableCopyingHelper for AVMetadataItem {
    type Result = AVMutableMetadataItem;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVMetadataItem {}
);

impl AVMetadataItem {
    extern_methods!(
        #[cfg(feature = "AVMetadataIdentifiers")]
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Option<Retained<AVMetadataIdentifier>>;

        #[unsafe(method(extendedLanguageTag))]
        #[unsafe(method_family = none)]
        pub unsafe fn extendedLanguageTag(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(locale))]
        #[unsafe(method_family = none)]
        pub unsafe fn locale(&self) -> Option<Retained<NSLocale>>;

        #[cfg(feature = "objc2-core-media")]
        #[unsafe(method(time))]
        #[unsafe(method_family = none)]
        pub unsafe fn time(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub unsafe fn duration(&self) -> CMTime;

        #[unsafe(method(dataType))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataType(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(value))]
        #[unsafe(method_family = none)]
        pub unsafe fn value(&self)
            -> Option<Retained<AnyObject /* NSObjectProtocol+ NSCopying */>>;

        #[cfg(feature = "AVMetadataFormat")]
        #[unsafe(method(extraAttributes))]
        #[unsafe(method_family = none)]
        pub unsafe fn extraAttributes(
            &self,
        ) -> Option<Retained<NSDictionary<AVMetadataExtraAttributeKey, AnyObject>>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVMetadataItem {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVMetadataItemDateRepresentation.
impl AVMetadataItem {
    extern_methods!(
        #[unsafe(method(startDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn startDate(&self) -> Option<Retained<NSDate>>;
    );
}

/// AVMetadataItemTypeCoercion.
impl AVMetadataItem {
    extern_methods!(
        #[unsafe(method(stringValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn stringValue(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(numberValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn numberValue(&self) -> Option<Retained<NSNumber>>;

        #[unsafe(method(dateValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn dateValue(&self) -> Option<Retained<NSDate>>;

        #[unsafe(method(dataValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataValue(&self) -> Option<Retained<NSData>>;
    );
}

/// AVAsynchronousKeyValueLoading.
impl AVMetadataItem {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(loadValuesAsynchronouslyForKeys:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadValuesAsynchronouslyForKeys_completionHandler(
            &self,
            keys: &NSArray<NSString>,
            handler: Option<&block2::DynBlock<dyn Fn()>>,
        );
    );
}

/// AVMetadataItemArrayFiltering.
impl AVMetadataItem {
    extern_methods!(
        /// Filters an array of AVMetadataItems according to whether their locales match any language identifier in the specified array of preferred languages. The returned array is sorted according to the order of preference of the language each matches.
        ///
        /// Parameter `metadataItems`: An array of AVMetadataItems to be filtered and sorted.
        ///
        /// Parameter `preferredLanguages`: An array of language identifiers in order of preference, each of which is an IETF BCP 47 (RFC 4646) language identifier. If your goal is to provide the best match for the end user's preferred languages without consideration of your app's available localizations, pass [NSLocale preferredLanguages] as the value of preferredLanguages. However, if you want to filter the available choices in order to obtain the best match among the localizations that are available for your app, pass [NSBundle preferredLocalizationsFromArray:[[NSBundle mainBundle] localizations] forPreferences:[NSLocale preferredLanguages]] instead. The latter choice is normally more appropriate for strings intended for display as part of the app's UI.
        ///
        /// Returns: An instance of NSArray containing metadata items of the specified NSArray that match a preferred language, sorted according to the order of preference of the language each matches.
        #[unsafe(method(metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItemsFromArray_filteredAndSortedAccordingToPreferredLanguages(
            metadata_items: &NSArray<AVMetadataItem>,
            preferred_languages: &NSArray<NSString>,
        ) -> Retained<NSArray<AVMetadataItem>>;

        #[cfg(feature = "AVMetadataIdentifiers")]
        /// Filters an array of AVMetadataItems according to identifier.
        ///
        /// Parameter `metadataItems`: An array of AVMetadataItems to be filtered by identifier.
        ///
        /// Parameter `identifier`: The identifier that must be matched for a metadata item to be copied to the output array. Items are considered a match not only when their identifiers are equal to the specified identifier, and also when their identifiers conform to the specified identifier.
        ///
        /// Returns: An instance of NSArray containing the metadata items of the target NSArray that match the specified identifier.
        #[unsafe(method(metadataItemsFromArray:filteredByIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItemsFromArray_filteredByIdentifier(
            metadata_items: &NSArray<AVMetadataItem>,
            identifier: &AVMetadataIdentifier,
        ) -> Retained<NSArray<AVMetadataItem>>;

        /// Filters an array of AVMetadataItems using the supplied AVMetadataItemFilter.
        ///
        /// Parameter `metadataItems`: An array of AVMetadataItems to be filtered.
        ///
        /// Parameter `metadataItemFilter`: The AVMetadataItemFilter object for filtering the metadataItems.
        ///
        /// Returns: An instance of NSArray containing the metadata items of the target NSArray that have not been removed by metadataItemFilter.
        #[unsafe(method(metadataItemsFromArray:filteredByMetadataItemFilter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItemsFromArray_filteredByMetadataItemFilter(
            metadata_items: &NSArray<AVMetadataItem>,
            metadata_item_filter: &AVMetadataItemFilter,
        ) -> Retained<NSArray<AVMetadataItem>>;
    );
}

/// AVMetadataItemKeyAndKeyspace.
impl AVMetadataItem {
    extern_methods!(
        #[cfg(all(feature = "AVMetadataFormat", feature = "AVMetadataIdentifiers"))]
        /// Provides the metadata identifier that's equivalent to a key and keySpace.
        ///
        /// Parameter `key`: The metadata key.
        ///
        /// Parameter `keySpace`: The metadata keySpace.
        ///
        /// Returns: A metadata identifier equivalent to the given key and keySpace, or nil if no identifier can be constructed from the given key and keySpace.
        ///
        /// Metadata keys that are not instances of NSString, NSNumber, or NSData cannot be converted to metadata identifiers; they also cannot be written to media resources via AVAssetExportSession or AVAssetWriter.  Metadata item keySpaces must be a string of one to four printable ASCII characters.
        ///
        /// For custom identifiers, the keySpace AVMetadataKeySpaceQuickTimeMetadata is recommended.  This keySpace defines its key values to be expressed as reverse-DNS strings, which allows third parties to define their own keys in a well established way that avoids collisions.
        ///
        /// # Safety
        ///
        /// `key` should be of the correct type.
        #[unsafe(method(identifierForKey:keySpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifierForKey_keySpace(
            key: &AnyObject,
            key_space: &AVMetadataKeySpace,
        ) -> Option<Retained<AVMetadataIdentifier>>;

        #[cfg(all(feature = "AVMetadataFormat", feature = "AVMetadataIdentifiers"))]
        #[unsafe(method(keySpaceForIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn keySpaceForIdentifier(
            identifier: &AVMetadataIdentifier,
        ) -> Option<Retained<AVMetadataKeySpace>>;

        #[cfg(feature = "AVMetadataIdentifiers")]
        #[unsafe(method(keyForIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn keyForIdentifier(
            identifier: &AVMetadataIdentifier,
        ) -> Option<Retained<AnyObject>>;

        #[unsafe(method(key))]
        #[unsafe(method_family = none)]
        pub unsafe fn key(&self) -> Option<Retained<AnyObject /* NSObjectProtocol+ NSCopying */>>;

        #[cfg(feature = "AVMetadataFormat")]
        #[unsafe(method(commonKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn commonKey(&self) -> Option<Retained<AVMetadataKey>>;

        #[cfg(feature = "AVMetadataFormat")]
        #[unsafe(method(keySpace))]
        #[unsafe(method_family = none)]
        pub unsafe fn keySpace(&self) -> Option<Retained<AVMetadataKeySpace>>;
    );
}

extern_class!(
    /// A mutable metadata item for an audiovisual asset or for one of its tracks.
    ///
    /// ## Overview
    ///
    /// You can initialize a mutable metadata item from an existing [`AVMetadataItem`](https://developer.apple.com/documentation/avfoundation/avmetadataitem) object or with a one or more of the basic properties of a metadata item: a key, a key space, a locale, and a value.
    ///
    ///
    #[unsafe(super(AVMetadataItem, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVMutableMetadataItem;
);

#[cfg(feature = "AVAsynchronousKeyValueLoading")]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVMutableMetadataItem {}
);

extern_conformance!(
    unsafe impl NSCopying for AVMutableMetadataItem {}
);

unsafe impl CopyingHelper for AVMutableMetadataItem {
    type Result = AVMetadataItem;
}

extern_conformance!(
    unsafe impl NSMutableCopying for AVMutableMetadataItem {}
);

unsafe impl MutableCopyingHelper for AVMutableMetadataItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVMutableMetadataItem {}
);

impl AVMutableMetadataItem {
    extern_methods!(
        #[cfg(feature = "AVMetadataIdentifiers")]
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Option<Retained<AVMetadataIdentifier>>;

        #[cfg(feature = "AVMetadataIdentifiers")]
        /// Setter for [`identifier`][Self::identifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentifier(&self, identifier: Option<&AVMetadataIdentifier>);

        #[unsafe(method(extendedLanguageTag))]
        #[unsafe(method_family = none)]
        pub unsafe fn extendedLanguageTag(&self) -> Option<Retained<NSString>>;

        /// Setter for [`extendedLanguageTag`][Self::extendedLanguageTag].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExtendedLanguageTag:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExtendedLanguageTag(&self, extended_language_tag: Option<&NSString>);

        #[unsafe(method(locale))]
        #[unsafe(method_family = none)]
        pub unsafe fn locale(&self) -> Option<Retained<NSLocale>>;

        /// Setter for [`locale`][Self::locale].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocale(&self, locale: Option<&NSLocale>);

        #[cfg(feature = "objc2-core-media")]
        #[unsafe(method(time))]
        #[unsafe(method_family = none)]
        pub unsafe fn time(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`time`][Self::time].
        #[unsafe(method(setTime:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTime(&self, time: CMTime);

        #[cfg(feature = "objc2-core-media")]
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub unsafe fn duration(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`duration`][Self::duration].
        #[unsafe(method(setDuration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDuration(&self, duration: CMTime);

        #[unsafe(method(dataType))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataType(&self) -> Option<Retained<NSString>>;

        /// Setter for [`dataType`][Self::dataType].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDataType(&self, data_type: Option<&NSString>);

        #[unsafe(method(value))]
        #[unsafe(method_family = none)]
        pub unsafe fn value(&self)
            -> Option<Retained<AnyObject /* NSObjectProtocol+ NSCopying */>>;

        /// Setter for [`value`][Self::value].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `value` should be of the correct type.
        #[unsafe(method(setValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValue(&self, value: Option<&AnyObject /* NSObjectProtocol+ NSCopying */>);

        #[cfg(feature = "AVMetadataFormat")]
        #[unsafe(method(extraAttributes))]
        #[unsafe(method_family = none)]
        pub unsafe fn extraAttributes(
            &self,
        ) -> Option<Retained<NSDictionary<AVMetadataExtraAttributeKey, AnyObject>>>;

        #[cfg(feature = "AVMetadataFormat")]
        /// Setter for [`extraAttributes`][Self::extraAttributes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `extra_attributes` generic should be of the correct type.
        #[unsafe(method(setExtraAttributes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExtraAttributes(
            &self,
            extra_attributes: Option<&NSDictionary<AVMetadataExtraAttributeKey, AnyObject>>,
        );

        /// Returns an instance of AVMutableMetadataItem.
        #[unsafe(method(metadataItem))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItem() -> Retained<AVMutableMetadataItem>;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVMutableMetadataItem {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVMutableMetadataItemDateRepresentation.
impl AVMutableMetadataItem {
    extern_methods!(
        #[unsafe(method(startDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn startDate(&self) -> Option<Retained<NSDate>>;

        /// Setter for [`startDate`][Self::startDate].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setStartDate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStartDate(&self, start_date: Option<&NSDate>);
    );
}

/// AVMutableMetadataItemKeyAndKeyspace.
impl AVMutableMetadataItem {
    extern_methods!(
        #[cfg(feature = "AVMetadataFormat")]
        #[unsafe(method(keySpace))]
        #[unsafe(method_family = none)]
        pub unsafe fn keySpace(&self) -> Option<Retained<AVMetadataKeySpace>>;

        #[cfg(feature = "AVMetadataFormat")]
        /// Setter for [`keySpace`][Self::keySpace].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setKeySpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setKeySpace(&self, key_space: Option<&AVMetadataKeySpace>);

        #[unsafe(method(key))]
        #[unsafe(method_family = none)]
        pub unsafe fn key(&self) -> Option<Retained<AnyObject /* NSObjectProtocol+ NSCopying */>>;

        /// Setter for [`key`][Self::key].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `key` should be of the correct type.
        #[unsafe(method(setKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setKey(&self, key: Option<&AnyObject /* NSObjectProtocol+ NSCopying */>);
    );
}

/// AVMetadataItemLazyValueLoading.
impl AVMetadataItem {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// Creates an instance of AVMutableMetadataItem with a value that you do not wish to load unless required, e.g. a large image value that needn't be loaded into memory until another module wants to display it.
        ///
        /// Parameter `metadataItem`: An instance of AVMetadataItem with the identifier, extendedLanguageTag, and other property values that you want the newly created instance of AVMetadataItem to share. The value of metadataItem is ignored.
        ///
        /// Parameter `handler`: A block that loads the value of the metadata item.
        ///
        /// Returns: An instance of AVMetadataItem.
        ///
        /// This method is intended for the creation of metadata items for optional display purposes, when there is no immediate need to load specific metadata values. For example, see the interface for navigation markers as consumed by AVPlayerViewController. It's not intended for the creation of metadata items with values that are required immediately, such as metadata items that are provided for impending serialization operations (e.g. via -[AVAssetExportSession setMetadata:] and other similar methods defined on AVAssetWriter and AVAssetWriterInput).
        /// When -loadValuesAsynchronouslyForKeys:completionHandler: is invoked on an AVMetadataItem created via +metadataItemWithPropertiesOfMetadataItem:valueLoadingHandler: and
        /// "
        /// value" is among the keys for which loading is requested, the block you provide as the value loading handler will be executed on an arbitrary dispatch queue, off the main thread. The handler can perform I/O and other necessary operations to obtain the value. If loading of the value succeeds, provide the value by invoking -[AVMetadataItemValueRequest respondWithValue:]. If loading of the value fails, provide an instance of NSError that describes the failure by invoking -[AVMetadataItemValueRequest respondWithError:].
        ///
        /// # Safety
        ///
        /// `handler` block must be sendable.
        #[unsafe(method(metadataItemWithPropertiesOfMetadataItem:valueLoadingHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItemWithPropertiesOfMetadataItem_valueLoadingHandler(
            metadata_item: &AVMetadataItem,
            handler: &block2::DynBlock<dyn Fn(NonNull<AVMetadataItemValueRequest>)>,
        ) -> Retained<AVMetadataItem>;
    );
}

extern_class!(
    /// An object that responds to a request to load the value of a metadata item.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVMetadataItemValueRequest;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for AVMetadataItemValueRequest {}
);

impl AVMetadataItemValueRequest {
    extern_methods!(
        #[unsafe(method(metadataItem))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItem(&self) -> Option<Retained<AVMetadataItem>>;

        /// Allows you to respond to an AVMetadataItemValueRequest by providing a value.
        ///
        /// Parameter `value`: The value of the AVMetadataItem.
        ///
        /// # Safety
        ///
        /// `value` should be of the correct type.
        #[unsafe(method(respondWithValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn respondWithValue(
            &self,
            value: &AnyObject, /* NSObjectProtocol+ NSCopying */
        );

        /// Allows you to respond to an AVMetadataItemValueRequest in the case of failure.
        ///
        /// Parameter `error`: An instance of NSError that describes a failure encountered while loading the value of an AVMetadataItem.
        #[unsafe(method(respondWithError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn respondWithError(&self, error: &NSError);
    );
}

/// Methods declared on superclass `NSObject`.
impl AVMetadataItemValueRequest {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object that filters selected information from a metadata item.
    ///
    /// ## Overview
    ///
    /// Filter instances are opaque, unmodifiable objects, that you create with the [`metadataItemFilterForSharing`](https://developer.apple.com/documentation/avfoundation/avmetadataitemfilter/forsharing()) class method.
    ///
    ///
    /// Filters selected information from a metadata item.
    ///
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVMetadataItemFilter;
);

unsafe impl Send for AVMetadataItemFilter {}

unsafe impl Sync for AVMetadataItemFilter {}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVMetadataItemFilter {}
);

impl AVMetadataItemFilter {
    extern_methods!(
        #[unsafe(method(metadataItemFilterForSharing))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItemFilterForSharing() -> Retained<AVMetadataItemFilter>;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVMetadataItemFilter {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVMetadataItemArrayFilteringDeprecable.
impl AVMetadataItem {
    extern_methods!(
        /// Instead, use metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:.
        #[unsafe(method(metadataItemsFromArray:withLocale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItemsFromArray_withLocale(
            metadata_items: &NSArray<AVMetadataItem>,
            locale: &NSLocale,
        ) -> Retained<NSArray<AVMetadataItem>>;

        #[cfg(feature = "AVMetadataFormat")]
        /// Instead, use metadataItemsFromArray:filteredByIdentifier:.
        ///
        /// # Safety
        ///
        /// `key` should be of the correct type.
        #[unsafe(method(metadataItemsFromArray:withKey:keySpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataItemsFromArray_withKey_keySpace(
            metadata_items: &NSArray<AVMetadataItem>,
            key: Option<&AnyObject>,
            key_space: Option<&AVMetadataKeySpace>,
        ) -> Retained<NSArray<AVMetadataItem>>;
    );
}

/// SynchronousMetadataItemInterface.
///
/// Redeclarations of async-only AVMetadataItem interfaces to allow synchronous usage in the mutable subclass.
///
/// See AVMetadataItem's interface for more information about these interfaces.
impl AVMutableMetadataItem {
    extern_methods!();
}
