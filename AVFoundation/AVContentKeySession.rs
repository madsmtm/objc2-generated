//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;

use crate::*;

/// AVContentKeySystem string constants
///
/// Used by AVContentKeySession to determine the method of key delivery
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeysystem?language=objc)
// NS_TYPED_ENUM
pub type AVContentKeySystem = NSString;

extern "C" {
    /// Used to specify FairPlay Streaming (FPS) as the method of key delivery.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeysystemfairplaystreaming?language=objc)
    pub static AVContentKeySystemFairPlayStreaming: &'static AVContentKeySystem;
}

extern "C" {
    /// Used to specify clear key as the method of key delivery.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeysystemclearkey?language=objc)
    pub static AVContentKeySystemClearKey: &'static AVContentKeySystem;
}

extern "C" {
    /// Used to specify a token that could be used to authorize playback of associated content key recipients.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeysystemauthorizationtoken?language=objc)
    pub static AVContentKeySystemAuthorizationToken: &'static AVContentKeySystem;
}

/// Options keys used to specify additional information for generating server playback context (SPC) in
/// -[AVContentKeySession invalidatePersistableContentKey:options:completionHandler:] and
/// -[AVContentKeySession invalidateAllPersistableContentKeysForApp:options:completionHandler:]
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeysessionserverplaybackcontextoption?language=objc)
// NS_TYPED_ENUM
pub type AVContentKeySessionServerPlaybackContextOption = NSString;

extern "C" {
    /// Specifies the versions of the content protection protocol supported by the application; as an NSArray of one or more NSNumber objects. If this option is not set, an appropriate protocol version will be selected based on sideband information such as an associated HLS playlist. If such information is not available, a protocol version of 1 is assumed
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeysessionserverplaybackcontextoptionprotocolversions?language=objc)
    pub static AVContentKeySessionServerPlaybackContextOptionProtocolVersions:
        &'static AVContentKeySessionServerPlaybackContextOption;
}

extern "C" {
    /// Specifies a nonce as a 8-byte NSData object to be included in the secure server playback context (SPC) in order to prevent replay attacks. If not specified default server challenge of 0 is assumed.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeysessionserverplaybackcontextoptionserverchallenge?language=objc)
    pub static AVContentKeySessionServerPlaybackContextOptionServerChallenge:
        &'static AVContentKeySessionServerPlaybackContextOption;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeysession?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVContentKeySession;
);

unsafe impl Send for AVContentKeySession {}

unsafe impl Sync for AVContentKeySession {}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVContentKeySession {}
);

impl AVContentKeySession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// Creates a new instance of AVContentKeySession to manage a collection of media content keys.
        ///
        /// Parameter `keySystem`: A valid key system for retrieving keys.
        ///
        /// Returns: A new AVContentKeySession.
        ///
        /// This method returns an AVContentKeySession instance that is capable of managing collection of media content keys corresponding to the input keySystem. An NSInvalidArgumentException will be raised if the value of keySystem is unsupported.
        #[unsafe(method(contentKeySessionWithKeySystem:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKeySessionWithKeySystem(
            key_system: &AVContentKeySystem,
        ) -> Retained<Self>;

        /// Creates a new instance of AVContentKeySession to manage a collection of media content keys.
        ///
        /// Parameter `keySystem`: A valid key system for retrieving keys.
        ///
        /// Parameter `storageURL`: URL to a writable directory that the session will use to facilitate expired session reports after abnormal session termination.
        ///
        /// Returns: A new AVContentKeySession.
        ///
        /// This method returns an AVContentKeySession instance that is capable of managing collection of media content keys corresponding to the input keySystem. An NSInvalidArgumentException will be raised if the value of keySystem is unsupported.
        #[unsafe(method(contentKeySessionWithKeySystem:storageDirectoryAtURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKeySessionWithKeySystem_storageDirectoryAtURL(
            key_system: &AVContentKeySystem,
            storage_url: &NSURL,
        ) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Sets the receiver's delegate. A delegate is required to handle content key initialization.
        ///
        /// Parameter `delegate`: An object conforming to the AVContentKeySessionDelegate protocol.
        ///
        /// Parameter `delegateQueue`: A dispatch queue on which delegate methods will be invoked whenever processes requiring content keys are executed asynchronously. Passing a value of nil for the delegateQueue parameter along with a non-nil value for the delegate parameter will result in an invalid argument exception.
        #[unsafe(method(setDelegate:queue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate_queue(
            &self,
            delegate: Option<&ProtocolObject<dyn AVContentKeySessionDelegate>>,
            delegate_queue: Option<&DispatchQueue>,
        );

        /// The receiver's delegate.
        ///
        /// The value of this property is an object conforming to the AVContentKeySessionDelegate protocol. The delegate is set using the setDelegate:queue: method.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn AVContentKeySessionDelegate>>>;

        #[cfg(feature = "dispatch2")]
        /// The dispatch queue on which all delegate methods will be invoked whenever processes requiring content keys are executed asynchronously.
        ///
        /// The value of this property is a dispatch_queue_t. The queue is set using the setDelegate:queue: method.
        #[unsafe(method(delegateQueue))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegateQueue(&self) -> Option<Retained<DispatchQueue>>;

        /// The storage URL provided when the AVContentKeySession was created. May be nil.
        ///
        /// URL to a writable directory; may be nil. The session will use this to facilitate expired session reports after abnormal session termination.
        #[unsafe(method(storageURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn storageURL(&self) -> Option<Retained<NSURL>>;

        /// The key system used for retrieving keys
        #[unsafe(method(keySystem))]
        #[unsafe(method_family = none)]
        pub unsafe fn keySystem(&self) -> Retained<AVContentKeySystem>;

        /// Tells the receiver to treat the session as having been intentionally and normally expired.
        ///
        /// When an instance of AVContentKeySession receives an expire message, all of its associated objects conforming to the AVContentKeyRecipient protocol will become inoperable. Send this message only after you have finished operating on the media data.
        #[unsafe(method(expire))]
        #[unsafe(method_family = none)]
        pub unsafe fn expire(&self);

        /// An opaque identifier for the current content protection session.
        ///
        /// May be nil. Will call the delegate's contentKeySessionContentProtectionSessionIdentifierDidChange: when the identifier changes. The protection session ID is a unique string identifier generated by the AVContentKeySession that can be used by the application to identify content key session objects.
        #[unsafe(method(contentProtectionSessionIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentProtectionSessionIdentifier(&self) -> Option<Retained<NSData>>;

        /// Informs the receiver that it should attempt to instantiate a content decryption key using the specified initialization data.
        ///
        /// Parameter `identifier`: Container- and protocol-specific identifier to be used to obtain a key response. Either identifier or initializationData must be non-nil. Both can be non-nil, if the content protection protocol requires both.
        ///
        /// Parameter `initializationData`: Container- and protocol-specific data to be used to obtain a key response. Either identifier or initializationData must be non-nil. Both can be non-nil, if the content protection protocol requires both.
        ///
        /// Parameter `options`: Additional information necessary to obtain the key, or nil if none. See AVContentKeyRequest*Key below.
        ///
        /// May be used to generate an AVContentKeyRequest from request initialization data already in hand, without awaiting such data during the processing of media data of an associated recipient.
        #[unsafe(method(processContentKeyRequestWithIdentifier:initializationData:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn processContentKeyRequestWithIdentifier_initializationData_options(
            &self,
            identifier: Option<&AnyObject>,
            initialization_data: Option<&NSData>,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        );

        /// Informs the receiver that the already provided response data for an earlier AVContentKeyRequest will imminently expire.
        ///
        /// In response the receiver will invoke your delegate with a new content key request entreating it to renew the expiring response data, via -contentKeySession:didProvideRenewingContentKeyRequest:.
        #[unsafe(method(renewExpiringResponseDataForContentKeyRequest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn renewExpiringResponseDataForContentKeyRequest(
            &self,
            content_key_request: &AVContentKeyRequest,
        );

        #[cfg(feature = "block2")]
        /// Creates a secure server playback context (SPC) that the client could send to the key server to obtain an expiration date for the provided persistable content key data.
        ///
        /// Parameter `persistableContentKeyData`: Persistable content key data that was previously created using -[AVContentKeyRequest persistableContentKeyFromKeyVendorResponse:options:error:] or obtained via AVContentKeySessionDelegate callback -contentKeySession:didUpdatePersistableContentKey:forContentKeyIdentifier:.
        ///
        /// Parameter `handler`: Once the secure token is ready, this block will be called with the token or an error describing the failure.
        #[unsafe(method(makeSecureTokenForExpirationDateOfPersistableContentKey:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeSecureTokenForExpirationDateOfPersistableContentKey_completionHandler(
            &self,
            persistable_content_key_data: &NSData,
            handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Invalidates the persistable content key and creates a secure server playback context (SPC) that the client could send to the key server to verify the outcome of invalidation request.
        ///
        /// Parameter `persistableContentKeyData`: Persistable content key data that was previously created using -[AVContentKeyRequest persistableContentKeyFromKeyVendorResponse:options:error:] or obtained via AVContentKeySessionDelegate callback -contentKeySession:didUpdatePersistableContentKey:forContentKeyIdentifier:.
        ///
        /// Parameter `options`: Additional information necessary to generate the server playback context, or nil if none. See AVContentKeySessionServerPlaybackContextOption for supported options.
        ///
        /// Parameter `handler`: Once the server playback context is ready, this block will be called with the data or an error describing the failure.
        ///
        /// Once invalidated, a persistable content key cannot be used to answer key requests during later playback sessions.
        #[unsafe(method(invalidatePersistableContentKey:options:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidatePersistableContentKey_options_completionHandler(
            &self,
            persistable_content_key_data: &NSData,
            options: Option<
                &NSDictionary<AVContentKeySessionServerPlaybackContextOption, AnyObject>,
            >,
            handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Invalidates all persistable content keys associated with the application and creates a secure server playback context (SPC) that the client could send to the key server to verify the outcome of invalidation request.
        ///
        /// Parameter `appIdentifier`: An opaque identifier for the application. The contents of this identifier depend on the particular protocol in use by the entity that controls the use of the media data.
        ///
        /// Parameter `options`: Additional information necessary to generate the server playback context, or nil if none. See AVContentKeySessionServerPlaybackContextOption for supported options.
        ///
        /// Parameter `handler`: Once the server playback context is ready, this block will be called with the data or an error describing the failure.
        ///
        /// Once invalidated, persistable content keys cannot be used to answer key requests during later playback sessions.
        #[unsafe(method(invalidateAllPersistableContentKeysForApp:options:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidateAllPersistableContentKeysForApp_options_completionHandler(
            &self,
            app_identifier: &NSData,
            options: Option<
                &NSDictionary<AVContentKeySessionServerPlaybackContextOption, AnyObject>,
            >,
            handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );
    );
}

/// AVContentKeyRecipients.
impl AVContentKeySession {
    extern_methods!(
        /// Informs the receiver that the specified recipient will be used for the session.
        ///
        /// It is an error to add recipient to sessions that have received an expire message. It is also an error to add recipients after they have already begun to process media data (e.g. after an AVURLAsset has loaded the values of any of its keys). Such errors will result in NSInternalInconsistencyExceptions. Sending this message to an AVContentKeySession is atomic.
        #[unsafe(method(addContentKeyRecipient:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addContentKeyRecipient(
            &self,
            recipient: &ProtocolObject<dyn AVContentKeyRecipient>,
        );

        /// Informs the receiver that the specified recipient will no longer be used.
        ///
        /// After the specified recipient is removed from the receiver it will become inoperable. Remove the recipient only after you have finished operating on the media data associated with it. Sending this message to an AVContentKeySession is atomic.
        #[unsafe(method(removeContentKeyRecipient:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeContentKeyRecipient(
            &self,
            recipient: &ProtocolObject<dyn AVContentKeyRecipient>,
        );

        /// The array of recipients of content keys currently associated with the AVContentKeySession.
        #[unsafe(method(contentKeyRecipients))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKeyRecipients(
            &self,
        ) -> Retained<NSArray<ProtocolObject<dyn AVContentKeyRecipient>>>;
    );
}

/// AVContentKeySessionPendingExpiredSessionReports.
impl AVContentKeySession {
    extern_methods!(
        /// Provides "expired session reports" for prior AVContentKeySessions created with the specified app identifier that have expired either normally or abnormally.
        ///
        /// Parameter `appIdentifier`: An opaque identifier for the application. The contents of this identifier depend on the particular protocol in use by the entity that controls the use of the media data.
        ///
        /// Parameter `storageURL`: URL to a directory previously used with one or more instances of AVContentKeySession for the storage of expired session reports.
        ///
        /// Returns: An NSArray containing instances of NSData, each containing a pending expired session report as a property-list serialization of an NSDictionary object. The contents of expired session reports depend on the particular protocol in use by the entity that controls the use of the media data.
        ///
        /// Note that no reports for sessions still in progress will be included.
        #[unsafe(method(pendingExpiredSessionReportsWithAppIdentifier:storageDirectoryAtURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn pendingExpiredSessionReportsWithAppIdentifier_storageDirectoryAtURL(
            app_identifier: &NSData,
            storage_url: &NSURL,
        ) -> Retained<NSArray<NSData>>;

        /// Removes expired session reports for prior AVContentKeySessions from storage. Once they have been removed, they will no longer be available via subsequent invocations of +pendingExpiredSessionReportsWithAppIdentifier:.
        ///
        /// Parameter `expiredSessionReports`: An array of expired session reports to be discarded.
        ///
        /// Parameter `appIdentifier`: An opaque identifier for the application. The contents of this identifier depend on the particular protocol in use by the entity that controls the use of the media data.
        ///
        /// Parameter `storageURL`: URL to a writable folder.
        ///
        /// This method is most suitable for use only after the specified expired session reports have been sent to the entity that controls the use of the media data and the entity has acknowledged their receipt.
        #[unsafe(method(removePendingExpiredSessionReports:withAppIdentifier:storageDirectoryAtURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removePendingExpiredSessionReports_withAppIdentifier_storageDirectoryAtURL(
            expired_session_reports: &NSArray<NSData>,
            app_identifier: &NSData,
            storage_url: &NSURL,
        );
    );
}

/// AVContentKeyRequestRetryReason string constants
///
/// Used to specify a reason for asking the client to retry a content key request.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyrequestretryreason?language=objc)
// NS_TYPED_ENUM
pub type AVContentKeyRequestRetryReason = NSString;

extern "C" {
    /// Indicates that the content key request should be retried because the key response was not set soon enough either due the initial request/response was taking too long, or a lease was expiring in the meantime.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyrequestretryreasontimedout?language=objc)
    pub static AVContentKeyRequestRetryReasonTimedOut: &'static AVContentKeyRequestRetryReason;
}

extern "C" {
    /// Indicates that the content key request should be retried because a key response with expired lease was set on the previous content key request.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyrequestretryreasonreceivedresponsewithexpiredlease?language=objc)
    pub static AVContentKeyRequestRetryReasonReceivedResponseWithExpiredLease:
        &'static AVContentKeyRequestRetryReason;
}

extern "C" {
    /// Indicates that the content key request should be retried because an obsolete key response was set on the previous content key request.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyrequestretryreasonreceivedobsoletecontentkey?language=objc)
    pub static AVContentKeyRequestRetryReasonReceivedObsoleteContentKey:
        &'static AVContentKeyRequestRetryReason;
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeysessiondelegate?language=objc)
    pub unsafe trait AVContentKeySessionDelegate: NSObjectProtocol {
        #[unsafe(method(contentKeySession:didProvideContentKeyRequest:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_didProvideContentKeyRequest(
            &self,
            session: &AVContentKeySession,
            key_request: &AVContentKeyRequest,
        );

        #[optional]
        #[unsafe(method(contentKeySession:didProvideRenewingContentKeyRequest:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_didProvideRenewingContentKeyRequest(
            &self,
            session: &AVContentKeySession,
            key_request: &AVContentKeyRequest,
        );

        #[optional]
        #[unsafe(method(contentKeySession:didProvidePersistableContentKeyRequest:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_didProvidePersistableContentKeyRequest(
            &self,
            session: &AVContentKeySession,
            key_request: &AVPersistableContentKeyRequest,
        );

        #[optional]
        #[unsafe(method(contentKeySession:didUpdatePersistableContentKey:forContentKeyIdentifier:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_didUpdatePersistableContentKey_forContentKeyIdentifier(
            &self,
            session: &AVContentKeySession,
            persistable_content_key: &NSData,
            key_identifier: &AnyObject,
        );

        #[optional]
        #[unsafe(method(contentKeySession:contentKeyRequest:didFailWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_contentKeyRequest_didFailWithError(
            &self,
            session: &AVContentKeySession,
            key_request: &AVContentKeyRequest,
            err: &NSError,
        );

        #[optional]
        #[unsafe(method(contentKeySession:shouldRetryContentKeyRequest:reason:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_shouldRetryContentKeyRequest_reason(
            &self,
            session: &AVContentKeySession,
            key_request: &AVContentKeyRequest,
            retry_reason: &AVContentKeyRequestRetryReason,
        ) -> bool;

        #[optional]
        #[unsafe(method(contentKeySession:contentKeyRequestDidSucceed:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_contentKeyRequestDidSucceed(
            &self,
            session: &AVContentKeySession,
            key_request: &AVContentKeyRequest,
        );

        #[optional]
        #[unsafe(method(contentKeySessionContentProtectionSessionIdentifierDidChange:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySessionContentProtectionSessionIdentifierDidChange(
            &self,
            session: &AVContentKeySession,
        );

        #[optional]
        #[unsafe(method(contentKeySessionDidGenerateExpiredSessionReport:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySessionDidGenerateExpiredSessionReport(
            &self,
            session: &AVContentKeySession,
        );

        #[optional]
        #[unsafe(method(contentKeySession:externalProtectionStatusDidChangeForContentKey:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_externalProtectionStatusDidChangeForContentKey(
            &self,
            session: &AVContentKeySession,
            content_key: &AVContentKey,
        );

        #[optional]
        #[unsafe(method(contentKeySession:didProvideContentKeyRequests:forInitializationData:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_didProvideContentKeyRequests_forInitializationData(
            &self,
            session: &AVContentKeySession,
            key_requests: &NSArray<AVContentKeyRequest>,
            initialization_data: Option<&NSData>,
        );
    }
);

/// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyrequeststatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVContentKeyRequestStatus(pub NSInteger);
impl AVContentKeyRequestStatus {
    #[doc(alias = "AVContentKeyRequestStatusRequestingResponse")]
    pub const RequestingResponse: Self = Self(0);
    #[doc(alias = "AVContentKeyRequestStatusReceivedResponse")]
    pub const ReceivedResponse: Self = Self(1);
    #[doc(alias = "AVContentKeyRequestStatusRenewed")]
    pub const Renewed: Self = Self(2);
    #[doc(alias = "AVContentKeyRequestStatusRetried")]
    pub const Retried: Self = Self(3);
    #[doc(alias = "AVContentKeyRequestStatusCancelled")]
    pub const Cancelled: Self = Self(4);
    #[doc(alias = "AVContentKeyRequestStatusFailed")]
    pub const Failed: Self = Self(5);
}

unsafe impl Encode for AVContentKeyRequestStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVContentKeyRequestStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyrequestrequiresvalidationdatainsecuretokenkey?language=objc)
    pub static AVContentKeyRequestRequiresValidationDataInSecureTokenKey: &'static NSString;
}

extern_class!(
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyrequest?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVContentKeyRequest;
);

unsafe impl Send for AVContentKeyRequest {}

unsafe impl Sync for AVContentKeyRequest {}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVContentKeyRequest {}
);

impl AVContentKeyRequest {
    extern_methods!(
        /// This describes the state of the AVContentKeyRequest, value is one of AVContentKeyRequestStatus.
        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        pub unsafe fn status(&self) -> AVContentKeyRequestStatus;

        /// If the receiver's status is AVContentKeyRequestStatusFailed, this describes the error that caused the failure.
        ///
        /// The value of this property is an NSError that describes what caused the content key request to fail. If the receiver's status is not AVContentKeyRequestStatusFailed, the value of this property is nil.
        #[unsafe(method(error))]
        #[unsafe(method_family = none)]
        pub unsafe fn error(&self) -> Option<Retained<NSError>>;

        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Option<Retained<AnyObject>>;

        /// This property is not atomic.
        #[unsafe(method(initializationData))]
        #[unsafe(method_family = none)]
        pub unsafe fn initializationData(&self) -> Option<Retained<NSData>>;

        #[unsafe(method(options))]
        #[unsafe(method_family = none)]
        pub unsafe fn options(&self) -> Retained<NSDictionary<NSString, AnyObject>>;

        #[unsafe(method(canProvidePersistableContentKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn canProvidePersistableContentKey(&self) -> bool;

        #[unsafe(method(contentKeySpecifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKeySpecifier(&self) -> Retained<AVContentKeySpecifier>;

        #[unsafe(method(contentKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKey(&self) -> Option<Retained<AVContentKey>>;

        #[cfg(feature = "block2")]
        /// Obtains a content key request data for a specific combination of application and content.
        ///
        /// Parameter `appIdentifier`: An opaque identifier for the application. The value of this identifier depends on the particular system used to provide the content key.
        ///
        /// Parameter `contentIdentifier`: An optional opaque identifier for the content. The value of this identifier depends on the particular system used to provide the content key.
        ///
        /// Parameter `options`: Additional information necessary to obtain the key, or nil if none. See AVContentKeyRequest*Key below.
        ///
        /// Parameter `handler`: Once the streaming content key request is prepared, this block will be called with the request data or an error describing the failure.
        ///
        /// If option AVContentKeyRequestProtocolVersionsKey is not specified the default protocol version of 1 is assumed.
        #[unsafe(method(makeStreamingContentKeyRequestDataForApp:contentIdentifier:options:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeStreamingContentKeyRequestDataForApp_contentIdentifier_options_completionHandler(
            &self,
            app_identifier: &NSData,
            content_identifier: Option<&NSData>,
            options: Option<&NSDictionary<NSString, AnyObject>>,
            handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        /// Informs the receiver to process the specified content key response.
        ///
        /// Parameter `keyResponse`: An instance of AVContentKeyResponse carrying a response to a content key request.
        ///
        /// After you receive an AVContentKeyRequest via -contentKeySession:didProvideContentKeyRequest: and after you invoke -[AVContentKeyRequest makeStreamingContentKeyRequestDataForApp:contentIdentifier:options:completionHandler:] on that request, you must obtain a response to the request in accordance with the protocol in use by the entity that controls the use of the media data. This is the method you use to provide the content key response to make protected content available for processing. If obtaining the content key response fails, use -processContentKeyResponseError:.
        #[unsafe(method(processContentKeyResponse:))]
        #[unsafe(method_family = none)]
        pub unsafe fn processContentKeyResponse(&self, key_response: &AVContentKeyResponse);

        /// Informs the receiver that obtaining a content key response has failed, resulting in failure handling.
        ///
        /// Parameter `error`: An instance of NSError that describes the specific failure that occurred.
        #[unsafe(method(processContentKeyResponseError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn processContentKeyResponseError(&self, error: &NSError);

        /// Informs the receiver to process a persistable content key request.
        ///
        /// When you receive an AVContentKeyRequest via -contentKeySession:didProvideContentKeyRequest: and you want the resulting key response to produce a key that can persist across multiple playback sessions, you must invoke -respondByRequestingPersistableContentKeyRequest on that AVContentKeyRequest in order to signal that you want to process an AVPersistableContentKeyRequest instead. If the underlying protocol supports persistable content keys, in response your delegate will receive an AVPersistableContentKeyRequest via -contentKeySession:didProvidePersistableContentKeyRequest:. NSInternalInconsistencyException will be raised, if you are attempting to create and use a persistable key but your AVContentKeySession delegate does not respond to contentKeySession:didProvidePersistableContentKeyRequest:.
        #[deprecated]
        #[unsafe(method(respondByRequestingPersistableContentKeyRequest))]
        #[unsafe(method_family = none)]
        pub unsafe fn respondByRequestingPersistableContentKeyRequest(&self);

        #[unsafe(method(respondByRequestingPersistableContentKeyRequestAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn respondByRequestingPersistableContentKeyRequestAndReturnError(
            &self,
        ) -> Result<(), Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVContentKeyRequest {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avpersistablecontentkeyrequest?language=objc)
    #[unsafe(super(AVContentKeyRequest, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVPersistableContentKeyRequest;
);

unsafe impl Send for AVPersistableContentKeyRequest {}

unsafe impl Sync for AVPersistableContentKeyRequest {}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVPersistableContentKeyRequest {}
);

impl AVPersistableContentKeyRequest {
    extern_methods!(
        /// Obtains a persistable content key from a context.
        ///
        /// Parameter `keyVendorResponse`: The response returned from the key vendor as a result of a request generated from makeStreamingContentKeyRequestDataForApp:contentIdentifier:options:completionHandler:.
        ///
        /// Parameter `options`: Additional information necessary to obtain the persistable content key, or nil if none.
        ///
        /// Parameter `outError`: If obtaining the persistable content key fails, will be set to an instance of NSError describing the failure.
        ///
        /// Returns: The persistable content key data that may be stored offline to answer future loading requests of the same content key.
        ///
        /// The data returned from this method may be used to immediately satisfy an AVPersistableContentKeyRequest, as well as any subsequent requests for the same key url using processContentKeyResponse: method. When you receive an AVContentKeyRequest via -contentKeySession:didProvideContentKeyRequest: and you want to use existing persistent content key from storage, you must invoke -respondByRequestingPersistableContentKeyRequest on that AVContentKeyRequest in order to signal that you want to process an AVPersistableContentKeyRequest instead. If the underlying protocol supports persistable content keys, in response your delegate will receive an AVPersistableContentKeyRequest via -contentKeySession:didProvidePersistableContentKeyRequest:. You can set the persistent key from storage on the AVPersistableContentKeyRequest using processContentKeyResponse:.
        #[unsafe(method(persistableContentKeyFromKeyVendorResponse:options:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn persistableContentKeyFromKeyVendorResponse_options_error(
            &self,
            key_vendor_response: &NSData,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Result<Retained<NSData>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVPersistableContentKeyRequest {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVContentKeyRequestRenewal.
impl AVContentKeyRequest {
    extern_methods!(
        #[unsafe(method(renewsExpiringResponseData))]
        #[unsafe(method_family = none)]
        pub unsafe fn renewsExpiringResponseData(&self) -> bool;
    );
}

extern_class!(
    /// AVContentKeyResponse is used to represent the data returned from the key server when requesting a key for decrypting content.
    ///
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyresponse?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVContentKeyResponse;
);

unsafe impl Send for AVContentKeyResponse {}

unsafe impl Sync for AVContentKeyResponse {}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVContentKeyResponse {}
);

impl AVContentKeyResponse {
    extern_methods!(
        /// Create an AVContentKeyResponse from the server response to a key request made when using FairPlayStreaming (FPS) as the method of key delivery.
        ///
        /// Parameter `keyResponseData`: The response from the FairPlayStreaming key server
        ///
        /// Returns: A new AVContentKeyResponse holding data from a FairPlayStreaming key server that is used to decrypt the content
        ///
        /// The object created by this method is typically used with an AVContentKeyRequest created by an AVContentKeySession using keySystem AVContentKeySystemFairPlayStreaming. It is passed to AVContentKeyRequest -processContentKeyResponse: in order to supply the decryptor with key data
        #[unsafe(method(contentKeyResponseWithFairPlayStreamingKeyResponseData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKeyResponseWithFairPlayStreamingKeyResponseData(
            key_response_data: &NSData,
        ) -> Retained<Self>;

        /// Create an AVContentKeyResponse from the key and IV when using AVContentKeySystemClearKey as the key system
        ///
        ///
        /// Parameter `keyData`: The key used for decrypting content.
        ///
        /// Parameter `initializationVector`: The initialization vector used for decrypting content, or nil if initialization vector is available in the media to be decrypted
        ///
        /// Returns: A new AVContentKeyResponse holding Clear Key data.
        ///
        /// The object created by this method is typically used with an AVContentKeyRequest created by an AVContentKeySession using keySystem AVContentKeySystemClearKey. It is passed to AVContentKeyRequest -processContentKeyResponse: in order to supply the decryptor with key data.
        #[unsafe(method(contentKeyResponseWithClearKeyData:initializationVector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKeyResponseWithClearKeyData_initializationVector(
            key_data: &NSData,
            initialization_vector: Option<&NSData>,
        ) -> Retained<Self>;

        /// Create an AVContentKeyResponse from authorization token data when using AVContentKeySystemAuthorizationToken key system.
        ///
        /// Parameter `authorizationTokenData`: Data blob containing the authorization token.
        ///
        /// Returns: A new AVContentKeyResponse holding the authorization token data.
        ///
        /// The object created by this method is typically used with an AVContentKeyRequest created by an AVContentKeySession using keySystem AVContentKeySystemAuthorizationToken. It is passed to AVContentKeyRequest -processContentKeyResponse: in order to supply the authorization token data.
        #[unsafe(method(contentKeyResponseWithAuthorizationTokenData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKeyResponseWithAuthorizationTokenData(
            authorization_token_data: &NSData,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVContentKeyResponse {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern "C" {
    /// Specifies the versions of the content protection protocol supported by the application as an NSArray of one or more NSNumber objects.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyrequestprotocolversionskey?language=objc)
    pub static AVContentKeyRequestProtocolVersionsKey: &'static NSString;
}

extern_protocol!(
    /// Classes of objects that may require decryption keys for media data in order to enable processing, such as parsing or playback, conform to this protocol.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyrecipient?language=objc)
    pub unsafe trait AVContentKeyRecipient {
        /// Informs the receiver that an AVContentKey has been obtained as the result of an invocation of -[AVContentKeyRequest processContentKeyResponse:].
        ///
        /// The recipient may employ the AVContentKey for use with objects that support manual attachment of keys, such as CMSampleBuffer via an invocation of AVSampleBufferAttachContentKey.
        #[optional]
        #[unsafe(method(contentKeySession:didProvideContentKey:))]
        #[unsafe(method_family = none)]
        unsafe fn contentKeySession_didProvideContentKey(
            &self,
            content_key_session: &AVContentKeySession,
            content_key: &AVContentKey,
        );

        /// Indicates whether the receiver may require decryption keys for media data in order to enable processing.
        ///
        /// When the value of mayRequireContentKeysForMediaDataProcessing is YES, adding the receiver to an AVContentKeySession allows it to employ the session's already existing keys and also enables the handling of new key requests by the AVContentKeySession's delegate.
        #[unsafe(method(mayRequireContentKeysForMediaDataProcessing))]
        #[unsafe(method_family = none)]
        unsafe fn mayRequireContentKeysForMediaDataProcessing(&self) -> bool;
    }
);

extern_class!(
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkeyspecifier?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVContentKeySpecifier;
);

unsafe impl Send for AVContentKeySpecifier {}

unsafe impl Sync for AVContentKeySpecifier {}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVContentKeySpecifier {}
);

impl AVContentKeySpecifier {
    extern_methods!(
        /// Creates a new instance of AVContentKeySpecifier.
        ///
        /// Parameter `keySystem`: A valid key system for content keys.
        ///
        /// Parameter `contentKeyIdentifier`: Container and protocol-specific key identifier.
        ///
        /// Parameter `options`: Additional information necessary to obtain the key, can be empty if none needed.
        ///
        /// Returns: A new AVContentKeySpecifier
        ///
        /// This method returns an AVContentKeySpecifier instance that represents a content key in a specific content key system.
        #[unsafe(method(contentKeySpecifierForKeySystem:identifier:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKeySpecifierForKeySystem_identifier_options(
            key_system: &AVContentKeySystem,
            content_key_identifier: &AnyObject,
            options: &NSDictionary<NSString, AnyObject>,
        ) -> Retained<Self>;

        /// Initialize an instance of AVContentKeySpecifier.
        ///
        /// Parameter `keySystem`: A valid key system for content keys.
        ///
        /// Parameter `contentKeyIdentifier`: Container and protocol-specific key identifier.
        ///
        /// Parameter `options`: Additional information necessary to obtain the key, can be empty if none needed.
        ///
        /// Returns: An instance of AVContentKeySpecifier
        ///
        /// This method returns an AVContentKeySpecifier instance that represents a content key in a specific content key system.
        #[unsafe(method(initForKeySystem:identifier:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initForKeySystem_identifier_options(
            this: Allocated<Self>,
            key_system: &AVContentKeySystem,
            content_key_identifier: &AnyObject,
            options: &NSDictionary<NSString, AnyObject>,
        ) -> Retained<Self>;

        /// A valid key system for content keys.
        #[unsafe(method(keySystem))]
        #[unsafe(method_family = none)]
        pub unsafe fn keySystem(&self) -> Retained<AVContentKeySystem>;

        /// Container and protocol-specific key identifier.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<AnyObject>;

        #[unsafe(method(options))]
        #[unsafe(method_family = none)]
        pub unsafe fn options(&self) -> Retained<NSDictionary<NSString, AnyObject>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVContentKeySpecifier {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The constants can be used to derive whether or not we have established sufficient protection to display content protected by this AVContentKey on some set of attached displays.
///
///
/// Indicates that the current protection status has not yet been discovered for the attached display(s).
///
/// Indicates that sufficient protection with the attached display(s) has been established, content protected by the associated AVContentKey will be eligible to be displayed on the display(s).
///
/// Indicates that sufficient protection with the attached display(s) has failed to be established, content protected by the associated AVContentKey will not be displayed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avexternalcontentprotectionstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVExternalContentProtectionStatus(pub NSInteger);
impl AVExternalContentProtectionStatus {
    #[doc(alias = "AVExternalContentProtectionStatusPending")]
    pub const Pending: Self = Self(0);
    #[doc(alias = "AVExternalContentProtectionStatusSufficient")]
    pub const Sufficient: Self = Self(1);
    #[doc(alias = "AVExternalContentProtectionStatusInsufficient")]
    pub const Insufficient: Self = Self(2);
}

unsafe impl Encode for AVExternalContentProtectionStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVExternalContentProtectionStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcontentkey?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVContentKey;
);

unsafe impl Send for AVContentKey {}

unsafe impl Sync for AVContentKey {}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVContentKey {}
);

impl AVContentKey {
    extern_methods!(
        #[unsafe(method(contentKeySpecifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentKeySpecifier(&self) -> Retained<AVContentKeySpecifier>;

        /// The external protection status for the AVContentKey based on all attached displays.
        ///
        /// This property is not key-value observable, instead the contentKeySession:externalProtectionStatusDidChangeForContentKey: delegate method should be used.
        #[unsafe(method(externalContentProtectionStatus))]
        #[unsafe(method_family = none)]
        pub unsafe fn externalContentProtectionStatus(&self) -> AVExternalContentProtectionStatus;

        /// Revokes the decryption context of the content key, and removes it from its associated AVContentKeySession.
        ///
        /// Once revoked, the AVContentKey is no longer eligible to be used with any media.
        /// If the key is required again, or if the key is requested to be loaded by the application, a new AVContentKeyRequest will be dispatched to the delegate.
        /// If there is media playback occurring which is dependent on the content key it will fail and may result in an error being generated with the playback halting.
        #[unsafe(method(revoke))]
        #[unsafe(method_family = none)]
        pub unsafe fn revoke(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl AVContentKey {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Attaches an AVContentKey to a CMSampleBuffer for the purpose of content decryption.
///
/// Parameter `sbuf`: The sample buffer to which the content key is to be attached.
///
/// Parameter `contentKey`: The content key to be attached.
///
/// Parameter `outError`: If the result is NO and errorOut is non-NULL, the location referenced by errorOut receives an instance of NSError that describes the reason for failure to attach the content key.
///
/// The client is expected to attach AVContentKeys to CMSampleBuffers that have been created by the client for enqueueing with AVSampleBufferDisplayLayer or AVSampleBufferAudioRenderer, for which the AVContentKeySpecifier matches indications of suitability that are available to the client according to the content key system that's in use.
#[cfg(feature = "objc2-core-media")]
#[inline]
pub unsafe extern "C-unwind" fn AVSampleBufferAttachContentKey(
    sbuf: &CMSampleBuffer,
    content_key: &AVContentKey,
    out_error: *mut *mut NSError,
) -> bool {
    extern "C-unwind" {
        fn AVSampleBufferAttachContentKey(
            sbuf: &CMSampleBuffer,
            content_key: &AVContentKey,
            out_error: *mut *mut NSError,
        ) -> Bool;
    }
    unsafe { AVSampleBufferAttachContentKey(sbuf, content_key, out_error) }.as_bool()
}
