//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-uniform-type-identifiers")]
use objc2_uniform_type_identifiers::*;

use crate::*;

extern_class!(
    /// An AVAsset is an abstract class that defines AVFoundation's model for timed audiovisual media.
    ///
    /// Each asset contains a collection of tracks that are intended to be presented or processed together, each of a uniform media type, including but not limited to audio, video, text, closed captions, and subtitles.
    ///
    /// AVAssets are often instantiated via its concrete subclass AVURLAsset with NSURLs that refer to audiovisual media resources, such as streams (including HTTP live streams), QuickTime movie files, MP3 files, and files of other types.
    ///
    /// They can also be instantiated using other concrete subclasses that extend the basic model for audiovisual media in useful ways, as AVComposition does for temporal editing.
    ///
    /// Properties of assets as a whole are defined by AVAsset. Additionally, references to instances of AVAssetTracks representing tracks of the collection can be obtained, so that each of these can be examined independently.
    ///
    /// Because of the nature of timed audiovisual media, upon successful initialization of an AVAsset some or all of the values for its keys may not be immediately available. The value of any key can be requested at any time, and AVAsset will always return its value synchronously, although it may have to block the calling thread in order to do so.
    ///
    /// In order to avoid blocking, clients can register their interest in particular keys and to become notified when their values become available. For further details, see AVAsynchronousKeyValueLoading.h. For clients who want to examine a subset of the tracks, metadata, and other parts of the asset, asynchronous methods like -loadTracksWithMediaType:completionHandler: can be used to load this information without blocking. When using these asynchronous methods, it is not necessary to load the associated property beforehand. Swift clients can also use the load(:) method to load properties in a type safe manner.
    ///
    /// On platforms other than macOS, it is particularly important to avoid blocking. To preserve responsiveness, a synchronous request that blocks for too long (eg, a property request on an asset on a slow HTTP server) may lead to media services being reset.
    ///
    /// To play an instance of AVAsset, initialize an instance of AVPlayerItem with it, use the AVPlayerItem to set up its presentation state (such as whether only a limited timeRange of the asset should be played, etc.), and provide the AVPlayerItem to an AVPlayer according to whether the items is to be played by itself or together with a collection of other items. Full details available in AVPlayerItem.h and AVPlayer.h.
    ///
    /// AVAssets can also be inserted into AVMutableCompositions in order to assemble audiovisual constructs from one or more source assets.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avasset?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVAsset;
);

#[cfg(feature = "AVAsynchronousKeyValueLoading")]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVAsset {}
);

extern_conformance!(
    unsafe impl NSCopying for AVAsset {}
);

unsafe impl CopyingHelper for AVAsset {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVAsset {}
);

impl AVAsset {
    extern_methods!(
        /// Returns an instance of AVAsset for inspection of a media resource.
        ///
        /// Returns a newly allocated instance of a subclass of AVAsset initialized with the specified URL.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        ///
        /// - Returns: An instance of AVAsset.
        #[unsafe(method(assetWithURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assetWithURL(url: &NSURL) -> Retained<Self>;

        #[cfg(feature = "objc2-core-media")]
        /// Indicates the duration of the asset.
        ///
        /// If
        /// "
        /// providesPreciseDurationAndTiming" is NO, a best-available estimate of the duration is returned. The degree of precision preferred for timing-related properties can be set at initialization time for assets initialized with URLs
        ///
        /// - Seealso: AVURLAssetPreferPreciseDurationAndTimingKey for AVURLAsset below.
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub unsafe fn duration(&self) -> CMTime;

        /// Indicates the natural rate at which the asset is to be played; often but not always 1.0
        #[unsafe(method(preferredRate))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredRate(&self) -> c_float;

        /// Indicates the preferred volume at which the audible media of an asset is to be played; often but not always 1.0
        #[unsafe(method(preferredVolume))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredVolume(&self) -> c_float;

        #[cfg(feature = "objc2-core-foundation")]
        /// Indicates the preferred transform to apply to the visual content of the asset for presentation or processing; the value is often but not always the identity transform
        #[unsafe(method(preferredTransform))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredTransform(&self) -> CGAffineTransform;

        #[cfg(feature = "objc2-core-foundation")]
        /// The following property is deprecated. Instead, use the naturalSize and preferredTransform, as appropriate, of the receiver's video tracks. See -tracksWithMediaType: below.
        #[deprecated = "Use the naturalSize and preferredTransform, as appropriate, of the receiver's video tracks. See -tracksWithMediaType:"]
        #[unsafe(method(naturalSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn naturalSize(&self) -> CGSize;

        #[cfg(feature = "objc2-core-media")]
        /// Indicates how close to the latest content in a live stream playback can be sustained.
        ///
        /// For non-live assets this value is kCMTimeInvalid.
        #[unsafe(method(minimumTimeOffsetFromLive))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumTimeOffsetFromLive(&self) -> CMTime;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVAsset {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVAssetAsynchronousLoading.
impl AVAsset {
    extern_methods!(
        /// Indicates that the asset provides precise timing. See
        /// "
        /// duration" above and AVURLAssetPreferPreciseDurationAndTimingKey below.
        #[unsafe(method(providesPreciseDurationAndTiming))]
        #[unsafe(method_family = none)]
        pub unsafe fn providesPreciseDurationAndTiming(&self) -> bool;

        /// Cancels the loading of all values for all observers.
        ///
        /// Deallocation or finalization of an instance of AVAsset will implicitly cancel loading if any loading requests are still outstanding.
        #[unsafe(method(cancelLoading))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelLoading(&self);
    );
}

/// These constants can be passed in to AVURLAssetReferenceRestrictionsKey to control the resolution of references to external media data.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetreferencerestrictions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVAssetReferenceRestrictions(pub NSUInteger);
bitflags::bitflags! {
    impl AVAssetReferenceRestrictions: NSUInteger {
/// Indicates that all types of references should be followed.
        #[doc(alias = "AVAssetReferenceRestrictionForbidNone")]
        const ForbidNone = 0;
/// Indicates that references from a remote asset (e.g. referenced via http URL) to local media data (e.g. stored in a local file) should not be followed.
        #[doc(alias = "AVAssetReferenceRestrictionForbidRemoteReferenceToLocal")]
        const ForbidRemoteReferenceToLocal = 1<<0;
/// Indicates that references from a local asset to remote media data should not be followed.
        #[doc(alias = "AVAssetReferenceRestrictionForbidLocalReferenceToRemote")]
        const ForbidLocalReferenceToRemote = 1<<1;
/// Indicates that references from a remote asset to remote media data stored at a different site should not be followed.
        #[doc(alias = "AVAssetReferenceRestrictionForbidCrossSiteReference")]
        const ForbidCrossSiteReference = 1<<2;
/// Indicates that references from a local asset to local media data stored outside the asset's container file should not be followed.
        #[doc(alias = "AVAssetReferenceRestrictionForbidLocalReferenceToLocal")]
        const ForbidLocalReferenceToLocal = 1<<3;
/// Indicates that only references to media data stored within the asset's container file should be allowed.
        #[doc(alias = "AVAssetReferenceRestrictionForbidAll")]
        const ForbidAll = 0xFFFF;
/// Indicates that only references to media data stored within the asset's container file should be allowed.
        #[doc(alias = "AVAssetReferenceRestrictionDefaultPolicy")]
        const DefaultPolicy = AVAssetReferenceRestrictions::ForbidLocalReferenceToRemote.0;
    }
}

unsafe impl Encode for AVAssetReferenceRestrictions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for AVAssetReferenceRestrictions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// AVAssetReferenceRestrictions.
impl AVAsset {
    extern_methods!(
        /// Indicates the reference restrictions being used by the receiver.
        ///
        /// For AVURLAsset, this property reflects the value passed in for AVURLAssetReferenceRestrictionsKey, if any. See AVURLAssetReferenceRestrictionsKey below for a full discussion of reference restrictions. The default value for this property is AVAssetReferenceRestrictionForbidLocalReferenceToRemote.
        #[unsafe(method(referenceRestrictions))]
        #[unsafe(method_family = none)]
        pub unsafe fn referenceRestrictions(&self) -> AVAssetReferenceRestrictions;
    );
}

/// AVAssetTrackInspection.
impl AVAsset {
    extern_methods!(
        #[cfg(feature = "AVAssetTrack")]
        /// Provides the array of AVAssetTracks contained by the asset
        #[unsafe(method(tracks))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracks(&self) -> Retained<NSArray<AVAssetTrack>>;

        #[cfg(all(feature = "AVAssetTrack", feature = "objc2-core-media"))]
        /// Provides an instance of AVAssetTrack that represents the track of the specified trackID.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        ///
        /// - Parameter trackID: The trackID of the requested AVAssetTrack.
        ///
        /// - Returns: An instance of AVAssetTrack; may be nil if no track of the specified trackID is available.
        #[deprecated = "Use loadTrackWithTrackID:completionHandler: instead"]
        #[unsafe(method(trackWithTrackID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackWithTrackID(
            &self,
            track_id: CMPersistentTrackID,
        ) -> Option<Retained<AVAssetTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "block2",
            feature = "objc2-core-media"
        ))]
        /// Loads an instance of AVAssetTrack that represents the track of the specified trackID.
        ///
        /// - Parameter trackID: The trackID of the requested AVAssetTrack.
        /// - Parameter completionHandler: A block that is called when the loading is finished, with either the loaded track (which may be nil if no track of the specified trackID is available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTrackWithTrackID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTrackWithTrackID_completionHandler(
            &self,
            track_id: CMPersistentTrackID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut AVAssetTrack, *mut NSError)>,
        );

        #[cfg(all(feature = "AVAssetTrack", feature = "AVMediaFormat"))]
        /// Provides an array of AVAssetTracks of the asset that present media of the specified media type.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        ///
        /// - Parameter mediaType: The media type according to which AVAsset filters its AVAssetTracks. (Media types are defined in AVMediaFormat.h.)
        ///
        /// - Returns: An NSArray of AVAssetTracks; may be empty if no tracks of the specified media type are available.
        #[deprecated = "Use loadTracksWithMediaType:completionHandler: instead"]
        #[unsafe(method(tracksWithMediaType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaType(
            &self,
            media_type: &AVMediaType,
        ) -> Retained<NSArray<AVAssetTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "block2"
        ))]
        /// Loads an array of AVAssetTracks of the asset that present media of the specified media type.
        ///
        /// - Parameter mediaType: The media type according to which AVAsset filters its AVAssetTracks. (Media types are defined in AVMediaFormat.h.)
        /// - Parameter completionHandler: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks of the specified media type are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaType_completionHandler(
            &self,
            media_type: &AVMediaType,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSArray<AVAssetTrack>, *mut NSError)>,
        );

        #[cfg(all(feature = "AVAssetTrack", feature = "AVMediaFormat"))]
        /// Provides an array of AVAssetTracks of the asset that present media with the specified characteristic.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        ///
        /// - Parameter mediaCharacteristic: The media characteristic according to which AVAsset filters its AVAssetTracks. (Media characteristics are defined in AVMediaFormat.h.)
        ///
        /// - Returns: An NSArray of AVAssetTracks; may be empty if no tracks with the specified characteristic are available.
        #[deprecated = "Use loadTracksWithMediaCharacteristic:completionHandler: instead"]
        #[unsafe(method(tracksWithMediaCharacteristic:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaCharacteristic(
            &self,
            media_characteristic: &AVMediaCharacteristic,
        ) -> Retained<NSArray<AVAssetTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "block2"
        ))]
        /// Loads an array of AVAssetTracks of the asset that present media with the specified characteristic.
        ///
        /// - Parameter mediaCharacteristic: The media characteristic according to which AVAsset filters its AVAssetTracks. (Media characteristics are defined in AVMediaFormat.h.)
        /// - Parameter completionHandler: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks with the specified characteristic are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaCharacteristic:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaCharacteristic_completionHandler(
            &self,
            media_characteristic: &AVMediaCharacteristic,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSArray<AVAssetTrack>, *mut NSError)>,
        );

        #[cfg(feature = "AVAssetTrackGroup")]
        /// All track groups in the receiver.
        ///
        /// The value of this property is an NSArray of AVAssetTrackGroups, each representing a different grouping of tracks in the receiver.
        #[unsafe(method(trackGroups))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackGroups(&self) -> Retained<NSArray<AVAssetTrackGroup>>;
    );
}

/// AVAssetMetadataReading.
impl AVAsset {
    extern_methods!(
        #[cfg(feature = "AVMetadataItem")]
        /// Indicates the creation date of the asset as an AVMetadataItem. May be nil. If a creation date has been stored by the asset in a form that can be converted to an NSDate, the dateValue property of the AVMetadataItem will provide an instance of NSDate. Otherwise the creation date is available only as a string value, via -[AVMetadataItem stringValue].
        #[unsafe(method(creationDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn creationDate(&self) -> Option<Retained<AVMetadataItem>>;

        /// Provides access to the lyrics of the asset suitable for the current locale.
        #[unsafe(method(lyrics))]
        #[unsafe(method_family = none)]
        pub unsafe fn lyrics(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "AVMetadataItem")]
        /// Provides access to an array of AVMetadataItems for each common metadata key for which a value is available; items can be filtered according to language via +[AVMetadataItem metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:] and according to identifier via +[AVMetadataItem metadataItemsFromArray:filteredByIdentifier:].
        #[unsafe(method(commonMetadata))]
        #[unsafe(method_family = none)]
        pub unsafe fn commonMetadata(&self) -> Retained<NSArray<AVMetadataItem>>;

        #[cfg(feature = "AVMetadataItem")]
        /// Provides access to an array of AVMetadataItems for all metadata identifiers for which a value is available; items can be filtered according to language via +[AVMetadataItem metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:] and according to identifier via +[AVMetadataItem metadataItemsFromArray:filteredByIdentifier:].
        #[unsafe(method(metadata))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadata(&self) -> Retained<NSArray<AVMetadataItem>>;

        #[cfg(feature = "AVMetadataFormat")]
        /// Provides an NSArray of NSStrings, each representing a metadata format that's available to the asset (e.g. ID3, iTunes metadata, etc.). Metadata formats are defined in AVMetadataFormat.h.
        #[unsafe(method(availableMetadataFormats))]
        #[unsafe(method_family = none)]
        pub unsafe fn availableMetadataFormats(&self) -> Retained<NSArray<AVMetadataFormat>>;

        #[cfg(all(feature = "AVMetadataFormat", feature = "AVMetadataItem"))]
        /// Provides an NSArray of AVMetadataItems, one for each metadata item in the container of the specified format; can subsequently be filtered according to language via +[AVMetadataItem metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:], according to locale via +[AVMetadataItem metadataItemsFromArray:withLocale:], or according to key via +[AVMetadataItem metadataItemsFromArray:withKey:keySpace:].
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// availableMetadataFormats" has been loaded
        ///
        /// - Parameter format: The metadata format for which items are requested.
        ///
        /// - Returns: An NSArray containing AVMetadataItems; may be empty if there is no metadata of the specified format.
        #[deprecated = "Use loadMetadataForFormat:completionHandler: instead"]
        #[unsafe(method(metadataForFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataForFormat(
            &self,
            format: &AVMetadataFormat,
        ) -> Retained<NSArray<AVMetadataItem>>;

        #[cfg(all(
            feature = "AVMetadataFormat",
            feature = "AVMetadataItem",
            feature = "block2"
        ))]
        /// Loads an NSArray of AVMetadataItems, one for each metadata item in the container of the specified format; can subsequently be filtered according to language via +[AVMetadataItem metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:], according to locale via +[AVMetadataItem metadataItemsFromArray:withLocale:], or according to key via +[AVMetadataItem metadataItemsFromArray:withKey:keySpace:].
        ///
        /// - Parameter format: The metadata format for which items are requested.
        /// - Parameter completionHandler: A block that is invoked when loading is complete, vending the array of metadata items (which may be empty if there is no metadata of the specified format) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadMetadataForFormat:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadMetadataForFormat_completionHandler(
            &self,
            format: &AVMetadataFormat,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVMetadataItem>, *mut NSError),
            >,
        );
    );
}

/// AVAssetChapterInspection.
impl AVAsset {
    extern_methods!(
        /// array of NSLocale
        #[unsafe(method(availableChapterLocales))]
        #[unsafe(method_family = none)]
        pub unsafe fn availableChapterLocales(&self) -> Retained<NSArray<NSLocale>>;

        #[cfg(all(feature = "AVMetadataFormat", feature = "AVTimedMetadataGroup"))]
        /// Provides an array of chapters.
        ///
        /// This method returns an array of AVTimedMetadataGroup objects. Each object in the array always contains an AVMetadataItem representing the chapter title; the timeRange property of the AVTimedMetadataGroup object is equal to the time range of the chapter title item.
        ///
        /// An AVMetadataItem with the specified common key will be added to an existing AVTimedMetadataGroup object if the time range (timestamp and duration) of the metadata item and the metadata group overlaps. The locale of items not carrying chapter titles need not match the specified locale parameter.
        ///
        /// Further filtering of the metadata items in AVTimedMetadataGroups according to language can be accomplished using +[AVMetadataItem metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:]; filtering of the metadata items according to locale can be accomplished using +[AVMetadataItem metadataItemsFromArray:withLocale:].
        ///
        /// - Parameter locale: Locale of the metadata items carrying chapter titles to be returned (supports the IETF BCP 47 specification).
        /// - Parameter commonKeys: Array of common keys of AVMetadataItem to be included; can be nil. AVMetadataCommonKeyArtwork is the only supported key for now.
        ///
        /// - Returns: An NSArray of AVTimedMetadataGroup.
        #[deprecated = "Use loadChapterMetadataGroupsWithTitleLocale:containingItemsWithCommonKeys:completionHandler: instead"]
        #[unsafe(method(chapterMetadataGroupsWithTitleLocale:containingItemsWithCommonKeys:))]
        #[unsafe(method_family = none)]
        pub unsafe fn chapterMetadataGroupsWithTitleLocale_containingItemsWithCommonKeys(
            &self,
            locale: &NSLocale,
            common_keys: Option<&NSArray<AVMetadataKey>>,
        ) -> Retained<NSArray<AVTimedMetadataGroup>>;

        #[cfg(all(
            feature = "AVMetadataFormat",
            feature = "AVTimedMetadataGroup",
            feature = "block2"
        ))]
        /// Loads an array of chapters.
        ///
        /// This method vends an array of AVTimedMetadataGroup objects. Each object in the array always contains an AVMetadataItem representing the chapter title; the timeRange property of the AVTimedMetadataGroup object is equal to the time range of the chapter title item.
        ///
        /// An AVMetadataItem with the specified common key will be added to an existing AVTimedMetadataGroup object if the time range (timestamp and duration) of the metadata item and the metadata group overlaps. The locale of items not carrying chapter titles need not match the specified locale parameter.
        ///
        /// Further filtering of the metadata items in AVTimedMetadataGroups according to language can be accomplished using +[AVMetadataItem metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:]; filtering of the metadata items according to locale can be accomplished using +[AVMetadataItem metadataItemsFromArray:withLocale:].
        ///
        /// - Parameter locale: Locale of the metadata items carrying chapter titles to be returned (supports the IETF BCP 47 specification).
        /// - Parameter commonKeys: Array of common keys of AVMetadataItem to be included; if no common keys are required, send an empty list. AVMetadataCommonKeyArtwork is the only supported key for now.
        /// - Parameter completionHandler: A block that is invoked when loading is complete, vending the array of timed metadata groups or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadChapterMetadataGroupsWithTitleLocale:containingItemsWithCommonKeys:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadChapterMetadataGroupsWithTitleLocale_containingItemsWithCommonKeys_completionHandler(
            &self,
            locale: &NSLocale,
            common_keys: &NSArray<AVMetadataKey>,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVTimedMetadataGroup>, *mut NSError),
            >,
        );

        #[cfg(feature = "AVTimedMetadataGroup")]
        /// Tests, in order of preference, for a match between language identifiers in the specified array of preferred languages and the available chapter locales, and returns the array of chapters corresponding to the first match that's found.
        ///
        /// Safe to call without blocking when the AVAsset key availableChapterLocales has status AVKeyValueStatusLoaded.
        ///
        /// Returns an array of AVTimedMetadataGroup objects. Each object in the array always contains an AVMetadataItem representing the chapter title; the timeRange property of the AVTimedMetadataGroup object is equal to the time range of the chapter title item.
        ///
        /// All of the available chapter metadata is included in the metadata groups, including items with the common key AVMetadataCommonKeyArtwork, if such items are present. Items not carrying chapter titles will be added to an existing AVTimedMetadataGroup object if the time range (timestamp and duration) of the metadata item and that of the metadata group overlaps. The locale of such items need not match the locale of the chapter titles.
        ///
        /// Further filtering of the metadata items in AVTimedMetadataGroups according to language can be accomplished using +[AVMetadataItem metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:]; filtering of the metadata items according to locale can be accomplished using +[AVMetadataItem metadataItemsFromArray:withLocale:].
        ///
        /// - Parameter preferredLanguages: An array of language identifiers in order of preference, each of which is an IETF BCP 47 (RFC 4646) language identifier. If your goal is to provide the best match for the end user's preferred languages without consideration of your app's available localizations, pass [NSLocale preferredLanguages] as the value of preferredLanguages. However, if you want to filter the available choices in order to obtain the best match among the localizations that are available for your app, pass [NSBundle preferredLocalizationsFromArray:[[NSBundle mainBundle] localizations] forPreferences:[NSLocale preferredLanguages]] instead. The latter choice is normally more appropriate for strings intended for display as part of the app's UI.
        ///
        /// - Returns: An NSArray of AVTimedMetadataGroup.
        #[deprecated = "Use loadChapterMetadataGroupsBestMatchingPreferredLanguages:completionHandler: instead"]
        #[unsafe(method(chapterMetadataGroupsBestMatchingPreferredLanguages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn chapterMetadataGroupsBestMatchingPreferredLanguages(
            &self,
            preferred_languages: &NSArray<NSString>,
        ) -> Retained<NSArray<AVTimedMetadataGroup>>;

        #[cfg(all(feature = "AVTimedMetadataGroup", feature = "block2"))]
        /// Tests, in order of preference, for a match between language identifiers in the specified array of preferred languages and the available chapter locales, and loads the array of chapters corresponding to the first match that's found.
        ///
        /// Returns an array of AVTimedMetadataGroup objects. Each object in the array always contains an AVMetadataItem representing the chapter title; the timeRange property of the AVTimedMetadataGroup object is equal to the time range of the chapter title item.
        ///
        /// All of the available chapter metadata is included in the metadata groups, including items with the common key AVMetadataCommonKeyArtwork, if such items are present. Items not carrying chapter titles will be added to an existing AVTimedMetadataGroup object if the time range (timestamp and duration) of the metadata item and that of the metadata group overlaps. The locale of such items need not match the locale of the chapter titles.
        ///
        /// Further filtering of the metadata items in AVTimedMetadataGroups according to language can be accomplished using +[AVMetadataItem metadataItemsFromArray:filteredAndSortedAccordingToPreferredLanguages:]; filtering of the metadata items according to locale can be accomplished using +[AVMetadataItem metadataItemsFromArray:withLocale:].
        ///
        /// - Parameter preferredLanguages: An array of language identifiers in order of preference, each of which is an IETF BCP 47 (RFC 4646) language identifier. If your goal is to provide the best match for the end user's preferred languages without consideration of your app's available localizations, pass [NSLocale preferredLanguages] as the value of preferredLanguages. However, if you want to filter the available choices in order to obtain the best match among the localizations that are available for your app, pass [NSBundle preferredLocalizationsFromArray:[[NSBundle mainBundle] localizations] forPreferences:[NSLocale preferredLanguages]] instead. The latter choice is normally more appropriate for strings intended for display as part of the app's UI.
        /// - Parameter completionHandler: A block that is invoked when loading is complete, vending the array of timed metadata groups or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadChapterMetadataGroupsBestMatchingPreferredLanguages:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadChapterMetadataGroupsBestMatchingPreferredLanguages_completionHandler(
            &self,
            preferred_languages: &NSArray<NSString>,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVTimedMetadataGroup>, *mut NSError),
            >,
        );
    );
}

/// AVAssetMediaSelection.
impl AVAsset {
    extern_methods!(
        #[cfg(feature = "AVMediaFormat")]
        /// Provides an NSArray of NSStrings, each NSString indicating a media characteristic for which a media selection option is available.
        #[unsafe(method(availableMediaCharacteristicsWithMediaSelectionOptions))]
        #[unsafe(method_family = none)]
        pub unsafe fn availableMediaCharacteristicsWithMediaSelectionOptions(
            &self,
        ) -> Retained<NSArray<AVMediaCharacteristic>>;

        #[cfg(all(feature = "AVMediaFormat", feature = "AVMediaSelectionGroup"))]
        /// Provides an instance of AVMediaSelectionGroup that contains one or more options with the specified media characteristic.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// availableMediaCharacteristicsWithMediaSelectionOptions" has been loaded.
        ///
        /// If the asset has no AVMediaSelectionGroup containing options with the specified media characteristic, the return value will be nil.
        ///
        /// Filtering of the options in the returned AVMediaSelectionGroup according to playability, locale, and additional media characteristics can be accomplished using the category AVMediaSelectionOptionFiltering defined on AVMediaSelectionGroup.
        ///
        /// - Parameter mediaCharacteristic: A media characteristic for which you wish to obtain the available media selection options. AVMediaCharacteristicAudible, AVMediaCharacteristicLegible, and AVMediaCharacteristicVisual are currently supported.
        /// Pass AVMediaCharacteristicAudible to obtain the group of available options for audio media in various languages and for various purposes, such as descriptive audio.
        /// Pass AVMediaCharacteristicLegible to obtain the group of available options for subtitles in various languages and for various purposes.
        /// Pass AVMediaCharacteristicVisual to obtain the group of available options for video media.
        ///
        /// - Returns: An instance of AVMediaSelectionGroup. May be nil.
        #[deprecated = "Use loadMediaSelectionGroupForMediaCharacteristic:completionHandler: instead"]
        #[unsafe(method(mediaSelectionGroupForMediaCharacteristic:))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaSelectionGroupForMediaCharacteristic(
            &self,
            media_characteristic: &AVMediaCharacteristic,
        ) -> Option<Retained<AVMediaSelectionGroup>>;

        #[cfg(all(
            feature = "AVMediaFormat",
            feature = "AVMediaSelectionGroup",
            feature = "block2"
        ))]
        /// Loads an instance of AVMediaSelectionGroup that contains one or more options with the specified media characteristic.
        ///
        /// If the asset has no AVMediaSelectionGroup containing options with the specified media characteristic, the return value will be nil.
        ///
        /// Filtering of the options in the returned AVMediaSelectionGroup according to playability, locale, and additional media characteristics can be accomplished using the category AVMediaSelectionOptionFiltering defined on AVMediaSelectionGroup.
        ///
        /// - Parameter mediaCharacteristic: A media characteristic for which you wish to obtain the available media selection options. AVMediaCharacteristicAudible, AVMediaCharacteristicLegible, and AVMediaCharacteristicVisual are currently supported.
        /// Pass AVMediaCharacteristicAudible to obtain the group of available options for audio media in various languages and for various purposes, such as descriptive audio.
        /// Pass AVMediaCharacteristicLegible to obtain the group of available options for subtitles in various languages and for various purposes
        /// Pass AVMediaCharacteristicVisual to obtain the group of available options for video media.
        /// - Parameter completionHandler: A block that is invoked when loading is complete, vending an instance of AVMediaSelectionGroup (which may be nil) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadMediaSelectionGroupForMediaCharacteristic:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadMediaSelectionGroupForMediaCharacteristic_completionHandler(
            &self,
            media_characteristic: &AVMediaCharacteristic,
            completion_handler: &block2::DynBlock<dyn Fn(*mut AVMediaSelectionGroup, *mut NSError)>,
        );

        #[cfg(feature = "AVMediaSelection")]
        /// Provides an instance of AVMediaSelection with default selections for each of the receiver's media selection groups.
        #[unsafe(method(preferredMediaSelection))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredMediaSelection(&self) -> Retained<AVMediaSelection>;

        #[cfg(feature = "AVMediaSelection")]
        /// Provides an array of all permutations of AVMediaSelection for this asset.
        #[unsafe(method(allMediaSelections))]
        #[unsafe(method_family = none)]
        pub unsafe fn allMediaSelections(&self) -> Retained<NSArray<AVMediaSelection>>;
    );
}

/// AVAssetProtectedContent.
impl AVAsset {
    extern_methods!(
        /// Indicates whether or not the asset has protected content.
        ///
        /// Assets containing protected content may not be playable without successful authorization, even if the value of the "playable" property is YES. See the properties in the AVAssetUsability category for details on how such an asset may be used. On macOS, clients can use the interfaces in AVPlayerItemProtectedContentAdditions.h to request authorization to play the asset.
        #[unsafe(method(hasProtectedContent))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasProtectedContent(&self) -> bool;
    );
}

/// AVAssetFragments.
impl AVAsset {
    extern_methods!(
        /// Indicates whether the asset is capable of being extended by fragments.
        ///
        /// For QuickTime movie files and MPEG-4 files, the value of canContainFragments is YES if an 'mvex' box is present in the 'moov' box. For those types, the 'mvex' box signals the possible presence of later 'moof' boxes.
        #[unsafe(method(canContainFragments))]
        #[unsafe(method_family = none)]
        pub unsafe fn canContainFragments(&self) -> bool;

        /// Indicates whether the asset is extended by at least one fragment.
        ///
        /// For QuickTime movie files and MPEG-4 files, the value of this property is YES if canContainFragments is YES and at least one 'moof' box is present after the 'moov' box.
        #[unsafe(method(containsFragments))]
        #[unsafe(method_family = none)]
        pub unsafe fn containsFragments(&self) -> bool;

        #[cfg(feature = "objc2-core-media")]
        /// Indicates the total duration of fragments that either exist now or may be appended in the future in order to extend the duration of the asset.
        ///
        /// For QuickTime movie files and MPEG-4 files, the value of this property is obtained from the 'mehd' box of the 'mvex' box, if present. If no total fragment duration hint is available, the value of this property is kCMTimeInvalid.
        #[unsafe(method(overallDurationHint))]
        #[unsafe(method_family = none)]
        pub unsafe fn overallDurationHint(&self) -> CMTime;
    );
}

/// AVAssetUsability.
impl AVAsset {
    extern_methods!(
        /// Indicates whether an AVPlayer can play the contents of the asset in a manner that meets user expectations.
        ///
        /// A client can attempt playback when playable is NO, this however may lead to a substandard playback experience.
        #[unsafe(method(isPlayable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPlayable(&self) -> bool;

        /// Indicates whether an AVAssetExportSession can be used with the receiver for export
        #[unsafe(method(isExportable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isExportable(&self) -> bool;

        /// Indicates whether an AVAssetReader can be used with the receiver for extracting media data
        #[unsafe(method(isReadable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isReadable(&self) -> bool;

        /// Indicates whether the receiver can be used to build an AVMutableComposition
        #[unsafe(method(isComposable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isComposable(&self) -> bool;

        /// Indicates whether the receiver can be written to the saved photos album
        #[unsafe(method(isCompatibleWithSavedPhotosAlbum))]
        #[unsafe(method_family = none)]
        pub unsafe fn isCompatibleWithSavedPhotosAlbum(&self) -> bool;

        /// Indicates whether the asset is compatible with AirPlay Video.
        ///
        /// YES if an AVPlayerItem initialized with the receiver can be played by an external device via AirPlay Video.
        #[unsafe(method(isCompatibleWithAirPlayVideo))]
        #[unsafe(method_family = none)]
        pub unsafe fn isCompatibleWithAirPlayVideo(&self) -> bool;
    );
}

extern "C" {
    /// Indicates whether the asset should be prepared to indicate a precise duration and provide precise random access by time.
    ///
    /// The value for this key is a boolean NSNumber.
    ///
    /// If nil is passed as the value of the options parameter to -[AVURLAsset initWithURL:options:], or if a dictionary that lacks a value for the key AVURLAssetPreferPreciseDurationAndTimingKey is passed instead, a default value of NO is assumed. If the asset is intended to be played only, because AVPlayer will support approximate random access by time when full precision isn't available, the default value of NO will suffice.
    /// Pass YES if longer loading times are acceptable in cases in which precise timing is required. If the asset is intended to be inserted into an AVMutableComposition, precise random access is typically desirable and the value of YES is recommended.
    /// Note that such precision may require additional parsing of the resource in advance of operations that make use of any portion of it, depending on the specifics of its container format. Many container formats provide sufficient summary information for precise timing and do not require additional parsing to prepare for it; QuickTime movie files and MPEG-4 files are examples of such formats. Other formats do not provide sufficient summary information, and precise random access for them is possible only after a preliminary examination of a file's contents.
    /// If you pass YES for an asset that you intend to play via an instance of AVPlayerItem and you are prepared for playback to commence before the value of -[AVPlayerItem duration] becomes available, you can omit the key
    /// "
    /// duration" from the array of AVAsset keys you pass to -[AVPlayerItem initWithAsset:automaticallyLoadedAssetKeys:] in order to prevent AVPlayerItem from automatically loading the value of duration while the item becomes ready to play.
    /// If precise duration and timing is not possible for the timed media resource referenced by the asset's URL, AVAsset.providesPreciseDurationAndTiming will be NO even if precise timing is requested via the use of this key.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassetpreferprecisedurationandtimingkey?language=objc)
    pub static AVURLAssetPreferPreciseDurationAndTimingKey: &'static NSString;
}

extern "C" {
    /// Indicates the MIME type that should be used to identify the format of the media resource.
    ///
    /// When a value for this key is provided, only the specified MIME type is considered in determining how to handle or parse the media resource. Any other information that may be available, such as the URL path extension or a server-provided MIME type, is ignored.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassetoverridemimetypekey?language=objc)
    pub static AVURLAssetOverrideMIMETypeKey: &'static NSString;
}

extern "C" {
    /// Indicates the restrictions used by the asset when resolving references to external media data. The value of this key is an NSNumber wrapping an AVAssetReferenceRestrictions enum value or the logical combination of multiple such values.
    ///
    /// Some assets can contain references to media data stored outside the asset's container file, for example in another file. This key can be used to specify a policy to use when these references are encountered. If an asset contains one or more references of a type that is forbidden by the reference restrictions, loading of asset properties will fail. In addition, such an asset cannot be used with other AVFoundation modules, such as AVPlayerItem or AVAssetExportSession.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassetreferencerestrictionskey?language=objc)
    pub static AVURLAssetReferenceRestrictionsKey: &'static NSString;
}

extern "C" {
    /// HTTP cookies that the AVURLAsset may send with HTTP requests
    ///
    /// Standard cross-site policy still applies: cookies will only be sent to domains to which they apply.
    ///
    /// By default, an AVURLAsset will only have access to cookies in the client's default cookie storage
    /// that apply to the AVURLAsset's URL. You can supplement the cookies available to the asset
    /// via use of this initialization option
    ///
    /// HTTP cookies do not apply to non-HTTP(S) URLS.
    /// In HLS, many HTTP requests (e.g., media, crypt key, variant index) might be issued to different paths or hosts.
    /// In both of these cases, HTTP requests will be missing any cookies that do not apply to the AVURLAsset's URL.
    /// This init option allows the AVURLAsset to use additional HTTP cookies for those HTTP(S) requests.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassethttpcookieskey?language=objc)
    pub static AVURLAssetHTTPCookiesKey: &'static NSString;
}

extern "C" {
    /// Indicates whether network requests on behalf of this asset are allowed to use the cellular interface.
    ///
    /// Default is YES.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassetallowscellularaccesskey?language=objc)
    pub static AVURLAssetAllowsCellularAccessKey: &'static NSString;
}

extern "C" {
    /// Indicates whether network requests on behalf of this asset are allowed to use the expensive interface (e.g. cellular, tethered, constrained).
    ///
    /// Default is YES.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassetallowsexpensivenetworkaccesskey?language=objc)
    pub static AVURLAssetAllowsExpensiveNetworkAccessKey: &'static NSString;
}

extern "C" {
    /// Indicates whether network requests on behalf of this asset are allowed to use the constrained interface (e.g. interfaces marked as being in data saver mode).
    ///
    /// Default is YES.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassetallowsconstrainednetworkaccesskey?language=objc)
    pub static AVURLAssetAllowsConstrainedNetworkAccessKey: &'static NSString;
}

extern "C" {
    /// Indicates whether alias data references in the asset should be parsed and resolved.
    ///
    /// Default is NO. Although the majority of QuickTime movie files contain all of the media data they require, some contain references to media stored in other files. While AVFoundation and CoreMedia typically employ a URL reference for this purpose, older implementations such as QuickTime 7 have commonly employed a Macintosh alias instead, as documented in the QuickTime File Format specification. If your application must work with legacy QuickTime movie files containing alias-based references to media data stored in other files, the use of this AVURLAsset initialization option is appropriate.
    ///
    /// If you provide a value for AVURLAssetReferenceRestrictionsKey, restrictions will be observed for resolved alias references just as they are for URL references.
    ///
    /// For more details about alias resolution, consult documentation of the bookmark-related interfaces of NSURL.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassetshouldsupportaliasdatareferenceskey?language=objc)
    pub static AVURLAssetShouldSupportAliasDataReferencesKey: &'static NSString;
}

extern "C" {
    /// Specifies the attribution of the URLs requested by this asset.
    ///
    /// Value is an NSNumber whose value is an NSURLRequestAttribution (see NSURLRequest.h).
    /// Default value is NSURLRequestAttributionDeveloper.
    /// All NSURLRequests issed on behalf of this AVURLAsset will be attributed with this value and follow the App Privacy Policy accordingly.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlasseturlrequestattributionkey?language=objc)
    pub static AVURLAssetURLRequestAttributionKey: &'static NSString;
}

extern "C" {
    /// Specifies the value of the User-Agent header to add to HTTP requests made by this asset.
    ///
    /// Value is an NSString
    /// Default value is the systems's default User-Agent.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassethttpuseragentkey?language=objc)
    pub static AVURLAssetHTTPUserAgentKey: &'static NSString;
}

extern "C" {
    /// Specifies a UUID to append as the value of the query parameter "_HLS_primary_id" to selected HTTP requests issued on behalf of the asset. Supported for HLS assets only.
    ///
    /// Value is an NSUUID. Its UUID string value will be used as the query parameter.
    /// If you create AVURLAssets for the templateItems of AVPlayerInterstitialEvents and you want the instances of AVURLAsset that you create to be used during interstitial playback rather than equivalent AVURLAssets with the same URL, you must provide a value for this key that's equal to the httpSessionIdentifier of the primary AVPlayerItem's asset. See AVPlayerInterstitialEventController.h. This is especially useful if you require the use of a custom AVAssetResourceLoader delegate for interstitial assets.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassetprimarysessionidentifierkey?language=objc)
    pub static AVURLAssetPrimarySessionIdentifierKey: &'static NSString;
}

extern "C" {
    /// Indicates whether additional projected media signaling in the asset should be parsed and resolved as format description extensions.
    ///
    /// Default is NO.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlassetshouldparseexternalsphericaltagskey?language=objc)
    pub static AVURLAssetShouldParseExternalSphericalTagsKey: &'static NSString;
}

extern_class!(
    /// AVURLAsset provides access to the AVAsset model for timed audiovisual media referenced by URL.
    ///
    /// Note that although instances of AVURLAsset are immutable, values for its keys may not be immediately available without blocking. See the discussion of the class AVAsset above regarding the availability of values for keys and the use of AVAsynchronousKeyValueLoading.
    ///
    /// Once an AVURLAsset's value for a key is available, it will not change. AVPlayerItem provides access to information that can change dynamically during playback; see AVPlayerItem.duration and AVPlayerItem.tracks.
    ///
    /// AVURLAssets can be initialized with NSURLs that refer to audiovisual media resources, such as streams (including HTTP live streams), QuickTime movie files, MP3 files, and files of other types.
    ///
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avurlasset?language=objc)
    #[unsafe(super(AVAsset, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVURLAsset;
);

unsafe impl Send for AVURLAsset {}

unsafe impl Sync for AVURLAsset {}

#[cfg(feature = "AVAsynchronousKeyValueLoading")]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVURLAsset {}
);

extern_conformance!(
    unsafe impl NSCopying for AVURLAsset {}
);

unsafe impl CopyingHelper for AVURLAsset {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVURLAsset {}
);

impl AVURLAsset {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "AVMediaFormat")]
        /// Provides the file types the AVURLAsset class understands.
        ///
        /// - Returns: An NSArray of UTIs identifying the file types the AVURLAsset class understands.
        #[deprecated = "Use audiovisualContentTypes instead"]
        #[unsafe(method(audiovisualTypes))]
        #[unsafe(method_family = none)]
        pub unsafe fn audiovisualTypes() -> Retained<NSArray<AVFileType>>;

        /// Provides the MIME types the AVURLAsset class understands.
        ///
        /// - Returns: An NSArray of NSStrings containing MIME types the AVURLAsset class understands.
        #[unsafe(method(audiovisualMIMETypes))]
        #[unsafe(method_family = none)]
        pub unsafe fn audiovisualMIMETypes() -> Retained<NSArray<NSString>>;

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        /// Provides the content types the AVURLAsset class understands.
        ///
        /// - Returns: An NSArray of UTTypes identifying the content types the AVURLAsset class understands.
        #[unsafe(method(audiovisualContentTypes))]
        #[unsafe(method_family = none)]
        pub unsafe fn audiovisualContentTypes() -> Retained<NSArray<UTType>>;

        /// Returns YES if asset is playable with the codec(s) and container type specified in extendedMIMEType. Returns NO otherwise.
        ///
        /// On releases prior to macOS 14, iOS 17, tvOS 17, and watchOS 10, regardless of the specified MIME type this method interprets all codecs parameters according to the ISO family syntax defined by RFC 6381 and evaluates playability according to whether the indicated codecs are supported when carried in container formats that conform to the ISO BMFF specification, such as the MPEG-4 file format.
        /// On releases starting with macOS 14, iOS 17, tvOS 17, and watchOS 10, this method interprets codecs parameters according to the syntax and namespace determined by the specified MIME type and evaluates playability according to whether the indicated codecs are supported when carried in the container format indicated by that MIME type. Codecs parameters for each of the following MIME types are supported: video/mp4 (per RFC 6381, ISO/IEC 14496-15 Annex E, et al), video/quicktime (RFC 6381 et al), video/mp2t (ISO/IEC 13818-1), audio/vnd.wave (RFC 2361), audio/aiff (using the CoreAudio AudioFormatID namespace), audio/x-caf (also using the CoreAudio AudioFormatID namespace), and audio/mpeg (e.g. codecs="mp3"). MIME types supported as alternatives for the same container formats, e.g audio/mp4, are equivalently treated. If the indicated MIME type defines no supported syntax and namespace for codecs parameters, when any codecs parameter is present this method returns NO.
        ///
        /// - Parameter extendedMIMEType:
        ///
        /// - Returns: YES or NO.
        #[unsafe(method(isPlayableExtendedMIMEType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPlayableExtendedMIMEType(extended_mime_type: &NSString) -> bool;

        /// Returns an instance of AVURLAsset for inspection of a media resource.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        /// - Parameter options: An instance of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above.
        ///
        /// - Returns: An instance of AVURLAsset.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(URLAssetWithURL:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn URLAssetWithURL_options(
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Initializes an instance of AVURLAsset for inspection of a media resource.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        /// - Parameter options: An instance of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above.
        ///
        /// - Returns: An instance of AVURLAsset.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithURL:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_options(
            this: Allocated<Self>,
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Indicates the URL with which the instance of AVURLAsset was initialized.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(URL))]
        #[unsafe(method_family = none)]
        pub unsafe fn URL(&self) -> Retained<NSURL>;

        /// Provides the identifier that's automatically included in any HTTP request issued on behalf of this asset in the HTTP header field "X-Playback-Session-Id".
        ///
        /// The value is an NSUUID from which the UUID string can be obtained.
        /// Note that copies of an AVURLAsset vend an equivalent httpSessionIdentifier.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(httpSessionIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn httpSessionIdentifier(&self) -> Retained<NSUUID>;
    );
}

/// Methods declared on superclass `AVAsset`.
impl AVURLAsset {
    extern_methods!(
        /// Returns an instance of AVAsset for inspection of a media resource.
        ///
        /// Returns a newly allocated instance of a subclass of AVAsset initialized with the specified URL.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        ///
        /// - Returns: An instance of AVAsset.
        #[unsafe(method(assetWithURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assetWithURL(url: &NSURL) -> Retained<Self>;
    );
}

/// AVURLAssetURLHandling.
impl AVURLAsset {
    extern_methods!(
        #[cfg(feature = "AVAssetResourceLoader")]
        /// Provides access to an instance of AVAssetResourceLoader, which offers limited control over the handling of URLs that may be loaded in the course of performing operations on the asset, such as playback.
        ///
        /// The loading of file URLs cannot be mediated via use of AVAssetResourceLoader.
        ///
        /// Note that copies of an AVAsset will vend the same instance of AVAssetResourceLoader.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(resourceLoader))]
        #[unsafe(method_family = none)]
        pub unsafe fn resourceLoader(&self) -> Retained<AVAssetResourceLoader>;
    );
}

/// AVURLAssetCache.
impl AVURLAsset {
    extern_methods!(
        #[cfg(feature = "AVAssetCache")]
        /// Provides access to an instance of AVAssetCache to use for inspection of locally cached media data. Will be nil if an asset has not been configured to store or access media data from disk.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(assetCache))]
        #[unsafe(method_family = none)]
        pub unsafe fn assetCache(&self) -> Option<Retained<AVAssetCache>>;
    );
}

/// AVAssetCompositionUtility.
impl AVURLAsset {
    extern_methods!(
        #[cfg(all(feature = "AVAssetTrack", feature = "AVCompositionTrack"))]
        /// Provides a reference to an AVAssetTrack of the target from which any timeRange can be inserted into a mutable composition track (via -[AVMutableCompositionTrack insertTimeRange:ofTrack:atTime:error:]).
        ///
        /// Finds a track of the target with content that can be accommodated by the specified composition track.
        /// The logical complement of -[AVMutableComposition mutableTrackCompatibleWithTrack:].
        ///
        /// - Parameter compositionTrack: The composition track for which a compatible AVAssetTrack is requested.
        ///
        /// - Returns: an instance of AVAssetTrack
        #[deprecated = "Use findCompatibleTrackForCompositionTrack:completionHandler: instead"]
        #[unsafe(method(compatibleTrackForCompositionTrack:))]
        #[unsafe(method_family = none)]
        pub unsafe fn compatibleTrackForCompositionTrack(
            &self,
            composition_track: &AVCompositionTrack,
        ) -> Option<Retained<AVAssetTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVCompositionTrack",
            feature = "block2"
        ))]
        /// Loads a reference to an AVAssetTrack of the target from which any timeRange can be inserted into a mutable composition track (via -[AVMutableCompositionTrack insertTimeRange:ofTrack:atTime:error:]).
        ///
        /// Finds a track of the target with content that can be accommodated by the specified composition track.
        /// The logical complement of -[AVMutableComposition mutableTrackCompatibleWithTrack:].
        ///
        /// - Parameter compositionTrack: The composition track for which a compatible AVAssetTrack is requested.
        /// - Parameter completionHandler: A block that is invoked when loading is complete, vending an instance of AVAssetTrack or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(findCompatibleTrackForCompositionTrack:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn findCompatibleTrackForCompositionTrack_completionHandler(
            &self,
            composition_track: &AVCompositionTrack,
            completion_handler: &block2::DynBlock<dyn Fn(*mut AVAssetTrack, *mut NSError)>,
        );
    );
}

/// AVAssetVariantInspection.
impl AVURLAsset {
    extern_methods!(
        #[cfg(feature = "AVAssetVariant")]
        /// Provides an array of AVAssetVariants contained in the asset
        ///
        /// Some variants may not be playable according to the current device configuration.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(variants))]
        #[unsafe(method_family = none)]
        pub unsafe fn variants(&self) -> Retained<NSArray<AVAssetVariant>>;
    );
}

/// AVURLAssetNSItemProvider.
///
/// AVURLAssets can be shared through any interface that supports passing NSItemProviders. Note that only AVURLAssets with file URLs can be added to NSItemProviders. Attempting to share assets with non file URLs will result in an error.
///
/// AVURLAssets can be retrieved from NSItemProviders by directly requesting an AVURLAsset through -[NSItemProvider loadObjectOfClass:completionHandler:]. Requesting data representations of AVURLAssets is not supported. File representations of AVURLAssets will be sent without copying the underlying media and the receiver will be extended readonly sandbox access to the sender's original URL until the AVURLAsset is deallocated. Use of NSFileCoordinator and NSFilePresenter is recommended for both the sender and receive to coordinate possible changes in the file's state once sharing has been completed.
impl AVURLAsset {
    extern_methods!();
}

extern_conformance!(
    unsafe impl NSItemProviderReading for AVURLAsset {}
);

extern_conformance!(
    unsafe impl NSItemProviderWriting for AVURLAsset {}
);

extern_class!(
    /// A class incorporating properties for a MediaExtension
    ///
    /// AVMediaExtensionProperties objects are returned from property queries on AVAsset, AVPlayerItemTrack, AVSampleBufferDisplayLayer, or AVSampleBufferVideoRenderer.
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmediaextensionproperties?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVMediaExtensionProperties;
);

unsafe impl Send for AVMediaExtensionProperties {}

unsafe impl Sync for AVMediaExtensionProperties {}

extern_conformance!(
    unsafe impl NSCopying for AVMediaExtensionProperties {}
);

unsafe impl CopyingHelper for AVMediaExtensionProperties {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVMediaExtensionProperties {}
);

impl AVMediaExtensionProperties {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// The identifier of the Media Extension.
        ///
        /// The extension identifier string, corresponding to the ClassImplementationID value from the EXAppExtensionAttributes dictionary in the Info.plist file.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(extensionIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn extensionIdentifier(&self) -> Retained<NSString>;

        /// The name of the MediaExtension.
        ///
        /// The localized name of the MediaExtension format reader or video decoder, corresponding to the CFBundleDisplayName.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(extensionName))]
        #[unsafe(method_family = none)]
        pub unsafe fn extensionName(&self) -> Retained<NSString>;

        /// The name of the containing application bundle.
        ///
        /// The localized name of the application that hosts the MediaExtension.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(containingBundleName))]
        #[unsafe(method_family = none)]
        pub unsafe fn containingBundleName(&self) -> Retained<NSString>;

        /// The file URL of the MediaExtension bundle.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(extensionURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn extensionURL(&self) -> Retained<NSURL>;

        /// The file URL of the host application for the MediaExtension.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(containingBundleURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn containingBundleURL(&self) -> Retained<NSURL>;
    );
}

/// AVMediaExtension.
impl AVURLAsset {
    extern_methods!(
        /// The properties of the MediaExtension format reader for the asset.
        ///
        /// If the asset is being decoded using a MediaExtension format reader, this property will return a AVMediaExtensionProperties object describing the extension. If the asset is not being decoded with a MediaExtension format reader, this property will return nil.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(mediaExtensionProperties))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaExtensionProperties(
            &self,
        ) -> Option<Retained<AVMediaExtensionProperties>>;

        /// The sidecar URL used by the MediaExtension.
        ///
        /// The sidecar URL is returned only if the MediaExtension format reader supports sidecar files, and implements this property [MEFileInfo setSidecarFilename:]. Will return nil otherwise.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(sidecarURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn sidecarURL(&self) -> Option<Retained<NSURL>>;
    );
}

extern "C" {
    /// Posted when the duration of an AVFragmentedAsset changes while it's being minded by an AVFragmentedAssetMinder, but only for changes that occur after the status of the value of
    /// "
    /// duration" has reached AVKeyValueStatusLoaded.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetdurationdidchangenotification?language=objc)
    pub static AVAssetDurationDidChangeNotification: &'static NSString;
}

extern "C" {
    /// Posted after the value of
    /// "
    /// containsFragments" has already been loaded and the AVFragmentedAsset is added to an AVFragmentedAssetMinder, either when 1) fragments are detected in the asset on disk after it had previously contained none or when 2) no fragments are detected in the asset on disk after it had previously contained one or more.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetcontainsfragmentsdidchangenotification?language=objc)
    pub static AVAssetContainsFragmentsDidChangeNotification: &'static NSString;
}

extern "C" {
    /// Posted when the asset on disk is defragmented while an AVFragmentedAsset is being minded by an AVFragmentedAssetMinder, but only if the defragmentation occurs after the status of the value of
    /// "
    /// canContainFragments" has reached AVKeyValueStatusLoaded.
    ///
    /// After this notification is posted, the value of the asset properties canContainFragments and containsFragments will both be NO.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetwasdefragmentednotification?language=objc)
    pub static AVAssetWasDefragmentedNotification: &'static NSString;
}

extern "C" {
    /// Posted when the collection of arrays of timed metadata groups representing chapters of an AVAsset change and when any of the contents of the timed metadata groups change, but only for changes that occur after the status of the value of
    /// "
    /// availableChapterLocales" has reached AVKeyValueStatusLoaded.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetchaptermetadatagroupsdidchangenotification?language=objc)
    pub static AVAssetChapterMetadataGroupsDidChangeNotification: &'static NSString;
}

extern "C" {
    /// Posted when the collection of media selection groups provided by an AVAsset changes and when any of the contents of its media selection groups change, but only for changes that occur after the status of the value of
    /// "
    /// availableMediaCharacteristicsWithMediaSelectionOptions" has reached AVKeyValueStatusLoaded.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avassetmediaselectiongroupsdidchangenotification?language=objc)
    pub static AVAssetMediaSelectionGroupsDidChangeNotification: &'static NSString;
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentminding?language=objc)
    pub unsafe trait AVFragmentMinding {
        /// Indicates whether an AVAsset that supports fragment minding is currently associated with a fragment minder, e.g. an instance of AVFragmentedAssetMinder.
        ///
        /// AVAssets that support fragment minding post change notifications only while associated with a fragment minder.
        #[unsafe(method(isAssociatedWithFragmentMinder))]
        #[unsafe(method_family = none)]
        unsafe fn isAssociatedWithFragmentMinder(&self) -> bool;
    }
);

extern_class!(
    /// A subclass of AVURLAsset that represents media resources that can be extended in total duration without modifying previously existing data structures.
    ///
    /// Such media resources include QuickTime movie files and MPEG-4 files that indicate, via an 'mvex' box in their 'moov' box, that they accommodate additional fragments. Media resources of other types may also be supported. To check whether a given instance of AVFragmentedAsset can be used to monitor the addition of fragments, check the value of the AVURLAsset property canContainFragments.
    ///
    /// An AVFragmentedAsset is capable of changing the values of certain of its properties and those of its tracks, while an operation that appends fragments to the underlying media resource in in progress, if the AVFragmentedAsset is associated with an instance of AVFragmentedAssetMinder.
    ///
    /// While associated with an AVFragmentedAssetMinder, AVFragmentedAsset posts AVAssetDurationDidChangeNotification whenever new fragments are detected, as appropriate. It may also post AVAssetContainsFragmentsDidChangeNotification and AVAssetWasDefragmentedNotification, as discussed in documentation of those notifications.
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedasset?language=objc)
    #[unsafe(super(AVURLAsset, AVAsset, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVFragmentedAsset;
);

unsafe impl Send for AVFragmentedAsset {}

unsafe impl Sync for AVFragmentedAsset {}

#[cfg(feature = "AVAsynchronousKeyValueLoading")]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVFragmentedAsset {}
);

extern_conformance!(
    unsafe impl AVFragmentMinding for AVFragmentedAsset {}
);

extern_conformance!(
    unsafe impl NSCopying for AVFragmentedAsset {}
);

unsafe impl CopyingHelper for AVFragmentedAsset {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVFragmentedAsset {}
);

impl AVFragmentedAsset {
    extern_methods!(
        /// Returns an instance of AVFragmentedAsset for inspection of a fragmented media resource.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        /// - Parameter options: An instance of NSDictionary that contains keys for specifying options for the initialization of the AVFragmentedAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above.
        ///
        /// - Returns: An instance of AVFragmentedAsset.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(fragmentedAssetWithURL:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fragmentedAssetWithURL_options(
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        #[cfg(feature = "AVAssetTrack")]
        /// The tracks in an asset.
        ///
        /// The value of this property is an array of tracks the asset contains; the tracks are of type AVFragmentedAssetTrack.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(tracks))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracks(&self) -> Retained<NSArray<AVFragmentedAssetTrack>>;
    );
}

/// Methods declared on superclass `AVURLAsset`.
impl AVFragmentedAsset {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// Returns an instance of AVURLAsset for inspection of a media resource.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        /// - Parameter options: An instance of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above.
        ///
        /// - Returns: An instance of AVURLAsset.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(URLAssetWithURL:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn URLAssetWithURL_options(
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Initializes an instance of AVURLAsset for inspection of a media resource.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        /// - Parameter options: An instance of NSDictionary that contains keys for specifying options for the initialization of the AVURLAsset. See AVURLAssetPreferPreciseDurationAndTimingKey and AVURLAssetReferenceRestrictionsKey above.
        ///
        /// - Returns: An instance of AVURLAsset.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithURL:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_options(
            this: Allocated<Self>,
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `AVAsset`.
impl AVFragmentedAsset {
    extern_methods!(
        /// Returns an instance of AVAsset for inspection of a media resource.
        ///
        /// Returns a newly allocated instance of a subclass of AVAsset initialized with the specified URL.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        ///
        /// - Returns: An instance of AVAsset.
        #[unsafe(method(assetWithURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assetWithURL(url: &NSURL) -> Retained<Self>;
    );
}

/// AVFragmentedAssetTrackInspection.
impl AVFragmentedAsset {
    extern_methods!(
        #[cfg(all(feature = "AVAssetTrack", feature = "objc2-core-media"))]
        /// Provides an instance of AVFragmentedAssetTrack that represents the track of the specified trackID.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        ///
        /// - Parameter trackID: The trackID of the requested AVFragmentedAssetTrack.
        ///
        /// - Returns: An instance of AVFragmentedAssetTrack; may be nil if no track of the specified trackID is available.
        #[deprecated = "Use loadTrackWithTrackID:completionHandler: instead"]
        #[unsafe(method(trackWithTrackID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackWithTrackID(
            &self,
            track_id: CMPersistentTrackID,
        ) -> Option<Retained<AVFragmentedAssetTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "block2",
            feature = "objc2-core-media"
        ))]
        /// Loads an instance of AVFragmentedAssetTrack that represents the track of the specified trackID.
        ///
        /// - Parameter trackID: The trackID of the requested AVFragmentedAssetTrack.
        /// - Parameter completionHandler: A block that is called when the loading is finished, with either the loaded track (which may be nil if no track of the specified trackID is available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTrackWithTrackID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTrackWithTrackID_completionHandler(
            &self,
            track_id: CMPersistentTrackID,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut AVFragmentedAssetTrack, *mut NSError),
            >,
        );

        #[cfg(all(feature = "AVAssetTrack", feature = "AVMediaFormat"))]
        /// Provides an array of AVFragmentedAssetTracks of the asset that present media of the specified media type.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        ///
        /// - Parameter mediaType: The media type according to which the receiver filters its AVFragmentedAssetTracks. (Media types are defined in AVMediaFormat.h)
        ///
        /// - Returns: An NSArray of AVFragmentedAssetTracks; may be empty if no tracks of the specified media type are available.
        #[deprecated = "Use loadTracksWithMediaType:completionHandler: instead"]
        #[unsafe(method(tracksWithMediaType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaType(
            &self,
            media_type: &AVMediaType,
        ) -> Retained<NSArray<AVFragmentedAssetTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "block2"
        ))]
        /// Loads an array of AVFragmentedAssetTracks of the asset that present media of the specified media type.
        ///
        /// - Parameter mediaType: The media type according to which AVAsset filters its AVFragmentedAssetTracks. (Media types are defined in AVMediaFormat.h.)
        /// - Parameter completionHandler: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks of the specified media type are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaType_completionHandler(
            &self,
            media_type: &AVMediaType,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVFragmentedAssetTrack>, *mut NSError),
            >,
        );

        #[cfg(all(feature = "AVAssetTrack", feature = "AVMediaFormat"))]
        /// Provides an array of AVFragmentedAssetTracks of the asset that present media with the specified characteristic.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        ///
        /// - Parameter mediaCharacteristic: The media characteristic according to which the receiver filters its AVFragmentedAssetTracks. (Media characteristics are defined in AVMediaFormat.h)
        ///
        /// - Returns: An NSArray of AVFragmentedAssetTracks; may be empty if no tracks with the specified characteristic are available.
        #[deprecated = "Use loadTracksWithMediaCharacteristic:completionHandler: instead"]
        #[unsafe(method(tracksWithMediaCharacteristic:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaCharacteristic(
            &self,
            media_characteristic: &AVMediaCharacteristic,
        ) -> Retained<NSArray<AVFragmentedAssetTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "block2"
        ))]
        /// Loads an array of AVFragmentedAssetTracks of the asset that present media with the specified characteristic.
        ///
        /// - Parameter mediaCharacteristic: The media characteristic according to which AVAsset filters its AVFragmentedAssetTracks. (Media characteristics are defined in AVMediaFormat.h.)
        /// - Parameter completionHandler: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks with the specified characteristic are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaCharacteristic:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaCharacteristic_completionHandler(
            &self,
            media_characteristic: &AVMediaCharacteristic,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVFragmentedAssetTrack>, *mut NSError),
            >,
        );
    );
}

extern_class!(
    /// A class that periodically checks whether additional fragments have been appended to fragmented assets.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedassetminder?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVFragmentedAssetMinder;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for AVFragmentedAssetMinder {}
);

impl AVFragmentedAssetMinder {
    extern_methods!(
        /// Creates an AVFragmentedAssetMinder, adds the specified asset to it, and sets the mindingInterval to the specified value.
        ///
        /// - Parameter asset: An instance of AVFragmentedAsset to add to the AVFragmentedAssetMinder
        /// - Parameter mindingInterval: The initial minding interval of the AVFragmentedAssetMinder.
        ///
        /// - Returns: A new instance of AVFragmentedAssetMinder.
        ///
        /// # Safety
        ///
        /// `asset` must implement AVFragmentMinding.
        #[unsafe(method(fragmentedAssetMinderWithAsset:mindingInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fragmentedAssetMinderWithAsset_mindingInterval(
            asset: &AVAsset,
            minding_interval: NSTimeInterval,
        ) -> Retained<Self>;

        /// Creates an AVFragmentedAssetMinder, adds the specified asset to it, and sets the mindingInterval to the specified value.
        ///
        /// - Parameter asset: An instance of AVFragmentedAsset to add to the AVFragmentedAssetMinder
        /// - Parameter mindingInterval: The initial minding interval of the AVFragmentedAssetMinder.
        ///
        /// - Returns: A new instance of AVFragmentedAssetMinder.
        ///
        /// # Safety
        ///
        /// `asset` must implement AVFragmentMinding.
        #[unsafe(method(initWithAsset:mindingInterval:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAsset_mindingInterval(
            this: Allocated<Self>,
            asset: &AVAsset,
            minding_interval: NSTimeInterval,
        ) -> Retained<Self>;

        /// An NSTimeInterval indicating how often a check for additional fragments should be performed. The default interval is 10.0.
        ///
        /// This property throws an excepion if a value is set less than one millisecond (0.001) in duration.
        #[unsafe(method(mindingInterval))]
        #[unsafe(method_family = none)]
        pub unsafe fn mindingInterval(&self) -> NSTimeInterval;

        /// Setter for [`mindingInterval`][Self::mindingInterval].
        #[unsafe(method(setMindingInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMindingInterval(&self, minding_interval: NSTimeInterval);

        /// An NSArray of the AVFragmentedAsset objects being minded.
        #[unsafe(method(assets))]
        #[unsafe(method_family = none)]
        pub unsafe fn assets(&self) -> Retained<NSArray<AVAsset>>;

        /// Adds a fragmented asset to the array of assets being minded.
        ///
        /// This method throws an exception if the asset is not a supported type (AVFragmentedAsset, AVFragmentedMovie), or if the asset is already being minded by another fragment minder.
        ///
        /// - Parameter asset: The fragmented asset to add to the minder.
        ///
        /// # Safety
        ///
        /// `asset` must implement AVFragmentMinding.
        #[unsafe(method(addFragmentedAsset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addFragmentedAsset(&self, asset: &AVAsset);

        /// Removes a fragmented asset from the array of assets being minded.
        ///
        /// This method throws an exception if the asset is not a supported type (AVFragmentedAsset, AVFragmentedMovie).
        ///
        /// - Parameter asset: The fragmented asset to remove from the minder.
        ///
        /// # Safety
        ///
        /// `asset` must implement AVFragmentMinding.
        #[unsafe(method(removeFragmentedAsset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFragmentedAsset(&self, asset: &AVAsset);
    );
}

/// Methods declared on superclass `NSObject`.
impl AVFragmentedAssetMinder {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVURLAssetContentKeyEligibility.
impl AVURLAsset {
    extern_methods!(
        /// Allows AVURLAsset to be added as a content key recipient to an AVContentKeySession.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(mayRequireContentKeysForMediaDataProcessing))]
        #[unsafe(method_family = none)]
        pub unsafe fn mayRequireContentKeysForMediaDataProcessing(&self) -> bool;
    );
}

#[cfg(feature = "AVContentKeySession")]
extern_conformance!(
    unsafe impl AVContentKeyRecipient for AVURLAsset {}
);
