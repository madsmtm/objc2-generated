//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// Indicates the restrictions used by the movie when resolving references to external media data. The value of this key is an NSNumber wrapping an AVAssetReferenceRestrictions enum value or the logical combination of multiple such values. See AVAsset.h for the declaration of the AVAssetReferenceRestrictions enum.
    ///
    /// Some movies can contain references to media data stored outside the movie's container, for example in another file. This key can be used to specify a policy to use when these references are encountered. If a movie contains one or more references of a type that is forbidden by the reference restrictions, loading of movie properties will fail. In addition, such a movie cannot be used with other AVFoundation modules, such as AVPlayerItem or AVAssetExportSession.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmoviereferencerestrictionskey?language=objc)
    pub static AVMovieReferenceRestrictionsKey: &'static NSString;
}

extern "C" {
    /// Indicates whether alias data references in the movie should be parsed and resolved.
    ///
    /// Default is NO. Although the majority of QuickTime movie files contain all of the media data they require, some contain references to media stored in other files. While AVFoundation and CoreMedia typically employ a URL reference for this purpose, older implementations such as QuickTime 7 have commonly employed a Macintosh alias instead, as documented in the QuickTime File Format specification. If your application must work with legacy QuickTime movie files containing alias-based references to media data stored in other files, the use of this AVMovie initialization option is appropriate. AVMovie and AVMutableMovie do not create movies using alias data references to external media files.
    ///
    /// If you provide a value for AVMovieReferenceRestrictionsKey, restrictions will be observed for resolved alias references just as they are for URL references.
    ///
    /// For more details about alias resolution, consult documentation of the bookmark-related interfaces of NSURL.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmovieshouldsupportaliasdatareferenceskey?language=objc)
    pub static AVMovieShouldSupportAliasDataReferencesKey: &'static NSString;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmovie?language=objc)
    #[unsafe(super(AVAsset, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AVAsset")]
    pub struct AVMovie;
);

#[cfg(all(feature = "AVAsset", feature = "AVAsynchronousKeyValueLoading"))]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVMovie {}
);

#[cfg(feature = "AVAsset")]
extern_conformance!(
    unsafe impl NSCopying for AVMovie {}
);

#[cfg(feature = "AVAsset")]
unsafe impl CopyingHelper for AVMovie {
    type Result = Self;
}

#[cfg(feature = "AVAsset")]
extern_conformance!(
    unsafe impl NSMutableCopying for AVMovie {}
);

#[cfg(feature = "AVAsset")]
unsafe impl MutableCopyingHelper for AVMovie {
    type Result = AVMutableMovie;
}

#[cfg(feature = "AVAsset")]
extern_conformance!(
    unsafe impl NSObjectProtocol for AVMovie {}
);

#[cfg(feature = "AVAsset")]
impl AVMovie {
    extern_methods!(
        #[cfg(feature = "AVMediaFormat")]
        /// Provides the file types the AVMovie class understands.
        ///
        /// Returns: An NSArray of UTIs identifying the file types the AVMovie class understands.
        #[unsafe(method(movieTypes))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieTypes() -> Retained<NSArray<AVFileType>>;

        /// Creates an AVMovie object from a movie header stored in a QuickTime movie file or ISO base media file.
        ///
        /// Parameter `URL`: An NSURL object that specifies a file containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from a file and then append sample buffers to any of its tracks, you must first set one of these properties
        /// to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(movieWithURL:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieWithURL_options(
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Creates an AVMovie object from a movie header stored in a QuickTime movie file or ISO base media file.
        ///
        /// Parameter `URL`: An NSURL object that specifies a file containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from a file and then append sample buffers to any of its tracks, you must first set one of these properties
        /// to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithURL:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_options(
            this: Allocated<Self>,
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Creates an AVMovie object from a movie header stored in an NSData object.
        ///
        /// Parameter `data`: An NSData object containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// You can use this method to operate on movie headers that are not stored in files; this might include movie headers on the pasteboard (which do not contain media data). In general you should avoid loading an entire movie file with its media data into an instance of NSData! By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(movieWithData:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieWithData_options(
            data: &NSData,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Creates an AVMovie object from a movie header stored in an NSData object.
        ///
        /// Parameter `data`: An NSData object containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// You can use this method to operate on movie headers that are not stored in files. In general you should avoid loading an entire movie file with its media data into an instance of NSData!
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil. If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithData:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData_options(
            this: Allocated<Self>,
            data: &NSData,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// The URL with which the instance of AVMovie was initialized; may be nil.
        #[unsafe(method(URL))]
        #[unsafe(method_family = none)]
        pub unsafe fn URL(&self) -> Option<Retained<NSURL>>;

        /// The data block with which the instance of AVMovie was initialized; may be nil.
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Option<Retained<NSData>>;

        /// The default storage container for media data added to a movie.
        ///
        /// The value of this property is an AVMediaDataStorage object that indicates where sample data that is added to a movie should be written by default.
        #[unsafe(method(defaultMediaDataStorage))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultMediaDataStorage(&self) -> Option<Retained<AVMediaDataStorage>>;

        #[cfg(all(feature = "AVAssetTrack", feature = "AVMovieTrack"))]
        /// The tracks in a movie.
        ///
        /// The value of this property is an array of tracks the movie contains; the tracks are of type AVMovieTrack.
        #[unsafe(method(tracks))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracks(&self) -> Retained<NSArray<AVMovieTrack>>;

        /// Indicates whether the movie file is capable of being extended by fragments.
        ///
        /// The value of this property is YES if an 'mvex' box is present in the 'moov' box. The 'mvex' box is necessary in order to signal the possible presence of later 'moof' boxes.
        #[unsafe(method(canContainMovieFragments))]
        #[unsafe(method_family = none)]
        pub unsafe fn canContainMovieFragments(&self) -> bool;

        /// Indicates whether the movie file is extended by at least one movie fragment.
        ///
        /// The value of this property is YES if canContainMovieFragments is YES and at least one 'moof' box is present after the 'moov' box.
        #[unsafe(method(containsMovieFragments))]
        #[unsafe(method_family = none)]
        pub unsafe fn containsMovieFragments(&self) -> bool;
    );
}

/// Methods declared on superclass `AVAsset`.
#[cfg(feature = "AVAsset")]
impl AVMovie {
    extern_methods!(
        /// Returns an instance of AVAsset for inspection of a media resource.
        ///
        /// Returns a newly allocated instance of a subclass of AVAsset initialized with the specified URL.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        ///
        /// - Returns: An instance of AVAsset.
        #[unsafe(method(assetWithURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assetWithURL(url: &NSURL) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "AVAsset")]
impl AVMovie {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// These options can be passed into writeMovieHeaderToURL:fileType:options:error: to control the writing of a movie header to a destination URL.
///
/// Writing the movie header will remove any existing movie header in the destination file and add a new movie header, preserving any other data in the file. If the destination file was empty, a file type box will be written at the beginning of the file.
///
/// If set, writing the movie header will truncate all existing data in the destination file and write a new movie header, thereby creating a pure reference movie file. A file type box will be written at the beginning of the file.
///
/// You would not want to use the AVMovieWritingTruncateDestinationToMovieHeaderOnly option if you had written sample data to the destination file using (for example) -[AVMutableMovie insertTimeRange:ofAsset:atTime:copySampleData:error:] with copySampleData set to YES, since that data would be lost.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmoviewritingoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVMovieWritingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl AVMovieWritingOptions: NSUInteger {
        #[doc(alias = "AVMovieWritingAddMovieHeaderToDestination")]
        const AddMovieHeaderToDestination = 0;
        #[doc(alias = "AVMovieWritingTruncateDestinationToMovieHeaderOnly")]
        const TruncateDestinationToMovieHeaderOnly = 1<<0;
    }
}

unsafe impl Encode for AVMovieWritingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for AVMovieWritingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// AVMovieMovieHeaderSupport.
#[cfg(feature = "AVAsset")]
impl AVMovie {
    extern_methods!(
        #[cfg(feature = "AVMediaFormat")]
        /// Creates an NSData object containing the movie header of the AVMovie object.
        ///
        /// Parameter `fileType`: A UTI indicating the specific file format of the movie header (e.g. AVFileTypeQuickTimeMovie for a QuickTime movie).
        ///
        /// Parameter `outError`: If an error occurs reading the movie header, describes the nature of the failure.
        ///
        /// Returns: An NSData object.
        ///
        /// The movie header will be a pure reference movie, with no base URL, suitable for use on the pasteboard.
        #[unsafe(method(movieHeaderWithFileType:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieHeaderWithFileType_error(
            &self,
            file_type: &AVFileType,
        ) -> Result<Retained<NSData>, Retained<NSError>>;

        #[cfg(feature = "AVMediaFormat")]
        /// Writes the movie header to a destination URL.
        ///
        /// Parameter `URL`: An NSURL object indicating where to write the movie header.
        ///
        /// Parameter `fileType`: A UTI indicating the specific file format (e.g. AVFileTypeQuickTimeMovie for a QuickTime movie).
        ///
        /// Parameter `options`: An NSUInteger whose bits specify options for the writing of the movie header. See AVMovieWritingOptions above.
        ///
        /// Parameter `outError`: If an error occurs writing the movie header, describes the nature of the failure.
        ///
        /// Note that modifications to instances of AVMutableMovie, to their constituent AVMutableMovieTracks, or to their collections of metadata are committed to storage when their movie headers are written.
        #[unsafe(method(writeMovieHeaderToURL:fileType:options:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeMovieHeaderToURL_fileType_options_error(
            &self,
            url: &NSURL,
            file_type: &AVFileType,
            options: AVMovieWritingOptions,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "AVMediaFormat")]
        /// Indicates whether a movie header for the AVMovie object can be created for the specified file type.
        ///
        /// Parameter `fileType`: A UTI indicating a movie file format (e.g. AVFileTypeQuickTimeMovie for a QuickTime movie).
        ///
        /// This method returns a BOOL that indicates whether a movie header of the specified type can be created for the receiver. For example, this method returns NO if the movie contains tracks whose media types or media subtypes are not allowed by the specified file type.
        #[unsafe(method(isCompatibleWithFileType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isCompatibleWithFileType(&self, file_type: &AVFileType) -> bool;
    );
}

/// AVMovieTrackInspection.
#[cfg(feature = "AVAsset")]
impl AVMovie {
    extern_methods!(
        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMovieTrack",
            feature = "objc2-core-media"
        ))]
        /// Provides an instance of AVMovieTrack that represents the track of the specified trackID.
        ///
        /// Parameter `trackID`: The trackID of the requested AVMovieTrack.
        ///
        /// Returns: An instance of AVMovieTrack; may be nil if no track of the specified trackID is available.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        #[deprecated = "Use loadTrackWithTrackID:completionHandler: instead"]
        #[unsafe(method(trackWithTrackID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackWithTrackID(
            &self,
            track_id: CMPersistentTrackID,
        ) -> Option<Retained<AVMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMovieTrack",
            feature = "block2",
            feature = "objc2-core-media"
        ))]
        /// Loads an instance of AVMovieTrack that represents the track of the specified trackID.
        ///
        /// Parameter `trackID`: The trackID of the requested AVMovieTrack.
        ///
        /// Parameter `completionHandler`: A block that is called when the loading is finished, with either the loaded track (which may be nil if no track of the specified trackID is available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTrackWithTrackID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTrackWithTrackID_completionHandler(
            &self,
            track_id: CMPersistentTrackID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut AVMovieTrack, *mut NSError)>,
        );

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack"
        ))]
        /// Provides an array of AVMovieTracks of the asset that present media of the specified media type.
        ///
        /// Parameter `mediaType`: The media type according to which the receiver filters its AVMovieTracks. (Media types are defined in AVMediaFormat.h)
        ///
        /// Returns: An NSArray of AVMovieTracks; may be empty if no tracks of the specified media type are available.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        #[deprecated = "Use loadTracksWithMediaType:completionHandler: instead"]
        #[unsafe(method(tracksWithMediaType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaType(
            &self,
            media_type: &AVMediaType,
        ) -> Retained<NSArray<AVMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack",
            feature = "block2"
        ))]
        /// Loads an array of AVMovieTracks of the asset that present media of the specified media type.
        ///
        /// Parameter `mediaType`: The media type according to which AVAsset filters its AVMovieTracks. (Media types are defined in AVMediaFormat.h.)
        ///
        /// Parameter `completionHandler`: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks of the specified media type are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaType_completionHandler(
            &self,
            media_type: &AVMediaType,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSArray<AVMovieTrack>, *mut NSError)>,
        );

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack"
        ))]
        /// Provides an array of AVMovieTracks of the asset that present media with the specified characteristic.
        ///
        /// Parameter `mediaCharacteristic`: The media characteristic according to which the receiver filters its AVMovieTracks. (Media characteristics are defined in AVMediaFormat.h)
        ///
        /// Returns: An NSArray of AVMovieTracks; may be empty if no tracks with the specified characteristic are available.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        #[deprecated = "Use loadTracksWithMediaCharacteristic:completionHandler: instead"]
        #[unsafe(method(tracksWithMediaCharacteristic:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaCharacteristic(
            &self,
            media_characteristic: &AVMediaCharacteristic,
        ) -> Retained<NSArray<AVMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack",
            feature = "block2"
        ))]
        /// Loads an array of AVMovieTracks of the asset that present media with the specified characteristic.
        ///
        /// Parameter `mediaCharacteristic`: The media characteristic according to which AVAsset filters its AVMovieTracks. (Media characteristics are defined in AVMediaFormat.h.)
        ///
        /// Parameter `completionHandler`: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks with the specified characteristic are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaCharacteristic:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaCharacteristic_completionHandler(
            &self,
            media_characteristic: &AVMediaCharacteristic,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSArray<AVMovieTrack>, *mut NSError)>,
        );
    );
}

extern_class!(
    /// AVMutableMovie adds to its immutable superclass, AVMovie, several categories of methods for editing QuickTime movie files, e.g. inserting and removing time ranges of media, adding and removing tracks, and modifying the metadata collections stored therein.
    ///
    ///
    /// By default, after creating an AVMutableMovie the defaultMediaDataStorage property will be nil and each associated AVMutableMovieTrack's mediaDataStorage property will be nil. If you want to create an AVMutableMovie from a file and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmutablemovie?language=objc)
    #[unsafe(super(AVMovie, AVAsset, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AVAsset")]
    pub struct AVMutableMovie;
);

#[cfg(all(feature = "AVAsset", feature = "AVAsynchronousKeyValueLoading"))]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVMutableMovie {}
);

#[cfg(feature = "AVAsset")]
extern_conformance!(
    unsafe impl NSCopying for AVMutableMovie {}
);

#[cfg(feature = "AVAsset")]
unsafe impl CopyingHelper for AVMutableMovie {
    type Result = AVMovie;
}

#[cfg(feature = "AVAsset")]
extern_conformance!(
    unsafe impl NSMutableCopying for AVMutableMovie {}
);

#[cfg(feature = "AVAsset")]
unsafe impl MutableCopyingHelper for AVMutableMovie {
    type Result = Self;
}

#[cfg(feature = "AVAsset")]
extern_conformance!(
    unsafe impl NSObjectProtocol for AVMutableMovie {}
);

#[cfg(feature = "AVAsset")]
impl AVMutableMovie {
    extern_methods!(
        /// Creates an AVMutableMovie object from a movie header stored in a QuickTime movie file or ISO base media file.
        ///
        /// Parameter `URL`: An NSURL object that specifies a file containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMutableMovie object.
        ///
        /// Parameter `outError`: If an error occurs creating a movie, describes the nature of the failure.
        ///
        /// Returns: An AVMutableMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMutableMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from a file and then append sample buffers to any of its tracks, you must first set one of these properties
        /// to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(movieWithURL:options:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieWithURL_options_error(
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        /// Creates an AVMutableMovie object from a movie header stored in a QuickTime movie file or ISO base media file.
        ///
        /// Parameter `URL`: An NSURL object that specifies a file containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMutableMovie object.
        ///
        /// Parameter `outError`: If an error occurs creating a movie, describes the nature of the failure.
        ///
        /// Returns: An AVMutableMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMutableMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from a file and then append sample buffers to any of its tracks, you must first set one of these properties
        /// to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithURL:options:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_options_error(
            this: Allocated<Self>,
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        /// Creates an AVMutableMovie object from a movie header stored in an NSData object.
        ///
        /// Parameter `data`: An NSData object containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMutableMovie object.
        ///
        /// Parameter `outError`: If an error occurs creating a movie, describes the nature of the failure.
        ///
        /// Returns: An AVMutableMovie object
        ///
        /// You can use this method to operate on movie headers that are not stored in files. In general you should avoid loading an entire movie file with its media data into an instance of NSData!
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMutableMovieTrack's mediaDataStorage property will be nil. If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(movieWithData:options:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieWithData_options_error(
            data: &NSData,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        /// Creates an AVMutableMovie object from a movie header stored in an NSData object.
        ///
        /// Parameter `data`: An NSData object containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMutableMovie object.
        ///
        /// Parameter `outError`: If an error occurs creating a movie, describes the nature of the failure.
        ///
        /// Returns: An AVMutableMovie object
        ///
        /// You can use this method to operate on movie headers that are not stored in files. In general you should avoid loading an entire movie file with its media data into an instance of NSData!
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMutableMovieTrack's mediaDataStorage property will be nil. If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithData:options:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData_options_error(
            this: Allocated<Self>,
            data: &NSData,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        /// Creates an AVMutableMovie object without tracks (and therefore without media).
        ///
        /// Parameter `movie`: If you wish to transfer settings from an existing movie (including movie userdata and metadata, preferred rate, preferred volume, etc.), pass a reference to an AVMovie object representing that movie. Otherwise pass nil. The userdata and metadata from the source movie may need to be converted if the format of that movie differs from fileType; you may wish to inspect the userdata or metadata of the receiver to ensure that important data was copied.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMutableMovie object. Pass nil for default initialization behavior.
        ///
        /// Parameter `outError`: If an error occurs creating a movie, describes the nature of the failure.
        ///
        /// Returns: An AVMutableMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(movieWithSettingsFromMovie:options:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieWithSettingsFromMovie_options_error(
            movie: Option<&AVMovie>,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        /// Creates an AVMutableMovie object without tracks (and therefore without media).
        ///
        /// Parameter `movie`: If you wish to transfer settings from an existing movie (including movie userdata and metadata, preferred rate, preferred volume, etc.), pass a reference to an AVMovie object representing that movie. Otherwise pass nil. The userdata and metadata from the source movie may need to be converted if the format of that movie differs from fileType; you may wish to inspect the userdata or metadata of the receiver to ensure that important data was copied.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMutableMovie object. Pass nil for default initialization behavior.
        ///
        /// Parameter `outError`: If an error occurs creating a movie, describes the nature of the failure.
        ///
        /// Returns: An AVMutableMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithSettingsFromMovie:options:error:_))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSettingsFromMovie_options_error(
            this: Allocated<Self>,
            movie: Option<&AVMovie>,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        /// The natural rate at which the movie is to be played; often but not always 1.0.
        #[unsafe(method(preferredRate))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredRate(&self) -> c_float;

        /// Setter for [`preferredRate`][Self::preferredRate].
        #[unsafe(method(setPreferredRate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredRate(&self, preferred_rate: c_float);

        /// The preferred volume of the audible media data of the movie; often but not always 1.0.
        #[unsafe(method(preferredVolume))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredVolume(&self) -> c_float;

        /// Setter for [`preferredVolume`][Self::preferredVolume].
        #[unsafe(method(setPreferredVolume:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredVolume(&self, preferred_volume: c_float);

        #[cfg(feature = "objc2-core-foundation")]
        /// A CGAffineTransform indicating the transform specified in the movie's storage container as the preferred transformation of the visual media data for display purposes; the value is often but not always CGAffineTransformIdentity.
        #[unsafe(method(preferredTransform))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredTransform(&self) -> CGAffineTransform;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`preferredTransform`][Self::preferredTransform].
        #[unsafe(method(setPreferredTransform:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredTransform(&self, preferred_transform: CGAffineTransform);

        #[cfg(feature = "objc2-core-media")]
        /// For file types that contain a 'moov' atom, such as QuickTime Movie files, specifies the time scale of the movie.
        ///
        /// The default movie time scale is 600. In certain cases, you may want to set this to a different value. For instance, a movie that
        /// contains a single audio track should typically have the movie time scale set to the media time scale of that track.
        ///
        /// This property should be set on a new empty movie before any edits are performed on the movie.
        #[unsafe(method(timescale))]
        #[unsafe(method_family = none)]
        pub unsafe fn timescale(&self) -> CMTimeScale;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`timescale`][Self::timescale].
        #[unsafe(method(setTimescale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimescale(&self, timescale: CMTimeScale);

        #[cfg(all(feature = "AVAssetTrack", feature = "AVMovieTrack"))]
        /// The tracks in a mutable movie.
        ///
        /// The value of this property is an array of tracks the mutable movie contains; the tracks are of type AVMutableMovieTrack.
        #[unsafe(method(tracks))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracks(&self) -> Retained<NSArray<AVMutableMovieTrack>>;
    );
}

/// Methods declared on superclass `AVMovie`.
#[cfg(feature = "AVAsset")]
impl AVMutableMovie {
    extern_methods!(
        /// Creates an AVMovie object from a movie header stored in a QuickTime movie file or ISO base media file.
        ///
        /// Parameter `URL`: An NSURL object that specifies a file containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from a file and then append sample buffers to any of its tracks, you must first set one of these properties
        /// to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(movieWithURL:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieWithURL_options(
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Creates an AVMovie object from a movie header stored in a QuickTime movie file or ISO base media file.
        ///
        /// Parameter `URL`: An NSURL object that specifies a file containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from a file and then append sample buffers to any of its tracks, you must first set one of these properties
        /// to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithURL:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_options(
            this: Allocated<Self>,
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Creates an AVMovie object from a movie header stored in an NSData object.
        ///
        /// Parameter `data`: An NSData object containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// You can use this method to operate on movie headers that are not stored in files; this might include movie headers on the pasteboard (which do not contain media data). In general you should avoid loading an entire movie file with its media data into an instance of NSData! By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(movieWithData:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieWithData_options(
            data: &NSData,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Creates an AVMovie object from a movie header stored in an NSData object.
        ///
        /// Parameter `data`: An NSData object containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// You can use this method to operate on movie headers that are not stored in files. In general you should avoid loading an entire movie file with its media data into an instance of NSData!
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil. If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithData:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData_options(
            this: Allocated<Self>,
            data: &NSData,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `AVAsset`.
#[cfg(feature = "AVAsset")]
impl AVMutableMovie {
    extern_methods!(
        /// Returns an instance of AVAsset for inspection of a media resource.
        ///
        /// Returns a newly allocated instance of a subclass of AVAsset initialized with the specified URL.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        ///
        /// - Returns: An instance of AVAsset.
        #[unsafe(method(assetWithURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assetWithURL(url: &NSURL) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "AVAsset")]
impl AVMutableMovie {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVMutableMovieMovieLevelEditing.
#[cfg(feature = "AVAsset")]
impl AVMutableMovie {
    extern_methods!(
        /// Whether a movie has been modified.
        ///
        /// The value of this property is a BOOL that indicates whether the AVMutableMovie object has been modified since it was created, was last written, or had its modified state cleared via a call to setModified:NO.
        #[unsafe(method(isModified))]
        #[unsafe(method_family = none)]
        pub unsafe fn isModified(&self) -> bool;

        /// Setter for [`isModified`][Self::isModified].
        #[unsafe(method(setModified:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setModified(&self, modified: bool);

        /// The default storage container for media data added to a movie.
        ///
        /// The value of this property is an AVMediaDataStorage object that indicates where sample data that is added to a movie should be written, for any track for whose mediaDataStorage property is nil.
        #[unsafe(method(defaultMediaDataStorage))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultMediaDataStorage(&self) -> Option<Retained<AVMediaDataStorage>>;

        /// Setter for [`defaultMediaDataStorage`][Self::defaultMediaDataStorage].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDefaultMediaDataStorage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDefaultMediaDataStorage(
            &self,
            default_media_data_storage: Option<&AVMediaDataStorage>,
        );

        #[cfg(feature = "objc2-core-media")]
        /// A CMTime that indicates the duration for interleaving runs of samples of each track.
        ///
        /// The default interleaving period is 0.5 seconds.
        #[unsafe(method(interleavingPeriod))]
        #[unsafe(method_family = none)]
        pub unsafe fn interleavingPeriod(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`interleavingPeriod`][Self::interleavingPeriod].
        #[unsafe(method(setInterleavingPeriod:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInterleavingPeriod(&self, interleaving_period: CMTime);

        #[cfg(feature = "objc2-core-media")]
        /// Inserts all the tracks of a timeRange of an asset into a movie.
        ///
        /// Parameter `timeRange`: The time range of the asset to be inserted.
        ///
        /// Parameter `asset`: An AVAsset object indicating the source of the inserted media. Only instances of AVURLAsset and AVComposition are supported.
        /// Must not be nil.
        ///
        /// Parameter `startTime`: The time in the target movie at which the media is to be inserted.
        ///
        /// Parameter `copySampleData`: A BOOL value that indicates whether sample data is to be copied from the source to the destination during edits.
        /// If YES, the sample data is written to the location specified by the track property mediaDataStorage if non-nil,
        /// or else by the movie property defaultMediaDataStorage if non-nil; if both are nil, the method will fail and return NO.
        /// If NO, sample data will not be written and sample references to the samples in their original container will be added as necessary.
        /// Note that in this case, this method will fail if the source AVAsset is not able to provide sample reference information for the original container.
        ///
        /// Parameter `outError`: If the insertion fails, an NSError object that describes the nature of the failure.
        ///
        /// Returns: A BOOL value that indicates the success of the insertion.
        ///
        /// This method may add new tracks to the target movie to ensure that all tracks of the asset are represented in the inserted timeRange.
        /// Existing content at the specified startTime will be pushed out by the duration of timeRange.
        /// Note that metadata will not be automatically copied.
        #[unsafe(method(insertTimeRange:ofAsset:atTime:copySampleData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertTimeRange_ofAsset_atTime_copySampleData_error(
            &self,
            time_range: CMTimeRange,
            asset: &AVAsset,
            start_time: CMTime,
            copy_sample_data: bool,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "objc2-core-media")]
        /// Adds an empty time range to the target movie.
        ///
        /// Parameter `timeRange`: The time range to be made empty. Note that you cannot add empty time ranges to the end of a movie.
        #[unsafe(method(insertEmptyTimeRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertEmptyTimeRange(&self, time_range: CMTimeRange);

        #[cfg(feature = "objc2-core-media")]
        /// Removes a specified time range from a movie.
        ///
        /// Parameter `timeRange`: The time range to be removed.
        #[unsafe(method(removeTimeRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTimeRange(&self, time_range: CMTimeRange);

        #[cfg(feature = "objc2-core-media")]
        /// Changes the duration of a time range of a movie.
        ///
        /// Parameter `timeRange`: The time range to be scaled.
        ///
        /// Parameter `duration`: The new duration of the time range.
        #[unsafe(method(scaleTimeRange:toDuration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn scaleTimeRange_toDuration(&self, time_range: CMTimeRange, duration: CMTime);
    );
}

/// AVMutableMovieTrackLevelEditing.
#[cfg(feature = "AVAsset")]
impl AVMutableMovie {
    extern_methods!(
        #[cfg(all(feature = "AVAssetTrack", feature = "AVMovieTrack"))]
        /// Provides a reference to a track of a mutable movie into which any time range of an AVAssetTrack
        /// can be inserted (via -[AVMutableMovieTrack insertTimeRange:ofTrack:atTime:copySampleData:error:]).
        ///
        /// Parameter `track`: A reference to the AVAssetTrack from which a time range may be inserted.
        ///
        /// Returns: An AVMutableMovieTrack that can accommodate the insertion.
        /// If no such track is available, the result is nil. A new track of the same media type
        /// as the AVAssetTrack can be created via -addMutableTrackWithMediaType:copySettingsFromTrack:options:,
        /// and this new track will be compatible.
        ///
        /// For best performance, the number of tracks in a movie should be kept to a minimum, corresponding to the
        /// number for which media data must be presented in parallel. If media data of the same type is to be presented
        /// serially, even from multiple assets, a single track of that media type should be used. This method,
        /// -mutableTrackCompatibleWithTrack:, can help the client to identify an existing target track for an insertion.
        #[unsafe(method(mutableTrackCompatibleWithTrack:))]
        #[unsafe(method_family = none)]
        pub unsafe fn mutableTrackCompatibleWithTrack(
            &self,
            track: &AVAssetTrack,
        ) -> Option<Retained<AVMutableMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack"
        ))]
        /// Adds an empty track to the target movie.
        ///
        /// Parameter `mediaType`: The media type of the new track (e.g. AVMediaTypeVideo for a video track).
        ///
        /// Parameter `track`: If you wish to transfer settings from an existing track, including width, height, preferred volume, etc., pass a reference to an AVAssetTrack representing that track. Otherwise pass nil.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the new AVMutableMovieTrack object. Pass nil for default initialization behavior.
        ///
        /// Returns: An AVMutableMovieTrack object
        ///
        /// The trackID of the newly added track is a property of the returned instance of AVMutableMovieTrack.
        /// This method throws an exception if media type is not equal to the track's media type, or if any option is invalid.
        /// Note that metadata will not be automatically copied.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(addMutableTrackWithMediaType:copySettingsFromTrack:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addMutableTrackWithMediaType_copySettingsFromTrack_options(
            &self,
            media_type: &AVMediaType,
            track: Option<&AVAssetTrack>,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Option<Retained<AVMutableMovieTrack>>;

        #[cfg(all(feature = "AVAssetTrack", feature = "AVMovieTrack"))]
        /// Adds one or more empty tracks to the target movie, copying track settings from the source tracks.
        ///
        /// Parameter `existingTracks`: An array of AVAssetTrack objects.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the new AVMutableMovieTrack objects. Pass nil for default initialization behavior.
        ///
        /// Returns: An array of AVMutableMovieTrack objects; the index of a track in this array is the same as the index of its source track in the existingTracks array.
        ///
        /// This method creates one or more empty tracks in the target movie and configures those tracks with settings (such as track userdata and metadata, width, height, and preferred volume) copied from the source tracks in the existingTracks array. Also, properties involving pairs of tracks (such as track references) are copied from the source tracks to the target tracks.
        /// This method throws an exception if any option is invalid.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(addMutableTracksCopyingSettingsFromTracks:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addMutableTracksCopyingSettingsFromTracks_options(
            &self,
            existing_tracks: &NSArray<AVAssetTrack>,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<NSArray<AVMutableMovieTrack>>;

        #[cfg(all(feature = "AVAssetTrack", feature = "AVMovieTrack"))]
        /// Removes a track from the target movie.
        ///
        /// Parameter `track`: The track to be removed.
        #[unsafe(method(removeTrack:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTrack(&self, track: &AVMovieTrack);
    );
}

/// AVMutableMovieMetadataEditing.
#[cfg(feature = "AVAsset")]
impl AVMutableMovie {
    extern_methods!(
        #[cfg(feature = "AVMetadataItem")]
        /// A collection of metadata stored by the movie.
        ///
        /// The value of this property is an array of AVMetadataItem objects representing the collection of metadata stored by the movie.
        #[unsafe(method(metadata))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadata(&self) -> Retained<NSArray<AVMetadataItem>>;

        #[cfg(feature = "AVMetadataItem")]
        /// Setter for [`metadata`][Self::metadata].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMetadata:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMetadata(&self, metadata: &NSArray<AVMetadataItem>);
    );
}

/// AVMutableMovieTrackInspection.
#[cfg(feature = "AVAsset")]
impl AVMutableMovie {
    extern_methods!(
        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMovieTrack",
            feature = "objc2-core-media"
        ))]
        /// Provides an instance of AVMutableMovieTrack that represents the track of the specified trackID.
        ///
        /// Parameter `trackID`: The trackID of the requested AVMutableMovieTrack.
        ///
        /// Returns: An instance of AVMutableMovieTrack; may be nil if no track of the specified trackID is available.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        #[unsafe(method(trackWithTrackID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackWithTrackID(
            &self,
            track_id: CMPersistentTrackID,
        ) -> Option<Retained<AVMutableMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMovieTrack",
            feature = "block2",
            feature = "objc2-core-media"
        ))]
        /// Loads an instance of AVMutableMovieTrack that represents the track of the specified trackID.
        ///
        /// Parameter `trackID`: The trackID of the requested AVMutableMovieTrack.
        ///
        /// Parameter `completionHandler`: A block that is called when the loading is finished, with either the loaded track (which may be nil if no track of the specified trackID is available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTrackWithTrackID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTrackWithTrackID_completionHandler(
            &self,
            track_id: CMPersistentTrackID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut AVMutableMovieTrack, *mut NSError)>,
        );

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack"
        ))]
        /// Provides an array of AVMutableMovieTracks of the asset that present media of the specified media type.
        ///
        /// Parameter `mediaType`: The media type according to which the receiver filters its AVMutableMovieTracks. (Media types are defined in AVMediaFormat.h)
        ///
        /// Returns: An NSArray of AVMutableMovieTracks; may be empty if no tracks of the specified media type are available.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        #[unsafe(method(tracksWithMediaType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaType(
            &self,
            media_type: &AVMediaType,
        ) -> Retained<NSArray<AVMutableMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack",
            feature = "block2"
        ))]
        /// Loads an array of AVMutableMovieTracks of the asset that present media of the specified media type.
        ///
        /// Parameter `mediaType`: The media type according to which AVAsset filters its AVMutableMovieTracks. (Media types are defined in AVMediaFormat.h.)
        ///
        /// Parameter `completionHandler`: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks of the specified media type are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaType_completionHandler(
            &self,
            media_type: &AVMediaType,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVMutableMovieTrack>, *mut NSError),
            >,
        );

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack"
        ))]
        /// Provides an array of AVMutableMovieTracks of the asset that present media with the specified characteristic.
        ///
        /// Parameter `mediaCharacteristic`: The media characteristic according to which the receiver filters its AVMutableMovieTracks. (Media characteristics are defined in AVMediaFormat.h)
        ///
        /// Returns: An NSArray of AVMutableMovieTracks; may be empty if no tracks with the specified characteristic are available.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        #[unsafe(method(tracksWithMediaCharacteristic:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaCharacteristic(
            &self,
            media_characteristic: &AVMediaCharacteristic,
        ) -> Retained<NSArray<AVMutableMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack",
            feature = "block2"
        ))]
        /// Loads an array of AVMutableMovieTracks of the asset that present media with the specified characteristic.
        ///
        /// Parameter `mediaCharacteristic`: The media characteristic according to which AVAsset filters its AVMutableMovieTracks. (Media characteristics are defined in AVMediaFormat.h.)
        ///
        /// Parameter `completionHandler`: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks with the specified characteristic are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaCharacteristic:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaCharacteristic_completionHandler(
            &self,
            media_characteristic: &AVMediaCharacteristic,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVMutableMovieTrack>, *mut NSError),
            >,
        );
    );
}

extern_class!(
    /// Media sample data storage file.
    ///
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmediadatastorage?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVMediaDataStorage;
);

unsafe impl Send for AVMediaDataStorage {}

unsafe impl Sync for AVMediaDataStorage {}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVMediaDataStorage {}
);

impl AVMediaDataStorage {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// Creates an AVMediaDataStorage object associated with a file URL.
        ///
        /// Parameter `URL`: An NSURL object that specifies a file where sample data that is added to a movie or track should be written.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMediaDataStorage object. Currently no keys are defined.
        ///
        /// Returns: An AVMediaDataStorage object
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithURL:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_options(
            this: Allocated<Self>,
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// The URL from which the receiver was initialized; may be nil.
        #[unsafe(method(URL))]
        #[unsafe(method_family = none)]
        pub unsafe fn URL(&self) -> Option<Retained<NSURL>>;
    );
}

extern "C" {
    /// Posted after the value of
    /// "
    /// containsMovieFragments" has already been loaded and the AVFragmentedMovie is added to an AVFragmentedMovieMinder, either when 1) movie fragments are detected in the movie file on disk after it had previously contained none or when 2) no movie fragments are detected in the movie file on disk after it had previously contained one or more.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedmoviecontainsmoviefragmentsdidchangenotification?language=objc)
    pub static AVFragmentedMovieContainsMovieFragmentsDidChangeNotification: &'static NSString;
}

extern "C" {
    /// Posted when the duration of an AVFragmentedMovie changes while it's being minded by an AVFragmentedMovieMinder, but only for changes that occur after the status of the value of
    /// "
    /// duration" has reached AVKeyValueStatusLoaded.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedmoviedurationdidchangenotification?language=objc)
    pub static AVFragmentedMovieDurationDidChangeNotification: &'static NSString;
}

extern "C" {
    /// Posted when the movie file on disk is defragmented while an AVFragmentedMovie is being minded by an AVFragmentedMovieMinder, but only if the defragmentation occurs after the status of the value of
    /// "
    /// canContainMovieFragments" has reached AVKeyValueStatusLoaded.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedmoviewasdefragmentednotification?language=objc)
    pub static AVFragmentedMovieWasDefragmentedNotification: &'static NSString;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedmovie?language=objc)
    #[unsafe(super(AVMovie, AVAsset, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AVAsset")]
    pub struct AVFragmentedMovie;
);

#[cfg(feature = "AVAsset")]
unsafe impl Send for AVFragmentedMovie {}

#[cfg(feature = "AVAsset")]
unsafe impl Sync for AVFragmentedMovie {}

#[cfg(all(feature = "AVAsset", feature = "AVAsynchronousKeyValueLoading"))]
extern_conformance!(
    unsafe impl AVAsynchronousKeyValueLoading for AVFragmentedMovie {}
);

#[cfg(feature = "AVAsset")]
extern_conformance!(
    unsafe impl AVFragmentMinding for AVFragmentedMovie {}
);

#[cfg(feature = "AVAsset")]
extern_conformance!(
    unsafe impl NSObjectProtocol for AVFragmentedMovie {}
);

#[cfg(feature = "AVAsset")]
impl AVFragmentedMovie {
    extern_methods!(
        #[cfg(all(feature = "AVAssetTrack", feature = "AVMovieTrack"))]
        /// The tracks in a movie.
        ///
        /// The value of this property is an array of tracks the movie contains; the tracks are of type AVFragmentedMovieTrack.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(tracks))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracks(&self) -> Retained<NSArray<AVFragmentedMovieTrack>>;
    );
}

/// Methods declared on superclass `AVMovie`.
#[cfg(feature = "AVAsset")]
impl AVFragmentedMovie {
    extern_methods!(
        /// Creates an AVMovie object from a movie header stored in a QuickTime movie file or ISO base media file.
        ///
        /// Parameter `URL`: An NSURL object that specifies a file containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from a file and then append sample buffers to any of its tracks, you must first set one of these properties
        /// to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(movieWithURL:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieWithURL_options(
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Creates an AVMovie object from a movie header stored in a QuickTime movie file or ISO base media file.
        ///
        /// Parameter `URL`: An NSURL object that specifies a file containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from a file and then append sample buffers to any of its tracks, you must first set one of these properties
        /// to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithURL:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_options(
            this: Allocated<Self>,
            url: &NSURL,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Creates an AVMovie object from a movie header stored in an NSData object.
        ///
        /// Parameter `data`: An NSData object containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// You can use this method to operate on movie headers that are not stored in files; this might include movie headers on the pasteboard (which do not contain media data). In general you should avoid loading an entire movie file with its media data into an instance of NSData! By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil.
        /// If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(movieWithData:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn movieWithData_options(
            data: &NSData,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Creates an AVMovie object from a movie header stored in an NSData object.
        ///
        /// Parameter `data`: An NSData object containing a movie header.
        ///
        /// Parameter `options`: An NSDictionary object that contains keys for specifying options for the initialization of the AVMovie object.
        ///
        /// Returns: An AVMovie object
        ///
        /// You can use this method to operate on movie headers that are not stored in files. In general you should avoid loading an entire movie file with its media data into an instance of NSData!
        ///
        /// By default, the defaultMediaDataStorage property will be nil and each associated AVMovieTrack's mediaDataStorage property will be nil. If you want to create an AVMutableMovie from an NSData object and then append sample buffers to any of its tracks, you must first set one of these properties to indicate where the sample data should be written.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(initWithData:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData_options(
            this: Allocated<Self>,
            data: &NSData,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `AVAsset`.
#[cfg(feature = "AVAsset")]
impl AVFragmentedMovie {
    extern_methods!(
        /// Returns an instance of AVAsset for inspection of a media resource.
        ///
        /// Returns a newly allocated instance of a subclass of AVAsset initialized with the specified URL.
        ///
        /// - Parameter URL: An instance of NSURL that references a media resource.
        ///
        /// - Returns: An instance of AVAsset.
        #[unsafe(method(assetWithURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn assetWithURL(url: &NSURL) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "AVAsset")]
impl AVFragmentedMovie {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVFragmentedMovieTrackInspection.
#[cfg(feature = "AVAsset")]
impl AVFragmentedMovie {
    extern_methods!(
        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMovieTrack",
            feature = "objc2-core-media"
        ))]
        /// Provides an instance of AVFragmentedMovieTrack that represents the track of the specified trackID.
        ///
        /// Parameter `trackID`: The trackID of the requested AVFragmentedMovieTrack.
        ///
        /// Returns: An instance of AVFragmentedMovieTrack; may be nil if no track of the specified trackID is available.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        #[deprecated = "Use loadTrackWithTrackID:completionHandler: instead"]
        #[unsafe(method(trackWithTrackID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackWithTrackID(
            &self,
            track_id: CMPersistentTrackID,
        ) -> Option<Retained<AVFragmentedMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMovieTrack",
            feature = "block2",
            feature = "objc2-core-media"
        ))]
        /// Loads an instance of AVFragmentedMovieTrack that represents the track of the specified trackID.
        ///
        /// Parameter `trackID`: The trackID of the requested AVFragmentedMovieTrack.
        ///
        /// Parameter `completionHandler`: A block that is called when the loading is finished, with either the loaded track (which may be nil if no track of the specified trackID is available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTrackWithTrackID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTrackWithTrackID_completionHandler(
            &self,
            track_id: CMPersistentTrackID,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut AVFragmentedMovieTrack, *mut NSError),
            >,
        );

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack"
        ))]
        /// Provides an array of AVFragmentedMovieTracks of the asset that present media of the specified media type.
        ///
        /// Parameter `mediaType`: The media type according to which the receiver filters its AVFragmentedMovieTracks. (Media types are defined in AVMediaFormat.h)
        ///
        /// Returns: An NSArray of AVFragmentedMovieTracks; may be empty if no tracks of the specified media type are available.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        #[deprecated = "Use loadTracksWithMediaType:completionHandler: instead"]
        #[unsafe(method(tracksWithMediaType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaType(
            &self,
            media_type: &AVMediaType,
        ) -> Retained<NSArray<AVFragmentedMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack",
            feature = "block2"
        ))]
        /// Loads an array of AVFragmentedMovieTracks of the asset that present media of the specified media type.
        ///
        /// Parameter `mediaType`: The media type according to which AVAsset filters its AVFragmentedMovieTracks. (Media types are defined in AVMediaFormat.h.)
        ///
        /// Parameter `completionHandler`: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks of the specified media type are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaType_completionHandler(
            &self,
            media_type: &AVMediaType,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVFragmentedMovieTrack>, *mut NSError),
            >,
        );

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack"
        ))]
        /// Provides an array of AVFragmentedMovieTracks of the asset that present media with the specified characteristic.
        ///
        /// Parameter `mediaCharacteristic`: The media characteristic according to which the receiver filters its AVFragmentedMovieTracks. (Media characteristics are defined in AVMediaFormat.h)
        ///
        /// Returns: An NSArray of AVFragmentedMovieTracks; may be empty if no tracks with the specified characteristic are available.
        ///
        /// Becomes callable without blocking when the key
        /// "
        /// tracks" has been loaded
        #[deprecated = "loadTracksWithMediaCharacteristic:completionHandler:"]
        #[unsafe(method(tracksWithMediaCharacteristic:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tracksWithMediaCharacteristic(
            &self,
            media_characteristic: &AVMediaCharacteristic,
        ) -> Retained<NSArray<AVFragmentedMovieTrack>>;

        #[cfg(all(
            feature = "AVAssetTrack",
            feature = "AVMediaFormat",
            feature = "AVMovieTrack",
            feature = "block2"
        ))]
        /// Loads an array of AVFragmentedMovieTracks of the asset that present media with the specified characteristic.
        ///
        /// Parameter `mediaCharacteristic`: The media characteristic according to which AVAsset filters its AVFragmentedMovieTracks. (Media characteristics are defined in AVMediaFormat.h.)
        ///
        /// Parameter `completionHandler`: A block that is called when the loading is finished, with either the loaded tracks (which may be empty if no tracks with the specified characteristic are available) or an error.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(loadTracksWithMediaCharacteristic:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadTracksWithMediaCharacteristic_completionHandler(
            &self,
            media_characteristic: &AVMediaCharacteristic,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVFragmentedMovieTrack>, *mut NSError),
            >,
        );
    );
}

extern_class!(
    /// A class that periodically checks whether additional movie fragments have been appended to fragmented movie files.
    ///
    /// AVFragmentedMovieMinder is identical to AVFragmentedAssetMinder except that it's capable of minding only assets of class AVFragmentedMovie.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avfragmentedmovieminder?language=objc)
    #[unsafe(super(AVFragmentedAssetMinder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "AVAsset")]
    pub struct AVFragmentedMovieMinder;
);

#[cfg(feature = "AVAsset")]
extern_conformance!(
    unsafe impl NSObjectProtocol for AVFragmentedMovieMinder {}
);

#[cfg(feature = "AVAsset")]
impl AVFragmentedMovieMinder {
    extern_methods!(
        /// Creates an AVFragmentedMovieMinder, adds the specified movie to it, and sets the mindingInterval to the specified value.
        ///
        /// Parameter `movie`: An instance of AVFragmentedMovie to add to the AVFragmentedMovieMinder
        ///
        /// Parameter `mindingInterval`: The initial minding interval of the AVFragmentedMovieMinder.
        ///
        /// Returns: A new instance of AVFragmentedMovieMinder.
        #[unsafe(method(fragmentedMovieMinderWithMovie:mindingInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fragmentedMovieMinderWithMovie_mindingInterval(
            movie: &AVFragmentedMovie,
            minding_interval: NSTimeInterval,
        ) -> Retained<Self>;

        /// Creates an AVFragmentedMovieMinder, adds the specified movie to it, and sets the mindingInterval to the specified value.
        ///
        /// Parameter `movie`: An instance of AVFragmentedMovie to add to the AVFragmentedMovieMinder
        ///
        /// Parameter `mindingInterval`: The initial minding interval of the AVFragmentedMovieMinder.
        ///
        /// Returns: A new instance of AVFragmentedMovieMinder.
        #[unsafe(method(initWithMovie:mindingInterval:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMovie_mindingInterval(
            this: Allocated<Self>,
            movie: &AVFragmentedMovie,
            minding_interval: NSTimeInterval,
        ) -> Retained<Self>;

        /// An NSTimeInterval indicating how often a check for additional movie fragments should be performed. The default interval is 10.0.
        #[unsafe(method(mindingInterval))]
        #[unsafe(method_family = none)]
        pub unsafe fn mindingInterval(&self) -> NSTimeInterval;

        /// Setter for [`mindingInterval`][Self::mindingInterval].
        #[unsafe(method(setMindingInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMindingInterval(&self, minding_interval: NSTimeInterval);

        /// An NSArray of the AVFragmentedMovie objects being minded.
        #[unsafe(method(movies))]
        #[unsafe(method_family = none)]
        pub unsafe fn movies(&self) -> Retained<NSArray<AVFragmentedMovie>>;

        /// Adds a fragmented movie to the array of movies being minded.
        ///
        /// Parameter `movie`: The fragmented movie to add to the minder.
        #[unsafe(method(addFragmentedMovie:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addFragmentedMovie(&self, movie: &AVFragmentedMovie);

        /// Removes a fragmented movie from the array of movies being minded.
        ///
        /// Parameter `movie`: The fragmented movie to remove from the minder.
        #[unsafe(method(removeFragmentedMovie:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFragmentedMovie(&self, movie: &AVFragmentedMovie);
    );
}

/// Methods declared on superclass `AVFragmentedAssetMinder`.
#[cfg(feature = "AVAsset")]
impl AVFragmentedMovieMinder {
    extern_methods!(
        /// Creates an AVFragmentedAssetMinder, adds the specified asset to it, and sets the mindingInterval to the specified value.
        ///
        /// - Parameter asset: An instance of AVFragmentedAsset to add to the AVFragmentedAssetMinder
        /// - Parameter mindingInterval: The initial minding interval of the AVFragmentedAssetMinder.
        ///
        /// - Returns: A new instance of AVFragmentedAssetMinder.
        ///
        /// # Safety
        ///
        /// `asset` must implement AVFragmentMinding.
        #[unsafe(method(fragmentedAssetMinderWithAsset:mindingInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fragmentedAssetMinderWithAsset_mindingInterval(
            asset: &AVAsset,
            minding_interval: NSTimeInterval,
        ) -> Retained<Self>;

        /// Creates an AVFragmentedAssetMinder, adds the specified asset to it, and sets the mindingInterval to the specified value.
        ///
        /// - Parameter asset: An instance of AVFragmentedAsset to add to the AVFragmentedAssetMinder
        /// - Parameter mindingInterval: The initial minding interval of the AVFragmentedAssetMinder.
        ///
        /// - Returns: A new instance of AVFragmentedAssetMinder.
        ///
        /// # Safety
        ///
        /// `asset` must implement AVFragmentMinding.
        #[unsafe(method(initWithAsset:mindingInterval:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAsset_mindingInterval(
            this: Allocated<Self>,
            asset: &AVAsset,
            minding_interval: NSTimeInterval,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "AVAsset")]
impl AVFragmentedMovieMinder {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// SynchronousAssetInterface.
///
/// Redeclarations of async-only AVAsset interfaces to allow synchronous usage in the synchronous subclass.
///
/// See AVAsset's interface for more information about these interfaces.
#[cfg(feature = "AVAsset")]
impl AVMutableMovie {
    extern_methods!(
        #[cfg(all(feature = "AVMetadataFormat", feature = "AVMetadataItem"))]
        #[unsafe(method(metadataForFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataForFormat(
            &self,
            format: &AVMetadataFormat,
        ) -> Retained<NSArray<AVMetadataItem>>;

        #[cfg(all(feature = "AVMetadataFormat", feature = "AVTimedMetadataGroup"))]
        #[unsafe(method(chapterMetadataGroupsWithTitleLocale:containingItemsWithCommonKeys:))]
        #[unsafe(method_family = none)]
        pub unsafe fn chapterMetadataGroupsWithTitleLocale_containingItemsWithCommonKeys(
            &self,
            locale: &NSLocale,
            common_keys: Option<&NSArray<AVMetadataKey>>,
        ) -> Retained<NSArray<AVTimedMetadataGroup>>;

        #[cfg(feature = "AVTimedMetadataGroup")]
        #[unsafe(method(chapterMetadataGroupsBestMatchingPreferredLanguages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn chapterMetadataGroupsBestMatchingPreferredLanguages(
            &self,
            preferred_languages: &NSArray<NSString>,
        ) -> Retained<NSArray<AVTimedMetadataGroup>>;

        #[cfg(all(feature = "AVMediaFormat", feature = "AVMediaSelectionGroup"))]
        #[unsafe(method(mediaSelectionGroupForMediaCharacteristic:))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaSelectionGroupForMediaCharacteristic(
            &self,
            media_characteristic: &AVMediaCharacteristic,
        ) -> Option<Retained<AVMediaSelectionGroup>>;

        #[cfg(feature = "objc2-core-media")]
        #[unsafe(method(unusedTrackID))]
        #[unsafe(method_family = none)]
        pub unsafe fn unusedTrackID(&self) -> CMPersistentTrackID;
    );
}
