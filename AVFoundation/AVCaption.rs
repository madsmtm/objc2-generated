//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;

use crate::*;

/// Geometry unit.
///
/// Some geometric objects are positioned or sized with different kinds of dimensions differeing in unit. In some cases, an object might allow multiple kinds of dimensions varrying by units. AVCaptionUnitsType is an enumeration of kinds of units that are used across caption formats.
///
/// The units has not been specified. The dimension can be seen as invalid.
///
/// The integer value is a number of cells.
///
/// The floating-point value number value is [0 .. 100] correspondng to 0% to 100%, typically relative to the enclosing rectangle.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionunitstype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionUnitsType(pub NSInteger);
impl AVCaptionUnitsType {
    #[doc(alias = "AVCaptionUnitsTypeUnspecified")]
    pub const Unspecified: Self = Self(0);
    #[doc(alias = "AVCaptionUnitsTypeCells")]
    pub const Cells: Self = Self(1);
    #[doc(alias = "AVCaptionUnitsTypePercent")]
    pub const Percent: Self = Self(2);
}

unsafe impl Encode for AVCaptionUnitsType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionUnitsType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The length with a unit or coordinate on a 2D geometric axis
/// Field: value The value of the coordinate or length.
/// Field: units The units of the coordinate (e.g., cells, points)
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptiondimension?language=objc)
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AVCaptionDimension {
    pub value: CGFloat,
    pub units: AVCaptionUnitsType,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AVCaptionDimension {
    const ENCODING: Encoding = Encoding::Struct(
        "AVCaptionDimension",
        &[<CGFloat>::ENCODING, <AVCaptionUnitsType>::ENCODING],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AVCaptionDimension {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A two dimensional point made of x and y AVCaptionDimension coordinates
/// Field: x An AVCaptionDimension holding the x coordinate of the point
/// Field: y An AVCaptionDimension holding the y coordinate of the point
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionpoint?language=objc)
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AVCaptionPoint {
    pub x: AVCaptionDimension,
    pub y: AVCaptionDimension,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AVCaptionPoint {
    const ENCODING: Encoding = Encoding::Struct(
        "AVCaptionPoint",
        &[
            <AVCaptionDimension>::ENCODING,
            <AVCaptionDimension>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AVCaptionPoint {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A two dimensional size made of width and height AVCaptionDimensions
/// Field: width An AVCaptionDimension holding the width
/// Field: height An AVCaptionDimension holding the height
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionsize?language=objc)
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AVCaptionSize {
    pub width: AVCaptionDimension,
    pub height: AVCaptionDimension,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for AVCaptionSize {
    const ENCODING: Encoding = Encoding::Struct(
        "AVCaptionSize",
        &[
            <AVCaptionDimension>::ENCODING,
            <AVCaptionDimension>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for AVCaptionSize {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "objc2-core-foundation")]
impl AVCaptionDimension {
    /// Makes an AVCaptionDimension from a value and units.
    #[doc(alias = "AVCaptionDimensionMake")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn new(value: CGFloat, units: AVCaptionUnitsType) -> AVCaptionDimension {
        extern "C-unwind" {
            fn AVCaptionDimensionMake(
                value: CGFloat,
                units: AVCaptionUnitsType,
            ) -> AVCaptionDimension;
        }
        unsafe { AVCaptionDimensionMake(value, units) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AVCaptionPoint {
    /// Makes an AVCaptionPoint from x and y coordinate AVCaptionDimensions.
    #[doc(alias = "AVCaptionPointMake")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn new(x: AVCaptionDimension, y: AVCaptionDimension) -> AVCaptionPoint {
        extern "C-unwind" {
            fn AVCaptionPointMake(x: AVCaptionDimension, y: AVCaptionDimension) -> AVCaptionPoint;
        }
        unsafe { AVCaptionPointMake(x, y) }
    }
}

#[cfg(feature = "objc2-core-foundation")]
impl AVCaptionSize {
    /// Makes an AVCaptionSize from width and height AVCaptionDimensions.
    #[doc(alias = "AVCaptionSizeMake")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn new(width: AVCaptionDimension, height: AVCaptionDimension) -> AVCaptionSize {
        extern "C-unwind" {
            fn AVCaptionSizeMake(
                width: AVCaptionDimension,
                height: AVCaptionDimension,
            ) -> AVCaptionSize;
        }
        unsafe { AVCaptionSizeMake(width, height) }
    }
}

/// Choices for region display alignment
///
///
/// Whenever a caption line is inserted into a region, it's placed relative to the existing lines and the direction to which the line is placed is called the block progression direction of the region. For example, English caption's block progression direction is top-to-bottom, while Japanese vertical caption uses right-to-left.
///
/// The value describes how the caption lines should positioned in a region in terms of the block progression direction.
///
///
/// Align lines in earlier position in the block progression direction, or align to the top for English captions, for example.
///
///
/// Align lines in center position in the block progression direction. iTT doesn't support this.
///
///
/// Align lines in later position in the block progression direction, or align to the left for Japanese vertical captions, for example.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionregiondisplayalignment?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionRegionDisplayAlignment(pub NSInteger);
impl AVCaptionRegionDisplayAlignment {
    #[doc(alias = "AVCaptionRegionDisplayAlignmentBefore")]
    pub const Before: Self = Self(0);
    #[doc(alias = "AVCaptionRegionDisplayAlignmentCenter")]
    pub const Center: Self = Self(1);
    #[doc(alias = "AVCaptionRegionDisplayAlignmentAfter")]
    pub const After: Self = Self(2);
}

unsafe impl Encode for AVCaptionRegionDisplayAlignment {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionRegionDisplayAlignment {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Choices for region writing mode
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionregionwritingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionRegionWritingMode(pub NSInteger);
impl AVCaptionRegionWritingMode {
    #[doc(alias = "AVCaptionRegionWritingModeLeftToRightAndTopToBottom")]
    pub const LeftToRightAndTopToBottom: Self = Self(0);
    #[doc(alias = "AVCaptionRegionWritingModeTopToBottomAndRightToLeft")]
    pub const TopToBottomAndRightToLeft: Self = Self(2);
}

unsafe impl Encode for AVCaptionRegionWritingMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionRegionWritingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Scrolling effect for a region
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionregionscroll?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionRegionScroll(pub NSInteger);
impl AVCaptionRegionScroll {
    #[doc(alias = "AVCaptionRegionScrollNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "AVCaptionRegionScrollRollUp")]
    pub const RollUp: Self = Self(1);
}

unsafe impl Encode for AVCaptionRegionScroll {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionRegionScroll {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An instance of AVCaptionRegion represents a region where a caption is placed.
    ///
    /// Currently, there is just four predefined region instances. The interface doesn't support configuration of region settings.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionregion?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVCaptionRegion;
);

extern_conformance!(
    unsafe impl NSCoding for AVCaptionRegion {}
);

extern_conformance!(
    unsafe impl NSCopying for AVCaptionRegion {}
);

unsafe impl CopyingHelper for AVCaptionRegion {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSMutableCopying for AVCaptionRegion {}
);

unsafe impl MutableCopyingHelper for AVCaptionRegion {
    type Result = AVMutableCaptionRegion;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVCaptionRegion {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for AVCaptionRegion {}
);

impl AVCaptionRegion {
    extern_methods!(
        /// The top region for iTT format
        ///
        /// This region can be used in iTT format and it occupies the top 15% of the display area. The region uses LRTB, a line progresses left to right and the block extends from top to bottom. Each line is stacked with top justified.
        #[unsafe(method(appleITTTopRegion))]
        #[unsafe(method_family = none)]
        pub unsafe fn appleITTTopRegion() -> Retained<AVCaptionRegion>;

        /// The bottom region for iTT format
        ///
        /// This region can be used in iTT format and it occupies the bottom 15% of the display area. The region uses LRTB, a line progresses left to right and the block extends from top to bottom. Each line is stacked with bottom justified.
        #[unsafe(method(appleITTBottomRegion))]
        #[unsafe(method_family = none)]
        pub unsafe fn appleITTBottomRegion() -> Retained<AVCaptionRegion>;

        /// The  left region for iTT format
        ///
        /// This region can be used in iTT format and it occupies the left 15% of the display area. The region uses TBRL, a line progresses top to bottom and the block extends from right to left. Each line is stacked with right justified.
        #[unsafe(method(appleITTLeftRegion))]
        #[unsafe(method_family = none)]
        pub unsafe fn appleITTLeftRegion() -> Retained<AVCaptionRegion>;

        /// The right region for iTT format
        ///
        /// This region can be used in iTT format and it occupies the right 15% of the display area. The region uses TBRL, a line progresses top to bottom and the block extends from right to left. Each line is stacked with right justified.
        #[unsafe(method(appleITTRightRegion))]
        #[unsafe(method_family = none)]
        pub unsafe fn appleITTRightRegion() -> Retained<AVCaptionRegion>;

        /// The bottom region for SubRip Text (SRT) format
        ///
        /// This region can be used in SRT format and it occupies the entire video display area. The region uses LRTB, a line progresses left to right and the block extends from top to bottom. Each line is stacked with bottom justified.
        #[unsafe(method(subRipTextBottomRegion))]
        #[unsafe(method_family = none)]
        pub unsafe fn subRipTextBottomRegion() -> Retained<AVCaptionRegion>;

        /// Identifier for the region
        ///
        /// When regionIdentifier is nil, two regions with the same position and endPosition are considered to be same, that is
        /// captions referring these regions belong to the same region when serialized to a format like TTML.  In addition, the
        /// AVCaptionRegion cannot be mutably copied.
        ///
        /// When regionIdentifier is not nil, two regions are same if and only if the region identifier is equal. It is a
        /// client's responsibility to ensure these AVCaptionRegion objects have the same properties.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "objc2-core-foundation")]
        /// The position of the top-left of the region, potentially with unspecified fields.
        ///
        /// It returns an AVCaptionPoint potentially with unspecified x and/or y fields. Unspecified dimensions indicate the region doesn't have positioning information for that dimension.
        #[unsafe(method(origin))]
        #[unsafe(method_family = none)]
        pub unsafe fn origin(&self) -> AVCaptionPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// The width and height of the region, potentally with unspecified fields.
        ///
        /// It returns an AVCaptionSize potentially with unspecified width and/or height.
        /// CEA608 closed captions support limits the size.height property’s value to 1 cell except when the AVCaptionRegionScroll is AVCaptionRegionScrollRollUp.
        /// If the AVCaptionRegionScroll is AVCaptionRegionScrollRollUp, the size.height property’s value must be 2, 3 or 4 cells.
        /// It returns an AVCaptionSize with unspecifed width and height when the region doesn't have width or height information.
        #[unsafe(method(size))]
        #[unsafe(method_family = none)]
        pub unsafe fn size(&self) -> AVCaptionSize;

        /// Scroll mode for the region
        ///
        /// See AVCaptionRegionScrollXXX enum for possible values.
        #[unsafe(method(scroll))]
        #[unsafe(method_family = none)]
        pub unsafe fn scroll(&self) -> AVCaptionRegionScroll;

        /// Alignment of lines for the region
        #[unsafe(method(displayAlignment))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayAlignment(&self) -> AVCaptionRegionDisplayAlignment;

        /// The block and inline progression direction of the region.
        #[unsafe(method(writingMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn writingMode(&self) -> AVCaptionRegionWritingMode;

        /// NSCoding protocol method override
        ///
        /// This method throws an exception if the caption region's size has different units for width and height, or if the units are unrecognizeable.
        #[unsafe(method(encodeWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeWithCoder(&self, encoder: &NSCoder);

        /// NSObject protocol method override
        ///
        /// This method throws an exception if the caption region's size has different units for width and height, or if the units are unrecognizeable.
        ///
        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[unsafe(method(isEqual:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEqual(&self, object: &AnyObject) -> bool;

        /// NSMutableCopying protocol method override
        ///
        /// This method throws an exception if the caption region contains an identifier.
        ///
        /// # Safety
        ///
        /// `zone` must be a valid pointer or null.
        #[unsafe(method(mutableCopyWithZone:))]
        #[unsafe(method_family = mutableCopy)]
        pub unsafe fn mutableCopyWithZone(&self, zone: *mut NSZone) -> Retained<AnyObject>;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVCaptionRegion {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Mutable subclass of AVCaptionRegion.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmutablecaptionregion?language=objc)
    #[unsafe(super(AVCaptionRegion, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVMutableCaptionRegion;
);

extern_conformance!(
    unsafe impl NSCoding for AVMutableCaptionRegion {}
);

extern_conformance!(
    unsafe impl NSCopying for AVMutableCaptionRegion {}
);

unsafe impl CopyingHelper for AVMutableCaptionRegion {
    type Result = AVCaptionRegion;
}

extern_conformance!(
    unsafe impl NSMutableCopying for AVMutableCaptionRegion {}
);

unsafe impl MutableCopyingHelper for AVMutableCaptionRegion {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVMutableCaptionRegion {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for AVMutableCaptionRegion {}
);

impl AVMutableCaptionRegion {
    extern_methods!(
        /// Create a region object without any properties.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Create a region object with the identifier.
        #[unsafe(method(initWithIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier(
            this: Allocated<Self>,
            identifier: &NSString,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        /// The position of the top-left of the region.
        #[unsafe(method(origin))]
        #[unsafe(method_family = none)]
        pub unsafe fn origin(&self) -> AVCaptionPoint;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`origin`][Self::origin].
        #[unsafe(method(setOrigin:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOrigin(&self, origin: AVCaptionPoint);

        #[cfg(feature = "objc2-core-foundation")]
        /// The width and height of the region, potentally with unspecified fields.
        #[unsafe(method(size))]
        #[unsafe(method_family = none)]
        pub unsafe fn size(&self) -> AVCaptionSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`size`][Self::size].
        #[unsafe(method(setSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSize(&self, size: AVCaptionSize);

        /// Region scroll mode.
        #[unsafe(method(scroll))]
        #[unsafe(method_family = none)]
        pub unsafe fn scroll(&self) -> AVCaptionRegionScroll;

        /// Setter for [`scroll`][Self::scroll].
        #[unsafe(method(setScroll:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setScroll(&self, scroll: AVCaptionRegionScroll);

        /// Alignment of lines in the region.
        #[unsafe(method(displayAlignment))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayAlignment(&self) -> AVCaptionRegionDisplayAlignment;

        /// Setter for [`displayAlignment`][Self::displayAlignment].
        #[unsafe(method(setDisplayAlignment:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisplayAlignment(
            &self,
            display_alignment: AVCaptionRegionDisplayAlignment,
        );

        /// The block and inline progression direction of the region.
        #[unsafe(method(writingMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn writingMode(&self) -> AVCaptionRegionWritingMode;

        /// Setter for [`writingMode`][Self::writingMode].
        #[unsafe(method(setWritingMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWritingMode(&self, writing_mode: AVCaptionRegionWritingMode);
    );
}

/// Methods declared on superclass `NSObject`.
impl AVMutableCaptionRegion {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Animation effect for a caption
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionanimation?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionAnimation(pub NSInteger);
impl AVCaptionAnimation {
    #[doc(alias = "AVCaptionAnimationNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "AVCaptionAnimationCharacterReveal")]
    pub const CharacterReveal: Self = Self(1);
}

unsafe impl Encode for AVCaptionAnimation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionAnimation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An instance of AVCaption represents a unit of text that is active at a particular time range.
    ///
    /// A caption contains one meaningful sentence, paragraph, or otherwise known as a caption cue. Within the active time range, it may perform animation (e.g. Karaoke), rolling-up, changes the visibility, or any other dynamic styling.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaption?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVCaption;
);

extern_conformance!(
    unsafe impl NSCoding for AVCaption {}
);

extern_conformance!(
    unsafe impl NSCopying for AVCaption {}
);

unsafe impl CopyingHelper for AVCaption {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSMutableCopying for AVCaption {}
);

unsafe impl MutableCopyingHelper for AVCaption {
    type Result = AVMutableCaption;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVCaption {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for AVCaption {}
);

impl AVCaption {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "objc2-core-media")]
        /// Initializes an instance of AVCaption with the given text and time range.
        ///
        /// Parameter `text`: The text for the new caption object. See text property for the available character sets and other restrictions.
        ///
        /// Parameter `timeRange`: The time range for the new caption object.
        ///
        /// Returns: An instance of AVCaption that carries the given text and time range.
        #[unsafe(method(initWithText:timeRange:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithText_timeRange(
            this: Allocated<Self>,
            text: &NSString,
            time_range: CMTimeRange,
        ) -> Retained<Self>;

        /// The text content of the caption.
        ///
        /// The text may contain any of the line breaking character sequences (LF, CR, or CF+LF) and separating the lines in the presentation.
        ///
        /// The Apple iTT format supports all Unicode code points allowed in a XML document. Any XML special characters such as '
        /// &
        /// ' are converted to a corresponding character reference syntax when written to the destination file.
        ///
        /// CEA608 closed captions support the following Unicode characters.
        /// Range: U+0020 - U+005F
        /// Range: U+0061 - U+007E
        /// Range: U+00A1 - U+00A5
        /// Characters: U+00A9, U+00AB, U+00AE, U+00B0, U+00BB, U+00BD, U+00BF
        /// Range: U+00C0-U+00C5
        /// Range: U+00C7-U+00CF
        /// Range: U+00D1-U+00D6
        /// Range: U+00D8-U+00DC
        /// Range: U+00DF-U+00E5
        /// Range: U+00E7-U+00EF
        /// Range: U+00F1-U+00FC
        /// Range: U+2018-U+2019
        /// Range: U+2018-U+201D
        /// Character: U+2022
        /// Range: U+2120-U+2122
        /// Characters: U+2501, U+2503, U+250F, U+2513, U+2517, U+251B, U+2588, U+266A
        ///
        /// CEA608 closed captions don't support the line breaking character sequences (LF, CR, or CF+LF).
        #[unsafe(method(text))]
        #[unsafe(method_family = none)]
        pub unsafe fn text(&self) -> Retained<NSString>;

        #[cfg(feature = "objc2-core-media")]
        /// The time range during which the caption should be presented.
        ///
        /// Apple iTT format doesn't allow two captions to have overlapped time range except when the two captions are associated with different regions.
        ///
        /// CEA608 closed caption time ranges can't start with zero, because the decoder needs some transmission time.
        /// CEA608 closed caption time ranges should be aligned with the video frame rate because this is how often the commands are delivered.
        #[unsafe(method(timeRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn timeRange(&self) -> CMTimeRange;
    );
}

extern_class!(
    /// Mutable subclass of AVCaption.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avmutablecaption?language=objc)
    #[unsafe(super(AVCaption, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVMutableCaption;
);

extern_conformance!(
    unsafe impl NSCoding for AVMutableCaption {}
);

extern_conformance!(
    unsafe impl NSCopying for AVMutableCaption {}
);

unsafe impl CopyingHelper for AVMutableCaption {
    type Result = AVCaption;
}

extern_conformance!(
    unsafe impl NSMutableCopying for AVMutableCaption {}
);

unsafe impl MutableCopyingHelper for AVMutableCaption {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVMutableCaption {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for AVMutableCaption {}
);

impl AVMutableCaption {
    extern_methods!(
        /// The text content of the caption.
        ///
        /// All styling information is cleared on setting this property.
        #[unsafe(method(text))]
        #[unsafe(method_family = none)]
        pub unsafe fn text(&self) -> Retained<NSString>;

        /// Setter for [`text`][Self::text].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setText:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setText(&self, text: &NSString);

        #[cfg(feature = "objc2-core-media")]
        /// The time range during which the caption should be presented.
        #[unsafe(method(timeRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn timeRange(&self) -> CMTimeRange;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`timeRange`][Self::timeRange].
        #[unsafe(method(setTimeRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimeRange(&self, time_range: CMTimeRange);
    );
}

/// Methods declared on superclass `AVCaption`.
impl AVMutableCaption {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(feature = "objc2-core-media")]
        /// Initializes an instance of AVCaption with the given text and time range.
        ///
        /// Parameter `text`: The text for the new caption object. See text property for the available character sets and other restrictions.
        ///
        /// Parameter `timeRange`: The time range for the new caption object.
        ///
        /// Returns: An instance of AVCaption that carries the given text and time range.
        #[unsafe(method(initWithText:timeRange:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithText_timeRange(
            this: Allocated<Self>,
            text: &NSString,
            time_range: CMTimeRange,
        ) -> Retained<Self>;
    );
}

/// Choices for font weight.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionfontweight?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionFontWeight(pub NSInteger);
impl AVCaptionFontWeight {
    #[doc(alias = "AVCaptionFontWeightUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "AVCaptionFontWeightNormal")]
    pub const Normal: Self = Self(1);
    #[doc(alias = "AVCaptionFontWeightBold")]
    pub const Bold: Self = Self(2);
}

unsafe impl Encode for AVCaptionFontWeight {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionFontWeight {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Choices for character style.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionfontstyle?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionFontStyle(pub NSInteger);
impl AVCaptionFontStyle {
    #[doc(alias = "AVCaptionFontStyleUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "AVCaptionFontStyleNormal")]
    pub const Normal: Self = Self(1);
    #[doc(alias = "AVCaptionFontStyleItalic")]
    pub const Italic: Self = Self(2);
}

unsafe impl Encode for AVCaptionFontStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionFontStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Choices for character decoration .
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptiondecoration?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionDecoration(pub NSUInteger);
bitflags::bitflags! {
    impl AVCaptionDecoration: NSUInteger {
        #[doc(alias = "AVCaptionDecorationNone")]
        const None = 0;
        #[doc(alias = "AVCaptionDecorationUnderline")]
        const Underline = 1<<0;
        #[doc(alias = "AVCaptionDecorationLineThrough")]
        const LineThrough = 1<<1;
        #[doc(alias = "AVCaptionDecorationOverline")]
        const Overline = 1<<2;
    }
}

unsafe impl Encode for AVCaptionDecoration {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionDecoration {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Choices for text combine.
///
///
/// Text combine is a special rendering policy to combine multiple characters into one unit and present it in upright position in a vertical text flow in order to accomplish so-called "Tate-Chu-Yoko" layout, or horizontal-in-vertical layout.
///
/// For example, it can be used to render "2017" horizontally in a vertical text.
///
///
/// Don't combine text upright. It is the same as not specifying the style.
///
///
/// Combine all the characters.
///
///
/// Make one digit upright.
///
///
/// Combine two consecutive digits
///
///
/// Combine three consecutive digits
///
///
/// Combine four consecutive digits
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptiontextcombine?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionTextCombine(pub NSInteger);
impl AVCaptionTextCombine {
    #[doc(alias = "AVCaptionTextCombineAll")]
    pub const All: Self = Self(-1);
    #[doc(alias = "AVCaptionTextCombineNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "AVCaptionTextCombineOneDigit")]
    pub const OneDigit: Self = Self(1);
    #[doc(alias = "AVCaptionTextCombineTwoDigits")]
    pub const TwoDigits: Self = Self(2);
    #[doc(alias = "AVCaptionTextCombineThreeDigits")]
    pub const ThreeDigits: Self = Self(3);
    #[doc(alias = "AVCaptionTextCombineFourDigits")]
    pub const FourDigits: Self = Self(4);
}

unsafe impl Encode for AVCaptionTextCombine {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionTextCombine {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Alignment of a caption within the containing region.
///
/// Aligned to the start of inline progression direction; e.g. left in left-to-right writing mode and right in right-to-left writing mode.
///
/// Aligned to the end of inline progression direction; e.g. right in left-to-right writing mode and right in right-to-left writing mode.
///
/// Aligned at center in inline progression direction.
///
/// Aligned to left in horizontal writing mode or top in vertical writing mode.
///
/// Aligned to right in horizontal writing mode or bottom in vertical writing mode.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptiontextalignment?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionTextAlignment(pub NSInteger);
impl AVCaptionTextAlignment {
    #[doc(alias = "AVCaptionTextAlignmentStart")]
    pub const Start: Self = Self(0);
    #[doc(alias = "AVCaptionTextAlignmentEnd")]
    pub const End: Self = Self(1);
    #[doc(alias = "AVCaptionTextAlignmentCenter")]
    pub const Center: Self = Self(2);
    #[doc(alias = "AVCaptionTextAlignmentLeft")]
    pub const Left: Self = Self(3);
    #[doc(alias = "AVCaptionTextAlignmentRight")]
    pub const Right: Self = Self(4);
}

unsafe impl Encode for AVCaptionTextAlignment {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionTextAlignment {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Styling.
impl AVCaption {
    extern_methods!(
        #[cfg(feature = "objc2-core-graphics")]
        /// The color of the character(s).
        ///
        /// A value of NULL means that the color is not specified. The caller must release the returned object via CGColorRelease. The range parameter receives UTF-16 code unit index range the style is effective. The range will indicate where the current style returned (including NULL) will be active and allows discovery of the next change in the style.
        ///
        /// CEA608 closed captions support the following 8 colors with 1.0 alpha value.
        /// White    (RGB:1.0, 1.0, 1.0)
        /// Red        (RGB:1.0, 0.0, 0.0)
        /// Blue    (RGB:0.0, 0.0, 1.0)
        /// Green    (RGB:0.0, 1.0, 0.0)
        /// Yellow    (RGB:1.0, 1.0, 0.0)
        /// Cyan    (RGB:0.0, 1.0, 1.0)
        /// Magenta    (RGB:1.0, 0.0, 1.0)
        /// Black    (RGB:0.0, 0.0, 0.0)
        ///
        /// # Safety
        ///
        /// `out_range` must be a valid pointer or null.
        #[unsafe(method(textColorAtIndex:range:))]
        // required for soundness, method has `returns_retained` attribute.
        #[unsafe(method_family = copy)]
        pub unsafe fn textColorAtIndex_range(
            &self,
            index: NSInteger,
            out_range: *mut NSRange,
        ) -> Option<Retained<CGColor>>;

        #[cfg(feature = "objc2-core-graphics")]
        /// The background color of the character(s).
        ///
        /// A value of NULL means that the color is not specified. The caller must release the returned object via CGColorRelease. The range parameter receives UTF-16 code unit index range the style is effective. After returning from the call, the range will indicate where the current style returned (including NULL) will be active and allows discovery of the next change in the style.
        ///
        /// iTT format ignores this property.
        ///
        /// CEA608 closed captions support the following 8 colors with 1.0, 0.5 and 0.0 alpha values.
        /// White    (RGB:1.0, 1.0, 1.0)
        /// Red        (RGB:1.0, 0.0, 0.0)
        /// Blue    (RGB:0.0, 0.0, 1.0)
        /// Green    (RGB:0.0, 1.0, 0.0)
        /// Yellow    (RGB:1.0, 1.0, 0.0)
        /// Cyan    (RGB:0.0, 1.0, 1.0)
        /// Magenta    (RGB:1.0, 0.0, 1.0)
        /// Black    (RGB:0.0, 0.0, 0.0)
        ///
        /// # Safety
        ///
        /// `out_range` must be a valid pointer or null.
        #[unsafe(method(backgroundColorAtIndex:range:))]
        // required for soundness, method has `returns_retained` attribute.
        #[unsafe(method_family = copy)]
        pub unsafe fn backgroundColorAtIndex_range(
            &self,
            index: NSInteger,
            out_range: *mut NSRange,
        ) -> Option<Retained<CGColor>>;

        /// Indicates the font weight of the character(s).
        ///
        /// The range parameter receives UTF-16 code unit index range the style is effective. After returning from the call, the range will indicate where the current style returned will be active and allows discovery of the next change in the style.
        ///
        /// CEA608 closed captions ignore this property.
        ///
        /// A visible distinction between AVCaptionFontWeightNormal and AVCaptionFontWeightBold may not exist if the font used has only one weight. This can be more common with CJK fonts where individual fonts can be quite large in terms of storage. Nevertheless, AVCaption still carries the font weight semantics so if the same AVCaption is applied to a different font having multiple weights, the distinction will become visible.
        ///
        /// # Safety
        ///
        /// `out_range` must be a valid pointer or null.
        #[unsafe(method(fontWeightAtIndex:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fontWeightAtIndex_range(
            &self,
            index: NSInteger,
            out_range: *mut NSRange,
        ) -> AVCaptionFontWeight;

        /// Indicates the font style of the character(s).
        ///
        /// The range parameter receives UTF-16 code unit index range the style is effective. After returning from the call, the range will indicate where the current style returned will be active and allows discovery of the next change in the style.
        ///
        /// Some writing systems may not have italic glyphs for characters and so fonts with italic forms are not available. For example, Japanese fonts do not typically have italic forms for most characters although there may be special cases for Latin characters. Nevertheless, AVCaption still carries the font style semantics even though there may be no visible rendering distinction between using AVCaptionFontStyleNormal and AVCaptionFontStyleItalic with that language.
        ///
        /// # Safety
        ///
        /// `out_range` must be a valid pointer or null.
        #[unsafe(method(fontStyleAtIndex:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fontStyleAtIndex_range(
            &self,
            index: NSInteger,
            out_range: *mut NSRange,
        ) -> AVCaptionFontStyle;

        /// Character decoration
        ///
        /// The value of OR-ed value of AVCaptionDecoration as NSInteger. The range parameter receives UTF-16 code unit index range the style is effective. After returning from the call, the range will indicate where the current style returned will be active and allows discovery of the next change in the style.
        ///
        /// CEA608 closed captions support only AVCaptionDecorationNone and AVCaptionDecorationUnderline.
        ///
        /// # Safety
        ///
        /// `out_range` must be a valid pointer or null.
        #[unsafe(method(decorationAtIndex:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn decorationAtIndex_range(
            &self,
            index: NSInteger,
            out_range: *mut NSRange,
        ) -> AVCaptionDecoration;

        /// Text combine (Tate-Chu-Yoko)
        ///
        /// The style is effective only in a vertical text region.
        ///
        /// When specified, the renderer combines all the characters in the style range so that their glyph areas consume the nominal bounding box of a single em square of the surrounding vertical text.
        ///
        /// # Safety
        ///
        /// `out_range` must be a valid pointer or null.
        #[unsafe(method(textCombineAtIndex:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textCombineAtIndex_range(
            &self,
            index: NSInteger,
            out_range: *mut NSRange,
        ) -> AVCaptionTextCombine;

        /// Get Ruby associated with the characters.
        ///
        /// The range parameter receives UTF-16 code unit index range where the ruby text is applied. After returning from the call, the range will indicate where the current style returned (including NULL) will be active and allows discovery of the next change in the style.
        ///
        /// It returns nil when the text doesn't have a ruby at the position.
        ///
        /// CEA608 closed captions ignore this property.
        ///
        /// # Safety
        ///
        /// `out_range` must be a valid pointer or null.
        #[unsafe(method(rubyAtIndex:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rubyAtIndex_range(
            &self,
            index: NSInteger,
            out_range: *mut NSRange,
        ) -> Option<Retained<AVCaptionRuby>>;
    );
}

/// Region.
impl AVCaption {
    extern_methods!(
        /// The region where the caption is placed.
        ///
        /// It can be nil when the underlying caption format doesn't support or use regions.
        #[unsafe(method(region))]
        #[unsafe(method_family = none)]
        pub unsafe fn region(&self) -> Option<Retained<AVCaptionRegion>>;

        /// The text alignment within the containing region.
        ///
        /// This property throws an exception if a value is set which is not a valid AVCaptionTextAlignment.
        #[unsafe(method(textAlignment))]
        #[unsafe(method_family = none)]
        pub unsafe fn textAlignment(&self) -> AVCaptionTextAlignment;
    );
}

/// Animation.
impl AVCaption {
    extern_methods!(
        #[unsafe(method(animation))]
        #[unsafe(method_family = none)]
        pub unsafe fn animation(&self) -> AVCaptionAnimation;
    );
}

/// Styling.
impl AVMutableCaption {
    extern_methods!(
        #[cfg(feature = "objc2-core-graphics")]
        /// Set text color for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(setTextColor:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTextColor_inRange(&self, color: &CGColor, range: NSRange);

        #[cfg(feature = "objc2-core-graphics")]
        /// Set background color for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(setBackgroundColor:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBackgroundColor_inRange(&self, color: &CGColor, range: NSRange);

        /// Set font weight for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(setFontWeight:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFontWeight_inRange(
            &self,
            font_weight: AVCaptionFontWeight,
            range: NSRange,
        );

        /// Set font style for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(setFontStyle:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFontStyle_inRange(&self, font_style: AVCaptionFontStyle, range: NSRange);

        /// Set text decoration for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(setDecoration:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDecoration_inRange(&self, decoration: AVCaptionDecoration, range: NSRange);

        /// Set text combine for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(setTextCombine:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTextCombine_inRange(
            &self,
            text_combine: AVCaptionTextCombine,
            range: NSRange,
        );

        /// Set ruby text  for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(setRuby:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRuby_inRange(&self, ruby: &AVCaptionRuby, range: NSRange);

        /// Remove text color for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(removeTextColorInRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTextColorInRange(&self, range: NSRange);

        /// Remove background color for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(removeBackgroundColorInRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeBackgroundColorInRange(&self, range: NSRange);

        /// Remove font weight for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(removeFontWeightInRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFontWeightInRange(&self, range: NSRange);

        /// Remove font style for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(removeFontStyleInRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFontStyleInRange(&self, range: NSRange);

        /// Remove text decoration for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(removeDecorationInRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeDecorationInRange(&self, range: NSRange);

        /// Remove text combine for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(removeTextCombineInRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeTextCombineInRange(&self, range: NSRange);

        /// Remove ruby text  for the range.
        ///
        /// The range parameter uses UTF-16 code unit index range.
        #[unsafe(method(removeRubyInRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeRubyInRange(&self, range: NSRange);
    );
}

/// Region.
impl AVMutableCaption {
    extern_methods!(
        /// The region where the caption is placed.
        ///
        /// It can be nil when the underlying caption format doesn't support or use regions.
        /// This property throws an exception if region has unrecognizeable units.
        #[unsafe(method(region))]
        #[unsafe(method_family = none)]
        pub unsafe fn region(&self) -> Retained<AVCaptionRegion>;

        /// Setter for [`region`][Self::region].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRegion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRegion(&self, region: &AVCaptionRegion);

        /// The text alignemnt within the containing region.
        #[unsafe(method(textAlignment))]
        #[unsafe(method_family = none)]
        pub unsafe fn textAlignment(&self) -> AVCaptionTextAlignment;

        /// Setter for [`textAlignment`][Self::textAlignment].
        #[unsafe(method(setTextAlignment:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTextAlignment(&self, text_alignment: AVCaptionTextAlignment);
    );
}

/// Animation.
impl AVMutableCaption {
    extern_methods!(
        #[unsafe(method(animation))]
        #[unsafe(method_family = none)]
        pub unsafe fn animation(&self) -> AVCaptionAnimation;

        /// Setter for [`animation`][Self::animation].
        #[unsafe(method(setAnimation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAnimation(&self, animation: AVCaptionAnimation);
    );
}

/// Choices for Ruby position
///
/// Display Ruby text above horizontal text or right of vertical text in a right to left block progression.
///
/// Display Ruby text below horizontal text or left of vertical text in a right to left block progression.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionrubyposition?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionRubyPosition(pub NSInteger);
impl AVCaptionRubyPosition {
    #[doc(alias = "AVCaptionRubyPositionBefore")]
    pub const Before: Self = Self(0);
    #[doc(alias = "AVCaptionRubyPositionAfter")]
    pub const After: Self = Self(1);
}

unsafe impl Encode for AVCaptionRubyPosition {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionRubyPosition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Choices for Ruby alignment
///
///
/// Given a ruby text rendering area denoted as [...], each spacing policy works as follows.
///
/// Start          [Ruby Text         ]
///
/// Center         [     Ruby Text    ]
///
/// SpaceBetween   [R u b y  T e x t]
/// <
/// - 'R' and 't' are aligned with start end end edges, spaces between each Ruby text character is equal.
///
/// SpaceAround    [ R u b y  T e x t ]
/// <
/// - Spaces around each Ruby text character is equal
///
///
/// Align Ruby base and text at left edge of horizontal text in a left to right inline progression, or at top of the vertical text in a top to bottom inline progression.
///
/// Align Ruby text at the center of Ruby base.
///
/// Align Ruby text so that the spaces between the Ruby text characters are equal. This is the default.
///
/// Align Ruby text so that the spaces around each Ruby text character are equal.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionrubyalignment?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVCaptionRubyAlignment(pub NSInteger);
impl AVCaptionRubyAlignment {
    #[doc(alias = "AVCaptionRubyAlignmentStart")]
    pub const Start: Self = Self(0);
    #[doc(alias = "AVCaptionRubyAlignmentCenter")]
    pub const Center: Self = Self(1);
    #[doc(alias = "AVCaptionRubyAlignmentDistributeSpaceBetween")]
    pub const DistributeSpaceBetween: Self = Self(2);
    #[doc(alias = "AVCaptionRubyAlignmentDistributeSpaceAround")]
    pub const DistributeSpaceAround: Self = Self(3);
}

unsafe impl Encode for AVCaptionRubyAlignment {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVCaptionRubyAlignment {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Subclasses of this type that are used from Swift must fulfill the requirements of a Sendable type.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avcaptionruby?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVCaptionRuby;
);

unsafe impl Send for AVCaptionRuby {}

unsafe impl Sync for AVCaptionRuby {}

extern_conformance!(
    unsafe impl NSCoding for AVCaptionRuby {}
);

extern_conformance!(
    unsafe impl NSCopying for AVCaptionRuby {}
);

unsafe impl CopyingHelper for AVCaptionRuby {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVCaptionRuby {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for AVCaptionRuby {}
);

impl AVCaptionRuby {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(initWithText:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithText(this: Allocated<Self>, text: &NSString) -> Retained<Self>;

        #[unsafe(method(initWithText:position:alignment:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithText_position_alignment(
            this: Allocated<Self>,
            text: &NSString,
            position: AVCaptionRubyPosition,
            alignment: AVCaptionRubyAlignment,
        ) -> Retained<Self>;

        /// The ruby text
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(text))]
        #[unsafe(method_family = none)]
        pub unsafe fn text(&self) -> Retained<NSString>;

        /// The position of ruby text with respect to the ruby base.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(position))]
        #[unsafe(method_family = none)]
        pub unsafe fn position(&self) -> AVCaptionRubyPosition;

        /// The alignment of ruby text.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(alignment))]
        #[unsafe(method_family = none)]
        pub unsafe fn alignment(&self) -> AVCaptionRubyAlignment;
    );
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "renamed to `AVCaptionDimension::new`"]
    pub fn AVCaptionDimensionMake(value: CGFloat, units: AVCaptionUnitsType) -> AVCaptionDimension;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "renamed to `AVCaptionPoint::new`"]
    pub fn AVCaptionPointMake(x: AVCaptionDimension, y: AVCaptionDimension) -> AVCaptionPoint;
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "renamed to `AVCaptionSize::new`"]
    pub fn AVCaptionSizeMake(
        width: AVCaptionDimension,
        height: AVCaptionDimension,
    ) -> AVCaptionSize;
}
