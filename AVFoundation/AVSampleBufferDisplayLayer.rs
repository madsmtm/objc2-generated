//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
use objc2_quartz_core::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplebufferdisplaylayerfailedtodecodenotification?language=objc)
    pub static AVSampleBufferDisplayLayerFailedToDecodeNotification: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplebufferdisplaylayerfailedtodecodenotificationerrorkey?language=objc)
    pub static AVSampleBufferDisplayLayerFailedToDecodeNotificationErrorKey: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplebufferdisplaylayerrequiresflushtoresumedecodingdidchangenotification?language=objc)
    pub static AVSampleBufferDisplayLayerRequiresFlushToResumeDecodingDidChangeNotification:
        &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplebufferdisplaylayeroutputobscuredduetoinsufficientexternalprotectiondidchangenotification?language=objc)
    pub static AVSampleBufferDisplayLayerOutputObscuredDueToInsufficientExternalProtectionDidChangeNotification:
        &'static NSNotificationName;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplebufferdisplaylayerreadyfordisplaydidchangenotification?language=objc)
    pub static AVSampleBufferDisplayLayerReadyForDisplayDidChangeNotification:
        &'static NSNotificationName;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avsamplebufferdisplaylayer?language=objc)
    #[unsafe(super(CALayer, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "objc2-quartz-core")]
    #[cfg(not(target_os = "watchos"))]
    pub struct AVSampleBufferDisplayLayer;
);

#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
extern_conformance!(
    unsafe impl CAMediaTiming for AVSampleBufferDisplayLayer {}
);

#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
extern_conformance!(
    unsafe impl NSCoding for AVSampleBufferDisplayLayer {}
);

#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for AVSampleBufferDisplayLayer {}
);

#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
extern_conformance!(
    unsafe impl NSSecureCoding for AVSampleBufferDisplayLayer {}
);

#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
impl AVSampleBufferDisplayLayer {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// The layer's control timebase, which governs how time stamps are interpreted.
        ///
        /// By default, this property is NULL, in which case time stamps will be interpreted
        /// according to the host time clock (mach_absolute_time with the appropriate timescale
        /// conversion; this is the same as Core Animation's CACurrentMediaTime).  With no
        /// control timebase, once frames are enqueued, it is not possible to adjust exactly
        /// when they are displayed.
        ///
        /// If a non-NULL control timebase is set, it will be used to interpret time stamps.
        /// You can control the timing of frame display by setting the rate and time of the
        /// control timebase.
        /// If you are synchronizing video to audio, you can use a timebase whose source clock
        /// is a CMAudioDeviceClock for the appropriate audio device to prevent drift.
        ///
        /// Note that prior to OSX 10.10 and iOS 8.0, the control timebase could not be changed after enqueueSampleBuffer: was called.  As of OSX 10.10 and iOS 8.0, the control timebase may be changed at any time.
        #[unsafe(method(controlTimebase))]
        #[unsafe(method_family = none)]
        pub unsafe fn controlTimebase(&self) -> Option<Retained<CMTimebase>>;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`controlTimebase`][Self::controlTimebase].
        #[unsafe(method(setControlTimebase:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setControlTimebase(&self, control_timebase: Option<&CMTimebase>);

        #[cfg(feature = "AVAnimation")]
        /// A string defining how the video is displayed within an AVSampleBufferDisplayLayer bounds rect.
        ///
        /// Options are AVLayerVideoGravityResizeAspect, AVLayerVideoGravityResizeAspectFill
        /// and AVLayerVideoGravityResize. AVLayerVideoGravityResizeAspect is default.
        /// See
        /// <AVFoundation
        /// /AVAnimation.h> for a description of these options.
        #[unsafe(method(videoGravity))]
        #[unsafe(method_family = none)]
        pub unsafe fn videoGravity(&self) -> Retained<AVLayerVideoGravity>;

        #[cfg(feature = "AVAnimation")]
        /// Setter for [`videoGravity`][Self::videoGravity].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setVideoGravity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVideoGravity(&self, video_gravity: &AVLayerVideoGravity);

        /// Boolean indicating that the first video frame has been made ready for display.
        ///
        /// Use this property as an indicator of when best to show or animate-in an AVSampleBufferDisplayLayer into view.
        /// An AVSampleBufferDisplayLayer may be displayed, or made visible, while this property is NO, however the layer will not have any user-visible content until the value becomes YES. Note that if an animation is added to an AVSampleBufferDisplayLayer before it becomes readyForDisplay the video image displayed inside might not animate with the receiver.
        /// readyForDisplay will change to NO when the layer can no longer display frames. readyForDisplay will be YES when the first video frame has been made ready for display.
        /// This property is not key-value observable.  AVSampleBufferDisplayLayerReadyForDisplayDidChangeNotification is posted when this value changes.
        #[unsafe(method(isReadyForDisplay))]
        #[unsafe(method_family = none)]
        pub unsafe fn isReadyForDisplay(&self) -> bool;
    );
}

/// Methods declared on superclass `CALayer`.
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
impl AVSampleBufferDisplayLayer {
    extern_methods!(
        /// Layer creation and initialization. *
        #[unsafe(method(layer))]
        #[unsafe(method_family = none)]
        pub unsafe fn layer() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `layer` should be of the correct type.
        #[unsafe(method(initWithLayer:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithLayer(this: Allocated<Self>, layer: &AnyObject) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
impl AVSampleBufferDisplayLayer {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// AVSampleBufferDisplayLayerQueueManagement.
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
impl AVSampleBufferDisplayLayer {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// The renderer's timebase, which governs how time stamps are interpreted.
        ///
        /// The timebase is used to interpret time stamps.
        ///
        /// The timebase is read-only.  Use the AVSampleBufferRenderSynchronizer to set the rate or time.
        #[deprecated = "Use sampleBufferRenderer's timebase instead"]
        #[unsafe(method(timebase))]
        #[unsafe(method_family = none)]
        pub unsafe fn timebase(&self) -> Retained<CMTimebase>;

        #[cfg(feature = "AVQueuedSampleBufferRendering")]
        /// The ability of the display layer to be used for enqueuing sample buffers.
        ///
        /// The value of this property is an AVQueuedSampleBufferRenderingStatus that indicates whether the receiver can be used for enqueuing and rendering sample buffers. When the value of this property is AVQueuedSampleBufferRenderingStatusFailed, clients can check the value of the error property to determine the failure. To resume rendering sample buffers using the display layer after a failure, clients must first reset the status to AVQueuedSampleBufferRenderingStatusUnknown. This can be achieved by invoking -flush on the display layer.
        ///
        /// This property is key value observable.
        #[deprecated = "Use sampleBufferRenderer's status instead"]
        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        pub unsafe fn status(&self) -> AVQueuedSampleBufferRenderingStatus;

        /// If the display layer's status is AVQueuedSampleBufferRenderingStatusFailed, this describes the error that caused the failure.
        ///
        /// The value of this property is an NSError that describes what caused the display layer to no longer be able to enqueue sample buffers. If the status is not AVQueuedSampleBufferRenderingStatusFailed, the value of this property is nil.
        #[deprecated = "Use sampleBufferRenderer's error instead"]
        #[unsafe(method(error))]
        #[unsafe(method_family = none)]
        pub unsafe fn error(&self) -> Option<Retained<NSError>>;

        #[cfg(feature = "objc2-core-media")]
        /// Sends a sample buffer for display.
        ///
        /// If sampleBuffer has the kCMSampleAttachmentKey_DoNotDisplay attachment set to
        /// kCFBooleanTrue, the frame will be decoded but not displayed.
        /// Otherwise, if sampleBuffer has the kCMSampleAttachmentKey_DisplayImmediately
        /// attachment set to kCFBooleanTrue, the decoded image will be displayed as soon
        /// as possible, replacing all previously enqueued images regardless of their timestamps.
        /// Otherwise, the decoded image will be displayed at sampleBuffer's output presentation
        /// timestamp, as interpreted by the control timebase (or the mach_absolute_time timeline
        /// if there is no control timebase).
        ///
        /// To schedule the removal of previous images at a specific timestamp, enqueue
        /// a marker sample buffer containing no samples, with the
        /// kCMSampleBufferAttachmentKey_EmptyMedia attachment set to kCFBooleanTrue.
        ///
        /// IMPORTANT NOTE: attachments with the kCMSampleAttachmentKey_ prefix must be set via
        /// CMSampleBufferGetSampleAttachmentsArray and CFDictionarySetValue.
        /// Attachments with the kCMSampleBufferAttachmentKey_ prefix must be set via
        /// CMSetAttachment.
        ///
        /// IMPORTANT NOTE:  When using CMSampleBuffers that wrap CVPixelBuffer, it is important that such CVPixelBuffers be IOSurface-backed.
        /// CoreVideo allocates IOSurface-backed CVPixelBuffers when the pixel buffer attribute dictionary passed to CVPixelBufferPoolCreate contains
        /// an entry with key kCVPixelBufferIOSurfacePropertiesKey and value being a dictionary (which can be an empty dictionary).
        ///
        /// The combination of either a non-NULL controlTimebase or an AVSampleBufferRenderSynchronizer with the use of kCMSampleAttachmentKey_DisplayImmediately as an attachment to the CMSampleBuffers that are enqueued for display is not recommended.
        #[deprecated = "Use sampleBufferRenderer's enqueueSampleBuffer: instead"]
        #[unsafe(method(enqueueSampleBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enqueueSampleBuffer(&self, sample_buffer: &CMSampleBuffer);

        /// Instructs the layer to discard pending enqueued sample buffers.
        ///
        /// It is not possible to determine which sample buffers have been decoded,
        /// so the next frame passed to enqueueSampleBuffer: should be an IDR frame
        /// (also known as a key frame or sync sample).
        #[deprecated = "Use sampleBufferRenderer's flush instead"]
        #[unsafe(method(flush))]
        #[unsafe(method_family = none)]
        pub unsafe fn flush(&self);

        /// Instructs the layer to discard pending enqueued sample buffers and remove any
        /// currently displayed image.
        ///
        /// It is not possible to determine which sample buffers have been decoded,
        /// so the next frame passed to enqueueSampleBuffer: should be an IDR frame
        /// (also known as a key frame or sync sample).
        #[deprecated = "Use sampleBufferRenderer's flushWithRemovalOfDisplayedImage:completionHandler: instead"]
        #[unsafe(method(flushAndRemoveImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn flushAndRemoveImage(&self);

        /// Indicates that the receiver is in a state where it requires a call to -flush to continue decoding frames.
        ///
        /// When the application enters a state where use of video decoder resources is not permissible, the value of this property changes to YES along with the display layer's status changing to AVQueuedSampleBufferRenderingStatusFailed.
        /// To resume rendering sample buffers using the display layer after this property's value is YES, clients must first reset the display layer's status to AVQueuedSampleBufferRenderingStatusUnknown. This can be achieved by invoking -flush on the display layer.
        /// Clients can track changes to this property via AVSampleBufferDisplayLayerRequiresFlushToResumeDecodingDidChangeNotification.
        /// This property is not key value observable.
        #[deprecated = "Use sampleBufferRenderer's requiresFlushToResumeDecoding instead"]
        #[unsafe(method(requiresFlushToResumeDecoding))]
        #[unsafe(method_family = none)]
        pub unsafe fn requiresFlushToResumeDecoding(&self) -> bool;

        /// Indicates the readiness of the layer to accept more sample buffers.
        ///
        /// AVSampleBufferDisplayLayer keeps track of the occupancy levels of its internal queues
        /// for the benefit of clients that enqueue sample buffers from non-real-time sources --
        /// i.e., clients that can supply sample buffers faster than they are consumed, and so
        /// need to decide when to hold back.
        ///
        /// Clients enqueueing sample buffers from non-real-time sources may hold off from
        /// generating or obtaining more sample buffers to enqueue when the value of
        /// readyForMoreMediaData is NO.
        ///
        /// It is safe to call enqueueSampleBuffer: when readyForMoreMediaData is NO, but
        /// it is a bad idea to enqueue sample buffers without bound.
        ///
        /// To help with control of the non-real-time supply of sample buffers, such clients can use
        /// -requestMediaDataWhenReadyOnQueue:usingBlock
        /// in order to specify a block that the layer should invoke whenever it's ready for
        /// sample buffers to be appended.
        ///
        /// The value of readyForMoreMediaData will often change from NO to YES asynchronously,
        /// as previously supplied sample buffers are decoded and displayed.
        ///
        /// This property is not key value observable.
        #[deprecated = "Use sampleBufferRenderer's readyForMoreMediaData instead"]
        #[unsafe(method(isReadyForMoreMediaData))]
        #[unsafe(method_family = none)]
        pub unsafe fn isReadyForMoreMediaData(&self) -> bool;

        #[cfg(all(feature = "block2", feature = "dispatch2"))]
        /// Instructs the target to invoke a client-supplied block repeatedly,
        /// at its convenience, in order to gather sample buffers for display.
        ///
        /// The block should enqueue sample buffers to the layer either until the layer's
        /// readyForMoreMediaData property becomes NO or until there is no more data
        /// to supply. When the layer has decoded enough of the media data it has received
        /// that it becomes ready for more media data again, it will invoke the block again
        /// in order to obtain more.
        /// If this function is called multiple times, only the last call is effective.
        /// Call stopRequestingMediaData to cancel this request.
        /// Each call to requestMediaDataWhenReadyOnQueue:usingBlock: should be paired
        /// with a corresponding call to stopRequestingMediaData:. Releasing the
        /// AVSampleBufferDisplayLayer without a call to stopRequestingMediaData will result
        /// in undefined behavior.
        ///
        /// # Safety
        ///
        /// `block` block must be sendable.
        #[deprecated = "Use sampleBufferRenderer's requestMediaDataWhenReadyOnQueue:usingBlock: instead"]
        #[unsafe(method(requestMediaDataWhenReadyOnQueue:usingBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestMediaDataWhenReadyOnQueue_usingBlock(
            &self,
            queue: &DispatchQueue,
            block: &block2::DynBlock<dyn Fn()>,
        );

        /// Cancels any current requestMediaDataWhenReadyOnQueue:usingBlock: call.
        ///
        /// This method may be called from outside the block or from within the block.
        #[deprecated = "Use sampleBufferRenderer's stopRequestingMediaData instead"]
        #[unsafe(method(stopRequestingMediaData))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopRequestingMediaData(&self);

        /// Indicates whether the enqueued media data meets the renderer's preroll level.
        ///
        /// Clients should fetch the value of this property to learn if the renderer has had enough media data enqueued to start playback reliably. Starting playback when this property is NO may prevent smooth playback following an immediate start.
        #[deprecated = "Use sampleBufferRenderer's hasSufficientMediaDataForReliablePlaybackStart instead"]
        #[unsafe(method(hasSufficientMediaDataForReliablePlaybackStart))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasSufficientMediaDataForReliablePlaybackStart(&self) -> bool;
    );
}

#[cfg(all(
    feature = "AVQueuedSampleBufferRendering",
    feature = "objc2-quartz-core"
))]
#[cfg(not(target_os = "watchos"))]
extern_conformance!(
    unsafe impl AVQueuedSampleBufferRendering for AVSampleBufferDisplayLayer {}
);

/// AVSampleBufferDisplayLayerImageProtection.
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
impl AVSampleBufferDisplayLayer {
    extern_methods!(
        /// Indicates that image data should be protected from capture.
        #[unsafe(method(preventsCapture))]
        #[unsafe(method_family = none)]
        pub unsafe fn preventsCapture(&self) -> bool;

        /// Setter for [`preventsCapture`][Self::preventsCapture].
        #[unsafe(method(setPreventsCapture:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreventsCapture(&self, prevents_capture: bool);
    );
}

/// AVSampleBufferDisplayLayerVideoDisplaySleepPrevention.
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
impl AVSampleBufferDisplayLayer {
    extern_methods!(
        /// Indicates whether video playback prevents display and device sleep.
        ///
        /// Default is YES on iOS, tvOS and in Mac Catalyst apps.  Default is NO on macOS.
        /// Setting this property to NO does not force the display to sleep, it simply stops preventing display sleep.  Other apps or frameworks within your app may still be preventing display sleep for various reasons.
        /// Note: If sample buffers are being enqueued for playback at the user's request, you should ensure that the value of this property is set to YES. If video is not being displayed as part of the user's primary focus, you should ensure that the value of this property is set to NO.
        #[unsafe(method(preventsDisplaySleepDuringVideoPlayback))]
        #[unsafe(method_family = none)]
        pub unsafe fn preventsDisplaySleepDuringVideoPlayback(&self) -> bool;

        /// Setter for [`preventsDisplaySleepDuringVideoPlayback`][Self::preventsDisplaySleepDuringVideoPlayback].
        #[unsafe(method(setPreventsDisplaySleepDuringVideoPlayback:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreventsDisplaySleepDuringVideoPlayback(
            &self,
            prevents_display_sleep_during_video_playback: bool,
        );
    );
}

/// AVSampleBufferDisplayLayerAutomaticBackgroundPrevention.
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
impl AVSampleBufferDisplayLayer {
    extern_methods!(
        /// Indicates whether video playback prevents the app from automatically getting backgrounded.
        ///
        /// Default is YES.
        /// Setting this property to YES prevents an application that is playing video from automatically getting backgrounded.  This property does not prevent the user from backgrounding the application.
        /// Note: If sample buffers are being enqueued for playback at the user's request, you should ensure that the value of this property is set to YES. If video is not being displayed as part of the user's primary focus, you should ensure that the value of this property is set to NO.
        #[unsafe(method(preventsAutomaticBackgroundingDuringVideoPlayback))]
        #[unsafe(method_family = none)]
        pub unsafe fn preventsAutomaticBackgroundingDuringVideoPlayback(&self) -> bool;

        /// Setter for [`preventsAutomaticBackgroundingDuringVideoPlayback`][Self::preventsAutomaticBackgroundingDuringVideoPlayback].
        #[unsafe(method(setPreventsAutomaticBackgroundingDuringVideoPlayback:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreventsAutomaticBackgroundingDuringVideoPlayback(
            &self,
            prevents_automatic_backgrounding_during_video_playback: bool,
        );
    );
}

/// ProtectedContent.
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
impl AVSampleBufferDisplayLayer {
    extern_methods!(
        /// Whether or not decoded output is being obscured due to insufficient external protection.
        ///
        ///
        /// The value of this property indicates whether the layer is purposefully obscuring its visual output
        /// because the requirement for an external protection mechanism is not met by the current device
        /// configuration. The change of this property can be observed through AVSampleBufferDisplayLayerOutputObscuredDueToInsufficientExternalProtectionDidChangeNotification
        ///
        /// It is highly recommended that clients whose content requires external
        /// protection observe this property and set the playback rate to zero and display an appropriate user
        /// interface when the value changes to YES.
        ///
        /// Note that the value of this property is dependent on the external protection requirements of the
        /// media being displayed by the layer. These requirements are inherent to the content itself and cannot
        /// be externally specified. If the content does not require external protection, the value of this
        /// property will be NO.
        #[unsafe(method(outputObscuredDueToInsufficientExternalProtection))]
        #[unsafe(method_family = none)]
        pub unsafe fn outputObscuredDueToInsufficientExternalProtection(&self) -> bool;
    );
}

/// AVSampleBufferDisplayLayerRenderer.
#[cfg(feature = "objc2-quartz-core")]
#[cfg(not(target_os = "watchos"))]
impl AVSampleBufferDisplayLayer {
    extern_methods!(
        #[cfg(feature = "AVSampleBufferVideoRenderer")]
        /// An AVSampleBufferVideoRenderer instance that allows enqueuing sample buffers for rendering.
        ///
        /// Although AVSampleBufferDisplayLayer conforms to the AVQueuedSampleBufferRendering protocol, the sampleBufferRenderer should be used to enqueue sample buffers. sampleBufferRenderer allows the client to safely enqueue sample buffers from a background thread. NOTE: Do not use AVSampleBufferDisplayLayer's AVQueuedSampleBufferRendering functions when using sampleBufferRenderer.
        #[unsafe(method(sampleBufferRenderer))]
        #[unsafe(method_family = none)]
        pub unsafe fn sampleBufferRenderer(&self) -> Retained<AVSampleBufferVideoRenderer>;
    );
}
