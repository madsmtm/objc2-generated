//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;

use crate::*;

/// These constants are the possible status values for queued sample buffer renderers.
///
/// Indicates that the receiver is in a fresh state without any sample buffers enqueued on it.
///
/// Indicates at least one sample buffer has been enqueued on the receiver.
///
/// Indicates that the receiver cannot currently enqueue or render sample buffers because of an error.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avqueuedsamplebufferrenderingstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVQueuedSampleBufferRenderingStatus(pub NSInteger);
impl AVQueuedSampleBufferRenderingStatus {
    #[doc(alias = "AVQueuedSampleBufferRenderingStatusUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "AVQueuedSampleBufferRenderingStatusRendering")]
    pub const Rendering: Self = Self(1);
    #[doc(alias = "AVQueuedSampleBufferRenderingStatusFailed")]
    pub const Failed: Self = Self(2);
}

unsafe impl Encode for AVQueuedSampleBufferRenderingStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVQueuedSampleBufferRenderingStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/avfoundation/avqueuedsamplebufferrendering?language=objc)
    pub unsafe trait AVQueuedSampleBufferRendering: NSObjectProtocol {
        #[cfg(feature = "objc2-core-media")]
        /// The renderer's timebase, which governs how time stamps are interpreted.
        ///
        /// The timebase is used to interpret time stamps.
        ///
        /// The timebase is read-only.  Use the AVSampleBufferRenderSynchronizer to set the rate or time.
        #[unsafe(method(timebase))]
        #[unsafe(method_family = none)]
        unsafe fn timebase(&self) -> Retained<CMTimebase>;

        #[cfg(feature = "objc2-core-media")]
        /// Sends a sample buffer in order to render its contents.
        ///
        /// Video-specific notes:
        ///
        /// If sampleBuffer has the kCMSampleAttachmentKey_DoNotDisplay attachment set to kCFBooleanTrue, the frame will be decoded but not displayed.  Otherwise, if sampleBuffer has the kCMSampleAttachmentKey_DisplayImmediately attachment set to kCFBooleanTrue, the decoded image will be displayed as soon as possible, replacing all previously enqueued images regardless of their timestamps.  Otherwise, the decoded image will be displayed at sampleBuffer's output presentation timestamp, as interpreted by the timebase.
        ///
        /// To schedule the removal of previous images at a specific timestamp, enqueue a marker sample buffer containing no samples, with the kCMSampleBufferAttachmentKey_EmptyMedia attachment set to kCFBooleanTrue.
        ///
        /// IMPORTANT NOTE: attachments with the kCMSampleAttachmentKey_ prefix must be set via CMSampleBufferGetSampleAttachmentsArray and CFDictionarySetValue.  Attachments with the kCMSampleBufferAttachmentKey_ prefix must be set via CMSetAttachment.
        ///
        /// The combination of either a non-NULL controlTimebase or an AVSampleBufferRenderSynchronizer with the use of kCMSampleAttachmentKey_DisplayImmediately as an attachment to the CMSampleBuffers that are enqueued for display is not recommended.
        #[unsafe(method(enqueueSampleBuffer:))]
        #[unsafe(method_family = none)]
        unsafe fn enqueueSampleBuffer(&self, sample_buffer: &CMSampleBuffer);

        /// Instructs the receiver to discard pending enqueued sample buffers.
        ///
        /// Additional sample buffers can be appended after -flush.
        ///
        /// Video-specific notes:
        ///
        /// It is not possible to determine which sample buffers have been decoded, so the next frame passed to enqueueSampleBuffer: should be an IDR frame (also known as a key frame or sync sample).
        #[unsafe(method(flush))]
        #[unsafe(method_family = none)]
        unsafe fn flush(&self);

        /// Indicates the readiness of the receiver to accept more sample buffers.
        ///
        /// An object conforming to AVQueuedSampleBufferRendering keeps track of the occupancy levels of its internal queues for the benefit of clients that enqueue sample buffers from non-real-time sources -- i.e., clients that can supply sample buffers faster than they are consumed, and so need to decide when to hold back.
        ///
        /// Clients enqueueing sample buffers from non-real-time sources may hold off from generating or obtaining more sample buffers to enqueue when the value of readyForMoreMediaData is NO.
        ///
        /// It is safe to call enqueueSampleBuffer: when readyForMoreMediaData is NO, but it is a bad idea to enqueue sample buffers without bound.
        ///
        /// To help with control of the non-real-time supply of sample buffers, such clients can use -requestMediaDataWhenReadyOnQueue:usingBlock in order to specify a block that the receiver should invoke whenever it's ready for sample buffers to be appended.
        ///
        /// The value of readyForMoreMediaData will often change from NO to YES asynchronously, as previously supplied sample buffers are decoded and rendered.
        ///
        /// This property is not key value observable.
        #[unsafe(method(isReadyForMoreMediaData))]
        #[unsafe(method_family = none)]
        unsafe fn isReadyForMoreMediaData(&self) -> bool;

        #[cfg(all(feature = "block2", feature = "dispatch2"))]
        /// Instructs the target to invoke a client-supplied block repeatedly, at its convenience, in order to gather sample buffers for playback.
        ///
        /// The block should enqueue sample buffers to the receiver either until the receiver's readyForMoreMediaData property becomes NO or until there is no more data to supply. When the receiver has decoded enough of the media data it has received that it becomes ready for more media data again, it will invoke the block again in order to obtain more.
        ///
        /// If this method is called multiple times, only the last call is effective. Call stopRequestingMediaData to cancel this request.
        ///
        /// Each call to requestMediaDataWhenReadyOnQueue:usingBlock: should be paired with a corresponding call to stopRequestingMediaData:. Releasing the AVQueuedSampleBufferRendering object without a call to stopRequestingMediaData will result in undefined behavior.
        ///
        /// # Safety
        ///
        /// `block` block must be sendable.
        #[unsafe(method(requestMediaDataWhenReadyOnQueue:usingBlock:))]
        #[unsafe(method_family = none)]
        unsafe fn requestMediaDataWhenReadyOnQueue_usingBlock(
            &self,
            queue: &DispatchQueue,
            block: &block2::DynBlock<dyn Fn()>,
        );

        /// Cancels any current requestMediaDataWhenReadyOnQueue:usingBlock: call.
        ///
        /// This method may be called from outside the block or from within the block.
        #[unsafe(method(stopRequestingMediaData))]
        #[unsafe(method_family = none)]
        unsafe fn stopRequestingMediaData(&self);

        /// Indicates whether the enqueued media data meets the renderer's preroll level.
        ///
        /// Clients should fetch the value of this property to learn if the renderer has had enough media data enqueued to start playback reliably. Starting playback when this property is NO may prevent smooth playback following an immediate start.
        #[unsafe(method(hasSufficientMediaDataForReliablePlaybackStart))]
        #[unsafe(method_family = none)]
        unsafe fn hasSufficientMediaDataForReliablePlaybackStart(&self) -> bool;
    }
);
