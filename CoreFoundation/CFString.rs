//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringencodinginvalidid?language=objc)
pub const kCFStringEncodingInvalidId: c_uint = 0xffffffff;
/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfstringencoding?language=objc)
pub type CFStringEncoding = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfstringbuiltinencodings?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFStringBuiltInEncodings(pub CFStringEncoding);
impl CFStringBuiltInEncodings {
    #[doc(alias = "kCFStringEncodingMacRoman")]
    pub const EncodingMacRoman: Self = Self(0);
    #[doc(alias = "kCFStringEncodingWindowsLatin1")]
    pub const EncodingWindowsLatin1: Self = Self(0x0500);
    #[doc(alias = "kCFStringEncodingISOLatin1")]
    pub const EncodingISOLatin1: Self = Self(0x0201);
    #[doc(alias = "kCFStringEncodingNextStepLatin")]
    pub const EncodingNextStepLatin: Self = Self(0x0B01);
    #[doc(alias = "kCFStringEncodingASCII")]
    pub const EncodingASCII: Self = Self(0x0600);
    #[doc(alias = "kCFStringEncodingUnicode")]
    pub const EncodingUnicode: Self = Self(0x0100);
    #[doc(alias = "kCFStringEncodingUTF8")]
    pub const EncodingUTF8: Self = Self(0x08000100);
    #[doc(alias = "kCFStringEncodingNonLossyASCII")]
    pub const EncodingNonLossyASCII: Self = Self(0x0BFF);
    #[doc(alias = "kCFStringEncodingUTF16")]
    pub const EncodingUTF16: Self = Self(0x0100);
    #[doc(alias = "kCFStringEncodingUTF16BE")]
    pub const EncodingUTF16BE: Self = Self(0x10000100);
    #[doc(alias = "kCFStringEncodingUTF16LE")]
    pub const EncodingUTF16LE: Self = Self(0x14000100);
    #[doc(alias = "kCFStringEncodingUTF32")]
    pub const EncodingUTF32: Self = Self(0x0c000100);
    #[doc(alias = "kCFStringEncodingUTF32BE")]
    pub const EncodingUTF32BE: Self = Self(0x18000100);
    #[doc(alias = "kCFStringEncodingUTF32LE")]
    pub const EncodingUTF32LE: Self = Self(0x1c000100);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStringBuiltInEncodings {
    const ENCODING: Encoding = CFStringEncoding::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStringBuiltInEncodings {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for CFString {
    #[doc(alias = "CFStringGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFStringGetTypeID() -> CFTypeID;
        }
        unsafe { CFStringGetTypeID() }
    }
}

impl CFString {
    /// * Immutable string creation functions **
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `p_str` must be a valid pointer.
    #[doc(alias = "CFStringCreateWithPascalString")]
    #[inline]
    pub unsafe fn with_pascal_string(
        alloc: Option<&CFAllocator>,
        p_str: ConstStr255Param,
        encoding: CFStringEncoding,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithPascalString(
                alloc: Option<&CFAllocator>,
                p_str: ConstStr255Param,
                encoding: CFStringEncoding,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringCreateWithPascalString(alloc, p_str, encoding) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `c_str` must be a valid pointer.
    #[doc(alias = "CFStringCreateWithCString")]
    #[inline]
    pub unsafe fn with_c_string(
        alloc: Option<&CFAllocator>,
        c_str: *const c_char,
        encoding: CFStringEncoding,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithCString(
                alloc: Option<&CFAllocator>,
                c_str: *const c_char,
                encoding: CFStringEncoding,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringCreateWithCString(alloc, c_str, encoding) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `bytes` must be a valid pointer.
    #[doc(alias = "CFStringCreateWithBytes")]
    #[inline]
    pub unsafe fn with_bytes(
        alloc: Option<&CFAllocator>,
        bytes: *const u8,
        num_bytes: CFIndex,
        encoding: CFStringEncoding,
        is_external_representation: bool,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithBytes(
                alloc: Option<&CFAllocator>,
                bytes: *const u8,
                num_bytes: CFIndex,
                encoding: CFStringEncoding,
                is_external_representation: Boolean,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe {
            CFStringCreateWithBytes(
                alloc,
                bytes,
                num_bytes,
                encoding,
                is_external_representation as _,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `chars` must be a valid pointer.
    #[doc(alias = "CFStringCreateWithCharacters")]
    #[inline]
    pub unsafe fn with_characters(
        alloc: Option<&CFAllocator>,
        chars: *const UniChar,
        num_chars: CFIndex,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithCharacters(
                alloc: Option<&CFAllocator>,
                chars: *const UniChar,
                num_chars: CFIndex,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringCreateWithCharacters(alloc, chars, num_chars) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `p_str` must be a valid pointer.
    /// - `contents_deallocator` might not allow `None`.
    #[doc(alias = "CFStringCreateWithPascalStringNoCopy")]
    #[inline]
    pub unsafe fn with_pascal_string_no_copy(
        alloc: Option<&CFAllocator>,
        p_str: ConstStr255Param,
        encoding: CFStringEncoding,
        contents_deallocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithPascalStringNoCopy(
                alloc: Option<&CFAllocator>,
                p_str: ConstStr255Param,
                encoding: CFStringEncoding,
                contents_deallocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe {
            CFStringCreateWithPascalStringNoCopy(alloc, p_str, encoding, contents_deallocator)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `c_str` must be a valid pointer.
    /// - `contents_deallocator` might not allow `None`.
    #[doc(alias = "CFStringCreateWithCStringNoCopy")]
    #[inline]
    pub unsafe fn with_c_string_no_copy(
        alloc: Option<&CFAllocator>,
        c_str: *const c_char,
        encoding: CFStringEncoding,
        contents_deallocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithCStringNoCopy(
                alloc: Option<&CFAllocator>,
                c_str: *const c_char,
                encoding: CFStringEncoding,
                contents_deallocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe {
            CFStringCreateWithCStringNoCopy(alloc, c_str, encoding, contents_deallocator)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `bytes` must be a valid pointer.
    /// - `contents_deallocator` might not allow `None`.
    #[doc(alias = "CFStringCreateWithBytesNoCopy")]
    #[inline]
    pub unsafe fn with_bytes_no_copy(
        alloc: Option<&CFAllocator>,
        bytes: *const u8,
        num_bytes: CFIndex,
        encoding: CFStringEncoding,
        is_external_representation: bool,
        contents_deallocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithBytesNoCopy(
                alloc: Option<&CFAllocator>,
                bytes: *const u8,
                num_bytes: CFIndex,
                encoding: CFStringEncoding,
                is_external_representation: Boolean,
                contents_deallocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe {
            CFStringCreateWithBytesNoCopy(
                alloc,
                bytes,
                num_bytes,
                encoding,
                is_external_representation as _,
                contents_deallocator,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `chars` must be a valid pointer.
    /// - `contents_deallocator` might not allow `None`.
    #[doc(alias = "CFStringCreateWithCharactersNoCopy")]
    #[inline]
    pub unsafe fn with_characters_no_copy(
        alloc: Option<&CFAllocator>,
        chars: *const UniChar,
        num_chars: CFIndex,
        contents_deallocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithCharactersNoCopy(
                alloc: Option<&CFAllocator>,
                chars: *const UniChar,
                num_chars: CFIndex,
                contents_deallocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe {
            CFStringCreateWithCharactersNoCopy(alloc, chars, num_chars, contents_deallocator)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `str` might not allow `None`.
    #[doc(alias = "CFStringCreateWithSubstring")]
    #[inline]
    pub unsafe fn with_substring(
        alloc: Option<&CFAllocator>,
        str: Option<&CFString>,
        range: CFRange,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithSubstring(
                alloc: Option<&CFAllocator>,
                str: Option<&CFString>,
                range: CFRange,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringCreateWithSubstring(alloc, str, range) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CFStringCreateCopy")]
    #[inline]
    pub fn new_copy(
        alloc: Option<&CFAllocator>,
        the_string: Option<&CFString>,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateCopy(
                alloc: Option<&CFAllocator>,
                the_string: Option<&CFString>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringCreateCopy(alloc, the_string) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFMutableString {
    #[doc(alias = "CFStringCreateMutable")]
    #[inline]
    pub fn new(
        alloc: Option<&CFAllocator>,
        max_length: CFIndex,
    ) -> Option<CFRetained<CFMutableString>> {
        extern "C-unwind" {
            fn CFStringCreateMutable(
                alloc: Option<&CFAllocator>,
                max_length: CFIndex,
            ) -> Option<NonNull<CFMutableString>>;
        }
        let ret = unsafe { CFStringCreateMutable(alloc, max_length) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CFStringCreateMutableCopy")]
    #[inline]
    pub fn new_copy(
        alloc: Option<&CFAllocator>,
        max_length: CFIndex,
        the_string: Option<&CFString>,
    ) -> Option<CFRetained<CFMutableString>> {
        extern "C-unwind" {
            fn CFStringCreateMutableCopy(
                alloc: Option<&CFAllocator>,
                max_length: CFIndex,
                the_string: Option<&CFString>,
            ) -> Option<NonNull<CFMutableString>>;
        }
        let ret = unsafe { CFStringCreateMutableCopy(alloc, max_length, the_string) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `chars` must be a valid pointer.
    /// - `external_characters_allocator` might not allow `None`.
    #[doc(alias = "CFStringCreateMutableWithExternalCharactersNoCopy")]
    #[inline]
    pub unsafe fn with_external_characters_no_copy(
        alloc: Option<&CFAllocator>,
        chars: *mut UniChar,
        num_chars: CFIndex,
        capacity: CFIndex,
        external_characters_allocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFMutableString>> {
        extern "C-unwind" {
            fn CFStringCreateMutableWithExternalCharactersNoCopy(
                alloc: Option<&CFAllocator>,
                chars: *mut UniChar,
                num_chars: CFIndex,
                capacity: CFIndex,
                external_characters_allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFMutableString>>;
        }
        let ret = unsafe {
            CFStringCreateMutableWithExternalCharactersNoCopy(
                alloc,
                chars,
                num_chars,
                capacity,
                external_characters_allocator,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFString {
    /// * Basic accessors for the contents **
    #[doc(alias = "CFStringGetLength")]
    #[inline]
    pub fn length(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFStringGetLength(the_string: &CFString) -> CFIndex;
        }
        unsafe { CFStringGetLength(self) }
    }

    #[doc(alias = "CFStringGetCharacterAtIndex")]
    #[inline]
    pub unsafe fn character_at_index(&self, idx: CFIndex) -> UniChar {
        extern "C-unwind" {
            fn CFStringGetCharacterAtIndex(the_string: &CFString, idx: CFIndex) -> UniChar;
        }
        unsafe { CFStringGetCharacterAtIndex(self, idx) }
    }

    /// # Safety
    ///
    /// `buffer` must be a valid pointer.
    #[doc(alias = "CFStringGetCharacters")]
    #[inline]
    pub unsafe fn characters(&self, range: CFRange, buffer: *mut UniChar) {
        extern "C-unwind" {
            fn CFStringGetCharacters(the_string: &CFString, range: CFRange, buffer: *mut UniChar);
        }
        unsafe { CFStringGetCharacters(self, range, buffer) }
    }

    /// # Safety
    ///
    /// `buffer` must be a valid pointer.
    #[doc(alias = "CFStringGetPascalString")]
    #[inline]
    pub unsafe fn pascal_string(
        &self,
        buffer: StringPtr,
        buffer_size: CFIndex,
        encoding: CFStringEncoding,
    ) -> bool {
        extern "C-unwind" {
            fn CFStringGetPascalString(
                the_string: &CFString,
                buffer: StringPtr,
                buffer_size: CFIndex,
                encoding: CFStringEncoding,
            ) -> Boolean;
        }
        let ret = unsafe { CFStringGetPascalString(self, buffer, buffer_size, encoding) };
        ret != 0
    }

    /// # Safety
    ///
    /// `buffer` must be a valid pointer.
    #[doc(alias = "CFStringGetCString")]
    #[inline]
    pub unsafe fn c_string(
        &self,
        buffer: *mut c_char,
        buffer_size: CFIndex,
        encoding: CFStringEncoding,
    ) -> bool {
        extern "C-unwind" {
            fn CFStringGetCString(
                the_string: &CFString,
                buffer: *mut c_char,
                buffer_size: CFIndex,
                encoding: CFStringEncoding,
            ) -> Boolean;
        }
        let ret = unsafe { CFStringGetCString(self, buffer, buffer_size, encoding) };
        ret != 0
    }

    #[doc(alias = "CFStringGetPascalStringPtr")]
    #[inline]
    pub fn pascal_string_ptr(&self, encoding: CFStringEncoding) -> ConstStringPtr {
        extern "C-unwind" {
            fn CFStringGetPascalStringPtr(
                the_string: &CFString,
                encoding: CFStringEncoding,
            ) -> ConstStringPtr;
        }
        unsafe { CFStringGetPascalStringPtr(self, encoding) }
    }

    #[doc(alias = "CFStringGetCStringPtr")]
    #[inline]
    pub fn c_string_ptr(&self, encoding: CFStringEncoding) -> *const c_char {
        extern "C-unwind" {
            fn CFStringGetCStringPtr(
                the_string: &CFString,
                encoding: CFStringEncoding,
            ) -> *const c_char;
        }
        unsafe { CFStringGetCStringPtr(self, encoding) }
    }

    #[doc(alias = "CFStringGetCharactersPtr")]
    #[inline]
    pub fn characters_ptr(&self) -> *const UniChar {
        extern "C-unwind" {
            fn CFStringGetCharactersPtr(the_string: &CFString) -> *const UniChar;
        }
        unsafe { CFStringGetCharactersPtr(self) }
    }

    /// # Safety
    ///
    /// - `buffer` must be a valid pointer.
    /// - `used_buf_len` must be a valid pointer.
    #[doc(alias = "CFStringGetBytes")]
    #[inline]
    pub unsafe fn bytes(
        &self,
        range: CFRange,
        encoding: CFStringEncoding,
        loss_byte: u8,
        is_external_representation: bool,
        buffer: *mut u8,
        max_buf_len: CFIndex,
        used_buf_len: *mut CFIndex,
    ) -> CFIndex {
        extern "C-unwind" {
            fn CFStringGetBytes(
                the_string: &CFString,
                range: CFRange,
                encoding: CFStringEncoding,
                loss_byte: u8,
                is_external_representation: Boolean,
                buffer: *mut u8,
                max_buf_len: CFIndex,
                used_buf_len: *mut CFIndex,
            ) -> CFIndex;
        }
        unsafe {
            CFStringGetBytes(
                self,
                range,
                encoding,
                loss_byte,
                is_external_representation as _,
                buffer,
                max_buf_len,
                used_buf_len,
            )
        }
    }

    #[doc(alias = "CFStringCreateFromExternalRepresentation")]
    #[cfg(feature = "CFData")]
    #[inline]
    pub fn from_external_representation(
        alloc: Option<&CFAllocator>,
        data: Option<&CFData>,
        encoding: CFStringEncoding,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateFromExternalRepresentation(
                alloc: Option<&CFAllocator>,
                data: Option<&CFData>,
                encoding: CFStringEncoding,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringCreateFromExternalRepresentation(alloc, data, encoding) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CFStringCreateExternalRepresentation")]
    #[cfg(feature = "CFData")]
    #[inline]
    pub fn new_external_representation(
        alloc: Option<&CFAllocator>,
        the_string: Option<&CFString>,
        encoding: CFStringEncoding,
        loss_byte: u8,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn CFStringCreateExternalRepresentation(
                alloc: Option<&CFAllocator>,
                the_string: Option<&CFString>,
                encoding: CFStringEncoding,
                loss_byte: u8,
            ) -> Option<NonNull<CFData>>;
        }
        let ret =
            unsafe { CFStringCreateExternalRepresentation(alloc, the_string, encoding, loss_byte) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CFStringGetSmallestEncoding")]
    #[inline]
    pub fn smallest_encoding(&self) -> CFStringEncoding {
        extern "C-unwind" {
            fn CFStringGetSmallestEncoding(the_string: &CFString) -> CFStringEncoding;
        }
        unsafe { CFStringGetSmallestEncoding(self) }
    }

    #[doc(alias = "CFStringGetFastestEncoding")]
    #[inline]
    pub fn fastest_encoding(&self) -> CFStringEncoding {
        extern "C-unwind" {
            fn CFStringGetFastestEncoding(the_string: &CFString) -> CFStringEncoding;
        }
        unsafe { CFStringGetFastestEncoding(self) }
    }

    #[doc(alias = "CFStringGetSystemEncoding")]
    #[inline]
    pub fn system_encoding() -> CFStringEncoding {
        extern "C-unwind" {
            fn CFStringGetSystemEncoding() -> CFStringEncoding;
        }
        unsafe { CFStringGetSystemEncoding() }
    }

    #[doc(alias = "CFStringGetMaximumSizeForEncoding")]
    #[inline]
    pub fn maximum_size_for_encoding(length: CFIndex, encoding: CFStringEncoding) -> CFIndex {
        extern "C-unwind" {
            fn CFStringGetMaximumSizeForEncoding(
                length: CFIndex,
                encoding: CFStringEncoding,
            ) -> CFIndex;
        }
        unsafe { CFStringGetMaximumSizeForEncoding(length, encoding) }
    }

    /// * FileSystem path conversion functions **
    ///
    /// # Safety
    ///
    /// `buffer` must be a valid pointer.
    #[doc(alias = "CFStringGetFileSystemRepresentation")]
    #[inline]
    pub unsafe fn file_system_representation(
        &self,
        buffer: *mut c_char,
        max_buf_len: CFIndex,
    ) -> bool {
        extern "C-unwind" {
            fn CFStringGetFileSystemRepresentation(
                string: &CFString,
                buffer: *mut c_char,
                max_buf_len: CFIndex,
            ) -> Boolean;
        }
        let ret = unsafe { CFStringGetFileSystemRepresentation(self, buffer, max_buf_len) };
        ret != 0
    }

    #[doc(alias = "CFStringGetMaximumSizeOfFileSystemRepresentation")]
    #[inline]
    pub fn maximum_size_of_file_system_representation(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFStringGetMaximumSizeOfFileSystemRepresentation(string: &CFString) -> CFIndex;
        }
        unsafe { CFStringGetMaximumSizeOfFileSystemRepresentation(self) }
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `buffer` must be a valid pointer.
    #[doc(alias = "CFStringCreateWithFileSystemRepresentation")]
    #[inline]
    pub unsafe fn with_file_system_representation(
        alloc: Option<&CFAllocator>,
        buffer: *const c_char,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateWithFileSystemRepresentation(
                alloc: Option<&CFAllocator>,
                buffer: *const c_char,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringCreateWithFileSystemRepresentation(alloc, buffer) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfstringcompareflags?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFStringCompareFlags(pub CFOptionFlags);
bitflags::bitflags! {
    impl CFStringCompareFlags: CFOptionFlags {
        #[doc(alias = "kCFCompareCaseInsensitive")]
        const CompareCaseInsensitive = 1;
        #[doc(alias = "kCFCompareBackwards")]
        const CompareBackwards = 4;
        #[doc(alias = "kCFCompareAnchored")]
        const CompareAnchored = 8;
        #[doc(alias = "kCFCompareNonliteral")]
        const CompareNonliteral = 16;
        #[doc(alias = "kCFCompareLocalized")]
        const CompareLocalized = 32;
        #[doc(alias = "kCFCompareNumerically")]
        const CompareNumerically = 64;
        #[doc(alias = "kCFCompareDiacriticInsensitive")]
        const CompareDiacriticInsensitive = 128;
        #[doc(alias = "kCFCompareWidthInsensitive")]
        const CompareWidthInsensitive = 256;
        #[doc(alias = "kCFCompareForcedOrdering")]
        const CompareForcedOrdering = 512;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStringCompareFlags {
    const ENCODING: Encoding = CFOptionFlags::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStringCompareFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CFString {
    /// # Safety
    ///
    /// - `the_string2` might not allow `None`.
    /// - `locale` might not allow `None`.
    #[doc(alias = "CFStringCompareWithOptionsAndLocale")]
    #[cfg(feature = "CFLocale")]
    #[inline]
    pub unsafe fn compare_with_options_and_locale(
        &self,
        the_string2: Option<&CFString>,
        range_to_compare: CFRange,
        compare_options: CFStringCompareFlags,
        locale: Option<&CFLocale>,
    ) -> CFComparisonResult {
        extern "C-unwind" {
            fn CFStringCompareWithOptionsAndLocale(
                the_string1: &CFString,
                the_string2: Option<&CFString>,
                range_to_compare: CFRange,
                compare_options: CFStringCompareFlags,
                locale: Option<&CFLocale>,
            ) -> CFComparisonResult;
        }
        unsafe {
            CFStringCompareWithOptionsAndLocale(
                self,
                the_string2,
                range_to_compare,
                compare_options,
                locale,
            )
        }
    }

    /// # Safety
    ///
    /// `the_string2` might not allow `None`.
    #[doc(alias = "CFStringCompareWithOptions")]
    #[inline]
    pub unsafe fn compare_with_options(
        &self,
        the_string2: Option<&CFString>,
        range_to_compare: CFRange,
        compare_options: CFStringCompareFlags,
    ) -> CFComparisonResult {
        extern "C-unwind" {
            fn CFStringCompareWithOptions(
                the_string1: &CFString,
                the_string2: Option<&CFString>,
                range_to_compare: CFRange,
                compare_options: CFStringCompareFlags,
            ) -> CFComparisonResult;
        }
        unsafe { CFStringCompareWithOptions(self, the_string2, range_to_compare, compare_options) }
    }

    #[doc(alias = "CFStringCompare")]
    #[inline]
    pub fn compare(
        &self,
        the_string2: Option<&CFString>,
        compare_options: CFStringCompareFlags,
    ) -> CFComparisonResult {
        extern "C-unwind" {
            fn CFStringCompare(
                the_string1: &CFString,
                the_string2: Option<&CFString>,
                compare_options: CFStringCompareFlags,
            ) -> CFComparisonResult;
        }
        unsafe { CFStringCompare(self, the_string2, compare_options) }
    }

    /// # Safety
    ///
    /// - `string_to_find` might not allow `None`.
    /// - `locale` might not allow `None`.
    /// - `result` must be a valid pointer.
    #[doc(alias = "CFStringFindWithOptionsAndLocale")]
    #[cfg(feature = "CFLocale")]
    #[inline]
    pub unsafe fn find_with_options_and_locale(
        &self,
        string_to_find: Option<&CFString>,
        range_to_search: CFRange,
        search_options: CFStringCompareFlags,
        locale: Option<&CFLocale>,
        result: *mut CFRange,
    ) -> bool {
        extern "C-unwind" {
            fn CFStringFindWithOptionsAndLocale(
                the_string: &CFString,
                string_to_find: Option<&CFString>,
                range_to_search: CFRange,
                search_options: CFStringCompareFlags,
                locale: Option<&CFLocale>,
                result: *mut CFRange,
            ) -> Boolean;
        }
        let ret = unsafe {
            CFStringFindWithOptionsAndLocale(
                self,
                string_to_find,
                range_to_search,
                search_options,
                locale,
                result,
            )
        };
        ret != 0
    }

    /// # Safety
    ///
    /// - `string_to_find` might not allow `None`.
    /// - `result` must be a valid pointer.
    #[doc(alias = "CFStringFindWithOptions")]
    #[inline]
    pub unsafe fn find_with_options(
        &self,
        string_to_find: Option<&CFString>,
        range_to_search: CFRange,
        search_options: CFStringCompareFlags,
        result: *mut CFRange,
    ) -> bool {
        extern "C-unwind" {
            fn CFStringFindWithOptions(
                the_string: &CFString,
                string_to_find: Option<&CFString>,
                range_to_search: CFRange,
                search_options: CFStringCompareFlags,
                result: *mut CFRange,
            ) -> Boolean;
        }
        let ret = unsafe {
            CFStringFindWithOptions(
                self,
                string_to_find,
                range_to_search,
                search_options,
                result,
            )
        };
        ret != 0
    }

    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `the_string` might not allow `None`.
    /// - `string_to_find` might not allow `None`.
    #[doc(alias = "CFStringCreateArrayWithFindResults")]
    #[cfg(feature = "CFArray")]
    #[inline]
    pub unsafe fn new_array_with_find_results(
        alloc: Option<&CFAllocator>,
        the_string: Option<&CFString>,
        string_to_find: Option<&CFString>,
        range_to_search: CFRange,
        compare_options: CFStringCompareFlags,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CFStringCreateArrayWithFindResults(
                alloc: Option<&CFAllocator>,
                the_string: Option<&CFString>,
                string_to_find: Option<&CFString>,
                range_to_search: CFRange,
                compare_options: CFStringCompareFlags,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe {
            CFStringCreateArrayWithFindResults(
                alloc,
                the_string,
                string_to_find,
                range_to_search,
                compare_options,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CFStringFind")]
    #[inline]
    pub fn find(
        &self,
        string_to_find: Option<&CFString>,
        compare_options: CFStringCompareFlags,
    ) -> CFRange {
        extern "C-unwind" {
            fn CFStringFind(
                the_string: &CFString,
                string_to_find: Option<&CFString>,
                compare_options: CFStringCompareFlags,
            ) -> CFRange;
        }
        unsafe { CFStringFind(self, string_to_find, compare_options) }
    }

    #[doc(alias = "CFStringHasPrefix")]
    #[inline]
    pub fn has_prefix(&self, prefix: Option<&CFString>) -> bool {
        extern "C-unwind" {
            fn CFStringHasPrefix(the_string: &CFString, prefix: Option<&CFString>) -> Boolean;
        }
        let ret = unsafe { CFStringHasPrefix(self, prefix) };
        ret != 0
    }

    #[doc(alias = "CFStringHasSuffix")]
    #[inline]
    pub fn has_suffix(&self, suffix: Option<&CFString>) -> bool {
        extern "C-unwind" {
            fn CFStringHasSuffix(the_string: &CFString, suffix: Option<&CFString>) -> Boolean;
        }
        let ret = unsafe { CFStringHasSuffix(self, suffix) };
        ret != 0
    }

    /// Returns the range of the composed character sequence at the specified index.
    ///
    /// Parameter `theString`: The CFString which is to be searched.  If this
    /// parameter is not a valid CFString, the behavior is
    /// undefined.
    ///
    /// Parameter `theIndex`: The index of the character contained in the
    /// composed character sequence.  If the index is
    /// outside the index space of the string (0 to N-1 inclusive,
    /// where N is the length of the string), the behavior is
    /// undefined.
    ///
    /// Returns: The range of the composed character sequence.
    #[doc(alias = "CFStringGetRangeOfComposedCharactersAtIndex")]
    #[inline]
    pub unsafe fn range_of_composed_characters_at_index(&self, the_index: CFIndex) -> CFRange {
        extern "C-unwind" {
            fn CFStringGetRangeOfComposedCharactersAtIndex(
                the_string: &CFString,
                the_index: CFIndex,
            ) -> CFRange;
        }
        unsafe { CFStringGetRangeOfComposedCharactersAtIndex(self, the_index) }
    }

    /// Query the range of the first character contained in the specified character set.
    ///
    /// Parameter `theString`: The CFString which is to be searched.  If this
    /// parameter is not a valid CFString, the behavior is
    /// undefined.
    ///
    /// Parameter `theSet`: The CFCharacterSet against which the membership
    /// of characters is checked.  If this parameter is not a valid
    /// CFCharacterSet, the behavior is undefined.
    ///
    /// Parameter `rangeToSearch`: The range of characters within the string to search. If
    /// the range location or end point (defined by the location
    /// plus length minus 1) are outside the index space of the
    /// string (0 to N-1 inclusive, where N is the length of the
    /// string), the behavior is undefined. If the range length is
    /// negative, the behavior is undefined. The range may be empty
    /// (length 0), in which case no search is performed.
    ///
    /// Parameter `searchOptions`: The bitwise-or'ed option flags to control
    /// the search behavior.  The supported options are
    /// kCFCompareBackwards andkCFCompareAnchored.
    /// If other option flags are specified, the behavior
    /// is undefined.
    ///
    /// Parameter `result`: The pointer to a CFRange supplied by the caller in
    /// which the search result is stored.  Note that the length
    /// of this range can be more than 1, if for instance the
    /// result is a composed character. If a pointer to an invalid
    /// memory is specified, the behavior is undefined.
    ///
    /// Returns: true, if at least a character which is a member of the character
    /// set is found and result is filled, otherwise, false.
    ///
    /// # Safety
    ///
    /// - `the_set` might not allow `None`.
    /// - `result` must be a valid pointer.
    #[doc(alias = "CFStringFindCharacterFromSet")]
    #[cfg(feature = "CFCharacterSet")]
    #[inline]
    pub unsafe fn find_character_from_set(
        &self,
        the_set: Option<&CFCharacterSet>,
        range_to_search: CFRange,
        search_options: CFStringCompareFlags,
        result: *mut CFRange,
    ) -> bool {
        extern "C-unwind" {
            fn CFStringFindCharacterFromSet(
                the_string: &CFString,
                the_set: Option<&CFCharacterSet>,
                range_to_search: CFRange,
                search_options: CFStringCompareFlags,
                result: *mut CFRange,
            ) -> Boolean;
        }
        let ret = unsafe {
            CFStringFindCharacterFromSet(self, the_set, range_to_search, search_options, result)
        };
        ret != 0
    }

    /// # Safety
    ///
    /// - `line_begin_index` must be a valid pointer.
    /// - `line_end_index` must be a valid pointer.
    /// - `contents_end_index` must be a valid pointer.
    #[doc(alias = "CFStringGetLineBounds")]
    #[inline]
    pub unsafe fn line_bounds(
        &self,
        range: CFRange,
        line_begin_index: *mut CFIndex,
        line_end_index: *mut CFIndex,
        contents_end_index: *mut CFIndex,
    ) {
        extern "C-unwind" {
            fn CFStringGetLineBounds(
                the_string: &CFString,
                range: CFRange,
                line_begin_index: *mut CFIndex,
                line_end_index: *mut CFIndex,
                contents_end_index: *mut CFIndex,
            );
        }
        unsafe {
            CFStringGetLineBounds(
                self,
                range,
                line_begin_index,
                line_end_index,
                contents_end_index,
            )
        }
    }

    /// # Safety
    ///
    /// - `par_begin_index` must be a valid pointer.
    /// - `par_end_index` must be a valid pointer.
    /// - `contents_end_index` must be a valid pointer.
    #[doc(alias = "CFStringGetParagraphBounds")]
    #[inline]
    pub unsafe fn paragraph_bounds(
        &self,
        range: CFRange,
        par_begin_index: *mut CFIndex,
        par_end_index: *mut CFIndex,
        contents_end_index: *mut CFIndex,
    ) {
        extern "C-unwind" {
            fn CFStringGetParagraphBounds(
                string: &CFString,
                range: CFRange,
                par_begin_index: *mut CFIndex,
                par_end_index: *mut CFIndex,
                contents_end_index: *mut CFIndex,
            );
        }
        unsafe {
            CFStringGetParagraphBounds(
                self,
                range,
                par_begin_index,
                par_end_index,
                contents_end_index,
            )
        }
    }

    /// Retrieve the first potential hyphenation location found before the specified location.
    ///
    /// Parameter `string`: The CFString which is to be hyphenated.  If this
    /// parameter is not a valid CFString, the behavior is
    /// undefined.
    ///
    /// Parameter `location`: An index in the string.  If a valid hyphen index is returned, it
    /// will be before this index.
    ///
    /// Parameter `limitRange`: The range of characters within the string to search. If
    /// the range location or end point (defined by the location
    /// plus length minus 1) are outside the index space of the
    /// string (0 to N-1 inclusive, where N is the length of the
    /// string), the behavior is undefined. If the range length is
    /// negative, the behavior is undefined. The range may be empty
    /// (length 0), in which case no hyphen location is generated.
    ///
    /// Parameter `options`: Reserved for future use.
    ///
    /// Parameter `locale`: Specifies which language's hyphenation conventions to use.
    /// This must be a valid locale.  Hyphenation data is not available
    /// for all locales.  You can use CFStringIsHyphenationAvailableForLocale
    /// to test for availability of hyphenation data.
    ///
    /// Parameter `character`: The suggested hyphen character to insert.  Pass NULL if you
    /// do not need this information.
    ///
    /// Returns: an index in the string where it is appropriate to insert a hyphen, if
    /// one exists; else kCFNotFound
    ///
    /// # Safety
    ///
    /// - `locale` might not allow `None`.
    /// - `character` must be a valid pointer.
    #[doc(alias = "CFStringGetHyphenationLocationBeforeIndex")]
    #[cfg(feature = "CFLocale")]
    #[inline]
    pub unsafe fn hyphenation_location_before_index(
        &self,
        location: CFIndex,
        limit_range: CFRange,
        options: CFOptionFlags,
        locale: Option<&CFLocale>,
        character: *mut UTF32Char,
    ) -> CFIndex {
        extern "C-unwind" {
            fn CFStringGetHyphenationLocationBeforeIndex(
                string: &CFString,
                location: CFIndex,
                limit_range: CFRange,
                options: CFOptionFlags,
                locale: Option<&CFLocale>,
                character: *mut UTF32Char,
            ) -> CFIndex;
        }
        unsafe {
            CFStringGetHyphenationLocationBeforeIndex(
                self,
                location,
                limit_range,
                options,
                locale,
                character,
            )
        }
    }

    #[doc(alias = "CFStringIsHyphenationAvailableForLocale")]
    #[cfg(feature = "CFLocale")]
    #[inline]
    pub fn is_hyphenation_available_for_locale(locale: Option<&CFLocale>) -> bool {
        extern "C-unwind" {
            fn CFStringIsHyphenationAvailableForLocale(locale: Option<&CFLocale>) -> Boolean;
        }
        let ret = unsafe { CFStringIsHyphenationAvailableForLocale(locale) };
        ret != 0
    }

    /// * Exploding and joining strings with a separator string **
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `the_array` generic must be of the correct type.
    /// - `the_array` might not allow `None`.
    /// - `separator_string` might not allow `None`.
    #[doc(alias = "CFStringCreateByCombiningStrings")]
    #[cfg(feature = "CFArray")]
    #[inline]
    pub unsafe fn new_by_combining_strings(
        alloc: Option<&CFAllocator>,
        the_array: Option<&CFArray>,
        separator_string: Option<&CFString>,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringCreateByCombiningStrings(
                alloc: Option<&CFAllocator>,
                the_array: Option<&CFArray>,
                separator_string: Option<&CFString>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringCreateByCombiningStrings(alloc, the_array, separator_string) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CFStringCreateArrayBySeparatingStrings")]
    #[cfg(feature = "CFArray")]
    #[inline]
    pub fn new_array_by_separating_strings(
        alloc: Option<&CFAllocator>,
        the_string: Option<&CFString>,
        separator_string: Option<&CFString>,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CFStringCreateArrayBySeparatingStrings(
                alloc: Option<&CFAllocator>,
                the_string: Option<&CFString>,
                separator_string: Option<&CFString>,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret =
            unsafe { CFStringCreateArrayBySeparatingStrings(alloc, the_string, separator_string) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// * Parsing non-localized numbers from strings **
    #[doc(alias = "CFStringGetIntValue")]
    #[inline]
    pub fn int_value(&self) -> i32 {
        extern "C-unwind" {
            fn CFStringGetIntValue(str: &CFString) -> i32;
        }
        unsafe { CFStringGetIntValue(self) }
    }

    #[doc(alias = "CFStringGetDoubleValue")]
    #[inline]
    pub fn double_value(&self) -> c_double {
        extern "C-unwind" {
            fn CFStringGetDoubleValue(str: &CFString) -> c_double;
        }
        unsafe { CFStringGetDoubleValue(self) }
    }
}

impl CFMutableString {
    /// * MutableString functions **
    #[doc(alias = "CFStringAppend")]
    #[inline]
    pub fn append(the_string: Option<&CFMutableString>, appended_string: Option<&CFString>) {
        extern "C-unwind" {
            fn CFStringAppend(
                the_string: Option<&CFMutableString>,
                appended_string: Option<&CFString>,
            );
        }
        unsafe { CFStringAppend(the_string, appended_string) }
    }

    /// # Safety
    ///
    /// - `the_string` might not allow `None`.
    /// - `chars` must be a valid pointer.
    #[doc(alias = "CFStringAppendCharacters")]
    #[inline]
    pub unsafe fn append_characters(
        the_string: Option<&CFMutableString>,
        chars: *const UniChar,
        num_chars: CFIndex,
    ) {
        extern "C-unwind" {
            fn CFStringAppendCharacters(
                the_string: Option<&CFMutableString>,
                chars: *const UniChar,
                num_chars: CFIndex,
            );
        }
        unsafe { CFStringAppendCharacters(the_string, chars, num_chars) }
    }

    /// # Safety
    ///
    /// - `the_string` might not allow `None`.
    /// - `p_str` must be a valid pointer.
    #[doc(alias = "CFStringAppendPascalString")]
    #[inline]
    pub unsafe fn append_pascal_string(
        the_string: Option<&CFMutableString>,
        p_str: ConstStr255Param,
        encoding: CFStringEncoding,
    ) {
        extern "C-unwind" {
            fn CFStringAppendPascalString(
                the_string: Option<&CFMutableString>,
                p_str: ConstStr255Param,
                encoding: CFStringEncoding,
            );
        }
        unsafe { CFStringAppendPascalString(the_string, p_str, encoding) }
    }

    /// # Safety
    ///
    /// - `the_string` might not allow `None`.
    /// - `c_str` must be a valid pointer.
    #[doc(alias = "CFStringAppendCString")]
    #[inline]
    pub unsafe fn append_c_string(
        the_string: Option<&CFMutableString>,
        c_str: *const c_char,
        encoding: CFStringEncoding,
    ) {
        extern "C-unwind" {
            fn CFStringAppendCString(
                the_string: Option<&CFMutableString>,
                c_str: *const c_char,
                encoding: CFStringEncoding,
            );
        }
        unsafe { CFStringAppendCString(the_string, c_str, encoding) }
    }

    /// # Safety
    ///
    /// - `str` might not allow `None`.
    /// - `inserted_str` might not allow `None`.
    #[doc(alias = "CFStringInsert")]
    #[inline]
    pub unsafe fn insert(
        str: Option<&CFMutableString>,
        idx: CFIndex,
        inserted_str: Option<&CFString>,
    ) {
        extern "C-unwind" {
            fn CFStringInsert(
                str: Option<&CFMutableString>,
                idx: CFIndex,
                inserted_str: Option<&CFString>,
            );
        }
        unsafe { CFStringInsert(str, idx, inserted_str) }
    }

    /// # Safety
    ///
    /// `the_string` might not allow `None`.
    #[doc(alias = "CFStringDelete")]
    #[inline]
    pub unsafe fn delete(the_string: Option<&CFMutableString>, range: CFRange) {
        extern "C-unwind" {
            fn CFStringDelete(the_string: Option<&CFMutableString>, range: CFRange);
        }
        unsafe { CFStringDelete(the_string, range) }
    }

    /// # Safety
    ///
    /// - `the_string` might not allow `None`.
    /// - `replacement` might not allow `None`.
    #[doc(alias = "CFStringReplace")]
    #[inline]
    pub unsafe fn replace(
        the_string: Option<&CFMutableString>,
        range: CFRange,
        replacement: Option<&CFString>,
    ) {
        extern "C-unwind" {
            fn CFStringReplace(
                the_string: Option<&CFMutableString>,
                range: CFRange,
                replacement: Option<&CFString>,
            );
        }
        unsafe { CFStringReplace(the_string, range, replacement) }
    }

    #[doc(alias = "CFStringReplaceAll")]
    #[inline]
    pub fn replace_all(the_string: Option<&CFMutableString>, replacement: Option<&CFString>) {
        extern "C-unwind" {
            fn CFStringReplaceAll(
                the_string: Option<&CFMutableString>,
                replacement: Option<&CFString>,
            );
        }
        unsafe { CFStringReplaceAll(the_string, replacement) }
    }

    /// # Safety
    ///
    /// - `the_string` might not allow `None`.
    /// - `string_to_find` might not allow `None`.
    /// - `replacement_string` might not allow `None`.
    #[doc(alias = "CFStringFindAndReplace")]
    #[inline]
    pub unsafe fn find_and_replace(
        the_string: Option<&CFMutableString>,
        string_to_find: Option<&CFString>,
        replacement_string: Option<&CFString>,
        range_to_search: CFRange,
        compare_options: CFStringCompareFlags,
    ) -> CFIndex {
        extern "C-unwind" {
            fn CFStringFindAndReplace(
                the_string: Option<&CFMutableString>,
                string_to_find: Option<&CFString>,
                replacement_string: Option<&CFString>,
                range_to_search: CFRange,
                compare_options: CFStringCompareFlags,
            ) -> CFIndex;
        }
        unsafe {
            CFStringFindAndReplace(
                the_string,
                string_to_find,
                replacement_string,
                range_to_search,
                compare_options,
            )
        }
    }

    /// # Safety
    ///
    /// - `the_string` might not allow `None`.
    /// - `chars` must be a valid pointer.
    #[doc(alias = "CFStringSetExternalCharactersNoCopy")]
    #[inline]
    pub unsafe fn set_external_characters_no_copy(
        the_string: Option<&CFMutableString>,
        chars: *mut UniChar,
        length: CFIndex,
        capacity: CFIndex,
    ) {
        extern "C-unwind" {
            fn CFStringSetExternalCharactersNoCopy(
                the_string: Option<&CFMutableString>,
                chars: *mut UniChar,
                length: CFIndex,
                capacity: CFIndex,
            );
        }
        unsafe { CFStringSetExternalCharactersNoCopy(the_string, chars, length, capacity) }
    }

    /// # Safety
    ///
    /// - `the_string` might not allow `None`.
    /// - `pad_string` might not allow `None`.
    #[doc(alias = "CFStringPad")]
    #[inline]
    pub unsafe fn pad(
        the_string: Option<&CFMutableString>,
        pad_string: Option<&CFString>,
        length: CFIndex,
        index_into_pad: CFIndex,
    ) {
        extern "C-unwind" {
            fn CFStringPad(
                the_string: Option<&CFMutableString>,
                pad_string: Option<&CFString>,
                length: CFIndex,
                index_into_pad: CFIndex,
            );
        }
        unsafe { CFStringPad(the_string, pad_string, length, index_into_pad) }
    }

    #[doc(alias = "CFStringTrim")]
    #[inline]
    pub fn trim(the_string: Option<&CFMutableString>, trim_string: Option<&CFString>) {
        extern "C-unwind" {
            fn CFStringTrim(the_string: Option<&CFMutableString>, trim_string: Option<&CFString>);
        }
        unsafe { CFStringTrim(the_string, trim_string) }
    }

    #[doc(alias = "CFStringTrimWhitespace")]
    #[inline]
    pub fn trim_whitespace(the_string: Option<&CFMutableString>) {
        extern "C-unwind" {
            fn CFStringTrimWhitespace(the_string: Option<&CFMutableString>);
        }
        unsafe { CFStringTrimWhitespace(the_string) }
    }

    #[doc(alias = "CFStringLowercase")]
    #[cfg(feature = "CFLocale")]
    #[inline]
    pub fn lowercase(the_string: Option<&CFMutableString>, locale: Option<&CFLocale>) {
        extern "C-unwind" {
            fn CFStringLowercase(the_string: Option<&CFMutableString>, locale: Option<&CFLocale>);
        }
        unsafe { CFStringLowercase(the_string, locale) }
    }

    #[doc(alias = "CFStringUppercase")]
    #[cfg(feature = "CFLocale")]
    #[inline]
    pub fn uppercase(the_string: Option<&CFMutableString>, locale: Option<&CFLocale>) {
        extern "C-unwind" {
            fn CFStringUppercase(the_string: Option<&CFMutableString>, locale: Option<&CFLocale>);
        }
        unsafe { CFStringUppercase(the_string, locale) }
    }

    #[doc(alias = "CFStringCapitalize")]
    #[cfg(feature = "CFLocale")]
    #[inline]
    pub fn capitalize(the_string: Option<&CFMutableString>, locale: Option<&CFLocale>) {
        extern "C-unwind" {
            fn CFStringCapitalize(the_string: Option<&CFMutableString>, locale: Option<&CFLocale>);
        }
        unsafe { CFStringCapitalize(the_string, locale) }
    }
}

/// This is the type of Unicode normalization forms as described in
/// Unicode Technical Report #15. To normalize for use with file
/// system calls, use CFStringGetFileSystemRepresentation().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfstringnormalizationform?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFStringNormalizationForm(pub CFIndex);
impl CFStringNormalizationForm {
    #[doc(alias = "kCFStringNormalizationFormD")]
    pub const D: Self = Self(0);
    #[doc(alias = "kCFStringNormalizationFormKD")]
    pub const KD: Self = Self(1);
    #[doc(alias = "kCFStringNormalizationFormC")]
    pub const C: Self = Self(2);
    #[doc(alias = "kCFStringNormalizationFormKC")]
    pub const KC: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStringNormalizationForm {
    const ENCODING: Encoding = CFIndex::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStringNormalizationForm {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CFMutableString {
    /// Normalizes the string into the specified form as described in
    /// Unicode Technical Report #15.
    ///
    /// Parameter `theString`: The string which is to be normalized.  If this
    /// parameter is not a valid mutable CFString, the behavior is
    /// undefined.
    ///
    /// Parameter `theForm`: The form into which the string is to be normalized.
    /// If this parameter is not a valid CFStringNormalizationForm value,
    /// the behavior is undefined.
    ///
    /// # Safety
    ///
    /// `the_string` might not allow `None`.
    #[doc(alias = "CFStringNormalize")]
    #[inline]
    pub unsafe fn normalize(
        the_string: Option<&CFMutableString>,
        the_form: CFStringNormalizationForm,
    ) {
        extern "C-unwind" {
            fn CFStringNormalize(
                the_string: Option<&CFMutableString>,
                the_form: CFStringNormalizationForm,
            );
        }
        unsafe { CFStringNormalize(the_string, the_form) }
    }

    /// Folds the string into the form specified by the flags.
    /// Character foldings are operations that convert any of a set of characters
    /// sharing similar semantics into a single representative from that set.
    /// This function can be used to preprocess strings that are to be compared,
    /// searched, or indexed.
    /// Note that folding does not include normalization, so it is necessary
    /// to use CFStringNormalize in addition to CFStringFold in order to obtain
    /// the effect of kCFCompareNonliteral.
    ///
    /// Parameter `theString`: The string which is to be folded.  If this parameter is not
    /// a valid mutable CFString, the behavior is undefined.
    ///
    /// Parameter `theFlags`: The equivalency flags which describes the character folding form.
    /// Only those flags containing the word "insensitive" are recognized here; other flags are ignored.
    /// Folding with kCFCompareCaseInsensitive removes case distinctions in accordance with the mapping
    /// specified by ftp://ftp.unicode.org/Public/UNIDATA/CaseFolding.txt.  Folding with
    /// kCFCompareDiacriticInsensitive removes distinctions of accents and other diacritics.  Folding
    /// with kCFCompareWidthInsensitive removes character width distinctions by mapping characters in
    /// the range U+FF00-U+FFEF to their ordinary equivalents.
    ///
    /// Parameter `theLocale`: The locale tailoring the character folding behavior. If NULL,
    /// it's considered to be the system locale returned from CFLocaleGetSystem().
    /// If non-NULL and not a valid CFLocale object, the behavior is undefined.
    #[doc(alias = "CFStringFold")]
    #[cfg(feature = "CFLocale")]
    #[inline]
    pub fn fold(
        the_string: Option<&CFMutableString>,
        the_flags: CFStringCompareFlags,
        the_locale: Option<&CFLocale>,
    ) {
        extern "C-unwind" {
            fn CFStringFold(
                the_string: Option<&CFMutableString>,
                the_flags: CFStringCompareFlags,
                the_locale: Option<&CFLocale>,
            );
        }
        unsafe { CFStringFold(the_string, the_flags, the_locale) }
    }

    /// # Safety
    ///
    /// - `string` might not allow `None`.
    /// - `range` must be a valid pointer.
    /// - `transform` might not allow `None`.
    #[doc(alias = "CFStringTransform")]
    #[inline]
    pub unsafe fn transform(
        string: Option<&CFMutableString>,
        range: *mut CFRange,
        transform: Option<&CFString>,
        reverse: bool,
    ) -> bool {
        extern "C-unwind" {
            fn CFStringTransform(
                string: Option<&CFMutableString>,
                range: *mut CFRange,
                transform: Option<&CFString>,
                reverse: Boolean,
            ) -> Boolean;
        }
        let ret = unsafe { CFStringTransform(string, range, transform, reverse as _) };
        ret != 0
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformstripcombiningmarks?language=objc)
    pub static kCFStringTransformStripCombiningMarks: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformtolatin?language=objc)
    pub static kCFStringTransformToLatin: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformfullwidthhalfwidth?language=objc)
    pub static kCFStringTransformFullwidthHalfwidth: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinkatakana?language=objc)
    pub static kCFStringTransformLatinKatakana: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinhiragana?language=objc)
    pub static kCFStringTransformLatinHiragana: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformhiraganakatakana?language=objc)
    pub static kCFStringTransformHiraganaKatakana: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformmandarinlatin?language=objc)
    pub static kCFStringTransformMandarinLatin: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinhangul?language=objc)
    pub static kCFStringTransformLatinHangul: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinarabic?language=objc)
    pub static kCFStringTransformLatinArabic: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinhebrew?language=objc)
    pub static kCFStringTransformLatinHebrew: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatinthai?language=objc)
    pub static kCFStringTransformLatinThai: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatincyrillic?language=objc)
    pub static kCFStringTransformLatinCyrillic: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformlatingreek?language=objc)
    pub static kCFStringTransformLatinGreek: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformtoxmlhex?language=objc)
    pub static kCFStringTransformToXMLHex: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformtounicodename?language=objc)
    pub static kCFStringTransformToUnicodeName: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/kcfstringtransformstripdiacritics?language=objc)
    pub static kCFStringTransformStripDiacritics: Option<&'static CFString>;
}

impl CFString {
    /// * General encoding related functionality **
    #[doc(alias = "CFStringIsEncodingAvailable")]
    #[inline]
    pub fn is_encoding_available(encoding: CFStringEncoding) -> bool {
        extern "C-unwind" {
            fn CFStringIsEncodingAvailable(encoding: CFStringEncoding) -> Boolean;
        }
        let ret = unsafe { CFStringIsEncodingAvailable(encoding) };
        ret != 0
    }

    #[doc(alias = "CFStringGetListOfAvailableEncodings")]
    #[inline]
    pub fn list_of_available_encodings() -> *const CFStringEncoding {
        extern "C-unwind" {
            fn CFStringGetListOfAvailableEncodings() -> *const CFStringEncoding;
        }
        unsafe { CFStringGetListOfAvailableEncodings() }
    }

    #[doc(alias = "CFStringGetNameOfEncoding")]
    #[inline]
    pub fn name_of_encoding(encoding: CFStringEncoding) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringGetNameOfEncoding(encoding: CFStringEncoding) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringGetNameOfEncoding(encoding) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CFStringConvertEncodingToNSStringEncoding")]
    #[inline]
    pub fn convert_encoding_to_ns_string_encoding(encoding: CFStringEncoding) -> c_ulong {
        extern "C-unwind" {
            fn CFStringConvertEncodingToNSStringEncoding(encoding: CFStringEncoding) -> c_ulong;
        }
        unsafe { CFStringConvertEncodingToNSStringEncoding(encoding) }
    }

    #[doc(alias = "CFStringConvertNSStringEncodingToEncoding")]
    #[inline]
    pub fn convert_ns_string_encoding_to_encoding(encoding: c_ulong) -> CFStringEncoding {
        extern "C-unwind" {
            fn CFStringConvertNSStringEncodingToEncoding(encoding: c_ulong) -> CFStringEncoding;
        }
        unsafe { CFStringConvertNSStringEncodingToEncoding(encoding) }
    }

    #[doc(alias = "CFStringConvertEncodingToWindowsCodepage")]
    #[inline]
    pub fn convert_encoding_to_windows_codepage(encoding: CFStringEncoding) -> u32 {
        extern "C-unwind" {
            fn CFStringConvertEncodingToWindowsCodepage(encoding: CFStringEncoding) -> u32;
        }
        unsafe { CFStringConvertEncodingToWindowsCodepage(encoding) }
    }

    #[doc(alias = "CFStringConvertWindowsCodepageToEncoding")]
    #[inline]
    pub fn convert_windows_codepage_to_encoding(codepage: u32) -> CFStringEncoding {
        extern "C-unwind" {
            fn CFStringConvertWindowsCodepageToEncoding(codepage: u32) -> CFStringEncoding;
        }
        unsafe { CFStringConvertWindowsCodepageToEncoding(codepage) }
    }

    #[doc(alias = "CFStringConvertIANACharSetNameToEncoding")]
    #[inline]
    pub fn convert_iana_char_set_name_to_encoding(&self) -> CFStringEncoding {
        extern "C-unwind" {
            fn CFStringConvertIANACharSetNameToEncoding(the_string: &CFString) -> CFStringEncoding;
        }
        unsafe { CFStringConvertIANACharSetNameToEncoding(self) }
    }

    #[doc(alias = "CFStringConvertEncodingToIANACharSetName")]
    #[inline]
    pub fn convert_encoding_to_iana_char_set_name(
        encoding: CFStringEncoding,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFStringConvertEncodingToIANACharSetName(
                encoding: CFStringEncoding,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFStringConvertEncodingToIANACharSetName(encoding) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CFStringGetMostCompatibleMacStringEncoding")]
    #[inline]
    pub fn most_compatible_mac_string_encoding(encoding: CFStringEncoding) -> CFStringEncoding {
        extern "C-unwind" {
            fn CFStringGetMostCompatibleMacStringEncoding(
                encoding: CFStringEncoding,
            ) -> CFStringEncoding;
        }
        unsafe { CFStringGetMostCompatibleMacStringEncoding(encoding) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/corefoundation/cfstringinlinebuffer?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFStringInlineBuffer {
    pub buffer: [UniChar; 64],
    pub theString: *const CFString,
    pub directUniCharBuffer: *const UniChar,
    pub directCStringBuffer: *const c_char,
    pub rangeToBuffer: CFRange,
    pub bufferedRangeStart: CFIndex,
    pub bufferedRangeEnd: CFIndex,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStringInlineBuffer {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <[UniChar; 64]>::ENCODING,
            <*const CFString>::ENCODING,
            <*const UniChar>::ENCODING,
            <*const c_char>::ENCODING,
            <CFRange>::ENCODING,
            <CFIndex>::ENCODING,
            <CFIndex>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStringInlineBuffer {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CFString {
    // TODO: pub fn CFStringInitInlineBuffer(str: &CFString,buf: *mut CFStringInlineBuffer,range: CFRange,);

    // TODO: pub fn CFStringGetCharacterFromInlineBuffer(buf: *mut CFStringInlineBuffer,idx: CFIndex,) -> UniChar;

    // TODO: pub fn CFStringIsSurrogateHighCharacter(character: UniChar,) -> Boolean;

    // TODO: pub fn CFStringIsSurrogateLowCharacter(character: UniChar,) -> Boolean;

    // TODO: pub fn CFStringGetLongCharacterForSurrogatePair(surrogate_high: UniChar,surrogate_low: UniChar,) -> UTF32Char;

    // TODO: pub fn CFStringGetSurrogatePairForLongCharacter(character: UTF32Char,surrogates: *mut UniChar,) -> Boolean;
}

#[inline]
pub extern "C-unwind" fn CFShow(obj: Option<&CFType>) {
    extern "C-unwind" {
        fn CFShow(obj: Option<&CFType>);
    }
    unsafe { CFShow(obj) }
}

#[inline]
pub extern "C-unwind" fn CFShowStr(str: Option<&CFString>) {
    extern "C-unwind" {
        fn CFShowStr(str: Option<&CFString>);
    }
    unsafe { CFShowStr(str) }
}

#[deprecated = "renamed to `CFString::with_pascal_string`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithPascalString(
    alloc: Option<&CFAllocator>,
    p_str: ConstStr255Param,
    encoding: CFStringEncoding,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithPascalString(
            alloc: Option<&CFAllocator>,
            p_str: ConstStr255Param,
            encoding: CFStringEncoding,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringCreateWithPascalString(alloc, p_str, encoding) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::with_c_string`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithCString(
    alloc: Option<&CFAllocator>,
    c_str: *const c_char,
    encoding: CFStringEncoding,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithCString(
            alloc: Option<&CFAllocator>,
            c_str: *const c_char,
            encoding: CFStringEncoding,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringCreateWithCString(alloc, c_str, encoding) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::with_bytes`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithBytes(
    alloc: Option<&CFAllocator>,
    bytes: *const u8,
    num_bytes: CFIndex,
    encoding: CFStringEncoding,
    is_external_representation: bool,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithBytes(
            alloc: Option<&CFAllocator>,
            bytes: *const u8,
            num_bytes: CFIndex,
            encoding: CFStringEncoding,
            is_external_representation: Boolean,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe {
        CFStringCreateWithBytes(
            alloc,
            bytes,
            num_bytes,
            encoding,
            is_external_representation as _,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::with_characters`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithCharacters(
    alloc: Option<&CFAllocator>,
    chars: *const UniChar,
    num_chars: CFIndex,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithCharacters(
            alloc: Option<&CFAllocator>,
            chars: *const UniChar,
            num_chars: CFIndex,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringCreateWithCharacters(alloc, chars, num_chars) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::with_pascal_string_no_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithPascalStringNoCopy(
    alloc: Option<&CFAllocator>,
    p_str: ConstStr255Param,
    encoding: CFStringEncoding,
    contents_deallocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithPascalStringNoCopy(
            alloc: Option<&CFAllocator>,
            p_str: ConstStr255Param,
            encoding: CFStringEncoding,
            contents_deallocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe {
        CFStringCreateWithPascalStringNoCopy(alloc, p_str, encoding, contents_deallocator)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::with_c_string_no_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithCStringNoCopy(
    alloc: Option<&CFAllocator>,
    c_str: *const c_char,
    encoding: CFStringEncoding,
    contents_deallocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithCStringNoCopy(
            alloc: Option<&CFAllocator>,
            c_str: *const c_char,
            encoding: CFStringEncoding,
            contents_deallocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret =
        unsafe { CFStringCreateWithCStringNoCopy(alloc, c_str, encoding, contents_deallocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::with_bytes_no_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithBytesNoCopy(
    alloc: Option<&CFAllocator>,
    bytes: *const u8,
    num_bytes: CFIndex,
    encoding: CFStringEncoding,
    is_external_representation: bool,
    contents_deallocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithBytesNoCopy(
            alloc: Option<&CFAllocator>,
            bytes: *const u8,
            num_bytes: CFIndex,
            encoding: CFStringEncoding,
            is_external_representation: Boolean,
            contents_deallocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe {
        CFStringCreateWithBytesNoCopy(
            alloc,
            bytes,
            num_bytes,
            encoding,
            is_external_representation as _,
            contents_deallocator,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::with_characters_no_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithCharactersNoCopy(
    alloc: Option<&CFAllocator>,
    chars: *const UniChar,
    num_chars: CFIndex,
    contents_deallocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithCharactersNoCopy(
            alloc: Option<&CFAllocator>,
            chars: *const UniChar,
            num_chars: CFIndex,
            contents_deallocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe {
        CFStringCreateWithCharactersNoCopy(alloc, chars, num_chars, contents_deallocator)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::with_substring`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithSubstring(
    alloc: Option<&CFAllocator>,
    str: Option<&CFString>,
    range: CFRange,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithSubstring(
            alloc: Option<&CFAllocator>,
            str: Option<&CFString>,
            range: CFRange,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringCreateWithSubstring(alloc, str, range) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::new_copy`"]
#[inline]
pub extern "C-unwind" fn CFStringCreateCopy(
    alloc: Option<&CFAllocator>,
    the_string: Option<&CFString>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateCopy(
            alloc: Option<&CFAllocator>,
            the_string: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringCreateCopy(alloc, the_string) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableString::new`"]
#[inline]
pub extern "C-unwind" fn CFStringCreateMutable(
    alloc: Option<&CFAllocator>,
    max_length: CFIndex,
) -> Option<CFRetained<CFMutableString>> {
    extern "C-unwind" {
        fn CFStringCreateMutable(
            alloc: Option<&CFAllocator>,
            max_length: CFIndex,
        ) -> Option<NonNull<CFMutableString>>;
    }
    let ret = unsafe { CFStringCreateMutable(alloc, max_length) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableString::new_copy`"]
#[inline]
pub extern "C-unwind" fn CFStringCreateMutableCopy(
    alloc: Option<&CFAllocator>,
    max_length: CFIndex,
    the_string: Option<&CFString>,
) -> Option<CFRetained<CFMutableString>> {
    extern "C-unwind" {
        fn CFStringCreateMutableCopy(
            alloc: Option<&CFAllocator>,
            max_length: CFIndex,
            the_string: Option<&CFString>,
        ) -> Option<NonNull<CFMutableString>>;
    }
    let ret = unsafe { CFStringCreateMutableCopy(alloc, max_length, the_string) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableString::with_external_characters_no_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateMutableWithExternalCharactersNoCopy(
    alloc: Option<&CFAllocator>,
    chars: *mut UniChar,
    num_chars: CFIndex,
    capacity: CFIndex,
    external_characters_allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFMutableString>> {
    extern "C-unwind" {
        fn CFStringCreateMutableWithExternalCharactersNoCopy(
            alloc: Option<&CFAllocator>,
            chars: *mut UniChar,
            num_chars: CFIndex,
            capacity: CFIndex,
            external_characters_allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFMutableString>>;
    }
    let ret = unsafe {
        CFStringCreateMutableWithExternalCharactersNoCopy(
            alloc,
            chars,
            num_chars,
            capacity,
            external_characters_allocator,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::length`"]
#[inline]
pub extern "C-unwind" fn CFStringGetLength(the_string: &CFString) -> CFIndex {
    extern "C-unwind" {
        fn CFStringGetLength(the_string: &CFString) -> CFIndex;
    }
    unsafe { CFStringGetLength(the_string) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFString::character_at_index`"]
    pub fn CFStringGetCharacterAtIndex(the_string: &CFString, idx: CFIndex) -> UniChar;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFString::characters`"]
    pub fn CFStringGetCharacters(the_string: &CFString, range: CFRange, buffer: *mut UniChar);
}

#[deprecated = "renamed to `CFString::pascal_string`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringGetPascalString(
    the_string: &CFString,
    buffer: StringPtr,
    buffer_size: CFIndex,
    encoding: CFStringEncoding,
) -> bool {
    extern "C-unwind" {
        fn CFStringGetPascalString(
            the_string: &CFString,
            buffer: StringPtr,
            buffer_size: CFIndex,
            encoding: CFStringEncoding,
        ) -> Boolean;
    }
    let ret = unsafe { CFStringGetPascalString(the_string, buffer, buffer_size, encoding) };
    ret != 0
}

#[deprecated = "renamed to `CFString::c_string`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringGetCString(
    the_string: &CFString,
    buffer: *mut c_char,
    buffer_size: CFIndex,
    encoding: CFStringEncoding,
) -> bool {
    extern "C-unwind" {
        fn CFStringGetCString(
            the_string: &CFString,
            buffer: *mut c_char,
            buffer_size: CFIndex,
            encoding: CFStringEncoding,
        ) -> Boolean;
    }
    let ret = unsafe { CFStringGetCString(the_string, buffer, buffer_size, encoding) };
    ret != 0
}

#[deprecated = "renamed to `CFString::pascal_string_ptr`"]
#[inline]
pub extern "C-unwind" fn CFStringGetPascalStringPtr(
    the_string: &CFString,
    encoding: CFStringEncoding,
) -> ConstStringPtr {
    extern "C-unwind" {
        fn CFStringGetPascalStringPtr(
            the_string: &CFString,
            encoding: CFStringEncoding,
        ) -> ConstStringPtr;
    }
    unsafe { CFStringGetPascalStringPtr(the_string, encoding) }
}

#[deprecated = "renamed to `CFString::c_string_ptr`"]
#[inline]
pub extern "C-unwind" fn CFStringGetCStringPtr(
    the_string: &CFString,
    encoding: CFStringEncoding,
) -> *const c_char {
    extern "C-unwind" {
        fn CFStringGetCStringPtr(
            the_string: &CFString,
            encoding: CFStringEncoding,
        ) -> *const c_char;
    }
    unsafe { CFStringGetCStringPtr(the_string, encoding) }
}

#[deprecated = "renamed to `CFString::characters_ptr`"]
#[inline]
pub extern "C-unwind" fn CFStringGetCharactersPtr(the_string: &CFString) -> *const UniChar {
    extern "C-unwind" {
        fn CFStringGetCharactersPtr(the_string: &CFString) -> *const UniChar;
    }
    unsafe { CFStringGetCharactersPtr(the_string) }
}

#[deprecated = "renamed to `CFString::bytes`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringGetBytes(
    the_string: &CFString,
    range: CFRange,
    encoding: CFStringEncoding,
    loss_byte: u8,
    is_external_representation: bool,
    buffer: *mut u8,
    max_buf_len: CFIndex,
    used_buf_len: *mut CFIndex,
) -> CFIndex {
    extern "C-unwind" {
        fn CFStringGetBytes(
            the_string: &CFString,
            range: CFRange,
            encoding: CFStringEncoding,
            loss_byte: u8,
            is_external_representation: Boolean,
            buffer: *mut u8,
            max_buf_len: CFIndex,
            used_buf_len: *mut CFIndex,
        ) -> CFIndex;
    }
    unsafe {
        CFStringGetBytes(
            the_string,
            range,
            encoding,
            loss_byte,
            is_external_representation as _,
            buffer,
            max_buf_len,
            used_buf_len,
        )
    }
}

#[cfg(feature = "CFData")]
#[deprecated = "renamed to `CFString::from_external_representation`"]
#[inline]
pub extern "C-unwind" fn CFStringCreateFromExternalRepresentation(
    alloc: Option<&CFAllocator>,
    data: Option<&CFData>,
    encoding: CFStringEncoding,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateFromExternalRepresentation(
            alloc: Option<&CFAllocator>,
            data: Option<&CFData>,
            encoding: CFStringEncoding,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringCreateFromExternalRepresentation(alloc, data, encoding) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFData")]
#[deprecated = "renamed to `CFString::new_external_representation`"]
#[inline]
pub extern "C-unwind" fn CFStringCreateExternalRepresentation(
    alloc: Option<&CFAllocator>,
    the_string: Option<&CFString>,
    encoding: CFStringEncoding,
    loss_byte: u8,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CFStringCreateExternalRepresentation(
            alloc: Option<&CFAllocator>,
            the_string: Option<&CFString>,
            encoding: CFStringEncoding,
            loss_byte: u8,
        ) -> Option<NonNull<CFData>>;
    }
    let ret =
        unsafe { CFStringCreateExternalRepresentation(alloc, the_string, encoding, loss_byte) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::smallest_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringGetSmallestEncoding(the_string: &CFString) -> CFStringEncoding {
    extern "C-unwind" {
        fn CFStringGetSmallestEncoding(the_string: &CFString) -> CFStringEncoding;
    }
    unsafe { CFStringGetSmallestEncoding(the_string) }
}

#[deprecated = "renamed to `CFString::fastest_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringGetFastestEncoding(the_string: &CFString) -> CFStringEncoding {
    extern "C-unwind" {
        fn CFStringGetFastestEncoding(the_string: &CFString) -> CFStringEncoding;
    }
    unsafe { CFStringGetFastestEncoding(the_string) }
}

#[deprecated = "renamed to `CFString::system_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringGetSystemEncoding() -> CFStringEncoding {
    extern "C-unwind" {
        fn CFStringGetSystemEncoding() -> CFStringEncoding;
    }
    unsafe { CFStringGetSystemEncoding() }
}

#[deprecated = "renamed to `CFString::maximum_size_for_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringGetMaximumSizeForEncoding(
    length: CFIndex,
    encoding: CFStringEncoding,
) -> CFIndex {
    extern "C-unwind" {
        fn CFStringGetMaximumSizeForEncoding(
            length: CFIndex,
            encoding: CFStringEncoding,
        ) -> CFIndex;
    }
    unsafe { CFStringGetMaximumSizeForEncoding(length, encoding) }
}

#[deprecated = "renamed to `CFString::file_system_representation`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringGetFileSystemRepresentation(
    string: &CFString,
    buffer: *mut c_char,
    max_buf_len: CFIndex,
) -> bool {
    extern "C-unwind" {
        fn CFStringGetFileSystemRepresentation(
            string: &CFString,
            buffer: *mut c_char,
            max_buf_len: CFIndex,
        ) -> Boolean;
    }
    let ret = unsafe { CFStringGetFileSystemRepresentation(string, buffer, max_buf_len) };
    ret != 0
}

#[deprecated = "renamed to `CFString::maximum_size_of_file_system_representation`"]
#[inline]
pub extern "C-unwind" fn CFStringGetMaximumSizeOfFileSystemRepresentation(
    string: &CFString,
) -> CFIndex {
    extern "C-unwind" {
        fn CFStringGetMaximumSizeOfFileSystemRepresentation(string: &CFString) -> CFIndex;
    }
    unsafe { CFStringGetMaximumSizeOfFileSystemRepresentation(string) }
}

#[deprecated = "renamed to `CFString::with_file_system_representation`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateWithFileSystemRepresentation(
    alloc: Option<&CFAllocator>,
    buffer: *const c_char,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateWithFileSystemRepresentation(
            alloc: Option<&CFAllocator>,
            buffer: *const c_char,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringCreateWithFileSystemRepresentation(alloc, buffer) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CFLocale")]
    #[deprecated = "renamed to `CFString::compare_with_options_and_locale`"]
    pub fn CFStringCompareWithOptionsAndLocale(
        the_string1: &CFString,
        the_string2: Option<&CFString>,
        range_to_compare: CFRange,
        compare_options: CFStringCompareFlags,
        locale: Option<&CFLocale>,
    ) -> CFComparisonResult;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFString::compare_with_options`"]
    pub fn CFStringCompareWithOptions(
        the_string1: &CFString,
        the_string2: Option<&CFString>,
        range_to_compare: CFRange,
        compare_options: CFStringCompareFlags,
    ) -> CFComparisonResult;
}

#[deprecated = "renamed to `CFString::compare`"]
#[inline]
pub extern "C-unwind" fn CFStringCompare(
    the_string1: &CFString,
    the_string2: Option<&CFString>,
    compare_options: CFStringCompareFlags,
) -> CFComparisonResult {
    extern "C-unwind" {
        fn CFStringCompare(
            the_string1: &CFString,
            the_string2: Option<&CFString>,
            compare_options: CFStringCompareFlags,
        ) -> CFComparisonResult;
    }
    unsafe { CFStringCompare(the_string1, the_string2, compare_options) }
}

#[cfg(feature = "CFLocale")]
#[deprecated = "renamed to `CFString::find_with_options_and_locale`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringFindWithOptionsAndLocale(
    the_string: &CFString,
    string_to_find: Option<&CFString>,
    range_to_search: CFRange,
    search_options: CFStringCompareFlags,
    locale: Option<&CFLocale>,
    result: *mut CFRange,
) -> bool {
    extern "C-unwind" {
        fn CFStringFindWithOptionsAndLocale(
            the_string: &CFString,
            string_to_find: Option<&CFString>,
            range_to_search: CFRange,
            search_options: CFStringCompareFlags,
            locale: Option<&CFLocale>,
            result: *mut CFRange,
        ) -> Boolean;
    }
    let ret = unsafe {
        CFStringFindWithOptionsAndLocale(
            the_string,
            string_to_find,
            range_to_search,
            search_options,
            locale,
            result,
        )
    };
    ret != 0
}

#[deprecated = "renamed to `CFString::find_with_options`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringFindWithOptions(
    the_string: &CFString,
    string_to_find: Option<&CFString>,
    range_to_search: CFRange,
    search_options: CFStringCompareFlags,
    result: *mut CFRange,
) -> bool {
    extern "C-unwind" {
        fn CFStringFindWithOptions(
            the_string: &CFString,
            string_to_find: Option<&CFString>,
            range_to_search: CFRange,
            search_options: CFStringCompareFlags,
            result: *mut CFRange,
        ) -> Boolean;
    }
    let ret = unsafe {
        CFStringFindWithOptions(
            the_string,
            string_to_find,
            range_to_search,
            search_options,
            result,
        )
    };
    ret != 0
}

#[cfg(feature = "CFArray")]
#[deprecated = "renamed to `CFString::new_array_with_find_results`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateArrayWithFindResults(
    alloc: Option<&CFAllocator>,
    the_string: Option<&CFString>,
    string_to_find: Option<&CFString>,
    range_to_search: CFRange,
    compare_options: CFStringCompareFlags,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CFStringCreateArrayWithFindResults(
            alloc: Option<&CFAllocator>,
            the_string: Option<&CFString>,
            string_to_find: Option<&CFString>,
            range_to_search: CFRange,
            compare_options: CFStringCompareFlags,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe {
        CFStringCreateArrayWithFindResults(
            alloc,
            the_string,
            string_to_find,
            range_to_search,
            compare_options,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::find`"]
#[inline]
pub extern "C-unwind" fn CFStringFind(
    the_string: &CFString,
    string_to_find: Option<&CFString>,
    compare_options: CFStringCompareFlags,
) -> CFRange {
    extern "C-unwind" {
        fn CFStringFind(
            the_string: &CFString,
            string_to_find: Option<&CFString>,
            compare_options: CFStringCompareFlags,
        ) -> CFRange;
    }
    unsafe { CFStringFind(the_string, string_to_find, compare_options) }
}

#[deprecated = "renamed to `CFString::has_prefix`"]
#[inline]
pub extern "C-unwind" fn CFStringHasPrefix(
    the_string: &CFString,
    prefix: Option<&CFString>,
) -> bool {
    extern "C-unwind" {
        fn CFStringHasPrefix(the_string: &CFString, prefix: Option<&CFString>) -> Boolean;
    }
    let ret = unsafe { CFStringHasPrefix(the_string, prefix) };
    ret != 0
}

#[deprecated = "renamed to `CFString::has_suffix`"]
#[inline]
pub extern "C-unwind" fn CFStringHasSuffix(
    the_string: &CFString,
    suffix: Option<&CFString>,
) -> bool {
    extern "C-unwind" {
        fn CFStringHasSuffix(the_string: &CFString, suffix: Option<&CFString>) -> Boolean;
    }
    let ret = unsafe { CFStringHasSuffix(the_string, suffix) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFString::range_of_composed_characters_at_index`"]
    pub fn CFStringGetRangeOfComposedCharactersAtIndex(
        the_string: &CFString,
        the_index: CFIndex,
    ) -> CFRange;
}

#[cfg(feature = "CFCharacterSet")]
#[deprecated = "renamed to `CFString::find_character_from_set`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringFindCharacterFromSet(
    the_string: &CFString,
    the_set: Option<&CFCharacterSet>,
    range_to_search: CFRange,
    search_options: CFStringCompareFlags,
    result: *mut CFRange,
) -> bool {
    extern "C-unwind" {
        fn CFStringFindCharacterFromSet(
            the_string: &CFString,
            the_set: Option<&CFCharacterSet>,
            range_to_search: CFRange,
            search_options: CFStringCompareFlags,
            result: *mut CFRange,
        ) -> Boolean;
    }
    let ret = unsafe {
        CFStringFindCharacterFromSet(the_string, the_set, range_to_search, search_options, result)
    };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFString::line_bounds`"]
    pub fn CFStringGetLineBounds(
        the_string: &CFString,
        range: CFRange,
        line_begin_index: *mut CFIndex,
        line_end_index: *mut CFIndex,
        contents_end_index: *mut CFIndex,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFString::paragraph_bounds`"]
    pub fn CFStringGetParagraphBounds(
        string: &CFString,
        range: CFRange,
        par_begin_index: *mut CFIndex,
        par_end_index: *mut CFIndex,
        contents_end_index: *mut CFIndex,
    );
}

extern "C-unwind" {
    #[cfg(feature = "CFLocale")]
    #[deprecated = "renamed to `CFString::hyphenation_location_before_index`"]
    pub fn CFStringGetHyphenationLocationBeforeIndex(
        string: &CFString,
        location: CFIndex,
        limit_range: CFRange,
        options: CFOptionFlags,
        locale: Option<&CFLocale>,
        character: *mut UTF32Char,
    ) -> CFIndex;
}

#[cfg(feature = "CFLocale")]
#[deprecated = "renamed to `CFString::is_hyphenation_available_for_locale`"]
#[inline]
pub extern "C-unwind" fn CFStringIsHyphenationAvailableForLocale(
    locale: Option<&CFLocale>,
) -> bool {
    extern "C-unwind" {
        fn CFStringIsHyphenationAvailableForLocale(locale: Option<&CFLocale>) -> Boolean;
    }
    let ret = unsafe { CFStringIsHyphenationAvailableForLocale(locale) };
    ret != 0
}

#[cfg(feature = "CFArray")]
#[deprecated = "renamed to `CFString::new_by_combining_strings`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringCreateByCombiningStrings(
    alloc: Option<&CFAllocator>,
    the_array: Option<&CFArray>,
    separator_string: Option<&CFString>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringCreateByCombiningStrings(
            alloc: Option<&CFAllocator>,
            the_array: Option<&CFArray>,
            separator_string: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringCreateByCombiningStrings(alloc, the_array, separator_string) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFArray")]
#[deprecated = "renamed to `CFString::new_array_by_separating_strings`"]
#[inline]
pub extern "C-unwind" fn CFStringCreateArrayBySeparatingStrings(
    alloc: Option<&CFAllocator>,
    the_string: Option<&CFString>,
    separator_string: Option<&CFString>,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CFStringCreateArrayBySeparatingStrings(
            alloc: Option<&CFAllocator>,
            the_string: Option<&CFString>,
            separator_string: Option<&CFString>,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret =
        unsafe { CFStringCreateArrayBySeparatingStrings(alloc, the_string, separator_string) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFString::int_value`"]
#[inline]
pub extern "C-unwind" fn CFStringGetIntValue(str: &CFString) -> i32 {
    extern "C-unwind" {
        fn CFStringGetIntValue(str: &CFString) -> i32;
    }
    unsafe { CFStringGetIntValue(str) }
}

#[deprecated = "renamed to `CFString::double_value`"]
#[inline]
pub extern "C-unwind" fn CFStringGetDoubleValue(str: &CFString) -> c_double {
    extern "C-unwind" {
        fn CFStringGetDoubleValue(str: &CFString) -> c_double;
    }
    unsafe { CFStringGetDoubleValue(str) }
}

#[deprecated = "renamed to `CFMutableString::append`"]
#[inline]
pub extern "C-unwind" fn CFStringAppend(
    the_string: Option<&CFMutableString>,
    appended_string: Option<&CFString>,
) {
    extern "C-unwind" {
        fn CFStringAppend(the_string: Option<&CFMutableString>, appended_string: Option<&CFString>);
    }
    unsafe { CFStringAppend(the_string, appended_string) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::append_characters`"]
    pub fn CFStringAppendCharacters(
        the_string: Option<&CFMutableString>,
        chars: *const UniChar,
        num_chars: CFIndex,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::append_pascal_string`"]
    pub fn CFStringAppendPascalString(
        the_string: Option<&CFMutableString>,
        p_str: ConstStr255Param,
        encoding: CFStringEncoding,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::append_c_string`"]
    pub fn CFStringAppendCString(
        the_string: Option<&CFMutableString>,
        c_str: *const c_char,
        encoding: CFStringEncoding,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::insert`"]
    pub fn CFStringInsert(
        str: Option<&CFMutableString>,
        idx: CFIndex,
        inserted_str: Option<&CFString>,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::delete`"]
    pub fn CFStringDelete(the_string: Option<&CFMutableString>, range: CFRange);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::replace`"]
    pub fn CFStringReplace(
        the_string: Option<&CFMutableString>,
        range: CFRange,
        replacement: Option<&CFString>,
    );
}

#[deprecated = "renamed to `CFMutableString::replace_all`"]
#[inline]
pub extern "C-unwind" fn CFStringReplaceAll(
    the_string: Option<&CFMutableString>,
    replacement: Option<&CFString>,
) {
    extern "C-unwind" {
        fn CFStringReplaceAll(the_string: Option<&CFMutableString>, replacement: Option<&CFString>);
    }
    unsafe { CFStringReplaceAll(the_string, replacement) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::find_and_replace`"]
    pub fn CFStringFindAndReplace(
        the_string: Option<&CFMutableString>,
        string_to_find: Option<&CFString>,
        replacement_string: Option<&CFString>,
        range_to_search: CFRange,
        compare_options: CFStringCompareFlags,
    ) -> CFIndex;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::set_external_characters_no_copy`"]
    pub fn CFStringSetExternalCharactersNoCopy(
        the_string: Option<&CFMutableString>,
        chars: *mut UniChar,
        length: CFIndex,
        capacity: CFIndex,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::pad`"]
    pub fn CFStringPad(
        the_string: Option<&CFMutableString>,
        pad_string: Option<&CFString>,
        length: CFIndex,
        index_into_pad: CFIndex,
    );
}

#[deprecated = "renamed to `CFMutableString::trim`"]
#[inline]
pub extern "C-unwind" fn CFStringTrim(
    the_string: Option<&CFMutableString>,
    trim_string: Option<&CFString>,
) {
    extern "C-unwind" {
        fn CFStringTrim(the_string: Option<&CFMutableString>, trim_string: Option<&CFString>);
    }
    unsafe { CFStringTrim(the_string, trim_string) }
}

#[deprecated = "renamed to `CFMutableString::trim_whitespace`"]
#[inline]
pub extern "C-unwind" fn CFStringTrimWhitespace(the_string: Option<&CFMutableString>) {
    extern "C-unwind" {
        fn CFStringTrimWhitespace(the_string: Option<&CFMutableString>);
    }
    unsafe { CFStringTrimWhitespace(the_string) }
}

#[cfg(feature = "CFLocale")]
#[deprecated = "renamed to `CFMutableString::lowercase`"]
#[inline]
pub extern "C-unwind" fn CFStringLowercase(
    the_string: Option<&CFMutableString>,
    locale: Option<&CFLocale>,
) {
    extern "C-unwind" {
        fn CFStringLowercase(the_string: Option<&CFMutableString>, locale: Option<&CFLocale>);
    }
    unsafe { CFStringLowercase(the_string, locale) }
}

#[cfg(feature = "CFLocale")]
#[deprecated = "renamed to `CFMutableString::uppercase`"]
#[inline]
pub extern "C-unwind" fn CFStringUppercase(
    the_string: Option<&CFMutableString>,
    locale: Option<&CFLocale>,
) {
    extern "C-unwind" {
        fn CFStringUppercase(the_string: Option<&CFMutableString>, locale: Option<&CFLocale>);
    }
    unsafe { CFStringUppercase(the_string, locale) }
}

#[cfg(feature = "CFLocale")]
#[deprecated = "renamed to `CFMutableString::capitalize`"]
#[inline]
pub extern "C-unwind" fn CFStringCapitalize(
    the_string: Option<&CFMutableString>,
    locale: Option<&CFLocale>,
) {
    extern "C-unwind" {
        fn CFStringCapitalize(the_string: Option<&CFMutableString>, locale: Option<&CFLocale>);
    }
    unsafe { CFStringCapitalize(the_string, locale) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableString::normalize`"]
    pub fn CFStringNormalize(
        the_string: Option<&CFMutableString>,
        the_form: CFStringNormalizationForm,
    );
}

#[cfg(feature = "CFLocale")]
#[deprecated = "renamed to `CFMutableString::fold`"]
#[inline]
pub extern "C-unwind" fn CFStringFold(
    the_string: Option<&CFMutableString>,
    the_flags: CFStringCompareFlags,
    the_locale: Option<&CFLocale>,
) {
    extern "C-unwind" {
        fn CFStringFold(
            the_string: Option<&CFMutableString>,
            the_flags: CFStringCompareFlags,
            the_locale: Option<&CFLocale>,
        );
    }
    unsafe { CFStringFold(the_string, the_flags, the_locale) }
}

#[deprecated = "renamed to `CFMutableString::transform`"]
#[inline]
pub unsafe extern "C-unwind" fn CFStringTransform(
    string: Option<&CFMutableString>,
    range: *mut CFRange,
    transform: Option<&CFString>,
    reverse: bool,
) -> bool {
    extern "C-unwind" {
        fn CFStringTransform(
            string: Option<&CFMutableString>,
            range: *mut CFRange,
            transform: Option<&CFString>,
            reverse: Boolean,
        ) -> Boolean;
    }
    let ret = unsafe { CFStringTransform(string, range, transform, reverse as _) };
    ret != 0
}

#[deprecated = "renamed to `CFString::is_encoding_available`"]
#[inline]
pub extern "C-unwind" fn CFStringIsEncodingAvailable(encoding: CFStringEncoding) -> bool {
    extern "C-unwind" {
        fn CFStringIsEncodingAvailable(encoding: CFStringEncoding) -> Boolean;
    }
    let ret = unsafe { CFStringIsEncodingAvailable(encoding) };
    ret != 0
}

#[deprecated = "renamed to `CFString::list_of_available_encodings`"]
#[inline]
pub extern "C-unwind" fn CFStringGetListOfAvailableEncodings() -> *const CFStringEncoding {
    extern "C-unwind" {
        fn CFStringGetListOfAvailableEncodings() -> *const CFStringEncoding;
    }
    unsafe { CFStringGetListOfAvailableEncodings() }
}

#[deprecated = "renamed to `CFString::name_of_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringGetNameOfEncoding(
    encoding: CFStringEncoding,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringGetNameOfEncoding(encoding: CFStringEncoding) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringGetNameOfEncoding(encoding) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CFString::convert_encoding_to_ns_string_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringConvertEncodingToNSStringEncoding(
    encoding: CFStringEncoding,
) -> c_ulong {
    extern "C-unwind" {
        fn CFStringConvertEncodingToNSStringEncoding(encoding: CFStringEncoding) -> c_ulong;
    }
    unsafe { CFStringConvertEncodingToNSStringEncoding(encoding) }
}

#[deprecated = "renamed to `CFString::convert_ns_string_encoding_to_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringConvertNSStringEncodingToEncoding(
    encoding: c_ulong,
) -> CFStringEncoding {
    extern "C-unwind" {
        fn CFStringConvertNSStringEncodingToEncoding(encoding: c_ulong) -> CFStringEncoding;
    }
    unsafe { CFStringConvertNSStringEncodingToEncoding(encoding) }
}

#[deprecated = "renamed to `CFString::convert_encoding_to_windows_codepage`"]
#[inline]
pub extern "C-unwind" fn CFStringConvertEncodingToWindowsCodepage(
    encoding: CFStringEncoding,
) -> u32 {
    extern "C-unwind" {
        fn CFStringConvertEncodingToWindowsCodepage(encoding: CFStringEncoding) -> u32;
    }
    unsafe { CFStringConvertEncodingToWindowsCodepage(encoding) }
}

#[deprecated = "renamed to `CFString::convert_windows_codepage_to_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringConvertWindowsCodepageToEncoding(
    codepage: u32,
) -> CFStringEncoding {
    extern "C-unwind" {
        fn CFStringConvertWindowsCodepageToEncoding(codepage: u32) -> CFStringEncoding;
    }
    unsafe { CFStringConvertWindowsCodepageToEncoding(codepage) }
}

#[deprecated = "renamed to `CFString::convert_iana_char_set_name_to_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringConvertIANACharSetNameToEncoding(
    the_string: &CFString,
) -> CFStringEncoding {
    extern "C-unwind" {
        fn CFStringConvertIANACharSetNameToEncoding(the_string: &CFString) -> CFStringEncoding;
    }
    unsafe { CFStringConvertIANACharSetNameToEncoding(the_string) }
}

#[deprecated = "renamed to `CFString::convert_encoding_to_iana_char_set_name`"]
#[inline]
pub extern "C-unwind" fn CFStringConvertEncodingToIANACharSetName(
    encoding: CFStringEncoding,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFStringConvertEncodingToIANACharSetName(
            encoding: CFStringEncoding,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFStringConvertEncodingToIANACharSetName(encoding) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CFString::most_compatible_mac_string_encoding`"]
#[inline]
pub extern "C-unwind" fn CFStringGetMostCompatibleMacStringEncoding(
    encoding: CFStringEncoding,
) -> CFStringEncoding {
    extern "C-unwind" {
        fn CFStringGetMostCompatibleMacStringEncoding(
            encoding: CFStringEncoding,
        ) -> CFStringEncoding;
    }
    unsafe { CFStringGetMostCompatibleMacStringEncoding(encoding) }
}
