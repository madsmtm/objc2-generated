//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// Encapsulates a file system object’s security information in a Core Foundation object.
///
/// This is toll-free bridged with `NSFileSecurity`.
#[doc(alias = "CFFileSecurityRef")]
#[repr(C)]
pub struct CFFileSecurity {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFFileSecurity {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFFileSecurity"> for CFFileSecurity {}
);

unsafe impl ConcreteType for CFFileSecurity {
    /// Returns the type identifier for the `CFFileSecurityRef` opaque type.
    #[doc(alias = "CFFileSecurityGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFFileSecurityGetTypeID() -> CFTypeID;
        }
        unsafe { CFFileSecurityGetTypeID() }
    }
}

impl CFFileSecurity {
    /// Creates a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the current default allocator.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns a new `CFFileSecurityRef` object, or `NULL` if an error occurred. Ownership follows the Create Rule.
    ///
    ///
    #[doc(alias = "CFFileSecurityCreate")]
    #[inline]
    pub fn new(allocator: Option<&CFAllocator>) -> Option<CFRetained<CFFileSecurity>> {
        extern "C-unwind" {
            fn CFFileSecurityCreate(
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFFileSecurity>>;
        }
        let ret = unsafe { CFFileSecurityCreate(allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a copy of a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the current default allocator.
    ///
    /// - fileSec: The `CFFileSecurityRef` object to copy.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns a new `CFFileSecurityRef` object, or `NULL` if an error occurred. Ownership follows the Create Rule.
    ///
    ///
    #[doc(alias = "CFFileSecurityCreateCopy")]
    #[inline]
    pub fn new_copy(
        allocator: Option<&CFAllocator>,
        file_sec: Option<&CFFileSecurity>,
    ) -> Option<CFRetained<CFFileSecurity>> {
        extern "C-unwind" {
            fn CFFileSecurityCreateCopy(
                allocator: Option<&CFAllocator>,
                file_sec: Option<&CFFileSecurity>,
            ) -> Option<NonNull<CFFileSecurity>>;
        }
        let ret = unsafe { CFFileSecurityCreateCopy(allocator, file_sec) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Copies the owner UUID associated with a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object.
    ///
    /// - ownerUUID: The address of a `CFUUIDRef` where the results are stored.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if an owner UUID was successfully copied, or `false` if there is no owner UUID property associated with this `CFFileSecurityRef` object.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `owner_uuid` must be a valid pointer.
    #[doc(alias = "CFFileSecurityCopyOwnerUUID")]
    #[cfg(feature = "CFUUID")]
    #[inline]
    pub unsafe fn owner_uuid(&self, owner_uuid: *mut *const CFUUID) -> bool {
        extern "C-unwind" {
            fn CFFileSecurityCopyOwnerUUID(
                file_sec: &CFFileSecurity,
                owner_uuid: *mut *const CFUUID,
            ) -> Boolean;
        }
        let ret = unsafe { CFFileSecurityCopyOwnerUUID(self, owner_uuid) };
        ret != 0
    }

    /// Sets the owner UUID associated with a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object to modify.
    ///
    /// - ownerUUID: The owner UUID to set.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if the owner UUID property was successfully set, otherwise `false`.
    ///
    ///
    #[doc(alias = "CFFileSecuritySetOwnerUUID")]
    #[cfg(feature = "CFUUID")]
    #[inline]
    pub fn set_owner_uuid(&self, owner_uuid: Option<&CFUUID>) -> bool {
        extern "C-unwind" {
            fn CFFileSecuritySetOwnerUUID(
                file_sec: &CFFileSecurity,
                owner_uuid: Option<&CFUUID>,
            ) -> Boolean;
        }
        let ret = unsafe { CFFileSecuritySetOwnerUUID(self, owner_uuid) };
        ret != 0
    }

    /// Copies the group UUID associated with a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object.
    ///
    /// - groupUUID: The address of a `CFUUIDRef` where the results are stored.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if a group UUID was successfully copied, or `false` if there is no group UUID property associated with this `CFFileSecurityRef` object.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `group_uuid` must be a valid pointer.
    #[doc(alias = "CFFileSecurityCopyGroupUUID")]
    #[cfg(feature = "CFUUID")]
    #[inline]
    pub unsafe fn group_uuid(&self, group_uuid: *mut *const CFUUID) -> bool {
        extern "C-unwind" {
            fn CFFileSecurityCopyGroupUUID(
                file_sec: &CFFileSecurity,
                group_uuid: *mut *const CFUUID,
            ) -> Boolean;
        }
        let ret = unsafe { CFFileSecurityCopyGroupUUID(self, group_uuid) };
        ret != 0
    }

    /// Sets the group UUID associated with a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object to modify.
    ///
    /// - groupUUID: The group UUID to set.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if the group UUID was successfully set, otherwise `false`.
    ///
    ///
    #[doc(alias = "CFFileSecuritySetGroupUUID")]
    #[cfg(feature = "CFUUID")]
    #[inline]
    pub fn set_group_uuid(&self, group_uuid: Option<&CFUUID>) -> bool {
        extern "C-unwind" {
            fn CFFileSecuritySetGroupUUID(
                file_sec: &CFFileSecurity,
                group_uuid: Option<&CFUUID>,
            ) -> Boolean;
        }
        let ret = unsafe { CFFileSecuritySetGroupUUID(self, group_uuid) };
        ret != 0
    }

    /// Gets the owner ID associated with a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object.
    ///
    /// - owner: The address of an integer of type `uid_t`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if the owner ID was stored in the address pointed to by `owner`, or `false` if there is no owner ID property associated with this `CFFileSecurityRef` object.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `owner` must be a valid pointer.
    #[doc(alias = "CFFileSecurityGetOwner")]
    #[cfg(feature = "libc")]
    #[inline]
    pub unsafe fn owner(&self, owner: *mut libc::uid_t) -> bool {
        extern "C-unwind" {
            fn CFFileSecurityGetOwner(
                file_sec: &CFFileSecurity,
                owner: *mut libc::uid_t,
            ) -> Boolean;
        }
        let ret = unsafe { CFFileSecurityGetOwner(self, owner) };
        ret != 0
    }

    /// Sets the owner ID associated with a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object to modify.
    ///
    /// - owner: An integer of type `uid_t`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if the owner ID property was successfully set, otherwise `false`.
    ///
    ///
    #[doc(alias = "CFFileSecuritySetOwner")]
    #[cfg(feature = "libc")]
    #[inline]
    pub fn set_owner(&self, owner: libc::uid_t) -> bool {
        extern "C-unwind" {
            fn CFFileSecuritySetOwner(file_sec: &CFFileSecurity, owner: libc::uid_t) -> Boolean;
        }
        let ret = unsafe { CFFileSecuritySetOwner(self, owner) };
        ret != 0
    }

    /// Gets the group ID associated with a `CFFileSecurityRef` object
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object.
    ///
    /// - group: The address of an integer of type `gid_t`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if the group ID was stored in the address pointed to by `group`, or `false` if there is no address property associated with this `CFFileSecurityRef` object.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `group` must be a valid pointer.
    #[doc(alias = "CFFileSecurityGetGroup")]
    #[cfg(feature = "libc")]
    #[inline]
    pub unsafe fn group(&self, group: *mut libc::gid_t) -> bool {
        extern "C-unwind" {
            fn CFFileSecurityGetGroup(
                file_sec: &CFFileSecurity,
                group: *mut libc::gid_t,
            ) -> Boolean;
        }
        let ret = unsafe { CFFileSecurityGetGroup(self, group) };
        ret != 0
    }

    /// Sets the group ID associated with a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object to modify.
    ///
    /// - group: An integer of type `gid_t`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if the group ID was successfully set, otherwise `false`.
    ///
    ///
    #[doc(alias = "CFFileSecuritySetGroup")]
    #[cfg(feature = "libc")]
    #[inline]
    pub fn set_group(&self, group: libc::gid_t) -> bool {
        extern "C-unwind" {
            fn CFFileSecuritySetGroup(file_sec: &CFFileSecurity, group: libc::gid_t) -> Boolean;
        }
        let ret = unsafe { CFFileSecuritySetGroup(self, group) };
        ret != 0
    }

    /// Gets the file mode associated with a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object.
    ///
    /// - mode: The address of an integer of type `mode_t`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if the file mode was stored in the address pointed to by `mode`, or `false` if there is no file mode property associated with this `CFFileSecurityRef` object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For more information on numerical file modes, see the chmod(2) manual page and the definitions in `/usr/include/sys/stat.h`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `mode` must be a valid pointer.
    #[doc(alias = "CFFileSecurityGetMode")]
    #[cfg(feature = "libc")]
    #[inline]
    pub unsafe fn mode(&self, mode: *mut libc::mode_t) -> bool {
        extern "C-unwind" {
            fn CFFileSecurityGetMode(file_sec: &CFFileSecurity, mode: *mut libc::mode_t)
                -> Boolean;
        }
        let ret = unsafe { CFFileSecurityGetMode(self, mode) };
        ret != 0
    }

    /// Sets the file mode associated with a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The `CFFileSecurityRef` object to modify.
    ///
    /// - mode: An integer of type `mode_t`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if the file mode property was successfully set, otherwise `false`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For more information on numerical file modes, see the chmod(2) manual page and the definitions in `/usr/include/sys/stat.h`.
    ///
    ///
    #[doc(alias = "CFFileSecuritySetMode")]
    #[cfg(feature = "libc")]
    #[inline]
    pub fn set_mode(&self, mode: libc::mode_t) -> bool {
        extern "C-unwind" {
            fn CFFileSecuritySetMode(file_sec: &CFFileSecurity, mode: libc::mode_t) -> Boolean;
        }
        let ret = unsafe { CFFileSecuritySetMode(self, mode) };
        ret != 0
    }
}

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CFFileSecurityClearOptions(pub CFOptionFlags);
bitflags::bitflags! {
    impl CFFileSecurityClearOptions: CFOptionFlags {
/// Clear the (POSIX) owner ID.
        #[doc(alias = "kCFFileSecurityClearOwner")]
        const Owner = 1<<0;
/// Clear the (POSIX) group ID.
        #[doc(alias = "kCFFileSecurityClearGroup")]
        const Group = 1<<1;
/// Clear the file’s mode (POSIX permissions).
        #[doc(alias = "kCFFileSecurityClearMode")]
        const Mode = 1<<2;
/// Clear the owner UUID (for the access control list).
        #[doc(alias = "kCFFileSecurityClearOwnerUUID")]
        const OwnerUUID = 1<<3;
/// Clear the group UUID (for the access control list).
        #[doc(alias = "kCFFileSecurityClearGroupUUID")]
        const GroupUUID = 1<<4;
/// Clear the access control list.
        #[doc(alias = "kCFFileSecurityClearAccessControlList")]
        const AccessControlList = 1<<5;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFFileSecurityClearOptions {
    const ENCODING: Encoding = CFOptionFlags::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFFileSecurityClearOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CFFileSecurity {
    /// Clears properties from a `CFFileSecurityRef` object.
    ///
    /// Parameters:
    /// - fileSec: The file security properties to clear.
    ///
    /// - clearPropertyMask: The file security properties to clear.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `true` if the file security properties were successfully cleared, or `false` otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// One common use for `CFFileSecurityRef` objects is to clone the permissions from one file to another. In this use, you may want to copy only a subset of the permissions. This function lets you delete the specific permissions that you do not want to change prior to applying the set of permissions to a different file.
    ///
    ///
    #[doc(alias = "CFFileSecurityClearProperties")]
    #[inline]
    pub fn clear_properties(&self, clear_property_mask: CFFileSecurityClearOptions) -> bool {
        extern "C-unwind" {
            fn CFFileSecurityClearProperties(
                file_sec: &CFFileSecurity,
                clear_property_mask: CFFileSecurityClearOptions,
            ) -> Boolean;
        }
        let ret = unsafe { CFFileSecurityClearProperties(self, clear_property_mask) };
        ret != 0
    }
}

#[deprecated = "renamed to `CFFileSecurity::new`"]
#[inline]
pub extern "C-unwind" fn CFFileSecurityCreate(
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFFileSecurity>> {
    extern "C-unwind" {
        fn CFFileSecurityCreate(allocator: Option<&CFAllocator>)
            -> Option<NonNull<CFFileSecurity>>;
    }
    let ret = unsafe { CFFileSecurityCreate(allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFFileSecurity::new_copy`"]
#[inline]
pub extern "C-unwind" fn CFFileSecurityCreateCopy(
    allocator: Option<&CFAllocator>,
    file_sec: Option<&CFFileSecurity>,
) -> Option<CFRetained<CFFileSecurity>> {
    extern "C-unwind" {
        fn CFFileSecurityCreateCopy(
            allocator: Option<&CFAllocator>,
            file_sec: Option<&CFFileSecurity>,
        ) -> Option<NonNull<CFFileSecurity>>;
    }
    let ret = unsafe { CFFileSecurityCreateCopy(allocator, file_sec) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFUUID")]
#[deprecated = "renamed to `CFFileSecurity::owner_uuid`"]
#[inline]
pub unsafe extern "C-unwind" fn CFFileSecurityCopyOwnerUUID(
    file_sec: &CFFileSecurity,
    owner_uuid: *mut *const CFUUID,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecurityCopyOwnerUUID(
            file_sec: &CFFileSecurity,
            owner_uuid: *mut *const CFUUID,
        ) -> Boolean;
    }
    let ret = unsafe { CFFileSecurityCopyOwnerUUID(file_sec, owner_uuid) };
    ret != 0
}

#[cfg(feature = "CFUUID")]
#[deprecated = "renamed to `CFFileSecurity::set_owner_uuid`"]
#[inline]
pub extern "C-unwind" fn CFFileSecuritySetOwnerUUID(
    file_sec: &CFFileSecurity,
    owner_uuid: Option<&CFUUID>,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecuritySetOwnerUUID(
            file_sec: &CFFileSecurity,
            owner_uuid: Option<&CFUUID>,
        ) -> Boolean;
    }
    let ret = unsafe { CFFileSecuritySetOwnerUUID(file_sec, owner_uuid) };
    ret != 0
}

#[cfg(feature = "CFUUID")]
#[deprecated = "renamed to `CFFileSecurity::group_uuid`"]
#[inline]
pub unsafe extern "C-unwind" fn CFFileSecurityCopyGroupUUID(
    file_sec: &CFFileSecurity,
    group_uuid: *mut *const CFUUID,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecurityCopyGroupUUID(
            file_sec: &CFFileSecurity,
            group_uuid: *mut *const CFUUID,
        ) -> Boolean;
    }
    let ret = unsafe { CFFileSecurityCopyGroupUUID(file_sec, group_uuid) };
    ret != 0
}

#[cfg(feature = "CFUUID")]
#[deprecated = "renamed to `CFFileSecurity::set_group_uuid`"]
#[inline]
pub extern "C-unwind" fn CFFileSecuritySetGroupUUID(
    file_sec: &CFFileSecurity,
    group_uuid: Option<&CFUUID>,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecuritySetGroupUUID(
            file_sec: &CFFileSecurity,
            group_uuid: Option<&CFUUID>,
        ) -> Boolean;
    }
    let ret = unsafe { CFFileSecuritySetGroupUUID(file_sec, group_uuid) };
    ret != 0
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `CFFileSecurity::owner`"]
#[inline]
pub unsafe extern "C-unwind" fn CFFileSecurityGetOwner(
    file_sec: &CFFileSecurity,
    owner: *mut libc::uid_t,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecurityGetOwner(file_sec: &CFFileSecurity, owner: *mut libc::uid_t) -> Boolean;
    }
    let ret = unsafe { CFFileSecurityGetOwner(file_sec, owner) };
    ret != 0
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `CFFileSecurity::set_owner`"]
#[inline]
pub extern "C-unwind" fn CFFileSecuritySetOwner(
    file_sec: &CFFileSecurity,
    owner: libc::uid_t,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecuritySetOwner(file_sec: &CFFileSecurity, owner: libc::uid_t) -> Boolean;
    }
    let ret = unsafe { CFFileSecuritySetOwner(file_sec, owner) };
    ret != 0
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `CFFileSecurity::group`"]
#[inline]
pub unsafe extern "C-unwind" fn CFFileSecurityGetGroup(
    file_sec: &CFFileSecurity,
    group: *mut libc::gid_t,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecurityGetGroup(file_sec: &CFFileSecurity, group: *mut libc::gid_t) -> Boolean;
    }
    let ret = unsafe { CFFileSecurityGetGroup(file_sec, group) };
    ret != 0
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `CFFileSecurity::set_group`"]
#[inline]
pub extern "C-unwind" fn CFFileSecuritySetGroup(
    file_sec: &CFFileSecurity,
    group: libc::gid_t,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecuritySetGroup(file_sec: &CFFileSecurity, group: libc::gid_t) -> Boolean;
    }
    let ret = unsafe { CFFileSecuritySetGroup(file_sec, group) };
    ret != 0
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `CFFileSecurity::mode`"]
#[inline]
pub unsafe extern "C-unwind" fn CFFileSecurityGetMode(
    file_sec: &CFFileSecurity,
    mode: *mut libc::mode_t,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecurityGetMode(file_sec: &CFFileSecurity, mode: *mut libc::mode_t) -> Boolean;
    }
    let ret = unsafe { CFFileSecurityGetMode(file_sec, mode) };
    ret != 0
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `CFFileSecurity::set_mode`"]
#[inline]
pub extern "C-unwind" fn CFFileSecuritySetMode(
    file_sec: &CFFileSecurity,
    mode: libc::mode_t,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecuritySetMode(file_sec: &CFFileSecurity, mode: libc::mode_t) -> Boolean;
    }
    let ret = unsafe { CFFileSecuritySetMode(file_sec, mode) };
    ret != 0
}

#[deprecated = "renamed to `CFFileSecurity::clear_properties`"]
#[inline]
pub extern "C-unwind" fn CFFileSecurityClearProperties(
    file_sec: &CFFileSecurity,
    clear_property_mask: CFFileSecurityClearOptions,
) -> bool {
    extern "C-unwind" {
        fn CFFileSecurityClearProperties(
            file_sec: &CFFileSecurity,
            clear_property_mask: CFFileSecurityClearOptions,
        ) -> Boolean;
    }
    let ret = unsafe { CFFileSecurityClearProperties(file_sec, clear_property_mask) };
    ret != 0
}
