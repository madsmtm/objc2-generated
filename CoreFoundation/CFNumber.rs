//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

///
/// ## Overview
///
/// CFBoolean objects are used to wrap boolean values for use in Core Foundation property lists and collection types.
///
///
///
/// This is toll-free bridged with `NSNumber`.
#[doc(alias = "CFBooleanRef")]
#[repr(C)]
pub struct CFBoolean {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFBoolean {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFBoolean"> for CFBoolean {}
);

extern "C" {
    /// Boolean true value.
    pub static kCFBooleanTrue: Option<&'static CFBoolean>;
}

extern "C" {
    /// Boolean false value.
    pub static kCFBooleanFalse: Option<&'static CFBoolean>;
}

unsafe impl ConcreteType for CFBoolean {
    /// Returns the Core Foundation type identifier for the CFBoolean opaque type.
    ///
    /// ## Return Value
    ///
    /// The Core Foundation type identifier for CFBoolean opaque type.
    ///
    ///
    #[doc(alias = "CFBooleanGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFBooleanGetTypeID() -> CFTypeID;
        }
        unsafe { CFBooleanGetTypeID() }
    }
}

impl CFBoolean {
    /// Returns the value of a CFBoolean object as a standard C type `Boolean`.
    ///
    /// Parameters:
    /// - boolean: The boolean to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The value of `boolean`.
    ///
    ///
    #[doc(alias = "CFBooleanGetValue")]
    #[inline]
    pub fn value(&self) -> bool {
        extern "C-unwind" {
            fn CFBooleanGetValue(boolean: &CFBoolean) -> Boolean;
        }
        let ret = unsafe { CFBooleanGetValue(self) };
        ret != 0
    }
}

/// Flags used by CFNumber to indicate the data type of a value.
///
/// ## Overview
///
/// The type specified in the call to [`CFNumberCreate`](https://developer.apple.com/documentation/corefoundation/cfnumbercreate(_:_:_:)) is not necessarily preserved when creating a new CFNumber object. A CFNumber object uses whatever internal storage type the creation function deems appropriate. Use the [`CFNumberGetType`](https://developer.apple.com/documentation/corefoundation/cfnumbergettype(_:)) function to find out what type the CFNumber object used to store your value.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFNumberType(pub CFIndex);
impl CFNumberType {
    /// Eight-bit, signed integer. The `SInt8` data type is defined in `MacTypes.h`.
    #[doc(alias = "kCFNumberSInt8Type")]
    pub const SInt8Type: Self = Self(1);
    /// Sixteen-bit, signed integer. The `SInt16` data type is defined in `MacTypes.h`.
    #[doc(alias = "kCFNumberSInt16Type")]
    pub const SInt16Type: Self = Self(2);
    /// Thirty-two-bit, signed integer. The `SInt32` data type is defined in `MacTypes.h`.
    #[doc(alias = "kCFNumberSInt32Type")]
    pub const SInt32Type: Self = Self(3);
    /// Sixty-four-bit, signed integer. The `SInt64` data type is defined in `MacTypes.h`.
    #[doc(alias = "kCFNumberSInt64Type")]
    pub const SInt64Type: Self = Self(4);
    /// Thirty-two-bit real. The `Float32` data type is defined in `MacTypes.h`.
    #[doc(alias = "kCFNumberFloat32Type")]
    pub const Float32Type: Self = Self(5);
    /// Sixty-four-bit real. The `Float64` data type is defined in `MacTypes.h` and conforms to the 64-bit IEEE 754 standard.
    #[doc(alias = "kCFNumberFloat64Type")]
    pub const Float64Type: Self = Self(6);
    /// Basic C `char` type.
    #[doc(alias = "kCFNumberCharType")]
    pub const CharType: Self = Self(7);
    /// Basic C `short` type.
    #[doc(alias = "kCFNumberShortType")]
    pub const ShortType: Self = Self(8);
    /// Basic C `int` type.
    #[doc(alias = "kCFNumberIntType")]
    pub const IntType: Self = Self(9);
    /// Basic C `long` type.
    #[doc(alias = "kCFNumberLongType")]
    pub const LongType: Self = Self(10);
    /// Basic C `long long` type.
    #[doc(alias = "kCFNumberLongLongType")]
    pub const LongLongType: Self = Self(11);
    /// Basic C `float` type.
    #[doc(alias = "kCFNumberFloatType")]
    pub const FloatType: Self = Self(12);
    /// Basic C `double` type.
    #[doc(alias = "kCFNumberDoubleType")]
    pub const DoubleType: Self = Self(13);
    /// CFIndex value.
    #[doc(alias = "kCFNumberCFIndexType")]
    pub const CFIndexType: Self = Self(14);
    /// `NSInteger` value.
    #[doc(alias = "kCFNumberNSIntegerType")]
    pub const NSIntegerType: Self = Self(15);
    /// `CGFloat` value.
    #[doc(alias = "kCFNumberCGFloatType")]
    pub const CGFloatType: Self = Self(16);
    /// Same as [`kCFNumberCGFloatType`](https://developer.apple.com/documentation/corefoundation/cfnumbertype/cgfloattype).
    ///
    /// ## Discussion
    ///
    /// Note that in OS X v10.4, [`kCFNumberMaxType`](https://developer.apple.com/documentation/corefoundation/cfnumbertype/maxtype) was the same as [`kCFNumberCFIndexType`](https://developer.apple.com/documentation/corefoundation/cfnumbertype/cfindextype) .
    ///
    ///
    #[doc(alias = "kCFNumberMaxType")]
    pub const MaxType: Self = Self(16);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFNumberType {
    const ENCODING: Encoding = CFIndex::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFNumberType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// CFNumber encapsulates C scalar (numeric) types. It provides functions for setting and accessing the value as any basic C type. It also provides a compare function to determine the ordering of two CFNumber objects. CFNumber objects are used to wrap numerical values for use in Core Foundation property lists and collections.
///
/// CFNumber objects are not intended as a replacement for C scalar values and should not be used in APIs or implementations where scalar values are more appropriate and efficient.
///
/// <div class="warning">
///
/// ### Note
///  In order to improve performance, some commonly-used numbers (such as `0` and `1`) are uniqued. You should not expect that allocating multiple CFNumber instances will necessarily result in distinct objects.
///
///
///
/// </div>
/// CFNumber is “toll-free bridged” with its Cocoa Foundation counterpart, [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber). This means that the Core Foundation type is interchangeable in function or method calls with the bridged Foundation object. Therefore, in a method where you see an `NSNumber *` parameter, you can pass in a `CFNumberRef`, and in a function where you see a `CFNumberRef` parameter, you can pass in an NSNumber instance. This fact also applies to concrete subclasses of NSNumber. See [Toll-Free Bridged Types](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677) for more information on toll-free bridging.
///
///
///
/// This is toll-free bridged with `NSNumber`.
#[doc(alias = "CFNumberRef")]
#[repr(C)]
pub struct CFNumber {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFNumber {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFNumber"> for CFNumber {}
);

extern "C" {
    /// Designates a positive infinity value.
    pub static kCFNumberPositiveInfinity: Option<&'static CFNumber>;
}

extern "C" {
    /// Designates a negative infinity value.
    pub static kCFNumberNegativeInfinity: Option<&'static CFNumber>;
}

extern "C" {
    /// “Not a Number.” This value is often the result of an invalid operation, such as the square-root of a negative number.
    pub static kCFNumberNaN: Option<&'static CFNumber>;
}

unsafe impl ConcreteType for CFNumber {
    /// Returns the type identifier for the CFNumber opaque type.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the CFNumber opaque type.
    ///
    ///
    #[doc(alias = "CFNumberGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFNumberGetTypeID() -> CFTypeID;
        }
        unsafe { CFNumberGetTypeID() }
    }
}

impl CFNumber {
    /// Creates a CFNumber object using a specified value.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the default allocator.
    ///
    /// - theType: A constant that specifies the data type of the value to convert. See [`CFNumberType`](https://developer.apple.com/documentation/corefoundation/cfnumbertype) for a list of possible values.
    ///
    /// - valuePtr: A pointer to the value for the returned number object.
    ///
    ///
    /// ## Return Value
    ///
    /// A new number with the value specified by `valuePtr`. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The `theType` parameter is not necessarily preserved when creating a new CFNumber object. The CFNumber object will be created using whatever internal storage type the creation function deems appropriate. Use the function [`CFNumberGetType`](https://developer.apple.com/documentation/corefoundation/cfnumbergettype(_:)) to find out what type the CFNumber object used to store your value.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `value_ptr` must be a valid pointer.
    #[doc(alias = "CFNumberCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        the_type: CFNumberType,
        value_ptr: *const c_void,
    ) -> Option<CFRetained<CFNumber>> {
        extern "C-unwind" {
            fn CFNumberCreate(
                allocator: Option<&CFAllocator>,
                the_type: CFNumberType,
                value_ptr: *const c_void,
            ) -> Option<NonNull<CFNumber>>;
        }
        let ret = unsafe { CFNumberCreate(allocator, the_type, value_ptr) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the type used by a CFNumber object to store its value.
    ///
    /// Parameters:
    /// - number: The CFNumber object to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A constant that indicates the data type of the value contained in `number`. See [`CFNumberType`](https://developer.apple.com/documentation/corefoundation/cfnumbertype) for a list of possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The type specified in the call to [`CFNumberCreate`](https://developer.apple.com/documentation/corefoundation/cfnumbercreate(_:_:_:)) is not necessarily preserved when a new CFNumber object is created—it uses whatever internal storage type the creation function deems appropriate.
    ///
    ///
    #[doc(alias = "CFNumberGetType")]
    #[inline]
    pub fn r#type(&self) -> CFNumberType {
        extern "C-unwind" {
            fn CFNumberGetType(number: &CFNumber) -> CFNumberType;
        }
        unsafe { CFNumberGetType(self) }
    }

    /// Returns the number of bytes used by a CFNumber object to store its value.
    ///
    /// Parameters:
    /// - number: The CFNumber object to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The size in bytes of the value contained in `number`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Because a CFNumber object might store a value using a type different from that of the original value with which it was created, this function may return a size different from the size of the original value’s type.
    ///
    ///
    #[doc(alias = "CFNumberGetByteSize")]
    #[inline]
    pub fn byte_size(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFNumberGetByteSize(number: &CFNumber) -> CFIndex;
        }
        unsafe { CFNumberGetByteSize(self) }
    }

    /// Determines whether a CFNumber object contains a value stored as one of the defined floating point types.
    ///
    /// Parameters:
    /// - number: The CFNumber object to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if `number`’s value is one of the defined floating point types, otherwise `false`. The valid floating point types are listed in [`CFNumberType`](https://developer.apple.com/documentation/corefoundation/cfnumbertype).
    ///
    ///
    #[doc(alias = "CFNumberIsFloatType")]
    #[inline]
    pub fn is_float_type(&self) -> bool {
        extern "C-unwind" {
            fn CFNumberIsFloatType(number: &CFNumber) -> Boolean;
        }
        let ret = unsafe { CFNumberIsFloatType(self) };
        ret != 0
    }

    /// Obtains the value of a CFNumber object cast to a specified type.
    ///
    /// Parameters:
    /// - number: The CFNumber object to examine.
    ///
    /// - theType: A constant that specifies the data type to return. See [`CFNumberType`](https://developer.apple.com/documentation/corefoundation/cfnumbertype) for a list of possible values.
    ///
    /// - valuePtr: On return, contains the value of `number`.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if the operation was successful, otherwise `false`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the argument type differs from the return type, and the conversion is lossy or the return value is out of range, then this function passes back an approximate value in `valuePtr` and returns `false`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `value_ptr` must be a valid pointer.
    #[doc(alias = "CFNumberGetValue")]
    #[inline]
    pub unsafe fn value(&self, the_type: CFNumberType, value_ptr: *mut c_void) -> bool {
        extern "C-unwind" {
            fn CFNumberGetValue(
                number: &CFNumber,
                the_type: CFNumberType,
                value_ptr: *mut c_void,
            ) -> Boolean;
        }
        let ret = unsafe { CFNumberGetValue(self, the_type, value_ptr) };
        ret != 0
    }

    /// Compares two CFNumber objects and returns a comparison result.
    ///
    /// Parameters:
    /// - number: The first CFNumber object to compare.
    ///
    /// - otherNumber: The second CFNumber object to compare.
    ///
    /// - context: Pass `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// A [`CFComparisonResult`](https://developer.apple.com/documentation/corefoundation/cfcomparisonresult) constant that indicates whether `number` is equal to, less than, or greater than `otherNumber`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// When comparing two CFNumber objects using this function, one or both objects can represent a special-case number such as signed 0, signed infinity, or NaN.
    ///
    /// The following rules apply:
    ///
    /// - Negative 0 compares less than positive 0.
    ///
    /// - Positive infinity compares greater than everything except itself, to which it compares equal.
    ///
    /// - Negative infinity compares less than everything except itself, to which it compares equal.
    ///
    /// - If both numbers are NaN, then they compare equal.
    ///
    /// - If only one of the numbers is NaN, then the NaN compares greater than the other number if it is negative, and smaller than the other number if it is positive.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `other_number` might not allow `None`.
    /// - `context` must be a valid pointer.
    #[doc(alias = "CFNumberCompare")]
    #[inline]
    pub unsafe fn compare(
        &self,
        other_number: Option<&CFNumber>,
        context: *mut c_void,
    ) -> CFComparisonResult {
        extern "C-unwind" {
            fn CFNumberCompare(
                number: &CFNumber,
                other_number: Option<&CFNumber>,
                context: *mut c_void,
            ) -> CFComparisonResult;
        }
        unsafe { CFNumberCompare(self, other_number, context) }
    }
}

#[deprecated = "renamed to `CFBoolean::value`"]
#[inline]
pub extern "C-unwind" fn CFBooleanGetValue(boolean: &CFBoolean) -> bool {
    extern "C-unwind" {
        fn CFBooleanGetValue(boolean: &CFBoolean) -> Boolean;
    }
    let ret = unsafe { CFBooleanGetValue(boolean) };
    ret != 0
}

#[deprecated = "renamed to `CFNumber::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFNumberCreate(
    allocator: Option<&CFAllocator>,
    the_type: CFNumberType,
    value_ptr: *const c_void,
) -> Option<CFRetained<CFNumber>> {
    extern "C-unwind" {
        fn CFNumberCreate(
            allocator: Option<&CFAllocator>,
            the_type: CFNumberType,
            value_ptr: *const c_void,
        ) -> Option<NonNull<CFNumber>>;
    }
    let ret = unsafe { CFNumberCreate(allocator, the_type, value_ptr) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFNumber::type`"]
#[inline]
pub extern "C-unwind" fn CFNumberGetType(number: &CFNumber) -> CFNumberType {
    extern "C-unwind" {
        fn CFNumberGetType(number: &CFNumber) -> CFNumberType;
    }
    unsafe { CFNumberGetType(number) }
}

#[deprecated = "renamed to `CFNumber::byte_size`"]
#[inline]
pub extern "C-unwind" fn CFNumberGetByteSize(number: &CFNumber) -> CFIndex {
    extern "C-unwind" {
        fn CFNumberGetByteSize(number: &CFNumber) -> CFIndex;
    }
    unsafe { CFNumberGetByteSize(number) }
}

#[deprecated = "renamed to `CFNumber::is_float_type`"]
#[inline]
pub extern "C-unwind" fn CFNumberIsFloatType(number: &CFNumber) -> bool {
    extern "C-unwind" {
        fn CFNumberIsFloatType(number: &CFNumber) -> Boolean;
    }
    let ret = unsafe { CFNumberIsFloatType(number) };
    ret != 0
}

#[deprecated = "renamed to `CFNumber::value`"]
#[inline]
pub unsafe extern "C-unwind" fn CFNumberGetValue(
    number: &CFNumber,
    the_type: CFNumberType,
    value_ptr: *mut c_void,
) -> bool {
    extern "C-unwind" {
        fn CFNumberGetValue(
            number: &CFNumber,
            the_type: CFNumberType,
            value_ptr: *mut c_void,
        ) -> Boolean;
    }
    let ret = unsafe { CFNumberGetValue(number, the_type, value_ptr) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFNumber::compare`"]
    pub fn CFNumberCompare(
        number: &CFNumber,
        other_number: Option<&CFNumber>,
        context: *mut c_void,
    ) -> CFComparisonResult;
}
