//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// A reference to a `CFURLEnumerator` object.
#[doc(alias = "CFURLEnumeratorRef")]
#[repr(C)]
pub struct CFURLEnumerator {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFURLEnumerator {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFURLEnumerator"> for CFURLEnumerator {}
);

unsafe impl ConcreteType for CFURLEnumerator {
    /// Returns the opaque type identifier for the CFURLEnumerator opaque type.
    ///
    /// ## Return Value
    ///
    /// The `CFURLEnumerator` opaque type identifier.
    ///
    ///
    #[doc(alias = "CFURLEnumeratorGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFURLEnumeratorGetTypeID() -> CFTypeID;
        }
        unsafe { CFURLEnumeratorGetTypeID() }
    }
}

/// Options for controlling enumerator behavior.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CFURLEnumeratorOptions(pub CFOptionFlags);
bitflags::bitflags! {
    impl CFURLEnumeratorOptions: CFOptionFlags {
/// The enumerator performs its default behavior.
        #[doc(alias = "kCFURLEnumeratorDefaultBehavior")]
        const DefaultBehavior = 0;
/// The enumerator recurses into each subdirectory enumerated.
///
/// ## Discussion
///
/// This option applies only to directory enumerators.
///
/// You can enumerate the directories that a recursive enumerator encounters in pre-order fashion, post-order fashion, or both, by providing a combination of the [`kCFURLEnumeratorIncludeDirectoriesPreOrder`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/includedirectoriespreorder) and [`kCFURLEnumeratorIncludeDirectoriesPostOrder`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/includedirectoriespostorder) options. If you provide neither option, the recursive enumerator behaves as if it was provided the [`kCFURLEnumeratorIncludeDirectoriesPreOrder`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/includedirectoriespreorder) option.
///
///
        #[doc(alias = "kCFURLEnumeratorDescendRecursively")]
        const DescendRecursively = 1<<0;
/// The enumerator skips “hidden” or “invisible” objects.
        #[doc(alias = "kCFURLEnumeratorSkipInvisibles")]
        const SkipInvisibles = 1<<1;
/// The enumerator generates file reference URLs instead of file path URLs.
///
/// ## Discussion
///
/// This option applies only to volume enumerators.
///
///
        #[doc(alias = "kCFURLEnumeratorGenerateFileReferenceURLs")]
        const GenerateFileReferenceURLs = 1<<2;
/// The enumerator skips package directory contents.
///
/// ## Discussion
///
/// This option applies only to directory enumerators.
///
///
        #[doc(alias = "kCFURLEnumeratorSkipPackageContents")]
        const SkipPackageContents = 1<<3;
/// If provided along with the [`kCFURLEnumeratorDescendRecursively`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/descendrecursively) option, the recursive enumerator returns a directory’s URL before returning the URLs of the directory’s descendents.
        #[doc(alias = "kCFURLEnumeratorIncludeDirectoriesPreOrder")]
        const IncludeDirectoriesPreOrder = 1<<4;
/// If provided along with the [`kCFURLEnumeratorDescendRecursively`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/descendrecursively) option, the recursive enumerator returns a directory’s URL after returning the URLs of the directory’s descendents.
///
/// ## Discussion
///
/// A recursive post-order enumerator returns [`kCFURLEnumeratorDirectoryPostOrderSuccess`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorresult/directorypostordersuccess) when it returns a directory’s URL after returning the directory’s descendents.
///
///
        #[doc(alias = "kCFURLEnumeratorIncludeDirectoriesPostOrder")]
        const IncludeDirectoriesPostOrder = 1<<5;
        #[doc(alias = "kCFURLEnumeratorGenerateRelativePathURLs")]
        const GenerateRelativePathURLs = 1<<6;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFURLEnumeratorOptions {
    const ENCODING: Encoding = CFOptionFlags::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFURLEnumeratorOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CFURLEnumerator {
    /// Creates and returns a directory enumerator with provided enumerator behavior options and properties to be prefetched.
    ///
    /// Parameters:
    /// - alloc: The memory allocator to use. If `NULL`, the default allocator is used.
    ///
    /// - directoryURL: The URL of the directory to enumerate.
    ///
    /// - option: A bit array of enumerator behavior options.
    ///
    /// - propertyKeys: An array of file property keys to prefetch for each enumerated URL. Can be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// The created directory enumerator.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Directory enumerators do not descend into subdirectories of `directoryURL` by default. To create a recursive enumerator, include the [`kCFURLEnumeratorDescendRecursively`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/descendrecursively) option in `options`.
    ///
    /// Specifying prefetch properties allows the enumerator to optimize device access by using bulk operations. However, you should not prefetch properties that are not needed, because doing so may degrade performance.
    ///
    /// The created directory enumerator generates URLs with the same type as `directoryURL`. If `directoryURL` is a file reference URL, then enumerated URLs are file reference URLs. If `directoryURL` is a file path URL, then enumerated URLs are file path URLs.
    ///
    /// In some areas of the file system hierarchy, file reference URLs cannot be generated. The enumerator always generates file path URLs for these areas.
    ///
    /// This function ignores the [`kCFURLEnumeratorGenerateFileReferenceURLs`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/generatefilereferenceurls) option.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `directory_url` might not allow `None`.
    /// - `property_keys` generic must be of the correct type.
    /// - `property_keys` might not allow `None`.
    #[doc(alias = "CFURLEnumeratorCreateForDirectoryURL")]
    #[cfg(all(feature = "CFArray", feature = "CFURL"))]
    #[inline]
    pub unsafe fn new_for_directory_url(
        alloc: Option<&CFAllocator>,
        directory_url: Option<&CFURL>,
        option: CFURLEnumeratorOptions,
        property_keys: Option<&CFArray>,
    ) -> Option<CFRetained<CFURLEnumerator>> {
        extern "C-unwind" {
            fn CFURLEnumeratorCreateForDirectoryURL(
                alloc: Option<&CFAllocator>,
                directory_url: Option<&CFURL>,
                option: CFURLEnumeratorOptions,
                property_keys: Option<&CFArray>,
            ) -> Option<NonNull<CFURLEnumerator>>;
        }
        let ret = unsafe {
            CFURLEnumeratorCreateForDirectoryURL(alloc, directory_url, option, property_keys)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates and returns a volume enumerator with provided enumerator behavior options and properties to be prefetched.
    ///
    /// Parameters:
    /// - alloc: The memory allocator to use. If `NULL`, the default allocator is used.
    ///
    /// - option: A bit array of enumerator behavior options.
    ///
    /// - propertyKeys: An array of file property keys to prefetch for each enumerated URL. Can be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// The created volume enumerator.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Volume enumerators generate file path URLs by default. To generate file reference URLs instead, include the [`kCFURLEnumeratorGenerateFileReferenceURLs`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/generatefilereferenceurls) option in `options`.
    ///
    /// Specifying prefetch properties allows the enumerator to optimize device access by using bulk operations. However, you should not prefetch properties that are not needed, because doing so may degrade performance.
    ///
    /// This function ignores the [`kCFURLEnumeratorDescendRecursively`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/descendrecursively) and [`kCFURLEnumeratorSkipPackageContents`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/skippackagecontents) options.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `property_keys` generic must be of the correct type.
    /// - `property_keys` might not allow `None`.
    #[doc(alias = "CFURLEnumeratorCreateForMountedVolumes")]
    #[cfg(feature = "CFArray")]
    #[inline]
    pub unsafe fn new_for_mounted_volumes(
        alloc: Option<&CFAllocator>,
        option: CFURLEnumeratorOptions,
        property_keys: Option<&CFArray>,
    ) -> Option<CFRetained<CFURLEnumerator>> {
        extern "C-unwind" {
            fn CFURLEnumeratorCreateForMountedVolumes(
                alloc: Option<&CFAllocator>,
                option: CFURLEnumeratorOptions,
                property_keys: Option<&CFArray>,
            ) -> Option<NonNull<CFURLEnumerator>>;
        }
        let ret = unsafe { CFURLEnumeratorCreateForMountedVolumes(alloc, option, property_keys) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// Result codes from the [`CFURLEnumeratorGetNextURL`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorgetnexturl(_:_:_:)) function.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFURLEnumeratorResult(pub CFIndex);
impl CFURLEnumeratorResult {
    /// The enumerator was advanced successfully and returned a valid URL.
    #[doc(alias = "kCFURLEnumeratorSuccess")]
    pub const Success: Self = Self(1);
    /// The enumeration is complete.
    #[doc(alias = "kCFURLEnumeratorEnd")]
    pub const End: Self = Self(2);
    /// An error occurred during enumeration. The `error` parameter of the function is populated with error information.
    #[doc(alias = "kCFURLEnumeratorError")]
    pub const Error: Self = Self(3);
    /// The recursive post-order enumerator returned the URL for a directory after having returned the URLs for all of the directory’s descendents.
    #[doc(alias = "kCFURLEnumeratorDirectoryPostOrderSuccess")]
    pub const DirectoryPostOrderSuccess: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFURLEnumeratorResult {
    const ENCODING: Encoding = CFIndex::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFURLEnumeratorResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CFURLEnumerator {
    /// Advances an enumerator to the next URL.
    ///
    /// Parameters:
    /// - enumerator: The enumerator.
    ///
    /// - url: Contains the next URL if this function returns [`kCFURLEnumeratorSuccess`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorresult/success).
    ///
    /// - error: Contains error information if this function returns [`kCFURLEnumeratorError`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorresult/error). Error information is retained and must be released. Can be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// The result of advancing the enumerator.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If this function returns [`kCFURLEnumeratorEnd`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorresult/end), the enumeration has finished.
    ///
    /// A return value of [`kCFURLEnumeratorError`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorresult/error) does not imply that the enumeration has finished.
    ///
    /// If this function returns [`kCFURLEnumeratorError`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorresult/error), the user info dictionary of `error` is populated with the following entries (when possible):
    ///
    /// - The [`kCFErrorUnderlyingErrorKey`](https://developer.apple.com/documentation/corefoundation/kcferrorunderlyingerrorkey) entry is populated with the underlying error if the underlying error is not in the [`kCFErrorDomainCocoa`](https://developer.apple.com/documentation/corefoundation/kcferrordomaincocoa) domain.
    ///
    /// - The [`NSURLErrorKey`](https://developer.apple.com/documentation/foundation/nsurlerrorkey) entry is populated with the URL that caused the error, as a [`CFURLRef`](https://developer.apple.com/documentation/corefoundation/cfurl) object.
    ///
    /// - The [`NSFilePathErrorKey`](https://developer.apple.com/documentation/foundation/nsfilepatherrorkey) entry is populated with the file path that caused the error, as a [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) object.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `url` must be a valid pointer.
    /// - `error` must be a valid pointer.
    #[doc(alias = "CFURLEnumeratorGetNextURL")]
    #[cfg(all(feature = "CFError", feature = "CFURL"))]
    #[inline]
    pub unsafe fn next_url(
        &self,
        url: *mut *const CFURL,
        error: *mut *mut CFError,
    ) -> CFURLEnumeratorResult {
        extern "C-unwind" {
            fn CFURLEnumeratorGetNextURL(
                enumerator: &CFURLEnumerator,
                url: *mut *const CFURL,
                error: *mut *mut CFError,
            ) -> CFURLEnumeratorResult;
        }
        unsafe { CFURLEnumeratorGetNextURL(self, url, error) }
    }

    /// Tells a recursive enumerator not to descend into the directory at the URL that was returned by the most recent call to the [`CFURLEnumeratorGetNextURL`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorgetnexturl(_:_:_:)) function.
    ///
    /// Parameters:
    /// - enumerator: The enumerator.
    ///
    ///
    /// ## Discussion
    ///
    /// A call to this function is ignored in the following cases:
    ///
    /// - The [`CFURLEnumeratorGetNextURL`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorgetnexturl(_:_:_:)) function has never been called with this enumerator.
    ///
    /// - The last URL returned by the [`CFURLEnumeratorGetNextURL`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratorgetnexturl(_:_:_:)) function is not a directory.
    ///
    /// - The enumerator is not a directory enumerator that was created with the [`kCFURLEnumeratorDescendRecursively`](https://developer.apple.com/documentation/corefoundation/cfurlenumeratoroptions/descendrecursively) option.
    ///
    ///
    #[doc(alias = "CFURLEnumeratorSkipDescendents")]
    #[inline]
    pub fn skip_descendents(&self) {
        extern "C-unwind" {
            fn CFURLEnumeratorSkipDescendents(enumerator: &CFURLEnumerator);
        }
        unsafe { CFURLEnumeratorSkipDescendents(self) }
    }

    /// Returns the number of levels a recursive directory enumerator has descended.
    ///
    /// Parameters:
    /// - enumerator: The directory enumerator.
    ///
    ///
    /// ## Return Value
    ///
    /// The current descendent level of the enumerator.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The children of the starting directory are at level 1. Each time a recursive enumerator descends into a subdirectory, it adds 1 to the descendent level. It subtracts 1 from its level when it finishes a subdirectory and continues enumerating the parent directory.
    ///
    ///
    #[doc(alias = "CFURLEnumeratorGetDescendentLevel")]
    #[inline]
    pub fn descendent_level(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFURLEnumeratorGetDescendentLevel(enumerator: &CFURLEnumerator) -> CFIndex;
        }
        unsafe { CFURLEnumeratorGetDescendentLevel(self) }
    }

    /// This function is unimplemented, so it performs no operation.
    ///
    /// Parameters:
    /// - enumerator: The enumerator.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `false`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use the File System Events API to detect changes to the file system. See [File System Events Programming Guide](https://developer.apple.com/library/archive/documentation/Darwin/Conceptual/FSEvents_ProgGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40005289) for more information.
    ///
    ///
    #[doc(alias = "CFURLEnumeratorGetSourceDidChange")]
    #[deprecated = "Use File System Events API instead"]
    #[inline]
    pub fn source_did_change(&self) -> bool {
        extern "C-unwind" {
            fn CFURLEnumeratorGetSourceDidChange(enumerator: &CFURLEnumerator) -> Boolean;
        }
        let ret = unsafe { CFURLEnumeratorGetSourceDidChange(self) };
        ret != 0
    }
}

#[cfg(all(feature = "CFArray", feature = "CFURL"))]
#[deprecated = "renamed to `CFURLEnumerator::new_for_directory_url`"]
#[inline]
pub unsafe extern "C-unwind" fn CFURLEnumeratorCreateForDirectoryURL(
    alloc: Option<&CFAllocator>,
    directory_url: Option<&CFURL>,
    option: CFURLEnumeratorOptions,
    property_keys: Option<&CFArray>,
) -> Option<CFRetained<CFURLEnumerator>> {
    extern "C-unwind" {
        fn CFURLEnumeratorCreateForDirectoryURL(
            alloc: Option<&CFAllocator>,
            directory_url: Option<&CFURL>,
            option: CFURLEnumeratorOptions,
            property_keys: Option<&CFArray>,
        ) -> Option<NonNull<CFURLEnumerator>>;
    }
    let ret = unsafe {
        CFURLEnumeratorCreateForDirectoryURL(alloc, directory_url, option, property_keys)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFArray")]
#[deprecated = "renamed to `CFURLEnumerator::new_for_mounted_volumes`"]
#[inline]
pub unsafe extern "C-unwind" fn CFURLEnumeratorCreateForMountedVolumes(
    alloc: Option<&CFAllocator>,
    option: CFURLEnumeratorOptions,
    property_keys: Option<&CFArray>,
) -> Option<CFRetained<CFURLEnumerator>> {
    extern "C-unwind" {
        fn CFURLEnumeratorCreateForMountedVolumes(
            alloc: Option<&CFAllocator>,
            option: CFURLEnumeratorOptions,
            property_keys: Option<&CFArray>,
        ) -> Option<NonNull<CFURLEnumerator>>;
    }
    let ret = unsafe { CFURLEnumeratorCreateForMountedVolumes(alloc, option, property_keys) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(all(feature = "CFError", feature = "CFURL"))]
    #[deprecated = "renamed to `CFURLEnumerator::next_url`"]
    pub fn CFURLEnumeratorGetNextURL(
        enumerator: &CFURLEnumerator,
        url: *mut *const CFURL,
        error: *mut *mut CFError,
    ) -> CFURLEnumeratorResult;
}

#[deprecated = "renamed to `CFURLEnumerator::skip_descendents`"]
#[inline]
pub extern "C-unwind" fn CFURLEnumeratorSkipDescendents(enumerator: &CFURLEnumerator) {
    extern "C-unwind" {
        fn CFURLEnumeratorSkipDescendents(enumerator: &CFURLEnumerator);
    }
    unsafe { CFURLEnumeratorSkipDescendents(enumerator) }
}

#[deprecated = "renamed to `CFURLEnumerator::descendent_level`"]
#[inline]
pub extern "C-unwind" fn CFURLEnumeratorGetDescendentLevel(
    enumerator: &CFURLEnumerator,
) -> CFIndex {
    extern "C-unwind" {
        fn CFURLEnumeratorGetDescendentLevel(enumerator: &CFURLEnumerator) -> CFIndex;
    }
    unsafe { CFURLEnumeratorGetDescendentLevel(enumerator) }
}

#[deprecated = "renamed to `CFURLEnumerator::source_did_change`"]
#[inline]
pub extern "C-unwind" fn CFURLEnumeratorGetSourceDidChange(enumerator: &CFURLEnumerator) -> bool {
    extern "C-unwind" {
        fn CFURLEnumeratorGetSourceDidChange(enumerator: &CFURLEnumerator) -> Boolean;
    }
    let ret = unsafe { CFURLEnumeratorGetSourceDidChange(enumerator) };
    ret != 0
}
