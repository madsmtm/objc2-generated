//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// The structure returned by [`CFReadStreamGetError`](https://developer.apple.com/documentation/corefoundation/cfreadstreamgeterror(_:)) and [`CFWriteStreamGetError`](https://developer.apple.com/documentation/corefoundation/cfwritestreamgeterror(_:)).
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CFStreamError {
    pub domain: CFIndex,
    pub error: i32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStreamError {
    const ENCODING: Encoding = Encoding::Struct("?", &[<CFIndex>::ENCODING, <i32>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStreamError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_TYPED_EXTENSIBLE_ENUM
pub type CFStreamPropertyKey = CFString;

/// Constants that describe the status of a stream.
///
/// ## Overview
///
/// The `CFStreamStatus` enumeration defines constants that describe the status of a stream. These values are returned by [`CFReadStreamGetStatus`](https://developer.apple.com/documentation/corefoundation/cfreadstreamgetstatus(_:)) and [`CFWriteStreamGetStatus`](https://developer.apple.com/documentation/corefoundation/cfwritestreamgetstatus(_:)).
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CFStreamStatus(pub CFIndex);
impl CFStreamStatus {
    /// The stream is not open for reading or writing.
    #[doc(alias = "kCFStreamStatusNotOpen")]
    pub const NotOpen: Self = Self(0);
    /// The stream is being opened for reading or for writing.
    #[doc(alias = "kCFStreamStatusOpening")]
    pub const Opening: Self = Self(1);
    /// The stream is open.
    #[doc(alias = "kCFStreamStatusOpen")]
    pub const Open: Self = Self(2);
    /// The stream is being read from.
    #[doc(alias = "kCFStreamStatusReading")]
    pub const Reading: Self = Self(3);
    /// The stream is being written to.
    #[doc(alias = "kCFStreamStatusWriting")]
    pub const Writing: Self = Self(4);
    /// There is no more data to read, or no more data can be written.
    #[doc(alias = "kCFStreamStatusAtEnd")]
    pub const AtEnd: Self = Self(5);
    /// The stream is closed.
    #[doc(alias = "kCFStreamStatusClosed")]
    pub const Closed: Self = Self(6);
    /// An error occurred on the stream.
    #[doc(alias = "kCFStreamStatusError")]
    pub const Error: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStreamStatus {
    const ENCODING: Encoding = CFIndex::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStreamStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Defines constants for stream-related events.
///
/// ## Overview
///
/// This enumeration defines constants for stream-related events.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CFStreamEventType(pub CFOptionFlags);
bitflags::bitflags! {
    impl CFStreamEventType: CFOptionFlags {
/// No event has occurred.
        #[doc(alias = "kCFStreamEventNone")]
        const None = 0;
/// The open has completed successfully.
        #[doc(alias = "kCFStreamEventOpenCompleted")]
        const OpenCompleted = 1;
/// The stream has bytes to be read.
        #[doc(alias = "kCFStreamEventHasBytesAvailable")]
        const HasBytesAvailable = 2;
/// The stream can accept bytes for writing.
        #[doc(alias = "kCFStreamEventCanAcceptBytes")]
        const CanAcceptBytes = 4;
/// An error has occurred on the stream.
        #[doc(alias = "kCFStreamEventErrorOccurred")]
        const ErrorOccurred = 8;
/// The end of the stream has been reached.
        #[doc(alias = "kCFStreamEventEndEncountered")]
        const EndEncountered = 16;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStreamEventType {
    const ENCODING: Encoding = CFOptionFlags::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStreamEventType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A structure that contains program-defined data and callbacks with which you can configure a stream’s client behavior.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFStreamClientContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*mut c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*mut c_void) -> *const CFString>,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStreamClientContext {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> *const CFString>>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStreamClientContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// `CFReadStream` provides an interface for reading a byte stream either synchronously or asynchronously. You can create streams that read bytes from a block of memory, a file, or a generic socket. All streams need to be opened, using [`CFReadStreamOpen`](https://developer.apple.com/documentation/corefoundation/cfreadstreamopen(_:)), before reading.
///
/// Use [`CFWriteStreamRef`](https://developer.apple.com/documentation/corefoundation/cfwritestream) for writing byte streams. The CFNetwork framework defines an additional type of stream for reading responses to HTTP requests.
///
/// CFReadStream is “toll-free bridged” with its Cocoa Foundation counterpart, [`NSInputStream`](https://developer.apple.com/documentation/foundation/inputstream). This means that the Core Foundation type is interchangeable in function or method calls with the bridged Foundation object. Therefore, in a method where you see an `NSInputStream *` parameter, you can pass in a CFReadStreamRef, and in a function where you see a CFReadStreamRef parameter, you can pass in an `NSInputStream` instance. Note, however, that you may have either a delegate or callbacks but not both. See [Toll-Free Bridged Types](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677) for more information on toll-free bridging.
///
///
///
/// This is toll-free bridged with `NSInputStream`.
#[doc(alias = "CFReadStreamRef")]
#[repr(C)]
pub struct CFReadStream {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFReadStream {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFReadStream"> for CFReadStream {}
);

///
/// ## Overview
///
/// `CFWriteStream` provides an interface for writing a byte stream either synchronously or asynchronously. You can create streams that write bytes to a block of memory, a file, or a generic socket. All streams need to be opened, using [`CFWriteStreamOpen`](https://developer.apple.com/documentation/corefoundation/cfwritestreamopen(_:)), before writing.
///
/// Use [`CFReadStreamRef`](https://developer.apple.com/documentation/corefoundation/cfreadstream) for reading byte streams, and for the functions, such as [`CFStreamCreatePairWithSocketToHost`](https://developer.apple.com/documentation/corefoundation/cfstreamcreatepairwithsockettohost(_:_:_:_:_:)), that create socket streams).
///
/// `CFWriteStream` is “toll-free bridged” with its Cocoa Foundation counterpart, [`NSOutputStream`](https://developer.apple.com/documentation/foundation/outputstream). This means that the Core Foundation type is interchangeable in function or method calls with the bridged Foundation object. Therefore, in a method where you see an `NSOutputStream *` parameter, you can pass in a `CFWriteStreamRef`, and in a function where you see a `CFWriteStreamRef` parameter, you can pass in an `NSOutputStream` instance. Note, however, that you may have either a delegate or callbacks but not both. See [Toll-Free Bridged Types](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677) for more information on toll-free bridging.
///
///
///
/// This is toll-free bridged with `NSOutputStream`.
#[doc(alias = "CFWriteStreamRef")]
#[repr(C)]
pub struct CFWriteStream {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFWriteStream {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFWriteStream"> for CFWriteStream {}
);

/// Callback invoked when certain types of activity takes place on a readable stream.
///
/// Parameters:
/// - stream: The stream that experienced the event `eventType`.
///
/// - eventType: The event that caused the callback to be called. The possible events are listed in [`CFStreamEventType`](https://developer.apple.com/documentation/corefoundation/cfstreameventtype).
///
/// - clientCallBackInfo: The `info` member of the [`CFStreamClientContext`](https://developer.apple.com/documentation/corefoundation/cfstreamclientcontext) structure that was used when setting the client for `stream`.
///
///
/// ## Discussion
///
/// This callback is called only for the events requested when setting the client with [`CFReadStreamSetClient`](https://developer.apple.com/documentation/corefoundation/cfreadstreamsetclient(_:_:_:_:)).
///
///
pub type CFReadStreamClientCallBack =
    Option<unsafe extern "C-unwind" fn(*mut CFReadStream, CFStreamEventType, *mut c_void)>;

/// Callback invoked when certain types of activity takes place on a writable stream.
///
/// Parameters:
/// - stream: The stream that experienced the event `eventType`.
///
/// - eventType: The event that caused the callback to be called. The possible events are listed in [`CFStreamEventType`](https://developer.apple.com/documentation/corefoundation/cfstreameventtype).
///
/// - clientCallBackInfo: The `info` member of the [`CFStreamClientContext`](https://developer.apple.com/documentation/corefoundation/cfstreamclientcontext) structure that was used when setting the client for `stream`.
///
///
/// ## Discussion
///
/// This callback is called only for the events requested when setting the client with [`CFWriteStreamSetClient`](https://developer.apple.com/documentation/corefoundation/cfwritestreamsetclient(_:_:_:_:)).
///
///
pub type CFWriteStreamClientCallBack =
    Option<unsafe extern "C-unwind" fn(*mut CFWriteStream, CFStreamEventType, *mut c_void)>;

unsafe impl ConcreteType for CFReadStream {
    /// Returns the type identifier the `CFReadStream` opaque type.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the `CFReadStream` opaque type.
    ///
    ///
    #[doc(alias = "CFReadStreamGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFReadStreamGetTypeID() -> CFTypeID;
        }
        unsafe { CFReadStreamGetTypeID() }
    }
}

unsafe impl ConcreteType for CFWriteStream {
    /// Returns the type identifier of all CFWriteStream objects.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the CFWriteStream opaque type.
    ///
    ///
    #[doc(alias = "CFWriteStreamGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFWriteStreamGetTypeID() -> CFTypeID;
        }
        unsafe { CFWriteStreamGetTypeID() }
    }
}

extern "C" {
    /// Value is a `CFData` object that contains all the bytes written to a writable memory stream. You cannot modify this value.
    pub static kCFStreamPropertyDataWritten: Option<&'static CFStreamPropertyKey>;
}

impl CFReadStream {
    /// Creates a readable stream for a block of memory.
    ///
    /// Parameters:
    /// - alloc: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - bytes: The memory buffer to read. This memory must exist for the lifetime of the new stream.
    ///
    /// - length: The size of `bytes`.
    ///
    /// - bytesDeallocator: The allocator to use to deallocate `bytes` when the stream is deallocated. Pass kCFAllocatorNull to prevent the stream from deallocating `bytes`.
    ///
    ///
    /// ## Return Value
    ///
    /// The new read stream, or `NULL` on failure. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You must open the stream, using [`CFReadStreamOpen`](https://developer.apple.com/documentation/corefoundation/cfreadstreamopen(_:)), before reading from it.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `bytes` must be a valid pointer.
    /// - `bytes_deallocator` might not allow `None`.
    #[doc(alias = "CFReadStreamCreateWithBytesNoCopy")]
    #[inline]
    pub unsafe fn with_bytes_no_copy(
        alloc: Option<&CFAllocator>,
        bytes: *const u8,
        length: CFIndex,
        bytes_deallocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFReadStream>> {
        extern "C-unwind" {
            fn CFReadStreamCreateWithBytesNoCopy(
                alloc: Option<&CFAllocator>,
                bytes: *const u8,
                length: CFIndex,
                bytes_deallocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFReadStream>>;
        }
        let ret =
            unsafe { CFReadStreamCreateWithBytesNoCopy(alloc, bytes, length, bytes_deallocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFWriteStream {
    /// Creates a writable stream for a fixed-size block of memory.
    ///
    /// Parameters:
    /// - alloc: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - buffer: The memory buffer into which to write data. This buffer must exist for the lifetime of the stream.
    ///
    /// - bufferCapacity: The size of `buffer` and the maximum number of bytes that can be written.
    ///
    ///
    /// ## Return Value
    ///
    /// A new write stream, or `NULL` on failure. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// When `buffer` is filled after writing `bufferCapacity` bytes, the stream is exhausted and its status becomes [`kCFStreamStatusAtEnd`](https://developer.apple.com/documentation/corefoundation/cfstreamstatus/atend).
    ///
    /// You must open the stream, using [`CFWriteStreamOpen`](https://developer.apple.com/documentation/corefoundation/cfwritestreamopen(_:)), before writing to it.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `buffer` must be a valid pointer.
    #[doc(alias = "CFWriteStreamCreateWithBuffer")]
    #[inline]
    pub unsafe fn with_buffer(
        alloc: Option<&CFAllocator>,
        buffer: *mut u8,
        buffer_capacity: CFIndex,
    ) -> Option<CFRetained<CFWriteStream>> {
        extern "C-unwind" {
            fn CFWriteStreamCreateWithBuffer(
                alloc: Option<&CFAllocator>,
                buffer: *mut u8,
                buffer_capacity: CFIndex,
            ) -> Option<NonNull<CFWriteStream>>;
        }
        let ret = unsafe { CFWriteStreamCreateWithBuffer(alloc, buffer, buffer_capacity) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a writable stream for a growable block of memory.
    ///
    /// Parameters:
    /// - alloc: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - bufferAllocator: The allocator to use to allocate memory for the stream’s memory buffers. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    ///
    /// ## Return Value
    ///
    /// A new write stream. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// New buffers are allocated using `bufferAllocator` as bytes are written to the stream. At any point, you can recover the bytes thus far written by asking for the property kCFStreamPropertyDataWritten with [`CFWriteStreamCopyProperty`](https://developer.apple.com/documentation/corefoundation/cfwritestreamcopyproperty(_:_:)).
    ///
    /// You must open the stream, using [`CFWriteStreamOpen`](https://developer.apple.com/documentation/corefoundation/cfwritestreamopen(_:)), before writing to it.
    ///
    ///
    #[doc(alias = "CFWriteStreamCreateWithAllocatedBuffers")]
    #[inline]
    pub fn with_allocated_buffers(
        alloc: Option<&CFAllocator>,
        buffer_allocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFWriteStream>> {
        extern "C-unwind" {
            fn CFWriteStreamCreateWithAllocatedBuffers(
                alloc: Option<&CFAllocator>,
                buffer_allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFWriteStream>>;
        }
        let ret = unsafe { CFWriteStreamCreateWithAllocatedBuffers(alloc, buffer_allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFReadStream {
    /// Creates a readable stream for a file.
    ///
    /// Parameters:
    /// - alloc: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - fileURL: The URL of the file to read. The URL must use the file scheme.
    ///
    ///
    /// ## Return Value
    ///
    /// The new readable stream object, or `NULL` on failure. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You must open the stream, using [`CFReadStreamOpen`](https://developer.apple.com/documentation/corefoundation/cfreadstreamopen(_:)), before reading from it.
    ///
    ///
    #[doc(alias = "CFReadStreamCreateWithFile")]
    #[cfg(feature = "CFURL")]
    #[inline]
    pub fn with_file(
        alloc: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
    ) -> Option<CFRetained<CFReadStream>> {
        extern "C-unwind" {
            fn CFReadStreamCreateWithFile(
                alloc: Option<&CFAllocator>,
                file_url: Option<&CFURL>,
            ) -> Option<NonNull<CFReadStream>>;
        }
        let ret = unsafe { CFReadStreamCreateWithFile(alloc, file_url) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFWriteStream {
    /// Creates a writable stream for a file.
    ///
    /// Parameters:
    /// - alloc: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - fileURL: The URL of the file to which to write. The URL must use a file scheme.
    ///
    ///
    /// ## Return Value
    ///
    /// The new write stream, or `NULL` on failure. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The stream overwrites an existing file unless you set the kCFStreamPropertyAppendToFile to kCFBooleanTrue with [`CFWriteStreamSetProperty`](https://developer.apple.com/documentation/corefoundation/cfwritestreamsetproperty(_:_:_:)), in which case the stream appends data to the file.
    ///
    /// You must open the stream, using [`CFWriteStreamOpen`](https://developer.apple.com/documentation/corefoundation/cfwritestreamopen(_:)), before writing to it.
    ///
    ///
    #[doc(alias = "CFWriteStreamCreateWithFile")]
    #[cfg(feature = "CFURL")]
    #[inline]
    pub fn with_file(
        alloc: Option<&CFAllocator>,
        file_url: Option<&CFURL>,
    ) -> Option<CFRetained<CFWriteStream>> {
        extern "C-unwind" {
            fn CFWriteStreamCreateWithFile(
                alloc: Option<&CFAllocator>,
                file_url: Option<&CFURL>,
            ) -> Option<NonNull<CFWriteStream>>;
        }
        let ret = unsafe { CFWriteStreamCreateWithFile(alloc, file_url) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

extern "C-unwind" {
    /// Creates a bound pair of read and write streams.
    ///
    /// Parameters:
    /// - alloc: The allocator to use to allocate memory for the new objects. Pass [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) or `NULL` to use the current default allocator.
    ///
    /// - readStream: On return, contains a readable stream. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    /// - writeStream: On return, contains a writable stream. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    /// - transferBufferSize: The size of the buffer, in bytes, used to transfer data from `readStream` to `writeStream`.
    ///
    ///
    /// ## Discussion
    ///
    /// The created streams are bound to one another, such that any data written to `writeStream` is received by `readStream`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `read_stream` must be a valid pointer.
    /// - `write_stream` must be a valid pointer.
    pub fn CFStreamCreateBoundPair(
        alloc: Option<&CFAllocator>,
        read_stream: *mut *mut CFReadStream,
        write_stream: *mut *mut CFWriteStream,
        transfer_buffer_size: CFIndex,
    );
}

extern "C" {
    /// Value is a `CFBoolean` value that indicates whether to append the written data to a file, if it already exists, rather than to replace its contents.
    ///
    /// ## Discussion
    ///
    /// You must set this value before opening the writable file stream. The default value is `kCFBooleanFalse`, indicating that the stream should replace any pre-existing file. You cannot read this value.
    ///
    ///
    pub static kCFStreamPropertyAppendToFile: Option<&'static CFStreamPropertyKey>;
}

extern "C" {
    /// Value is a `CFNumber` object containing the current file offset.
    pub static kCFStreamPropertyFileCurrentOffset: Option<&'static CFStreamPropertyKey>;
}

extern "C" {
    /// Value is a `CFData` object that contains the native handle for a socket stream—of type [`CFSocketNativeHandle`](https://developer.apple.com/documentation/corefoundation/cfsocketnativehandle)—to which the socket stream is connected.
    ///
    /// ## Discussion
    ///
    /// This property is only available for socket streams. You cannot modify this value. You can read this value at any time.
    ///
    ///
    pub static kCFStreamPropertySocketNativeHandle: Option<&'static CFStreamPropertyKey>;
}

extern "C" {
    /// Value is a `CFString` object containing the name of the host to which the socket stream is connected or `NULL` if unknown.
    ///
    /// ## Discussion
    ///
    /// You cannot modify this value. You can read this value at any time.]
    ///
    ///
    pub static kCFStreamPropertySocketRemoteHostName: Option<&'static CFStreamPropertyKey>;
}

extern "C" {
    /// Value is a `CFNumber` object containing the remote port number to which the socket stream is connected or `NULL` if unknown.
    ///
    /// ## Discussion
    ///
    /// You cannot modify this value. You can read this value at any time.]
    ///
    ///
    pub static kCFStreamPropertySocketRemotePortNumber: Option<&'static CFStreamPropertyKey>;
}

extern "C" {
    /// The error code is a SOCKS proxy error.
    pub static kCFStreamErrorDomainSOCKS: c_int;
}

extern "C" {
    /// SOCKS proxy property key.
    ///
    /// ## Discussion
    ///
    /// To set a `CFStream` object to use a SOCKS proxy, call [`CFReadStreamSetProperty`](https://developer.apple.com/documentation/corefoundation/cfreadstreamsetproperty(_:_:_:)) or [`CFWriteStreamSetProperty`](https://developer.apple.com/documentation/corefoundation/cfwritestreamsetproperty(_:_:_:)) with the property name set to `kCFStreamPropertySOCKSProxy` and its value set to a `CFDictionary` object having at minimum a `kCFStreamPropertySOCKSProxyHost` key and a `kCFStreamPropertySOCKSProxyPort` key. For information on these keys, see [CFStream SOCKS Proxy Key Constants](https://developer.apple.com/documentation/corefoundation/cfstream-socks-proxy-key-constants). SystemConfiguration returns a CFDictionary for SOCKS proxies that is usable without modification.
    ///
    ///
    pub static kCFStreamPropertySOCKSProxy: &'static CFString;
}

extern "C" {
    /// Constant for the SOCKS proxy host key.
    ///
    /// ## Discussion
    ///
    /// This key contains a CFString object that represents the SOCKS proxy host. Defined to match `kSCPropNetProxiesSOCKSProxy`.
    ///
    ///
    pub static kCFStreamPropertySOCKSProxyHost: &'static CFString;
}

extern "C" {
    /// Constant for the SOCKS proxy host port key.
    ///
    /// ## Discussion
    ///
    /// This key contains a `CFNumberRef` object of type `kCFNumberSInt32Type` whose value represents the port on which the proxy listens.
    ///
    ///
    pub static kCFStreamPropertySOCKSProxyPort: &'static CFString;
}

extern "C" {
    /// Constant for the SOCKS version key.
    ///
    /// ## Discussion
    ///
    /// Its value must be `kCFStreamSocketSOCKSVersion4` or `kCFStreamSocketSOCKSVersion5` to set SOCKS4 or SOCKS5, respectively. If this key is not present, SOCKS5 is used by default.
    ///
    ///
    pub static kCFStreamPropertySOCKSVersion: &'static CFString;
}

extern "C" {
    /// Constant used in the `kCFStreamSockerSOCKSVersion` key to specify SOCKS4 as the SOCKS version for the stream.
    pub static kCFStreamSocketSOCKSVersion4: &'static CFString;
}

extern "C" {
    /// Constant used in the `kCFStreamSOCKSVersion` key to specify SOCKS5 as the SOCKS version for the stream.
    pub static kCFStreamSocketSOCKSVersion5: &'static CFString;
}

extern "C" {
    /// Constant for the key required to set a user name.
    ///
    /// ## Discussion
    ///
    /// The value is a `CFString` object containing the user’s name.
    ///
    ///
    pub static kCFStreamPropertySOCKSUser: &'static CFString;
}

extern "C" {
    /// Constant for the key required to set a user’s password.
    ///
    /// ## Discussion
    ///
    /// The value is a `CFString` object containing the user’s password.
    ///
    ///
    pub static kCFStreamPropertySOCKSPassword: &'static CFString;
}

extern "C" {
    /// The error code is an SSL error code as defined in `Security/SecureTransport.h`.
    pub static kCFStreamErrorDomainSSL: c_int;
}

extern "C" {
    /// Socket Security Level property key.
    ///
    /// ## Discussion
    ///
    /// See [CFStream Socket Security Level Constants](https://developer.apple.com/documentation/corefoundation/cfstream-socket-security-level-constants) for specific security level constants to use.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  If you set this key, you must do so before setting any other SSL options, such as `kCFStreamPropertySSLSettings`.
    ///
    ///
    ///
    /// </div>
    ///
    pub static kCFStreamPropertySocketSecurityLevel: &'static CFString;
}

extern "C" {
    /// Specifies that no security level be set.
    pub static kCFStreamSocketSecurityLevelNone: &'static CFString;
}

extern "C" {
    /// Specifies that SSL version 2 be set as the security protocol for a socket stream.
    #[deprecated]
    pub static kCFStreamSocketSecurityLevelSSLv2: &'static CFString;
}

extern "C" {
    /// Specifies that SSL version 3 be set as the security protocol for a socket stream pair.
    ///
    /// ## Discussion
    ///
    /// If SSL version 3 is not available, specifies that SSL version 2 be set as the security protocol for a socket stream.
    ///
    ///
    #[deprecated]
    pub static kCFStreamSocketSecurityLevelSSLv3: &'static CFString;
}

extern "C" {
    /// Specifies that TLS version 1 be set as the security protocol for a socket stream.
    pub static kCFStreamSocketSecurityLevelTLSv1: &'static CFString;
}

extern "C" {
    /// Specifies that the highest level security protocol that can be negotiated be set as the security protocol for a socket stream.
    pub static kCFStreamSocketSecurityLevelNegotiatedSSL: &'static CFString;
}

extern "C" {
    /// Should Close Native Socket property key.
    ///
    /// ## Discussion
    ///
    /// If set to `kCFBooleanTrue`, the stream will close and release the underlying native socket when the stream is released. If set to `kCFBooleanFalse`, the stream will not close and release the underlying native socket when the stream is released. If a stream is created with a native socket, the default value of this property is `kCFBooleanFalse`. This property is only available for socket streams. It can be set by calling [`CFReadStreamSetProperty`](https://developer.apple.com/documentation/corefoundation/cfreadstreamsetproperty(_:_:_:)) and [`CFWriteStreamSetProperty`](https://developer.apple.com/documentation/corefoundation/cfwritestreamsetproperty(_:_:_:)), and it can be copied by [`CFReadStreamCopyProperty`](https://developer.apple.com/documentation/corefoundation/cfreadstreamcopyproperty(_:_:)) and [`CFWriteStreamCopyProperty`](https://developer.apple.com/documentation/corefoundation/cfwritestreamcopyproperty(_:_:)).
    ///
    ///
    pub static kCFStreamPropertyShouldCloseNativeSocket: &'static CFString;
}

extern "C-unwind" {
    /// Creates readable and writable streams connected to a socket.
    ///
    /// Parameters:
    /// - alloc: The allocator to use to allocate memory for the new objects. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the current default allocator.
    ///
    /// - sock: The pre-existing (and already connected) socket which the socket streams should use.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  By default, your app is responsible for closing this socket after you close both streams. If you want CFNetwork to take ownership of the socket, set the [`kCFStreamPropertyShouldCloseNativeSocket`](https://developer.apple.com/documentation/corefoundation/kcfstreampropertyshouldclosenativesocket) property of the stream to [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue).
    ///
    ///
    ///
    /// </div>
    /// - readStream: Upon return, a readable stream connected to the socket address in `signature`. If you pass `NULL`, this function will not create a readable stream. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    /// - writeStream: Upon return, a writable stream connected to the socket address in `signature`. If you pass `NULL`, this function will not create a writable stream. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    /// ## Discussion
    ///
    /// Most properties are shared by both streams. Setting a shared property for one stream automatically sets the property for the other.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `read_stream` must be a valid pointer.
    /// - `write_stream` must be a valid pointer.
    #[cfg(feature = "CFSocket")]
    #[deprecated = "Use nw_connection_t in Network framework instead"]
    pub fn CFStreamCreatePairWithSocket(
        alloc: Option<&CFAllocator>,
        sock: CFSocketNativeHandle,
        read_stream: *mut *mut CFReadStream,
        write_stream: *mut *mut CFWriteStream,
    );
}

extern "C-unwind" {
    /// Creates readable and writable streams connected to a TCP/IP port of a particular host.
    ///
    /// Parameters:
    /// - alloc: The allocator to use to allocate memory for the `CFReadStream` and `CFWriteStream` objects. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the current default allocator.
    ///
    /// - host: The hostname to which the socket streams should connect. The host can be specified using an IPv4 or IPv6 address or a fully qualified DNS hostname.
    ///
    /// - port: The TCP port number to which the socket streams should connect.
    ///
    /// - readStream: Upon return, a readable stream connected to the socket address in `port`. If you pass `NULL`, this function will not create a readable stream. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    /// - writeStream: Upon return, a writable stream connected to the socket address in `port`. If you pass `NULL`, this function will not create a writable stream. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    /// ## Discussion
    ///
    /// The streams do not create a socket, resolve the hostname, or connect to the remote host until you open one of the streams.
    ///
    /// Most properties are shared by both streams. Setting a shared property for one stream automatically sets the property for the other.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `host` might not allow `None`.
    /// - `read_stream` must be a valid pointer.
    /// - `write_stream` must be a valid pointer.
    #[deprecated = "Use nw_connection_t in Network framework instead"]
    pub fn CFStreamCreatePairWithSocketToHost(
        alloc: Option<&CFAllocator>,
        host: Option<&CFString>,
        port: u32,
        read_stream: *mut *mut CFReadStream,
        write_stream: *mut *mut CFWriteStream,
    );
}

extern "C-unwind" {
    /// Creates readable and writable streams connected to a socket.
    ///
    /// Parameters:
    /// - alloc: The allocator to use to allocate memory for the new objects. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the current default allocator.
    ///
    /// - signature: A [`CFSocketSignature`](https://developer.apple.com/documentation/corefoundation/cfsocketsignature) structure identifying the communication protocol and address to which the socket streams should connect.
    ///
    /// - readStream: On return, a readable stream connected to the socket address in `signature`. If you pass `NULL`, this function will not create a readable stream. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    /// - writeStream: On return, a writable stream connected to the socket address in `signature`. If you pass `NULL`, this function will not create a writable stream. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    /// ## Discussion
    ///
    /// The streams do not create a socket or connect to the remote host until you open one of the streams.
    ///
    /// Most properties are shared by both streams. Setting a shared property for one stream automatically sets the property for the other.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `alloc` might not allow `None`.
    /// - `signature` must be a valid pointer.
    /// - `read_stream` must be a valid pointer.
    /// - `write_stream` must be a valid pointer.
    #[cfg(all(feature = "CFData", feature = "CFSocket"))]
    #[deprecated = "Use nw_connection_t in Network framework instead"]
    pub fn CFStreamCreatePairWithPeerSocketSignature(
        alloc: Option<&CFAllocator>,
        signature: *const CFSocketSignature,
        read_stream: *mut *mut CFReadStream,
        write_stream: *mut *mut CFWriteStream,
    );
}

impl CFReadStream {
    /// Returns the current state of a stream.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The current state of `stream`. See [`CFStreamStatus`](https://developer.apple.com/documentation/corefoundation/cfstreamstatus) for the list of possible states.
    ///
    ///
    #[doc(alias = "CFReadStreamGetStatus")]
    #[inline]
    pub fn status(&self) -> CFStreamStatus {
        extern "C-unwind" {
            fn CFReadStreamGetStatus(stream: &CFReadStream) -> CFStreamStatus;
        }
        unsafe { CFReadStreamGetStatus(self) }
    }
}

impl CFWriteStream {
    /// Returns the current state of a stream.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The current state of `stream`. See [`CFStreamStatus`](https://developer.apple.com/documentation/corefoundation/cfstreamstatus) for the list of possible states.
    ///
    ///
    #[doc(alias = "CFWriteStreamGetStatus")]
    #[inline]
    pub fn status(&self) -> CFStreamStatus {
        extern "C-unwind" {
            fn CFWriteStreamGetStatus(stream: &CFWriteStream) -> CFStreamStatus;
        }
        unsafe { CFWriteStreamGetStatus(self) }
    }
}

impl CFReadStream {
    /// Returns the error associated with a stream.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A CFError object that describes the current problem with stream, or `NULL` if there is no error. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    #[doc(alias = "CFReadStreamCopyError")]
    #[cfg(feature = "CFError")]
    #[inline]
    pub fn copy_error(&self) -> Option<CFRetained<CFError>> {
        extern "C-unwind" {
            fn CFReadStreamCopyError(stream: &CFReadStream) -> Option<NonNull<CFError>>;
        }
        let ret = unsafe { CFReadStreamCopyError(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFWriteStream {
    /// Returns the error associated with a stream.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A CFError object that describes the current problem with stream, or `NULL` if there is no error. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    #[doc(alias = "CFWriteStreamCopyError")]
    #[cfg(feature = "CFError")]
    #[inline]
    pub fn copy_error(&self) -> Option<CFRetained<CFError>> {
        extern "C-unwind" {
            fn CFWriteStreamCopyError(stream: &CFWriteStream) -> Option<NonNull<CFError>>;
        }
        let ret = unsafe { CFWriteStreamCopyError(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFReadStream {
    /// Opens a stream for reading.
    ///
    /// Parameters:
    /// - stream: The stream to open.
    ///
    ///
    /// ## Return Value
    ///
    /// `TRUE` if `stream` was successfully opened, `FALSE` otherwise. If `stream` is not in the [`kCFStreamStatusNotOpen`](https://developer.apple.com/documentation/corefoundation/cfstreamstatus/notopen) state, this function returns `FALSE`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Opening a stream causes it to reserve all the system resources it requires. If the stream can open in the background without blocking, this function always returns `true`. To learn when a background open operation completes, you can either schedule the stream into a run loop with [`CFReadStreamScheduleWithRunLoop`](https://developer.apple.com/documentation/corefoundation/cfreadstreamschedulewithrunloop(_:_:_:)) and wait for the stream’s client (set with [`CFReadStreamSetClient`](https://developer.apple.com/documentation/corefoundation/cfreadstreamsetclient(_:_:_:_:))) to be notified or you can poll the stream using [`CFReadStreamGetStatus`](https://developer.apple.com/documentation/corefoundation/cfreadstreamgetstatus(_:)), waiting for a status of [`kCFStreamStatusOpen`](https://developer.apple.com/documentation/corefoundation/cfstreamstatus/open) or [`kCFStreamStatusError`](https://developer.apple.com/documentation/corefoundation/cfstreamstatus/error).
    ///
    /// You do not need to wait until a stream has finished opening in the background before calling the [`CFReadStreamRead`](https://developer.apple.com/documentation/corefoundation/cfreadstreamread(_:_:_:)) function. The read operation will simply block until the open has completed.
    ///
    ///
    #[doc(alias = "CFReadStreamOpen")]
    #[inline]
    pub fn open(&self) -> bool {
        extern "C-unwind" {
            fn CFReadStreamOpen(stream: &CFReadStream) -> Boolean;
        }
        let ret = unsafe { CFReadStreamOpen(self) };
        ret != 0
    }
}

impl CFWriteStream {
    /// Opens a stream for writing.
    ///
    /// Parameters:
    /// - stream: The stream to open.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if `stream` was successfully opened, `false` otherwise. If `stream` is not in the [`kCFStreamStatusNotOpen`](https://developer.apple.com/documentation/corefoundation/cfstreamstatus/notopen) state, this function returns `false`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Opening a stream causes it to reserve all the system resources it requires. If the stream can open in the background without blocking, this function always returns `true`. To learn when a background open operation completes, you can either schedule the stream into a run loop with [`CFWriteStreamScheduleWithRunLoop`](https://developer.apple.com/documentation/corefoundation/cfwritestreamschedulewithrunloop(_:_:_:)) and wait for the stream’s client (set with [`CFWriteStreamSetClient`](https://developer.apple.com/documentation/corefoundation/cfwritestreamsetclient(_:_:_:_:))) to be notified or you can poll the stream using [`CFWriteStreamGetStatus`](https://developer.apple.com/documentation/corefoundation/cfwritestreamgetstatus(_:)), waiting for a status of [`kCFStreamStatusOpen`](https://developer.apple.com/documentation/corefoundation/cfstreamstatus/open) or [`kCFStreamStatusError`](https://developer.apple.com/documentation/corefoundation/cfstreamstatus/error).
    ///
    ///
    #[doc(alias = "CFWriteStreamOpen")]
    #[inline]
    pub fn open(&self) -> bool {
        extern "C-unwind" {
            fn CFWriteStreamOpen(stream: &CFWriteStream) -> Boolean;
        }
        let ret = unsafe { CFWriteStreamOpen(self) };
        ret != 0
    }
}

impl CFReadStream {
    /// Closes a readable stream.
    ///
    /// Parameters:
    /// - stream: The stream to close.
    ///
    ///
    /// ## Discussion
    ///
    /// This function terminates the flow of bytes and releases any system resources required by the stream. The stream is removed from any run loops in which it was scheduled. Once closed, the stream cannot be reopened.
    ///
    ///
    #[doc(alias = "CFReadStreamClose")]
    #[inline]
    pub fn close(&self) {
        extern "C-unwind" {
            fn CFReadStreamClose(stream: &CFReadStream);
        }
        unsafe { CFReadStreamClose(self) }
    }
}

impl CFWriteStream {
    /// Closes a writable stream.
    ///
    /// Parameters:
    /// - stream: The stream to close.
    ///
    ///
    /// ## Discussion
    ///
    /// This function terminates the flow of bytes and releases any system resources required by the stream. The stream is removed from any run loops in which it was scheduled. Once closed, the stream cannot be reopened.
    ///
    ///
    #[doc(alias = "CFWriteStreamClose")]
    #[inline]
    pub fn close(&self) {
        extern "C-unwind" {
            fn CFWriteStreamClose(stream: &CFWriteStream);
        }
        unsafe { CFWriteStreamClose(self) }
    }
}

impl CFReadStream {
    /// Returns a Boolean value that indicates whether a readable stream has data that can be read without blocking.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// `TRUE` if data can be read from `stream` without blocking, otherwise `FALSE`. If `stream` cannot tell if data is available without actually trying to read the data, this function returns `TRUE`.
    ///
    ///
    #[doc(alias = "CFReadStreamHasBytesAvailable")]
    #[inline]
    pub fn has_bytes_available(&self) -> bool {
        extern "C-unwind" {
            fn CFReadStreamHasBytesAvailable(stream: &CFReadStream) -> Boolean;
        }
        let ret = unsafe { CFReadStreamHasBytesAvailable(self) };
        ret != 0
    }

    /// Reads data from a readable stream.
    ///
    /// Parameters:
    /// - stream: The stream from which to read.
    ///
    /// - buffer: The buffer into which to place the data.
    ///
    /// - bufferLength: The size of `buffer` and the maximum number of bytes to read.
    ///
    ///
    /// ## Return Value
    ///
    /// The number of bytes read; `0` if the stream has reached its end; or `-1` if either the stream is not open or an error occurs.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If `stream` is in the process of opening, this function waits until it has completed. This function blocks until at least one byte is available; it does not block until `buffer` is filled. To avoid blocking, call this function only if [`CFReadStreamHasBytesAvailable`](https://developer.apple.com/documentation/corefoundation/cfreadstreamhasbytesavailable(_:)) returns `TRUE` or after the stream’s client (set with [`CFReadStreamSetClient`](https://developer.apple.com/documentation/corefoundation/cfreadstreamsetclient(_:_:_:_:))) is notified of a [`kCFStreamEventHasBytesAvailable`](https://developer.apple.com/documentation/corefoundation/cfstreameventtype/hasbytesavailable) event.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `buffer` must be a valid pointer.
    #[doc(alias = "CFReadStreamRead")]
    #[inline]
    pub unsafe fn read(&self, buffer: *mut u8, buffer_length: CFIndex) -> CFIndex {
        extern "C-unwind" {
            fn CFReadStreamRead(
                stream: &CFReadStream,
                buffer: *mut u8,
                buffer_length: CFIndex,
            ) -> CFIndex;
        }
        unsafe { CFReadStreamRead(self, buffer, buffer_length) }
    }

    /// Returns a pointer to a stream’s internal buffer of unread data, if possible.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    /// - maxBytesToRead: The maximum number of bytes to read. If greater than `0`, `maxBytesToRead` limits the number of bytes read; if `0` or less, all available bytes are read.
    ///
    /// - numBytesRead: On return, contains the length of returned buffer. If `stream` is not open or has encountered an error, `numBytesRead` is set to `-1`.
    ///
    ///
    /// ## Return Value
    ///
    /// A pointer to the internal buffer of unread data for `stream`, if possible; `NULL` otherwise. The buffer is good only until the next stream operation called on the stream. You should neither change the contents of the returned buffer nor attempt to deallocate the buffer; it is still owned by the stream. The bytes returned in the buffer are considered read from the stream.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `num_bytes_read` must be a valid pointer.
    #[doc(alias = "CFReadStreamGetBuffer")]
    #[inline]
    pub unsafe fn buffer(
        &self,
        max_bytes_to_read: CFIndex,
        num_bytes_read: *mut CFIndex,
    ) -> *const u8 {
        extern "C-unwind" {
            fn CFReadStreamGetBuffer(
                stream: &CFReadStream,
                max_bytes_to_read: CFIndex,
                num_bytes_read: *mut CFIndex,
            ) -> *const u8;
        }
        unsafe { CFReadStreamGetBuffer(self, max_bytes_to_read, num_bytes_read) }
    }
}

impl CFWriteStream {
    /// Returns whether a writable stream can accept new data without blocking.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if data can be written to `stream` without blocking, `false` otherwise. If `stream` cannot tell if data can be written without actually trying to write the data, this function returns `true`.
    ///
    ///
    #[doc(alias = "CFWriteStreamCanAcceptBytes")]
    #[inline]
    pub fn can_accept_bytes(&self) -> bool {
        extern "C-unwind" {
            fn CFWriteStreamCanAcceptBytes(stream: &CFWriteStream) -> Boolean;
        }
        let ret = unsafe { CFWriteStreamCanAcceptBytes(self) };
        ret != 0
    }

    /// Writes data to a writable stream.
    ///
    /// Parameters:
    /// - stream: The stream to which to write.
    ///
    /// - buffer: The buffer holding the data to write.
    ///
    /// - bufferLength: The number of bytes from `buffer` to write.
    ///
    ///
    /// ## Return Value
    ///
    /// The number of bytes successfully written, `0` if the stream has been filled to capacity (for fixed-length streams), or `-1` if either the stream is not open or an error occurs.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If `stream` is in the process of opening, this function waits until it has completed. If the stream is not full, this call blocks until at least one byte is written; it does not block until all the bytes in `buffer` is written. To avoid blocking, call this function only if [`CFWriteStreamCanAcceptBytes`](https://developer.apple.com/documentation/corefoundation/cfwritestreamcanacceptbytes(_:)) returns `true` or after the stream’s client (set with [`CFWriteStreamSetClient`](https://developer.apple.com/documentation/corefoundation/cfwritestreamsetclient(_:_:_:_:))) is notified of a [`kCFStreamEventCanAcceptBytes`](https://developer.apple.com/documentation/corefoundation/cfstreameventtype/canacceptbytes) event.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `buffer` must be a valid pointer.
    #[doc(alias = "CFWriteStreamWrite")]
    #[inline]
    pub unsafe fn write(&self, buffer: *const u8, buffer_length: CFIndex) -> CFIndex {
        extern "C-unwind" {
            fn CFWriteStreamWrite(
                stream: &CFWriteStream,
                buffer: *const u8,
                buffer_length: CFIndex,
            ) -> CFIndex;
        }
        unsafe { CFWriteStreamWrite(self, buffer, buffer_length) }
    }
}

impl CFReadStream {
    /// Returns the value of a property for a stream.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    /// - propertyName: The name of the stream property to obtain. The available properties for standard Core Foundation streams are listed in [CFStream](https://developer.apple.com/documentation/corefoundation/cfstream).
    ///
    ///
    /// ## Return Value
    ///
    /// The value of the property `propertyName`. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Each type of stream can define a set of properties that either describe or configure individual streams. A property can be any information about a stream, other than the actual data the stream handles. Examples include the headers from an HTTP transmission, the expected number of bytes, file permission information, and so on. Use [`CFReadStreamSetProperty`](https://developer.apple.com/documentation/corefoundation/cfreadstreamsetproperty(_:_:_:)) to modify the value of a property, although some properties are read-only.
    ///
    ///
    #[doc(alias = "CFReadStreamCopyProperty")]
    #[inline]
    pub fn property(
        &self,
        property_name: Option<&CFStreamPropertyKey>,
    ) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn CFReadStreamCopyProperty(
                stream: &CFReadStream,
                property_name: Option<&CFStreamPropertyKey>,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { CFReadStreamCopyProperty(self, property_name) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFWriteStream {
    /// Returns the value of a property for a stream.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    /// - propertyName: The name of the stream property to obtain. The available properties for standard Core Foundation streams are listed in Stream Properties.
    ///
    ///
    /// ## Return Value
    ///
    /// The value of the property `propertyName`. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Each type of stream can define a set of properties that either describe or configure individual streams. A property can be any interesting information about a stream. Examples include the headers from an HTTP transmission, the expected number of bytes, file permission information, and so on. Use [`CFWriteStreamSetProperty`](https://developer.apple.com/documentation/corefoundation/cfwritestreamsetproperty(_:_:_:)) to modify the value of a property, although some properties are read-only.
    ///
    ///
    #[doc(alias = "CFWriteStreamCopyProperty")]
    #[inline]
    pub fn property(
        &self,
        property_name: Option<&CFStreamPropertyKey>,
    ) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn CFWriteStreamCopyProperty(
                stream: &CFWriteStream,
                property_name: Option<&CFStreamPropertyKey>,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { CFWriteStreamCopyProperty(self, property_name) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFReadStream {
    /// Sets the value of a property for a stream.
    ///
    /// Parameters:
    /// - stream: The stream to modify.
    ///
    /// - propertyName: The name of the property to set. The available properties for standard Core Foundation streams are listed in [CFStream](https://developer.apple.com/documentation/corefoundation/cfstream).
    ///
    /// - propertyValue: The value to which to set the property `propertyName` for `stream`. The allowed data type of the value depends on the property being set.
    ///
    ///
    /// ## Return Value
    ///
    /// `TRUE` if `stream` recognizes and accepts the given property-value pair, otherwise`FALSE`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Each type of stream can define a set of properties that either describe or configure individual streams. A property can be any interesting information about a stream. Examples include the headers from an HTTP transmission, the expected number of bytes, file permission information, and so on. Properties that can be set configure the behavior of the stream and may be modifiable only at particular times, such as before the stream has been opened. (In fact, you should assume that you can set properties only before opening the stream, unless otherwise noted.) To read the value of a property use [`CFReadStreamCopyProperty`](https://developer.apple.com/documentation/corefoundation/cfreadstreamcopyproperty(_:_:)), although some properties are write-only.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `property_name` might not allow `None`.
    /// - `property_value` should be of the correct type.
    /// - `property_value` might not allow `None`.
    #[doc(alias = "CFReadStreamSetProperty")]
    #[inline]
    pub unsafe fn set_property(
        &self,
        property_name: Option<&CFStreamPropertyKey>,
        property_value: Option<&CFType>,
    ) -> bool {
        extern "C-unwind" {
            fn CFReadStreamSetProperty(
                stream: &CFReadStream,
                property_name: Option<&CFStreamPropertyKey>,
                property_value: Option<&CFType>,
            ) -> Boolean;
        }
        let ret = unsafe { CFReadStreamSetProperty(self, property_name, property_value) };
        ret != 0
    }
}

impl CFWriteStream {
    /// Sets the value of a property for a stream.
    ///
    /// Parameters:
    /// - stream: The stream to modify.
    ///
    /// - propertyName: The name of the property to set. The available properties for standard Core Foundation streams are listed in Stream Properties.
    ///
    /// - propertyValue: The value to which to set the property `propertyName` for `stream`. The allowed data type of the value depends on the property being set.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if `stream` recognizes and accepts the given property-value pair, `false` otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Each type of stream can define a set of properties that either describe or configure individual streams. A property can be any interesting information about a stream. Examples include the headers from an HTTP transmission, the expected number of bytes, file permission information, and so on. Properties that can be set configure the behavior of the stream and may be modifiable only at particular times, such as before the stream has been opened. (In fact, you should assume that you can set properties only before opening the stream, unless otherwise noted.) To read the value of a property use [`CFWriteStreamCopyProperty`](https://developer.apple.com/documentation/corefoundation/cfwritestreamcopyproperty(_:_:)), although some properties are write-only.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `property_name` might not allow `None`.
    /// - `property_value` should be of the correct type.
    /// - `property_value` might not allow `None`.
    #[doc(alias = "CFWriteStreamSetProperty")]
    #[inline]
    pub unsafe fn set_property(
        &self,
        property_name: Option<&CFStreamPropertyKey>,
        property_value: Option<&CFType>,
    ) -> bool {
        extern "C-unwind" {
            fn CFWriteStreamSetProperty(
                stream: &CFWriteStream,
                property_name: Option<&CFStreamPropertyKey>,
                property_value: Option<&CFType>,
            ) -> Boolean;
        }
        let ret = unsafe { CFWriteStreamSetProperty(self, property_name, property_value) };
        ret != 0
    }
}

impl CFReadStream {
    /// Assigns a client to a stream, which receives callbacks when certain events occur.
    ///
    /// Parameters:
    /// - stream: The stream to modify.
    ///
    /// - streamEvents: The set of events for which the client should receive callbacks. The events are listed in [`CFStreamEventType`](https://developer.apple.com/documentation/corefoundation/cfstreameventtype). If you pass [`kCFStreamEventNone`](https://developer.apple.com/documentation/corefoundation/cfstreameventtype/kcfstreameventnone), the current client for `stream` is removed.
    ///
    /// - clientCB: The client callback function to be called when one of the events requested in `streamEvents` occurs. If `NULL`, the current client for `stream` is removed.
    ///
    /// - clientContext: A structure holding contextual information for the stream client. The function copies the information out of the structure, so the memory pointed to by `clientContext` does not need to persist beyond the function call. If `NULL`, the current client for `stream` is removed.
    ///
    ///
    /// ## Return Value
    ///
    /// `TRUE` if the stream supports asynchronous notification, otherwise `FALSE`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// To avoid polling and blocking, you can register a client to hear about interesting events that occur on a stream. Only one client per stream is allowed; registering a new client replaces the previous one.
    ///
    /// Once you have set a client, you need to schedule the stream in a run loop using [`CFReadStreamScheduleWithRunLoop`](https://developer.apple.com/documentation/corefoundation/cfreadstreamschedulewithrunloop(_:_:_:)) so that the client can receive the asynchronous notifications. You can schedule each stream in multiple run loops (for example, if you are using a thread pool). It is the caller’s responsibility to ensure that at least one of the scheduled run loops is being run, otherwise the callback cannot be called.
    ///
    /// Although all Core Foundation streams currently support asynchronous notification, future stream types may not. If a stream does not support asynchronous notification, this function returns `false`. Typically, such streams never block for device I/O (for example, a stream reading memory) and don’t benefit from asynchronous notification.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `client_cb` must be implemented correctly.
    /// - `client_context` must be a valid pointer.
    #[doc(alias = "CFReadStreamSetClient")]
    #[inline]
    pub unsafe fn set_client(
        &self,
        stream_events: CFOptionFlags,
        client_cb: CFReadStreamClientCallBack,
        client_context: *mut CFStreamClientContext,
    ) -> bool {
        extern "C-unwind" {
            fn CFReadStreamSetClient(
                stream: &CFReadStream,
                stream_events: CFOptionFlags,
                client_cb: CFReadStreamClientCallBack,
                client_context: *mut CFStreamClientContext,
            ) -> Boolean;
        }
        let ret = unsafe { CFReadStreamSetClient(self, stream_events, client_cb, client_context) };
        ret != 0
    }
}

impl CFWriteStream {
    /// Assigns a client to a stream, which receives callbacks when certain events occur.
    ///
    /// Parameters:
    /// - stream: The stream to modify.
    ///
    /// - streamEvents: The set of events for which the client should receive callbacks. The events are listed in [`CFStreamEventType`](https://developer.apple.com/documentation/corefoundation/cfstreameventtype). If you pass [`kCFStreamEventNone`](https://developer.apple.com/documentation/corefoundation/cfstreameventtype/kcfstreameventnone), the current client for `stream` is removed.
    ///
    /// - clientCB: The client callback function to call when one of the events requested in `streamEvents` occurs. If `NULL`, the current client for `stream` is removed.
    ///
    /// - clientContext: A structure holding contextual information for the stream client. The function copies the information out of the structure, so the memory pointed to by `clientContext` does not need to persist beyond the function call. If `NULL`, the current client for `stream` is removed.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if the stream supports asynchronous notification, `false` otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// To avoid polling and blocking, you can register a client to hear about interesting events that occur on a stream. Only one client per stream is allowed; registering a new client replaces the previous one.
    ///
    /// Once you have set a client, you need to schedule the stream in a run loop using [`CFWriteStreamScheduleWithRunLoop`](https://developer.apple.com/documentation/corefoundation/cfwritestreamschedulewithrunloop(_:_:_:)) so that the client can receive the asynchronous notifications. You can schedule each stream in multiple run loops (for example, if you are using a thread pool). It is the caller’s responsibility to ensure that at least one of the scheduled run loops is being run, otherwise the callback cannot be called.
    ///
    /// Although all Core Foundation streams currently support asynchronous notification, future stream types may not. If a stream does not support asynchronous notification, this function returns `false`. Typically, such streams never block for device I/O (for example, a stream writing to memory) and don’t benefit from asynchronous notification.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `client_cb` must be implemented correctly.
    /// - `client_context` must be a valid pointer.
    #[doc(alias = "CFWriteStreamSetClient")]
    #[inline]
    pub unsafe fn set_client(
        &self,
        stream_events: CFOptionFlags,
        client_cb: CFWriteStreamClientCallBack,
        client_context: *mut CFStreamClientContext,
    ) -> bool {
        extern "C-unwind" {
            fn CFWriteStreamSetClient(
                stream: &CFWriteStream,
                stream_events: CFOptionFlags,
                client_cb: CFWriteStreamClientCallBack,
                client_context: *mut CFStreamClientContext,
            ) -> Boolean;
        }
        let ret = unsafe { CFWriteStreamSetClient(self, stream_events, client_cb, client_context) };
        ret != 0
    }
}

impl CFReadStream {
    /// Schedules a stream into a run loop.
    ///
    /// Parameters:
    /// - stream: The stream to schedule.
    ///
    /// - runLoop: The run loop with which to schedule `stream`.
    ///
    /// - runLoopMode: The run loop mode of `runLoop` in which to schedule `stream`.
    ///
    ///
    /// ## Discussion
    ///
    /// After scheduling `stream` with a run loop, its client (set with [`CFReadStreamSetClient`](https://developer.apple.com/documentation/corefoundation/cfreadstreamsetclient(_:_:_:_:))) is notified when various events happen with the stream, such as when it finishes opening, when it has bytes available, and when an error occurs. A stream can be scheduled with multiple run loops and run loop modes. Use [`CFReadStreamUnscheduleFromRunLoop`](https://developer.apple.com/documentation/corefoundation/cfreadstreamunschedulefromrunloop(_:_:_:)) to later remove `stream` from the run loop.
    ///
    ///
    #[doc(alias = "CFReadStreamScheduleWithRunLoop")]
    #[cfg(feature = "CFRunLoop")]
    #[inline]
    pub fn schedule_with_run_loop(
        &self,
        run_loop: Option<&CFRunLoop>,
        run_loop_mode: Option<&CFRunLoopMode>,
    ) {
        extern "C-unwind" {
            fn CFReadStreamScheduleWithRunLoop(
                stream: &CFReadStream,
                run_loop: Option<&CFRunLoop>,
                run_loop_mode: Option<&CFRunLoopMode>,
            );
        }
        unsafe { CFReadStreamScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }
}

impl CFWriteStream {
    /// Schedules a stream into a run loop.
    ///
    /// Parameters:
    /// - stream: The stream to schedule.
    ///
    /// - runLoop: The run loop in which to schedule `stream`.
    ///
    /// - runLoopMode: The run loop mode of `runLoop` in which to schedule `stream`.
    ///
    ///
    /// ## Discussion
    ///
    /// After scheduling `stream` into a run loop, its client (set with [`CFWriteStreamSetClient`](https://developer.apple.com/documentation/corefoundation/cfwritestreamsetclient(_:_:_:_:))) is notified when various events happen with the stream, such as when it finishes opening, when it can accept new bytes, and when an error occurs. A stream can be scheduled into multiple run loops and run loop modes. Use [`CFWriteStreamUnscheduleFromRunLoop`](https://developer.apple.com/documentation/corefoundation/cfwritestreamunschedulefromrunloop(_:_:_:)) to later remove `stream` from the run loop.
    ///
    ///
    #[doc(alias = "CFWriteStreamScheduleWithRunLoop")]
    #[cfg(feature = "CFRunLoop")]
    #[inline]
    pub fn schedule_with_run_loop(
        &self,
        run_loop: Option<&CFRunLoop>,
        run_loop_mode: Option<&CFRunLoopMode>,
    ) {
        extern "C-unwind" {
            fn CFWriteStreamScheduleWithRunLoop(
                stream: &CFWriteStream,
                run_loop: Option<&CFRunLoop>,
                run_loop_mode: Option<&CFRunLoopMode>,
            );
        }
        unsafe { CFWriteStreamScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }
}

impl CFReadStream {
    /// Removes a read stream from a given run loop.
    ///
    /// Parameters:
    /// - stream: The stream to unschedule.
    ///
    /// - runLoop: The run loop from which to remove `stream`.
    ///
    /// - runLoopMode: The run loop mode of `runLoop` from which to remove `stream`.
    ///
    #[doc(alias = "CFReadStreamUnscheduleFromRunLoop")]
    #[cfg(feature = "CFRunLoop")]
    #[inline]
    pub fn unschedule_from_run_loop(
        &self,
        run_loop: Option<&CFRunLoop>,
        run_loop_mode: Option<&CFRunLoopMode>,
    ) {
        extern "C-unwind" {
            fn CFReadStreamUnscheduleFromRunLoop(
                stream: &CFReadStream,
                run_loop: Option<&CFRunLoop>,
                run_loop_mode: Option<&CFRunLoopMode>,
            );
        }
        unsafe { CFReadStreamUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }
}

impl CFWriteStream {
    /// Removes a stream from a particular run loop.
    ///
    /// Parameters:
    /// - stream: The stream to remove.
    ///
    /// - runLoop: The run loop from which to remove `stream`.
    ///
    /// - runLoopMode: The run loop mode of `runLoop` from which to remove `stream`.
    ///
    #[doc(alias = "CFWriteStreamUnscheduleFromRunLoop")]
    #[cfg(feature = "CFRunLoop")]
    #[inline]
    pub fn unschedule_from_run_loop(
        &self,
        run_loop: Option<&CFRunLoop>,
        run_loop_mode: Option<&CFRunLoopMode>,
    ) {
        extern "C-unwind" {
            fn CFWriteStreamUnscheduleFromRunLoop(
                stream: &CFWriteStream,
                run_loop: Option<&CFRunLoop>,
                run_loop_mode: Option<&CFRunLoopMode>,
            );
        }
        unsafe { CFWriteStreamUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }
}

impl CFReadStream {
    /// # Safety
    ///
    /// - `q` possibly has additional threading requirements.
    /// - `q` might not allow `None`.
    #[doc(alias = "CFReadStreamSetDispatchQueue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_dispatch_queue(&self, q: Option<&DispatchQueue>) {
        extern "C-unwind" {
            fn CFReadStreamSetDispatchQueue(stream: &CFReadStream, q: Option<&DispatchQueue>);
        }
        unsafe { CFReadStreamSetDispatchQueue(self, q) }
    }
}

impl CFWriteStream {
    /// # Safety
    ///
    /// - `q` possibly has additional threading requirements.
    /// - `q` might not allow `None`.
    #[doc(alias = "CFWriteStreamSetDispatchQueue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_dispatch_queue(&self, q: Option<&DispatchQueue>) {
        extern "C-unwind" {
            fn CFWriteStreamSetDispatchQueue(stream: &CFWriteStream, q: Option<&DispatchQueue>);
        }
        unsafe { CFWriteStreamSetDispatchQueue(self, q) }
    }
}

impl CFReadStream {
    #[doc(alias = "CFReadStreamCopyDispatchQueue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub fn dispatch_queue(&self) -> Option<DispatchRetained<DispatchQueue>> {
        extern "C-unwind" {
            fn CFReadStreamCopyDispatchQueue(
                stream: &CFReadStream,
            ) -> Option<NonNull<DispatchQueue>>;
        }
        let ret = unsafe { CFReadStreamCopyDispatchQueue(self) };
        ret.map(|ret| unsafe { DispatchRetained::from_raw(ret) })
    }
}

impl CFWriteStream {
    #[doc(alias = "CFWriteStreamCopyDispatchQueue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub fn dispatch_queue(&self) -> Option<DispatchRetained<DispatchQueue>> {
        extern "C-unwind" {
            fn CFWriteStreamCopyDispatchQueue(
                stream: &CFWriteStream,
            ) -> Option<NonNull<DispatchQueue>>;
        }
        let ret = unsafe { CFWriteStreamCopyDispatchQueue(self) };
        ret.map(|ret| unsafe { DispatchRetained::from_raw(ret) })
    }
}

/// Defines constants for values returned in the domain field of the `CFStreamError` structure.
///
/// ## Overview
///
/// These constants indicate how the error code in the `error` field in the [`CFStreamError`](https://developer.apple.com/documentation/corefoundation/cfstreamerror) structure should be interpreted.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CFStreamErrorDomain(pub CFIndex);
impl CFStreamErrorDomain {
    /// The error code is a custom error code.
    #[doc(alias = "kCFStreamErrorDomainCustom")]
    pub const Custom: Self = Self(-1);
    /// The error code is an error code defined in `errno.h`.
    #[doc(alias = "kCFStreamErrorDomainPOSIX")]
    pub const POSIX: Self = Self(1);
    /// The error is an OSStatus value defined in `MacErrors.h`.
    #[doc(alias = "kCFStreamErrorDomainMacOSStatus")]
    pub const MacOSStatus: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFStreamErrorDomain {
    const ENCODING: Encoding = CFIndex::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFStreamErrorDomain {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CFReadStream {
    /// Returns the error status of a stream.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The error status of `stream` returned in a [`CFStreamError`](https://developer.apple.com/documentation/corefoundation/cfstreamerror) structure.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The error field is `0` if no error has occurred. If the error field is not `0`, the `domain` field contains a code that identifies the domain in which the value of the `error` field should be interpreted.
    ///
    ///
    #[doc(alias = "CFReadStreamGetError")]
    #[inline]
    pub fn error(&self) -> CFStreamError {
        extern "C-unwind" {
            fn CFReadStreamGetError(stream: &CFReadStream) -> CFStreamError;
        }
        unsafe { CFReadStreamGetError(self) }
    }
}

impl CFWriteStream {
    /// Returns the error status of a stream.
    ///
    /// Parameters:
    /// - stream: The stream to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The error status of `stream` returned in a CFStreamError structure.
    ///
    ///
    #[doc(alias = "CFWriteStreamGetError")]
    #[inline]
    pub fn error(&self) -> CFStreamError {
        extern "C-unwind" {
            fn CFWriteStreamGetError(stream: &CFWriteStream) -> CFStreamError;
        }
        unsafe { CFWriteStreamGetError(self) }
    }
}

#[deprecated = "renamed to `CFReadStream::with_bytes_no_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFReadStreamCreateWithBytesNoCopy(
    alloc: Option<&CFAllocator>,
    bytes: *const u8,
    length: CFIndex,
    bytes_deallocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFReadStream>> {
    extern "C-unwind" {
        fn CFReadStreamCreateWithBytesNoCopy(
            alloc: Option<&CFAllocator>,
            bytes: *const u8,
            length: CFIndex,
            bytes_deallocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFReadStream>>;
    }
    let ret = unsafe { CFReadStreamCreateWithBytesNoCopy(alloc, bytes, length, bytes_deallocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFWriteStream::with_buffer`"]
#[inline]
pub unsafe extern "C-unwind" fn CFWriteStreamCreateWithBuffer(
    alloc: Option<&CFAllocator>,
    buffer: *mut u8,
    buffer_capacity: CFIndex,
) -> Option<CFRetained<CFWriteStream>> {
    extern "C-unwind" {
        fn CFWriteStreamCreateWithBuffer(
            alloc: Option<&CFAllocator>,
            buffer: *mut u8,
            buffer_capacity: CFIndex,
        ) -> Option<NonNull<CFWriteStream>>;
    }
    let ret = unsafe { CFWriteStreamCreateWithBuffer(alloc, buffer, buffer_capacity) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFWriteStream::with_allocated_buffers`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamCreateWithAllocatedBuffers(
    alloc: Option<&CFAllocator>,
    buffer_allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFWriteStream>> {
    extern "C-unwind" {
        fn CFWriteStreamCreateWithAllocatedBuffers(
            alloc: Option<&CFAllocator>,
            buffer_allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFWriteStream>>;
    }
    let ret = unsafe { CFWriteStreamCreateWithAllocatedBuffers(alloc, buffer_allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFURL")]
#[deprecated = "renamed to `CFReadStream::with_file`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamCreateWithFile(
    alloc: Option<&CFAllocator>,
    file_url: Option<&CFURL>,
) -> Option<CFRetained<CFReadStream>> {
    extern "C-unwind" {
        fn CFReadStreamCreateWithFile(
            alloc: Option<&CFAllocator>,
            file_url: Option<&CFURL>,
        ) -> Option<NonNull<CFReadStream>>;
    }
    let ret = unsafe { CFReadStreamCreateWithFile(alloc, file_url) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFURL")]
#[deprecated = "renamed to `CFWriteStream::with_file`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamCreateWithFile(
    alloc: Option<&CFAllocator>,
    file_url: Option<&CFURL>,
) -> Option<CFRetained<CFWriteStream>> {
    extern "C-unwind" {
        fn CFWriteStreamCreateWithFile(
            alloc: Option<&CFAllocator>,
            file_url: Option<&CFURL>,
        ) -> Option<NonNull<CFWriteStream>>;
    }
    let ret = unsafe { CFWriteStreamCreateWithFile(alloc, file_url) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFReadStream::status`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamGetStatus(stream: &CFReadStream) -> CFStreamStatus {
    extern "C-unwind" {
        fn CFReadStreamGetStatus(stream: &CFReadStream) -> CFStreamStatus;
    }
    unsafe { CFReadStreamGetStatus(stream) }
}

#[deprecated = "renamed to `CFWriteStream::status`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamGetStatus(stream: &CFWriteStream) -> CFStreamStatus {
    extern "C-unwind" {
        fn CFWriteStreamGetStatus(stream: &CFWriteStream) -> CFStreamStatus;
    }
    unsafe { CFWriteStreamGetStatus(stream) }
}

#[cfg(feature = "CFError")]
#[deprecated = "renamed to `CFReadStream::copy_error`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamCopyError(
    stream: &CFReadStream,
) -> Option<CFRetained<CFError>> {
    extern "C-unwind" {
        fn CFReadStreamCopyError(stream: &CFReadStream) -> Option<NonNull<CFError>>;
    }
    let ret = unsafe { CFReadStreamCopyError(stream) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFError")]
#[deprecated = "renamed to `CFWriteStream::copy_error`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamCopyError(
    stream: &CFWriteStream,
) -> Option<CFRetained<CFError>> {
    extern "C-unwind" {
        fn CFWriteStreamCopyError(stream: &CFWriteStream) -> Option<NonNull<CFError>>;
    }
    let ret = unsafe { CFWriteStreamCopyError(stream) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFReadStream::open`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamOpen(stream: &CFReadStream) -> bool {
    extern "C-unwind" {
        fn CFReadStreamOpen(stream: &CFReadStream) -> Boolean;
    }
    let ret = unsafe { CFReadStreamOpen(stream) };
    ret != 0
}

#[deprecated = "renamed to `CFWriteStream::open`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamOpen(stream: &CFWriteStream) -> bool {
    extern "C-unwind" {
        fn CFWriteStreamOpen(stream: &CFWriteStream) -> Boolean;
    }
    let ret = unsafe { CFWriteStreamOpen(stream) };
    ret != 0
}

#[deprecated = "renamed to `CFReadStream::close`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamClose(stream: &CFReadStream) {
    extern "C-unwind" {
        fn CFReadStreamClose(stream: &CFReadStream);
    }
    unsafe { CFReadStreamClose(stream) }
}

#[deprecated = "renamed to `CFWriteStream::close`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamClose(stream: &CFWriteStream) {
    extern "C-unwind" {
        fn CFWriteStreamClose(stream: &CFWriteStream);
    }
    unsafe { CFWriteStreamClose(stream) }
}

#[deprecated = "renamed to `CFReadStream::has_bytes_available`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamHasBytesAvailable(stream: &CFReadStream) -> bool {
    extern "C-unwind" {
        fn CFReadStreamHasBytesAvailable(stream: &CFReadStream) -> Boolean;
    }
    let ret = unsafe { CFReadStreamHasBytesAvailable(stream) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFReadStream::read`"]
    pub fn CFReadStreamRead(
        stream: &CFReadStream,
        buffer: *mut u8,
        buffer_length: CFIndex,
    ) -> CFIndex;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFReadStream::buffer`"]
    pub fn CFReadStreamGetBuffer(
        stream: &CFReadStream,
        max_bytes_to_read: CFIndex,
        num_bytes_read: *mut CFIndex,
    ) -> *const u8;
}

#[deprecated = "renamed to `CFWriteStream::can_accept_bytes`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamCanAcceptBytes(stream: &CFWriteStream) -> bool {
    extern "C-unwind" {
        fn CFWriteStreamCanAcceptBytes(stream: &CFWriteStream) -> Boolean;
    }
    let ret = unsafe { CFWriteStreamCanAcceptBytes(stream) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFWriteStream::write`"]
    pub fn CFWriteStreamWrite(
        stream: &CFWriteStream,
        buffer: *const u8,
        buffer_length: CFIndex,
    ) -> CFIndex;
}

#[deprecated = "renamed to `CFReadStream::property`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamCopyProperty(
    stream: &CFReadStream,
    property_name: Option<&CFStreamPropertyKey>,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn CFReadStreamCopyProperty(
            stream: &CFReadStream,
            property_name: Option<&CFStreamPropertyKey>,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { CFReadStreamCopyProperty(stream, property_name) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFWriteStream::property`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamCopyProperty(
    stream: &CFWriteStream,
    property_name: Option<&CFStreamPropertyKey>,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn CFWriteStreamCopyProperty(
            stream: &CFWriteStream,
            property_name: Option<&CFStreamPropertyKey>,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { CFWriteStreamCopyProperty(stream, property_name) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFReadStream::set_property`"]
#[inline]
pub unsafe extern "C-unwind" fn CFReadStreamSetProperty(
    stream: &CFReadStream,
    property_name: Option<&CFStreamPropertyKey>,
    property_value: Option<&CFType>,
) -> bool {
    extern "C-unwind" {
        fn CFReadStreamSetProperty(
            stream: &CFReadStream,
            property_name: Option<&CFStreamPropertyKey>,
            property_value: Option<&CFType>,
        ) -> Boolean;
    }
    let ret = unsafe { CFReadStreamSetProperty(stream, property_name, property_value) };
    ret != 0
}

#[deprecated = "renamed to `CFWriteStream::set_property`"]
#[inline]
pub unsafe extern "C-unwind" fn CFWriteStreamSetProperty(
    stream: &CFWriteStream,
    property_name: Option<&CFStreamPropertyKey>,
    property_value: Option<&CFType>,
) -> bool {
    extern "C-unwind" {
        fn CFWriteStreamSetProperty(
            stream: &CFWriteStream,
            property_name: Option<&CFStreamPropertyKey>,
            property_value: Option<&CFType>,
        ) -> Boolean;
    }
    let ret = unsafe { CFWriteStreamSetProperty(stream, property_name, property_value) };
    ret != 0
}

#[deprecated = "renamed to `CFReadStream::set_client`"]
#[inline]
pub unsafe extern "C-unwind" fn CFReadStreamSetClient(
    stream: &CFReadStream,
    stream_events: CFOptionFlags,
    client_cb: CFReadStreamClientCallBack,
    client_context: *mut CFStreamClientContext,
) -> bool {
    extern "C-unwind" {
        fn CFReadStreamSetClient(
            stream: &CFReadStream,
            stream_events: CFOptionFlags,
            client_cb: CFReadStreamClientCallBack,
            client_context: *mut CFStreamClientContext,
        ) -> Boolean;
    }
    let ret = unsafe { CFReadStreamSetClient(stream, stream_events, client_cb, client_context) };
    ret != 0
}

#[deprecated = "renamed to `CFWriteStream::set_client`"]
#[inline]
pub unsafe extern "C-unwind" fn CFWriteStreamSetClient(
    stream: &CFWriteStream,
    stream_events: CFOptionFlags,
    client_cb: CFWriteStreamClientCallBack,
    client_context: *mut CFStreamClientContext,
) -> bool {
    extern "C-unwind" {
        fn CFWriteStreamSetClient(
            stream: &CFWriteStream,
            stream_events: CFOptionFlags,
            client_cb: CFWriteStreamClientCallBack,
            client_context: *mut CFStreamClientContext,
        ) -> Boolean;
    }
    let ret = unsafe { CFWriteStreamSetClient(stream, stream_events, client_cb, client_context) };
    ret != 0
}

#[cfg(feature = "CFRunLoop")]
#[deprecated = "renamed to `CFReadStream::schedule_with_run_loop`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamScheduleWithRunLoop(
    stream: &CFReadStream,
    run_loop: Option<&CFRunLoop>,
    run_loop_mode: Option<&CFRunLoopMode>,
) {
    extern "C-unwind" {
        fn CFReadStreamScheduleWithRunLoop(
            stream: &CFReadStream,
            run_loop: Option<&CFRunLoop>,
            run_loop_mode: Option<&CFRunLoopMode>,
        );
    }
    unsafe { CFReadStreamScheduleWithRunLoop(stream, run_loop, run_loop_mode) }
}

#[cfg(feature = "CFRunLoop")]
#[deprecated = "renamed to `CFWriteStream::schedule_with_run_loop`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamScheduleWithRunLoop(
    stream: &CFWriteStream,
    run_loop: Option<&CFRunLoop>,
    run_loop_mode: Option<&CFRunLoopMode>,
) {
    extern "C-unwind" {
        fn CFWriteStreamScheduleWithRunLoop(
            stream: &CFWriteStream,
            run_loop: Option<&CFRunLoop>,
            run_loop_mode: Option<&CFRunLoopMode>,
        );
    }
    unsafe { CFWriteStreamScheduleWithRunLoop(stream, run_loop, run_loop_mode) }
}

#[cfg(feature = "CFRunLoop")]
#[deprecated = "renamed to `CFReadStream::unschedule_from_run_loop`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamUnscheduleFromRunLoop(
    stream: &CFReadStream,
    run_loop: Option<&CFRunLoop>,
    run_loop_mode: Option<&CFRunLoopMode>,
) {
    extern "C-unwind" {
        fn CFReadStreamUnscheduleFromRunLoop(
            stream: &CFReadStream,
            run_loop: Option<&CFRunLoop>,
            run_loop_mode: Option<&CFRunLoopMode>,
        );
    }
    unsafe { CFReadStreamUnscheduleFromRunLoop(stream, run_loop, run_loop_mode) }
}

#[cfg(feature = "CFRunLoop")]
#[deprecated = "renamed to `CFWriteStream::unschedule_from_run_loop`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamUnscheduleFromRunLoop(
    stream: &CFWriteStream,
    run_loop: Option<&CFRunLoop>,
    run_loop_mode: Option<&CFRunLoopMode>,
) {
    extern "C-unwind" {
        fn CFWriteStreamUnscheduleFromRunLoop(
            stream: &CFWriteStream,
            run_loop: Option<&CFRunLoop>,
            run_loop_mode: Option<&CFRunLoopMode>,
        );
    }
    unsafe { CFWriteStreamUnscheduleFromRunLoop(stream, run_loop, run_loop_mode) }
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `CFReadStream::set_dispatch_queue`"]
    pub fn CFReadStreamSetDispatchQueue(stream: &CFReadStream, q: Option<&DispatchQueue>);
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `CFWriteStream::set_dispatch_queue`"]
    pub fn CFWriteStreamSetDispatchQueue(stream: &CFWriteStream, q: Option<&DispatchQueue>);
}

#[cfg(feature = "dispatch2")]
#[deprecated = "renamed to `CFReadStream::dispatch_queue`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamCopyDispatchQueue(
    stream: &CFReadStream,
) -> Option<DispatchRetained<DispatchQueue>> {
    extern "C-unwind" {
        fn CFReadStreamCopyDispatchQueue(stream: &CFReadStream) -> Option<NonNull<DispatchQueue>>;
    }
    let ret = unsafe { CFReadStreamCopyDispatchQueue(stream) };
    ret.map(|ret| unsafe { DispatchRetained::from_raw(ret) })
}

#[cfg(feature = "dispatch2")]
#[deprecated = "renamed to `CFWriteStream::dispatch_queue`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamCopyDispatchQueue(
    stream: &CFWriteStream,
) -> Option<DispatchRetained<DispatchQueue>> {
    extern "C-unwind" {
        fn CFWriteStreamCopyDispatchQueue(stream: &CFWriteStream)
            -> Option<NonNull<DispatchQueue>>;
    }
    let ret = unsafe { CFWriteStreamCopyDispatchQueue(stream) };
    ret.map(|ret| unsafe { DispatchRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFReadStream::error`"]
#[inline]
pub extern "C-unwind" fn CFReadStreamGetError(stream: &CFReadStream) -> CFStreamError {
    extern "C-unwind" {
        fn CFReadStreamGetError(stream: &CFReadStream) -> CFStreamError;
    }
    unsafe { CFReadStreamGetError(stream) }
}

#[deprecated = "renamed to `CFWriteStream::error`"]
#[inline]
pub extern "C-unwind" fn CFWriteStreamGetError(stream: &CFWriteStream) -> CFStreamError {
    extern "C-unwind" {
        fn CFWriteStreamGetError(stream: &CFWriteStream) -> CFStreamError;
    }
    unsafe { CFWriteStreamGetError(stream) }
}
