//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// Defines a type for the native file descriptor.
pub type CFFileDescriptorNativeDescriptor = c_int;

///
/// ## Overview
///
/// The CFFileDescriptor provides an opaque type to monitor file descriptors for read and write activity via CFRunLoop.
///
/// You use CFFileDescriptor to monitor file descriptors for read and write activity via CFRunLoop using callbacks. Each call back is one-shot, and must be re-enabled if you want to get another one.
///
/// You can re-enable the callback in the callback function itself, but you must completely service the file descriptor before doing so. For example, if you create a CFFileDescriptor for a pipe and get a callback because there are bytes to be read, then if you don’t read all of the bytes but nevertheless re-enable the CFFileDescriptor for read activity, you’ll get called back again immediately.
///
/// You can monitor kqueue file descriptors for read activity to find out when an event the kqueue is filtering for has occurred. You are responsible for understanding the use of the kevent() API and inserting and removing filters from the kqueue file descriptor yourself.
///
/// The following example takes a UNIX process ID as argument, and watches up to 20 seconds, and reports if the process terminates in that time:
///
/// ```objc
/// // cc test.c -framework CoreFoundation -O
/// #include <CoreFoundation/CoreFoundation.h>
/// #include <unistd.h>
/// #include <sys/event.h>
/// static void noteProcDeath(CFFileDescriptorRef fdref, CFOptionFlags callBackTypes, void *info) {
///     struct kevent kev;
///     int fd = CFFileDescriptorGetNativeDescriptor(fdref);
///     kevent(fd, NULL, 0, &kev, 1, NULL);
///     // take action on death of process here
///     printf("process with pid '%u' died\n", (unsigned int)kev.ident);
///     CFFileDescriptorInvalidate(fdref);
///     CFRelease(fdref); // the CFFileDescriptorRef is no longer of any use in this example
/// }
/// // one argument, an integer pid to watch, required
/// int main(int argc, char *argv[]) {
///     if (argc < 2) exit(1);
///     int fd = kqueue();
///     struct kevent kev;
///     EV_SET(&kev, atoi(argv[1]), EVFILT_PROC, EV_ADD|EV_ENABLE, NOTE_EXIT, 0, NULL);
///     kevent(fd, &kev, 1, NULL, 0, NULL);
///     CFFileDescriptorRef fdref = CFFileDescriptorCreate(kCFAllocatorDefault, fd, true, noteProcDeath, NULL);
///     CFFileDescriptorEnableCallBacks(fdref, kCFFileDescriptorReadCallBack);
///     CFRunLoopSourceRef source = CFFileDescriptorCreateRunLoopSource(kCFAllocatorDefault, fdref, 0);
///     CFRunLoopAddSource(CFRunLoopGetMain(), source, kCFRunLoopDefaultMode);
///     CFRelease(source);
///     // run the run loop for 20 seconds
///     CFRunLoopRunInMode(kCFRunLoopDefaultMode, 20.0, false);
///     return 0;
/// }
/// ```
///
///
#[doc(alias = "CFFileDescriptorRef")]
#[repr(C)]
pub struct CFFileDescriptor {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFFileDescriptor {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFFileDescriptor"> for CFFileDescriptor {}
);

/// Identifies the read callback.
pub const kCFFileDescriptorReadCallBack: CFOptionFlags = 1 << 0;
/// Identifies the write callback.
pub const kCFFileDescriptorWriteCallBack: CFOptionFlags = 1 << 1;

/// Defines a structure for a callback for a CFFileDescriptor.
pub type CFFileDescriptorCallBack =
    Option<unsafe extern "C-unwind" fn(*mut CFFileDescriptor, CFOptionFlags, *mut c_void)>;

/// Defines a structure for the context of a CFFileDescriptor.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFFileDescriptorContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>,
    pub release: Option<unsafe extern "C-unwind" fn(*mut c_void)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(*mut c_void) -> *const CFString>,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFFileDescriptorContext {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut c_void>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(*mut c_void) -> *const CFString>>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFFileDescriptorContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for CFFileDescriptor {
    /// Returns the type identifier for the CFFileDescriptor opaque type.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the CFFileDescriptor opaque type.
    ///
    ///
    #[doc(alias = "CFFileDescriptorGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFFileDescriptorGetTypeID() -> CFTypeID;
        }
        unsafe { CFFileDescriptorGetTypeID() }
    }
}

impl CFFileDescriptor {
    /// Creates a new CFFileDescriptor.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new file descriptor object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - fd: The file descriptor for the new CFFileDescriptor.
    ///
    /// - closeOnInvalidate: `true` if the new CFFileDescriptor should close `fd` when it is invalidated, otherwise `false`.
    ///
    /// - callout: The CFFileDescriptorCallBack for the new CFFileDescriptor.
    ///
    /// - context: Contextual information for the new CFFileDescriptor.
    ///
    ///
    /// ## Return Value
    ///
    /// A new CFFileDescriptor or `NULL` if there was a problem creating the object. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `callout` must be implemented correctly.
    /// - `context` must be a valid pointer.
    #[doc(alias = "CFFileDescriptorCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        fd: CFFileDescriptorNativeDescriptor,
        close_on_invalidate: bool,
        callout: CFFileDescriptorCallBack,
        context: *const CFFileDescriptorContext,
    ) -> Option<CFRetained<CFFileDescriptor>> {
        extern "C-unwind" {
            fn CFFileDescriptorCreate(
                allocator: Option<&CFAllocator>,
                fd: CFFileDescriptorNativeDescriptor,
                close_on_invalidate: Boolean,
                callout: CFFileDescriptorCallBack,
                context: *const CFFileDescriptorContext,
            ) -> Option<NonNull<CFFileDescriptor>>;
        }
        let ret = unsafe {
            CFFileDescriptorCreate(allocator, fd, close_on_invalidate as _, callout, context)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the native file descriptor for a given CFFileDescriptor.
    ///
    /// Parameters:
    /// - f: A CFFileDescriptor.
    ///
    ///
    /// ## Return Value
    ///
    /// The native file descriptor for `f`.
    ///
    ///
    #[doc(alias = "CFFileDescriptorGetNativeDescriptor")]
    #[inline]
    pub fn native_descriptor(&self) -> CFFileDescriptorNativeDescriptor {
        extern "C-unwind" {
            fn CFFileDescriptorGetNativeDescriptor(
                f: &CFFileDescriptor,
            ) -> CFFileDescriptorNativeDescriptor;
        }
        unsafe { CFFileDescriptorGetNativeDescriptor(self) }
    }

    /// Gets the context for a given CFFileDescriptor.
    ///
    /// Parameters:
    /// - f: A CFFileDescriptor.
    ///
    /// - context: Upon return, contains the context passed to `f` in [`CFFileDescriptorCreate`](https://developer.apple.com/documentation/corefoundation/cffiledescriptorcreate(_:_:_:_:_:)).
    ///
    ///
    /// # Safety
    ///
    /// `context` must be a valid pointer.
    #[doc(alias = "CFFileDescriptorGetContext")]
    #[inline]
    pub unsafe fn context(&self, context: *mut CFFileDescriptorContext) {
        extern "C-unwind" {
            fn CFFileDescriptorGetContext(
                f: &CFFileDescriptor,
                context: *mut CFFileDescriptorContext,
            );
        }
        unsafe { CFFileDescriptorGetContext(self, context) }
    }

    /// Enables callbacks for a given CFFileDescriptor.
    ///
    /// Parameters:
    /// - f: A CFFileDescriptor.
    ///
    /// - callBackTypes: A bitmask that specifies which callbacks to enable (see [Callback Identifiers](https://developer.apple.com/documentation/corefoundation/1477595-callback-identifiers) for possible components).
    ///
    #[doc(alias = "CFFileDescriptorEnableCallBacks")]
    #[inline]
    pub fn enable_call_backs(&self, call_back_types: CFOptionFlags) {
        extern "C-unwind" {
            fn CFFileDescriptorEnableCallBacks(
                f: &CFFileDescriptor,
                call_back_types: CFOptionFlags,
            );
        }
        unsafe { CFFileDescriptorEnableCallBacks(self, call_back_types) }
    }

    /// Disables callbacks for a given CFFileDescriptor.
    ///
    /// Parameters:
    /// - f: A CFFileDescriptor.
    ///
    /// - callBackTypes: A bitmask that specifies which callbacks to disable (see [Callback Identifiers](https://developer.apple.com/documentation/corefoundation/1477595-callback-identifiers) for possible components).
    ///
    #[doc(alias = "CFFileDescriptorDisableCallBacks")]
    #[inline]
    pub fn disable_call_backs(&self, call_back_types: CFOptionFlags) {
        extern "C-unwind" {
            fn CFFileDescriptorDisableCallBacks(
                f: &CFFileDescriptor,
                call_back_types: CFOptionFlags,
            );
        }
        unsafe { CFFileDescriptorDisableCallBacks(self, call_back_types) }
    }

    /// Invalidates a CFFileDescriptor object.
    ///
    /// Parameters:
    /// - f: A CFFileDescriptor.
    ///
    ///
    /// ## Discussion
    ///
    /// Once invalidated, the CFFileDescriptor object will no longer be read from or written to at the Core Fundation level.
    ///
    /// If you passed `true` for the `closeOnInvalidate` parameter when you called [`CFFileDescriptorCreate`](https://developer.apple.com/documentation/corefoundation/cffiledescriptorcreate(_:_:_:_:_:)), this function also closes the underlying file descriptor. If you passed `false`, you must close the descriptor yourself _after_ invalidating the CFFileDescriptor object.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  You must invalidate the CFFileDescriptor before closing the underlying file descriptor.
    ///
    ///
    ///
    /// </div>
    ///
    #[doc(alias = "CFFileDescriptorInvalidate")]
    #[inline]
    pub fn invalidate(&self) {
        extern "C-unwind" {
            fn CFFileDescriptorInvalidate(f: &CFFileDescriptor);
        }
        unsafe { CFFileDescriptorInvalidate(self) }
    }

    /// Returns a Boolean value that indicates whether the native file descriptor for a given CFFileDescriptor is valid.
    ///
    /// Parameters:
    /// - f: A CFFileDescriptor.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if the native file descriptor for `f` is valid, otherwise `false`.
    ///
    ///
    #[doc(alias = "CFFileDescriptorIsValid")]
    #[inline]
    pub fn is_valid(&self) -> bool {
        extern "C-unwind" {
            fn CFFileDescriptorIsValid(f: &CFFileDescriptor) -> Boolean;
        }
        let ret = unsafe { CFFileDescriptorIsValid(self) };
        ret != 0
    }

    /// Creates a new runloop source for a given CFFileDescriptor.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new bag and its storage for values. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - f: A CFFileDescriptor.
    ///
    /// - order: The order for the new run loop (see [`CFRunLoopSourceCreate`](https://developer.apple.com/documentation/corefoundation/cfrunloopsourcecreate(_:_:_:))).
    ///
    ///
    /// ## Return Value
    ///
    /// A new runloop source for `f`, or `NULL` if there was a problem creating the object. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The context for the new runloop (see [`CFRunLoopSourceCreate`](https://developer.apple.com/documentation/corefoundation/cfrunloopsourcecreate(_:_:_:))) is the same as the context passed in when the CFFileDescriptor was created (see [`CFFileDescriptorCreate`](https://developer.apple.com/documentation/corefoundation/cffiledescriptorcreate(_:_:_:_:_:))).
    ///
    ///
    #[doc(alias = "CFFileDescriptorCreateRunLoopSource")]
    #[cfg(feature = "CFRunLoop")]
    #[inline]
    pub fn new_run_loop_source(
        allocator: Option<&CFAllocator>,
        f: Option<&CFFileDescriptor>,
        order: CFIndex,
    ) -> Option<CFRetained<CFRunLoopSource>> {
        extern "C-unwind" {
            fn CFFileDescriptorCreateRunLoopSource(
                allocator: Option<&CFAllocator>,
                f: Option<&CFFileDescriptor>,
                order: CFIndex,
            ) -> Option<NonNull<CFRunLoopSource>>;
        }
        let ret = unsafe { CFFileDescriptorCreateRunLoopSource(allocator, f, order) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

#[deprecated = "renamed to `CFFileDescriptor::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFFileDescriptorCreate(
    allocator: Option<&CFAllocator>,
    fd: CFFileDescriptorNativeDescriptor,
    close_on_invalidate: bool,
    callout: CFFileDescriptorCallBack,
    context: *const CFFileDescriptorContext,
) -> Option<CFRetained<CFFileDescriptor>> {
    extern "C-unwind" {
        fn CFFileDescriptorCreate(
            allocator: Option<&CFAllocator>,
            fd: CFFileDescriptorNativeDescriptor,
            close_on_invalidate: Boolean,
            callout: CFFileDescriptorCallBack,
            context: *const CFFileDescriptorContext,
        ) -> Option<NonNull<CFFileDescriptor>>;
    }
    let ret = unsafe {
        CFFileDescriptorCreate(allocator, fd, close_on_invalidate as _, callout, context)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFFileDescriptor::native_descriptor`"]
#[inline]
pub extern "C-unwind" fn CFFileDescriptorGetNativeDescriptor(
    f: &CFFileDescriptor,
) -> CFFileDescriptorNativeDescriptor {
    extern "C-unwind" {
        fn CFFileDescriptorGetNativeDescriptor(
            f: &CFFileDescriptor,
        ) -> CFFileDescriptorNativeDescriptor;
    }
    unsafe { CFFileDescriptorGetNativeDescriptor(f) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFFileDescriptor::context`"]
    pub fn CFFileDescriptorGetContext(f: &CFFileDescriptor, context: *mut CFFileDescriptorContext);
}

#[deprecated = "renamed to `CFFileDescriptor::enable_call_backs`"]
#[inline]
pub extern "C-unwind" fn CFFileDescriptorEnableCallBacks(
    f: &CFFileDescriptor,
    call_back_types: CFOptionFlags,
) {
    extern "C-unwind" {
        fn CFFileDescriptorEnableCallBacks(f: &CFFileDescriptor, call_back_types: CFOptionFlags);
    }
    unsafe { CFFileDescriptorEnableCallBacks(f, call_back_types) }
}

#[deprecated = "renamed to `CFFileDescriptor::disable_call_backs`"]
#[inline]
pub extern "C-unwind" fn CFFileDescriptorDisableCallBacks(
    f: &CFFileDescriptor,
    call_back_types: CFOptionFlags,
) {
    extern "C-unwind" {
        fn CFFileDescriptorDisableCallBacks(f: &CFFileDescriptor, call_back_types: CFOptionFlags);
    }
    unsafe { CFFileDescriptorDisableCallBacks(f, call_back_types) }
}

#[deprecated = "renamed to `CFFileDescriptor::invalidate`"]
#[inline]
pub extern "C-unwind" fn CFFileDescriptorInvalidate(f: &CFFileDescriptor) {
    extern "C-unwind" {
        fn CFFileDescriptorInvalidate(f: &CFFileDescriptor);
    }
    unsafe { CFFileDescriptorInvalidate(f) }
}

#[deprecated = "renamed to `CFFileDescriptor::is_valid`"]
#[inline]
pub extern "C-unwind" fn CFFileDescriptorIsValid(f: &CFFileDescriptor) -> bool {
    extern "C-unwind" {
        fn CFFileDescriptorIsValid(f: &CFFileDescriptor) -> Boolean;
    }
    let ret = unsafe { CFFileDescriptorIsValid(f) };
    ret != 0
}

#[cfg(feature = "CFRunLoop")]
#[deprecated = "renamed to `CFFileDescriptor::new_run_loop_source`"]
#[inline]
pub extern "C-unwind" fn CFFileDescriptorCreateRunLoopSource(
    allocator: Option<&CFAllocator>,
    f: Option<&CFFileDescriptor>,
    order: CFIndex,
) -> Option<CFRetained<CFRunLoopSource>> {
    extern "C-unwind" {
        fn CFFileDescriptorCreateRunLoopSource(
            allocator: Option<&CFAllocator>,
            f: Option<&CFFileDescriptor>,
            order: CFIndex,
        ) -> Option<NonNull<CFRunLoopSource>>;
    }
    let ret = unsafe { CFFileDescriptorCreateRunLoopSource(allocator, f, order) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
