//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

#[cfg(feature = "CFDate")]
unsafe impl ConcreteType for CFTimeZone {
    /// Returns the type identifier for the CFTimeZone opaque type.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the CFTimeZone opaque type.
    ///
    ///
    #[doc(alias = "CFTimeZoneGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFTimeZoneGetTypeID() -> CFTypeID;
        }
        unsafe { CFTimeZoneGetTypeID() }
    }
}

#[cfg(feature = "CFDate")]
impl CFTimeZone {
    /// Returns the time zone currently used by the system.
    ///
    /// ## Return Value
    ///
    /// A time zone representing the time zone currently used by the system, or the GMT time zone if the current zone cannot be determined. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    #[doc(alias = "CFTimeZoneCopySystem")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn system() -> Option<CFRetained<CFTimeZone>> {
        extern "C-unwind" {
            fn CFTimeZoneCopySystem() -> Option<NonNull<CFTimeZone>>;
        }
        let ret = unsafe { CFTimeZoneCopySystem() };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Clears the previously determined system time zone, if any.
    ///
    /// ## Discussion
    ///
    /// If the default time zone is set to the same value as the system time zone or has not been explicitly set, this function clears it as well.
    ///
    /// Subsequent calls to [`CFTimeZoneCopySystem`](https://developer.apple.com/documentation/corefoundation/cftimezonecopysystem()) will attempt to re-determine the system time zone.
    ///
    ///
    #[doc(alias = "CFTimeZoneResetSystem")]
    #[inline]
    pub fn reset_system() {
        extern "C-unwind" {
            fn CFTimeZoneResetSystem();
        }
        unsafe { CFTimeZoneResetSystem() }
    }

    /// Returns the default time zone set for your application.
    ///
    /// ## Return Value
    ///
    /// A time zone representing the default time zone set for your application, or the system time zone if no default is set. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If no default time zone is set, this function simply returns the result of the [`CFTimeZoneCopySystem`](https://developer.apple.com/documentation/corefoundation/cftimezonecopysystem()) function.
    ///
    ///
    #[doc(alias = "CFTimeZoneCopyDefault")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn default() -> Option<CFRetained<CFTimeZone>> {
        extern "C-unwind" {
            fn CFTimeZoneCopyDefault() -> Option<NonNull<CFTimeZone>>;
        }
        let ret = unsafe { CFTimeZoneCopyDefault() };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sets the default time zone for your application the given time zone.
    ///
    /// Parameters:
    /// - tz: The time zone to use as default.
    ///
    ///
    /// ## Discussion
    ///
    /// There can be only one default time zone, so by setting a new default time zone, you lose the previous one.
    ///
    ///
    #[doc(alias = "CFTimeZoneSetDefault")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn set_default(&self) {
        extern "C-unwind" {
            fn CFTimeZoneSetDefault(tz: &CFTimeZone);
        }
        unsafe { CFTimeZoneSetDefault(self) }
    }

    /// Returns an array of strings containing the names of all the time zones known to the system.
    ///
    /// ## Return Value
    ///
    /// An array containing CFString objects representing all the known time zone names. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    #[doc(alias = "CFTimeZoneCopyKnownNames")]
    #[cfg(feature = "CFArray")]
    #[inline]
    pub fn known_names() -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CFTimeZoneCopyKnownNames() -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CFTimeZoneCopyKnownNames() };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a dictionary holding the mappings of time zone abbreviations to time zone names.
    ///
    /// ## Return Value
    ///
    /// A dictionary containing the mappings of time zone abbreviations to time zone names. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// More than one time zone may have the same abbreviation. For example, US/Pacific and Canada/Pacific both use the abbreviation “PST.” In these cases this function chooses a single name to map the abbreviation to.
    ///
    ///
    #[doc(alias = "CFTimeZoneCopyAbbreviationDictionary")]
    #[cfg(feature = "CFDictionary")]
    #[inline]
    pub fn abbreviation_dictionary() -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CFTimeZoneCopyAbbreviationDictionary() -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CFTimeZoneCopyAbbreviationDictionary() };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sets the abbreviation dictionary to a given dictionary.
    ///
    /// Parameters:
    /// - dict: A dictionary containing key-value pairs for looking up time zone names given their abbreviations. The keys should be CFString objects containing the abbreviations; the values should be CFString objects containing their corresponding geopolitical region names.
    ///
    ///
    /// # Safety
    ///
    /// - `dict` generic must be of the correct type.
    /// - `dict` generic must be of the correct type.
    /// - `dict` might not allow `None`.
    #[doc(alias = "CFTimeZoneSetAbbreviationDictionary")]
    #[cfg(feature = "CFDictionary")]
    #[inline]
    pub unsafe fn set_abbreviation_dictionary(dict: Option<&CFDictionary>) {
        extern "C-unwind" {
            fn CFTimeZoneSetAbbreviationDictionary(dict: Option<&CFDictionary>);
        }
        unsafe { CFTimeZoneSetAbbreviationDictionary(dict) }
    }

    /// Creates a time zone with a given name and data.
    ///
    /// Parameters:
    /// - allocator: The allocator object to use to allocate memory for the new time zone. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - name: The name of the time zone to create.
    ///
    /// - data: The data to use to initialize the time zone. The contents of the data should be the same as that found within the time-zone files located at `/usr/share/zoneinfo`.
    ///
    ///
    /// ## Return Value
    ///
    /// A time zone corresponding to `name` and `data`. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You typically do not call this function directly. Use the [`CFTimeZoneCreateWithName`](https://developer.apple.com/documentation/corefoundation/cftimezonecreatewithname(_:_:_:)) function to obtain a time zone given its name.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `name` might not allow `None`.
    /// - `data` might not allow `None`.
    #[doc(alias = "CFTimeZoneCreate")]
    #[cfg(all(feature = "CFData", feature = "CFDate"))]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        name: Option<&CFString>,
        data: Option<&CFData>,
    ) -> Option<CFRetained<CFTimeZone>> {
        extern "C-unwind" {
            fn CFTimeZoneCreate(
                allocator: Option<&CFAllocator>,
                name: Option<&CFString>,
                data: Option<&CFData>,
            ) -> Option<NonNull<CFTimeZone>>;
        }
        let ret = unsafe { CFTimeZoneCreate(allocator, name, data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a time zone object for the specified time interval offset from Greenwich Mean Time (GMT).
    ///
    /// Parameters:
    /// - allocator: The allocator object to use to allocate memory for the new time zone. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - ti: The offset, from GMT, of the new time zone.
    ///
    ///
    /// ## Return Value
    ///
    /// A new time zone whose offset from GMT is given by the interval `ti`. The name of the new time zone is GMT +/- the offset, in hours and minutes. Time zones created with this function never have daylight savings, and the offset is constant no matter what the date. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    #[doc(alias = "CFTimeZoneCreateWithTimeIntervalFromGMT")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn with_time_interval_from_gmt(
        allocator: Option<&CFAllocator>,
        ti: CFTimeInterval,
    ) -> Option<CFRetained<CFTimeZone>> {
        extern "C-unwind" {
            fn CFTimeZoneCreateWithTimeIntervalFromGMT(
                allocator: Option<&CFAllocator>,
                ti: CFTimeInterval,
            ) -> Option<NonNull<CFTimeZone>>;
        }
        let ret = unsafe { CFTimeZoneCreateWithTimeIntervalFromGMT(allocator, ti) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the time zone object identified by a given name or abbreviation.
    ///
    /// Parameters:
    /// - allocator: The allocator object to use to allocate memory for the new time zone. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - name: The name or abbreviation of the time zone to obtain. The name may be in any of the formats understood by the system, for example “EST”, “Etc/GMT-2”, “America/Argentina/Buenos_Aires”, “Europe/Monaco”, “US/Pacific”, or “posixrules”. For a complete list of system names, you can see the output of  [`CFTimeZoneCopyKnownNames`](https://developer.apple.com/documentation/corefoundation/cftimezonecopyknownnames()).
    ///
    /// - tryAbbrev: If `false`, assumes `name` is not an abbreviation and searches the time zone information directory for a matching name. If `true`, tries to resolve `name` using the abbreviation dictionary first before searching the information dictionary.
    ///
    ///
    /// ## Return Value
    ///
    /// A time zone corresponding to `name`, or `NULL` if no match was found. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    #[doc(alias = "CFTimeZoneCreateWithName")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn with_name(
        allocator: Option<&CFAllocator>,
        name: Option<&CFString>,
        try_abbrev: bool,
    ) -> Option<CFRetained<CFTimeZone>> {
        extern "C-unwind" {
            fn CFTimeZoneCreateWithName(
                allocator: Option<&CFAllocator>,
                name: Option<&CFString>,
                try_abbrev: Boolean,
            ) -> Option<NonNull<CFTimeZone>>;
        }
        let ret = unsafe { CFTimeZoneCreateWithName(allocator, name, try_abbrev as _) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the geopolitical region name that identifies a given time zone.
    ///
    /// Parameters:
    /// - tz: The time zone to analyze.
    ///
    ///
    /// ## Return Value
    ///
    /// A string containing the geopolitical region name that identifies `tz`. Ownership follows the [The Get Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-SW1).
    ///
    ///
    #[doc(alias = "CFTimeZoneGetName")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn name(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFTimeZoneGetName(tz: &CFTimeZone) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFTimeZoneGetName(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the data that stores the information used by a time zone.
    ///
    /// Parameters:
    /// - tz: The time zone to analyze.
    ///
    ///
    /// ## Return Value
    ///
    /// The data used to store `tz`. Ownership follows the [The Get Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-SW1). May be `NULL` if the timezone does not have any data or use Olson data for its information.
    ///
    ///
    #[doc(alias = "CFTimeZoneGetData")]
    #[cfg(all(feature = "CFData", feature = "CFDate"))]
    #[inline]
    pub fn data(&self) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn CFTimeZoneGetData(tz: &CFTimeZone) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { CFTimeZoneGetData(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the difference in seconds between the receiver and Greenwich Mean Time (GMT) at the specified date.
    ///
    /// Parameters:
    /// - tz: The time zone to analyze.
    ///
    /// - at: The date at which the interval is to be computed.
    ///
    ///
    /// ## Return Value
    ///
    /// The difference in seconds between `tz` and GMT at the specified date, `at`.
    ///
    ///
    #[doc(alias = "CFTimeZoneGetSecondsFromGMT")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn seconds_from_gmt(&self, at: CFAbsoluteTime) -> CFTimeInterval {
        extern "C-unwind" {
            fn CFTimeZoneGetSecondsFromGMT(tz: &CFTimeZone, at: CFAbsoluteTime) -> CFTimeInterval;
        }
        unsafe { CFTimeZoneGetSecondsFromGMT(self, at) }
    }

    /// Returns the abbreviation of a time zone at a specified date.
    ///
    /// Parameters:
    /// - tz: The time zone to use.
    ///
    /// - at: The absolute time at which to obtain the abbreviation.
    ///
    ///
    /// ## Return Value
    ///
    /// A string containing the time zone abbreviation of `at`. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Note that the abbreviation may be different at different dates. For example, during daylight savings time the US/Eastern time zone has an abbreviation of “EDT.” At other times, its abbreviation is “EST.”
    ///
    ///
    #[doc(alias = "CFTimeZoneCopyAbbreviation")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn abbreviation(&self, at: CFAbsoluteTime) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFTimeZoneCopyAbbreviation(
                tz: &CFTimeZone,
                at: CFAbsoluteTime,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFTimeZoneCopyAbbreviation(self, at) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns whether or not a time zone is in daylight savings time at a specified date.
    ///
    /// Parameters:
    /// - tz: The time zone to analyze.
    ///
    /// - at: The date in `tz` to test for daylight savings.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if `tz` is in daylight savings time at `at`, otherwise `false`.
    ///
    ///
    #[doc(alias = "CFTimeZoneIsDaylightSavingTime")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn is_daylight_saving_time(&self, at: CFAbsoluteTime) -> bool {
        extern "C-unwind" {
            fn CFTimeZoneIsDaylightSavingTime(tz: &CFTimeZone, at: CFAbsoluteTime) -> Boolean;
        }
        let ret = unsafe { CFTimeZoneIsDaylightSavingTime(self, at) };
        ret != 0
    }

    /// Returns the daylight saving time offset for a time zone at a given time.
    ///
    /// Parameters:
    /// - tz: The time zone to analyze.
    ///
    /// - at: The time in `tz` to test for daylight saving time offset.
    ///
    ///
    /// ## Return Value
    ///
    /// The daylight saving time offset for `tz` at `at`.
    ///
    ///
    #[doc(alias = "CFTimeZoneGetDaylightSavingTimeOffset")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn daylight_saving_time_offset(&self, at: CFAbsoluteTime) -> CFTimeInterval {
        extern "C-unwind" {
            fn CFTimeZoneGetDaylightSavingTimeOffset(
                tz: &CFTimeZone,
                at: CFAbsoluteTime,
            ) -> CFTimeInterval;
        }
        unsafe { CFTimeZoneGetDaylightSavingTimeOffset(self, at) }
    }

    /// Returns the time in a given time zone of the next daylight saving time transition after a given time.
    ///
    /// Parameters:
    /// - tz: The time zone to analyze.
    ///
    /// - at: A time in `tz`.
    ///
    ///
    /// ## Return Value
    ///
    /// The time in `tz` of the next daylight saving time transition after `at`.
    ///
    ///
    #[doc(alias = "CFTimeZoneGetNextDaylightSavingTimeTransition")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub fn next_daylight_saving_time_transition(&self, at: CFAbsoluteTime) -> CFAbsoluteTime {
        extern "C-unwind" {
            fn CFTimeZoneGetNextDaylightSavingTimeTransition(
                tz: &CFTimeZone,
                at: CFAbsoluteTime,
            ) -> CFAbsoluteTime;
        }
        unsafe { CFTimeZoneGetNextDaylightSavingTimeTransition(self, at) }
    }
}

/// Index type for constants used to specify styles of time zone names.
///
/// ## Overview
///
/// For values, see [Time Zone Name Styles](https://developer.apple.com/documentation/corefoundation/time_zone_name_styles)
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CFTimeZoneNameStyle(pub CFIndex);
impl CFTimeZoneNameStyle {
    /// Specifies the standard name style; for example, “Central Standard Time” for the Central time zone.
    #[doc(alias = "kCFTimeZoneNameStyleStandard")]
    pub const Standard: Self = Self(0);
    /// Specifies the short standard name style; for example, “CST” for the Central time zone.
    #[doc(alias = "kCFTimeZoneNameStyleShortStandard")]
    pub const ShortStandard: Self = Self(1);
    /// Specifies the daylight saving name style; for example, “Central Daylight Time” for the Central time zone.
    #[doc(alias = "kCFTimeZoneNameStyleDaylightSaving")]
    pub const DaylightSaving: Self = Self(2);
    /// Specifies the short daylight saving name style; for example, “CDT” for the Central time zone.
    #[doc(alias = "kCFTimeZoneNameStyleShortDaylightSaving")]
    pub const ShortDaylightSaving: Self = Self(3);
    /// Specifies the generic name style, which does not distinguish between daylight saving and standard time; for example, “Central Time” for the Central time zone.
    #[doc(alias = "kCFTimeZoneNameStyleGeneric")]
    pub const Generic: Self = Self(4);
    /// Specifies the short generic name style, which does not distinguish between daylight saving and standard time; for example, “CT” for the Central time zone.
    #[doc(alias = "kCFTimeZoneNameStyleShortGeneric")]
    pub const ShortGeneric: Self = Self(5);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFTimeZoneNameStyle {
    const ENCODING: Encoding = CFIndex::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFTimeZoneNameStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "CFDate")]
impl CFTimeZone {
    /// Returns the localized name of a given time zone.
    ///
    /// Parameters:
    /// - tz: The time zone to analyze.
    ///
    /// - style: The style for the returned name.
    ///
    /// - locale: The locale for which to localize the returned name.
    ///
    ///
    /// ## Return Value
    ///
    /// The name of `tz` localized for `locale`. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    #[doc(alias = "CFTimeZoneCopyLocalizedName")]
    #[cfg(all(feature = "CFDate", feature = "CFLocale"))]
    #[inline]
    pub fn localized_name(
        &self,
        style: CFTimeZoneNameStyle,
        locale: Option<&CFLocale>,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFTimeZoneCopyLocalizedName(
                tz: &CFTimeZone,
                style: CFTimeZoneNameStyle,
                locale: Option<&CFLocale>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFTimeZoneCopyLocalizedName(self, style, locale) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

extern "C" {
    /// Name of the notification posted when the system time zone changes.
    ///
    /// ## Discussion
    ///
    /// The object of the notification is the previous system time zone object. This notification carries no user info.
    ///
    /// Keep in mind that there is no order in how notifications are delivered to observers; frameworks or other parts of your code may also be observing this notification to take their own actions, and these may not have occurred by the time you receive the notification.
    ///
    ///
    #[cfg(feature = "CFNotificationCenter")]
    pub static kCFTimeZoneSystemTimeZoneDidChangeNotification: Option<&'static CFNotificationName>;
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::system`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneCopySystem() -> Option<CFRetained<CFTimeZone>> {
    extern "C-unwind" {
        fn CFTimeZoneCopySystem() -> Option<NonNull<CFTimeZone>>;
    }
    let ret = unsafe { CFTimeZoneCopySystem() };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFTimeZone::reset_system`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneResetSystem() {
    extern "C-unwind" {
        fn CFTimeZoneResetSystem();
    }
    unsafe { CFTimeZoneResetSystem() }
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::default`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneCopyDefault() -> Option<CFRetained<CFTimeZone>> {
    extern "C-unwind" {
        fn CFTimeZoneCopyDefault() -> Option<NonNull<CFTimeZone>>;
    }
    let ret = unsafe { CFTimeZoneCopyDefault() };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::set_default`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneSetDefault(tz: &CFTimeZone) {
    extern "C-unwind" {
        fn CFTimeZoneSetDefault(tz: &CFTimeZone);
    }
    unsafe { CFTimeZoneSetDefault(tz) }
}

#[cfg(feature = "CFArray")]
#[deprecated = "renamed to `CFTimeZone::known_names`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneCopyKnownNames() -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CFTimeZoneCopyKnownNames() -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CFTimeZoneCopyKnownNames() };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFDictionary")]
#[deprecated = "renamed to `CFTimeZone::abbreviation_dictionary`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneCopyAbbreviationDictionary() -> Option<CFRetained<CFDictionary>>
{
    extern "C-unwind" {
        fn CFTimeZoneCopyAbbreviationDictionary() -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CFTimeZoneCopyAbbreviationDictionary() };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CFDictionary")]
    #[deprecated = "renamed to `CFTimeZone::set_abbreviation_dictionary`"]
    pub fn CFTimeZoneSetAbbreviationDictionary(dict: Option<&CFDictionary>);
}

#[cfg(all(feature = "CFData", feature = "CFDate"))]
#[deprecated = "renamed to `CFTimeZone::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFTimeZoneCreate(
    allocator: Option<&CFAllocator>,
    name: Option<&CFString>,
    data: Option<&CFData>,
) -> Option<CFRetained<CFTimeZone>> {
    extern "C-unwind" {
        fn CFTimeZoneCreate(
            allocator: Option<&CFAllocator>,
            name: Option<&CFString>,
            data: Option<&CFData>,
        ) -> Option<NonNull<CFTimeZone>>;
    }
    let ret = unsafe { CFTimeZoneCreate(allocator, name, data) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::with_time_interval_from_gmt`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneCreateWithTimeIntervalFromGMT(
    allocator: Option<&CFAllocator>,
    ti: CFTimeInterval,
) -> Option<CFRetained<CFTimeZone>> {
    extern "C-unwind" {
        fn CFTimeZoneCreateWithTimeIntervalFromGMT(
            allocator: Option<&CFAllocator>,
            ti: CFTimeInterval,
        ) -> Option<NonNull<CFTimeZone>>;
    }
    let ret = unsafe { CFTimeZoneCreateWithTimeIntervalFromGMT(allocator, ti) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::with_name`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneCreateWithName(
    allocator: Option<&CFAllocator>,
    name: Option<&CFString>,
    try_abbrev: bool,
) -> Option<CFRetained<CFTimeZone>> {
    extern "C-unwind" {
        fn CFTimeZoneCreateWithName(
            allocator: Option<&CFAllocator>,
            name: Option<&CFString>,
            try_abbrev: Boolean,
        ) -> Option<NonNull<CFTimeZone>>;
    }
    let ret = unsafe { CFTimeZoneCreateWithName(allocator, name, try_abbrev as _) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::name`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneGetName(tz: &CFTimeZone) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFTimeZoneGetName(tz: &CFTimeZone) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFTimeZoneGetName(tz) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CFData", feature = "CFDate"))]
#[deprecated = "renamed to `CFTimeZone::data`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneGetData(tz: &CFTimeZone) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CFTimeZoneGetData(tz: &CFTimeZone) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { CFTimeZoneGetData(tz) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::seconds_from_gmt`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneGetSecondsFromGMT(
    tz: &CFTimeZone,
    at: CFAbsoluteTime,
) -> CFTimeInterval {
    extern "C-unwind" {
        fn CFTimeZoneGetSecondsFromGMT(tz: &CFTimeZone, at: CFAbsoluteTime) -> CFTimeInterval;
    }
    unsafe { CFTimeZoneGetSecondsFromGMT(tz, at) }
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::abbreviation`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneCopyAbbreviation(
    tz: &CFTimeZone,
    at: CFAbsoluteTime,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFTimeZoneCopyAbbreviation(
            tz: &CFTimeZone,
            at: CFAbsoluteTime,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFTimeZoneCopyAbbreviation(tz, at) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::is_daylight_saving_time`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneIsDaylightSavingTime(
    tz: &CFTimeZone,
    at: CFAbsoluteTime,
) -> bool {
    extern "C-unwind" {
        fn CFTimeZoneIsDaylightSavingTime(tz: &CFTimeZone, at: CFAbsoluteTime) -> Boolean;
    }
    let ret = unsafe { CFTimeZoneIsDaylightSavingTime(tz, at) };
    ret != 0
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::daylight_saving_time_offset`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneGetDaylightSavingTimeOffset(
    tz: &CFTimeZone,
    at: CFAbsoluteTime,
) -> CFTimeInterval {
    extern "C-unwind" {
        fn CFTimeZoneGetDaylightSavingTimeOffset(
            tz: &CFTimeZone,
            at: CFAbsoluteTime,
        ) -> CFTimeInterval;
    }
    unsafe { CFTimeZoneGetDaylightSavingTimeOffset(tz, at) }
}

#[cfg(feature = "CFDate")]
#[deprecated = "renamed to `CFTimeZone::next_daylight_saving_time_transition`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneGetNextDaylightSavingTimeTransition(
    tz: &CFTimeZone,
    at: CFAbsoluteTime,
) -> CFAbsoluteTime {
    extern "C-unwind" {
        fn CFTimeZoneGetNextDaylightSavingTimeTransition(
            tz: &CFTimeZone,
            at: CFAbsoluteTime,
        ) -> CFAbsoluteTime;
    }
    unsafe { CFTimeZoneGetNextDaylightSavingTimeTransition(tz, at) }
}

#[cfg(all(feature = "CFDate", feature = "CFLocale"))]
#[deprecated = "renamed to `CFTimeZone::localized_name`"]
#[inline]
pub extern "C-unwind" fn CFTimeZoneCopyLocalizedName(
    tz: &CFTimeZone,
    style: CFTimeZoneNameStyle,
    locale: Option<&CFLocale>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFTimeZoneCopyLocalizedName(
            tz: &CFTimeZone,
            style: CFTimeZoneNameStyle,
            locale: Option<&CFLocale>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFTimeZoneCopyLocalizedName(tz, style, locale) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
