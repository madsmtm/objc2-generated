//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

///
/// ## Overview
///
/// CFXMLParser provides an XML parser you can use to find and extract data in XML documents. You can use a high-level interface to load an XML document into a Core Foundation collection object. A low-level callback-based interface allows you to perform any action you wish on an XML structured type when it is detected by the parser. This opaque type is relevant for applications that need information about an XML document’s structure or content.
///
///
#[doc(alias = "CFXMLParserRef")]
#[repr(C)]
pub struct CFXMLParser {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFXMLParser {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFXMLParser"> for CFXMLParser {}
);

/// Options you can use to control the parser’s treatment of an XML document.
///
/// ## Overview
///
/// These are the various options you use to configure the parser. An option flag of 0 ([`kCFXMLParserNoOptions`](https://developer.apple.com/documentation/corefoundation/cfxmlparseroptions/kcfxmlparsernooptions)) leaves the XML as “intact” as possible (reports all structures; performs no replacements). Hence, to make the parser do the most work, returning only the pure element tree, set the option flag to [`kCFXMLParserAllOptions`](https://developer.apple.com/documentation/corefoundation/cfxmlparseroptions/alloptions).
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CFXMLParserOptions(pub CFOptionFlags);
bitflags::bitflags! {
    impl CFXMLParserOptions: CFOptionFlags {
/// Validates the document against its grammar from the DTD, reporting any errors. Currently not supported.
        #[doc(alias = "kCFXMLParserValidateDocument")]
        const ValidateDocument = 1<<0;
/// Silently skip over metadata constructs (the DTD and comments).
        #[doc(alias = "kCFXMLParserSkipMetaData")]
        const SkipMetaData = 1<<1;
/// Replaces declared entities like `&lt`;. Note that other than the 5 predefined entities (`lt`, `gt`, `quot`, `amp`, `apos`), these must be defined in the DTD. Currently not supported.
        #[doc(alias = "kCFXMLParserReplacePhysicalEntities")]
        const ReplacePhysicalEntities = 1<<2;
///
/// ## Discussion
///
/// Skip over all whitespace that does not abut non-whitespace character data. In other words, given “`<foo>  <bar> blah </bar></foo>`,” the whitespace between foo’s open tag and bar’s open tag would be suppressed, but the whitespace around `blah` would be preserved.
///
///
        #[doc(alias = "kCFXMLParserSkipWhitespace")]
        const SkipWhitespace = 1<<3;
/// Resolves all external entities.
        #[doc(alias = "kCFXMLParserResolveExternalEntities")]
        const ResolveExternalEntities = 1<<4;
/// Where the DTD specifies implied attribute-value pairs for a particular element, add those pairs to any occurrences of the element in the element tree. Currently not supported.
        #[doc(alias = "kCFXMLParserAddImpliedAttributes")]
        const AddImpliedAttributes = 1<<5;
/// Makes the parser do the most work, returning only the pure elementtree.
        #[doc(alias = "kCFXMLParserAllOptions")]
        const AllOptions = 0x00FFFFFF;
/// Leaves the XML as “intact” as possible (reports all structures; performs no replacements).
        #[doc(alias = "kCFXMLParserNoOptions")]
        const NoOptions = 0;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFXMLParserOptions {
    const ENCODING: Encoding = CFOptionFlags::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFXMLParserOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The various status and error flags that can be returned by the parser.
///
/// ## Overview
///
/// Parser status is determined by calling the [`CFXMLParserGetStatusCode`](https://developer.apple.com/documentation/corefoundation/cfxmlparsergetstatuscode) function. The parser reports errors to your application by invoking the [`CFXMLParserHandleErrorCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparserhandleerrorcallback) function.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CFXMLParserStatusCode(pub CFIndex);
bitflags::bitflags! {
    impl CFXMLParserStatusCode: CFIndex {
/// Indicates the parser has not begun.
        #[doc(alias = "kCFXMLStatusParseNotBegun")]
        const StatusParseNotBegun = -2;
/// Indicates the parser is in progress.
        #[doc(alias = "kCFXMLStatusParseInProgress")]
        const StatusParseInProgress = -1;
/// Indicates the parser was successful.
        #[doc(alias = "kCFXMLStatusParseSuccessful")]
        const StatusParseSuccessful = 0;
/// Indicates an unexpected EOF occurred.
        #[doc(alias = "kCFXMLErrorUnexpectedEOF")]
        const ErrorUnexpectedEOF = 1;
/// Indicates an unknown encoding error.
        #[doc(alias = "kCFXMLErrorUnknownEncoding")]
        const ErrorUnknownEncoding = 2;
/// Indicates an encoding conversion error.
        #[doc(alias = "kCFXMLErrorEncodingConversionFailure")]
        const ErrorEncodingConversionFailure = 3;
/// Indicates a malformed processing instruction.
        #[doc(alias = "kCFXMLErrorMalformedProcessingInstruction")]
        const ErrorMalformedProcessingInstruction = 4;
/// Indicates a malformed DTD.
        #[doc(alias = "kCFXMLErrorMalformedDTD")]
        const ErrorMalformedDTD = 5;
/// Indicates a malformed name.
        #[doc(alias = "kCFXMLErrorMalformedName")]
        const ErrorMalformedName = 6;
/// Indicates a malformed CDATA section.
        #[doc(alias = "kCFXMLErrorMalformedCDSect")]
        const ErrorMalformedCDSect = 7;
/// Indicates a malformed close tag.
        #[doc(alias = "kCFXMLErrorMalformedCloseTag")]
        const ErrorMalformedCloseTag = 8;
/// Indicates a malformed start tag.
        #[doc(alias = "kCFXMLErrorMalformedStartTag")]
        const ErrorMalformedStartTag = 9;
/// Indicates a malformed document.
        #[doc(alias = "kCFXMLErrorMalformedDocument")]
        const ErrorMalformedDocument = 10;
/// Indicates a document containing no elements.
        #[doc(alias = "kCFXMLErrorElementlessDocument")]
        const ErrorElementlessDocument = 11;
/// Indicates a malformed comment.
        #[doc(alias = "kCFXMLErrorMalformedComment")]
        const ErrorMalformedComment = 12;
/// Indicates a malformed character reference.
        #[doc(alias = "kCFXMLErrorMalformedCharacterReference")]
        const ErrorMalformedCharacterReference = 13;
/// Indicates malformed character data.
        #[doc(alias = "kCFXMLErrorMalformedParsedCharacterData")]
        const ErrorMalformedParsedCharacterData = 14;
/// Indicates a no data error.
        #[doc(alias = "kCFXMLErrorNoData")]
        const ErrorNoData = 15;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFXMLParserStatusCode {
    const ENCODING: Encoding = CFIndex::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFXMLParserStatusCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Callback function invoked when the parser encounters an XML open tag.
///
/// Parameters:
/// - parser: The CFXMLParser object making the callback.
///
/// - nodeDesc: The CFXMLNode object that represents the XML structure encountered.
///
/// - info: The program-defined context data you specified in the [`CFXMLParserContext`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercontext) structure when creating the parser.
///
///
/// ## Return Value
///
/// A program-defined value representing the new XML element or `NULL` to indicate that the given structure should be skipped. This value is passed to the other callbacks.
///
///
///
/// ## Discussion
///
/// If NULL is returned for a given structure, only minimal parsing is done for that structure (enough to correctly determine its end, and to extract any data necessary for the remainder of the parse, such as Entity definitions). This callback (or any of the tree-creation callbacks) will not be called for any children of the skipped structure. The only exception is that the top-most element will always be reported even if NULL was returned for the document as a whole. For performance reasons, the node passed to this callback cannot be safely retained by the client; the node as a whole must be copied (using the [`CFXMLNodeCreateCopy`](https://developer.apple.com/documentation/corefoundation/cfxmlnodecreatecopy) function), or its contents must be extracted and copied. You are required to implement this callback for the parser to operate.
///
///
#[cfg(feature = "CFXMLNode")]
pub type CFXMLParserCreateXMLStructureCallBack = Option<
    unsafe extern "C-unwind" fn(*mut CFXMLParser, *const CFXMLNode, *mut c_void) -> *mut c_void,
>;

/// Callback function invoked by the parser to notify your application of parent/child relationships between XML structures.
///
/// Parameters:
/// - parser: The CFXMLParser object making the callback.
///
/// - parent: The program-defined value representing the XML element to whom `child` is being added. This value was returned by the [`CFXMLParserCreateXMLStructureCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercreatexmlstructurecallback) callback when this element’s open tag was detected.
///
/// - child: The program-defined value representing the XML element that is being added to `parent`. This value was returned by the [`CFXMLParserCreateXMLStructureCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercreatexmlstructurecallback) callback when this element’s open tag was detected.
///
/// - info: The program-defined context data you specified in the [`CFXMLParserContext`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercontext) structure when creating the parser.
///
///
/// ## Discussion
///
/// If the [`CFXMLParserCreateXMLStructureCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercreatexmlstructurecallback) function returns NULL for a given structure, that structure is omitted entirely, and this callback will _not_ be called for either a NULL child or parent.
///
///
pub type CFXMLParserAddChildCallBack =
    Option<unsafe extern "C-unwind" fn(*mut CFXMLParser, *mut c_void, *mut c_void, *mut c_void)>;

/// Callback function invoked by the parser to notify your application that an XML structure (and all its children) have been completely parsed.
///
/// Parameters:
/// - parser: The CFXMLParser object making the callback.
///
/// - xmlType: The program-defined value representing the XML element whose end tag has been detected. This value was returned by the [`CFXMLParserCreateXMLStructureCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercreatexmlstructurecallback) callback.
///
/// - info: The program-defined context data you specified in the [`CFXMLParserContext`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercontext) structure when creating the parser.
///
///
/// ## Discussion
///
/// As elements are encountered, this callback is called first, then the [`CFXMLParserAddChildCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparseraddchildcallback) callback to add the new structure to its parent, then the [`CFXMLParserAddChildCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparseraddchildcallback) callback (potentially several times) to add the new structure’s children to it, and then finally the [`CFXMLParserEndXMLStructureCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparserendxmlstructurecallback) callback to show that the structure has been fully parsed.This callback is optional.
///
///
pub type CFXMLParserEndXMLStructureCallBack =
    Option<unsafe extern "C-unwind" fn(*mut CFXMLParser, *mut c_void, *mut c_void)>;

/// Callback function invoked by the parser to notify your application that an external entity has been referenced.
///
/// Parameters:
/// - parser: The CFXMLParser object making the callback.
///
/// - extID: The identifier for the external entity.
///
/// - info: The program-defined context data you specified in the [`CFXMLParserContext`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercontext) structure when creating the parser.
///
///
/// ## Return Value
///
/// The external entity or `NULL` if it should not be resolved.
///
///
///
/// ## Discussion
///
/// If this callback is not defined, the parser uses its internal routines to try and resolve the entity. Otherwise, if this callback returns NULL, a place holder for the external entity is inserted into the tree. In this manner, the parser’s client can prevent any external network or file accesses. This callback is optional.
///
///
#[cfg(all(feature = "CFData", feature = "CFURL", feature = "CFXMLNode"))]
pub type CFXMLParserResolveExternalEntityCallBack = Option<
    unsafe extern "C-unwind" fn(
        *mut CFXMLParser,
        *mut CFXMLExternalID,
        *mut c_void,
    ) -> *const CFData,
>;

/// Callback function invoked by the parser to notify your application that an error has occurred.
///
/// Parameters:
/// - parser: A CFXMLParser object making the callback.
///
/// - error: A status code describing the error.
///
/// - info: The program-defined context data you specified in the [`CFXMLParserContext`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercontext) structure when creating the parser.
///
///
/// ## Return Value
///
/// `true` if the parser should continue parsing the XML, `false` if the parser should stop.
///
///
///
/// ## Discussion
///
/// If this callback is not defined, the parser will silently attempt to recover. Otherwise, this callback may return false to force the parser to stop. If this callback returns true, the parser will attempt to recover (fatal errors will still cause the parse to abort immediately). This callback is optional.
///
///
pub type CFXMLParserHandleErrorCallBack = Option<
    unsafe extern "C-unwind" fn(*mut CFXMLParser, CFXMLParserStatusCode, *mut c_void) -> Boolean,
>;

/// Contains version information and function pointers to callbacks needed when parsing XML.
///
/// ## Overview
///
/// This structure is passed to one of the `CFXMLParserCreate...` functions. Only the `createXMLStructure`, `addChild`, and `endXMLStructure` fields are required. Set the others to `NULL` if you don’t wish to implement them.
///
///
#[cfg(all(feature = "CFData", feature = "CFURL", feature = "CFXMLNode"))]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFXMLParserCallBacks {
    pub version: CFIndex,
    pub createXMLStructure: CFXMLParserCreateXMLStructureCallBack,
    pub addChild: CFXMLParserAddChildCallBack,
    pub endXMLStructure: CFXMLParserEndXMLStructureCallBack,
    pub resolveExternalEntity: CFXMLParserResolveExternalEntityCallBack,
    pub handleError: CFXMLParserHandleErrorCallBack,
}

#[cfg(all(
    feature = "CFData",
    feature = "CFURL",
    feature = "CFXMLNode",
    feature = "objc2"
))]
unsafe impl Encode for CFXMLParserCallBacks {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <CFXMLParserCreateXMLStructureCallBack>::ENCODING,
            <CFXMLParserAddChildCallBack>::ENCODING,
            <CFXMLParserEndXMLStructureCallBack>::ENCODING,
            <CFXMLParserResolveExternalEntityCallBack>::ENCODING,
            <CFXMLParserHandleErrorCallBack>::ENCODING,
        ],
    );
}

#[cfg(all(
    feature = "CFData",
    feature = "CFURL",
    feature = "CFXMLNode",
    feature = "objc2"
))]
unsafe impl RefEncode for CFXMLParserCallBacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Callback function invoked by the parser when it needs another reference to the information pointer.
///
/// Parameters:
/// - info: The program-defined context data you specified in the [`CFXMLParserContext`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercontext) structure when creating the parser.
///
pub type CFXMLParserRetainCallBack =
    Option<unsafe extern "C-unwind" fn(*const c_void) -> *const c_void>;

/// Callback function invoked by the parser when it wants to release a reference to the information pointer.
///
/// Parameters:
/// - info: The program-defined context data you specified in the [`CFXMLParserContext`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercontext) structure when creating the parser.
///
pub type CFXMLParserReleaseCallBack = Option<unsafe extern "C-unwind" fn(*const c_void)>;

/// Callback function invoked by the parser when handling the information pointer.
///
/// Parameters:
/// - info: The program-defined context data you specified in the [`CFXMLParserContext`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercontext) structure when creating the parser.
///
///
/// ## Return Value
///
/// A textual description of `info`. The caller is responsible for releasing this object.
///
///
pub type CFXMLParserCopyDescriptionCallBack =
    Option<unsafe extern "C-unwind" fn(*const c_void) -> *const CFString>;

/// Contains version information and function pointers to callbacks used when handling a program-defined context.
///
/// ## Overview
///
/// You can associate a context with a parser when the parser is created. The context can be anything you wish and will be passed as a parameter to all of the XML parser callbacks.
///
///
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CFXMLParserContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: CFXMLParserRetainCallBack,
    pub release: CFXMLParserReleaseCallBack,
    pub copyDescription: CFXMLParserCopyDescriptionCallBack,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CFXMLParserContext {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <CFXMLParserRetainCallBack>::ENCODING,
            <CFXMLParserReleaseCallBack>::ENCODING,
            <CFXMLParserCopyDescriptionCallBack>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CFXMLParserContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for CFXMLParser {
    /// Returns the type identifier for the CFXMLParser opaque type.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the CFXMLParser opaque type.
    ///
    ///
    #[doc(alias = "CFXMLParserGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFXMLParserGetTypeID() -> CFTypeID;
        }
        unsafe { CFXMLParserGetTypeID() }
    }
}

impl CFXMLParser {
    /// Creates a new XML parser for the specified XML data.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - xmlData: The XML data to parse. Do not pass `NULL`.
    ///
    /// - dataSource: The URL from which the XML data was obtained. The URL is used to resolve any relative references found in XML Data. Pass `NULL` if a valid URL is unavailable.
    ///
    /// - parseOptions: Flags which control how the XML data will be parsed. See [`CFXMLParserOptions`](https://developer.apple.com/documentation/corefoundation/cfxmlparseroptions) for the list of available options.
    ///
    /// - versionOfNodes: Determines which version of CFXMLNode objects are produced by the parser.
    ///
    /// - callBacks: Callbacks called by the parser as the XML is processed. The callbacks are called as each XML tag is encountered, when an external entity needs to be resolved, and when an error occurs. See [`CFXMLParserCallBacks`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercallbacks) and the individual callbacks for more details. Do not pass `NULL`.
    ///
    /// - context: Determines what, if any, information pointer is passed to the callbacks as the parse progresses; `context` may be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// The newly created parser. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `xml_data` might not allow `None`.
    /// - `data_source` might not allow `None`.
    /// - `call_backs` must be a valid pointer.
    /// - `context` must be a valid pointer.
    #[doc(alias = "CFXMLParserCreate")]
    #[cfg(all(feature = "CFData", feature = "CFURL", feature = "CFXMLNode"))]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        xml_data: Option<&CFData>,
        data_source: Option<&CFURL>,
        parse_options: CFOptionFlags,
        version_of_nodes: CFIndex,
        call_backs: *mut CFXMLParserCallBacks,
        context: *mut CFXMLParserContext,
    ) -> Option<CFRetained<CFXMLParser>> {
        extern "C-unwind" {
            fn CFXMLParserCreate(
                allocator: Option<&CFAllocator>,
                xml_data: Option<&CFData>,
                data_source: Option<&CFURL>,
                parse_options: CFOptionFlags,
                version_of_nodes: CFIndex,
                call_backs: *mut CFXMLParserCallBacks,
                context: *mut CFXMLParserContext,
            ) -> Option<NonNull<CFXMLParser>>;
        }
        let ret = unsafe {
            CFXMLParserCreate(
                allocator,
                xml_data,
                data_source,
                parse_options,
                version_of_nodes,
                call_backs,
                context,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a new XML parser for the specified XML data at the specified URL.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - dataSource: The URL from which to load the XML data. The URL is used to resolve any relative references found in XML Data. It must be a valid CFURL object; `NULL` is an unacceptable value.
    ///
    /// - parseOptions: Flags which control how the XML data will be parsed. See [`CFXMLParserOptions`](https://developer.apple.com/documentation/corefoundation/cfxmlparseroptions) for the list of available options.
    ///
    /// - versionOfNodes: Determines which version of CFXMLNode objects are produced by the parser.
    ///
    /// - callBacks: Callbacks called by the parser as the XML is processed. The callbacks are called as each XML tag is encountered, when an external entity needs to be resolved, and when an error occurs. See [`CFXMLParserCallBacks`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercallbacks) and the individual callbacks for more details. Do not pass `NULL`.
    ///
    /// - context: Determines what, if any, information pointer is passed to the callbacks as the parse progresses; may be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// The newly created parser. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `data_source` might not allow `None`.
    /// - `call_backs` must be a valid pointer.
    /// - `context` must be a valid pointer.
    #[doc(alias = "CFXMLParserCreateWithDataFromURL")]
    #[cfg(all(feature = "CFData", feature = "CFURL", feature = "CFXMLNode"))]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub unsafe fn with_data_from_url(
        allocator: Option<&CFAllocator>,
        data_source: Option<&CFURL>,
        parse_options: CFOptionFlags,
        version_of_nodes: CFIndex,
        call_backs: *mut CFXMLParserCallBacks,
        context: *mut CFXMLParserContext,
    ) -> Option<CFRetained<CFXMLParser>> {
        extern "C-unwind" {
            fn CFXMLParserCreateWithDataFromURL(
                allocator: Option<&CFAllocator>,
                data_source: Option<&CFURL>,
                parse_options: CFOptionFlags,
                version_of_nodes: CFIndex,
                call_backs: *mut CFXMLParserCallBacks,
                context: *mut CFXMLParserContext,
            ) -> Option<NonNull<CFXMLParser>>;
        }
        let ret = unsafe {
            CFXMLParserCreateWithDataFromURL(
                allocator,
                data_source,
                parse_options,
                version_of_nodes,
                call_backs,
                context,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the context for an XML parser.
    ///
    /// Parameters:
    /// - parser: The XML parser to examine.
    ///
    /// - context: On return, a pointer to the context structure for `parser`.
    ///
    ///
    /// ## Discussion
    ///
    /// If you set a context for the parser, it will be passed to you as a parameter in each of the parser callback functions. The context data structure is application defined and associated with a parser using one of the `CFXMLParserCreate...` functions.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `context` must be a valid pointer.
    #[doc(alias = "CFXMLParserGetContext")]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub unsafe fn context(&self, context: *mut CFXMLParserContext) {
        extern "C-unwind" {
            fn CFXMLParserGetContext(parser: &CFXMLParser, context: *mut CFXMLParserContext);
        }
        unsafe { CFXMLParserGetContext(self, context) }
    }

    /// Returns the callbacks associated with an XML parser when it was created.
    ///
    /// Parameters:
    /// - parser: The XML parser to examine.
    ///
    /// - callBacks: On return, contains the callbacks for `parser`.
    ///
    ///
    /// # Safety
    ///
    /// `call_backs` must be a valid pointer.
    #[doc(alias = "CFXMLParserGetCallBacks")]
    #[cfg(all(feature = "CFData", feature = "CFURL", feature = "CFXMLNode"))]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub unsafe fn call_backs(&self, call_backs: *mut CFXMLParserCallBacks) {
        extern "C-unwind" {
            fn CFXMLParserGetCallBacks(parser: &CFXMLParser, call_backs: *mut CFXMLParserCallBacks);
        }
        unsafe { CFXMLParserGetCallBacks(self, call_backs) }
    }

    /// Returns the URL for the XML data being parsed.
    ///
    /// Parameters:
    /// - parser: The XML parser to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The URL for the XML document being parsed. Ownership follows the [The Get Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-SW1).
    ///
    ///
    #[doc(alias = "CFXMLParserGetSourceURL")]
    #[cfg(feature = "CFURL")]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub fn source_url(&self) -> Option<CFRetained<CFURL>> {
        extern "C-unwind" {
            fn CFXMLParserGetSourceURL(parser: &CFXMLParser) -> Option<NonNull<CFURL>>;
        }
        let ret = unsafe { CFXMLParserGetSourceURL(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the character index of the current parse location.
    ///
    /// Parameters:
    /// - parser: The XML parser to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The character index of the current parse location.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is typically used in conjunction with the [`CFXMLParserHandleErrorCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparserhandleerrorcallback) function so that error location information can be reported.
    ///
    ///
    #[doc(alias = "CFXMLParserGetLocation")]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub fn location(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFXMLParserGetLocation(parser: &CFXMLParser) -> CFIndex;
        }
        unsafe { CFXMLParserGetLocation(self) }
    }

    /// Returns the line number of the current parse location.
    ///
    /// Parameters:
    /// - parser: The XML parser to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The line number of the current location.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function is typically used in conjunction with the [`CFXMLParserHandleErrorCallBack`](https://developer.apple.com/documentation/corefoundation/cfxmlparserhandleerrorcallback) function so that error location information can be reported.
    ///
    ///
    #[doc(alias = "CFXMLParserGetLineNumber")]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub fn line_number(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFXMLParserGetLineNumber(parser: &CFXMLParser) -> CFIndex;
        }
        unsafe { CFXMLParserGetLineNumber(self) }
    }

    /// Returns the top-most object returned by the create XML structure callback.
    ///
    /// Parameters:
    /// - parser: The XML parser to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The top-most object returned by the `createXMLStructure` field in the [`CFXMLParserCallBacks`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercallbacks) structure. If the returned value is a Core Foundation object, ownership follows the [The Get Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-SW1).
    ///
    ///
    #[doc(alias = "CFXMLParserGetDocument")]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub fn document(&self) -> *mut c_void {
        extern "C-unwind" {
            fn CFXMLParserGetDocument(parser: &CFXMLParser) -> *mut c_void;
        }
        unsafe { CFXMLParserGetDocument(self) }
    }

    /// Returns a numeric code indicating the current status of the parser.
    ///
    /// Parameters:
    /// - parser: The XML parser to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A status code indicating the current parser. See [`CFXMLParserStatusCode`](https://developer.apple.com/documentation/corefoundation/cfxmlparserstatuscode) for a list of possible status codes.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If an error has occurred, the code for the last error is returned. If no error has occurred, a status code is returned.
    ///
    ///
    #[doc(alias = "CFXMLParserGetStatusCode")]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub fn status_code(&self) -> CFXMLParserStatusCode {
        extern "C-unwind" {
            fn CFXMLParserGetStatusCode(parser: &CFXMLParser) -> CFXMLParserStatusCode;
        }
        unsafe { CFXMLParserGetStatusCode(self) }
    }

    /// Returns the user-readable description of the current error condition.
    ///
    /// Parameters:
    /// - parser: The XML parser to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A user-readable description of the current error condition, or `NULL` if no error occurred. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    #[doc(alias = "CFXMLParserCopyErrorDescription")]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub fn error_description(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFXMLParserCopyErrorDescription(parser: &CFXMLParser) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFXMLParserCopyErrorDescription(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Causes a parser to abort with the given error code and description.
    ///
    /// Parameters:
    /// - parser: The parser to abort.
    ///
    /// - errorCode: The error code to return to the parser.
    ///
    /// - errorDescription: The error description string to return to the parser. This value may not be `NULL`.
    ///
    ///
    /// ## Discussion
    ///
    /// This function cannot be called asynchronously. In other words, it must be called from within a parser callback function.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `error_description` might not allow `None`.
    #[doc(alias = "CFXMLParserAbort")]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub unsafe fn abort(
        &self,
        error_code: CFXMLParserStatusCode,
        error_description: Option<&CFString>,
    ) {
        extern "C-unwind" {
            fn CFXMLParserAbort(
                parser: &CFXMLParser,
                error_code: CFXMLParserStatusCode,
                error_description: Option<&CFString>,
            );
        }
        unsafe { CFXMLParserAbort(self, error_code, error_description) }
    }

    /// Begins a parse of the XML data that was associated with the parser when it was created.
    ///
    /// Parameters:
    /// - parser: The XML parser to start.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if the parse was successful, `false` otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Upon success, use the [`CFXMLParserGetDocument`](https://developer.apple.com/documentation/corefoundation/cfxmlparsergetdocument) function to get the product of the parse. Upon failure, use the [`CFXMLParserGetContext`](https://developer.apple.com/documentation/corefoundation/cfxmlparsergetcontext) or [`CFXMLParserCopyErrorDescription`](https://developer.apple.com/documentation/corefoundation/cfxmlparsercopyerrordescription) functions to get information about the error. It is an error to call the [`CFXMLParserParse`](https://developer.apple.com/documentation/corefoundation/cfxmlparserparse) function while a parse is already underway.
    ///
    ///
    #[doc(alias = "CFXMLParserParse")]
    #[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
    #[inline]
    pub fn parse(&self) -> bool {
        extern "C-unwind" {
            fn CFXMLParserParse(parser: &CFXMLParser) -> Boolean;
        }
        let ret = unsafe { CFXMLParserParse(self) };
        ret != 0
    }
}

/// Parses the given XML data and returns the resulting CFXMLTree object.
///
/// Parameters:
/// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
///
/// - xmlData: The XML data you wish to parse.
///
/// - dataSource: The URL from which the XML data was obtained. The URL is used to resolve any relative references found in `xmlData`. Pass `NULL` if a valid URL is unavailable.
///
/// - parseOptions: Flags which control how the XML data will be parsed. See [`CFXMLParserOptions`](https://developer.apple.com/documentation/corefoundation/cfxmlparseroptions) for the list of available options.
///
/// - versionOfNodes: Determines which version of CFXMLNode objects are produced by the parser.
///
///
/// ## Return Value
///
/// A new CFXMLTree object containing the data from the specified XML document. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
///
///
///
/// ## Discussion
///
/// This function represents the high-level interface to the XML parser. This single function creates a parser for the specified XML data using the specified options. The parser creates and returns a CFXMLTree object that you can examine and modify with the CFTree functions or obtain the node using the [`CFXMLTreeGetNode`](https://developer.apple.com/documentation/corefoundation/cfxmltreegetnode) function and examine its attributes using CFXMLNode functions.
///
///
///
/// # Safety
///
/// - `allocator` might not allow `None`.
/// - `xml_data` might not allow `None`.
/// - `data_source` might not allow `None`.
#[cfg(all(
    feature = "CFData",
    feature = "CFTree",
    feature = "CFURL",
    feature = "CFXMLNode"
))]
#[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
#[inline]
pub unsafe extern "C-unwind" fn CFXMLTreeCreateFromData(
    allocator: Option<&CFAllocator>,
    xml_data: Option<&CFData>,
    data_source: Option<&CFURL>,
    parse_options: CFOptionFlags,
    version_of_nodes: CFIndex,
) -> Option<CFRetained<CFXMLTree>> {
    extern "C-unwind" {
        fn CFXMLTreeCreateFromData(
            allocator: Option<&CFAllocator>,
            xml_data: Option<&CFData>,
            data_source: Option<&CFURL>,
            parse_options: CFOptionFlags,
            version_of_nodes: CFIndex,
        ) -> Option<NonNull<CFXMLTree>>;
    }
    let ret = unsafe {
        CFXMLTreeCreateFromData(
            allocator,
            xml_data,
            data_source,
            parse_options,
            version_of_nodes,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Parses the given XML data and returns the resulting CFXMLTree object and any error information.
///
/// Parameters:
/// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
///
/// - xmlData: The XML data you wish to parse.
///
/// - dataSource: The URL from which the XML data was obtained. The URL is used to resolve any relative references found in `xmlData`. Pass `NULL` if a valid URL is unavailable.
///
/// - parseOptions: Flags which control how the XML data will be parsed. See [`CFXMLParserOptions`](https://developer.apple.com/documentation/corefoundation/cfxmlparseroptions) for the list of available options.
///
/// - versionOfNodes: Determines which version of CFXMLNode objects are produced by the parser. The current version is 1.
///
/// - errorDict: Upon return, if an error occurs contains a CFDictionary object that describes the error. If no errors occur, this parameter is not changed. Pass `NULL` if you don’t want error information. See [Error Dictionary Keys](https://developer.apple.com/documentation/corefoundation/error-dictionary-keys) for a description of the key-value pairs in this dictionary. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
///
///
/// ## Return Value
///
/// A new CFXMLTree object containing the data from the specified XML document. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
///
///
///
/// ## Discussion
///
/// Use this function instead of [`CFXMLTreeCreateFromData`](https://developer.apple.com/documentation/corefoundation/cfxmltreecreatefromdata) if you need access to XML parsing errors.
///
///
///
/// # Safety
///
/// - `allocator` might not allow `None`.
/// - `xml_data` might not allow `None`.
/// - `data_source` might not allow `None`.
/// - `error_dict` must be a valid pointer.
#[cfg(all(
    feature = "CFData",
    feature = "CFDictionary",
    feature = "CFTree",
    feature = "CFURL",
    feature = "CFXMLNode"
))]
#[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
#[inline]
pub unsafe extern "C-unwind" fn CFXMLTreeCreateFromDataWithError(
    allocator: Option<&CFAllocator>,
    xml_data: Option<&CFData>,
    data_source: Option<&CFURL>,
    parse_options: CFOptionFlags,
    version_of_nodes: CFIndex,
    error_dict: *mut *const CFDictionary,
) -> Option<CFRetained<CFXMLTree>> {
    extern "C-unwind" {
        fn CFXMLTreeCreateFromDataWithError(
            allocator: Option<&CFAllocator>,
            xml_data: Option<&CFData>,
            data_source: Option<&CFURL>,
            parse_options: CFOptionFlags,
            version_of_nodes: CFIndex,
            error_dict: *mut *const CFDictionary,
        ) -> Option<NonNull<CFXMLTree>>;
    }
    let ret = unsafe {
        CFXMLTreeCreateFromDataWithError(
            allocator,
            xml_data,
            data_source,
            parse_options,
            version_of_nodes,
            error_dict,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Creates a new CFXMLTree object by loading the data to be parsed directly from a data source.
///
/// Parameters:
/// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
///
/// - dataSource: The URL from which the XML data is obtained. The URL is used to resolve any relative references found in XML Data. Pass `NULL` if a valid URL is unavailable.
///
/// - parseOptions: Flags which control how the XML data will be parsed. See [`CFXMLParserOptions`](https://developer.apple.com/documentation/corefoundation/cfxmlparseroptions) for the list of available options.
///
/// - versionOfNodes: Determines which version of CFXMLNode objects are produced by the parser.
///
///
/// ## Return Value
///
/// A new CFXMLTree object containing the data from the specified XML data source. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
///
///
///
/// # Safety
///
/// - `allocator` might not allow `None`.
/// - `data_source` might not allow `None`.
#[cfg(all(feature = "CFTree", feature = "CFURL", feature = "CFXMLNode"))]
#[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
#[inline]
pub unsafe extern "C-unwind" fn CFXMLTreeCreateWithDataFromURL(
    allocator: Option<&CFAllocator>,
    data_source: Option<&CFURL>,
    parse_options: CFOptionFlags,
    version_of_nodes: CFIndex,
) -> Option<CFRetained<CFXMLTree>> {
    extern "C-unwind" {
        fn CFXMLTreeCreateWithDataFromURL(
            allocator: Option<&CFAllocator>,
            data_source: Option<&CFURL>,
            parse_options: CFOptionFlags,
            version_of_nodes: CFIndex,
        ) -> Option<NonNull<CFXMLTree>>;
    }
    let ret = unsafe {
        CFXMLTreeCreateWithDataFromURL(allocator, data_source, parse_options, version_of_nodes)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Generates an XML document from a CFXMLTree object which is ready to be written to permanent storage.
///
/// Parameters:
/// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
///
/// - xmlTree: The CFXMLTree object you wish to convert to an XML document.
///
///
/// ## Return Value
///
/// The XML data. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
///
///
///
/// ## Discussion
///
/// This function will _not_ regenerate entity references replaced at the parse time (except those required for syntactic correctness). If you need this you must manually walk the tree and re-insert any entity references that should appear in the final output file.
///
///
///
/// # Safety
///
/// - `allocator` might not allow `None`.
/// - `xml_tree` might not allow `None`.
#[cfg(all(feature = "CFData", feature = "CFTree", feature = "CFXMLNode"))]
#[deprecated = "CFXMLParser is deprecated, use NSXMLParser, NSXMLDocument or libxml2 library instead"]
#[inline]
pub unsafe extern "C-unwind" fn CFXMLTreeCreateXMLData(
    allocator: Option<&CFAllocator>,
    xml_tree: Option<&CFXMLTree>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CFXMLTreeCreateXMLData(
            allocator: Option<&CFAllocator>,
            xml_tree: Option<&CFXMLTree>,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { CFXMLTreeCreateXMLData(allocator, xml_tree) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Given a CFString object containing XML source with unescaped entities, returns a string with specified XML entities escaped.
///
/// Parameters:
/// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
///
/// - string: Any CFString object that may contain XML source. This function translates any substring that is mapped to an entity in `entitiesDictionary` to the specified entity.
///
/// - entitiesDictionary: Specifies the entities to be replaced. Dictionary keys should be the entity names (for example, “para” for ¶), and the values should be CFString objects containing the expansion. Pass `NULL` to indicate no entities other than the standard five.
///
///
/// ## Return Value
///
/// A CFString object derived from `string` with substrings identified in `entitiesDictionary` escaped to their corresponding entities. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
///
///
///
/// ## Discussion
///
/// The standard five predefined entities are automatically supported.
///
/// As an example of using this function, say you apply this function to string “Refer to ¶ 5 of the contract” with a key of “para” mapped to “¶” in `entitiesDictionary`. The resulting string is “Refer to ¶ 5 of the contract”.
///
/// <div class="warning">
///
/// ### Note
///  Currently, only the standard predefined entities are supported; passing `NULL` for `entitiesDictionary` is sufficient.
///
///
///
/// </div>
///
///
/// # Safety
///
/// - `allocator` might not allow `None`.
/// - `string` might not allow `None`.
/// - `entities_dictionary` generic must be of the correct type.
/// - `entities_dictionary` generic must be of the correct type.
/// - `entities_dictionary` might not allow `None`.
#[cfg(feature = "CFDictionary")]
#[inline]
pub unsafe extern "C-unwind" fn CFXMLCreateStringByEscapingEntities(
    allocator: Option<&CFAllocator>,
    string: Option<&CFString>,
    entities_dictionary: Option<&CFDictionary>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFXMLCreateStringByEscapingEntities(
            allocator: Option<&CFAllocator>,
            string: Option<&CFString>,
            entities_dictionary: Option<&CFDictionary>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret =
        unsafe { CFXMLCreateStringByEscapingEntities(allocator, string, entities_dictionary) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Given a CFString object containing XML source with escaped entities, returns a string with specified XML entities unescaped.
///
/// Parameters:
/// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
///
/// - string: Any CFString object that may contain XML source. This function translates any entity that is mapped to an substring in `entitiesDictionary` to the specified substring.
///
/// - entitiesDictionary: Specifies the entities to be replaced. Dictionary keys should be the entity names (for example, “para” for ¶), and the values should be CFString objects containing the expansion. Pass `NULL` to indicate no entities other than the standard five.
///
///
/// ## Return Value
///
/// A CFString object derived from `string` with entities identified in `entitiesDictionary` unescaped to their corresponding substrings. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
///
///
///
/// ## Discussion
///
/// The standard five predefined entities are automatically supported.
///
/// As an example of using this function, say you apply this function to string “Refer to ¶ 5 of the contract” with a key of “para” mapped to “¶” in `entitiesDictionary`. The resulting string is “Refer to ¶ 5 of the contract”.
///
/// <div class="warning">
///
/// ### Note
///  Currently, only the standard predefined entities are supported; passing `NULL` for `entitiesDictionary` is sufficient.
///
///
///
/// </div>
///
///
/// # Safety
///
/// - `allocator` might not allow `None`.
/// - `string` might not allow `None`.
/// - `entities_dictionary` generic must be of the correct type.
/// - `entities_dictionary` generic must be of the correct type.
/// - `entities_dictionary` might not allow `None`.
#[cfg(feature = "CFDictionary")]
#[inline]
pub unsafe extern "C-unwind" fn CFXMLCreateStringByUnescapingEntities(
    allocator: Option<&CFAllocator>,
    string: Option<&CFString>,
    entities_dictionary: Option<&CFDictionary>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFXMLCreateStringByUnescapingEntities(
            allocator: Option<&CFAllocator>,
            string: Option<&CFString>,
            entities_dictionary: Option<&CFDictionary>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret =
        unsafe { CFXMLCreateStringByUnescapingEntities(allocator, string, entities_dictionary) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C" {
    /// Dictionary key whose value is a CFString containing a readable description of the error.
    pub static kCFXMLTreeErrorDescription: Option<&'static CFString>;
}

extern "C" {
    /// Dictionary key whose value is a CFNumber containing the line number where the error was detected. This may not be the line number where the actual XML error is located.
    pub static kCFXMLTreeErrorLineNumber: Option<&'static CFString>;
}

extern "C" {
    /// Dictionary key whose value is a CFNumber containing the byte location where the error was detected.
    pub static kCFXMLTreeErrorLocation: Option<&'static CFString>;
}

extern "C" {
    /// Dictionary key whose value is a CFNumber containing the error status code. See [`CFXMLParserRef`](https://developer.apple.com/documentation/corefoundation/cfxmlparser) for possible status code values.
    pub static kCFXMLTreeErrorStatusCode: Option<&'static CFString>;
}

#[cfg(all(feature = "CFData", feature = "CFURL", feature = "CFXMLNode"))]
#[deprecated = "renamed to `CFXMLParser::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFXMLParserCreate(
    allocator: Option<&CFAllocator>,
    xml_data: Option<&CFData>,
    data_source: Option<&CFURL>,
    parse_options: CFOptionFlags,
    version_of_nodes: CFIndex,
    call_backs: *mut CFXMLParserCallBacks,
    context: *mut CFXMLParserContext,
) -> Option<CFRetained<CFXMLParser>> {
    extern "C-unwind" {
        fn CFXMLParserCreate(
            allocator: Option<&CFAllocator>,
            xml_data: Option<&CFData>,
            data_source: Option<&CFURL>,
            parse_options: CFOptionFlags,
            version_of_nodes: CFIndex,
            call_backs: *mut CFXMLParserCallBacks,
            context: *mut CFXMLParserContext,
        ) -> Option<NonNull<CFXMLParser>>;
    }
    let ret = unsafe {
        CFXMLParserCreate(
            allocator,
            xml_data,
            data_source,
            parse_options,
            version_of_nodes,
            call_backs,
            context,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CFData", feature = "CFURL", feature = "CFXMLNode"))]
#[deprecated = "renamed to `CFXMLParser::with_data_from_url`"]
#[inline]
pub unsafe extern "C-unwind" fn CFXMLParserCreateWithDataFromURL(
    allocator: Option<&CFAllocator>,
    data_source: Option<&CFURL>,
    parse_options: CFOptionFlags,
    version_of_nodes: CFIndex,
    call_backs: *mut CFXMLParserCallBacks,
    context: *mut CFXMLParserContext,
) -> Option<CFRetained<CFXMLParser>> {
    extern "C-unwind" {
        fn CFXMLParserCreateWithDataFromURL(
            allocator: Option<&CFAllocator>,
            data_source: Option<&CFURL>,
            parse_options: CFOptionFlags,
            version_of_nodes: CFIndex,
            call_backs: *mut CFXMLParserCallBacks,
            context: *mut CFXMLParserContext,
        ) -> Option<NonNull<CFXMLParser>>;
    }
    let ret = unsafe {
        CFXMLParserCreateWithDataFromURL(
            allocator,
            data_source,
            parse_options,
            version_of_nodes,
            call_backs,
            context,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFXMLParser::context`"]
    pub fn CFXMLParserGetContext(parser: &CFXMLParser, context: *mut CFXMLParserContext);
}

extern "C-unwind" {
    #[cfg(all(feature = "CFData", feature = "CFURL", feature = "CFXMLNode"))]
    #[deprecated = "renamed to `CFXMLParser::call_backs`"]
    pub fn CFXMLParserGetCallBacks(parser: &CFXMLParser, call_backs: *mut CFXMLParserCallBacks);
}

#[cfg(feature = "CFURL")]
#[deprecated = "renamed to `CFXMLParser::source_url`"]
#[inline]
pub extern "C-unwind" fn CFXMLParserGetSourceURL(
    parser: &CFXMLParser,
) -> Option<CFRetained<CFURL>> {
    extern "C-unwind" {
        fn CFXMLParserGetSourceURL(parser: &CFXMLParser) -> Option<NonNull<CFURL>>;
    }
    let ret = unsafe { CFXMLParserGetSourceURL(parser) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CFXMLParser::location`"]
#[inline]
pub extern "C-unwind" fn CFXMLParserGetLocation(parser: &CFXMLParser) -> CFIndex {
    extern "C-unwind" {
        fn CFXMLParserGetLocation(parser: &CFXMLParser) -> CFIndex;
    }
    unsafe { CFXMLParserGetLocation(parser) }
}

#[deprecated = "renamed to `CFXMLParser::line_number`"]
#[inline]
pub extern "C-unwind" fn CFXMLParserGetLineNumber(parser: &CFXMLParser) -> CFIndex {
    extern "C-unwind" {
        fn CFXMLParserGetLineNumber(parser: &CFXMLParser) -> CFIndex;
    }
    unsafe { CFXMLParserGetLineNumber(parser) }
}

#[deprecated = "renamed to `CFXMLParser::document`"]
#[inline]
pub extern "C-unwind" fn CFXMLParserGetDocument(parser: &CFXMLParser) -> *mut c_void {
    extern "C-unwind" {
        fn CFXMLParserGetDocument(parser: &CFXMLParser) -> *mut c_void;
    }
    unsafe { CFXMLParserGetDocument(parser) }
}

#[deprecated = "renamed to `CFXMLParser::status_code`"]
#[inline]
pub extern "C-unwind" fn CFXMLParserGetStatusCode(parser: &CFXMLParser) -> CFXMLParserStatusCode {
    extern "C-unwind" {
        fn CFXMLParserGetStatusCode(parser: &CFXMLParser) -> CFXMLParserStatusCode;
    }
    unsafe { CFXMLParserGetStatusCode(parser) }
}

#[deprecated = "renamed to `CFXMLParser::error_description`"]
#[inline]
pub extern "C-unwind" fn CFXMLParserCopyErrorDescription(
    parser: &CFXMLParser,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFXMLParserCopyErrorDescription(parser: &CFXMLParser) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFXMLParserCopyErrorDescription(parser) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFXMLParser::abort`"]
    pub fn CFXMLParserAbort(
        parser: &CFXMLParser,
        error_code: CFXMLParserStatusCode,
        error_description: Option<&CFString>,
    );
}

#[deprecated = "renamed to `CFXMLParser::parse`"]
#[inline]
pub extern "C-unwind" fn CFXMLParserParse(parser: &CFXMLParser) -> bool {
    extern "C-unwind" {
        fn CFXMLParserParse(parser: &CFXMLParser) -> Boolean;
    }
    let ret = unsafe { CFXMLParserParse(parser) };
    ret != 0
}
