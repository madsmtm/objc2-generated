//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// A binary value of either `0` or `1`.
pub type CFBit = u32;

///
/// ## Overview
///
/// CFBitVector and its derived mutable type, [`CFMutableBitVectorRef`](https://developer.apple.com/documentation/corefoundation/cfmutablebitvector), manage ordered collections of bit values, which are either `0` or `1`. CFBitVector creates static bit vectors and CFMutableBitVector creates dynamic bit vectors.
///
///
#[doc(alias = "CFBitVectorRef")]
#[repr(C)]
pub struct CFBitVector {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFBitVector {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFBitVector"> for CFBitVector {}
);

///
/// ## Overview
///
/// CFMutableBitVector objects manage dynamic bit vectors. The basic interface for managing bit vectors is provided by [`CFBitVectorRef`](https://developer.apple.com/documentation/corefoundation/cfbitvector). CFMutableBitVector adds functions to modify the contents of a bit vector.
///
/// You create a mutable bit vector object using either the [`CFBitVectorCreateMutable`](https://developer.apple.com/documentation/corefoundation/cfbitvectorcreatemutable(_:_:)) or [`CFBitVectorCreateMutableCopy`](https://developer.apple.com/documentation/corefoundation/cfbitvectorcreatemutablecopy(_:_:_:)) function. You add to and remove from a bit vector by altering the size of the bit vector with the [`CFBitVectorSetCount`](https://developer.apple.com/documentation/corefoundation/cfbitvectorsetcount(_:_:)) function
///
///
#[doc(alias = "CFMutableBitVectorRef")]
#[repr(C)]
pub struct CFMutableBitVector {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFMutableBitVector: CFBitVector {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFBitVector"> for CFMutableBitVector {}
);

unsafe impl ConcreteType for CFBitVector {
    /// Returns the type identifier for the CFBitVector opaque type.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the CFBitVector opaque type.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// CFMutableBitVector objects have the same type identifier as CFBitVector objects.
    ///
    ///
    #[doc(alias = "CFBitVectorGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFBitVectorGetTypeID() -> CFTypeID;
        }
        unsafe { CFBitVectorGetTypeID() }
    }
}

impl CFBitVector {
    /// Creates an immutable bit vector from a block of memory.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new bit vector. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - bytes: A pointer to the bit values to store in the new bit vector. The values are copied into the bit vector’s own memory. The bit indices are numbered left-to-right with `0` being the left-most, or most-significant, bit in the byte stream.
    ///
    /// - numBits: The number of bits in the bit vector.
    ///
    ///
    /// ## Return Value
    ///
    /// A new bit vector. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `bytes` must be a valid pointer.
    #[doc(alias = "CFBitVectorCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        bytes: *const u8,
        num_bits: CFIndex,
    ) -> Option<CFRetained<CFBitVector>> {
        extern "C-unwind" {
            fn CFBitVectorCreate(
                allocator: Option<&CFAllocator>,
                bytes: *const u8,
                num_bits: CFIndex,
            ) -> Option<NonNull<CFBitVector>>;
        }
        let ret = unsafe { CFBitVectorCreate(allocator, bytes, num_bits) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates an immutable bit vector that is a copy of another bit vector.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new bit vector. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - bv: The bit vector to copy.
    ///
    ///
    /// ## Return Value
    ///
    /// A new bit vector holding the same bit values as `bv`. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `bv` might not allow `None`.
    #[doc(alias = "CFBitVectorCreateCopy")]
    #[inline]
    pub unsafe fn new_copy(
        allocator: Option<&CFAllocator>,
        bv: Option<&CFBitVector>,
    ) -> Option<CFRetained<CFBitVector>> {
        extern "C-unwind" {
            fn CFBitVectorCreateCopy(
                allocator: Option<&CFAllocator>,
                bv: Option<&CFBitVector>,
            ) -> Option<NonNull<CFBitVector>>;
        }
        let ret = unsafe { CFBitVectorCreateCopy(allocator, bv) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFMutableBitVector {
    /// Creates a mutable bit vector.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - capacity: The maximum number of values that can be contained by the new bit vector. The bit vector starts empty and can grow to this number of values (and it can have less).
    ///
    /// Pass `0` to specify that the maximum capacity is not limited. The value must not be negative.
    ///
    ///
    /// ## Return Value
    ///
    /// A new bit vector. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `allocator` might not allow `None`.
    #[doc(alias = "CFBitVectorCreateMutable")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
    ) -> Option<CFRetained<CFMutableBitVector>> {
        extern "C-unwind" {
            fn CFBitVectorCreateMutable(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
            ) -> Option<NonNull<CFMutableBitVector>>;
        }
        let ret = unsafe { CFBitVectorCreateMutable(allocator, capacity) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a new mutable bit vector from a pre-existing bit vector.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - capacity: The maximum number of values that can be contained by the new bit vector. The bit vector starts with the same number of values as `bv` and can grow to this number of values (it can have less).
    ///
    /// Pass `0` to specify that the maximum capacity is not limited. If non-`0`, `capacity` must be large enough to hold all bit values from `bv`.
    ///
    /// - bv: The bit vector to copy.
    ///
    ///
    /// ## Return Value
    ///
    /// A new bit vector holding the same bit values as `bv`. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029)
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `bv` might not allow `None`.
    #[doc(alias = "CFBitVectorCreateMutableCopy")]
    #[inline]
    pub unsafe fn new_copy(
        allocator: Option<&CFAllocator>,
        capacity: CFIndex,
        bv: Option<&CFBitVector>,
    ) -> Option<CFRetained<CFMutableBitVector>> {
        extern "C-unwind" {
            fn CFBitVectorCreateMutableCopy(
                allocator: Option<&CFAllocator>,
                capacity: CFIndex,
                bv: Option<&CFBitVector>,
            ) -> Option<NonNull<CFMutableBitVector>>;
        }
        let ret = unsafe { CFBitVectorCreateMutableCopy(allocator, capacity, bv) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CFBitVector {
    /// Returns the number of bit values in a bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// The current size of `bv`.
    ///
    ///
    #[doc(alias = "CFBitVectorGetCount")]
    #[inline]
    pub fn count(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFBitVectorGetCount(bv: &CFBitVector) -> CFIndex;
        }
        unsafe { CFBitVectorGetCount(self) }
    }

    /// Counts the number of times a certain bit value occurs within a range of bits in a bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to examine.
    ///
    /// - range: The range of bits in `bv` to search.
    ///
    /// - value: The bit value to count.
    ///
    ///
    /// ## Return Value
    ///
    /// The number of occurrences of `value` in the specified range of `bv`.
    ///
    ///
    #[doc(alias = "CFBitVectorGetCountOfBit")]
    #[inline]
    pub fn count_of_bit(&self, range: CFRange, value: CFBit) -> CFIndex {
        extern "C-unwind" {
            fn CFBitVectorGetCountOfBit(bv: &CFBitVector, range: CFRange, value: CFBit) -> CFIndex;
        }
        unsafe { CFBitVectorGetCountOfBit(self, range, value) }
    }

    /// Returns whether a bit vector contains a particular bit value.
    ///
    /// Parameters:
    /// - bv: The bit vector to search.
    ///
    /// - range: The range of bits in `bv` to search.
    ///
    /// - value: The bit value for which to search.
    ///
    ///
    /// ## Return Value
    ///
    /// `true` if the specified range of bits in `bv` contains `value`, otherwise `false`.
    ///
    ///
    #[doc(alias = "CFBitVectorContainsBit")]
    #[inline]
    pub fn contains_bit(&self, range: CFRange, value: CFBit) -> bool {
        extern "C-unwind" {
            fn CFBitVectorContainsBit(bv: &CFBitVector, range: CFRange, value: CFBit) -> Boolean;
        }
        let ret = unsafe { CFBitVectorContainsBit(self, range, value) };
        ret != 0
    }

    /// Returns the bit value at a given index in a bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to examine.
    ///
    /// - idx: The index of the bit value in `bv` to return.
    ///
    ///
    /// ## Return Value
    ///
    /// The bit value at index `idx` in `bv`.
    ///
    ///
    #[doc(alias = "CFBitVectorGetBitAtIndex")]
    #[inline]
    pub fn bit_at_index(&self, idx: CFIndex) -> CFBit {
        extern "C-unwind" {
            fn CFBitVectorGetBitAtIndex(bv: &CFBitVector, idx: CFIndex) -> CFBit;
        }
        unsafe { CFBitVectorGetBitAtIndex(self, idx) }
    }

    /// Returns the bit values in a range of indices in a bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to examine.
    ///
    /// - range: The range of bit values to return.
    ///
    /// - bytes: On return, contains the requested bit values from `bv`. This argument must point to enough memory to hold the number of bits requested. The requested bits are left-aligned with the first requested bit stored in the left-most, or most-significant, bit of the byte stream.
    ///
    ///
    /// # Safety
    ///
    /// `bytes` must be a valid pointer.
    #[doc(alias = "CFBitVectorGetBits")]
    #[inline]
    pub unsafe fn bits(&self, range: CFRange, bytes: *mut u8) {
        extern "C-unwind" {
            fn CFBitVectorGetBits(bv: &CFBitVector, range: CFRange, bytes: *mut u8);
        }
        unsafe { CFBitVectorGetBits(self, range, bytes) }
    }

    /// Locates the first occurrence of a certain bit value within a range of bits in a bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to examine.
    ///
    /// - range: The range of bits in `bv` to search.
    ///
    /// - value: The bit value for which to search.
    ///
    ///
    /// ## Return Value
    ///
    /// The index of the first occurrence of `value` in the specified range of `bv`, or `kCFNotFound` if `value` is not present.
    ///
    ///
    #[doc(alias = "CFBitVectorGetFirstIndexOfBit")]
    #[inline]
    pub fn first_index_of_bit(&self, range: CFRange, value: CFBit) -> CFIndex {
        extern "C-unwind" {
            fn CFBitVectorGetFirstIndexOfBit(
                bv: &CFBitVector,
                range: CFRange,
                value: CFBit,
            ) -> CFIndex;
        }
        unsafe { CFBitVectorGetFirstIndexOfBit(self, range, value) }
    }

    /// Locates the last occurrence of a certain bit value within a range of bits in a bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to examine.
    ///
    /// - range: The range of bits in `bv` to search.
    ///
    /// - value: The bit value for which to search.
    ///
    ///
    /// ## Return Value
    ///
    /// The index of the last occurrence of `value` in the specified range of `bv`, or `kCFNotFound` if `value` is not present.
    ///
    ///
    #[doc(alias = "CFBitVectorGetLastIndexOfBit")]
    #[inline]
    pub fn last_index_of_bit(&self, range: CFRange, value: CFBit) -> CFIndex {
        extern "C-unwind" {
            fn CFBitVectorGetLastIndexOfBit(
                bv: &CFBitVector,
                range: CFRange,
                value: CFBit,
            ) -> CFIndex;
        }
        unsafe { CFBitVectorGetLastIndexOfBit(self, range, value) }
    }
}

impl CFMutableBitVector {
    /// Changes the size of a mutable bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to modify.
    ///
    /// - count: The new size for `bv`. If `count` is greater than the current size of `bv`, the additional bit values are set to `0`.
    ///
    ///
    /// ## Discussion
    ///
    /// If `bv` was created with a fixed capacity, you cannot increase its size beyond that capacity.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `bv` might not allow `None`.
    #[doc(alias = "CFBitVectorSetCount")]
    #[inline]
    pub unsafe fn set_count(bv: Option<&CFMutableBitVector>, count: CFIndex) {
        extern "C-unwind" {
            fn CFBitVectorSetCount(bv: Option<&CFMutableBitVector>, count: CFIndex);
        }
        unsafe { CFBitVectorSetCount(bv, count) }
    }

    /// Flips a bit value in a bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to modify.
    ///
    /// - idx: The index of the bit value to flip. The index must be in the range `0…N-1`, where `N` is the count of the vector.
    ///
    ///
    /// # Safety
    ///
    /// `bv` might not allow `None`.
    #[doc(alias = "CFBitVectorFlipBitAtIndex")]
    #[inline]
    pub unsafe fn flip_bit_at_index(bv: Option<&CFMutableBitVector>, idx: CFIndex) {
        extern "C-unwind" {
            fn CFBitVectorFlipBitAtIndex(bv: Option<&CFMutableBitVector>, idx: CFIndex);
        }
        unsafe { CFBitVectorFlipBitAtIndex(bv, idx) }
    }

    /// Flips a range of bit values in a bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to modify.
    ///
    /// - range: The range of bit values in `bv` to flip. The range must not exceed `0…N-1`, where `N` is the count of the vector.
    ///
    ///
    /// # Safety
    ///
    /// `bv` might not allow `None`.
    #[doc(alias = "CFBitVectorFlipBits")]
    #[inline]
    pub unsafe fn flip_bits(bv: Option<&CFMutableBitVector>, range: CFRange) {
        extern "C-unwind" {
            fn CFBitVectorFlipBits(bv: Option<&CFMutableBitVector>, range: CFRange);
        }
        unsafe { CFBitVectorFlipBits(bv, range) }
    }

    /// Sets the value of a particular bit in a bit vector.
    ///
    /// Parameters:
    /// - bv: The bit vector to modify.
    ///
    /// - idx: The index of the bit value to set. The index must be in the range `0…N-1`, where `N` is the count of the vector.
    ///
    /// - value: The bit value to which to set the bit at index `idx`.
    ///
    ///
    /// # Safety
    ///
    /// `bv` might not allow `None`.
    #[doc(alias = "CFBitVectorSetBitAtIndex")]
    #[inline]
    pub unsafe fn set_bit_at_index(bv: Option<&CFMutableBitVector>, idx: CFIndex, value: CFBit) {
        extern "C-unwind" {
            fn CFBitVectorSetBitAtIndex(
                bv: Option<&CFMutableBitVector>,
                idx: CFIndex,
                value: CFBit,
            );
        }
        unsafe { CFBitVectorSetBitAtIndex(bv, idx, value) }
    }

    /// Sets a range of bits in a bit vector to a particular value.
    ///
    /// Parameters:
    /// - bv: The bit vector to modify.
    ///
    /// - range: The range of bits to set. The range must not exceed `0…N-1`, where `N` is the count of the vector.
    ///
    /// - value: The bit value to which to set the range of bits.
    ///
    ///
    /// # Safety
    ///
    /// `bv` might not allow `None`.
    #[doc(alias = "CFBitVectorSetBits")]
    #[inline]
    pub unsafe fn set_bits(bv: Option<&CFMutableBitVector>, range: CFRange, value: CFBit) {
        extern "C-unwind" {
            fn CFBitVectorSetBits(bv: Option<&CFMutableBitVector>, range: CFRange, value: CFBit);
        }
        unsafe { CFBitVectorSetBits(bv, range, value) }
    }

    /// Sets all bits in a bit vector to a particular value.
    ///
    /// Parameters:
    /// - bv: The bit vector to modify.
    ///
    /// - value: The bit value to which to set all bits in `bv`.
    ///
    ///
    /// # Safety
    ///
    /// `bv` might not allow `None`.
    #[doc(alias = "CFBitVectorSetAllBits")]
    #[inline]
    pub unsafe fn set_all_bits(bv: Option<&CFMutableBitVector>, value: CFBit) {
        extern "C-unwind" {
            fn CFBitVectorSetAllBits(bv: Option<&CFMutableBitVector>, value: CFBit);
        }
        unsafe { CFBitVectorSetAllBits(bv, value) }
    }
}

#[deprecated = "renamed to `CFBitVector::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFBitVectorCreate(
    allocator: Option<&CFAllocator>,
    bytes: *const u8,
    num_bits: CFIndex,
) -> Option<CFRetained<CFBitVector>> {
    extern "C-unwind" {
        fn CFBitVectorCreate(
            allocator: Option<&CFAllocator>,
            bytes: *const u8,
            num_bits: CFIndex,
        ) -> Option<NonNull<CFBitVector>>;
    }
    let ret = unsafe { CFBitVectorCreate(allocator, bytes, num_bits) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFBitVector::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFBitVectorCreateCopy(
    allocator: Option<&CFAllocator>,
    bv: Option<&CFBitVector>,
) -> Option<CFRetained<CFBitVector>> {
    extern "C-unwind" {
        fn CFBitVectorCreateCopy(
            allocator: Option<&CFAllocator>,
            bv: Option<&CFBitVector>,
        ) -> Option<NonNull<CFBitVector>>;
    }
    let ret = unsafe { CFBitVectorCreateCopy(allocator, bv) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableBitVector::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFBitVectorCreateMutable(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
) -> Option<CFRetained<CFMutableBitVector>> {
    extern "C-unwind" {
        fn CFBitVectorCreateMutable(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
        ) -> Option<NonNull<CFMutableBitVector>>;
    }
    let ret = unsafe { CFBitVectorCreateMutable(allocator, capacity) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFMutableBitVector::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CFBitVectorCreateMutableCopy(
    allocator: Option<&CFAllocator>,
    capacity: CFIndex,
    bv: Option<&CFBitVector>,
) -> Option<CFRetained<CFMutableBitVector>> {
    extern "C-unwind" {
        fn CFBitVectorCreateMutableCopy(
            allocator: Option<&CFAllocator>,
            capacity: CFIndex,
            bv: Option<&CFBitVector>,
        ) -> Option<NonNull<CFMutableBitVector>>;
    }
    let ret = unsafe { CFBitVectorCreateMutableCopy(allocator, capacity, bv) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFBitVector::count`"]
#[inline]
pub extern "C-unwind" fn CFBitVectorGetCount(bv: &CFBitVector) -> CFIndex {
    extern "C-unwind" {
        fn CFBitVectorGetCount(bv: &CFBitVector) -> CFIndex;
    }
    unsafe { CFBitVectorGetCount(bv) }
}

#[deprecated = "renamed to `CFBitVector::count_of_bit`"]
#[inline]
pub extern "C-unwind" fn CFBitVectorGetCountOfBit(
    bv: &CFBitVector,
    range: CFRange,
    value: CFBit,
) -> CFIndex {
    extern "C-unwind" {
        fn CFBitVectorGetCountOfBit(bv: &CFBitVector, range: CFRange, value: CFBit) -> CFIndex;
    }
    unsafe { CFBitVectorGetCountOfBit(bv, range, value) }
}

#[deprecated = "renamed to `CFBitVector::contains_bit`"]
#[inline]
pub extern "C-unwind" fn CFBitVectorContainsBit(
    bv: &CFBitVector,
    range: CFRange,
    value: CFBit,
) -> bool {
    extern "C-unwind" {
        fn CFBitVectorContainsBit(bv: &CFBitVector, range: CFRange, value: CFBit) -> Boolean;
    }
    let ret = unsafe { CFBitVectorContainsBit(bv, range, value) };
    ret != 0
}

#[deprecated = "renamed to `CFBitVector::bit_at_index`"]
#[inline]
pub extern "C-unwind" fn CFBitVectorGetBitAtIndex(bv: &CFBitVector, idx: CFIndex) -> CFBit {
    extern "C-unwind" {
        fn CFBitVectorGetBitAtIndex(bv: &CFBitVector, idx: CFIndex) -> CFBit;
    }
    unsafe { CFBitVectorGetBitAtIndex(bv, idx) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFBitVector::bits`"]
    pub fn CFBitVectorGetBits(bv: &CFBitVector, range: CFRange, bytes: *mut u8);
}

#[deprecated = "renamed to `CFBitVector::first_index_of_bit`"]
#[inline]
pub extern "C-unwind" fn CFBitVectorGetFirstIndexOfBit(
    bv: &CFBitVector,
    range: CFRange,
    value: CFBit,
) -> CFIndex {
    extern "C-unwind" {
        fn CFBitVectorGetFirstIndexOfBit(bv: &CFBitVector, range: CFRange, value: CFBit)
            -> CFIndex;
    }
    unsafe { CFBitVectorGetFirstIndexOfBit(bv, range, value) }
}

#[deprecated = "renamed to `CFBitVector::last_index_of_bit`"]
#[inline]
pub extern "C-unwind" fn CFBitVectorGetLastIndexOfBit(
    bv: &CFBitVector,
    range: CFRange,
    value: CFBit,
) -> CFIndex {
    extern "C-unwind" {
        fn CFBitVectorGetLastIndexOfBit(bv: &CFBitVector, range: CFRange, value: CFBit) -> CFIndex;
    }
    unsafe { CFBitVectorGetLastIndexOfBit(bv, range, value) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableBitVector::set_count`"]
    pub fn CFBitVectorSetCount(bv: Option<&CFMutableBitVector>, count: CFIndex);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableBitVector::flip_bit_at_index`"]
    pub fn CFBitVectorFlipBitAtIndex(bv: Option<&CFMutableBitVector>, idx: CFIndex);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableBitVector::flip_bits`"]
    pub fn CFBitVectorFlipBits(bv: Option<&CFMutableBitVector>, range: CFRange);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableBitVector::set_bit_at_index`"]
    pub fn CFBitVectorSetBitAtIndex(bv: Option<&CFMutableBitVector>, idx: CFIndex, value: CFBit);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableBitVector::set_bits`"]
    pub fn CFBitVectorSetBits(bv: Option<&CFMutableBitVector>, range: CFRange, value: CFBit);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CFMutableBitVector::set_all_bits`"]
    pub fn CFBitVectorSetAllBits(bv: Option<&CFMutableBitVector>, value: CFBit);
}
