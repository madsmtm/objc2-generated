//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

// NS_TYPED_EXTENSIBLE_ENUM
pub type CFErrorDomain = CFString;

///
/// ## Overview
///
/// A CFError object encapsulates more rich and extensible error information than is possible using only an error code or error string. The core attributes of a CFError object are an error domain (represented by a string), a domain-specific error code, and a “user info” dictionary containing application-specific information. Errors are required to have a domain and an error code within that domain. Several well-known domains are defined corresponding to Mach, POSIX, and OSStatus errors.
///
/// The optional “user info” dictionary may provide additional information that might be useful for the interpretation and reporting of the error, including a human-readable description for the error. The “user info” dictionary sometimes includes another CFError object that represents an error in a subsystem underlying the error represented by the containing CFError object. This underlying error object may provide more specific information about the cause of the error.
///
/// In general, a method should signal an error condition by returning, for example, `false` or `NULL` rather than by the simple presence of an error object. The method can then optionally return an CFError object by reference, in order to further describe the error.
///
/// CFError is toll-free bridged to [`NSError`](https://developer.apple.com/documentation/foundation/nserror) in the Foundation framework—for more details on toll-free bridging, see [Toll-Free Bridged Types](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFDesignConcepts/Articles/tollFreeBridgedTypes.html#//apple_ref/doc/uid/TP40010677). `NSError` has some additional guidelines that make it easy to report errors automatically to users and attempt to recover from them. See [Error Handling Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ErrorHandlingCocoa/ErrorHandling/ErrorHandling.html#//apple_ref/doc/uid/TP40001806) for more information on `NSError` programming guidelines.
///
///
/// This is the type of a reference to CFErrors.  CFErrorRef is toll-free bridged with NSError.
///
/// This is toll-free bridged with `NSError`.
#[doc(alias = "CFErrorRef")]
#[repr(C)]
pub struct CFError {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFError {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFError"> for CFError {}
);

unsafe impl ConcreteType for CFError {
    /// Returns the type identifier for the CFError opaque type.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the CFError opaque type.
    ///
    ///
    /// Returns the type identifier of all CFError instances.
    #[doc(alias = "CFErrorGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFErrorGetTypeID() -> CFTypeID;
        }
        unsafe { CFErrorGetTypeID() }
    }
}

extern "C" {
    /// A constant that specified the POSIX domain.
    pub static kCFErrorDomainPOSIX: Option<&'static CFErrorDomain>;
}

extern "C" {
    /// A constant that specified the OS domain.
    pub static kCFErrorDomainOSStatus: Option<&'static CFErrorDomain>;
}

extern "C" {
    /// A constant that specified the Mach domain.
    pub static kCFErrorDomainMach: Option<&'static CFErrorDomain>;
}

extern "C" {
    /// A constant that specified the Cocoa domain.
    pub static kCFErrorDomainCocoa: Option<&'static CFErrorDomain>;
}

extern "C" {
    /// Key to identify the user-presentable description in the `userInfo` dictionary.
    pub static kCFErrorLocalizedDescriptionKey: Option<&'static CFString>;
}

extern "C" {
    pub static kCFErrorLocalizedFailureKey: Option<&'static CFString>;
}

extern "C" {
    /// Key to identify the user-presentable failure reason in the `userInfo` dictionary.
    pub static kCFErrorLocalizedFailureReasonKey: Option<&'static CFString>;
}

extern "C" {
    /// Key to identify the user-presentable recovery suggestion in the `userInfo` dictionary.
    pub static kCFErrorLocalizedRecoverySuggestionKey: Option<&'static CFString>;
}

extern "C" {
    /// Key to identify the description in the `userInfo` dictionary.
    ///
    /// ## Discussion
    ///
    /// When you create a CFError object, you can provide a value for this key if you do not have localizable error strings. The description should be a complete sentence if possible, and should not contain the domain name or error code.
    ///
    ///
    pub static kCFErrorDescriptionKey: Option<&'static CFString>;
}

extern "C" {
    /// Key to identify the underlying error in the `userInfo` dictionary.
    pub static kCFErrorUnderlyingErrorKey: Option<&'static CFString>;
}

extern "C" {
    /// Key to identify associated URL in the `userInfo` dictionary.
    pub static kCFErrorURLKey: Option<&'static CFString>;
}

extern "C" {
    /// Key to identify associated file path in the `userInfo` dictionary.
    pub static kCFErrorFilePathKey: Option<&'static CFString>;
}

impl CFError {
    /// Creates a new CFError object.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the current default allocator.
    ///
    /// - domain: A CFString that identifies the error domain. If this reference is `NULL` or is otherwise not a valid CFString, the behavior is undefined.
    ///
    /// - code: A CFIndex that identifies the error code. The code is interpreted within the context of the error domain.
    ///
    /// - userInfo: A CFDictionary created with [`kCFCopyStringDictionaryKeyCallBacks`](https://developer.apple.com/documentation/corefoundation/kcfcopystringdictionarykeycallbacks) and [`kCFTypeDictionaryValueCallBacks`](https://developer.apple.com/documentation/corefoundation/kcftypedictionaryvaluecallbacks). The dictionary is copied with [`CFDictionaryCreateCopy`](https://developer.apple.com/documentation/corefoundation/cfdictionarycreatecopy(_:_:)). If you do not want the userInfo dictionary, you can pass `NULL`, in which case an empty dictionary will be assigned.
    ///
    ///
    /// ## Return Value
    ///
    /// A new CFError object. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    /// Creates a new CFError.
    ///
    /// Parameter `allocator`: The CFAllocator which should be used to allocate memory for the error. This parameter may be NULL in which case the
    /// current default CFAllocator is used. If this reference is not a valid CFAllocator, the behavior is undefined.
    ///
    /// Parameter `domain`: A CFString identifying the error domain. If this reference is NULL or is otherwise not a valid CFString, the behavior is undefined.
    ///
    /// Parameter `code`: A CFIndex identifying the error code. The code is interpreted within the context of the error domain.
    ///
    /// Parameter `userInfo`: A CFDictionary created with kCFCopyStringDictionaryKeyCallBacks and kCFTypeDictionaryValueCallBacks. It will be copied with CFDictionaryCreateCopy().
    /// If no userInfo dictionary is desired, NULL may be passed in as a convenience, in which case an empty userInfo dictionary will be assigned.
    ///
    /// Returns: A reference to the new CFError.
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `domain` might not allow `None`.
    /// - `user_info` generic must be of the correct type.
    /// - `user_info` generic must be of the correct type.
    /// - `user_info` might not allow `None`.
    #[doc(alias = "CFErrorCreate")]
    #[cfg(feature = "CFDictionary")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        domain: Option<&CFErrorDomain>,
        code: CFIndex,
        user_info: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFError>> {
        extern "C-unwind" {
            fn CFErrorCreate(
                allocator: Option<&CFAllocator>,
                domain: Option<&CFErrorDomain>,
                code: CFIndex,
                user_info: Option<&CFDictionary>,
            ) -> Option<NonNull<CFError>>;
        }
        let ret = unsafe { CFErrorCreate(allocator, domain, code, user_info) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a new CFError object using given keys and values to create the user info dictionary.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the current default allocator.
    ///
    /// - domain: A CFString that identifies the error domain. If this reference is `NULL` or is otherwise not a valid CFString, the behavior is undefined.
    ///
    /// - code: A CFIndex that identifies the error code. The code is interpreted within the context of the error domain.
    ///
    /// - userInfoKeys: An array of `numUserInfoValues` CFStrings used as keys in creating the userInfo dictionary. The value of this parameter can be `NULL` if `numUserInfoValues` is `0`.
    ///
    /// - userInfoValues: An array of `numUserInfoValues` CF types used as values in creating the userInfo dictionary.  The value of this parameter can be `NULL` if `numUserInfoValues` is `0`.
    ///
    /// - numUserInfoValues: The number of keys and values in the `userInfoKeys` and `userInfoValues` arrays.
    ///
    ///
    /// ## Return Value
    ///
    /// A new CFError object. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    /// Creates a new CFError without having to create an intermediate userInfo dictionary.
    ///
    /// Parameter `allocator`: The CFAllocator which should be used to allocate memory for the error. This parameter may be NULL in which case the
    /// current default CFAllocator is used. If this reference is not a valid CFAllocator, the behavior is undefined.
    ///
    /// Parameter `domain`: A CFString identifying the error domain. If this reference is NULL or is otherwise not a valid CFString, the behavior is undefined.
    ///
    /// Parameter `code`: A CFIndex identifying the error code. The code is interpreted within the context of the error domain.
    ///
    /// Parameter `userInfoKeys`: An array of numUserInfoValues CFStrings used as keys in creating the userInfo dictionary. NULL is valid only if numUserInfoValues is 0.
    ///
    /// Parameter `userInfoValues`: An array of numUserInfoValues CF types used as values in creating the userInfo dictionary.  NULL is valid only if numUserInfoValues is 0.
    ///
    /// Parameter `numUserInfoValues`: CFIndex representing the number of keys and values in the userInfoKeys and userInfoValues arrays.
    ///
    /// Returns: A reference to the new CFError. numUserInfoValues CF types are gathered from each of userInfoKeys and userInfoValues to create the userInfo dictionary.
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `domain` might not allow `None`.
    /// - `user_info_keys` must be a valid pointer.
    /// - `user_info_values` must be a valid pointer.
    #[doc(alias = "CFErrorCreateWithUserInfoKeysAndValues")]
    #[inline]
    pub unsafe fn with_user_info_keys_and_values(
        allocator: Option<&CFAllocator>,
        domain: Option<&CFErrorDomain>,
        code: CFIndex,
        user_info_keys: *const *const c_void,
        user_info_values: *const *const c_void,
        num_user_info_values: CFIndex,
    ) -> Option<CFRetained<CFError>> {
        extern "C-unwind" {
            fn CFErrorCreateWithUserInfoKeysAndValues(
                allocator: Option<&CFAllocator>,
                domain: Option<&CFErrorDomain>,
                code: CFIndex,
                user_info_keys: *const *const c_void,
                user_info_values: *const *const c_void,
                num_user_info_values: CFIndex,
            ) -> Option<NonNull<CFError>>;
        }
        let ret = unsafe {
            CFErrorCreateWithUserInfoKeysAndValues(
                allocator,
                domain,
                code,
                user_info_keys,
                user_info_values,
                num_user_info_values,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the error domain for a given CFError.
    ///
    /// Parameters:
    /// - err: The error to examine. If this is not a valid CFError, the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// The error domain for `err`. Ownership follows the [The Get Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-SW1).
    ///
    ///
    /// Returns the error domain the CFError was created with.
    ///
    /// Parameter `err`: The CFError whose error domain is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///
    /// Returns: The error domain of the CFError. Since this is a "Get" function, the caller shouldn't CFRelease the return value.
    #[doc(alias = "CFErrorGetDomain")]
    #[inline]
    pub fn domain(&self) -> Option<CFRetained<CFErrorDomain>> {
        extern "C-unwind" {
            fn CFErrorGetDomain(err: &CFError) -> Option<NonNull<CFErrorDomain>>;
        }
        let ret = unsafe { CFErrorGetDomain(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the error code for a given CFError.
    ///
    /// Parameters:
    /// - err: The error to examine. If this is not a valid CFError, the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// The error code of `err`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Note that this function returns the error code for the specified CFError, not an error return for the current call.
    ///
    ///
    /// Returns the error code the CFError was created with.
    ///
    /// Parameter `err`: The CFError whose error code is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///
    /// Returns: The error code of the CFError (not an error return for the current call).
    #[doc(alias = "CFErrorGetCode")]
    #[inline]
    pub fn code(&self) -> CFIndex {
        extern "C-unwind" {
            fn CFErrorGetCode(err: &CFError) -> CFIndex;
        }
        unsafe { CFErrorGetCode(self) }
    }

    /// Returns the user info dictionary for a given CFError.
    ///
    /// Parameters:
    /// - err: The error to examine. If this is not a valid CFError, the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary containing the same keys and values as in the userInfo dictionary `err` was created with. Returns an empty dictionary if `NULL` was supplied to the create function. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    /// Returns CFError userInfo dictionary.
    ///
    /// Returns a dictionary containing the same keys and values as in the userInfo dictionary the CFError was created with. Returns an empty dictionary if NULL was supplied to CFErrorCreate().
    ///
    /// Parameter `err`: The CFError whose error user info is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///
    /// Returns: The user info of the CFError.
    #[doc(alias = "CFErrorCopyUserInfo")]
    #[cfg(feature = "CFDictionary")]
    #[inline]
    pub fn user_info(&self) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CFErrorCopyUserInfo(err: &CFError) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CFErrorCopyUserInfo(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a human-presentable description for a given error.
    ///
    /// Parameters:
    /// - err: The [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror) to examine. If this is not a valid [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror), the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// A localized, human-presentable description of `err`. This function never returns `NULL`. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This is a complete sentence or two which says what failed and why it failed. The structure of the description depends on the details provided in the user info dictionary. The rules for computing the return value are as follows:
    ///
    /// 1. If the value in the user info dictionary for [`kCFErrorLocalizedDescriptionKey`](https://developer.apple.com/documentation/corefoundation/kcferrorlocalizeddescriptionkey) is not `NULL`, it returns that value as-is.
    ///
    /// 2. If the value in the user info dictionary for [`kCFErrorLocalizedFailureReasonKey`](https://developer.apple.com/documentation/corefoundation/kcferrorlocalizedfailurereasonkey) is not `NULL`, there will be an error generated from that.
    ///
    /// The description is something like: “Operation could not be completed. “ + `kCFErrorLocalizedFailureReasonKey` 3. Generate a user-presentable string from [`kCFErrorDescriptionKey`](https://developer.apple.com/documentation/corefoundation/kcferrordescriptionkey), the domain, and code.
    ///
    /// The description is something like: “Operation could not be completed. Error domain/code occurred. “ or “Operation could not be completed. “ + `kCFErrorDescriptionKey` + “ (Error domain/code)”
    ///
    /// Toll-free bridged instances of [`NSError`](https://developer.apple.com/documentation/foundation/nserror) might provide additional behaviors for manufacturing a description string.
    ///
    /// You should not depend on the exact contents or format of the returned string, as it might change in different releases of the operating system.
    ///
    /// When you create a [`CFErrorRef`](https://developer.apple.com/documentation/corefoundation/cferror), you should try to make sure the return value is human-presentable and localized by providing a value for [`kCFErrorLocalizedDescriptionKey`](https://developer.apple.com/documentation/corefoundation/kcferrorlocalizeddescriptionkey) in the user info dictionary.
    ///
    ///
    /// Returns a human-presentable description for the error. CFError creators should strive to make sure the return value is human-presentable and localized by providing a value for kCFErrorLocalizedDescriptionKey at the time of CFError creation.
    ///
    /// This is a complete sentence or two which says what failed and why it failed. Please refer to header comments for -[NSError localizedDescription] for details on the steps used to compute this; but roughly:
    /// - Use value of kCFErrorLocalizedDescriptionKey as-is if provided.
    /// - Use value of kCFErrorLocalizedFailureKey if provided, optionally followed by kCFErrorLocalizedFailureReasonKey if available.
    /// - Use value of kCFErrorLocalizedFailureReasonKey, combining with a generic failure message such as: "Operation code not be completed. " + kCFErrorLocalizedFailureReasonKey.
    /// - If all of the above fail, generate a semi-user presentable string from kCFErrorDescriptionKey, the domain, and code. Something like: "Operation could not be completed. Error domain/code occurred. " or "Operation could not be completed. " + kCFErrorDescriptionKey + " (Error domain/code)"
    /// Toll-free bridged NSError instances might provide additional behaviors for manufacturing a description string.  Do not count on the exact contents or format of the returned string, it might change.
    ///
    /// Parameter `err`: The CFError whose description is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///
    /// Returns: A CFString with human-presentable description of the CFError. Never NULL.
    #[doc(alias = "CFErrorCopyDescription")]
    #[inline]
    pub fn description(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFErrorCopyDescription(err: &CFError) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFErrorCopyDescription(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a human-presentable failure reason for a given error.
    ///
    /// Parameters:
    /// - err: The CFError to examine. If this is not a valid CFError, the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// A localized, human-presentable failure reason for `err`, or `NULL` if no user-presentable string is available. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The failure reason is a complete sentence which describes why the operation failed. In many cases this will be just the “because” part of the description (but as a complete sentence, which makes localization easier). For example, an error description “Could not save file ‘Letter’ in folder ‘Documents’ because the volume ‘MyDisk’ doesn’t have enough space.” might have a corresponding failure reason, “The volume ‘MyDisk’ doesn’t have enough space.”
    ///
    /// By default, this function looks for a value for the [`kCFErrorLocalizedFailureReasonKey`](https://developer.apple.com/documentation/corefoundation/kcferrorlocalizedfailurereasonkey) key in the user info dictionary. Toll-free bridged instances of `NSError` might provide additional behaviors for manufacturing this value.
    ///
    /// When you create a CFError, you should try to make sure the return value is human-presentable and localized by providing a value for [`kCFErrorLocalizedFailureReasonKey`](https://developer.apple.com/documentation/corefoundation/kcferrorlocalizedfailurereasonkey) in the user info dictionary.
    ///
    ///
    /// Returns a human-presentable failure reason for the error.  May return NULL.  CFError creators should strive to make sure the return value is human-presentable and localized by providing a value for kCFErrorLocalizedFailureReasonKey at the time of CFError creation.
    ///
    /// This is a complete sentence which describes why the operation failed. In many cases this will be just the "because" part of the description (but as a complete sentence, which makes localization easier). By default this looks for kCFErrorLocalizedFailureReasonKey in the user info. Toll-free bridged NSError instances might provide additional behaviors for manufacturing this value. If no user-presentable string is available, returns NULL.
    /// Example Description: "Could not save file 'Letter' in folder 'Documents' because the volume 'MyDisk' doesn't have enough space."
    /// Corresponding FailureReason: "The volume 'MyDisk' doesn't have enough space."
    ///
    /// Parameter `err`: The CFError whose failure reason is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///
    /// Returns: A CFString with the localized, end-user presentable failure reason of the CFError, or NULL.
    #[doc(alias = "CFErrorCopyFailureReason")]
    #[inline]
    pub fn failure_reason(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFErrorCopyFailureReason(err: &CFError) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFErrorCopyFailureReason(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a human presentable recovery suggestion for a given error.
    ///
    /// Parameters:
    /// - err: The CFError to examine. If this is not a valid CFError, the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// A localized, human-presentable recovery suggestion for `err`, or `NULL` if no user-presentable string is available. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This is the string that can be displayed as the “informative” (or “secondary”) message on an alert panel. For example, an error description “Could not save file ‘Letter’ in folder ‘Documents’ because the volume ‘MyDisk’ doesn’t have enough space.” might have a corresponding recovery suggestion, “Remove some files from the volume and try again.”
    ///
    /// By default, this function looks for a value for the [`kCFErrorLocalizedRecoverySuggestionKey`](https://developer.apple.com/documentation/corefoundation/kcferrorlocalizedrecoverysuggestionkey) key in the user info dictionary. Toll-free bridged instances of `NSError` might provide additional behaviors for manufacturing this value.
    ///
    /// When you create a CFError, you should try to make sure the return value is human-presentable and localized by providing a value for [`kCFErrorLocalizedRecoverySuggestionKey`](https://developer.apple.com/documentation/corefoundation/kcferrorlocalizedrecoverysuggestionkey) in the user info dictionary.
    ///
    ///
    /// Returns a human presentable recovery suggestion for the error.  May return NULL.  CFError creators should strive to make sure the return value is human-presentable and localized by providing a value for kCFErrorLocalizedRecoverySuggestionKey at the time of CFError creation.
    ///
    /// This is the string that can be displayed as the "informative" (aka "secondary") message on an alert panel. By default this looks for kCFErrorLocalizedRecoverySuggestionKey in the user info. Toll-free bridged NSError instances might provide additional behaviors for manufacturing this value. If no user-presentable string is available, returns NULL.
    /// Example Description: "Could not save file 'Letter' in folder 'Documents' because the volume 'MyDisk' doesn't have enough space."
    /// Corresponding RecoverySuggestion: "Remove some files from the volume and try again."
    ///
    /// Parameter `err`: The CFError whose recovery suggestion is to be returned. If this reference is not a valid CFError, the behavior is undefined.
    ///
    /// Returns: A CFString with the localized, end-user presentable recovery suggestion of the CFError, or NULL.
    #[doc(alias = "CFErrorCopyRecoverySuggestion")]
    #[inline]
    pub fn recovery_suggestion(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFErrorCopyRecoverySuggestion(err: &CFError) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFErrorCopyRecoverySuggestion(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

#[cfg(feature = "CFDictionary")]
#[deprecated = "renamed to `CFError::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFErrorCreate(
    allocator: Option<&CFAllocator>,
    domain: Option<&CFErrorDomain>,
    code: CFIndex,
    user_info: Option<&CFDictionary>,
) -> Option<CFRetained<CFError>> {
    extern "C-unwind" {
        fn CFErrorCreate(
            allocator: Option<&CFAllocator>,
            domain: Option<&CFErrorDomain>,
            code: CFIndex,
            user_info: Option<&CFDictionary>,
        ) -> Option<NonNull<CFError>>;
    }
    let ret = unsafe { CFErrorCreate(allocator, domain, code, user_info) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::with_user_info_keys_and_values`"]
#[inline]
pub unsafe extern "C-unwind" fn CFErrorCreateWithUserInfoKeysAndValues(
    allocator: Option<&CFAllocator>,
    domain: Option<&CFErrorDomain>,
    code: CFIndex,
    user_info_keys: *const *const c_void,
    user_info_values: *const *const c_void,
    num_user_info_values: CFIndex,
) -> Option<CFRetained<CFError>> {
    extern "C-unwind" {
        fn CFErrorCreateWithUserInfoKeysAndValues(
            allocator: Option<&CFAllocator>,
            domain: Option<&CFErrorDomain>,
            code: CFIndex,
            user_info_keys: *const *const c_void,
            user_info_values: *const *const c_void,
            num_user_info_values: CFIndex,
        ) -> Option<NonNull<CFError>>;
    }
    let ret = unsafe {
        CFErrorCreateWithUserInfoKeysAndValues(
            allocator,
            domain,
            code,
            user_info_keys,
            user_info_values,
            num_user_info_values,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::domain`"]
#[inline]
pub extern "C-unwind" fn CFErrorGetDomain(err: &CFError) -> Option<CFRetained<CFErrorDomain>> {
    extern "C-unwind" {
        fn CFErrorGetDomain(err: &CFError) -> Option<NonNull<CFErrorDomain>>;
    }
    let ret = unsafe { CFErrorGetDomain(err) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CFError::code`"]
#[inline]
pub extern "C-unwind" fn CFErrorGetCode(err: &CFError) -> CFIndex {
    extern "C-unwind" {
        fn CFErrorGetCode(err: &CFError) -> CFIndex;
    }
    unsafe { CFErrorGetCode(err) }
}

#[cfg(feature = "CFDictionary")]
#[deprecated = "renamed to `CFError::user_info`"]
#[inline]
pub extern "C-unwind" fn CFErrorCopyUserInfo(err: &CFError) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CFErrorCopyUserInfo(err: &CFError) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CFErrorCopyUserInfo(err) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::description`"]
#[inline]
pub extern "C-unwind" fn CFErrorCopyDescription(err: &CFError) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFErrorCopyDescription(err: &CFError) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFErrorCopyDescription(err) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::failure_reason`"]
#[inline]
pub extern "C-unwind" fn CFErrorCopyFailureReason(err: &CFError) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFErrorCopyFailureReason(err: &CFError) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFErrorCopyFailureReason(err) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CFError::recovery_suggestion`"]
#[inline]
pub extern "C-unwind" fn CFErrorCopyRecoverySuggestion(
    err: &CFError,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFErrorCopyRecoverySuggestion(err: &CFError) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFErrorCopyRecoverySuggestion(err) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
