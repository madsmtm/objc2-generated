//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

///
/// ## Overview
///
/// A `CFUserNotification` object presents a simple dialog on the screen and optionally receives feedback from the user. The contents of the dialog can include a header, a message, an icon, text fields, a pop-up button, radio buttons or checkboxes, and up to three ordinary buttons. Use `CFUserNotification` in processes that do not otherwise have user interfaces, but may need occasional interaction with the user.
///
/// You create a user notification with the [`CFUserNotificationCreate`](https://developer.apple.com/documentation/corefoundation/cfusernotificationcreate(_:_:_:_:_:)) function. You pass in a dictionary whose keys describe the items to place into the dialog. (See [Dialog Description Keys](https://developer.apple.com/documentation/corefoundation/dialog-description-keys) for the list of keys.) A set of flags passed to the function determines, among other things, whether secure text fields are used (such as for password fields), whether radio buttons or checkboxes are used, and which of these buttons are checked by default. You can also specify a timeout for the dialog, in which case the dialog cancels itself if the user does not respond in the allotted time period.
///
/// A user notification displays its dialog as soon as it is created. If any reply is required, it may be awaited in one of two ways: either synchronously, using [`CFUserNotificationReceiveResponse`](https://developer.apple.com/documentation/corefoundation/cfusernotificationreceiveresponse(_:_:_:)), or asynchronously, using a run loop source created with [`CFUserNotificationCreateRunLoopSource`](https://developer.apple.com/documentation/corefoundation/cfusernotificationcreaterunloopsource(_:_:_:_:)). [`CFUserNotificationReceiveResponse`](https://developer.apple.com/documentation/corefoundation/cfusernotificationreceiveresponse(_:_:_:)) has a timeout parameter that determines how long it will block (zero meaning indefinitely) and it may be called as many times as necessary until a response arrives. If a user notification has not yet received a response, it may be updated with new information or it may be cancelled. User notifications may not be reused.
///
/// `CFUserNotification` provides two convenience functions, [`CFUserNotificationDisplayNotice`](https://developer.apple.com/documentation/corefoundation/cfusernotificationdisplaynotice(_:_:_:_:_:_:_:_:)) and [`CFUserNotificationDisplayAlert`](https://developer.apple.com/documentation/corefoundation/cfusernotificationdisplayalert(_:_:_:_:_:_:_:_:_:_:_:)), to display very basic dialogs that either require no response from the user or require only a single button to be pressed, respectively.
///
///
#[doc(alias = "CFUserNotificationRef")]
#[repr(C)]
pub struct CFUserNotification {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CFUserNotification {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__CFUserNotification"> for CFUserNotification {}
);

/// Callback invoked when an asynchronous user notification dialog is dismissed.
///
/// Parameters:
/// - userNotification: The user notification that was dismissed.
///
/// - responseFlags: On return, contains flags identifying how the notification was dismissed, the state of any checkboxes, and the selected item of the pop-up menu. See [`CFUserNotificationReceiveResponse`](https://developer.apple.com/documentation/corefoundation/cfusernotificationreceiveresponse(_:_:_:)) for details.
///
pub type CFUserNotificationCallBack =
    Option<unsafe extern "C-unwind" fn(*mut CFUserNotification, CFOptionFlags)>;

unsafe impl ConcreteType for CFUserNotification {
    /// Returns the type identifier for the `CFUserNotification` opaque type.
    ///
    /// ## Return Value
    ///
    /// The type identifier for the `CFUserNotification` opaque type.
    ///
    ///
    #[doc(alias = "CFUserNotificationGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CFUserNotificationGetTypeID() -> CFTypeID;
        }
        unsafe { CFUserNotificationGetTypeID() }
    }
}

impl CFUserNotification {
    /// Creates a CFUserNotification object and displays its notification dialog on screen.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - timeout: The time to wait before the notification dialog dismisses itself if the user does not respond. If `0`, the notification never times out.
    ///
    /// - flags: A set of flags describing the type of notification to display. These flags specify an alert level for the notification (see [Alert Levels](https://developer.apple.com/documentation/corefoundation/1534483-alert-levels)), determine whether radio buttons or checkboxes are to be used (see [Button Flags](https://developer.apple.com/documentation/corefoundation/1534481-button-flags)), specify which, if any, of these buttons are checked by default (see [`CFUserNotificationCheckBoxChecked`](https://developer.apple.com/documentation/corefoundation/cfusernotificationcheckboxchecked(_:))), specify whether any of the text fields are to be secure text fields (see [`CFUserNotificationSecureTextField`](https://developer.apple.com/documentation/corefoundation/cfusernotificationsecuretextfield(_:))), and determine which element of a pop-up menu, if present, should be selected by default (see [`CFUserNotificationPopUpSelection`](https://developer.apple.com/documentation/corefoundation/cfusernotificationpopupselection(_:))). Combine these flags together by performing a bitwise-OR operation with all the individual flags.
    ///
    /// - error: On return contains an integer error code. If `0`, the user notification was successfully created and displayed.
    ///
    /// - dictionary: A description of the elements to display in the notification dialog. The possible keys are listed in [Dialog Description Keys](https://developer.apple.com/documentation/corefoundation/dialog-description-keys). The dictionary must contain a value for the key [`kCFUserNotificationAlertHeaderKey`](https://developer.apple.com/documentation/corefoundation/kcfusernotificationalertheaderkey), but the other keys are optional.
    ///
    ///
    /// ## Return Value
    ///
    /// The new CFUserNotification object. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `error` must be a valid pointer.
    /// - `dictionary` generic must be of the correct type.
    /// - `dictionary` generic must be of the correct type.
    /// - `dictionary` might not allow `None`.
    #[doc(alias = "CFUserNotificationCreate")]
    #[cfg(all(feature = "CFDate", feature = "CFDictionary"))]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        error: *mut i32,
        dictionary: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFUserNotification>> {
        extern "C-unwind" {
            fn CFUserNotificationCreate(
                allocator: Option<&CFAllocator>,
                timeout: CFTimeInterval,
                flags: CFOptionFlags,
                error: *mut i32,
                dictionary: Option<&CFDictionary>,
            ) -> Option<NonNull<CFUserNotification>>;
        }
        let ret = unsafe { CFUserNotificationCreate(allocator, timeout, flags, error, dictionary) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Waits for the user to respond to a notification or for the notification to time out.
    ///
    /// Parameters:
    /// - userNotification: The user notification to use.
    ///
    /// - timeout: The amount of time to wait for the user to respond to `userNotification` or for the notification to time out. If neither happens before `timeout` passes, this function returns a non-`0` value. If `timeout` is `0`, the function blocks until the user notification is dismissed.
    ///
    /// - responseFlags: On return, contains flags identifying how the notification was dismissed, the state of any checkboxes, and the selected element of the pop-up menu. Bits 0-1 of the value hold an identifier for the button pressed by the user (see [Response Codes](https://developer.apple.com/documentation/corefoundation/1534504-response-codes)). Extract the identifier by performing a bitwise-AND operation with `0x3`. Bits 8-15 of `responseFlags` hold the state of up to 8 checkboxes or radio buttons, if present. Extract the flags by performing bitwise-AND operations with the return value of [`CFUserNotificationCheckBoxChecked`](https://developer.apple.com/documentation/corefoundation/cfusernotificationcheckboxchecked(_:)). Bits 24-31 hold the index number of the element selected in a pop-up menu, if present. Extract the index by performing a 24-bit right shift: `responseFlags >> 24`.
    ///
    ///
    /// ## Return Value
    ///
    /// `0` if the call successfully received a response; a non-`0` value otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this function to poll a user notification for a user response. You can call it any number of times on the same user notification.
    ///
    /// To avoid polling and blocking your thread’s execution, you can create a run loop source for the user notification with [`CFUserNotificationCreateRunLoopSource`](https://developer.apple.com/documentation/corefoundation/cfusernotificationcreaterunloopsource(_:_:_:_:)). You will then receive a callback when the dialog is dismissed.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `response_flags` must be a valid pointer.
    #[doc(alias = "CFUserNotificationReceiveResponse")]
    #[cfg(feature = "CFDate")]
    #[inline]
    pub unsafe fn receive_response(
        &self,
        timeout: CFTimeInterval,
        response_flags: *mut CFOptionFlags,
    ) -> i32 {
        extern "C-unwind" {
            fn CFUserNotificationReceiveResponse(
                user_notification: &CFUserNotification,
                timeout: CFTimeInterval,
                response_flags: *mut CFOptionFlags,
            ) -> i32;
        }
        unsafe { CFUserNotificationReceiveResponse(self, timeout, response_flags) }
    }

    /// Extracts the values of the text fields from a dismissed notification dialog.
    ///
    /// Parameters:
    /// - userNotification: The user notification to use.
    ///
    /// - key: The dictionary key identifying the text fields to use. Currently, only [`kCFUserNotificationTextFieldValuesKey`](https://developer.apple.com/documentation/corefoundation/kcfusernotificationtextfieldvalueskey) is supported.
    ///
    /// - idx: The index of the text field value to return. The index corresponds to the order in which text fields are listed in the [`kCFUserNotificationTextFieldTitlesKey`](https://developer.apple.com/documentation/corefoundation/kcfusernotificationtextfieldtitleskey) array in the user notification’s description dictionary.
    ///
    ///
    /// ## Return Value
    ///
    /// The value of the text field identified by `key` and `idx`. Ownership follows the [The Get Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-SW1).
    ///
    ///
    ///
    /// # Safety
    ///
    /// `key` might not allow `None`.
    #[doc(alias = "CFUserNotificationGetResponseValue")]
    #[inline]
    pub unsafe fn response_value(
        &self,
        key: Option<&CFString>,
        idx: CFIndex,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CFUserNotificationGetResponseValue(
                user_notification: &CFUserNotification,
                key: Option<&CFString>,
                idx: CFIndex,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CFUserNotificationGetResponseValue(self, key, idx) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the dictionary containing all the text field values from a dismissed notification dialog.
    ///
    /// Parameters:
    /// - userNotification: The user notification to use.
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary holding the values of all the text fields in `userNotification` when it was dismissed. The values are in an array stored with the key [`kCFUserNotificationTextFieldValuesKey`](https://developer.apple.com/documentation/corefoundation/kcfusernotificationtextfieldvalueskey). Ownership follows the [The Get Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-SW1).
    ///
    ///
    #[doc(alias = "CFUserNotificationGetResponseDictionary")]
    #[cfg(feature = "CFDictionary")]
    #[inline]
    pub fn response_dictionary(&self) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CFUserNotificationGetResponseDictionary(
                user_notification: &CFUserNotification,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CFUserNotificationGetResponseDictionary(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Updates a displayed user notification dialog with new user interface information.
    ///
    /// Parameters:
    /// - userNotification: The user notification to update.
    ///
    /// - timeout: The new timeout value for the dialog.
    ///
    /// - flags: A set of flags describing the type of notification to display. See [`CFUserNotificationCreate`](https://developer.apple.com/documentation/corefoundation/cfusernotificationcreate(_:_:_:_:_:)) for details.
    ///
    /// - dictionary: A description of the elements to display in the notification dialog. The possible keys are listed in [Dialog Description Keys](https://developer.apple.com/documentation/corefoundation/dialog-description-keys).
    ///
    ///
    /// ## Return Value
    ///
    /// `0` if the cancel was successful; a non-`0` value otherwise.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `dictionary` generic must be of the correct type.
    /// - `dictionary` generic must be of the correct type.
    /// - `dictionary` might not allow `None`.
    #[doc(alias = "CFUserNotificationUpdate")]
    #[cfg(all(feature = "CFDate", feature = "CFDictionary"))]
    #[inline]
    pub unsafe fn update(
        &self,
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        dictionary: Option<&CFDictionary>,
    ) -> i32 {
        extern "C-unwind" {
            fn CFUserNotificationUpdate(
                user_notification: &CFUserNotification,
                timeout: CFTimeInterval,
                flags: CFOptionFlags,
                dictionary: Option<&CFDictionary>,
            ) -> i32;
        }
        unsafe { CFUserNotificationUpdate(self, timeout, flags, dictionary) }
    }

    /// Cancels a user notification dialog.
    ///
    /// Parameters:
    /// - userNotification: The user notification to cancel.
    ///
    ///
    /// ## Return Value
    ///
    /// `0` if the cancel was successful; a non-`0` value otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You must cancel a user notification if you want to remove its dialog from the screen before the user dismisses it. It is not sufficient to just release the object.
    ///
    ///
    #[doc(alias = "CFUserNotificationCancel")]
    #[inline]
    pub fn cancel(&self) -> i32 {
        extern "C-unwind" {
            fn CFUserNotificationCancel(user_notification: &CFUserNotification) -> i32;
        }
        unsafe { CFUserNotificationCancel(self) }
    }

    /// Creates a run loop source for a user notification.
    ///
    /// Parameters:
    /// - allocator: The allocator to use to allocate memory for the new object. Pass `NULL` or kCFAllocatorDefault to use the current default allocator.
    ///
    /// - userNotification: The user notification to use.
    ///
    /// - callout: The callback function to invoke when the user notification dialog is dismissed.
    ///
    /// - order: A priority index indicating the order in which run loop sources are processed. User notifications currently ignore this parameter. Pass `0` for this value.
    ///
    ///
    /// ## Return Value
    ///
    /// The new CFRunLoopSource object. Ownership follows the [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A run loop source needs to be added to a run loop before it can fire and call its callback function. To add the source to a run loop, use [`CFRunLoopAddSource`](https://developer.apple.com/documentation/corefoundation/cfrunloopaddsource(_:_:_:)).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `user_notification` might not allow `None`.
    /// - `callout` must be implemented correctly.
    #[doc(alias = "CFUserNotificationCreateRunLoopSource")]
    #[cfg(feature = "CFRunLoop")]
    #[inline]
    pub unsafe fn new_run_loop_source(
        allocator: Option<&CFAllocator>,
        user_notification: Option<&CFUserNotification>,
        callout: CFUserNotificationCallBack,
        order: CFIndex,
    ) -> Option<CFRetained<CFRunLoopSource>> {
        extern "C-unwind" {
            fn CFUserNotificationCreateRunLoopSource(
                allocator: Option<&CFAllocator>,
                user_notification: Option<&CFUserNotification>,
                callout: CFUserNotificationCallBack,
                order: CFIndex,
            ) -> Option<NonNull<CFRunLoopSource>>;
        }
        let ret = unsafe {
            CFUserNotificationCreateRunLoopSource(allocator, user_notification, callout, order)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Displays a user notification dialog that does not need a user response.
    ///
    /// Parameters:
    /// - timeout: The amount of time to wait for the user to dismiss the notification dialog before the dialog dismisses itself. Pass `0` to have the dialog never time out.
    ///
    /// - flags: A set of flags describing the type of notification dialog to display. The value is normally just the alert level from [Alert Levels](https://developer.apple.com/documentation/corefoundation/1534483-alert-levels). If you don’t want a default button displayed, perform a bitwise-OR operation with the alert level and the constant [`kCFUserNotificationNoDefaultButtonFlag`](https://developer.apple.com/documentation/corefoundation/kcfusernotificationnodefaultbuttonflag).
    ///
    /// - iconURL: A file URL pointing to the icon to display in the dialog. If `NULL`, a default icon is used based on the notification’s alert level specified in `flags`.
    ///
    /// - soundURL: Not used.
    ///
    /// - localizationURL: A file URL pointing to a bundle that contains localized versions of the strings displayed in the dialog. Can be `NULL`.
    ///
    /// - alertHeader: The title of the notification dialog. Cannot be `NULL`.
    ///
    /// - alertMessage: The message string to display in the dialog. Can be `NULL`.
    ///
    /// - defaultButtonTitle: The title of the default button. If `NULL`, the string `OK` is used.
    ///
    ///
    /// ## Return Value
    ///
    /// `0` if the cancel was successful; a non-`0` value otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function returns immediately. It does not wait for a user response after displaying the dialog.
    ///
    ///
    #[doc(alias = "CFUserNotificationDisplayNotice")]
    #[cfg(all(feature = "CFDate", feature = "CFURL"))]
    #[inline]
    pub fn display_notice(
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        icon_url: Option<&CFURL>,
        sound_url: Option<&CFURL>,
        localization_url: Option<&CFURL>,
        alert_header: Option<&CFString>,
        alert_message: Option<&CFString>,
        default_button_title: Option<&CFString>,
    ) -> i32 {
        extern "C-unwind" {
            fn CFUserNotificationDisplayNotice(
                timeout: CFTimeInterval,
                flags: CFOptionFlags,
                icon_url: Option<&CFURL>,
                sound_url: Option<&CFURL>,
                localization_url: Option<&CFURL>,
                alert_header: Option<&CFString>,
                alert_message: Option<&CFString>,
                default_button_title: Option<&CFString>,
            ) -> i32;
        }
        unsafe {
            CFUserNotificationDisplayNotice(
                timeout,
                flags,
                icon_url,
                sound_url,
                localization_url,
                alert_header,
                alert_message,
                default_button_title,
            )
        }
    }

    /// Displays a user notification dialog and waits for a user response.
    ///
    /// Parameters:
    /// - timeout: The amount of time to wait for the user to dismiss the notification dialog before the dialog dismisses itself. Pass `0` to have the dialog never time out.
    ///
    /// - flags: A set of flags describing the type of notification dialog to display. The value is normally just the alert level from [Alert Levels](https://developer.apple.com/documentation/corefoundation/1534483-alert-levels). If you don’t want a default button displayed, perform a bitwise-OR operation with the alert level and the constant [`kCFUserNotificationNoDefaultButtonFlag`](https://developer.apple.com/documentation/corefoundation/kcfusernotificationnodefaultbuttonflag).
    ///
    /// - iconURL: A file URL pointing to the icon to display in the dialog. If `NULL`, a default icon is used based on the notification’s alert level specified in `flags`.
    ///
    /// - soundURL: Not used.
    ///
    /// - localizationURL: A file URL pointing to a bundle that contains localized versions of the strings displayed in the dialog. Can be `NULL`.
    ///
    /// - alertHeader: The title of the notification dialog. Cannot be `NULL`.
    ///
    /// - alertMessage: The message string to display in the dialog. Can be `NULL`.
    ///
    /// - defaultButtonTitle: The title of the default button. If `NULL`, the string `OK` is used.
    ///
    /// - alternateButtonTitle: The title of an optional alternate button. Can be `NULL`.
    ///
    /// - otherButtonTitle: The title of an optional third button. Can be `NULL`.
    ///
    /// - responseFlags: On return, contains flags identifying how the notification was dismissed. See [Response Codes](https://developer.apple.com/documentation/corefoundation/1534504-response-codes) for details.
    ///
    ///
    /// ## Return Value
    ///
    /// `0` if the cancel was successful; a non-`0` value otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function blocks the current thread’s execution until the dialog is dismissed, either by the user or by timing out.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `icon_url` might not allow `None`.
    /// - `sound_url` might not allow `None`.
    /// - `localization_url` might not allow `None`.
    /// - `alert_header` might not allow `None`.
    /// - `alert_message` might not allow `None`.
    /// - `default_button_title` might not allow `None`.
    /// - `alternate_button_title` might not allow `None`.
    /// - `other_button_title` might not allow `None`.
    /// - `response_flags` must be a valid pointer.
    #[doc(alias = "CFUserNotificationDisplayAlert")]
    #[cfg(all(feature = "CFDate", feature = "CFURL"))]
    #[inline]
    pub unsafe fn display_alert(
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        icon_url: Option<&CFURL>,
        sound_url: Option<&CFURL>,
        localization_url: Option<&CFURL>,
        alert_header: Option<&CFString>,
        alert_message: Option<&CFString>,
        default_button_title: Option<&CFString>,
        alternate_button_title: Option<&CFString>,
        other_button_title: Option<&CFString>,
        response_flags: *mut CFOptionFlags,
    ) -> i32 {
        extern "C-unwind" {
            fn CFUserNotificationDisplayAlert(
                timeout: CFTimeInterval,
                flags: CFOptionFlags,
                icon_url: Option<&CFURL>,
                sound_url: Option<&CFURL>,
                localization_url: Option<&CFURL>,
                alert_header: Option<&CFString>,
                alert_message: Option<&CFString>,
                default_button_title: Option<&CFString>,
                alternate_button_title: Option<&CFString>,
                other_button_title: Option<&CFString>,
                response_flags: *mut CFOptionFlags,
            ) -> i32;
        }
        unsafe {
            CFUserNotificationDisplayAlert(
                timeout,
                flags,
                icon_url,
                sound_url,
                localization_url,
                alert_header,
                alert_message,
                default_button_title,
                alternate_button_title,
                other_button_title,
                response_flags,
            )
        }
    }
}

/// The notification is very serious.
///
/// ## Discussion
///
/// A stop icon is displayed by default.
///
///
pub const kCFUserNotificationStopAlertLevel: CFOptionFlags = 0;
/// The notification is not very serious.
///
/// ## Discussion
///
/// A note icon is displayed by default.
///
///
pub const kCFUserNotificationNoteAlertLevel: CFOptionFlags = 1;
/// The notification is somewhat serious.
///
/// ## Discussion
///
/// A caution icon is displayed by default.
///
///
pub const kCFUserNotificationCautionAlertLevel: CFOptionFlags = 2;
/// The notification is not serious.
///
/// ## Discussion
///
/// An information icon is displayed by default.
///
///
pub const kCFUserNotificationPlainAlertLevel: CFOptionFlags = 3;

/// The default button was pressed.
pub const kCFUserNotificationDefaultResponse: CFOptionFlags = 0;
/// The alternate button was pressed.
pub const kCFUserNotificationAlternateResponse: CFOptionFlags = 1;
/// The third button was pressed.
pub const kCFUserNotificationOtherResponse: CFOptionFlags = 2;
/// No button was pressed and the notification timed out.
pub const kCFUserNotificationCancelResponse: CFOptionFlags = 3;

/// Displays the dialog without the default, alternate, or other buttons.
///
/// ## Discussion
///
/// The dialog remains on screen until it times out or you cancel it with [`CFUserNotificationCancel`](https://developer.apple.com/documentation/corefoundation/cfusernotificationcancel(_:)). If you provide a title for the default button in the user notification’s description dictionary, this flag is ignored and buttons show up normally.
///
///
pub const kCFUserNotificationNoDefaultButtonFlag: CFOptionFlags = 1 << 5;
/// Creates a group of radio buttons instead of checkboxes for the elements in the [`kCFUserNotificationCheckBoxTitlesKey`](https://developer.apple.com/documentation/corefoundation/kcfusernotificationcheckboxtitleskey) array in the user notification’s description dictionary.
pub const kCFUserNotificationUseRadioButtonsFlag: CFOptionFlags = 1 << 6;

extern "C" {
    /// A file URL pointing to the icon to display in the dialog.
    ///
    /// ## Discussion
    ///
    /// If absent, a default icon based on the alert level is used.
    ///
    ///
    pub static kCFUserNotificationIconURLKey: Option<&'static CFString>;
}

extern "C" {
    /// A file URL pointing to a sound that will be played when the alert appears.
    pub static kCFUserNotificationSoundURLKey: Option<&'static CFString>;
}

extern "C" {
    /// A file URL pointing to a bundle that contains localized versions of the strings displayed in the dialog.
    pub static kCFUserNotificationLocalizationURLKey: Option<&'static CFString>;
}

extern "C" {
    /// The title of the notification dialog.
    ///
    /// ## Discussion
    ///
    /// This key is required.
    ///
    ///
    pub static kCFUserNotificationAlertHeaderKey: Option<&'static CFString>;
}

extern "C" {
    /// The message string to display in the dialog.
    pub static kCFUserNotificationAlertMessageKey: Option<&'static CFString>;
}

extern "C" {
    /// The title of the default button.
    ///
    /// ## Discussion
    ///
    /// If absent and the dialog is not being created with the [`kCFUserNotificationNoDefaultButtonFlag`](https://developer.apple.com/documentation/corefoundation/kcfusernotificationnodefaultbuttonflag) flag, a default button title of `OK` is used.
    ///
    ///
    pub static kCFUserNotificationDefaultButtonTitleKey: Option<&'static CFString>;
}

extern "C" {
    /// The title of an optional alternate button.
    pub static kCFUserNotificationAlternateButtonTitleKey: Option<&'static CFString>;
}

extern "C" {
    /// The title of an optional third button.
    pub static kCFUserNotificationOtherButtonTitleKey: Option<&'static CFString>;
}

extern "C" {
    /// A value to indicate the progress of an operation.
    ///
    /// ## Discussion
    ///
    /// The value is a number between `0` and `1`, for a “definite” progress indicator, or a Boolean for an “indefinite” progress indicator.
    ///
    ///
    pub static kCFUserNotificationProgressIndicatorValueKey: Option<&'static CFString>;
}

extern "C" {
    /// The list of strings to display in a pop-up menu.
    ///
    /// ## Discussion
    ///
    /// The array cannot have more than 256 elements.
    ///
    ///
    pub static kCFUserNotificationPopUpTitlesKey: Option<&'static CFString>;
}

extern "C" {
    /// The list of titles for all the text fields to display.
    ///
    /// ## Discussion
    ///
    /// If only one text field is to be displayed, you can pass its title string directly without putting it into an array first.
    ///
    ///
    pub static kCFUserNotificationTextFieldTitlesKey: Option<&'static CFString>;
}

extern "C" {
    /// The list of titles for all the checkboxes or radio buttons to display.
    ///
    /// ## Discussion
    ///
    /// The array cannot have more than 8 elements. If only one checkbox is to be displayed, you can pass its title string directly without putting it into an array first.
    ///
    ///
    pub static kCFUserNotificationCheckBoxTitlesKey: Option<&'static CFString>;
}

extern "C" {
    /// The list of values to put into the text fields. If only one text field is to be displayed, you can pass its value string directly without putting it into an array first.
    pub static kCFUserNotificationTextFieldValuesKey: Option<&'static CFString>;
}

extern "C" {
    /// The item that was selected from a pop-up menu.
    pub static kCFUserNotificationPopUpSelectionKey: Option<&'static CFString>;
}

extern "C" {
    pub static kCFUserNotificationAlertTopMostKey: Option<&'static CFString>;
}

extern "C" {
    pub static kCFUserNotificationKeyboardTypesKey: Option<&'static CFString>;
}

extern "C" {
    pub static kCFUserNotificationAlertAccessibilityIdentifierKey: Option<&'static CFString>;
}

extern "C" {
    pub static kCFUserNotificationDefaultButtonAccessibilityIdentifierKey:
        Option<&'static CFString>;
}

extern "C" {
    pub static kCFUserNotificationAlternateButtonAccessibilityIdentifierKey:
        Option<&'static CFString>;
}

extern "C" {
    pub static kCFUserNotificationOtherButtonAccessibilityIdentifierKey: Option<&'static CFString>;
}

#[cfg(all(feature = "CFDate", feature = "CFDictionary"))]
#[deprecated = "renamed to `CFUserNotification::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CFUserNotificationCreate(
    allocator: Option<&CFAllocator>,
    timeout: CFTimeInterval,
    flags: CFOptionFlags,
    error: *mut i32,
    dictionary: Option<&CFDictionary>,
) -> Option<CFRetained<CFUserNotification>> {
    extern "C-unwind" {
        fn CFUserNotificationCreate(
            allocator: Option<&CFAllocator>,
            timeout: CFTimeInterval,
            flags: CFOptionFlags,
            error: *mut i32,
            dictionary: Option<&CFDictionary>,
        ) -> Option<NonNull<CFUserNotification>>;
    }
    let ret = unsafe { CFUserNotificationCreate(allocator, timeout, flags, error, dictionary) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CFDate")]
    #[deprecated = "renamed to `CFUserNotification::receive_response`"]
    pub fn CFUserNotificationReceiveResponse(
        user_notification: &CFUserNotification,
        timeout: CFTimeInterval,
        response_flags: *mut CFOptionFlags,
    ) -> i32;
}

#[deprecated = "renamed to `CFUserNotification::response_value`"]
#[inline]
pub unsafe extern "C-unwind" fn CFUserNotificationGetResponseValue(
    user_notification: &CFUserNotification,
    key: Option<&CFString>,
    idx: CFIndex,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CFUserNotificationGetResponseValue(
            user_notification: &CFUserNotification,
            key: Option<&CFString>,
            idx: CFIndex,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CFUserNotificationGetResponseValue(user_notification, key, idx) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "CFDictionary")]
#[deprecated = "renamed to `CFUserNotification::response_dictionary`"]
#[inline]
pub extern "C-unwind" fn CFUserNotificationGetResponseDictionary(
    user_notification: &CFUserNotification,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CFUserNotificationGetResponseDictionary(
            user_notification: &CFUserNotification,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CFUserNotificationGetResponseDictionary(user_notification) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[cfg(all(feature = "CFDate", feature = "CFDictionary"))]
    #[deprecated = "renamed to `CFUserNotification::update`"]
    pub fn CFUserNotificationUpdate(
        user_notification: &CFUserNotification,
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        dictionary: Option<&CFDictionary>,
    ) -> i32;
}

#[deprecated = "renamed to `CFUserNotification::cancel`"]
#[inline]
pub extern "C-unwind" fn CFUserNotificationCancel(user_notification: &CFUserNotification) -> i32 {
    extern "C-unwind" {
        fn CFUserNotificationCancel(user_notification: &CFUserNotification) -> i32;
    }
    unsafe { CFUserNotificationCancel(user_notification) }
}

#[cfg(feature = "CFRunLoop")]
#[deprecated = "renamed to `CFUserNotification::new_run_loop_source`"]
#[inline]
pub unsafe extern "C-unwind" fn CFUserNotificationCreateRunLoopSource(
    allocator: Option<&CFAllocator>,
    user_notification: Option<&CFUserNotification>,
    callout: CFUserNotificationCallBack,
    order: CFIndex,
) -> Option<CFRetained<CFRunLoopSource>> {
    extern "C-unwind" {
        fn CFUserNotificationCreateRunLoopSource(
            allocator: Option<&CFAllocator>,
            user_notification: Option<&CFUserNotification>,
            callout: CFUserNotificationCallBack,
            order: CFIndex,
        ) -> Option<NonNull<CFRunLoopSource>>;
    }
    let ret = unsafe {
        CFUserNotificationCreateRunLoopSource(allocator, user_notification, callout, order)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CFDate", feature = "CFURL"))]
#[deprecated = "renamed to `CFUserNotification::display_notice`"]
#[inline]
pub extern "C-unwind" fn CFUserNotificationDisplayNotice(
    timeout: CFTimeInterval,
    flags: CFOptionFlags,
    icon_url: Option<&CFURL>,
    sound_url: Option<&CFURL>,
    localization_url: Option<&CFURL>,
    alert_header: Option<&CFString>,
    alert_message: Option<&CFString>,
    default_button_title: Option<&CFString>,
) -> i32 {
    extern "C-unwind" {
        fn CFUserNotificationDisplayNotice(
            timeout: CFTimeInterval,
            flags: CFOptionFlags,
            icon_url: Option<&CFURL>,
            sound_url: Option<&CFURL>,
            localization_url: Option<&CFURL>,
            alert_header: Option<&CFString>,
            alert_message: Option<&CFString>,
            default_button_title: Option<&CFString>,
        ) -> i32;
    }
    unsafe {
        CFUserNotificationDisplayNotice(
            timeout,
            flags,
            icon_url,
            sound_url,
            localization_url,
            alert_header,
            alert_message,
            default_button_title,
        )
    }
}

extern "C-unwind" {
    #[cfg(all(feature = "CFDate", feature = "CFURL"))]
    #[deprecated = "renamed to `CFUserNotification::display_alert`"]
    pub fn CFUserNotificationDisplayAlert(
        timeout: CFTimeInterval,
        flags: CFOptionFlags,
        icon_url: Option<&CFURL>,
        sound_url: Option<&CFURL>,
        localization_url: Option<&CFURL>,
        alert_header: Option<&CFString>,
        alert_message: Option<&CFString>,
        default_button_title: Option<&CFString>,
        alternate_button_title: Option<&CFString>,
        other_button_title: Option<&CFString>,
        response_flags: *mut CFOptionFlags,
    ) -> i32;
}
