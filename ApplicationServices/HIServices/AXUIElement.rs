//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;

use crate::*;

/// Returns whether the accessibility API is enabled.
///
/// Returns: Returns TRUE if the accessibility API is currently enabled, otherwise FALSE.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn AXAPIEnabled() -> bool {
    extern "C-unwind" {
        fn AXAPIEnabled() -> Boolean;
    }
    let ret = unsafe { AXAPIEnabled() };
    ret != 0
}

/// Returns whether the current process is a trusted accessibility client.
///
/// Parameter `options`: A dictionary of options, or NULL to specify no options. The following options are available:
///
/// KEY: kAXTrustedCheckOptionPrompt
/// VALUE: ACFBooleanRef indicating whether the user will be informed if the current process is untrusted. This could be used, for example, on application startup to always warn a user if accessibility is not enabled for the current process. Prompting occurs asynchronously and does not affect the return value.
///
///
/// Returns: Returns TRUE if the current process is a trusted accessibility client, FALSE if it is not.
///
/// # Safety
///
/// `options` generics must be of the correct type.
#[inline]
pub unsafe extern "C-unwind" fn AXIsProcessTrustedWithOptions(
    options: Option<&CFDictionary>,
) -> bool {
    extern "C-unwind" {
        fn AXIsProcessTrustedWithOptions(options: Option<&CFDictionary>) -> Boolean;
    }
    let ret = unsafe { AXIsProcessTrustedWithOptions(options) };
    ret != 0
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/applicationservices/kaxtrustedcheckoptionprompt?language=objc)
    pub static kAXTrustedCheckOptionPrompt: &'static CFString;
}

/// Returns whether the current process is a trusted accessibility client.
///
///
/// Returns: Returns TRUE if the current process is a trusted accessibility client, FALSE if it is not.
#[inline]
pub unsafe extern "C-unwind" fn AXIsProcessTrusted() -> bool {
    extern "C-unwind" {
        fn AXIsProcessTrusted() -> Boolean;
    }
    let ret = unsafe { AXIsProcessTrusted() };
    ret != 0
}

extern "C-unwind" {
    /// Attempts to make the process represented by the specified path a trusted accessibility client.
    ///
    ///
    /// Use this function to make a process a trusted accessibility client.  Note: The caller must be running as
    /// <code>
    /// root
    /// </code>
    /// to successfully call this function. In addition, the caller should relaunch the process after this function returns successfully for the trusted status to take effect.
    ///
    ///
    /// Parameter `executablePath`: The path to the executable of the process to make trusted.
    ///
    ///
    /// Returns: An AXError that indicates success or failure.
    #[cfg(feature = "AXError")]
    #[deprecated]
    pub fn AXMakeProcessTrusted(executable_path: &CFString) -> AXError;
}

/// A structure used to refer to an accessibility object.
///
///
/// An accessibility object provides information about the user interface object it represents. This information includes the object's
/// position in the accessibility hierarchy, its position on the display, details about what it is, and what actions it can perform. Accessibility objects
/// respond to messages sent by assistive applications and send notifications that describe state changes.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/applicationservices/axuielement?language=objc)
#[doc(alias = "AXUIElementRef")]
#[repr(C)]
pub struct AXUIElement {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl AXUIElement {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__AXUIElement"> for AXUIElement {}
);

/// Pass this option to
///
/// ```text
///  AXUIElementCopyMultipleAttributeValues AXUIElementCopyMultipleAttributeValues
/// ```
///
/// to force the function
/// to stop when it gets an error.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/applicationservices/axcopymultipleattributeoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AXCopyMultipleAttributeOptions(pub u32);
bitflags::bitflags! {
    impl AXCopyMultipleAttributeOptions: u32 {
        #[doc(alias = "kAXCopyMultipleAttributeOptionStopOnError")]
        const StopOnError = 0x1;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for AXCopyMultipleAttributeOptions {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for AXCopyMultipleAttributeOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for AXUIElement {
    /// Returns the unique type identifier for the AXUIElementRef type.
    ///
    ///
    /// Returns: Returns a CFTypeID representing the AXUIElementRef type.
    #[doc(alias = "AXUIElementGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn AXUIElementGetTypeID() -> CFTypeID;
        }
        unsafe { AXUIElementGetTypeID() }
    }
}

impl AXUIElement {
    /// Returns a list of all the attributes supported by the specified accessibility object.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `names`: On return, an array containing the accessibility object's attribute names.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementCopyAttributeNames
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorAttributeUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified AXUIElementRef does not support the specified attribute.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or both of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorFailure
    /// </code>
    /// </dt>
    /// <dd>
    /// There was a system memory failure.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `names` must be a valid pointer.
    #[doc(alias = "AXUIElementCopyAttributeNames")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn copy_attribute_names(&self, names: NonNull<*const CFArray>) -> AXError {
        extern "C-unwind" {
            fn AXUIElementCopyAttributeNames(
                element: &AXUIElement,
                names: NonNull<*const CFArray>,
            ) -> AXError;
        }
        unsafe { AXUIElementCopyAttributeNames(self, names) }
    }

    /// Returns the value of an accessibility object's attribute.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `attribute`: The attribute name.
    ///
    /// Parameter `value`: On return, the value associated with the specified attribute.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementCopyAttributeValue
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorAttributeUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified AXUIElementRef does not support the specified attribute.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNoValue
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified attribute does not have a value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `value` must be a valid pointer.
    #[doc(alias = "AXUIElementCopyAttributeValue")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn copy_attribute_value(
        &self,
        attribute: &CFString,
        value: NonNull<*const CFType>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementCopyAttributeValue(
                element: &AXUIElement,
                attribute: &CFString,
                value: NonNull<*const CFType>,
            ) -> AXError;
        }
        unsafe { AXUIElementCopyAttributeValue(self, attribute, value) }
    }

    /// Returns the count of the array of an accessibility object's attribute value.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `attribute`: The attribute name.
    ///
    /// Parameter `count`: On return, the size of the array that is the attribute's value.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementGetAttributeValueCount
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// The attribute's value is not an array or one of the other arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorAttributeUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified AXUIElementRef does not support the specified attribute.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `count` must be a valid pointer.
    #[doc(alias = "AXUIElementGetAttributeValueCount")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn attribute_value_count(
        &self,
        attribute: &CFString,
        count: NonNull<CFIndex>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementGetAttributeValueCount(
                element: &AXUIElement,
                attribute: &CFString,
                count: NonNull<CFIndex>,
            ) -> AXError;
        }
        unsafe { AXUIElementGetAttributeValueCount(self, attribute, count) }
    }

    /// Returns an array of attribute values for the accessibility object's attribute, starting at the specified index.
    ///
    /// This function is useful for dealing with large arrays, for example, a table view with a large number of children.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `attribute`: The attribute name.
    ///
    /// Parameter `index`: The index into the array.
    ///
    /// Parameter `maxValues`: The maximum number of values you want (this may be more or less than the number of values associated with the attribute).
    ///
    /// Parameter `values`: On return, the attribute values you requested. If
    /// <code>
    /// maxValues
    /// </code>
    /// is greater than the number of values associated with the attribute, the
    /// <code>
    /// values
    /// </code>
    /// array will contain values found between
    /// <code>
    /// index
    /// </code>
    /// and the end of the attribute's array, inclusive.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementCopyAttributeValues
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// The attribute's value is not array, the
    /// <code>
    /// index
    /// </code>
    /// or
    /// <code>
    /// maxValues
    /// </code>
    /// arguments are outside the array's range, or one of the other arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNoValue
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified attribute does not have a value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `values` must be a valid pointer.
    #[doc(alias = "AXUIElementCopyAttributeValues")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn copy_attribute_values(
        &self,
        attribute: &CFString,
        index: CFIndex,
        max_values: CFIndex,
        values: NonNull<*const CFArray>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementCopyAttributeValues(
                element: &AXUIElement,
                attribute: &CFString,
                index: CFIndex,
                max_values: CFIndex,
                values: NonNull<*const CFArray>,
            ) -> AXError;
        }
        unsafe { AXUIElementCopyAttributeValues(self, attribute, index, max_values, values) }
    }

    /// Returns whether the specified accessibility object's attribute can be modified.
    ///
    /// If you receive a
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// error from this function, you might want to repeat the request or change the timeout value.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `attribute`: The attribute name.
    ///
    /// Parameter `settable`: On return, a Boolean value indicating whether the attribute is settable.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementIsAttributeSettable
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way (often due to a timeout).
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorAttributeUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified AXUIElementRef does not support the specified attribute.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNoValue
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified attribute does not have a value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `settable` must be a valid pointer.
    #[doc(alias = "AXUIElementIsAttributeSettable")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn is_attribute_settable(
        &self,
        attribute: &CFString,
        settable: NonNull<Boolean>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementIsAttributeSettable(
                element: &AXUIElement,
                attribute: &CFString,
                settable: NonNull<Boolean>,
            ) -> AXError;
        }
        unsafe { AXUIElementIsAttributeSettable(self, attribute, settable) }
    }

    /// Sets the accessibility object's attribute to the specified value.
    ///
    /// You can send and receive many different CFTypeRefs using the accessibility API.
    /// These include all CFPropertyListRef types, AXUIElementRef, AXValueRef, AXTextMarkerRef, AXTextMarkerRangeRef,
    /// CFNullRef, CFAttributedStringRef, and CRURLRef.
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `attribute`: The attribute name.
    ///
    /// Parameter `value`: The new value for the attribute.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementSetAttributeValue
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// The value is not recognized by the accessible application or one of the other arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorAttributeUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified AXUIElementRef does not support the specified attribute.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `value` should be of the correct type.
    #[doc(alias = "AXUIElementSetAttributeValue")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn set_attribute_value(&self, attribute: &CFString, value: &CFType) -> AXError {
        extern "C-unwind" {
            fn AXUIElementSetAttributeValue(
                element: &AXUIElement,
                attribute: &CFString,
                value: &CFType,
            ) -> AXError;
        }
        unsafe { AXUIElementSetAttributeValue(self, attribute, value) }
    }

    /// Returns the values of multiple attributes in the accessibility object.
    ///
    /// If the specified AXUIElementRef does not support an attribute passed in the
    /// <code>
    /// attributes
    /// </code>
    /// array, the returned array
    /// can contain an error or CFNull at the corresponding position.
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `attributes`: An array of attribute names.
    ///
    /// Parameter `options`: A value that tells
    /// <code>
    /// AXUIElementCopyMultipleAttributeValues
    /// </code>
    /// how to handle errors.
    ///
    /// Parameter `values`: On return, an array in which each position contains the value of the
    /// attribute that is in the corresponding position in the passed-in
    /// <code>
    /// attributes
    /// </code>
    /// array (or CFNull). If
    /// <code>
    /// options
    /// </code>
    /// = 0,
    /// the
    /// <code>
    /// values
    /// </code>
    /// array can contain an AXValueRef of type
    /// <code>
    /// kAXValueAXErrorType
    /// </code>
    /// in the corresponding position. If
    /// <code>
    /// options
    /// </code>
    /// =
    /// <code>
    /// kAXCopyMultipleAttributeOptionStopOnError
    /// </code>
    /// ,
    /// this function will return immediately when it gets an error.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementCopyMultipleAttributeValues
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// - `attributes` generic must be of the correct type.
    /// - `values` must be a valid pointer.
    #[doc(alias = "AXUIElementCopyMultipleAttributeValues")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn copy_multiple_attribute_values(
        &self,
        attributes: &CFArray,
        options: AXCopyMultipleAttributeOptions,
        values: NonNull<*const CFArray>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementCopyMultipleAttributeValues(
                element: &AXUIElement,
                attributes: &CFArray,
                options: AXCopyMultipleAttributeOptions,
                values: NonNull<*const CFArray>,
            ) -> AXError;
        }
        unsafe { AXUIElementCopyMultipleAttributeValues(self, attributes, options, values) }
    }

    /// Returns a list of all the parameterized attributes supported by the specified accessibility object.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `names`: On return, an array containing the accessibility object's parameterized attribute names.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementCopyParameterizedAttributeNames
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorAttributeUnsupported
    /// </code>
    /// or
    /// <code>
    /// kAXErrorParameterizedAttributeUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified AXUIElementRef does not support the specified parameterized attribute.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or both of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorFailure
    /// </code>
    /// </dt>
    /// <dd>
    /// There was some sort of system memory failure.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `names` must be a valid pointer.
    #[doc(alias = "AXUIElementCopyParameterizedAttributeNames")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn copy_parameterized_attribute_names(
        &self,
        names: NonNull<*const CFArray>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementCopyParameterizedAttributeNames(
                element: &AXUIElement,
                names: NonNull<*const CFArray>,
            ) -> AXError;
        }
        unsafe { AXUIElementCopyParameterizedAttributeNames(self, names) }
    }

    /// Returns the value of an accessibility object's parameterized attribute.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `parameterizedAttribute`: The parameterized attribute.
    ///
    /// Parameter `parameter`: The parameter.
    ///
    /// Parameter `result`: On return, the value of the parameterized attribute.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementCopyParameterizedAttributeValue
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorAttributeUnsupported
    /// </code>
    /// or
    /// <code>
    /// kAXErrorParameterizedAttributeUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified AXUIElementRef does not support the specified parameterized attribute.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNoValue
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified parameterized attribute does not have a value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// - `parameter` should be of the correct type.
    /// - `result` must be a valid pointer.
    #[doc(alias = "AXUIElementCopyParameterizedAttributeValue")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn copy_parameterized_attribute_value(
        &self,
        parameterized_attribute: &CFString,
        parameter: &CFType,
        result: NonNull<*const CFType>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementCopyParameterizedAttributeValue(
                element: &AXUIElement,
                parameterized_attribute: &CFString,
                parameter: &CFType,
                result: NonNull<*const CFType>,
            ) -> AXError;
        }
        unsafe {
            AXUIElementCopyParameterizedAttributeValue(
                self,
                parameterized_attribute,
                parameter,
                result,
            )
        }
    }

    /// Returns a list of all the actions the specified accessibility object can perform.
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `names`: On return, an array of actions the accessibility object can perform (empty if the accessibility object supports no actions).
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementCopyActionNames
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or both of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorFailure
    /// </code>
    /// </dt>
    /// <dd>
    /// There was some sort of system memory failure.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `names` must be a valid pointer.
    #[doc(alias = "AXUIElementCopyActionNames")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn copy_action_names(&self, names: NonNull<*const CFArray>) -> AXError {
        extern "C-unwind" {
            fn AXUIElementCopyActionNames(
                element: &AXUIElement,
                names: NonNull<*const CFArray>,
            ) -> AXError;
        }
        unsafe { AXUIElementCopyActionNames(self, names) }
    }

    /// Returns a localized description of the specified accessibility object's action.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `action`: The action to be described.
    ///
    /// Parameter `description`: On return, a string containing the description of the action.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementCopyActionDescription
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorActionUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified AXUIElementRef does not support the specified action (you will also receive this error if you pass in the system-wide accessibility object).
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `description` must be a valid pointer.
    #[doc(alias = "AXUIElementCopyActionDescription")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn copy_action_description(
        &self,
        action: &CFString,
        description: NonNull<*const CFString>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementCopyActionDescription(
                element: &AXUIElement,
                action: &CFString,
                description: NonNull<*const CFString>,
            ) -> AXError;
        }
        unsafe { AXUIElementCopyActionDescription(self, action, description) }
    }

    /// Requests that the specified accessibility object perform the specified action.
    ///
    /// It is possible to receive the
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// error code from this function because accessible applications often need to
    /// perform some sort of modal processing inside their action callbacks and they may not return within the timeout value set by the accessibility API.
    /// This does not necessarily mean that the function has failed, however. If appropriate, your assistive application
    /// can try to call this function again. Also, you may be able to increase the timeout value (see
    ///
    /// ```text
    ///  AXUIElementSetMessagingTimeout AXUIElementSetMessagingTimeout
    /// ```
    ///
    /// ).
    ///
    /// Parameter `element`: The AXUIElementRef representing the accessibility object.
    ///
    /// Parameter `action`: The action to be performed.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementPerformAction
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorActionUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The specified AXUIElementRef does not support the specified action (you will also receive this error if you pass in the system-wide accessibility object).
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way or the application has not yet responded.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    #[doc(alias = "AXUIElementPerformAction")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn perform_action(&self, action: &CFString) -> AXError {
        extern "C-unwind" {
            fn AXUIElementPerformAction(element: &AXUIElement, action: &CFString) -> AXError;
        }
        unsafe { AXUIElementPerformAction(self, action) }
    }

    /// Returns the accessibility object at the specified position in top-left relative screen coordinates.
    ///
    ///
    /// This function does hit-testing based on window z-order (that is, layering). If one window is on top of another window, the returned accessibility object comes from whichever window is topmost at the specified
    /// location. Note that if the system-wide accessibility object is passed in the
    /// <code>
    /// application
    /// </code>
    /// parameter, the position test is not restricted to a
    /// particular application.
    ///
    ///
    /// Parameter `application`: The AXUIElementRef representing the application that contains the screen coordinates (or the system-wide accessibility object).
    ///
    /// Parameter `x`: The horizontal position.
    ///
    /// Parameter `y`: The vertical position.
    ///
    /// Parameter `element`: On return, the accessibility object at the position specified by x and y.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementCopyElementAtPosition
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorNoValue
    /// </code>
    /// </dt>
    /// <dd>
    /// There is no accessibility object at the specified position.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `element` must be a valid pointer.
    #[doc(alias = "AXUIElementCopyElementAtPosition")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn copy_element_at_position(
        &self,
        x: c_float,
        y: c_float,
        element: NonNull<*const AXUIElement>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementCopyElementAtPosition(
                application: &AXUIElement,
                x: c_float,
                y: c_float,
                element: NonNull<*const AXUIElement>,
            ) -> AXError;
        }
        unsafe { AXUIElementCopyElementAtPosition(self, x, y, element) }
    }

    /// Creates and returns the top-level accessibility object for the application with the specified process ID.
    ///
    ///
    /// Parameter `pid`: The process ID of an application.
    ///
    /// Returns: The AXUIElementRef representing the top-level accessibility object for the application with the specified process ID.
    #[doc(alias = "AXUIElementCreateApplication")]
    #[cfg(feature = "libc")]
    #[inline]
    pub unsafe fn new_application(pid: libc::pid_t) -> CFRetained<AXUIElement> {
        extern "C-unwind" {
            fn AXUIElementCreateApplication(pid: libc::pid_t) -> Option<NonNull<AXUIElement>>;
        }
        let ret = unsafe { AXUIElementCreateApplication(pid) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Returns an accessibility object that provides access to system attributes.
    ///
    /// This is useful for things like finding the focused accessibility object regardless of which application is currently active.
    ///
    ///
    /// Returns: The AXUIElementRef representing the system-wide accessibility object.
    #[doc(alias = "AXUIElementCreateSystemWide")]
    #[inline]
    pub unsafe fn new_system_wide() -> CFRetained<AXUIElement> {
        extern "C-unwind" {
            fn AXUIElementCreateSystemWide() -> Option<NonNull<AXUIElement>>;
        }
        let ret = unsafe { AXUIElementCreateSystemWide() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Returns the process ID associated with the specified accessibility object.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing an accessibility object.
    ///
    /// Parameter `pid`: On return, the process ID associated with the specified accessibility object.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementGetPid
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `pid` must be a valid pointer.
    #[doc(alias = "AXUIElementGetPid")]
    #[cfg(all(feature = "AXError", feature = "libc"))]
    #[inline]
    pub unsafe fn pid(&self, pid: NonNull<libc::pid_t>) -> AXError {
        extern "C-unwind" {
            fn AXUIElementGetPid(element: &AXUIElement, pid: NonNull<libc::pid_t>) -> AXError;
        }
        unsafe { AXUIElementGetPid(self, pid) }
    }

    /// Sets the timeout value used in the accessibility API.
    ///
    /// Pass the system-wide accessibility object (see
    ///
    /// ```text
    ///  AXUIElementCreateSystemWide AXUIElementCreateSystemWide
    /// ```
    ///
    /// ) if you want to set the timeout globally for this process.
    /// Setting the timeout on another accessibility object sets it only for that object, not for other accessibility objects that are equal to it.
    ///
    /// Setting
    /// <code>
    /// timeoutInSeconds
    /// </code>
    /// to 0 for the system-wide accessibility object resets the global timeout to its default value. Setting
    /// <code>
    /// timeoutInSeconds
    /// </code>
    /// to 0 for any other accessibility object makes that element use the current global timeout value.
    ///
    ///
    /// Parameter `element`: The AXUIElementRef representing an accessibility object.
    ///
    /// Parameter `timeoutInSeconds`: The number of seconds for the new timeout value.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementSetMessagingTimeout
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value (timeout values must be positive).
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// </dl>
    #[doc(alias = "AXUIElementSetMessagingTimeout")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn set_messaging_timeout(&self, timeout_in_seconds: c_float) -> AXError {
        extern "C-unwind" {
            fn AXUIElementSetMessagingTimeout(
                element: &AXUIElement,
                timeout_in_seconds: c_float,
            ) -> AXError;
        }
        unsafe { AXUIElementSetMessagingTimeout(self, timeout_in_seconds) }
    }

    /// Posts keys to the specified application.
    ///
    ///
    /// This is similar to
    ///
    /// ```text
    ///  //apple_ref/c/func/CGPostKeyboardEvent CGPostKeyboardEvent
    /// ```
    ///
    /// (which synthesizes a low-level keyboard event on the
    /// local machine), but it allows you to specify the target application as opposed to always sending the events to the active application. If the
    /// system-wide accessibility object is passed in the
    /// <code>
    /// application
    /// </code>
    /// parameter, the event is sent to the active application.
    ///
    /// You can only pass in the system-wide or application AXUIElementRef.
    ///
    ///
    /// Parameter `application`: The AXUIElementRef representing the application (or the system-wide accessibility object).
    ///
    /// Parameter `keyChar`:
    /// Parameter `virtualKey`:
    /// Parameter `keyDown`:
    /// Returns: If unsuccessful,
    /// <code>
    /// AXUIElementPostKeyboardEvent
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElement
    /// </code>
    /// </dt>
    /// <dd>
    /// The AXUIElementRef is invalid.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorFailure
    /// </code>
    /// </dt>
    /// <dd>
    /// There is some sort of system memory failure.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotImplemented
    /// </code>
    /// </dt>
    /// <dd>
    /// The process does not fully support the accessibility API.
    /// </dd>
    /// </dl>
    #[doc(alias = "AXUIElementPostKeyboardEvent")]
    #[cfg(all(feature = "AXError", feature = "objc2-core-graphics"))]
    #[deprecated]
    #[inline]
    pub unsafe fn post_keyboard_event(
        &self,
        key_char: CGCharCode,
        virtual_key: CGKeyCode,
        key_down: bool,
    ) -> AXError {
        extern "C-unwind" {
            fn AXUIElementPostKeyboardEvent(
                application: &AXUIElement,
                key_char: CGCharCode,
                virtual_key: CGKeyCode,
                key_down: Boolean,
            ) -> AXError;
        }
        unsafe { AXUIElementPostKeyboardEvent(self, key_char, virtual_key, key_down as _) }
    }
}

/// An AXTextMarkerRef is a CFType. Like all CFTypes, they are reference counted (
///
/// ```text
///  //apple_ref/c/func/CFRetain CFRetain
/// ```
///
/// ,
///
/// ```text
///  //apple_ref/c/func/CFRelease CFRelease
/// ```
///
/// ).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/applicationservices/axtextmarker?language=objc)
#[doc(alias = "AXTextMarkerRef")]
#[repr(C)]
pub struct AXTextMarker {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl AXTextMarker {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__AXTextMarker"> for AXTextMarker {}
);

unsafe impl ConcreteType for AXTextMarker {
    /// Returns the unique type identifier for the AXTextMarkerRef type.
    ///
    ///
    /// Returns: Returns the CFTypeID of the AXTextMarkerRef type.
    #[doc(alias = "AXTextMarkerGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn AXTextMarkerGetTypeID() -> CFTypeID;
        }
        unsafe { AXTextMarkerGetTypeID() }
    }
}

impl AXTextMarker {
    /// Creates a new text marker.
    ///
    ///
    /// Parameter `bytes`: The data used to identify this location in text
    ///
    /// Parameter `length`: The length of the data
    ///
    /// # Safety
    ///
    /// `bytes` must be a valid pointer.
    #[doc(alias = "AXTextMarkerCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        bytes: NonNull<u8>,
        length: CFIndex,
    ) -> CFRetained<AXTextMarker> {
        extern "C-unwind" {
            fn AXTextMarkerCreate(
                allocator: Option<&CFAllocator>,
                bytes: NonNull<u8>,
                length: CFIndex,
            ) -> Option<NonNull<AXTextMarker>>;
        }
        let ret = unsafe { AXTextMarkerCreate(allocator, bytes, length) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Get the length of bytes stored in a text marker
    ///
    ///
    /// Parameter `marker`: The text marker
    ///
    ///
    /// Returns: The length of the data
    #[doc(alias = "AXTextMarkerGetLength")]
    #[inline]
    pub unsafe fn length(&self) -> CFIndex {
        extern "C-unwind" {
            fn AXTextMarkerGetLength(marker: &AXTextMarker) -> CFIndex;
        }
        unsafe { AXTextMarkerGetLength(self) }
    }

    /// Get the byte data used to identify this location in text.
    ///
    ///
    /// Parameter `marker`: The text marker
    ///
    ///
    /// Returns: a pointer to the byte data used to identify this location in text.
    #[doc(alias = "AXTextMarkerGetBytePtr")]
    #[inline]
    pub unsafe fn byte_ptr(&self) -> NonNull<u8> {
        extern "C-unwind" {
            fn AXTextMarkerGetBytePtr(the_text_marker: &AXTextMarker) -> Option<NonNull<u8>>;
        }
        let ret = unsafe { AXTextMarkerGetBytePtr(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// An AXTextMarkerRangeRef is a CFType. Like all CFTypes, they are reference counted (
///
/// ```text
///  //apple_ref/c/func/CFRetain CFRetain
/// ```
///
/// ,
///
/// ```text
///  //apple_ref/c/func/CFRelease CFRelease
/// ```
///
/// ).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/applicationservices/axtextmarkerrange?language=objc)
#[doc(alias = "AXTextMarkerRangeRef")]
#[repr(C)]
pub struct AXTextMarkerRange {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl AXTextMarkerRange {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__AXTextMarkerRange"> for AXTextMarkerRange {}
);

unsafe impl ConcreteType for AXTextMarkerRange {
    /// Returns the unique type identifier for the AXTextMarkerRangeRef type.
    ///
    ///
    /// Returns: Returns the CFTypeID of the AXTextMarkerRangeRef type.
    #[doc(alias = "AXTextMarkerRangeGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn AXTextMarkerRangeGetTypeID() -> CFTypeID;
        }
        unsafe { AXTextMarkerRangeGetTypeID() }
    }
}

impl AXTextMarkerRange {
    /// Creates a new text marker given a start and end marker
    ///
    ///
    /// Parameter `startMarker`: The text marker for the beginning of the range
    ///
    /// Parameter `endMarker`: The text marker for the end of the range
    ///
    ///
    /// Returns: The text marker range object
    #[doc(alias = "AXTextMarkerRangeCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        start_marker: &AXTextMarker,
        end_marker: &AXTextMarker,
    ) -> CFRetained<AXTextMarkerRange> {
        extern "C-unwind" {
            fn AXTextMarkerRangeCreate(
                allocator: Option<&CFAllocator>,
                start_marker: &AXTextMarker,
                end_marker: &AXTextMarker,
            ) -> Option<NonNull<AXTextMarkerRange>>;
        }
        let ret = unsafe { AXTextMarkerRangeCreate(allocator, start_marker, end_marker) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a new text marker given the bytes for a start marker and an end marker
    ///
    ///
    /// Parameter `startMarkerBytes`: The data used to identify the start marker location in text
    ///
    /// Parameter `startMarkerLength`: The length of the start marker data
    ///
    /// Parameter `endMarkeBytes`: The data used to identify the end marker location in text
    ///
    /// Parameter `endMarkerLength`: The length of the end marker data
    ///
    ///
    /// Returns: The text marker range object
    ///
    /// # Safety
    ///
    /// - `start_marker_bytes` must be a valid pointer.
    /// - `end_marker_bytes` must be a valid pointer.
    #[doc(alias = "AXTextMarkerRangeCreateWithBytes")]
    #[inline]
    pub unsafe fn with_bytes(
        allocator: Option<&CFAllocator>,
        start_marker_bytes: NonNull<u8>,
        start_marker_length: CFIndex,
        end_marker_bytes: NonNull<u8>,
        end_marker_length: CFIndex,
    ) -> CFRetained<AXTextMarkerRange> {
        extern "C-unwind" {
            fn AXTextMarkerRangeCreateWithBytes(
                allocator: Option<&CFAllocator>,
                start_marker_bytes: NonNull<u8>,
                start_marker_length: CFIndex,
                end_marker_bytes: NonNull<u8>,
                end_marker_length: CFIndex,
            ) -> Option<NonNull<AXTextMarkerRange>>;
        }
        let ret = unsafe {
            AXTextMarkerRangeCreateWithBytes(
                allocator,
                start_marker_bytes,
                start_marker_length,
                end_marker_bytes,
                end_marker_length,
            )
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Copies the start marker from a text marker range
    ///
    ///
    /// Parameter `textMarkerRange`: The text marker range
    ///
    ///
    /// Returns: The start text marker object
    #[doc(alias = "AXTextMarkerRangeCopyStartMarker")]
    #[inline]
    pub unsafe fn start_marker(&self) -> CFRetained<AXTextMarker> {
        extern "C-unwind" {
            fn AXTextMarkerRangeCopyStartMarker(
                text_marker_range: &AXTextMarkerRange,
            ) -> Option<NonNull<AXTextMarker>>;
        }
        let ret = unsafe { AXTextMarkerRangeCopyStartMarker(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Copies the end marker from a text marker range
    ///
    ///
    /// Parameter `textMarkerRange`: The text marker range
    ///
    ///
    /// Returns: The end text marker object
    #[doc(alias = "AXTextMarkerRangeCopyEndMarker")]
    #[inline]
    pub unsafe fn end_marker(&self) -> CFRetained<AXTextMarker> {
        extern "C-unwind" {
            fn AXTextMarkerRangeCopyEndMarker(
                text_marker_range: &AXTextMarkerRange,
            ) -> Option<NonNull<AXTextMarker>>;
        }
        let ret = unsafe { AXTextMarkerRangeCopyEndMarker(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

/// An AXObserverRef is a CFType. Like all CFTypes, they are reference counted (
///
/// ```text
///  //apple_ref/c/func/CFRetain CFRetain
/// ```
///
/// ,
///
/// ```text
///  //apple_ref/c/func/CFRelease CFRelease
/// ```
///
/// ).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/applicationservices/axobserver?language=objc)
#[doc(alias = "AXObserverRef")]
#[repr(C)]
pub struct AXObserver {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl AXObserver {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__AXObserver"> for AXObserver {}
);

/// Parameter `observer`: An AXObserverRef object to observe the notifications.
///
/// Parameter `element`: The accessibility object.
///
/// Parameter `notification`: The name of the notification to observe.
///
/// Parameter `refcon`: Application-defined data specified when registering the observer for notification
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/applicationservices/axobservercallback?language=objc)
pub type AXObserverCallback = Option<
    unsafe extern "C-unwind" fn(
        NonNull<AXObserver>,
        NonNull<AXUIElement>,
        NonNull<CFString>,
        *mut c_void,
    ),
>;

/// Parameter `observer`: An AXObserverRef object to observe the notifications.
///
/// Parameter `element`: The accessibility object.
///
/// Parameter `notification`: The name of the notification to observe.
///
/// Parameter `info`: The coresponding notification information.
///
/// Parameter `refcon`: Application-defined data specified when registering the observer for notification
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/applicationservices/axobservercallbackwithinfo?language=objc)
pub type AXObserverCallbackWithInfo = Option<
    unsafe extern "C-unwind" fn(
        NonNull<AXObserver>,
        NonNull<AXUIElement>,
        NonNull<CFString>,
        NonNull<CFDictionary>,
        *mut c_void,
    ),
>;

unsafe impl ConcreteType for AXObserver {
    /// Returns the unique type identifier for the AXObserverRef type.
    ///
    ///
    /// Returns: Returns the CFTypeID of the AXObserverRef type.
    #[doc(alias = "AXObserverGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn AXObserverGetTypeID() -> CFTypeID;
        }
        unsafe { AXObserverGetTypeID() }
    }
}

impl AXObserver {
    /// Creates a new observer that can receive notifications from the specified application.
    ///
    /// When an observed notification is received, it is passed to
    ///
    /// ```text
    ///  AXObserverCallback AXObserverCallback
    /// ```
    ///
    /// .
    ///
    ///
    /// Parameter `application`: The process ID of the application.
    ///
    /// Parameter `callback`: The callback function.
    ///
    /// Parameter `outObserver`: On return, an AXObserverRef representing the observer object.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXObserverCreate
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorFailure
    /// </code>
    /// </dt>
    /// <dd>
    /// There is some sort of system memory failure.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `out_observer` must be a valid pointer.
    #[doc(alias = "AXObserverCreate")]
    #[cfg(all(feature = "AXError", feature = "libc"))]
    #[inline]
    pub unsafe fn create(
        application: libc::pid_t,
        callback: AXObserverCallback,
        out_observer: NonNull<*mut AXObserver>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXObserverCreate(
                application: libc::pid_t,
                callback: AXObserverCallback,
                out_observer: NonNull<*mut AXObserver>,
            ) -> AXError;
        }
        unsafe { AXObserverCreate(application, callback, out_observer) }
    }

    /// Creates a new observer that can receive notifications with an information dictionary from the specified application.
    ///
    /// When an observed notification is received, it is passed to
    ///
    /// ```text
    ///  AXObserverCallbackWithInfo AXObserverCallbackWithInfo
    /// ```
    ///
    /// .
    ///
    ///
    /// Parameter `application`: The process ID of the application.
    ///
    /// Parameter `callback`: The callback function.
    ///
    /// Parameter `outObserver`: On return, an AXObserverRef representing the observer object.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXObserverCreateWithInfoCallback
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorFailure
    /// </code>
    /// </dt>
    /// <dd>
    /// There is some sort of system memory failure.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `out_observer` must be a valid pointer.
    #[doc(alias = "AXObserverCreateWithInfoCallback")]
    #[cfg(all(feature = "AXError", feature = "libc"))]
    #[inline]
    pub unsafe fn create_with_info_callback(
        application: libc::pid_t,
        callback: AXObserverCallbackWithInfo,
        out_observer: NonNull<*mut AXObserver>,
    ) -> AXError {
        extern "C-unwind" {
            fn AXObserverCreateWithInfoCallback(
                application: libc::pid_t,
                callback: AXObserverCallbackWithInfo,
                out_observer: NonNull<*mut AXObserver>,
            ) -> AXError;
        }
        unsafe { AXObserverCreateWithInfoCallback(application, callback, out_observer) }
    }

    /// Registers the specified observer to receive notifications from the specified accessibility object.
    ///
    ///
    /// Parameter `observer`: The observer object created from a call to
    ///
    /// ```text
    ///  AXObserverCreate AXObserverCreate
    /// ```
    ///
    /// .
    ///
    /// Parameter `element`: The accessibility object for which to observe notifications.
    ///
    /// Parameter `notification`: The name of the notification to observe.
    ///
    /// Parameter `refcon`: Application-defined data passed to the callback when it is called.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXObserverAddNotification
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElementObserver
    /// </code>
    /// </dt>
    /// <dd>
    /// The observer is not a valid AXObserverRef type.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value or the length of the notification name is greater than 1024.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotificationUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The accessibility object does not support notifications (note that the system-wide accessibility object does not support notifications).
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotificationAlreadyRegistered
    /// </code>
    /// </dt>
    /// <dd>
    /// The notification has already been registered.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorFailure
    /// </code>
    /// </dt>
    /// <dd>
    /// There is some sort of system memory failure.
    /// </dd>
    /// </dl>
    ///
    /// # Safety
    ///
    /// `refcon` must be a valid pointer or null.
    #[doc(alias = "AXObserverAddNotification")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn add_notification(
        &self,
        element: &AXUIElement,
        notification: &CFString,
        refcon: *mut c_void,
    ) -> AXError {
        extern "C-unwind" {
            fn AXObserverAddNotification(
                observer: &AXObserver,
                element: &AXUIElement,
                notification: &CFString,
                refcon: *mut c_void,
            ) -> AXError;
        }
        unsafe { AXObserverAddNotification(self, element, notification, refcon) }
    }

    /// Removes the specified notification from the list of notifications the observer wants to receive from the accessibility object.
    ///
    ///
    /// Parameter `observer`: The observer object created from a call to
    ///
    /// ```text
    ///  AXObserverCreate AXObserverCreate
    /// ```
    ///
    /// .
    ///
    /// Parameter `element`: The accessibility object for which this observer observes notifications.
    ///
    /// Parameter `notification`: The name of the notification to remove from the list of observed notifications.
    ///
    ///
    /// Returns: If unsuccessful,
    /// <code>
    /// AXObserverRemoveNotification
    /// </code>
    /// may return one of the following error codes, among others:
    /// <dl>
    /// <dt>
    /// <code>
    /// kAXErrorInvalidUIElementObserver
    /// </code>
    /// </dt>
    /// <dd>
    /// The observer is not a valid AXObserverRef type.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorIllegalArgument
    /// </code>
    /// </dt>
    /// <dd>
    /// One or more of the arguments is an illegal value or the length of the notification name is greater than 1024.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotificationUnsupported
    /// </code>
    /// </dt>
    /// <dd>
    /// The accessibility object does not support notifications (note that the system-wide accessibility object does not support notifications).
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorNotificationNotRegistered
    /// </code>
    /// </dt>
    /// <dd>
    /// This observer has not registered for any notifications.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorCannotComplete
    /// </code>
    /// </dt>
    /// <dd>
    /// The function cannot complete because messaging has failed in some way.
    /// </dd>
    /// <dt>
    /// <code>
    /// kAXErrorFailure
    /// </code>
    /// </dt>
    /// <dd>
    /// There is some sort of system memory failure.
    /// </dd>
    /// </dl>
    #[doc(alias = "AXObserverRemoveNotification")]
    #[cfg(feature = "AXError")]
    #[inline]
    pub unsafe fn remove_notification(
        &self,
        element: &AXUIElement,
        notification: &CFString,
    ) -> AXError {
        extern "C-unwind" {
            fn AXObserverRemoveNotification(
                observer: &AXObserver,
                element: &AXUIElement,
                notification: &CFString,
            ) -> AXError;
        }
        unsafe { AXObserverRemoveNotification(self, element, notification) }
    }

    /// Returns the observer's run loop source.
    ///
    /// The observer must be added to a run loop before it can receive notifications. Note that releasing the AXObserverRef automatically
    /// removes the run loop source from the run loop (you can also do this explicitly by calling
    ///
    /// ```text
    ///  //apple_ref/c/func/CFRunLoopRemoveSource CFRunLoopRemoveSource
    /// ```
    ///
    /// ).
    ///
    /// <code>
    /// AXObserverGetRunLoopSource
    /// </code>
    /// might be used in code in this way:
    ///
    /// <pre>
    /// CFRunLoopAddSource(CFRunLoopGetCurrent(), AXObserverGetRunLoopSource(observer), kCFRunLoopDefaultMode);
    /// </pre>
    ///
    ///
    /// Parameter `observer`: The observer object (created from a call to
    ///
    /// ```text
    ///  AXObserverCreate AXObserverCreate
    /// ```
    ///
    /// ) for which to get the run loop source.
    ///
    /// Returns: Returns the CFRunLoopSourceRef of the observer; NIL if you pass NIL in
    /// <code>
    /// observer
    /// </code>
    /// .
    #[doc(alias = "AXObserverGetRunLoopSource")]
    #[inline]
    pub unsafe fn run_loop_source(&self) -> CFRetained<CFRunLoopSource> {
        extern "C-unwind" {
            fn AXObserverGetRunLoopSource(
                observer: &AXObserver,
            ) -> Option<NonNull<CFRunLoopSource>>;
        }
        let ret = unsafe { AXObserverGetRunLoopSource(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::copy_attribute_names`"]
    pub fn AXUIElementCopyAttributeNames(
        element: &AXUIElement,
        names: NonNull<*const CFArray>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::copy_attribute_value`"]
    pub fn AXUIElementCopyAttributeValue(
        element: &AXUIElement,
        attribute: &CFString,
        value: NonNull<*const CFType>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::attribute_value_count`"]
    pub fn AXUIElementGetAttributeValueCount(
        element: &AXUIElement,
        attribute: &CFString,
        count: NonNull<CFIndex>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::copy_attribute_values`"]
    pub fn AXUIElementCopyAttributeValues(
        element: &AXUIElement,
        attribute: &CFString,
        index: CFIndex,
        max_values: CFIndex,
        values: NonNull<*const CFArray>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::is_attribute_settable`"]
    pub fn AXUIElementIsAttributeSettable(
        element: &AXUIElement,
        attribute: &CFString,
        settable: NonNull<Boolean>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::set_attribute_value`"]
    pub fn AXUIElementSetAttributeValue(
        element: &AXUIElement,
        attribute: &CFString,
        value: &CFType,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::copy_multiple_attribute_values`"]
    pub fn AXUIElementCopyMultipleAttributeValues(
        element: &AXUIElement,
        attributes: &CFArray,
        options: AXCopyMultipleAttributeOptions,
        values: NonNull<*const CFArray>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::copy_parameterized_attribute_names`"]
    pub fn AXUIElementCopyParameterizedAttributeNames(
        element: &AXUIElement,
        names: NonNull<*const CFArray>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::copy_parameterized_attribute_value`"]
    pub fn AXUIElementCopyParameterizedAttributeValue(
        element: &AXUIElement,
        parameterized_attribute: &CFString,
        parameter: &CFType,
        result: NonNull<*const CFType>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::copy_action_names`"]
    pub fn AXUIElementCopyActionNames(
        element: &AXUIElement,
        names: NonNull<*const CFArray>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::copy_action_description`"]
    pub fn AXUIElementCopyActionDescription(
        element: &AXUIElement,
        action: &CFString,
        description: NonNull<*const CFString>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::perform_action`"]
    pub fn AXUIElementPerformAction(element: &AXUIElement, action: &CFString) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::copy_element_at_position`"]
    pub fn AXUIElementCopyElementAtPosition(
        application: &AXUIElement,
        x: c_float,
        y: c_float,
        element: NonNull<*const AXUIElement>,
    ) -> AXError;
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `AXUIElement::new_application`"]
#[inline]
pub unsafe extern "C-unwind" fn AXUIElementCreateApplication(
    pid: libc::pid_t,
) -> CFRetained<AXUIElement> {
    extern "C-unwind" {
        fn AXUIElementCreateApplication(pid: libc::pid_t) -> Option<NonNull<AXUIElement>>;
    }
    let ret = unsafe { AXUIElementCreateApplication(pid) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `AXUIElement::new_system_wide`"]
#[inline]
pub unsafe extern "C-unwind" fn AXUIElementCreateSystemWide() -> CFRetained<AXUIElement> {
    extern "C-unwind" {
        fn AXUIElementCreateSystemWide() -> Option<NonNull<AXUIElement>>;
    }
    let ret = unsafe { AXUIElementCreateSystemWide() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[cfg(all(feature = "AXError", feature = "libc"))]
    #[deprecated = "renamed to `AXUIElement::pid`"]
    pub fn AXUIElementGetPid(element: &AXUIElement, pid: NonNull<libc::pid_t>) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXUIElement::set_messaging_timeout`"]
    pub fn AXUIElementSetMessagingTimeout(
        element: &AXUIElement,
        timeout_in_seconds: c_float,
    ) -> AXError;
}

#[cfg(all(feature = "AXError", feature = "objc2-core-graphics"))]
#[deprecated = "renamed to `AXUIElement::post_keyboard_event`"]
#[inline]
pub unsafe extern "C-unwind" fn AXUIElementPostKeyboardEvent(
    application: &AXUIElement,
    key_char: CGCharCode,
    virtual_key: CGKeyCode,
    key_down: bool,
) -> AXError {
    extern "C-unwind" {
        fn AXUIElementPostKeyboardEvent(
            application: &AXUIElement,
            key_char: CGCharCode,
            virtual_key: CGKeyCode,
            key_down: Boolean,
        ) -> AXError;
    }
    unsafe { AXUIElementPostKeyboardEvent(application, key_char, virtual_key, key_down as _) }
}

#[deprecated = "renamed to `AXTextMarker::new`"]
#[inline]
pub unsafe extern "C-unwind" fn AXTextMarkerCreate(
    allocator: Option<&CFAllocator>,
    bytes: NonNull<u8>,
    length: CFIndex,
) -> CFRetained<AXTextMarker> {
    extern "C-unwind" {
        fn AXTextMarkerCreate(
            allocator: Option<&CFAllocator>,
            bytes: NonNull<u8>,
            length: CFIndex,
        ) -> Option<NonNull<AXTextMarker>>;
    }
    let ret = unsafe { AXTextMarkerCreate(allocator, bytes, length) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `AXTextMarker::length`"]
    pub fn AXTextMarkerGetLength(marker: &AXTextMarker) -> CFIndex;
}

#[deprecated = "renamed to `AXTextMarker::byte_ptr`"]
#[inline]
pub unsafe extern "C-unwind" fn AXTextMarkerGetBytePtr(
    the_text_marker: &AXTextMarker,
) -> NonNull<u8> {
    extern "C-unwind" {
        fn AXTextMarkerGetBytePtr(the_text_marker: &AXTextMarker) -> Option<NonNull<u8>>;
    }
    let ret = unsafe { AXTextMarkerGetBytePtr(the_text_marker) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `AXTextMarkerRange::new`"]
#[inline]
pub unsafe extern "C-unwind" fn AXTextMarkerRangeCreate(
    allocator: Option<&CFAllocator>,
    start_marker: &AXTextMarker,
    end_marker: &AXTextMarker,
) -> CFRetained<AXTextMarkerRange> {
    extern "C-unwind" {
        fn AXTextMarkerRangeCreate(
            allocator: Option<&CFAllocator>,
            start_marker: &AXTextMarker,
            end_marker: &AXTextMarker,
        ) -> Option<NonNull<AXTextMarkerRange>>;
    }
    let ret = unsafe { AXTextMarkerRangeCreate(allocator, start_marker, end_marker) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `AXTextMarkerRange::with_bytes`"]
#[inline]
pub unsafe extern "C-unwind" fn AXTextMarkerRangeCreateWithBytes(
    allocator: Option<&CFAllocator>,
    start_marker_bytes: NonNull<u8>,
    start_marker_length: CFIndex,
    end_marker_bytes: NonNull<u8>,
    end_marker_length: CFIndex,
) -> CFRetained<AXTextMarkerRange> {
    extern "C-unwind" {
        fn AXTextMarkerRangeCreateWithBytes(
            allocator: Option<&CFAllocator>,
            start_marker_bytes: NonNull<u8>,
            start_marker_length: CFIndex,
            end_marker_bytes: NonNull<u8>,
            end_marker_length: CFIndex,
        ) -> Option<NonNull<AXTextMarkerRange>>;
    }
    let ret = unsafe {
        AXTextMarkerRangeCreateWithBytes(
            allocator,
            start_marker_bytes,
            start_marker_length,
            end_marker_bytes,
            end_marker_length,
        )
    };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `AXTextMarkerRange::start_marker`"]
#[inline]
pub unsafe extern "C-unwind" fn AXTextMarkerRangeCopyStartMarker(
    text_marker_range: &AXTextMarkerRange,
) -> CFRetained<AXTextMarker> {
    extern "C-unwind" {
        fn AXTextMarkerRangeCopyStartMarker(
            text_marker_range: &AXTextMarkerRange,
        ) -> Option<NonNull<AXTextMarker>>;
    }
    let ret = unsafe { AXTextMarkerRangeCopyStartMarker(text_marker_range) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `AXTextMarkerRange::end_marker`"]
#[inline]
pub unsafe extern "C-unwind" fn AXTextMarkerRangeCopyEndMarker(
    text_marker_range: &AXTextMarkerRange,
) -> CFRetained<AXTextMarker> {
    extern "C-unwind" {
        fn AXTextMarkerRangeCopyEndMarker(
            text_marker_range: &AXTextMarkerRange,
        ) -> Option<NonNull<AXTextMarker>>;
    }
    let ret = unsafe { AXTextMarkerRangeCopyEndMarker(text_marker_range) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[cfg(all(feature = "AXError", feature = "libc"))]
    #[deprecated = "renamed to `AXObserver::create`"]
    pub fn AXObserverCreate(
        application: libc::pid_t,
        callback: AXObserverCallback,
        out_observer: NonNull<*mut AXObserver>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(all(feature = "AXError", feature = "libc"))]
    #[deprecated = "renamed to `AXObserver::create_with_info_callback`"]
    pub fn AXObserverCreateWithInfoCallback(
        application: libc::pid_t,
        callback: AXObserverCallbackWithInfo,
        out_observer: NonNull<*mut AXObserver>,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXObserver::add_notification`"]
    pub fn AXObserverAddNotification(
        observer: &AXObserver,
        element: &AXUIElement,
        notification: &CFString,
        refcon: *mut c_void,
    ) -> AXError;
}

extern "C-unwind" {
    #[cfg(feature = "AXError")]
    #[deprecated = "renamed to `AXObserver::remove_notification`"]
    pub fn AXObserverRemoveNotification(
        observer: &AXObserver,
        element: &AXUIElement,
        notification: &CFString,
    ) -> AXError;
}

#[deprecated = "renamed to `AXObserver::run_loop_source`"]
#[inline]
pub unsafe extern "C-unwind" fn AXObserverGetRunLoopSource(
    observer: &AXObserver,
) -> CFRetained<CFRunLoopSource> {
    extern "C-unwind" {
        fn AXObserverGetRunLoopSource(observer: &AXObserver) -> Option<NonNull<CFRunLoopSource>>;
    }
    let ret = unsafe { AXObserverGetRunLoopSource(observer) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}
