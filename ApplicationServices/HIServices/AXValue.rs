//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// These are AXValueType wrappers for other structures. You must use the AXValueCreate
/// and AXValueGetValue functions to convert between the wrapped structure and the native structure.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/applicationservices/axvaluetype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct AXValueType(pub u32);
impl AXValueType {
    #[doc(alias = "kAXValueTypeCGPoint")]
    pub const CGPoint: Self = Self(1);
    #[doc(alias = "kAXValueTypeCGSize")]
    pub const CGSize: Self = Self(2);
    #[doc(alias = "kAXValueTypeCGRect")]
    pub const CGRect: Self = Self(3);
    #[doc(alias = "kAXValueTypeCFRange")]
    pub const CFRange: Self = Self(4);
    #[doc(alias = "kAXValueTypeAXError")]
    pub const AXError: Self = Self(5);
    #[doc(alias = "kAXValueTypeIllegal")]
    pub const Illegal: Self = Self(0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for AXValueType {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for AXValueType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/applicationservices/kaxvaluecgpointtype?language=objc)
pub static kAXValueCGPointType: u32 = AXValueType::CGPoint.0;

/// [Apple's documentation](https://developer.apple.com/documentation/applicationservices/kaxvaluecgsizetype?language=objc)
pub static kAXValueCGSizeType: u32 = AXValueType::CGSize.0;

/// [Apple's documentation](https://developer.apple.com/documentation/applicationservices/kaxvaluecgrecttype?language=objc)
pub static kAXValueCGRectType: u32 = AXValueType::CGRect.0;

/// [Apple's documentation](https://developer.apple.com/documentation/applicationservices/kaxvaluecfrangetype?language=objc)
pub static kAXValueCFRangeType: u32 = AXValueType::CFRange.0;

/// [Apple's documentation](https://developer.apple.com/documentation/applicationservices/kaxvalueaxerrortype?language=objc)
pub static kAXValueAXErrorType: u32 = AXValueType::AXError.0;

/// [Apple's documentation](https://developer.apple.com/documentation/applicationservices/kaxvalueillegaltype?language=objc)
pub static kAXValueIllegalType: u32 = AXValueType::Illegal.0;

#[doc(alias = "AXValueRef")]
#[repr(C)]
pub struct AXValue {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl AXValue {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__AXValue"> for AXValue {}
);

unsafe impl ConcreteType for AXValue {
    /// Returns:
    /// Availability: Mac OS X version 10.3 or later
    #[doc(alias = "AXValueGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn AXValueGetTypeID() -> CFTypeID;
        }
        unsafe { AXValueGetTypeID() }
    }
}

impl AXValue {
    /// Encodes a structure pointed to by valuePtr into a CFTypeRef.
    ///
    ///
    /// Parameter `theType`:
    /// Parameter `valuePtr`:
    /// Returns:
    ///
    /// # Safety
    ///
    /// `value_ptr` must be a valid pointer.
    #[doc(alias = "AXValueCreate")]
    #[inline]
    pub unsafe fn new(
        the_type: AXValueType,
        value_ptr: NonNull<c_void>,
    ) -> Option<CFRetained<AXValue>> {
        extern "C-unwind" {
            fn AXValueCreate(
                the_type: AXValueType,
                value_ptr: NonNull<c_void>,
            ) -> Option<NonNull<AXValue>>;
        }
        let ret = unsafe { AXValueCreate(the_type, value_ptr) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the structure type encoded in value. If the type is not recognized, it returns kAXValueIllegalType.
    ///
    ///
    /// Parameter `value`:
    /// Returns:
    #[doc(alias = "AXValueGetType")]
    #[inline]
    pub unsafe fn r#type(&self) -> AXValueType {
        extern "C-unwind" {
            fn AXValueGetType(value: &AXValue) -> AXValueType;
        }
        unsafe { AXValueGetType(self) }
    }

    /// Decodes the structure stored in value and copies it into valuePtr. If the structure stored in value is not
    /// the same as requested by theType, the function returns false.
    ///
    ///
    /// Parameter `value`:
    /// Returns:
    ///
    /// # Safety
    ///
    /// `value_ptr` must be a valid pointer.
    #[doc(alias = "AXValueGetValue")]
    #[inline]
    pub unsafe fn value(&self, the_type: AXValueType, value_ptr: NonNull<c_void>) -> bool {
        extern "C-unwind" {
            fn AXValueGetValue(
                value: &AXValue,
                the_type: AXValueType,
                value_ptr: NonNull<c_void>,
            ) -> Boolean;
        }
        let ret = unsafe { AXValueGetValue(self, the_type, value_ptr) };
        ret != 0
    }
}

#[deprecated = "renamed to `AXValue::new`"]
#[inline]
pub unsafe extern "C-unwind" fn AXValueCreate(
    the_type: AXValueType,
    value_ptr: NonNull<c_void>,
) -> Option<CFRetained<AXValue>> {
    extern "C-unwind" {
        fn AXValueCreate(
            the_type: AXValueType,
            value_ptr: NonNull<c_void>,
        ) -> Option<NonNull<AXValue>>;
    }
    let ret = unsafe { AXValueCreate(the_type, value_ptr) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `AXValue::type`"]
    pub fn AXValueGetType(value: &AXValue) -> AXValueType;
}

#[deprecated = "renamed to `AXValue::value`"]
#[inline]
pub unsafe extern "C-unwind" fn AXValueGetValue(
    value: &AXValue,
    the_type: AXValueType,
    value_ptr: NonNull<c_void>,
) -> bool {
    extern "C-unwind" {
        fn AXValueGetValue(
            value: &AXValue,
            the_type: AXValueType,
            value_ptr: NonNull<c_void>,
        ) -> Boolean;
    }
    let ret = unsafe { AXValueGetValue(value, the_type, value_ptr) };
    ret != 0
}
