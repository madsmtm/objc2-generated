//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "CSIdentity")]
unsafe impl ConcreteType for CSIdentityQuery {
    #[doc(alias = "CSIdentityQueryGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CSIdentityQueryGetTypeID() -> CFTypeID;
        }
        unsafe { CSIdentityQueryGetTypeID() }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityquerygenerateupdateevents?language=objc)
pub const kCSIdentityQueryGenerateUpdateEvents: c_uint = 0x0001;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityqueryincludehiddenidentities?language=objc)
pub const kCSIdentityQueryIncludeHiddenIdentities: c_uint = 0x0002;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentityqueryflags?language=objc)
pub type CSIdentityQueryFlags = CFOptionFlags;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityquerystringequals?language=objc)
pub const kCSIdentityQueryStringEquals: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityquerystringbeginswith?language=objc)
pub const kCSIdentityQueryStringBeginsWith: c_uint = 2;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentityquerystringcomparisonmethod?language=objc)
pub type CSIdentityQueryStringComparisonMethod = CFIndex;

#[cfg(feature = "CSIdentity")]
impl CSIdentityQuery {
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `authority` might not allow `None`.
    #[doc(alias = "CSIdentityQueryCreate")]
    #[cfg(all(feature = "CSIdentity", feature = "CSIdentityAuthority"))]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        identity_class: CSIdentityClass,
        authority: Option<&CSIdentityAuthority>,
    ) -> Option<CFRetained<CSIdentityQuery>> {
        extern "C-unwind" {
            fn CSIdentityQueryCreate(
                allocator: Option<&CFAllocator>,
                identity_class: CSIdentityClass,
                authority: Option<&CSIdentityAuthority>,
            ) -> Option<NonNull<CSIdentityQuery>>;
        }
        let ret = unsafe { CSIdentityQueryCreate(allocator, identity_class, authority) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `name` might not allow `None`.
    /// - `authority` might not allow `None`.
    #[doc(alias = "CSIdentityQueryCreateForName")]
    #[cfg(all(feature = "CSIdentity", feature = "CSIdentityAuthority"))]
    #[inline]
    pub unsafe fn new_for_name(
        allocator: Option<&CFAllocator>,
        name: Option<&CFString>,
        comparison_method: CSIdentityQueryStringComparisonMethod,
        identity_class: CSIdentityClass,
        authority: Option<&CSIdentityAuthority>,
    ) -> Option<CFRetained<CSIdentityQuery>> {
        extern "C-unwind" {
            fn CSIdentityQueryCreateForName(
                allocator: Option<&CFAllocator>,
                name: Option<&CFString>,
                comparison_method: CSIdentityQueryStringComparisonMethod,
                identity_class: CSIdentityClass,
                authority: Option<&CSIdentityAuthority>,
            ) -> Option<NonNull<CSIdentityQuery>>;
        }
        let ret = unsafe {
            CSIdentityQueryCreateForName(
                allocator,
                name,
                comparison_method,
                identity_class,
                authority,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `uuid` might not allow `None`.
    /// - `authority` might not allow `None`.
    #[doc(alias = "CSIdentityQueryCreateForUUID")]
    #[cfg(all(feature = "CSIdentity", feature = "CSIdentityAuthority"))]
    #[inline]
    pub unsafe fn new_for_uuid(
        allocator: Option<&CFAllocator>,
        uuid: Option<&CFUUID>,
        authority: Option<&CSIdentityAuthority>,
    ) -> Option<CFRetained<CSIdentityQuery>> {
        extern "C-unwind" {
            fn CSIdentityQueryCreateForUUID(
                allocator: Option<&CFAllocator>,
                uuid: Option<&CFUUID>,
                authority: Option<&CSIdentityAuthority>,
            ) -> Option<NonNull<CSIdentityQuery>>;
        }
        let ret = unsafe { CSIdentityQueryCreateForUUID(allocator, uuid, authority) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `authority` might not allow `None`.
    #[doc(alias = "CSIdentityQueryCreateForPosixID")]
    #[cfg(all(
        feature = "CSIdentity",
        feature = "CSIdentityAuthority",
        feature = "libc"
    ))]
    #[inline]
    pub unsafe fn new_for_posix_id(
        allocator: Option<&CFAllocator>,
        posix_id: libc::id_t,
        identity_class: CSIdentityClass,
        authority: Option<&CSIdentityAuthority>,
    ) -> Option<CFRetained<CSIdentityQuery>> {
        extern "C-unwind" {
            fn CSIdentityQueryCreateForPosixID(
                allocator: Option<&CFAllocator>,
                posix_id: libc::id_t,
                identity_class: CSIdentityClass,
                authority: Option<&CSIdentityAuthority>,
            ) -> Option<NonNull<CSIdentityQuery>>;
        }
        let ret = unsafe {
            CSIdentityQueryCreateForPosixID(allocator, posix_id, identity_class, authority)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `reference_data` might not allow `None`.
    #[doc(alias = "CSIdentityQueryCreateForPersistentReference")]
    #[cfg(feature = "CSIdentity")]
    #[inline]
    pub unsafe fn new_for_persistent_reference(
        allocator: Option<&CFAllocator>,
        reference_data: Option<&CFData>,
    ) -> Option<CFRetained<CSIdentityQuery>> {
        extern "C-unwind" {
            fn CSIdentityQueryCreateForPersistentReference(
                allocator: Option<&CFAllocator>,
                reference_data: Option<&CFData>,
            ) -> Option<NonNull<CSIdentityQuery>>;
        }
        let ret = unsafe { CSIdentityQueryCreateForPersistentReference(allocator, reference_data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `allocator` might not allow `None`.
    #[doc(alias = "CSIdentityQueryCreateForCurrentUser")]
    #[cfg(feature = "CSIdentity")]
    #[inline]
    pub unsafe fn new_for_current_user(
        allocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CSIdentityQuery>> {
        extern "C-unwind" {
            fn CSIdentityQueryCreateForCurrentUser(
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CSIdentityQuery>>;
        }
        let ret = unsafe { CSIdentityQueryCreateForCurrentUser(allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CSIdentityQueryCopyResults")]
    #[cfg(feature = "CSIdentity")]
    #[inline]
    pub unsafe fn results(&self) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CSIdentityQueryCopyResults(query: &CSIdentityQuery) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CSIdentityQueryCopyResults(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `error` must be a valid pointer.
    #[doc(alias = "CSIdentityQueryExecute")]
    #[cfg(feature = "CSIdentity")]
    #[inline]
    pub unsafe fn execute(&self, flags: CSIdentityQueryFlags, error: *mut *mut CFError) -> bool {
        extern "C-unwind" {
            fn CSIdentityQueryExecute(
                query: &CSIdentityQuery,
                flags: CSIdentityQueryFlags,
                error: *mut *mut CFError,
            ) -> Boolean;
        }
        let ret = unsafe { CSIdentityQueryExecute(self, flags, error) };
        ret != 0
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityqueryeventsearchphasefinished?language=objc)
pub const kCSIdentityQueryEventSearchPhaseFinished: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityqueryeventresultsadded?language=objc)
pub const kCSIdentityQueryEventResultsAdded: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityqueryeventresultschanged?language=objc)
pub const kCSIdentityQueryEventResultsChanged: c_uint = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityqueryeventresultsremoved?language=objc)
pub const kCSIdentityQueryEventResultsRemoved: c_uint = 4;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcsidentityqueryeventerroroccurred?language=objc)
pub const kCSIdentityQueryEventErrorOccurred: c_uint = 5;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentityqueryevent?language=objc)
pub type CSIdentityQueryEvent = CFIndex;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentityqueryreceiveeventcallback?language=objc)
#[cfg(feature = "CSIdentity")]
pub type CSIdentityQueryReceiveEventCallback = Option<
    unsafe extern "C-unwind" fn(
        *mut CSIdentityQuery,
        CSIdentityQueryEvent,
        *const CFArray,
        *mut CFError,
        *mut c_void,
    ),
>;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/csidentityqueryclientcontext?language=objc)
#[cfg(feature = "CSIdentity")]
#[repr(C, packed(2))]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CSIdentityQueryClientContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retainInfo: CFAllocatorRetainCallBack,
    pub releaseInfo: CFAllocatorReleaseCallBack,
    pub copyInfoDescription: CFAllocatorCopyDescriptionCallBack,
    pub receiveEvent: CSIdentityQueryReceiveEventCallback,
}

#[cfg(all(feature = "CSIdentity", feature = "objc2"))]
unsafe impl Encode for CSIdentityQueryClientContext {
    const ENCODING: Encoding = Encoding::Struct(
        "CSIdentityQueryClientContext",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <CFAllocatorRetainCallBack>::ENCODING,
            <CFAllocatorReleaseCallBack>::ENCODING,
            <CFAllocatorCopyDescriptionCallBack>::ENCODING,
            <CSIdentityQueryReceiveEventCallback>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CSIdentity", feature = "objc2"))]
unsafe impl RefEncode for CSIdentityQueryClientContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "CSIdentity")]
impl CSIdentityQuery {
    /// # Safety
    ///
    /// - `client_context` must be a valid pointer.
    /// - `run_loop` possibly has additional threading requirements.
    /// - `run_loop` might not allow `None`.
    /// - `run_loop_mode` might not allow `None`.
    #[doc(alias = "CSIdentityQueryExecuteAsynchronously")]
    #[cfg(feature = "CSIdentity")]
    #[inline]
    pub unsafe fn execute_asynchronously(
        &self,
        flags: CSIdentityQueryFlags,
        client_context: *const CSIdentityQueryClientContext,
        run_loop: Option<&CFRunLoop>,
        run_loop_mode: Option<&CFString>,
    ) -> bool {
        extern "C-unwind" {
            fn CSIdentityQueryExecuteAsynchronously(
                query: &CSIdentityQuery,
                flags: CSIdentityQueryFlags,
                client_context: *const CSIdentityQueryClientContext,
                run_loop: Option<&CFRunLoop>,
                run_loop_mode: Option<&CFString>,
            ) -> Boolean;
        }
        let ret = unsafe {
            CSIdentityQueryExecuteAsynchronously(
                self,
                flags,
                client_context,
                run_loop,
                run_loop_mode,
            )
        };
        ret != 0
    }

    #[doc(alias = "CSIdentityQueryStop")]
    #[cfg(feature = "CSIdentity")]
    #[inline]
    pub unsafe fn stop(&self) {
        extern "C-unwind" {
            fn CSIdentityQueryStop(query: &CSIdentityQuery);
        }
        unsafe { CSIdentityQueryStop(self) }
    }
}

#[cfg(all(feature = "CSIdentity", feature = "CSIdentityAuthority"))]
#[deprecated = "renamed to `CSIdentityQuery::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityQueryCreate(
    allocator: Option<&CFAllocator>,
    identity_class: CSIdentityClass,
    authority: Option<&CSIdentityAuthority>,
) -> Option<CFRetained<CSIdentityQuery>> {
    extern "C-unwind" {
        fn CSIdentityQueryCreate(
            allocator: Option<&CFAllocator>,
            identity_class: CSIdentityClass,
            authority: Option<&CSIdentityAuthority>,
        ) -> Option<NonNull<CSIdentityQuery>>;
    }
    let ret = unsafe { CSIdentityQueryCreate(allocator, identity_class, authority) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CSIdentity", feature = "CSIdentityAuthority"))]
#[deprecated = "renamed to `CSIdentityQuery::new_for_name`"]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityQueryCreateForName(
    allocator: Option<&CFAllocator>,
    name: Option<&CFString>,
    comparison_method: CSIdentityQueryStringComparisonMethod,
    identity_class: CSIdentityClass,
    authority: Option<&CSIdentityAuthority>,
) -> Option<CFRetained<CSIdentityQuery>> {
    extern "C-unwind" {
        fn CSIdentityQueryCreateForName(
            allocator: Option<&CFAllocator>,
            name: Option<&CFString>,
            comparison_method: CSIdentityQueryStringComparisonMethod,
            identity_class: CSIdentityClass,
            authority: Option<&CSIdentityAuthority>,
        ) -> Option<NonNull<CSIdentityQuery>>;
    }
    let ret = unsafe {
        CSIdentityQueryCreateForName(
            allocator,
            name,
            comparison_method,
            identity_class,
            authority,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "CSIdentity", feature = "CSIdentityAuthority"))]
#[deprecated = "renamed to `CSIdentityQuery::new_for_uuid`"]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityQueryCreateForUUID(
    allocator: Option<&CFAllocator>,
    uuid: Option<&CFUUID>,
    authority: Option<&CSIdentityAuthority>,
) -> Option<CFRetained<CSIdentityQuery>> {
    extern "C-unwind" {
        fn CSIdentityQueryCreateForUUID(
            allocator: Option<&CFAllocator>,
            uuid: Option<&CFUUID>,
            authority: Option<&CSIdentityAuthority>,
        ) -> Option<NonNull<CSIdentityQuery>>;
    }
    let ret = unsafe { CSIdentityQueryCreateForUUID(allocator, uuid, authority) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(
    feature = "CSIdentity",
    feature = "CSIdentityAuthority",
    feature = "libc"
))]
#[deprecated = "renamed to `CSIdentityQuery::new_for_posix_id`"]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityQueryCreateForPosixID(
    allocator: Option<&CFAllocator>,
    posix_id: libc::id_t,
    identity_class: CSIdentityClass,
    authority: Option<&CSIdentityAuthority>,
) -> Option<CFRetained<CSIdentityQuery>> {
    extern "C-unwind" {
        fn CSIdentityQueryCreateForPosixID(
            allocator: Option<&CFAllocator>,
            posix_id: libc::id_t,
            identity_class: CSIdentityClass,
            authority: Option<&CSIdentityAuthority>,
        ) -> Option<NonNull<CSIdentityQuery>>;
    }
    let ret =
        unsafe { CSIdentityQueryCreateForPosixID(allocator, posix_id, identity_class, authority) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CSIdentity")]
#[deprecated = "renamed to `CSIdentityQuery::new_for_persistent_reference`"]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityQueryCreateForPersistentReference(
    allocator: Option<&CFAllocator>,
    reference_data: Option<&CFData>,
) -> Option<CFRetained<CSIdentityQuery>> {
    extern "C-unwind" {
        fn CSIdentityQueryCreateForPersistentReference(
            allocator: Option<&CFAllocator>,
            reference_data: Option<&CFData>,
        ) -> Option<NonNull<CSIdentityQuery>>;
    }
    let ret = unsafe { CSIdentityQueryCreateForPersistentReference(allocator, reference_data) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CSIdentity")]
#[deprecated = "renamed to `CSIdentityQuery::new_for_current_user`"]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityQueryCreateForCurrentUser(
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CSIdentityQuery>> {
    extern "C-unwind" {
        fn CSIdentityQueryCreateForCurrentUser(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CSIdentityQuery>>;
    }
    let ret = unsafe { CSIdentityQueryCreateForCurrentUser(allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CSIdentity")]
#[deprecated = "renamed to `CSIdentityQuery::results`"]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityQueryCopyResults(
    query: &CSIdentityQuery,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CSIdentityQueryCopyResults(query: &CSIdentityQuery) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CSIdentityQueryCopyResults(query) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CSIdentity")]
#[deprecated = "renamed to `CSIdentityQuery::execute`"]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityQueryExecute(
    query: &CSIdentityQuery,
    flags: CSIdentityQueryFlags,
    error: *mut *mut CFError,
) -> bool {
    extern "C-unwind" {
        fn CSIdentityQueryExecute(
            query: &CSIdentityQuery,
            flags: CSIdentityQueryFlags,
            error: *mut *mut CFError,
        ) -> Boolean;
    }
    let ret = unsafe { CSIdentityQueryExecute(query, flags, error) };
    ret != 0
}

#[cfg(feature = "CSIdentity")]
#[deprecated = "renamed to `CSIdentityQuery::execute_asynchronously`"]
#[inline]
pub unsafe extern "C-unwind" fn CSIdentityQueryExecuteAsynchronously(
    query: &CSIdentityQuery,
    flags: CSIdentityQueryFlags,
    client_context: *const CSIdentityQueryClientContext,
    run_loop: Option<&CFRunLoop>,
    run_loop_mode: Option<&CFString>,
) -> bool {
    extern "C-unwind" {
        fn CSIdentityQueryExecuteAsynchronously(
            query: &CSIdentityQuery,
            flags: CSIdentityQueryFlags,
            client_context: *const CSIdentityQueryClientContext,
            run_loop: Option<&CFRunLoop>,
            run_loop_mode: Option<&CFString>,
        ) -> Boolean;
    }
    let ret = unsafe {
        CSIdentityQueryExecuteAsynchronously(query, flags, client_context, run_loop, run_loop_mode)
    };
    ret != 0
}

extern "C-unwind" {
    #[cfg(feature = "CSIdentity")]
    #[deprecated = "renamed to `CSIdentityQuery::stop`"]
    pub fn CSIdentityQueryStop(query: &CSIdentityQuery);
}
