//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/wsprotocolhandler?language=objc)
#[doc(alias = "WSProtocolHandlerRef")]
#[repr(C)]
pub struct WSProtocolHandler {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl WSProtocolHandler {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueWSProtocolHandlerRef"> for WSProtocolHandler {}
);

unsafe impl ConcreteType for WSProtocolHandler {
    #[doc(alias = "WSProtocolHandlerGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn WSProtocolHandlerGetTypeID() -> CFTypeID;
        }
        unsafe { WSProtocolHandlerGetTypeID() }
    }
}

impl WSProtocolHandler {
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `protocol` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCreate")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        protocol: Option<&CFString>,
    ) -> Option<CFRetained<WSProtocolHandler>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCreate(
                allocator: Option<&CFAllocator>,
                protocol: Option<&CFString>,
            ) -> Option<NonNull<WSProtocolHandler>>;
        }
        let ret = unsafe { WSProtocolHandlerCreate(allocator, protocol) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `data` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyRequestDictionary")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn request_dictionary(
        &self,
        data: Option<&CFData>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyRequestDictionary(
                r#ref: &WSProtocolHandler,
                data: Option<&CFData>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyRequestDictionary(self, data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `method_name` might not allow `None`.
    /// - `data` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyReplyDictionary")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn reply_dictionary(
        &self,
        method_name: Option<&CFString>,
        data: Option<&CFData>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyReplyDictionary(
                r#ref: &WSProtocolHandler,
                method_name: Option<&CFString>,
                data: Option<&CFData>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyReplyDictionary(self, method_name, data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `method_context` generic must be of the correct type.
    /// - `method_context` generic must be of the correct type.
    /// - `method_context` might not allow `None`.
    /// - `result_value` should be of the correct type.
    /// - `result_value` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyReplyDocument")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn reply_document(
        &self,
        method_context: Option<&CFDictionary>,
        result_value: Option<&CFType>,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyReplyDocument(
                r#ref: &WSProtocolHandler,
                method_context: Option<&CFDictionary>,
                result_value: Option<&CFType>,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyReplyDocument(self, method_context, result_value) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `method_context` generic must be of the correct type.
    /// - `method_context` generic must be of the correct type.
    /// - `method_context` might not allow `None`.
    /// - `fault_dict` generic must be of the correct type.
    /// - `fault_dict` generic must be of the correct type.
    /// - `fault_dict` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyFaultDocument")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn fault_document(
        &self,
        method_context: Option<&CFDictionary>,
        fault_dict: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyFaultDocument(
                r#ref: &WSProtocolHandler,
                method_context: Option<&CFDictionary>,
                fault_dict: Option<&CFDictionary>,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyFaultDocument(self, method_context, fault_dict) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `method_name` might not allow `None`.
    /// - `method_params` generic must be of the correct type.
    /// - `method_params` generic must be of the correct type.
    /// - `method_params` might not allow `None`.
    /// - `method_param_order` generic must be of the correct type.
    /// - `method_param_order` might not allow `None`.
    /// - `method_extras` generic must be of the correct type.
    /// - `method_extras` generic must be of the correct type.
    /// - `method_extras` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyRequestDocument")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn request_document(
        &self,
        method_name: Option<&CFString>,
        method_params: Option<&CFDictionary>,
        method_param_order: Option<&CFArray>,
        method_extras: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyRequestDocument(
                r#ref: &WSProtocolHandler,
                method_name: Option<&CFString>,
                method_params: Option<&CFDictionary>,
                method_param_order: Option<&CFArray>,
                method_extras: Option<&CFDictionary>,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe {
            WSProtocolHandlerCopyRequestDocument(
                self,
                method_name,
                method_params,
                method_param_order,
                method_extras,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `property_name` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyProperty")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn property(&self, property_name: Option<&CFString>) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyProperty(
                r#ref: &WSProtocolHandler,
                property_name: Option<&CFString>,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyProperty(self, property_name) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `property_name` might not allow `None`.
    /// - `property_value` should be of the correct type.
    /// - `property_value` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerSetProperty")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn set_property(
        &self,
        property_name: Option<&CFString>,
        property_value: Option<&CFType>,
    ) {
        extern "C-unwind" {
            fn WSProtocolHandlerSetProperty(
                r#ref: &WSProtocolHandler,
                property_name: Option<&CFString>,
                property_value: Option<&CFType>,
            );
        }
        unsafe { WSProtocolHandlerSetProperty(self, property_name, property_value) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/wsprotocolhandlerserializationprocptr?language=objc)
pub type WSProtocolHandlerSerializationProcPtr = Option<
    unsafe extern "C-unwind" fn(
        *mut WSProtocolHandler,
        *const CFType,
        *mut c_void,
    ) -> *const CFString,
>;

impl WSProtocolHandler {
    /// # Safety
    ///
    /// - `serialization_proc` must be implemented correctly.
    /// - `context` must be a valid pointer.
    #[doc(alias = "WSProtocolHandlerSetSerializationOverride")]
    #[cfg(feature = "WSTypes")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn set_serialization_override(
        &self,
        obj_type: CFTypeID,
        serialization_proc: WSProtocolHandlerSerializationProcPtr,
        context: *mut WSClientContext,
    ) {
        extern "C-unwind" {
            fn WSProtocolHandlerSetSerializationOverride(
                protocol: &WSProtocolHandler,
                obj_type: CFTypeID,
                serialization_proc: WSProtocolHandlerSerializationProcPtr,
                context: *mut WSClientContext,
            );
        }
        unsafe {
            WSProtocolHandlerSetSerializationOverride(self, obj_type, serialization_proc, context)
        }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/wsprotocolhandlerdeserializationprocptr?language=objc)
pub type WSProtocolHandlerDeserializationProcPtr = Option<
    unsafe extern "C-unwind" fn(
        *mut WSProtocolHandler,
        *mut CFXMLTree,
        *mut CFXMLTree,
        *mut c_void,
    ) -> *const CFType,
>;

impl WSProtocolHandler {
    /// # Safety
    ///
    /// - `type_namespace` might not allow `None`.
    /// - `type_name` might not allow `None`.
    /// - `deserialization_proc` must be implemented correctly.
    /// - `context` must be a valid pointer.
    #[doc(alias = "WSProtocolHandlerSetDeserializationOverride")]
    #[cfg(feature = "WSTypes")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn set_deserialization_override(
        &self,
        type_namespace: Option<&CFString>,
        type_name: Option<&CFString>,
        deserialization_proc: WSProtocolHandlerDeserializationProcPtr,
        context: *mut WSClientContext,
    ) {
        extern "C-unwind" {
            fn WSProtocolHandlerSetDeserializationOverride(
                protocol: &WSProtocolHandler,
                type_namespace: Option<&CFString>,
                type_name: Option<&CFString>,
                deserialization_proc: WSProtocolHandlerDeserializationProcPtr,
                context: *mut WSClientContext,
            );
        }
        unsafe {
            WSProtocolHandlerSetDeserializationOverride(
                self,
                type_namespace,
                type_name,
                deserialization_proc,
                context,
            )
        }
    }
}
