//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// An opaque reference to a web services protocol handler.
///
/// ## Discussion
///
/// The `WSProtocolHandlerRef` represents an instance of a protocol handler. Create it using `WSProtocolHandlerCreate`.
///
///
#[doc(alias = "WSProtocolHandlerRef")]
#[repr(C)]
pub struct WSProtocolHandler {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl WSProtocolHandler {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueWSProtocolHandlerRef"> for WSProtocolHandler {}
);

unsafe impl ConcreteType for WSProtocolHandler {
    /// Returns a `CFTypeID` for the current `WSProtocolHandlerRef`.
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// A `CFTypeID`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Returns the `CFTypeID` of the opaque `WSProtocolHandlerRef` most recently created by `WSProtocolHandlerCreate`. `CFTypeIDs` are only valid during a particular instance of a process and should not be used as static values.
    ///
    ///
    #[doc(alias = "WSProtocolHandlerGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn WSProtocolHandlerGetTypeID() -> CFTypeID;
        }
        unsafe { WSProtocolHandlerGetTypeID() }
    }
}

impl WSProtocolHandler {
    /// Creates a `WSProtocolHandlerRef` for use in translating an XML document.
    ///
    /// Parameters:
    /// - allocator: A `CFAllocatorRef` used to allocate the protocol handler.
    ///
    /// - protocol: A constant string, defined in `WSMethodInvocation.h`, that determines the type of implementation to create (XML-RPC vs. SOAP).
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// A `WSProtocolHandlerRef`; `NULL` if a parse error occurred.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function creates a `WSProtocolHandlerRef` for use in translating an XML document. A protocol handler translates dictionaries into web services requests. It is created with a string specifying the protocol (XML-RPC or SOAP) and can be modified by setting various properties. It should be noted that the parser can be re-used for multiple parses.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `protocol` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCreate")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        protocol: Option<&CFString>,
    ) -> Option<CFRetained<WSProtocolHandler>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCreate(
                allocator: Option<&CFAllocator>,
                protocol: Option<&CFString>,
            ) -> Option<NonNull<WSProtocolHandler>>;
        }
        let ret = unsafe { WSProtocolHandlerCreate(allocator, protocol) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Parses an incoming XML document for the method name and parameters.
    ///
    /// Parameters:
    /// - ref: The protocol handler to use.
    ///
    /// - data: The XML document to parse.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// A `CFDictionary`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function parses an incoming XML document for the method name and parameters. The results are in a dictionory as `kWSMethodName` (a `CFString`), `kWSMethodParameters` (a `CFDictionary`), and `kWSMethodParameterOrder` (a `CFArray`). If a parse error occurred, `NULL` is returned. Protocol specific additions (for example, `kWSSOAPMessageHeaders`) may also be present in the dictionary. The dictionary returned also represents the context with which XML reply documents are created (see `WSProtocolHandlerCreateReply`). The caller must release the resulting dictionary. Note that the returned dictionary should be used as an input parameter for other `WSProtocol` functions that require a context dictionary parameter.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `data` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyRequestDictionary")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn request_dictionary(
        &self,
        data: Option<&CFData>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyRequestDictionary(
                r#ref: &WSProtocolHandler,
                data: Option<&CFData>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyRequestDictionary(self, data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Parses an incoming XML document as if it were the reply of a method.
    ///
    /// Parameters:
    /// - ref: A `WSProtocolHandlerRef`, as created by `WSProtocolHandlerCreate`.
    ///
    /// - methodName: The method name to treat the XML file as a result of.
    ///
    /// - data: A `CFDataRef` of the XML document to parse
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// A `CFDictionary`, as returned by `WSMethodInvocationInvoke`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Parse an incoming XML document as if it were the reply of a method.  The results are the same as the `WSMethodInvocationInvoke` response;  the reply could be a fault.  If there was a parse error, `NULL` is returned.  Protocol specific additions, such as `kWSSOAPMessageHeaders`, may also be present in the dictionary.  The caller must release the resulting dictionary.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `method_name` might not allow `None`.
    /// - `data` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyReplyDictionary")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn reply_dictionary(
        &self,
        method_name: Option<&CFString>,
        data: Option<&CFData>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyReplyDictionary(
                r#ref: &WSProtocolHandler,
                method_name: Option<&CFString>,
                data: Option<&CFData>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyReplyDictionary(self, method_name, data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a Reply XML document for a given WS ProtocolHandler and context dictionary.
    ///
    /// Parameters:
    /// - ref: The WSProtocolHandler to respond.
    ///
    /// - methodContext: The `CFDictionary` containing the context for this method call, as returned by `WSProtocolHandlerParseRequest`.
    ///
    /// - resultValue: A `CFTypeRef` representing the data to be serialized.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// A `CFDataRef` containing the XML response.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function creates a Reply XML document for a given `WSProtocolHandler` and context dictionary. Protocol specific addtions (for example, `kWSSOAPMessageHeaders`) may also be present in the dictionary.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `method_context` generic must be of the correct type.
    /// - `method_context` generic must be of the correct type.
    /// - `method_context` might not allow `None`.
    /// - `result_value` should be of the correct type.
    /// - `result_value` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyReplyDocument")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn reply_document(
        &self,
        method_context: Option<&CFDictionary>,
        result_value: Option<&CFType>,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyReplyDocument(
                r#ref: &WSProtocolHandler,
                method_context: Option<&CFDictionary>,
                result_value: Option<&CFType>,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyReplyDocument(self, method_context, result_value) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a Fault XML response for a given WSProtocolHandler and fault details dictionary.
    ///
    /// Parameters:
    /// - ref: A `WSProtocolHandlerRef`, as created by `WSProtocolHandlerCreate`.
    ///
    /// - methodContext: The CFDictionary containing the context for this method call, as returned by `WSProtocolHandlerParseRequest`.
    ///
    /// - faultDict: A `CFDictionary` containing the fault information. See `WSMethodInvocation.h` for valid keys.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// A `CFDataRef` containing the XML fault.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function creates a Fault XML response for a given `WSProtocolHandlerRef` and fault details dictionary. The fault dictionary contains one or more of `kWSFaultString`, `kWSFaultCode` or `kWSFaultExtra`, as per WSMethodInvocation.h.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `method_context` generic must be of the correct type.
    /// - `method_context` generic must be of the correct type.
    /// - `method_context` might not allow `None`.
    /// - `fault_dict` generic must be of the correct type.
    /// - `fault_dict` generic must be of the correct type.
    /// - `fault_dict` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyFaultDocument")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn fault_document(
        &self,
        method_context: Option<&CFDictionary>,
        fault_dict: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyFaultDocument(
                r#ref: &WSProtocolHandler,
                method_context: Option<&CFDictionary>,
                fault_dict: Option<&CFDictionary>,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyFaultDocument(self, method_context, fault_dict) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates an XML request for a given `WSProtocolHandler` and parameter list.
    ///
    /// Parameters:
    /// - ref: The `WSProtocolHandlerRef`.
    ///
    /// - methodName: A `CFString` of the method name to call.
    ///
    /// - methodParams: A `CFDictionary` containing the parameters to send.
    ///
    /// - methodParamOrder: A `CFArray`, which, if not `NULL`, specifies the order of the parameters in the `CFDictionary`.
    ///
    /// - methodExtras: A `CFDictionary`, which, if not `NULL`, contains additional information for the protocol (for example, `kWSSoapMessageHeaders`).
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// A `CFDataRef`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function creates an XML request for a given `WSProtocolHandler` and parameter list. This is the request sent to a server.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `method_name` might not allow `None`.
    /// - `method_params` generic must be of the correct type.
    /// - `method_params` generic must be of the correct type.
    /// - `method_params` might not allow `None`.
    /// - `method_param_order` generic must be of the correct type.
    /// - `method_param_order` might not allow `None`.
    /// - `method_extras` generic must be of the correct type.
    /// - `method_extras` generic must be of the correct type.
    /// - `method_extras` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyRequestDocument")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn request_document(
        &self,
        method_name: Option<&CFString>,
        method_params: Option<&CFDictionary>,
        method_param_order: Option<&CFArray>,
        method_extras: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyRequestDocument(
                r#ref: &WSProtocolHandler,
                method_name: Option<&CFString>,
                method_params: Option<&CFDictionary>,
                method_param_order: Option<&CFArray>,
                method_extras: Option<&CFDictionary>,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe {
            WSProtocolHandlerCopyRequestDocument(
                self,
                method_name,
                method_params,
                method_param_order,
                method_extras,
            )
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a copy of a property from a protocol handler reference.
    ///
    /// Parameters:
    /// - ref: A `WSProtocolHandlerRef`, as created by `WSProtocolHandlerCreate`.
    ///
    /// - propertyName: The name of the property to copy.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// The `CFTypeRef` value of the property, or `NULL` if the specified property does not exist.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Returns a property from a protocol handler.  If the result is `NULL`, the property doesn't exist.  Since this is a Copy call, you must release the result.
    ///
    ///
    ///
    /// # Safety
    ///
    /// `property_name` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerCopyProperty")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn property(&self, property_name: Option<&CFString>) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn WSProtocolHandlerCopyProperty(
                r#ref: &WSProtocolHandler,
                property_name: Option<&CFString>,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { WSProtocolHandlerCopyProperty(self, property_name) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sets a property in a specified protocol handler.
    ///
    /// Parameters:
    /// - ref: The protocol handler.
    ///
    /// - propertyName: The name of the property to set.
    ///
    /// - propertyValue: The value of the property to set.
    ///
    ///
    /// ## Discussion
    ///
    /// This function sets the value of a named property in a method implementation.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `property_name` might not allow `None`.
    /// - `property_value` should be of the correct type.
    /// - `property_value` might not allow `None`.
    #[doc(alias = "WSProtocolHandlerSetProperty")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn set_property(
        &self,
        property_name: Option<&CFString>,
        property_value: Option<&CFType>,
    ) {
        extern "C-unwind" {
            fn WSProtocolHandlerSetProperty(
                r#ref: &WSProtocolHandler,
                property_name: Option<&CFString>,
                property_value: Option<&CFType>,
            );
        }
        unsafe { WSProtocolHandlerSetProperty(self, property_name, property_value) }
    }
}

/// This is an optional callback that handles custom serialization of a particular data type for a protocol handler.
///
/// Parameters:
/// - protocol: The protocol handler for which this callback handles serialization.
///
/// - obj: The CFTypeRef for which this callback produces serialized XML.
///
/// - info: Private callback data.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// A `CFStringRef` containing valid XML.  The caller of this callback will release the string. If you return `NULL`, the default serializer is used.
///
///
///
/// ## Discussion
///
/// If your callback is named MySerilaizerCallback, declare it like this:
///
/// <a id="1681601"></a>
/// ### Discussion
///
/// This callback is called whenever a type to be serialized by the protocol handler has the given CFTypeID. The callback should return an XML snippet that will be understood by the server as a correct serialization for a given type.  If the callback returns `NULL`, the default serializer is used.
///
/// <div class="warning">
///
/// ### Important
/// For SOAP serializations, the parameter key (element name) is not part of the callback; it will be substituded for all occurances of "%@" in the returned string.
///
///
///
/// </div>
///
pub type WSProtocolHandlerSerializationProcPtr = Option<
    unsafe extern "C-unwind" fn(
        *mut WSProtocolHandler,
        *const CFType,
        *mut c_void,
    ) -> *const CFString,
>;

impl WSProtocolHandler {
    /// Specifies a callback which will be called to produce the XML that represents the serialization of a given type ref.
    ///
    /// Parameters:
    /// - protocol: The protocol which is to be executed.
    ///
    /// - objType: The `CFTypeID` of the object to be serialized.
    ///
    /// - serializationProc: The serialization callback that will do the work.
    ///
    /// - context: A pointer to a `WSClientContext`. The structure will be copied.
    ///
    ///
    /// ## Discussion
    ///
    /// This function specifies a callback which will be called to produce the XML that represents the serialization of a given type ref. This callback is called whenever a type has the given `CFTypeID`. The callback should return an XML snippet that will be understood by the server as a correct serialization for a given type.  If the callback returns NULL, the default serializer is used. For SOAP serializations, the parameter key (element name) is not part of the callback; it will be substituded for all occurances of "%@" in the returned string. If your callback returns `NULL`, the default serializer will be used.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `serialization_proc` must be implemented correctly.
    /// - `context` must be a valid pointer.
    #[doc(alias = "WSProtocolHandlerSetSerializationOverride")]
    #[cfg(feature = "WSTypes")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn set_serialization_override(
        &self,
        obj_type: CFTypeID,
        serialization_proc: WSProtocolHandlerSerializationProcPtr,
        context: *mut WSClientContext,
    ) {
        extern "C-unwind" {
            fn WSProtocolHandlerSetSerializationOverride(
                protocol: &WSProtocolHandler,
                obj_type: CFTypeID,
                serialization_proc: WSProtocolHandlerSerializationProcPtr,
                context: *mut WSClientContext,
            );
        }
        unsafe {
            WSProtocolHandlerSetSerializationOverride(self, obj_type, serialization_proc, context)
        }
    }
}

/// This is an optional callback that handles custom deserialization of a particular data type for a protocol handler.
///
/// Parameters:
/// - protocol: The protocol handler for which this callback handles deserialization.
///
/// - msgRoot: The root element of the XML to be deserialized.
///
/// - deserializeRoot: The tree element of the XML to be deserialized.
///
/// - info: Private callback data.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// A `CFTypeRef` representing the deserialized data. The caller will release this data. If you return `NULL`, the default deserializer is used.
///
///
///
/// ## Discussion
///
/// If your callback is named MyDeserilaizerCallback, declare it like this:
///
/// <a id="1681620"></a>
/// ### Discussion
///
/// This callback is passed a reference to the invocation currently being executed, the root of the response parse tree, the current node being deserialized, and a pointer to private data. The return result should be a valid `CFTypeRef` object (which will be released  by the caller) or `NULL` to allow the default deserializer to act. Unlike the serialization callback, which is called only for a specified data type, the deserialization callback is called for every element to be deserialized.
///
///
pub type WSProtocolHandlerDeserializationProcPtr = Option<
    unsafe extern "C-unwind" fn(
        *mut WSProtocolHandler,
        *mut CFXMLTree,
        *mut CFXMLTree,
        *mut c_void,
    ) -> *const CFType,
>;

impl WSProtocolHandler {
    /// Specifies a callback to be made when parsing an XML method response.
    ///
    /// Parameters:
    /// - protocol: The `ProtocolHandlerRef`.
    ///
    /// - typeNamespace: The fully resolved namespace for a specific type. If `NULL`, the default namespace will be used. For example, this field could be: `CFSTR("http://www.w3.org/2001/XMLSchema-instance")`.
    ///
    /// - typeName: The non-qualified type name. This parameter must not be `NULL`.
    ///
    /// - deserializationProc: A `ProcPtr` to be called to perform the deserialization.
    ///
    /// - context: A pointer to a `WSClientContext`. The structure will be copied.
    ///
    ///
    /// ## Discussion
    ///
    /// This function specifies a callback to be made when parsing an XML method response. The callback is passed a reference to the protocol element currently being executed, the root of the response parse tree, the current node being deserialized, and a pointer to private data. The return result should be a valid `CFTypeRef` object, which will be released by the caller. If the callback returns `NULL`, the default deserializer will be used.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `type_namespace` might not allow `None`.
    /// - `type_name` might not allow `None`.
    /// - `deserialization_proc` must be implemented correctly.
    /// - `context` must be a valid pointer.
    #[doc(alias = "WSProtocolHandlerSetDeserializationOverride")]
    #[cfg(feature = "WSTypes")]
    #[deprecated = "No longer supported"]
    #[inline]
    pub unsafe fn set_deserialization_override(
        &self,
        type_namespace: Option<&CFString>,
        type_name: Option<&CFString>,
        deserialization_proc: WSProtocolHandlerDeserializationProcPtr,
        context: *mut WSClientContext,
    ) {
        extern "C-unwind" {
            fn WSProtocolHandlerSetDeserializationOverride(
                protocol: &WSProtocolHandler,
                type_namespace: Option<&CFString>,
                type_name: Option<&CFString>,
                deserialization_proc: WSProtocolHandlerDeserializationProcPtr,
                context: *mut WSClientContext,
            );
        }
        unsafe {
            WSProtocolHandlerSetDeserializationOverride(
                self,
                type_namespace,
                type_name,
                deserialization_proc,
                context,
            )
        }
    }
}

#[deprecated = "renamed to `WSProtocolHandler::new`"]
#[inline]
pub unsafe extern "C-unwind" fn WSProtocolHandlerCreate(
    allocator: Option<&CFAllocator>,
    protocol: Option<&CFString>,
) -> Option<CFRetained<WSProtocolHandler>> {
    extern "C-unwind" {
        fn WSProtocolHandlerCreate(
            allocator: Option<&CFAllocator>,
            protocol: Option<&CFString>,
        ) -> Option<NonNull<WSProtocolHandler>>;
    }
    let ret = unsafe { WSProtocolHandlerCreate(allocator, protocol) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `WSProtocolHandler::request_dictionary`"]
#[inline]
pub unsafe extern "C-unwind" fn WSProtocolHandlerCopyRequestDictionary(
    r#ref: &WSProtocolHandler,
    data: Option<&CFData>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn WSProtocolHandlerCopyRequestDictionary(
            r#ref: &WSProtocolHandler,
            data: Option<&CFData>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { WSProtocolHandlerCopyRequestDictionary(r#ref, data) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `WSProtocolHandler::reply_dictionary`"]
#[inline]
pub unsafe extern "C-unwind" fn WSProtocolHandlerCopyReplyDictionary(
    r#ref: &WSProtocolHandler,
    method_name: Option<&CFString>,
    data: Option<&CFData>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn WSProtocolHandlerCopyReplyDictionary(
            r#ref: &WSProtocolHandler,
            method_name: Option<&CFString>,
            data: Option<&CFData>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { WSProtocolHandlerCopyReplyDictionary(r#ref, method_name, data) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `WSProtocolHandler::reply_document`"]
#[inline]
pub unsafe extern "C-unwind" fn WSProtocolHandlerCopyReplyDocument(
    r#ref: &WSProtocolHandler,
    method_context: Option<&CFDictionary>,
    result_value: Option<&CFType>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn WSProtocolHandlerCopyReplyDocument(
            r#ref: &WSProtocolHandler,
            method_context: Option<&CFDictionary>,
            result_value: Option<&CFType>,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { WSProtocolHandlerCopyReplyDocument(r#ref, method_context, result_value) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `WSProtocolHandler::fault_document`"]
#[inline]
pub unsafe extern "C-unwind" fn WSProtocolHandlerCopyFaultDocument(
    r#ref: &WSProtocolHandler,
    method_context: Option<&CFDictionary>,
    fault_dict: Option<&CFDictionary>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn WSProtocolHandlerCopyFaultDocument(
            r#ref: &WSProtocolHandler,
            method_context: Option<&CFDictionary>,
            fault_dict: Option<&CFDictionary>,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { WSProtocolHandlerCopyFaultDocument(r#ref, method_context, fault_dict) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `WSProtocolHandler::request_document`"]
#[inline]
pub unsafe extern "C-unwind" fn WSProtocolHandlerCopyRequestDocument(
    r#ref: &WSProtocolHandler,
    method_name: Option<&CFString>,
    method_params: Option<&CFDictionary>,
    method_param_order: Option<&CFArray>,
    method_extras: Option<&CFDictionary>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn WSProtocolHandlerCopyRequestDocument(
            r#ref: &WSProtocolHandler,
            method_name: Option<&CFString>,
            method_params: Option<&CFDictionary>,
            method_param_order: Option<&CFArray>,
            method_extras: Option<&CFDictionary>,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe {
        WSProtocolHandlerCopyRequestDocument(
            r#ref,
            method_name,
            method_params,
            method_param_order,
            method_extras,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `WSProtocolHandler::property`"]
#[inline]
pub unsafe extern "C-unwind" fn WSProtocolHandlerCopyProperty(
    r#ref: &WSProtocolHandler,
    property_name: Option<&CFString>,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn WSProtocolHandlerCopyProperty(
            r#ref: &WSProtocolHandler,
            property_name: Option<&CFString>,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { WSProtocolHandlerCopyProperty(r#ref, property_name) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `WSProtocolHandler::set_property`"]
    pub fn WSProtocolHandlerSetProperty(
        r#ref: &WSProtocolHandler,
        property_name: Option<&CFString>,
        property_value: Option<&CFType>,
    );
}

extern "C-unwind" {
    #[cfg(feature = "WSTypes")]
    #[deprecated = "renamed to `WSProtocolHandler::set_serialization_override`"]
    pub fn WSProtocolHandlerSetSerializationOverride(
        protocol: &WSProtocolHandler,
        obj_type: CFTypeID,
        serialization_proc: WSProtocolHandlerSerializationProcPtr,
        context: *mut WSClientContext,
    );
}

extern "C-unwind" {
    #[cfg(feature = "WSTypes")]
    #[deprecated = "renamed to `WSProtocolHandler::set_deserialization_override`"]
    pub fn WSProtocolHandlerSetDeserializationOverride(
        protocol: &WSProtocolHandler,
        type_namespace: Option<&CFString>,
        type_name: Option<&CFString>,
        deserialization_proc: WSProtocolHandlerDeserializationProcPtr,
        context: *mut WSClientContext,
    );
}
