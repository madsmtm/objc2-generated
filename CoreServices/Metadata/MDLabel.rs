//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// This is the type of a reference to an MDLabel.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/mdlabel?language=objc)
#[doc(alias = "MDLabelRef")]
#[repr(C)]
pub struct MDLabel {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl MDLabel {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__MDLabel"> for MDLabel {}
);

unsafe impl ConcreteType for MDLabel {
    #[doc(alias = "MDLabelGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn MDLabelGetTypeID() -> CFTypeID;
        }
        unsafe { MDLabelGetTypeID() }
    }
}

#[cfg(feature = "MDItem")]
impl MDItem {
    /// Returns an array of the labels set on the specified item.
    ///
    /// Parameter `item`: The item to be interrogated.
    ///
    /// Returns: A CFArrayRef containing MDLabelRefs for the labels set on the item, or NULL on failure.
    #[doc(alias = "MDItemCopyLabels")]
    #[cfg(feature = "MDItem")]
    #[inline]
    pub unsafe fn labels(&self) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn MDItemCopyLabels(item: &MDItem) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { MDItemCopyLabels(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sets a label on the specified item.
    ///
    /// Parameter `item`: The item to be updated.
    ///
    /// Parameter `label`: The label.
    ///
    /// Returns: True if the label was successfully set on the item, false otherwise.
    ///
    /// # Safety
    ///
    /// `label` might not allow `None`.
    #[doc(alias = "MDItemSetLabel")]
    #[cfg(feature = "MDItem")]
    #[inline]
    pub unsafe fn set_label(&self, label: Option<&MDLabel>) -> bool {
        extern "C-unwind" {
            fn MDItemSetLabel(item: &MDItem, label: Option<&MDLabel>) -> Boolean;
        }
        let ret = unsafe { MDItemSetLabel(self, label) };
        ret != 0
    }

    /// Removes a label from the specified item.
    ///
    /// Parameter `item`: The item to be updated.
    ///
    /// Parameter `label`: The label.
    ///
    /// Returns: True if the label was successfully removed from the item, false otherwise.
    ///
    /// # Safety
    ///
    /// `label` might not allow `None`.
    #[doc(alias = "MDItemRemoveLabel")]
    #[cfg(feature = "MDItem")]
    #[inline]
    pub unsafe fn remove_label(&self, label: Option<&MDLabel>) -> bool {
        extern "C-unwind" {
            fn MDItemRemoveLabel(item: &MDItem, label: Option<&MDLabel>) -> Boolean;
        }
        let ret = unsafe { MDItemRemoveLabel(self, label) };
        ret != 0
    }
}

/// These constants are used to specify a domain to MDLabelCreate().
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/mdlabeldomain?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MDLabelDomain(pub c_uint);
impl MDLabelDomain {
    #[doc(alias = "kMDLabelUserDomain")]
    pub const UserDomain: Self = Self(0);
    #[doc(alias = "kMDLabelLocalDomain")]
    pub const LocalDomain: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for MDLabelDomain {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for MDLabelDomain {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl MDLabel {
    /// Returns a label with the specified parameters. If there is already a label that exactly matches the parameters, a reference to the existing label will be returned; otherwise this will attempt to create a new label.  A successful creation of a new private label definition will generate a kMDLabelAddedNotification. Note that this function can only create labels with "Private" visibility. Creating "Public" labels requires creating and installing a label bundle.
    ///
    /// Parameter `allocator`: The CFAllocator which should be used to allocate memory for the label. This parameter may be NULL in which case the current default CFAllocator is used. Use kCFAllocatorNull to request a reference to an existing label only.
    ///
    /// Parameter `displayName`: The label's display name.
    ///
    /// Parameter `kind`: The label's kind string.
    ///
    /// Parameter `domain`: The domain of the label (normally kMDLabelUserDomain).
    ///
    /// Returns: An MDLabelRef, or NULL on failure.
    ///
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `display_name` might not allow `None`.
    /// - `kind` might not allow `None`.
    #[doc(alias = "MDLabelCreate")]
    #[inline]
    pub unsafe fn new(
        allocator: Option<&CFAllocator>,
        display_name: Option<&CFString>,
        kind: Option<&CFString>,
        domain: MDLabelDomain,
    ) -> Option<CFRetained<MDLabel>> {
        extern "C-unwind" {
            fn MDLabelCreate(
                allocator: Option<&CFAllocator>,
                display_name: Option<&CFString>,
                kind: Option<&CFString>,
                domain: MDLabelDomain,
            ) -> Option<NonNull<MDLabel>>;
        }
        let ret = unsafe { MDLabelCreate(allocator, display_name, kind, domain) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Copy the value of the named attribute of a label.
    ///
    /// Parameter `label`: The label.
    ///
    /// Parameter `name`: The name of the desired attribute.
    ///
    /// Returns: A CFTypeRef, or NULL on failure, or if the attribute does not exist, or if the attribute is not readable.
    ///
    /// # Safety
    ///
    /// `name` might not allow `None`.
    #[doc(alias = "MDLabelCopyAttribute")]
    #[inline]
    pub unsafe fn attribute(&self, name: Option<&CFString>) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn MDLabelCopyAttribute(
                label: &MDLabel,
                name: Option<&CFString>,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { MDLabelCopyAttribute(self, name) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Copy the MDItem attribute name of a label. The attribute name can be used in an MDQuery string to search for MDItems that have the label set. The value of the MDItem attribute is a CFDate corresponding to the time the label was set on the item.
    ///
    /// Parameter `label`: The label.
    ///
    /// Returns: A CFStringRef, or NULL on failure.
    #[doc(alias = "MDLabelCopyAttributeName")]
    #[inline]
    pub unsafe fn attribute_name(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn MDLabelCopyAttributeName(label: &MDLabel) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { MDLabelCopyAttributeName(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Deletes the user's definition or override of the specified label from ~/Library/Metadata. Labels defined in bundles elsewhere in the filesystem cannot be deleted using this API. Deleting an override of a label merely makes the original definition of the label visible again and thus will generate a kMDLabelChangedNotification. A successful deletion of a private label definition will generate a kMDLabelRemovedNotification.
    ///
    /// Parameter `label`: The label.
    ///
    /// Returns: True if a label definition or override was successfully deleted.
    #[doc(alias = "MDLabelDelete")]
    #[inline]
    pub unsafe fn delete(&self) -> bool {
        extern "C-unwind" {
            fn MDLabelDelete(label: &MDLabel) -> Boolean;
        }
        let ret = unsafe { MDLabelDelete(self) };
        ret != 0
    }

    /// Updates the attributes of the specified label. Labels defined in ~/Library/Metadata are modified directly. Labels defined in bundles elsewhere in the filesystem are overridden by creating a private copy of the label definition in ~/Library/Metadata. The updated attributes are then stored in the private copy. A successful call to MDLabelSetAttributes() will generate a kMDLabelChangedNotification.
    ///
    /// Parameter `label`: The label.
    ///
    /// Parameter `attrs`: A dictionary containing the attributes to be modified. To remove an attribute, include it in the dictionary with kCFNull as its value.
    ///
    /// Returns: True if the label definition or override was successfully updated.
    ///
    /// # Safety
    ///
    /// - `attrs` generics must be of the correct type.
    /// - `attrs` might not allow `None`.
    #[doc(alias = "MDLabelSetAttributes")]
    #[inline]
    pub unsafe fn set_attributes(&self, attrs: Option<&CFDictionary>) -> bool {
        extern "C-unwind" {
            fn MDLabelSetAttributes(label: &MDLabel, attrs: Option<&CFDictionary>) -> Boolean;
        }
        let ret = unsafe { MDLabelSetAttributes(self, attrs) };
        ret != 0
    }
}

/// Copy the list of label kind strings.
///
/// Returns: A CFArrayRef containing all of the label kind strings, or NULL on failure.
#[inline]
pub unsafe extern "C-unwind" fn MDCopyLabelKinds() -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn MDCopyLabelKinds() -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { MDCopyLabelKinds() };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Copy the list of labels matching the specified query expression.
///
/// Parameter `simpleQueryString`: The query expression string.
///
/// Returns: A CFArrayRef containing all of the matching labels, or NULL on failure.
///
/// # Safety
///
/// `simple_query_string` might not allow `None`.
#[inline]
pub unsafe extern "C-unwind" fn MDCopyLabelsMatchingExpression(
    simple_query_string: Option<&CFString>,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn MDCopyLabelsMatchingExpression(
            simple_query_string: Option<&CFString>,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { MDCopyLabelsMatchingExpression(simple_query_string) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Copy the list of labels with the specified kind string.
///
/// Parameter `kind`: The kind string, or NULL to copy all labels.
///
/// Returns: A CFArrayRef containing all of the labels with the specified kind string, or NULL on failure.
///
/// # Safety
///
/// `kind` might not allow `None`.
#[inline]
pub unsafe extern "C-unwind" fn MDCopyLabelsWithKind(
    kind: Option<&CFString>,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn MDCopyLabelsWithKind(kind: Option<&CFString>) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { MDCopyLabelsWithKind(kind) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Copy the label with the specified UUID.
///
/// Parameter `labelUUID`: The label UUID.
///
/// Returns: An MDLabelRef, or NULL on failure.
///
/// # Safety
///
/// `label_uuid` might not allow `None`.
#[inline]
pub unsafe extern "C-unwind" fn MDCopyLabelWithUUID(
    label_uuid: Option<&CFUUID>,
) -> Option<CFRetained<MDLabel>> {
    extern "C-unwind" {
        fn MDCopyLabelWithUUID(label_uuid: Option<&CFUUID>) -> Option<NonNull<MDLabel>>;
    }
    let ret = unsafe { MDCopyLabelWithUUID(label_uuid) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C" {
    /// This is the bundle URL for the label.
    /// Type is a CFURL. This attribute is read-only.
    ///
    ///
    ///
    /// This is the date the the label content last changed.
    /// Type is a CFDate. This attribute is read-only, but its value will be altered by setting any of the writable attributes described below.
    ///
    ///
    ///
    /// This is the localized name of the label.
    /// Type is a CFString.
    ///
    ///
    ///
    /// This is the data that should be used to create an icon image source for the label. Pass this data to the ImageIO framework to create a CGImageSourceRef. To reset a label's icon to its default image, set kMDLabelIconData to kCFNull.
    /// Type is a CFData.
    ///
    ///
    ///
    /// This is the UUID of the icon image source for the label. Labels that share the same icon image source will have the same icon UUID.
    /// Type is a CFUUID. This attribute is read-only, but its value may be altered by setting the kMDLabelIconData attribute described above.
    ///
    ///
    ///
    /// This attribute is true if the label kind specifies a mutually-exclusive set of labels.
    /// Type is a CFBoolean. This attribute is read-only.
    ///
    ///
    ///
    /// This is the kind string for the label. The label kind is the name of the bundle the label is defined in.
    /// Type is a CFString. This attribute is read-only.
    ///
    ///
    ///
    /// This attribute is optional and applicable only to labels with "Public" visibility. If it is present, then when the label is set on a file the file's Finder color will be set to the specified value (0 - 7). If the label is later removed, the file's Finder color will be reverted either to the color specified by the most-recently-set label with this attribute that remains set on the file, or to 0 (none).
    /// Type is a CFNumber. This attribute is ignored for unless the label's visibility is "Public".
    ///
    ///
    ///
    /// This is the UUID of the label.
    /// Type is a CFUUID. This attribute is read-only.
    ///
    ///
    ///
    /// This is a constant describing the label's visibility, either "Public" (kMDPublicVisibility) or "Private" (kMDPrivateVisibility).
    /// Type is a CFString. This attribute is read-only.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelbundleurl?language=objc)
    pub static kMDLabelBundleURL: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelcontentchangedate?language=objc)
    pub static kMDLabelContentChangeDate: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabeldisplayname?language=objc)
    pub static kMDLabelDisplayName: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelicondata?language=objc)
    pub static kMDLabelIconData: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabeliconuuid?language=objc)
    pub static kMDLabelIconUUID: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelismutuallyexclusivesetmember?language=objc)
    pub static kMDLabelIsMutuallyExclusiveSetMember: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelkind?language=objc)
    pub static kMDLabelKind: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelsetsfindercolor?language=objc)
    pub static kMDLabelSetsFinderColor: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabeluuid?language=objc)
    pub static kMDLabelUUID: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelvisibility?language=objc)
    pub static kMDLabelVisibility: Option<&'static CFString>;
}

extern "C" {
    /// This key is used in the Info.plist file of a label bundle to specify that the label kind constitutes a mutually exclusive set.
    /// The value is a CFBoolean.
    ///
    ///
    ///
    /// This key is used in the Info.plist file of a label bundle to specify the visibility of the labels defined by the bundle.
    /// The value is a CFString constant, either "Public" (kMDPublicVisibility) or "Private" (kMDPrivateVisibility).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelkindismutuallyexclusivesetkey?language=objc)
    pub static kMDLabelKindIsMutuallyExclusiveSetKey: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelkindvisibilitykey?language=objc)
    pub static kMDLabelKindVisibilityKey: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdprivatevisibility?language=objc)
    pub static kMDPrivateVisibility: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdpublicvisibility?language=objc)
    pub static kMDPublicVisibility: Option<&'static CFString>;
}

extern "C" {
    /// The name of the notification sent when a label has been added. The notification object is the subject MDLabelRef. All label notifications are distributed to processes owned by the same uid that have initialized the Metadata framework label APIs.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabeladdednotification?language=objc)
    pub static kMDLabelAddedNotification: Option<&'static CFString>;
}

extern "C" {
    /// The name of the notification sent when a label has been changed. The notification object is the subject MDLabelRef. The label's new attributes can be retrieved using MDLabelCopyAttribute().
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelchangednotification?language=objc)
    pub static kMDLabelChangedNotification: Option<&'static CFString>;
}

extern "C" {
    /// The name of the notification sent when a label has been deleted. The notification object is the subject MDLabelRef. The label's kMDLabelIconUUID, kMDLabelKind, kMDLabelKindBundleURL and kMDLabelUUID attributes can still be retrieved using MDLabelCopyAttribute(), and the label may still be passed to MDLabelCopyAttributeName().
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kmdlabelremovednotification?language=objc)
    pub static kMDLabelRemovedNotification: Option<&'static CFString>;
}

#[cfg(feature = "MDItem")]
#[deprecated = "renamed to `MDItem::labels`"]
#[inline]
pub unsafe extern "C-unwind" fn MDItemCopyLabels(item: &MDItem) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn MDItemCopyLabels(item: &MDItem) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { MDItemCopyLabels(item) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "MDItem")]
#[deprecated = "renamed to `MDItem::set_label`"]
#[inline]
pub unsafe extern "C-unwind" fn MDItemSetLabel(item: &MDItem, label: Option<&MDLabel>) -> bool {
    extern "C-unwind" {
        fn MDItemSetLabel(item: &MDItem, label: Option<&MDLabel>) -> Boolean;
    }
    let ret = unsafe { MDItemSetLabel(item, label) };
    ret != 0
}

#[cfg(feature = "MDItem")]
#[deprecated = "renamed to `MDItem::remove_label`"]
#[inline]
pub unsafe extern "C-unwind" fn MDItemRemoveLabel(item: &MDItem, label: Option<&MDLabel>) -> bool {
    extern "C-unwind" {
        fn MDItemRemoveLabel(item: &MDItem, label: Option<&MDLabel>) -> Boolean;
    }
    let ret = unsafe { MDItemRemoveLabel(item, label) };
    ret != 0
}

#[deprecated = "renamed to `MDLabel::new`"]
#[inline]
pub unsafe extern "C-unwind" fn MDLabelCreate(
    allocator: Option<&CFAllocator>,
    display_name: Option<&CFString>,
    kind: Option<&CFString>,
    domain: MDLabelDomain,
) -> Option<CFRetained<MDLabel>> {
    extern "C-unwind" {
        fn MDLabelCreate(
            allocator: Option<&CFAllocator>,
            display_name: Option<&CFString>,
            kind: Option<&CFString>,
            domain: MDLabelDomain,
        ) -> Option<NonNull<MDLabel>>;
    }
    let ret = unsafe { MDLabelCreate(allocator, display_name, kind, domain) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `MDLabel::attribute`"]
#[inline]
pub unsafe extern "C-unwind" fn MDLabelCopyAttribute(
    label: &MDLabel,
    name: Option<&CFString>,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn MDLabelCopyAttribute(
            label: &MDLabel,
            name: Option<&CFString>,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { MDLabelCopyAttribute(label, name) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `MDLabel::attribute_name`"]
#[inline]
pub unsafe extern "C-unwind" fn MDLabelCopyAttributeName(
    label: &MDLabel,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn MDLabelCopyAttributeName(label: &MDLabel) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { MDLabelCopyAttributeName(label) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `MDLabel::delete`"]
#[inline]
pub unsafe extern "C-unwind" fn MDLabelDelete(label: &MDLabel) -> bool {
    extern "C-unwind" {
        fn MDLabelDelete(label: &MDLabel) -> Boolean;
    }
    let ret = unsafe { MDLabelDelete(label) };
    ret != 0
}

#[deprecated = "renamed to `MDLabel::set_attributes`"]
#[inline]
pub unsafe extern "C-unwind" fn MDLabelSetAttributes(
    label: &MDLabel,
    attrs: Option<&CFDictionary>,
) -> bool {
    extern "C-unwind" {
        fn MDLabelSetAttributes(label: &MDLabel, attrs: Option<&CFDictionary>) -> Boolean;
    }
    let ret = unsafe { MDLabelSetAttributes(label, attrs) };
    ret != 0
}
