//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/keydirectobject?language=objc)
#[cfg(feature = "AEDataModel")]
pub const keyDirectObject: AEKeyword = 0x2d2d2d2d;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/keyerrornumber?language=objc)
#[cfg(feature = "AEDataModel")]
pub const keyErrorNumber: AEKeyword = 0x6572726e;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/keyerrorstring?language=objc)
#[cfg(feature = "AEDataModel")]
pub const keyErrorString: AEKeyword = 0x65727273;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/keyprocessserialnumber?language=objc)
#[cfg(feature = "AEDataModel")]
pub const keyProcessSerialNumber: AEKeyword = 0x70736e20;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/keypredispatch?language=objc)
#[cfg(feature = "AEDataModel")]
pub const keyPreDispatch: AEKeyword = 0x70686163;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/keyselectproc?language=objc)
#[cfg(feature = "AEDataModel")]
pub const keySelectProc: AEKeyword = 0x73656c68;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/keyaerecordercount?language=objc)
#[cfg(feature = "AEDataModel")]
pub const keyAERecorderCount: AEKeyword = 0x72656372;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/keyaeversion?language=objc)
#[cfg(feature = "AEDataModel")]
pub const keyAEVersion: AEKeyword = 0x76657273;

/// in a kAEOpenDocuments/kAEReopenApplication event, a typeBoolean value, if true then the process should expect a request to be frontmost to accompany this AppleEvent
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeapplicationactivationexpected?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEApplicationActivationExpected: AEKeyword = 0x61617064;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kcoreeventclass?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kCoreEventClass: DescType = 0x61657674;

/// Event sent as the first AppleEvent to an application which is not launched with a document to open or print or with a URL to open.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeopenapplication?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEOpenApplication: AEEventID = 0x6f617070;
/// Event that provides an application with a list of documents to open.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeopendocuments?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEOpenDocuments: AEEventID = 0x6f646f63;
/// Event that provides an application with a list of documents to print.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeprintdocuments?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEPrintDocuments: AEEventID = 0x70646f63;
/// Event that provides an application with dragged content, such as text or an image.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeopencontents?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEOpenContents: AEEventID = 0x6f636f6e;
/// Event that causes an application to quit.  May include a property kAEQuitReason indicating what lead to the quit being sent.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaequitapplication?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEQuitApplication: AEEventID = 0x71756974;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeanswer?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEAnswer: AEEventID = 0x616e7372;
/// Event sent by the Process Manager to an application that launched another application when the launched application quits or terminates.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeapplicationdied?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEApplicationDied: AEEventID = 0x6f626974;
/// sent by Mac OS X when the user chooses the Preferences item
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeshowpreferences?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEShowPreferences: AEEventID = 0x70726566;

/// If present in a kAEOpenApplication or kAEReopenApplication AppleEvent, with the value kAEYes, then any saved application state should be restored; if present and kAENo, then any saved application state should not be restored
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/keyaerestoreappstate?language=objc)
#[cfg(feature = "AEDataModel")]
pub const keyAERestoreAppState: DescType = 0x7273746f;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaestartrecording?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEStartRecording: AEEventID = 0x72656361;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaestoprecording?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAEStopRecording: AEEventID = 0x72656363;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaenotifystartrecording?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAENotifyStartRecording: AEEventID = 0x72656331;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaenotifystoprecording?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAENotifyStopRecording: AEEventID = 0x72656330;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaenotifyrecording?language=objc)
#[cfg(feature = "AEDataModel")]
pub const kAENotifyRecording: AEEventID = 0x72656372;

/// AEEventSource is defined as an SInt8 for compatability with pascal.
/// Important note: keyEventSourceAttr is returned by AttributePtr as a typeShortInteger.
/// Be sure to pass at least two bytes of storage to AEGetAttributePtr - the result can be
/// compared directly against the following enums.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/aeeventsource?language=objc)
pub type AEEventSource = i8;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeunknownsource?language=objc)
pub const kAEUnknownSource: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaedirectcall?language=objc)
pub const kAEDirectCall: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaesameprocess?language=objc)
pub const kAESameProcess: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaelocalprocess?language=objc)
pub const kAELocalProcess: c_uint = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeremoteprocess?language=objc)
pub const kAERemoteProcess: c_uint = 4;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/erraetargetaddressnotpermitted?language=objc)
pub const errAETargetAddressNotPermitted: c_int = -1742;
/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/erraeeventnotpermitted?language=objc)
pub const errAEEventNotPermitted: c_int = -1743;

/// ************************************************************************
/// These calls are used to set up and modify the event dispatch table.D
/// ************************************************************************
///
/// # Safety
///
/// - `handler` must be implemented correctly.
/// - `handler_refcon` must be a valid pointer.
#[cfg(feature = "AEDataModel")]
#[inline]
pub unsafe extern "C-unwind" fn AEInstallEventHandler(
    the_ae_event_class: AEEventClass,
    the_ae_event_id: AEEventID,
    handler: AEEventHandlerUPP,
    handler_refcon: SRefCon,
    is_sys_handler: bool,
) -> OSErr {
    extern "C-unwind" {
        fn AEInstallEventHandler(
            the_ae_event_class: AEEventClass,
            the_ae_event_id: AEEventID,
            handler: AEEventHandlerUPP,
            handler_refcon: SRefCon,
            is_sys_handler: Boolean,
        ) -> OSErr;
    }
    unsafe {
        AEInstallEventHandler(
            the_ae_event_class,
            the_ae_event_id,
            handler,
            handler_refcon,
            is_sys_handler as _,
        )
    }
}

/// # Safety
///
/// `handler` must be implemented correctly.
#[cfg(feature = "AEDataModel")]
#[inline]
pub unsafe extern "C-unwind" fn AERemoveEventHandler(
    the_ae_event_class: AEEventClass,
    the_ae_event_id: AEEventID,
    handler: AEEventHandlerUPP,
    is_sys_handler: bool,
) -> OSErr {
    extern "C-unwind" {
        fn AERemoveEventHandler(
            the_ae_event_class: AEEventClass,
            the_ae_event_id: AEEventID,
            handler: AEEventHandlerUPP,
            is_sys_handler: Boolean,
        ) -> OSErr;
    }
    unsafe {
        AERemoveEventHandler(
            the_ae_event_class,
            the_ae_event_id,
            handler,
            is_sys_handler as _,
        )
    }
}

/// # Safety
///
/// - `handler` must be a valid pointer.
/// - `handler_refcon` must be a valid pointer.
#[cfg(feature = "AEDataModel")]
#[inline]
pub unsafe extern "C-unwind" fn AEGetEventHandler(
    the_ae_event_class: AEEventClass,
    the_ae_event_id: AEEventID,
    handler: *mut AEEventHandlerUPP,
    handler_refcon: *mut SRefCon,
    is_sys_handler: bool,
) -> OSErr {
    extern "C-unwind" {
        fn AEGetEventHandler(
            the_ae_event_class: AEEventClass,
            the_ae_event_id: AEEventID,
            handler: *mut AEEventHandlerUPP,
            handler_refcon: *mut SRefCon,
            is_sys_handler: Boolean,
        ) -> OSErr;
    }
    unsafe {
        AEGetEventHandler(
            the_ae_event_class,
            the_ae_event_id,
            handler,
            handler_refcon,
            is_sys_handler as _,
        )
    }
}

/// ************************************************************************
/// These calls are used to set up and modify special hooks into the
/// AppleEvent manager.
/// ************************************************************************
///
/// # Safety
///
/// `handler` must be implemented correctly.
#[cfg(feature = "AEDataModel")]
#[inline]
pub unsafe extern "C-unwind" fn AEInstallSpecialHandler(
    function_class: AEKeyword,
    handler: AEEventHandlerUPP,
    is_sys_handler: bool,
) -> OSErr {
    extern "C-unwind" {
        fn AEInstallSpecialHandler(
            function_class: AEKeyword,
            handler: AEEventHandlerUPP,
            is_sys_handler: Boolean,
        ) -> OSErr;
    }
    unsafe { AEInstallSpecialHandler(function_class, handler, is_sys_handler as _) }
}

/// # Safety
///
/// `handler` must be implemented correctly.
#[cfg(feature = "AEDataModel")]
#[inline]
pub unsafe extern "C-unwind" fn AERemoveSpecialHandler(
    function_class: AEKeyword,
    handler: AEEventHandlerUPP,
    is_sys_handler: bool,
) -> OSErr {
    extern "C-unwind" {
        fn AERemoveSpecialHandler(
            function_class: AEKeyword,
            handler: AEEventHandlerUPP,
            is_sys_handler: Boolean,
        ) -> OSErr;
    }
    unsafe { AERemoveSpecialHandler(function_class, handler, is_sys_handler as _) }
}

/// # Safety
///
/// `handler` must be a valid pointer.
#[cfg(feature = "AEDataModel")]
#[inline]
pub unsafe extern "C-unwind" fn AEGetSpecialHandler(
    function_class: AEKeyword,
    handler: *mut AEEventHandlerUPP,
    is_sys_handler: bool,
) -> OSErr {
    extern "C-unwind" {
        fn AEGetSpecialHandler(
            function_class: AEKeyword,
            handler: *mut AEEventHandlerUPP,
            is_sys_handler: Boolean,
        ) -> OSErr;
    }
    unsafe { AEGetSpecialHandler(function_class, handler, is_sys_handler as _) }
}

extern "C-unwind" {
    /// ************************************************************************
    /// This call was added in version 1.0.1. If called with the keyword
    /// keyAERecorderCount ('recr'), the number of recorders that are
    /// currently active is returned in 'result'
    /// (available only in vers 1.0.1 and greater).
    /// ************************************************************************
    ///
    /// # Safety
    ///
    /// `result` must be a valid pointer.
    #[cfg(feature = "AEDataModel")]
    pub fn AEManagerInfo(key_word: AEKeyword, result: *mut c_long) -> OSErr;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeremoteprocessurlkey?language=objc)
    pub static kAERemoteProcessURLKey: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeremoteprocessnamekey?language=objc)
    pub static kAERemoteProcessNameKey: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeremoteprocessuseridkey?language=objc)
    pub static kAERemoteProcessUserIDKey: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaeremoteprocessprocessidkey?language=objc)
    pub static kAERemoteProcessProcessIDKey: Option<&'static CFString>;
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/aeremoteprocessresolvercontext?language=objc)
#[repr(C, packed(2))]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct AERemoteProcessResolverContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: CFAllocatorRetainCallBack,
    pub release: CFAllocatorReleaseCallBack,
    pub copyDescription: CFAllocatorCopyDescriptionCallBack,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for AERemoteProcessResolverContext {
    const ENCODING: Encoding = Encoding::Struct(
        "AERemoteProcessResolverContext",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <CFAllocatorRetainCallBack>::ENCODING,
            <CFAllocatorReleaseCallBack>::ENCODING,
            <CFAllocatorCopyDescriptionCallBack>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for AERemoteProcessResolverContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/aeremoteprocessresolver?language=objc)
#[repr(C)]
#[derive(Debug)]
pub struct AERemoteProcessResolver {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for AERemoteProcessResolver {
    const ENCODING_REF: Encoding =
        Encoding::Pointer(&Encoding::Struct("AERemoteProcessResolver", &[]));
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/aeremoteprocessresolverref?language=objc)
pub type AERemoteProcessResolverRef = *mut AERemoteProcessResolver;

extern "C-unwind" {
    /// # Safety
    ///
    /// - `allocator` might not allow `None`.
    /// - `url` might not allow `None`.
    pub fn AECreateRemoteProcessResolver(
        allocator: Option<&CFAllocator>,
        url: Option<&CFURL>,
    ) -> AERemoteProcessResolverRef;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `ref` must be a valid pointer.
    pub fn AEDisposeRemoteProcessResolver(r#ref: AERemoteProcessResolverRef);
}

impl AERemoteProcessResolver {
    /// # Safety
    ///
    /// - `ref` must be a valid pointer.
    /// - `out_error` must be a valid pointer.
    #[doc(alias = "AERemoteProcessResolverGetProcesses")]
    #[inline]
    pub unsafe fn processes(
        r#ref: AERemoteProcessResolverRef,
        out_error: *mut CFStreamError,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn AERemoteProcessResolverGetProcesses(
                r#ref: AERemoteProcessResolverRef,
                out_error: *mut CFStreamError,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { AERemoteProcessResolverGetProcesses(r#ref, out_error) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/aeremoteprocessresolvercallback?language=objc)
pub type AERemoteProcessResolverCallback =
    Option<unsafe extern "C-unwind" fn(AERemoteProcessResolverRef, *mut c_void)>;

impl AERemoteProcessResolver {
    /// # Safety
    ///
    /// - `ref` must be a valid pointer.
    /// - `run_loop` possibly has additional threading requirements.
    /// - `run_loop` might not allow `None`.
    /// - `run_loop_mode` might not allow `None`.
    /// - `callback` must be implemented correctly.
    /// - `ctx` must be a valid pointer.
    #[doc(alias = "AERemoteProcessResolverScheduleWithRunLoop")]
    #[inline]
    pub unsafe fn schedule_with_run_loop(
        r#ref: AERemoteProcessResolverRef,
        run_loop: Option<&CFRunLoop>,
        run_loop_mode: Option<&CFString>,
        callback: AERemoteProcessResolverCallback,
        ctx: *const AERemoteProcessResolverContext,
    ) {
        extern "C-unwind" {
            fn AERemoteProcessResolverScheduleWithRunLoop(
                r#ref: AERemoteProcessResolverRef,
                run_loop: Option<&CFRunLoop>,
                run_loop_mode: Option<&CFString>,
                callback: AERemoteProcessResolverCallback,
                ctx: *const AERemoteProcessResolverContext,
            );
        }
        unsafe {
            AERemoteProcessResolverScheduleWithRunLoop(
                r#ref,
                run_loop,
                run_loop_mode,
                callback,
                ctx,
            )
        }
    }
}

/// Determines whether the current application is able to send an AppleEvent with the given eventClass and eventID to the application described as targetAddressDesc.
///
/// Mac OS 10.14 and later impose additional requirements on applications when they send AppleEvents to other applications in order
/// to insure that users are aware of and consent to allowing such control or information exchange.  Generally this involves
/// the user being prompted in a secure fashion the first time an application attempts to send an AppleEvent to another application.
/// If the user consents then this application can send events to the target.  If the user does not consent then any future
/// attempts to send AppleEvents will result in a failure with errAEEventNotPermitted being returned.
///
/// Certain AppleEvents are allowed to be sent without prompting the user.  Pass typeWildCard for the eventClass and eventID
/// to determine if every event is allowed to be sent from this application to the target.
///
/// Applications can determine, without sending an AppleEvent to a target application, whether they are allowed to send AppleEvents
/// to the target with this function.  If askUserIfNeeded is true, and this application does not yet have permission to send
/// AppleEvents to the target, then the user will be asked if permission can be granted; if askUserIfNeeded is false and permission
/// has not been granted, then errAEEventWouldRequireUserConsent will be returned.
///
/// The target AEAddressDesc must refer to an already running application.
///
///
/// Thread safe since version 10.14.  Do not call this function on your main thread because it may take arbitrarily long
/// to return if the user needs to be prompted for consent.
///
///
/// Parameter `target`: A pointer to an address descriptor. Before calling AEDeterminePermissionToAutomateTarget, you set the descriptor to identify
/// the target application for the Apple event.  The target address descriptor must refer to a running application.  If
/// the target application is on another machine, then Remote AppleEvents must be enabled on that machine for the user.
///
///
/// Parameter `theAEEventClass`: The event class of the Apple event to determine permission for.
///
///
/// Parameter `theAEEventID`: The event ID of the Apple event to determine permission for.
///
///
/// Parameter `askUserIfNeeded`: a Boolean; if true, and if this application does not yet have permission to send events to the target application, then
/// prompt the user to obtain permission.  If false, do not prompt the user.
///
///
/// Returns: If the current application is permitted to send the given AppleEvent to the target, then noErr will be returned.  If the
/// current application is not permitted to send the event, errAEEventNotPermitted will be returned.  If the target application
/// is not running, then procNotFound will be returned.  If askUserIfNeeded is false, and this application is not yet permitted
/// to send AppleEvents to the target, then errAEEventWouldRequireUserConsent will be returned.
///
/// # Safety
///
/// `target` must be a valid pointer.
#[cfg(feature = "AEDataModel")]
#[inline]
pub unsafe extern "C-unwind" fn AEDeterminePermissionToAutomateTarget(
    target: *const AEAddressDesc,
    the_ae_event_class: AEEventClass,
    the_ae_event_id: AEEventID,
    ask_user_if_needed: bool,
) -> OSStatus {
    extern "C-unwind" {
        fn AEDeterminePermissionToAutomateTarget(
            target: *const AEAddressDesc,
            the_ae_event_class: AEEventClass,
            the_ae_event_id: AEEventID,
            ask_user_if_needed: Boolean,
        ) -> OSStatus;
    }
    unsafe {
        AEDeterminePermissionToAutomateTarget(
            target,
            the_ae_event_class,
            the_ae_event_id,
            ask_user_if_needed as _,
        )
    }
}

/// Determining whether this can be sent would require prompting the user, and the AppleEvent was sent with kAEDoNotPromptForPermission
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/erraeeventwouldrequireuserconsent?language=objc)
pub const errAEEventWouldRequireUserConsent: c_int = -1744;

/// If set, and the AppleEvent requires user consent, do not prompt and instead return errAEEventWouldRequireUserConsent
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coreservices/kaedonotpromptforuserconsent?language=objc)
pub const kAEDoNotPromptForUserConsent: c_uint = 0x00020000;

#[deprecated = "renamed to `AERemoteProcessResolver::processes`"]
#[inline]
pub unsafe extern "C-unwind" fn AERemoteProcessResolverGetProcesses(
    r#ref: AERemoteProcessResolverRef,
    out_error: *mut CFStreamError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn AERemoteProcessResolverGetProcesses(
            r#ref: AERemoteProcessResolverRef,
            out_error: *mut CFStreamError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { AERemoteProcessResolverGetProcesses(r#ref, out_error) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `AERemoteProcessResolver::schedule_with_run_loop`"]
    pub fn AERemoteProcessResolverScheduleWithRunLoop(
        r#ref: AERemoteProcessResolverRef,
        run_loop: Option<&CFRunLoop>,
        run_loop_mode: Option<&CFString>,
        callback: AERemoteProcessResolverCallback,
        ctx: *const AERemoteProcessResolverContext,
    );
}
