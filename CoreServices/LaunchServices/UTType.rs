//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    pub static kUTExportedTypeDeclarationsKey: &'static CFString;
}

extern "C" {
    pub static kUTImportedTypeDeclarationsKey: &'static CFString;
}

extern "C" {
    pub static kUTTypeIdentifierKey: &'static CFString;
}

extern "C" {
    pub static kUTTypeTagSpecificationKey: &'static CFString;
}

extern "C" {
    pub static kUTTypeConformsToKey: &'static CFString;
}

extern "C" {
    pub static kUTTypeDescriptionKey: &'static CFString;
}

extern "C" {
    pub static kUTTypeIconFileKey: &'static CFString;
}

extern "C" {
    pub static kUTTypeReferenceURLKey: &'static CFString;
}

extern "C" {
    pub static kUTTypeVersionKey: &'static CFString;
}

extern "C" {
    #[deprecated = "Use UTTagClassFilenameExtension instead."]
    pub static kUTTagClassFilenameExtension: &'static CFString;
}

extern "C" {
    #[deprecated = "Use UTTagClassMIMEType instead."]
    pub static kUTTagClassMIMEType: &'static CFString;
}

extern "C" {
    #[deprecated = "NSPasteboard types are obsolete."]
    pub static kUTTagClassNSPboardType: &'static CFString;
}

extern "C" {
    #[deprecated = "HFS file types are obsolete."]
    pub static kUTTagClassOSType: &'static CFString;
}

/// Creates a uniform type identifier for the type indicated by the specified tag.
///
/// Parameters:
/// - inTagClass: The class of the `inTag` parameter. For more information, see `Type Tag Classes`.
///
/// - inTag: The tag to translate into a uniform type identifier.
///
/// - inConformingToUTI: If not `NULL`, the returned uniform type identifier must conform to this parameter.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// A new CFStringRef containing a uniform type identifier, or `NULL` if inTagClass is not a known tag class
///
///
///
/// ## Discussion
///
/// This function is used to translate a type declared using another declaration mechanism (for example, MIME types) into a uniform type identifier. This function searches all UTI declarations for a matching translation. If a conforming parameter is assigned, the search is reduced to the subset of type identifiers that conform to that type.
///
/// If there is more than one possible UTI for the specified tag, the UTI that will be returned is undefined. See [`UTTypeCreateAllIdentifiersForTag`](https://developer.apple.com/documentation/coreservices/1447261-uttypecreateallidentifiersfortag) if you need to see all search results.
///
/// If no result is found, this function creates a dynamic type beginning with the `dyn` prefix. This allows you to pass the UTI around and convert it back to the original tag.
///
///
#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCreatePreferredIdentifierForTag(
    in_tag_class: &CFString,
    in_tag: &CFString,
    in_conforming_to_uti: Option<&CFString>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn UTTypeCreatePreferredIdentifierForTag(
            in_tag_class: &CFString,
            in_tag: &CFString,
            in_conforming_to_uti: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe {
        UTTypeCreatePreferredIdentifierForTag(in_tag_class, in_tag, in_conforming_to_uti)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Creates an array of all uniform type identifiers for the type indicated by the specified tag.
///
/// Parameters:
/// - inTagClass: The class of the `inTag` parameter. For more information, see `Type Tag Classes`.
///
/// - inTag: The tag to translate into a uniform type identifier.
///
/// - inConformingToUTI: If not `nil`, all returned uniform type identifiers must conform to this parameter.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// An array of uniform type identifiers, or `NULL` if inTagClass is not a known tag class
///
///
///
/// ## Discussion
///
/// This function is used to translate a type declared using another declaration mechanism (for example, MIME types) into a uniform type identifier. This function searches all UTI declarations for a matching translation and returns all possible results. If a conforming parameter is assigned, the search is reduced to the subset of type identifiers that conform to that type.
///
/// If no result is found, this function creates a dynamic type beginning with the `dyn` prefix.
///
///
#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCreateAllIdentifiersForTag(
    in_tag_class: &CFString,
    in_tag: &CFString,
    in_conforming_to_uti: Option<&CFString>,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn UTTypeCreateAllIdentifiersForTag(
            in_tag_class: &CFString,
            in_tag: &CFString,
            in_conforming_to_uti: Option<&CFString>,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret =
        unsafe { UTTypeCreateAllIdentifiersForTag(in_tag_class, in_tag, in_conforming_to_uti) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Translates a uniform type identifier to a list of tags in a different type classification method.
///
/// Parameters:
/// - inUTI: The uniform type identifier to convert.
///
/// - inTagClass: The class of the tags you want to return. For more information, see `Type Tag Classes`.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// An array of tags (as CFStrings), or `NULL` if there was no translation available to convert the uniform type identifier to the specified class.
///
///
///
/// ## Discussion
///
/// If the type declaration included more than one tag with the specified class, the first tag in the declared tag array is the preferred tag.
///
///
#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyPreferredTagWithClass(
    in_uti: &CFString,
    in_tag_class: &CFString,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn UTTypeCopyPreferredTagWithClass(
            in_uti: &CFString,
            in_tag_class: &CFString,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { UTTypeCopyPreferredTagWithClass(in_uti, in_tag_class) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyAllTagsWithClass(
    in_uti: &CFString,
    in_tag_class: &CFString,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn UTTypeCopyAllTagsWithClass(
            in_uti: &CFString,
            in_tag_class: &CFString,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { UTTypeCopyAllTagsWithClass(in_uti, in_tag_class) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns whether two uniform type identifiers are equal.
///
/// Parameters:
/// - inUTI1: A uniform type identifier.
///
/// - inUTI2: The uniform type identifier to compare it to.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns `true` if the two uniform type identifiers are equivalent.
///
///
#[deprecated = "Use -[UTType isEqual:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeEqual(in_uti1: &CFString, in_uti2: &CFString) -> bool {
    extern "C-unwind" {
        fn UTTypeEqual(in_uti1: &CFString, in_uti2: &CFString) -> Boolean;
    }
    let ret = unsafe { UTTypeEqual(in_uti1, in_uti2) };
    ret != 0
}

/// Returns whether a uniform type identifier conforms to another uniform type identifier.
///
/// Parameters:
/// - inUTI: A uniform type identifier to compare.
///
/// - inConformsToUTI: The uniform type identifier to compare it to.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns `true` if the uniform type identifier is equal to or conforms to the second type.
///
///
#[deprecated = "Use -[UTType conformsToType:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeConformsTo(
    in_uti: &CFString,
    in_conforms_to_uti: &CFString,
) -> bool {
    extern "C-unwind" {
        fn UTTypeConformsTo(in_uti: &CFString, in_conforms_to_uti: &CFString) -> Boolean;
    }
    let ret = unsafe { UTTypeConformsTo(in_uti, in_conforms_to_uti) };
    ret != 0
}

/// Returns the localized, user-readable type description string associated with a uniform type identifier.
///
/// Parameters:
/// - inUTI: A uniform type identifier.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// A localized string describing the type, or `NULL` if no type description is available.
///
///
///
/// ## Discussion
///
/// The localized string that describes the uniform type is found in the type’s declaration.
///
///
#[deprecated = "Use UTType.localizedDescription instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyDescription(
    in_uti: &CFString,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn UTTypeCopyDescription(in_uti: &CFString) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { UTTypeCopyDescription(in_uti) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "Use UTType.declared instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeIsDeclared(in_uti: &CFString) -> bool {
    extern "C-unwind" {
        fn UTTypeIsDeclared(in_uti: &CFString) -> Boolean;
    }
    let ret = unsafe { UTTypeIsDeclared(in_uti) };
    ret != 0
}

#[deprecated = "Use UTType.dynamic instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeIsDynamic(in_uti: &CFString) -> bool {
    extern "C-unwind" {
        fn UTTypeIsDynamic(in_uti: &CFString) -> Boolean;
    }
    let ret = unsafe { UTTypeIsDynamic(in_uti) };
    ret != 0
}

/// Returns a uniform type’s declaration.
///
/// Parameters:
/// - inUTI: A uniform type identifier.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// A dictionary that contains the uniform type’s declaration, or `NULL` if no declaration for that type can be found.
///
///
///
/// ## Discussion
///
/// A uniform type identifier is declared in a bundle’s information [Property list](https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/PropertyList.html#//apple_ref/doc/uid/TP40008195-CH44) (`info.plist`). This function extracts and returns a dictionary that contains the complete declaration of the uniform type identifier. This is useful when your application needs to access properties that does not have a built-in accessor function. For more information on the dictionary format, see [Uniform Type Identifiers Overview](https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_intro/understand_utis_intro.html#//apple_ref/doc/uid/TP40001319).
///
///
#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyDeclaration(
    in_uti: &CFString,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn UTTypeCopyDeclaration(in_uti: &CFString) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { UTTypeCopyDeclaration(in_uti) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns the location of a bundle containing the declaration for a type.
///
/// Parameters:
/// - inUTI: A uniform type identifier.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// A URL that points to the bundle that holds the uniform type identifier’s declaration, or `NULL` if a bundle that holds the declaration cannot be located.
///
///
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyDeclaringBundleURL(
    in_uti: &CFString,
) -> Option<CFRetained<CFURL>> {
    extern "C-unwind" {
        fn UTTypeCopyDeclaringBundleURL(in_uti: &CFString) -> Option<NonNull<CFURL>>;
    }
    let ret = unsafe { UTTypeCopyDeclaringBundleURL(in_uti) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Encodes an `OSType` into a string suitable for use as a tag argument.
///
/// Parameters:
/// - inOSType: The `OSType` to convert.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// A string that encodes the OSType.
///
///
///
/// ## Discussion
///
/// The UTI functions assume that all alternate identifier tags can be represented as Core Foundation strings. OSTypes are integer-based rather than string-based, so to pass an OSType into a UTI function, you must call this function to convert it to a string.
///
///
#[deprecated = "HFS type codes are obsolete."]
#[inline]
pub unsafe extern "C-unwind" fn UTCreateStringForOSType(
    in_os_type: OSType,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn UTCreateStringForOSType(in_os_type: OSType) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { UTCreateStringForOSType(in_os_type) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    /// Decodes a tag string into an OSType.
    ///
    /// Parameters:
    /// - inString: A string that encodes an OSType.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// The OSType that was encoded in the string.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You call this function to convert an OSType string returned by a UTI function back into the integer-based OSType.
    ///
    ///
    #[deprecated = "HFS type codes are obsolete."]
    pub fn UTGetOSTypeFromString(in_string: &CFString) -> OSType;
}
