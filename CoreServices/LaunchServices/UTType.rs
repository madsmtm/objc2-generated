//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kutexportedtypedeclarationskey?language=objc)
    pub static kUTExportedTypeDeclarationsKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kutimportedtypedeclarationskey?language=objc)
    pub static kUTImportedTypeDeclarationsKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttypeidentifierkey?language=objc)
    pub static kUTTypeIdentifierKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttypetagspecificationkey?language=objc)
    pub static kUTTypeTagSpecificationKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttypeconformstokey?language=objc)
    pub static kUTTypeConformsToKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttypedescriptionkey?language=objc)
    pub static kUTTypeDescriptionKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttypeiconfilekey?language=objc)
    pub static kUTTypeIconFileKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttypereferenceurlkey?language=objc)
    pub static kUTTypeReferenceURLKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttypeversionkey?language=objc)
    pub static kUTTypeVersionKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttagclassfilenameextension?language=objc)
    #[deprecated = "Use UTTagClassFilenameExtension instead."]
    pub static kUTTagClassFilenameExtension: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttagclassmimetype?language=objc)
    #[deprecated = "Use UTTagClassMIMEType instead."]
    pub static kUTTagClassMIMEType: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttagclassnspboardtype?language=objc)
    #[deprecated = "NSPasteboard types are obsolete."]
    pub static kUTTagClassNSPboardType: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coreservices/kuttagclassostype?language=objc)
    #[deprecated = "HFS file types are obsolete."]
    pub static kUTTagClassOSType: &'static CFString;
}

#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCreatePreferredIdentifierForTag(
    in_tag_class: &CFString,
    in_tag: &CFString,
    in_conforming_to_uti: Option<&CFString>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn UTTypeCreatePreferredIdentifierForTag(
            in_tag_class: &CFString,
            in_tag: &CFString,
            in_conforming_to_uti: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe {
        UTTypeCreatePreferredIdentifierForTag(in_tag_class, in_tag, in_conforming_to_uti)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCreateAllIdentifiersForTag(
    in_tag_class: &CFString,
    in_tag: &CFString,
    in_conforming_to_uti: Option<&CFString>,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn UTTypeCreateAllIdentifiersForTag(
            in_tag_class: &CFString,
            in_tag: &CFString,
            in_conforming_to_uti: Option<&CFString>,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret =
        unsafe { UTTypeCreateAllIdentifiersForTag(in_tag_class, in_tag, in_conforming_to_uti) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyPreferredTagWithClass(
    in_uti: &CFString,
    in_tag_class: &CFString,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn UTTypeCopyPreferredTagWithClass(
            in_uti: &CFString,
            in_tag_class: &CFString,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { UTTypeCopyPreferredTagWithClass(in_uti, in_tag_class) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyAllTagsWithClass(
    in_uti: &CFString,
    in_tag_class: &CFString,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn UTTypeCopyAllTagsWithClass(
            in_uti: &CFString,
            in_tag_class: &CFString,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { UTTypeCopyAllTagsWithClass(in_uti, in_tag_class) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "Use -[UTType isEqual:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeEqual(in_uti1: &CFString, in_uti2: &CFString) -> bool {
    extern "C-unwind" {
        fn UTTypeEqual(in_uti1: &CFString, in_uti2: &CFString) -> Boolean;
    }
    let ret = unsafe { UTTypeEqual(in_uti1, in_uti2) };
    ret != 0
}

#[deprecated = "Use -[UTType conformsToType:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeConformsTo(
    in_uti: &CFString,
    in_conforms_to_uti: &CFString,
) -> bool {
    extern "C-unwind" {
        fn UTTypeConformsTo(in_uti: &CFString, in_conforms_to_uti: &CFString) -> Boolean;
    }
    let ret = unsafe { UTTypeConformsTo(in_uti, in_conforms_to_uti) };
    ret != 0
}

#[deprecated = "Use UTType.localizedDescription instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyDescription(
    in_uti: &CFString,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn UTTypeCopyDescription(in_uti: &CFString) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { UTTypeCopyDescription(in_uti) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "Use UTType.declared instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeIsDeclared(in_uti: &CFString) -> bool {
    extern "C-unwind" {
        fn UTTypeIsDeclared(in_uti: &CFString) -> Boolean;
    }
    let ret = unsafe { UTTypeIsDeclared(in_uti) };
    ret != 0
}

#[deprecated = "Use UTType.dynamic instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeIsDynamic(in_uti: &CFString) -> bool {
    extern "C-unwind" {
        fn UTTypeIsDynamic(in_uti: &CFString) -> Boolean;
    }
    let ret = unsafe { UTTypeIsDynamic(in_uti) };
    ret != 0
}

#[deprecated = "Use the UTType class instead."]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyDeclaration(
    in_uti: &CFString,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn UTTypeCopyDeclaration(in_uti: &CFString) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { UTTypeCopyDeclaration(in_uti) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn UTTypeCopyDeclaringBundleURL(
    in_uti: &CFString,
) -> Option<CFRetained<CFURL>> {
    extern "C-unwind" {
        fn UTTypeCopyDeclaringBundleURL(in_uti: &CFString) -> Option<NonNull<CFURL>>;
    }
    let ret = unsafe { UTTypeCopyDeclaringBundleURL(in_uti) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "HFS type codes are obsolete."]
#[inline]
pub unsafe extern "C-unwind" fn UTCreateStringForOSType(
    in_os_type: OSType,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn UTCreateStringForOSType(in_os_type: OSType) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { UTCreateStringForOSType(in_os_type) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "HFS type codes are obsolete."]
    pub fn UTGetOSTypeFromString(in_string: &CFString) -> OSType;
}
