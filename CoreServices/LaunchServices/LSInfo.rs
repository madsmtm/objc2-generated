//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coreservices/lsacceptanceflags?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct LSAcceptanceFlags(pub OptionBits);
bitflags::bitflags! {
    impl LSAcceptanceFlags: OptionBits {
        #[doc(alias = "kLSAcceptDefault")]
        const AcceptDefault = 0x00000001;
        #[doc(alias = "kLSAcceptAllowLoginUI")]
        const AcceptAllowLoginUI = 0x00000002;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for LSAcceptanceFlags {
    const ENCODING: Encoding = OptionBits::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for LSAcceptanceFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Return the application used to open an item.
///
///
/// Consults the binding tables to return the application that would
/// be used to open inURL if it were double-clicked in the
/// Finder. This application will be the user-specified override if
/// appropriate or the default otherwise.
///
///
/// Parameter `inURL`: The URL of the item for which the application is requested.
///
///
/// Parameter `inRoleMask`: Whether to return the editor or viewer for inURL. If you
/// don't care which, use kLSRolesAll.
///
///
/// Parameter `outError`: On failure, set to a CFError describing the problem. If you are
/// not interested in this information, pass NULL. The caller is
/// responsible for releasing this object.
///
///
/// Returns: If an acceptable application is found, its URL is returned.
/// If the URL is a file:// URL, the application bound to the specified
/// file or directory's type is returned. If the URL's scheme is something
/// else, its default scheme handler is returned. If no application could
/// be found, NULL is returned and outError (if not NULL) is populated.
/// with kLSApplicationNotFoundErr.
/// The caller is responsible for releasing this URL.
///
/// # Safety
///
/// `out_error` must be a valid pointer or null.
#[cfg(feature = "LSConstants")]
#[deprecated = "Use -[NSWorkspace URLForApplicationToOpenURL:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn LSCopyDefaultApplicationURLForURL(
    in_url: &CFURL,
    in_role_mask: LSRolesMask,
    out_error: *mut *mut CFError,
) -> Option<CFRetained<CFURL>> {
    extern "C-unwind" {
        fn LSCopyDefaultApplicationURLForURL(
            in_url: &CFURL,
            in_role_mask: LSRolesMask,
            out_error: *mut *mut CFError,
        ) -> Option<NonNull<CFURL>>;
    }
    let ret = unsafe { LSCopyDefaultApplicationURLForURL(in_url, in_role_mask, out_error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Return the application used to open a content type (UTI).
///
///
/// Consults the binding tables to return the application that would
/// be used to open a file of type inContentType if it were double-clicked
/// in the Finder. This application will be the user-specified override if
/// appropriate or the default otherwise.
///
///
/// Parameter `inContentType`: The Uniform Type Identifier (UTI) of the item for which the
/// application is requested.
///
///
/// Parameter `inRoleMask`: Whether to return the editor or viewer for inContentType. If you
/// don't care which, use kLSRolesAll.
///
///
/// Parameter `outError`: On failure, set to a CFError describing the problem. If you are
/// not interested in this information, pass NULL. The caller is
/// responsible for releasing this object.
///
///
/// Returns: If an acceptable application is found, its URL is returned.
/// If no application could be found, NULL is returned and
/// outError (if not NULL) is populated with kLSApplicationNotFoundErr.
/// The caller is responsible for releasing this URL.
///
/// # Safety
///
/// `out_error` must be a valid pointer or null.
#[cfg(feature = "LSConstants")]
#[deprecated = "Use -[NSWorkspace URLForApplicationToOpenContentType:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn LSCopyDefaultApplicationURLForContentType(
    in_content_type: &CFString,
    in_role_mask: LSRolesMask,
    out_error: *mut *mut CFError,
) -> Option<CFRetained<CFURL>> {
    extern "C-unwind" {
        fn LSCopyDefaultApplicationURLForContentType(
            in_content_type: &CFString,
            in_role_mask: LSRolesMask,
            out_error: *mut *mut CFError,
        ) -> Option<NonNull<CFURL>>;
    }
    let ret = unsafe {
        LSCopyDefaultApplicationURLForContentType(in_content_type, in_role_mask, out_error)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Given a bundle identifier (such as com.apple.finder), find all URLs to the corresponding application.
///
///
/// Returns zero or more URLs to applications that have the specified
/// bundle identifier.
///
///
/// Parameter `inBundleIdentifier`: The bundle identifier of interest, such as "com.apple.finder". Must
/// not be NULL.
///
///
/// Parameter `outError`: On failure, set to a CFError describing the problem. If you are
/// not interested in this information, pass NULL. The caller is
/// responsible for releasing this object.
///
///
/// Returns: If any applications with the specified bundle identifier are found,
/// their URLs are returned in a CFArray. If no application could be found,
/// NULL is returned and outError (if not NULL) is populated with kLSApplicationNotFoundErr.
/// In macOS 10.15 and later, the returned array is sorted with the first element containing the
/// best available application with the specified bundle identifier. Prior to macOS 10.15, the
/// order of elements in the array was undefined.
///
/// # Safety
///
/// `out_error` must be a valid pointer or null.
#[deprecated = "Use -[NSWorkspace URLsForApplicationsWithBundleIdentifier:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn LSCopyApplicationURLsForBundleIdentifier(
    in_bundle_identifier: &CFString,
    out_error: *mut *mut CFError,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSCopyApplicationURLsForBundleIdentifier(
            in_bundle_identifier: &CFString,
            out_error: *mut *mut CFError,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSCopyApplicationURLsForBundleIdentifier(in_bundle_identifier, out_error) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns an array of URLs to applications that offer the requested
/// role(s) for the input item.
///
///
/// Parameter `inURL`: The CFURLRef of the item for which all suitable applications
/// are desired. If the URL is a file URL, it is treated as a
/// document, and applications are selected based on the document's
/// type information. Otherwise, applications are selected based on
/// the URL's scheme.
///
///
/// Parameter `inRoleMask`: The role(s) which must intersect with the role provided by an
/// application for the specified item in order for the application
/// to be included in the result. Pass kLSRolesAll if any role is
/// acceptable.
///
///
/// Returns: An array of CFURLRefs, one for each application which can open
/// inURL with at least one of the roles in inRoleMask, or NULL if no
/// applications can open the item. When an array is returned, you
/// must eventually release it.
///
/// The order of the resulting array is undefined. If you need the
/// default application for the specified URL, use LSCopyDefaultApplicationURLForURL.
#[cfg(feature = "LSConstants")]
#[deprecated = "Use -[NSWorkspace URLsForApplicationsToOpenURL:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn LSCopyApplicationURLsForURL(
    in_url: &CFURL,
    in_role_mask: LSRolesMask,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSCopyApplicationURLsForURL(
            in_url: &CFURL,
            in_role_mask: LSRolesMask,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSCopyApplicationURLsForURL(in_url, in_role_mask) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Determine whether an item can accept another item.
    ///
    ///
    /// Returns in outAcceptsItem whether inTargetURL can accept
    /// inItemURL as in a drag and drop operation. If inRoleMask is other
    /// than kLSRolesAll then make sure inTargetRef claims to fulfill the
    /// requested role.
    ///
    ///
    /// Parameter `inItemURL`: CFURLRef of the item about which acceptance is requested.
    ///
    ///
    /// Parameter `inTargetURL`: CFURLRef of the potential target.
    ///
    ///
    /// Parameter `inRoleMask`: The role(s) the target must claim in order to consider
    /// acceptance.
    ///
    ///
    /// Parameter `inFlags`: Use kLSAcceptDefault.
    ///
    ///
    /// Parameter `outAcceptsItem`: Filled in with result. Must not be NULL.
    ///
    /// # Safety
    ///
    /// `out_accepts_item` must be a valid pointer.
    #[cfg(feature = "LSConstants")]
    pub fn LSCanURLAcceptURL(
        in_item_url: &CFURL,
        in_target_url: &CFURL,
        in_role_mask: LSRolesMask,
        in_flags: LSAcceptanceFlags,
        out_accepts_item: NonNull<Boolean>,
    ) -> OSStatus;
}

/// If the specified URL refers to an application or other bundle
/// claiming to handle documents or URLs, add the bundle's document
/// and URL claims to the Launch Services database.
///
///
/// Parameter `inURL`: The CFURLRef of the item (a directory or file) to be registered.
///
///
/// Parameter `inUpdate`: When false, LSRegisterURL does not register the item if it has
/// already been registered and the current modification date of
/// the item has not changed from when it was last registered. When
/// true, the item's registered info is updated, even if the
/// modification has not changed.
///
///
/// Returns: An OSStatus value: noErr - Success kLSNoRegistrationInfoErr - The
/// item does not contain info requiring registration kLSDataErr -
/// The item's property list info is malformed.
#[inline]
pub unsafe extern "C-unwind" fn LSRegisterURL(in_url: &CFURL, in_update: bool) -> OSStatus {
    extern "C-unwind" {
        fn LSRegisterURL(in_url: &CFURL, in_update: Boolean) -> OSStatus;
    }
    unsafe { LSRegisterURL(in_url, in_update as _) }
}

/// Returns the application bundle identifier of the default handler
/// for the specified content type (UTI), in the specified role(s).
/// For any role, specify kLSRolesAll. Returns NULL if no handler
/// is available.
///
///
/// Parameter `inContentType`: a string UTI type identifier
///
/// Parameter `inRole`: a LSRole
///
///
/// Returns: an application bundle identifier which is the default handler for the given type and role, or NULL if there is no default handler
#[cfg(feature = "LSConstants")]
#[deprecated = "Use -[NSWorkspace URLForApplicationToOpenContentType:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn LSCopyDefaultRoleHandlerForContentType(
    in_content_type: &CFString,
    in_role: LSRolesMask,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn LSCopyDefaultRoleHandlerForContentType(
            in_content_type: &CFString,
            in_role: LSRolesMask,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { LSCopyDefaultRoleHandlerForContentType(in_content_type, in_role) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns an array of application bundle identifiers for
/// applications capable of handling the specified content type
/// (UTI) with the specified role(s). Application content handling
/// capabilities are determined according to the kCFBundleDocumentTypes
/// listed in an application's Info.plist). For any role, specify kLSRolesAll.
/// Returns NULL if no handlers are available.
///
///
/// Parameter `inContentType`: a string UTI type identifier
///
/// Parameter `inRole`: a LSRole
///
///
/// Returns: an array of of CFStringRef bundle identifiers, or NULL
#[cfg(feature = "LSConstants")]
#[deprecated = "Use -[NSWorkspace URLsForApplicationsToOpenContentType:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn LSCopyAllRoleHandlersForContentType(
    in_content_type: &CFString,
    in_role: LSRolesMask,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSCopyAllRoleHandlersForContentType(
            in_content_type: &CFString,
            in_role: LSRolesMask,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSCopyAllRoleHandlersForContentType(in_content_type, in_role) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Sets the user's preferred handler for the specified content
    /// type (UTI) in the specified role(s). For all roles, specify
    /// kLSRolesAll. The handler is specified as an application
    /// bundle identifier.
    ///
    ///
    /// Parameter `inContentType`: a string UTI type identifier
    ///
    /// Parameter `inRole`: the role type(s) to set
    ///
    /// Parameter `inHandlerBundleID`: the bundle identifier to set as the default handler for the given contet type and role(s)
    ///
    ///
    /// Returns: noErr on success, or an error indicating why the call failed
    #[cfg(feature = "LSConstants")]
    #[deprecated = "Use -[NSWorkspace setDefaultApplicationAtURL:toOpenContentType:completionHandler:] instead."]
    pub fn LSSetDefaultRoleHandlerForContentType(
        in_content_type: &CFString,
        in_role: LSRolesMask,
        in_handler_bundle_id: &CFString,
    ) -> OSStatus;
}

/// Returns the bundle identifier of the default handler for
/// the specified URL scheme. Returns NULL if no handler
/// is available.
///
///
/// Parameter `inURLScheme`: the scheme to return the default handler bundle identifier for
///
///
/// Returns: a CFStringRef bundle identifier of the default handler, or NULL if no handler is available
#[deprecated = "Use -[NSWorkspace URLForApplicationToOpenURL:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn LSCopyDefaultHandlerForURLScheme(
    in_url_scheme: &CFString,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn LSCopyDefaultHandlerForURLScheme(in_url_scheme: &CFString) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { LSCopyDefaultHandlerForURLScheme(in_url_scheme) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Returns an array of application bundle identifiers for
/// applications capable of handling the specified URL scheme.
/// URL handling capability is determined according to the
/// kCFBundleURLTypes listed in an application's Info.plist).
/// Returns NULL if no handlers are available.
///
///
/// Parameter `inURLScheme`: the scheme to return an array of bundle identifiers for applications capable of handling the scheme
///
///
/// Returns: An array of bundle identifier strings
#[deprecated = "Use -[NSWorkspace URLsForApplicationsToOpenURL:] instead."]
#[inline]
pub unsafe extern "C-unwind" fn LSCopyAllHandlersForURLScheme(
    in_url_scheme: &CFString,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSCopyAllHandlersForURLScheme(in_url_scheme: &CFString) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSCopyAllHandlersForURLScheme(in_url_scheme) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Sets the user's preferred handler for the specified URL
    /// scheme. The handler is specified as an application
    /// bundle identifier.
    ///
    ///
    /// Parameter `inURLScheme`: the url scheme to set a default handler for
    ///
    /// Parameter `inHandlerBundleID`: the bundle identifier to be set as the default handler for the given scheme
    #[deprecated = "Use -[NSWorkspace setDefaultApplicationAtURL:toOpenURLsWithScheme:completionHandler:] instead."]
    pub fn LSSetDefaultHandlerForURLScheme(
        in_url_scheme: &CFString,
        in_handler_bundle_id: &CFString,
    ) -> OSStatus;
}
