// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "LatentSemanticMapping", kind = "framework")]
extern "C" {}

use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapoutofstate?language=objc)
pub const kLSMMapOutOfState: c_int = -6640;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapnosuchcategory?language=objc)
pub const kLSMMapNoSuchCategory: c_int = -6641;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapwriteerror?language=objc)
pub const kLSMMapWriteError: c_int = -6642;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapbadpath?language=objc)
pub const kLSMMapBadPath: c_int = -6643;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapbadcluster?language=objc)
pub const kLSMMapBadCluster: c_int = -6644;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapoverflow?language=objc)
pub const kLSMMapOverflow: c_int = -6645;

/// An opaque Core Foundation type representing an LSM map (mutable).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/lsmmap?language=objc)
#[repr(C)]
pub struct LSMMap {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl LSMMap {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__LSMMap"> for LSMMap {}
);

unsafe impl ConcreteType for LSMMap {
    /// Returns the Core Foundation type identifier for LSM maps.
    #[doc(alias = "LSMMapGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn LSMMapGetTypeID() -> CFTypeID;
        }
        unsafe { LSMMapGetTypeID() }
    }
}

/// An opaque Core Foundation type representing an input text (mutable).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/lsmtext?language=objc)
#[repr(C)]
pub struct LSMText {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl LSMText {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__LSMText"> for LSMText {}
);

unsafe impl ConcreteType for LSMText {
    /// Returns the Core Foundation type identifier for LSM texts.
    #[doc(alias = "LSMTextGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn LSMTextGetTypeID() -> CFTypeID;
        }
        unsafe { LSMTextGetTypeID() }
    }
}

/// An opaque Core Foundation type representing the result of a lookup (immutable).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/lsmresult?language=objc)
#[repr(C)]
pub struct LSMResult {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl LSMResult {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__LSMResult"> for LSMResult {}
);

unsafe impl ConcreteType for LSMResult {
    /// Returns the Core Foundation type identifier for LSM results.
    #[doc(alias = "LSMResultGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn LSMResultGetTypeID() -> CFTypeID;
        }
        unsafe { LSMResultGetTypeID() }
    }
}

/// An integral type representing a category.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/lsmcategory?language=objc)
pub type LSMCategory = u32;

impl LSMMap {
    /// Creates a new LSM map. Call CFRelease to dispose.
    #[doc(alias = "LSMMapCreate")]
    #[inline]
    pub unsafe fn new(alloc: Option<&CFAllocator>, flags: CFOptionFlags) -> CFRetained<LSMMap> {
        extern "C-unwind" {
            fn LSMMapCreate(
                alloc: Option<&CFAllocator>,
                flags: CFOptionFlags,
            ) -> Option<NonNull<LSMMap>>;
        }
        let ret = unsafe { LSMMapCreate(alloc, flags) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmappairs?language=objc)
pub const kLSMMapPairs: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmaptriplets?language=objc)
pub const kLSMMapTriplets: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmaphashtext?language=objc)
pub const kLSMMapHashText: c_uint = 256;

impl LSMMap {
    /// Set a dictionary of properties for the map. LSM makes its own copy
    /// of the properties, there's no need to retain them past this call.
    ///
    /// # Safety
    ///
    /// `properties` generics must be of the correct type.
    #[doc(alias = "LSMMapSetProperties")]
    #[inline]
    pub unsafe fn set_properties(&self, properties: &CFDictionary) {
        extern "C-unwind" {
            fn LSMMapSetProperties(mapref: &LSMMap, properties: &CFDictionary);
        }
        unsafe { LSMMapSetProperties(self, properties) }
    }

    /// Get a dictionary of properties for the map. LSM retains ownership of
    /// this dictionary, do not release it.
    #[doc(alias = "LSMMapGetProperties")]
    #[inline]
    pub unsafe fn properties(&self) -> CFRetained<CFDictionary> {
        extern "C-unwind" {
            fn LSMMapGetProperties(mapref: &LSMMap) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { LSMMapGetProperties(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Puts the map into training mode, preparing it for the addition of more
    /// categories and/or texts. This function will be somewhat expensive, as it
    /// requires substantial data structure reorganization.
    #[doc(alias = "LSMMapStartTraining")]
    #[inline]
    pub unsafe fn start_training(&self) -> OSStatus {
        extern "C-unwind" {
            fn LSMMapStartTraining(mapref: &LSMMap) -> OSStatus;
        }
        unsafe { LSMMapStartTraining(self) }
    }

    /// Adds another category and returns its category identifier.
    #[doc(alias = "LSMMapAddCategory")]
    #[inline]
    pub unsafe fn add_category(&self) -> LSMCategory {
        extern "C-unwind" {
            fn LSMMapAddCategory(mapref: &LSMMap) -> LSMCategory;
        }
        unsafe { LSMMapAddCategory(self) }
    }

    /// Returns the number of categories in the map.
    #[doc(alias = "LSMMapGetCategoryCount")]
    #[inline]
    pub unsafe fn category_count(&self) -> CFIndex {
        extern "C-unwind" {
            fn LSMMapGetCategoryCount(mapref: &LSMMap) -> CFIndex;
        }
        unsafe { LSMMapGetCategoryCount(self) }
    }

    /// The specified words will be omitted from all classification efforts.
    /// Needs to be called before any other texts are created.
    /// The textref is no longer needed after this call.
    #[doc(alias = "LSMMapSetStopWords")]
    #[inline]
    pub unsafe fn set_stop_words(&self, textref: &LSMText) -> OSStatus {
        extern "C-unwind" {
            fn LSMMapSetStopWords(mapref: &LSMMap, textref: &LSMText) -> OSStatus;
        }
        unsafe { LSMMapSetStopWords(self, textref) }
    }

    /// Adds a training text to the given category.
    /// The textref is no longer needed after this call.
    #[doc(alias = "LSMMapAddText")]
    #[inline]
    pub unsafe fn add_text(&self, textref: &LSMText, category: LSMCategory) -> OSStatus {
        extern "C-unwind" {
            fn LSMMapAddText(mapref: &LSMMap, textref: &LSMText, category: LSMCategory)
                -> OSStatus;
        }
        unsafe { LSMMapAddText(self, textref, category) }
    }

    /// Adds a training text to the given category with a weight different from 1.
    /// The weight may be negative, but global counts will be pinned to 0.
    /// The textref is no longer needed after this call.
    #[doc(alias = "LSMMapAddTextWithWeight")]
    #[inline]
    pub unsafe fn add_text_with_weight(
        &self,
        textref: &LSMText,
        category: LSMCategory,
        weight: c_float,
    ) -> OSStatus {
        extern "C-unwind" {
            fn LSMMapAddTextWithWeight(
                mapref: &LSMMap,
                textref: &LSMText,
                category: LSMCategory,
                weight: c_float,
            ) -> OSStatus;
        }
        unsafe { LSMMapAddTextWithWeight(self, textref, category, weight) }
    }

    /// Compiles the map into executable form and puts it into mapping mode,
    /// preparing it for the classification of texts. This function is
    /// computationally expensive.
    #[doc(alias = "LSMMapCompile")]
    #[inline]
    pub unsafe fn compile(&self) -> OSStatus {
        extern "C-unwind" {
            fn LSMMapCompile(mapref: &LSMMap) -> OSStatus;
        }
        unsafe { LSMMapCompile(self) }
    }

    /// Compute a set of clusters grouping similar categories or words.
    /// If subset is non-NULL, only perform clustering on the categories
    /// or words listed.
    ///
    /// # Safety
    ///
    /// `subset` generic must be of the correct type.
    #[doc(alias = "LSMMapCreateClusters")]
    #[inline]
    pub unsafe fn new_clusters(
        alloc: Option<&CFAllocator>,
        mapref: &LSMMap,
        subset: Option<&CFArray>,
        num_clusters: CFIndex,
        flags: CFOptionFlags,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn LSMMapCreateClusters(
                alloc: Option<&CFAllocator>,
                mapref: &LSMMap,
                subset: Option<&CFArray>,
                num_clusters: CFIndex,
                flags: CFOptionFlags,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { LSMMapCreateClusters(alloc, mapref, subset, num_clusters, flags) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclustercategories?language=objc)
pub const kLSMClusterCategories: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclusterwords?language=objc)
pub const kLSMClusterWords: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclustertokens?language=objc)
pub const kLSMClusterTokens: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclusterkmeans?language=objc)
pub const kLSMClusterKMeans: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmclusteragglomerative?language=objc)
pub const kLSMClusterAgglomerative: c_uint = 4;

impl LSMMap {
    /// Group categories or words (tokens) into the specified sets of clusters.
    ///
    /// # Safety
    ///
    /// `clusters` generic must be of the correct type.
    #[doc(alias = "LSMMapApplyClusters")]
    #[inline]
    pub unsafe fn apply_clusters(&self, clusters: &CFArray) -> OSStatus {
        extern "C-unwind" {
            fn LSMMapApplyClusters(mapref: &LSMMap, clusters: &CFArray) -> OSStatus;
        }
        unsafe { LSMMapApplyClusters(self, clusters) }
    }
}

impl LSMResult {
    /// Returns, in decreasing order of likelihood, the categories or words
    /// that best match when a text is mapped into a map.
    #[doc(alias = "LSMResultCreate")]
    #[inline]
    pub unsafe fn new(
        alloc: Option<&CFAllocator>,
        mapref: &LSMMap,
        textref: &LSMText,
        num_results: CFIndex,
        flags: CFOptionFlags,
    ) -> CFRetained<LSMResult> {
        extern "C-unwind" {
            fn LSMResultCreate(
                alloc: Option<&CFAllocator>,
                mapref: &LSMMap,
                textref: &LSMText,
                num_results: CFIndex,
                flags: CFOptionFlags,
            ) -> Option<NonNull<LSMResult>>;
        }
        let ret = unsafe { LSMResultCreate(alloc, mapref, textref, num_results, flags) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmresultbestwords?language=objc)
pub const kLSMResultBestWords: c_uint = 1;

impl LSMResult {
    /// Returns the number of results.
    #[doc(alias = "LSMResultGetCount")]
    #[inline]
    pub unsafe fn count(&self) -> CFIndex {
        extern "C-unwind" {
            fn LSMResultGetCount(result: &LSMResult) -> CFIndex;
        }
        unsafe { LSMResultGetCount(self) }
    }

    /// Returns the category of the n-th best (zero based) result.
    #[doc(alias = "LSMResultGetCategory")]
    #[inline]
    pub unsafe fn category(&self, n: CFIndex) -> LSMCategory {
        extern "C-unwind" {
            fn LSMResultGetCategory(result: &LSMResult, n: CFIndex) -> LSMCategory;
        }
        unsafe { LSMResultGetCategory(self, n) }
    }

    /// Returns the likelihood of the n-th best (zero based) result.
    /// A nan score often indicates that the category does not contain
    /// any token.
    #[doc(alias = "LSMResultGetScore")]
    #[inline]
    pub unsafe fn score(&self, n: CFIndex) -> c_float {
        extern "C-unwind" {
            fn LSMResultGetScore(result: &LSMResult, n: CFIndex) -> c_float;
        }
        unsafe { LSMResultGetScore(self, n) }
    }

    /// Returns the word for the n-th best (zero based) result.
    #[doc(alias = "LSMResultCopyWord")]
    #[inline]
    pub unsafe fn word(&self, n: CFIndex) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn LSMResultCopyWord(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { LSMResultCopyWord(self, n) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the token for the n-th best (zero based) result.
    #[doc(alias = "LSMResultCopyToken")]
    #[inline]
    pub unsafe fn token(&self, n: CFIndex) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn LSMResultCopyToken(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { LSMResultCopyToken(self, n) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the cluster of words for the n-th best (zero based) result.
    #[doc(alias = "LSMResultCopyWordCluster")]
    #[inline]
    pub unsafe fn word_cluster(&self, n: CFIndex) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn LSMResultCopyWordCluster(result: &LSMResult, n: CFIndex)
                -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { LSMResultCopyWordCluster(self, n) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the cluster of tokens for the n-th best (zero based) result.
    #[doc(alias = "LSMResultCopyTokenCluster")]
    #[inline]
    pub unsafe fn token_cluster(&self, n: CFIndex) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn LSMResultCopyTokenCluster(
                result: &LSMResult,
                n: CFIndex,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { LSMResultCopyTokenCluster(self, n) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl LSMMap {
    /// Compiles the map if necessary and then stores it into the given file.
    #[doc(alias = "LSMMapWriteToURL")]
    #[inline]
    pub unsafe fn write_to_url(&self, file: &CFURL, flags: CFOptionFlags) -> OSStatus {
        extern "C-unwind" {
            fn LSMMapWriteToURL(mapref: &LSMMap, file: &CFURL, flags: CFOptionFlags) -> OSStatus;
        }
        unsafe { LSMMapWriteToURL(self, file, flags) }
    }

    /// Loads a map from a given file.
    #[doc(alias = "LSMMapCreateFromURL")]
    #[inline]
    pub unsafe fn from_url(
        alloc: Option<&CFAllocator>,
        file: &CFURL,
        flags: CFOptionFlags,
    ) -> Option<CFRetained<LSMMap>> {
        extern "C-unwind" {
            fn LSMMapCreateFromURL(
                alloc: Option<&CFAllocator>,
                file: &CFURL,
                flags: CFOptionFlags,
            ) -> Option<NonNull<LSMMap>>;
        }
        let ret = unsafe { LSMMapCreateFromURL(alloc, file, flags) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmapdiscardcounts?language=objc)
pub const kLSMMapDiscardCounts: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmmaploadmutable?language=objc)
pub const kLSMMapLoadMutable: c_uint = 2;

impl LSMMap {
    /// Writes information about a map and/or text to a stream in text form
    #[doc(alias = "LSMMapWriteToStream")]
    #[inline]
    pub unsafe fn write_to_stream(
        &self,
        textref: Option<&LSMText>,
        stream: &CFWriteStream,
        options: CFOptionFlags,
    ) -> OSStatus {
        extern "C-unwind" {
            fn LSMMapWriteToStream(
                mapref: &LSMMap,
                textref: Option<&LSMText>,
                stream: &CFWriteStream,
                options: CFOptionFlags,
            ) -> OSStatus;
        }
        unsafe { LSMMapWriteToStream(self, textref, stream, options) }
    }
}

impl LSMText {
    /// Creates a new text.
    #[doc(alias = "LSMTextCreate")]
    #[inline]
    pub unsafe fn new(alloc: Option<&CFAllocator>, mapref: &LSMMap) -> CFRetained<LSMText> {
        extern "C-unwind" {
            fn LSMTextCreate(
                alloc: Option<&CFAllocator>,
                mapref: &LSMMap,
            ) -> Option<NonNull<LSMText>>;
        }
        let ret = unsafe { LSMTextCreate(alloc, mapref) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Adds a word to the text. The order of words is significant if the map
    /// uses pairs or triplets, and the count of words is always significant.
    #[doc(alias = "LSMTextAddWord")]
    #[inline]
    pub unsafe fn add_word(&self, word: &CFString) -> OSStatus {
        extern "C-unwind" {
            fn LSMTextAddWord(textref: &LSMText, word: &CFString) -> OSStatus;
        }
        unsafe { LSMTextAddWord(self, word) }
    }

    /// Breaks a string into words using the locale provided and adds the words
    /// to the text.
    #[doc(alias = "LSMTextAddWords")]
    #[inline]
    pub unsafe fn add_words(
        &self,
        words: &CFString,
        locale: Option<&CFLocale>,
        flags: CFOptionFlags,
    ) -> OSStatus {
        extern "C-unwind" {
            fn LSMTextAddWords(
                textref: &LSMText,
                words: &CFString,
                locale: Option<&CFLocale>,
                flags: CFOptionFlags,
            ) -> OSStatus;
        }
        unsafe { LSMTextAddWords(self, words, locale, flags) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmtextpreservecase?language=objc)
pub const kLSMTextPreserveCase: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmtextpreserveacronyms?language=objc)
pub const kLSMTextPreserveAcronyms: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/latentsemanticmapping/klsmtextapplyspamheuristics?language=objc)
pub const kLSMTextApplySpamHeuristics: c_uint = 4;

impl LSMText {
    /// Adds an arbitrary binary token to the text. The order of tokens is
    /// significant if the map uses pairs or triplets, and the count of
    /// tokens is always significant.
    #[doc(alias = "LSMTextAddToken")]
    #[inline]
    pub unsafe fn add_token(&self, token: &CFData) -> OSStatus {
        extern "C-unwind" {
            fn LSMTextAddToken(textref: &LSMText, token: &CFData) -> OSStatus;
        }
        unsafe { LSMTextAddToken(self, token) }
    }
}

#[deprecated = "renamed to `LSMMap::new`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMMapCreate(
    alloc: Option<&CFAllocator>,
    flags: CFOptionFlags,
) -> CFRetained<LSMMap> {
    extern "C-unwind" {
        fn LSMMapCreate(
            alloc: Option<&CFAllocator>,
            flags: CFOptionFlags,
        ) -> Option<NonNull<LSMMap>>;
    }
    let ret = unsafe { LSMMapCreate(alloc, flags) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::set_properties`"]
    pub fn LSMMapSetProperties(mapref: &LSMMap, properties: &CFDictionary);
}

#[deprecated = "renamed to `LSMMap::properties`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMMapGetProperties(mapref: &LSMMap) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn LSMMapGetProperties(mapref: &LSMMap) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { LSMMapGetProperties(mapref) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::start_training`"]
    pub fn LSMMapStartTraining(mapref: &LSMMap) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::add_category`"]
    pub fn LSMMapAddCategory(mapref: &LSMMap) -> LSMCategory;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::category_count`"]
    pub fn LSMMapGetCategoryCount(mapref: &LSMMap) -> CFIndex;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::set_stop_words`"]
    pub fn LSMMapSetStopWords(mapref: &LSMMap, textref: &LSMText) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::add_text`"]
    pub fn LSMMapAddText(mapref: &LSMMap, textref: &LSMText, category: LSMCategory) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::add_text_with_weight`"]
    pub fn LSMMapAddTextWithWeight(
        mapref: &LSMMap,
        textref: &LSMText,
        category: LSMCategory,
        weight: c_float,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::compile`"]
    pub fn LSMMapCompile(mapref: &LSMMap) -> OSStatus;
}

#[deprecated = "renamed to `LSMMap::new_clusters`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMMapCreateClusters(
    alloc: Option<&CFAllocator>,
    mapref: &LSMMap,
    subset: Option<&CFArray>,
    num_clusters: CFIndex,
    flags: CFOptionFlags,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSMMapCreateClusters(
            alloc: Option<&CFAllocator>,
            mapref: &LSMMap,
            subset: Option<&CFArray>,
            num_clusters: CFIndex,
            flags: CFOptionFlags,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSMMapCreateClusters(alloc, mapref, subset, num_clusters, flags) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::apply_clusters`"]
    pub fn LSMMapApplyClusters(mapref: &LSMMap, clusters: &CFArray) -> OSStatus;
}

#[deprecated = "renamed to `LSMResult::new`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCreate(
    alloc: Option<&CFAllocator>,
    mapref: &LSMMap,
    textref: &LSMText,
    num_results: CFIndex,
    flags: CFOptionFlags,
) -> CFRetained<LSMResult> {
    extern "C-unwind" {
        fn LSMResultCreate(
            alloc: Option<&CFAllocator>,
            mapref: &LSMMap,
            textref: &LSMText,
            num_results: CFIndex,
            flags: CFOptionFlags,
        ) -> Option<NonNull<LSMResult>>;
    }
    let ret = unsafe { LSMResultCreate(alloc, mapref, textref, num_results, flags) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMResult::count`"]
    pub fn LSMResultGetCount(result: &LSMResult) -> CFIndex;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMResult::category`"]
    pub fn LSMResultGetCategory(result: &LSMResult, n: CFIndex) -> LSMCategory;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMResult::score`"]
    pub fn LSMResultGetScore(result: &LSMResult, n: CFIndex) -> c_float;
}

#[deprecated = "renamed to `LSMResult::word`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCopyWord(
    result: &LSMResult,
    n: CFIndex,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn LSMResultCopyWord(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { LSMResultCopyWord(result, n) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `LSMResult::token`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCopyToken(
    result: &LSMResult,
    n: CFIndex,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn LSMResultCopyToken(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { LSMResultCopyToken(result, n) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `LSMResult::word_cluster`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCopyWordCluster(
    result: &LSMResult,
    n: CFIndex,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSMResultCopyWordCluster(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSMResultCopyWordCluster(result, n) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `LSMResult::token_cluster`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMResultCopyTokenCluster(
    result: &LSMResult,
    n: CFIndex,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn LSMResultCopyTokenCluster(result: &LSMResult, n: CFIndex) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { LSMResultCopyTokenCluster(result, n) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::write_to_url`"]
    pub fn LSMMapWriteToURL(mapref: &LSMMap, file: &CFURL, flags: CFOptionFlags) -> OSStatus;
}

#[deprecated = "renamed to `LSMMap::from_url`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMMapCreateFromURL(
    alloc: Option<&CFAllocator>,
    file: &CFURL,
    flags: CFOptionFlags,
) -> Option<CFRetained<LSMMap>> {
    extern "C-unwind" {
        fn LSMMapCreateFromURL(
            alloc: Option<&CFAllocator>,
            file: &CFURL,
            flags: CFOptionFlags,
        ) -> Option<NonNull<LSMMap>>;
    }
    let ret = unsafe { LSMMapCreateFromURL(alloc, file, flags) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMMap::write_to_stream`"]
    pub fn LSMMapWriteToStream(
        mapref: &LSMMap,
        textref: Option<&LSMText>,
        stream: &CFWriteStream,
        options: CFOptionFlags,
    ) -> OSStatus;
}

#[deprecated = "renamed to `LSMText::new`"]
#[inline]
pub unsafe extern "C-unwind" fn LSMTextCreate(
    alloc: Option<&CFAllocator>,
    mapref: &LSMMap,
) -> CFRetained<LSMText> {
    extern "C-unwind" {
        fn LSMTextCreate(alloc: Option<&CFAllocator>, mapref: &LSMMap) -> Option<NonNull<LSMText>>;
    }
    let ret = unsafe { LSMTextCreate(alloc, mapref) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMText::add_word`"]
    pub fn LSMTextAddWord(textref: &LSMText, word: &CFString) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMText::add_words`"]
    pub fn LSMTextAddWords(
        textref: &LSMText,
        words: &CFString,
        locale: Option<&CFLocale>,
        flags: CFOptionFlags,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `LSMText::add_token`"]
    pub fn LSMTextAddToken(textref: &LSMText, token: &CFData) -> OSStatus;
}
