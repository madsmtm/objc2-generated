//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An object that uniquely identifies a push notification that a container sends.
    ///
    /// ## Overview
    ///
    /// You don’t create notification IDs directly. The server creates them when it creates instances of [`CKNotification`](https://developer.apple.com/documentation/cloudkit/cknotification) that correspond to the push notifications that CloudKit sends to your app. You can compare two IDs using the [`isEqual:`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/isequal(_:)) method to determine whether two notifications are the same. This class defines no methods or properties.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKNotificationID;
);

extern_conformance!(
    unsafe impl NSCoding for CKNotificationID {}
);

extern_conformance!(
    unsafe impl NSCopying for CKNotificationID {}
);

unsafe impl CopyingHelper for CKNotificationID {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKNotificationID {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CKNotificationID {}
);

impl CKNotificationID {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl CKNotificationID {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Constants that indicate the type of event that generates the push notification.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CKNotificationType(pub NSInteger);
impl CKNotificationType {
    /// A notification that CloudKit generates from a query subscription’s predicate.
    /// Generated by ``CKQuerySubscription``s
    #[doc(alias = "CKNotificationTypeQuery")]
    pub const Query: Self = Self(1);
    /// A notification that CloudKit generates when the contents of a record zone change.
    /// Generated by ``CKRecordZoneSubscription``s
    #[doc(alias = "CKNotificationTypeRecordZone")]
    pub const RecordZone: Self = Self(2);
    /// A notification that your app marks as read.
    /// Indicates a notification that a client had previously marked as read
    #[doc(alias = "CKNotificationTypeReadNotification")]
    pub const ReadNotification: Self = Self(3);
    /// A notification that CloudKit generates when the contents of a database change.
    /// Generated by ``CKDatabaseSubscription``s
    #[doc(alias = "CKNotificationTypeDatabase")]
    pub const Database: Self = Self(4);
}

unsafe impl Encode for CKNotificationType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CKNotificationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The abstract base class for CloudKit notifications.
    ///
    /// ## Overview
    ///
    /// Use subclasses of `CKNotification` to extract data from push notifications that the system receives, or to fetch a container’s previous push notifications. In both cases, the object indicates the changed data.
    ///
    /// `CKNotification` is an abstract class. When you create a notification from a payload dictionary, the [`notificationFromRemoteNotificationDictionary:`](https://developer.apple.com/documentation/cloudkit/cknotification/init(fromremotenotificationdictionary:)) method returns an instance of the appropriate subclass. Similarly, when you fetch notifications from a container, you receive instances of a concrete subclass. `CKNotification` provides information about the push notification and its method of delivery. Subclasses contain specific data that provides the changes.
    ///
    ///
    /// Pushes from CloudKit servers contain both CloudKit-specific and APS-specific information.
    /// APS-specific information includes elements like alerts, badges, sounds, categories, etc.
    /// When receiving a push from CloudKit servers, the push may be delivered via multiple API flows.
    /// The flow(s) chosen will depend on the type of push requested (e.g. via the ``CKSubscription``
    /// that triggered it and its configured `notificationInfo`).
    ///
    /// Pushes with UI elements (alerts, badges, sounds):
    /// These pushes are delivered via the `UserNotifications` framework, in the form of a `UNNotification`
    /// Applications should use the `UserNotifications` framework to interact with the UI elements of this push.
    /// Applications may create a ``CKNotification`` from a `UNNotification` in their `UNUserNotificationCenterDelegate`:
    ///
    /// func userNotificationCenter(_ center: UNUserNotificationCenter, willPresent notification: UNNotification) async -> UNNotificationPresentationOptions {
    /// let ckNotification = CKNotification(fromRemoteNotificationDictionary: notification.request.content.userInfo)
    /// }
    ///
    /// Pushes with `content-available`:
    /// These pushes are delivered via an application delegate, in the form of a remote notification.
    /// For example: `UIApplicationDelegate.application(_:didReceiveRemoteNotification:) async`
    /// Applications do not need to interact with any UI element in the push payload argument, that's intended to be handled via the `UserNotifications` flow
    /// (a push with both UI elements and `content-available` will be delivered via both API flows)
    /// Applications may create a ``CKNotification`` from the remote notification in their `UIApplicationDelegate`:
    ///
    /// func application(_ application: UIApplication, didReceiveRemoteNotification userInfo: [AnyHashable : Any]) async -> UIBackgroundFetchResult {
    /// let ckNotification = CKNotification(fromRemoteNotificationDictionary: userInfo)
    /// }
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKNotification;
);

unsafe impl Send for CKNotification {}

unsafe impl Sync for CKNotification {}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKNotification {}
);

impl CKNotification {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// # Safety
        ///
        /// `notification_dictionary` generic should be of the correct type.
        #[unsafe(method(notificationFromRemoteNotificationDictionary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationFromRemoteNotificationDictionary(
            notification_dictionary: &NSDictionary,
        ) -> Option<Retained<Self>>;

        /// When you instantiate a ``CKNotification`` from a remote notification dictionary, you will get back a concrete
        /// subclass defined below.  Use `notificationType` to avoid `as?` or `-isKindOfClass:` checks.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(notificationType))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationType(&self) -> CKNotificationType;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(notificationID))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationID(&self) -> Option<Retained<CKNotificationID>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(containerIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn containerIdentifier(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "CKRecordID")]
        /// The user `recordID` of the owner of the subscription for which this notification was generated
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(subscriptionOwnerUserRecordID))]
        #[unsafe(method_family = none)]
        pub unsafe fn subscriptionOwnerUserRecordID(&self) -> Option<Retained<CKRecordID>>;

        /// Whether or not the notification fully represents what the server wanted to send.
        ///
        /// Push notifications have a limited size.  In some cases, CloudKit servers may not be able to send you a full ``CKNotification``'s worth of info in one push.
        /// In those cases, `isPruned` returns `true`.
        /// The order in which properties are dropped from a push notification is defined in each ``CKNotification`` subclass below.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(isPruned))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPruned(&self) -> bool;

        #[cfg(feature = "CKSubscription")]
        /// The ID of the subscription that caused this notification to fire.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(subscriptionID))]
        #[unsafe(method_family = none)]
        pub unsafe fn subscriptionID(&self) -> Option<Retained<CKSubscriptionID>>;
    );
}

/// DeprecatedAPSProperties.
#[deprecated = "Interact with UI elements of a CloudKit-server-generated push message via UserNotifications.framework"]
impl CKNotification {
    extern_methods!(
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Interact with UI elements of a CloudKit-server-generated push message via UserNotifications.framework"]
        #[unsafe(method(alertBody))]
        #[unsafe(method_family = none)]
        pub unsafe fn alertBody(&self) -> Option<Retained<NSString>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Interact with UI elements of a CloudKit-server-generated push message via UserNotifications.framework"]
        #[unsafe(method(alertLocalizationKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn alertLocalizationKey(&self) -> Option<Retained<NSString>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Interact with UI elements of a CloudKit-server-generated push message via UserNotifications.framework"]
        #[unsafe(method(alertLocalizationArgs))]
        #[unsafe(method_family = none)]
        pub unsafe fn alertLocalizationArgs(&self) -> Option<Retained<NSArray<NSString>>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub unsafe fn title(&self) -> Option<Retained<NSString>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(titleLocalizationKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn titleLocalizationKey(&self) -> Option<Retained<NSString>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(titleLocalizationArgs))]
        #[unsafe(method_family = none)]
        pub unsafe fn titleLocalizationArgs(&self) -> Option<Retained<NSArray<NSString>>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(subtitle))]
        #[unsafe(method_family = none)]
        pub unsafe fn subtitle(&self) -> Option<Retained<NSString>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(subtitleLocalizationKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn subtitleLocalizationKey(&self) -> Option<Retained<NSString>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(subtitleLocalizationArgs))]
        #[unsafe(method_family = none)]
        pub unsafe fn subtitleLocalizationArgs(&self) -> Option<Retained<NSArray<NSString>>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Interact with UI elements of a CloudKit-server-generated push message via UserNotifications.framework"]
        #[unsafe(method(alertActionLocalizationKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn alertActionLocalizationKey(&self) -> Option<Retained<NSString>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Interact with UI elements of a CloudKit-server-generated push message via UserNotifications.framework"]
        #[unsafe(method(alertLaunchImage))]
        #[unsafe(method_family = none)]
        pub unsafe fn alertLaunchImage(&self) -> Option<Retained<NSString>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Interact with UI elements of a CloudKit-server-generated push message via UserNotifications.framework"]
        #[unsafe(method(badge))]
        #[unsafe(method_family = none)]
        pub unsafe fn badge(&self) -> Option<Retained<NSNumber>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Interact with UI elements of a CloudKit-server-generated push message via UserNotifications.framework"]
        #[unsafe(method(soundName))]
        #[unsafe(method_family = none)]
        pub unsafe fn soundName(&self) -> Option<Retained<NSString>>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(category))]
        #[unsafe(method_family = none)]
        pub unsafe fn category(&self) -> Option<Retained<NSString>>;
    );
}

/// Constants that indicate the event that triggers the notification.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CKQueryNotificationReason(pub NSInteger);
impl CKQueryNotificationReason {
    /// A notification that indicates the creation of a record matching the subscription’s predicate.
    #[doc(alias = "CKQueryNotificationReasonRecordCreated")]
    pub const RecordCreated: Self = Self(1);
    /// A notification that indicates the update of a record matching the subscription’s predicate.
    #[doc(alias = "CKQueryNotificationReasonRecordUpdated")]
    pub const RecordUpdated: Self = Self(2);
    /// A notification that indicates the deletion of a record matching the subscription’s predicate.
    #[doc(alias = "CKQueryNotificationReasonRecordDeleted")]
    pub const RecordDeleted: Self = Self(3);
}

unsafe impl Encode for CKQueryNotificationReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CKQueryNotificationReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A notification that triggers when a record that matches the subscription’s predicate changes.
    ///
    /// ## Overview
    ///
    /// Query subscriptions execute when a record that matches the subscription’s predicate changes, for example, when the user modifies a field’s value in the record. When CloudKit registers the change, it sends push notifications to the user’s devices to inform your app about the change. You can then fetch the changes and cache them on-device. When appropriate, CloudKit excludes the device where the change originates.
    ///
    /// You configure a subscription’s notifications by setting it’s [`notificationInfo`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.property) property. Do this before you save it to the server. A subscription generates either high-priority or medium-priority push notifications. CloudKit delivers medium-priority notifications to your app in the background. High-priority notifications are visual and the system displays them to the user. Visual notifications need the user’s permission. For more information, see [Asking permission to use notifications](https://developer.apple.com/documentation/usernotifications/asking-permission-to-use-notifications).
    ///
    /// A subscription uses [`CKNotificationInfo`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.class) to configure its notifications. For background delivery, set only its [`shouldSendContentAvailable`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.class/shouldsendcontentavailable) property to [`true`](https://developer.apple.com/documentation/swift/true). If you set any other property, CloudKit treats the notification as high-priority.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  To receive silent push notifications, add the Background Modes capability to your Xcode project and select the “Background fetch” and “Remote notifications” options.
    ///
    ///
    ///
    /// </div>
    /// Don’t rely on push notifications for changes because the system can coalesce them. CloudKit can omit data to keep the notification’s payload size under the APNs size limit. If you use [`desiredKeys`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.class/desiredkeys) to include extra data in the payload, the server removes that first. A notification’s [`isPruned`](https://developer.apple.com/documentation/cloudkit/cknotification/ispruned) property is [`true`](https://developer.apple.com/documentation/swift/true) if CloudKit omits data.
    ///
    /// Consider notifications an indication of remote changes. Use [`databaseScope`](https://developer.apple.com/documentation/cloudkit/ckdatabasenotification/databasescope) to determine which database contains the changed record. To fetch the changes, configure an instance of [`CKQueryOperation`](https://developer.apple.com/documentation/cloudkit/ckqueryoperation) to match the subscription and then execute it in the database. CloudKit returns all records that match the predicate, including the changed record. Dispose of any records you cache on-device and use the operation’s results instead.
    ///
    /// You don’t instantiate this class. Instead, implement [`application:didReceiveRemoteNotification:fetchCompletionHandler:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:didreceiveremotenotification:fetchcompletionhandler:)) in your app delegate. Initialize [`CKNotification`](https://developer.apple.com/documentation/cloudkit/cknotification) with the `userInfo` dictionary that CloudKit passes to the method. This returns an instance of the appropriate subclass. Use the [`notificationType`](https://developer.apple.com/documentation/cloudkit/cknotification/notificationtype-swift.property) property to determine the type. Then cast to that type to access type-specific properties and methods.
    ///
    ///
    /// A notification generated by a ``CKQuerySubscription``
    ///
    /// `notificationType` == `.query`
    /// When properties must be dropped (see
    /// `isPruned),`here's the order of importance.  The most important properties are first, they'll be the last ones to be dropped.
    /// - notificationID
    /// - badge
    /// - alertLocalizationKey
    /// - alertLocalizationArgs
    /// - alertBody
    /// - alertActionLocalizationKey
    /// - alertLaunchImage
    /// - soundName
    /// - content-available
    /// - desiredKeys
    /// - queryNotificationReason
    /// - recordID
    /// - containerIdentifier
    /// - subscriptionOwnerUserRecordID
    /// - titleLocalizationKey
    /// - titleLocalizationArgs
    /// - title
    /// - subtitleLocalizationKey
    /// - subtitleLocalizationArgs
    /// - subtitle
    #[unsafe(super(CKNotification, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKQueryNotification;
);

unsafe impl Send for CKQueryNotification {}

unsafe impl Sync for CKQueryNotification {}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKQueryNotification {}
);

impl CKQueryNotification {
    extern_methods!(
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(queryNotificationReason))]
        #[unsafe(method_family = none)]
        pub unsafe fn queryNotificationReason(&self) -> CKQueryNotificationReason;

        /// A set of key->value pairs for creates and updates.
        ///
        /// You request the server fill out this property via the `desiredKeys` property of `CKSubscription.NotificationInfo`
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(recordFields))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordFields(&self) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        #[cfg(feature = "CKRecordID")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(recordID))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordID(&self) -> Option<Retained<CKRecordID>>;

        #[cfg(feature = "CKDatabase")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(databaseScope))]
        #[unsafe(method_family = none)]
        pub unsafe fn databaseScope(&self) -> CKDatabaseScope;
    );
}

/// Methods declared on superclass `CKNotification`.
impl CKQueryNotification {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// # Safety
        ///
        /// `notification_dictionary` generic should be of the correct type.
        #[unsafe(method(notificationFromRemoteNotificationDictionary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationFromRemoteNotificationDictionary(
            notification_dictionary: &NSDictionary,
        ) -> Option<Retained<Self>>;
    );
}

extern_class!(
    /// A notification that triggers when the contents of a record zone change.
    ///
    /// ## Overview
    ///
    /// A record zone subscription executes when a user, or in certain scenarios, CloudKit, modifies a record in that zone, for example, when a field’s value changes in a record. When CloudKit registers the change, it sends push notifications to the user’s devices to inform your app about the change. You can then fetch the changes and cache them on-device. When appropriate, CloudKit excludes the device where the change originates.
    ///
    /// You configure a subscription’s notifications by setting it’s [`notificationInfo`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.property) property. Do this before you save it to the server. A subscription generates either high-priority or medium-priority push notifications. CloudKit delivers medium-priority notifications to your app in the background. High-priority notifications are visual and the system displays them to the user. Visual notifications need the user’s permission. For more information, see [Asking permission to use notifications](https://developer.apple.com/documentation/usernotifications/asking-permission-to-use-notifications).
    ///
    /// A subscription uses [`CKNotificationInfo`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.class) to configure its notifications. For background delivery, set only its [`shouldSendContentAvailable`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.class/shouldsendcontentavailable) property to [`true`](https://developer.apple.com/documentation/swift/true). If you set any other property, CloudKit treats the notification as high-priority.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  To receive silent push notifications, add the Background Modes capability to your Xcode project and select the “Background fetch” and “Remote notifications” options.
    ///
    ///
    ///
    /// </div>
    /// Don’t rely on push notifications for specific changes to records because the system can coalesce them. CloudKit can omit data to keep the notification’s payload size under the APNs size limit. Consider notifications an indication of remote changes. Use [`databaseScope`](https://developer.apple.com/documentation/cloudkit/ckrecordzonenotification/databasescope) to determine which database contains the changed record zone, and [`recordZoneID`](https://developer.apple.com/documentation/cloudkit/ckrecordzonenotification/recordzoneid) to determine which zone contains changed records. You can then fetch just those changes using [`CKFetchRecordZoneChangesOperation`](https://developer.apple.com/documentation/cloudkit/ckfetchrecordzonechangesoperation). A notification’s [`isPruned`](https://developer.apple.com/documentation/cloudkit/cknotification/ispruned) property is [`true`](https://developer.apple.com/documentation/swift/true) if CloudKit omits data.
    ///
    /// You don’t instantiate this class. Instead, implement [`application:didReceiveRemoteNotification:fetchCompletionHandler:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:didreceiveremotenotification:fetchcompletionhandler:)) in your app delegate. Initialize [`CKNotification`](https://developer.apple.com/documentation/cloudkit/cknotification) with the `userInfo` dictionary that CloudKit passes to the method. This returns an instance of the appropriate subclass. Use the [`notificationType`](https://developer.apple.com/documentation/cloudkit/cknotification/notificationtype-swift.property) property to determine the type. Then cast to that type to access type-specific properties and methods.
    ///
    ///
    /// A notification generated by a ``CKRecordZoneSubscription``
    ///
    /// `notificationType` == `.recordZone`
    /// When properties must be dropped (see
    /// `isPruned),`here's the order of importance.  The most important properties are first, they'll be the last ones to be dropped.
    /// - notificationID
    /// - badge
    /// - alertLocalizationKey
    /// - alertLocalizationArgs
    /// - alertBody
    /// - alertActionLocalizationKey
    /// - alertLaunchImage
    /// - soundName
    /// - content-available
    /// - recordZoneID
    /// - containerIdentifier
    /// - subscriptionOwnerUserRecordID
    /// - titleLocalizationKey
    /// - titleLocalizationArgs
    /// - title
    /// - subtitleLocalizationKey
    /// - subtitleLocalizationArgs
    /// - subtitle
    #[unsafe(super(CKNotification, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKRecordZoneNotification;
);

unsafe impl Send for CKRecordZoneNotification {}

unsafe impl Sync for CKRecordZoneNotification {}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKRecordZoneNotification {}
);

impl CKRecordZoneNotification {
    extern_methods!(
        #[cfg(feature = "CKRecordZoneID")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(recordZoneID))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordZoneID(&self) -> Option<Retained<CKRecordZoneID>>;

        #[cfg(feature = "CKDatabase")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(databaseScope))]
        #[unsafe(method_family = none)]
        pub unsafe fn databaseScope(&self) -> CKDatabaseScope;
    );
}

/// Methods declared on superclass `CKNotification`.
impl CKRecordZoneNotification {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// # Safety
        ///
        /// `notification_dictionary` generic should be of the correct type.
        #[unsafe(method(notificationFromRemoteNotificationDictionary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationFromRemoteNotificationDictionary(
            notification_dictionary: &NSDictionary,
        ) -> Option<Retained<Self>>;
    );
}

extern_class!(
    /// A notification that triggers when the contents of a database change.
    ///
    /// ## Overview
    ///
    /// Database subscriptions execute when changes happen in any of a database’s record zones, for example, when CloudKit saves a new record. When the subscription registers a change, it sends push notifications to the user’s devices to inform your app about the change. You can then fetch the changes and cache them on-device. When appropriate, CloudKit excludes the device where the change originates.
    ///
    /// You configure a subscription’s notifications by setting it’s [`notificationInfo`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.property) property. Do this before you save it to the server. A subscription generates either high-priority or medium-priority push notifications. CloudKit delivers medium-priority notifications to your app in the background. High-priority notifications are visual and the system displays them to the user. Visual notifications need the user’s permission. For more information, see [Asking permission to use notifications](https://developer.apple.com/documentation/usernotifications/asking-permission-to-use-notifications).
    ///
    /// A subscription uses [`CKNotificationInfo`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.class) to configure its notifications. For background delivery, set only its [`shouldSendContentAvailable`](https://developer.apple.com/documentation/cloudkit/cksubscription/notificationinfo-swift.class/shouldsendcontentavailable) property to [`true`](https://developer.apple.com/documentation/swift/true). If you set any other property, CloudKit treats the notification as high-priority.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  To receive silent push notifications, add the Background Modes capability to your Xcode project and select the “Background fetch” and “Remote notifications” options.
    ///
    ///
    ///
    /// </div>
    /// Don’t rely on push notifications for specific changes because the system can coalesce them. CloudKit can omit data to keep the notification’s payload size under the APNs size limit. Consider notifications an indication of remote changes. Use [`databaseScope`](https://developer.apple.com/documentation/cloudkit/ckdatabasenotification/databasescope) to determine which database has changes, and then [`CKFetchDatabaseChangesOperation`](https://developer.apple.com/documentation/cloudkit/ckfetchdatabasechangesoperation) to fetch those changes. A notification’s [`isPruned`](https://developer.apple.com/documentation/cloudkit/cknotification/ispruned) property is [`true`](https://developer.apple.com/documentation/swift/true) if CloudKit omits data.
    ///
    /// You don’t instantiate this class. Instead, implement [`application:didReceiveRemoteNotification:fetchCompletionHandler:`](https://developer.apple.com/documentation/uikit/uiapplicationdelegate/application(_:didreceiveremotenotification:fetchcompletionhandler:)) in your app delegate. Initialize [`CKNotification`](https://developer.apple.com/documentation/cloudkit/cknotification) with the `userInfo` dictionary that CloudKit passes to the method. This returns an instance of the appropriate subclass. Use the [`notificationType`](https://developer.apple.com/documentation/cloudkit/cknotification/notificationtype-swift.property) property to determine the type. Then cast to that type to access type-specific properties and methods.
    ///
    ///
    /// A notification generated by a ``CKDatabaseSubscription``
    ///
    /// `notificationType` == `.database`
    /// When properties must be dropped (see
    /// `isPruned),`here's the order of importance.  The most important properties are first, they'll be the last ones to be dropped.
    /// - notificationID
    /// - badge
    /// - alertLocalizationKey
    /// - alertLocalizationArgs
    /// - alertBody
    /// - alertActionLocalizationKey
    /// - alertLaunchImage
    /// - soundName
    /// - content-available
    /// - containerIdentifier
    /// - subscriptionOwnerUserRecordID
    /// - titleLocalizationKey
    /// - titleLocalizationArgs
    /// - title
    /// - subtitleLocalizationKey
    /// - subtitleLocalizationArgs
    /// - subtitle
    #[unsafe(super(CKNotification, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKDatabaseNotification;
);

unsafe impl Send for CKDatabaseNotification {}

unsafe impl Sync for CKDatabaseNotification {}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKDatabaseNotification {}
);

impl CKDatabaseNotification {
    extern_methods!(
        #[cfg(feature = "CKDatabase")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(databaseScope))]
        #[unsafe(method_family = none)]
        pub unsafe fn databaseScope(&self) -> CKDatabaseScope;
    );
}

/// Methods declared on superclass `CKNotification`.
impl CKDatabaseNotification {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// # Safety
        ///
        /// `notification_dictionary` generic should be of the correct type.
        #[unsafe(method(notificationFromRemoteNotificationDictionary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn notificationFromRemoteNotificationDictionary(
            notification_dictionary: &NSDictionary,
        ) -> Option<Retained<Self>>;
    );
}
