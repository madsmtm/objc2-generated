//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// A type that represents the ID of an operation.
pub type CKOperationID = NSString;

extern_class!(
    /// The abstract base class for all operations that execute in a database.
    ///
    /// ## Overview
    ///
    /// All CloudKit operations descend from `CKOperation`, which provides the infrastructure for executing tasks in one of your app’s containers. Don’t subclass or create instances of this class directly. Instead, create instances of one of its concrete subclasses.
    ///
    /// Use the properties of this class to configure the behavior of the operation before submitting it to a queue or executing it directly. CloudKit operations involve communicating with the iCloud servers to send and receive data. You can use the properties of this class to configure the behavior of those network requests to ensure the best performance for your app.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  `CKOperation` objects have a default quality of service level of [`NSQualityOfServiceDefault`](https://developer.apple.com/documentation/foundation/qualityofservice/default) (see [`qualityOfService`](https://developer.apple.com/documentation/foundation/operation/qualityofservice)). Operations with this service level are discretionary, and the system schedules them for an optimal time according to battery level and other factors. On iPhone, discretionary activities pause when the device is in Low Power Mode. For information about quality of service levels, see [Prioritize Work with Quality of Service Classes](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html#//apple_ref/doc/uid/TP40015243-CH39) in [Energy Efficiency Guide for iOS Apps](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/index.html#//apple_ref/doc/uid/TP40015243) and [Prioritize Work at the Task Level](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/PrioritizeWorkAtTheTaskLevel.html#//apple_ref/doc/uid/TP40013929-CH35) in [Energy Efficiency Guide for Mac Apps](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/index.html#//apple_ref/doc/uid/TP40013929).
    ///
    ///
    ///
    /// </div>
    /// ### Long-Lived Operations
    ///
    /// A _long-lived operation_ is an operation that continues to run after the user closes the app. To specify a long-lived operation, set [`longLived`](https://developer.apple.com/documentation/cloudkit/ckoperation/islonglived) to [`true`](https://developer.apple.com/documentation/swift/true), provide a completion handler, and execute the operation. To get the identifiers of all running long-lived operations, use the [`fetchAllLongLivedOperationIDsWithCompletionHandler:`](https://developer.apple.com/documentation/cloudkit/ckcontainer/fetchalllonglivedoperationidswithcompletionhandler:) method that [`CKContainer`](https://developer.apple.com/documentation/cloudkit/ckcontainer) provides. To get a specific long-lived operation, use the [`fetchLongLivedOperationWithID:completionHandler:`](https://developer.apple.com/documentation/cloudkit/ckcontainer/fetchlonglivedoperationwithid:completionhandler:) method. Make sure you set the completion handler of a long-lived operation before you execute it so that the system can notify you when it completes and you can process the results. Do not execute an operation, change it to long-lived, and execute it again as a long-lived operation.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["container.fetchAllLongLivedOperationIDs(completionHandler: { (operationIDs, error) in", "    if let error = error {", "        print(\"Error fetching long lived operations: \\(error)\")", "        // Handle error", "        return", "    }", "    guard let identifiers = operationIDs else { return }", "    for operationID in identifiers {", "        container.fetchLongLivedOperation(withID: operationID, completionHandler: { (operation, error) in", "            if let error = error {", "                print(\"Error fetching operation: \\(operationID)\\n\\(error)\")", "                // Handle error", "                return", "            }", "            guard let operation = operation else { return }", "            // Add callback handlers to operation", "            container.add(operation)", "        })", "    }", "})"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[container fetchAllLongLivedOperationIDsWithCompletionHandler:^(NSArray<NSString *> *_Nullable operationIDs, NSError *_Nullable error) {", "    if (error) {", "        // Handle error", "        return", "    }", "    for (NSString *operationID in operationIDs) {", "        [container fetchLongLivedOperationWithID:operationID completionHandler:^(CKOperation *_Nullable operation, NSError *_Nullable error) {", "            if (error) {", "                // Handle error", "                return", "            }", "            // Add callback handlers to operation", "            [container addOperation:operation];", "        }];", "    }", "}];"], metadata: None }] }] })
    /// The following is the typical life cycle of a long-lived operation:
    ///
    /// 1. The app creates a long-lived operation and executes it.
    ///
    /// The daemon starts saving and sending the callbacks to the running app. 2. The app exits.
    ///
    /// The daemon continues running the long-lived operation and saves the callbacks. 3. The app launches and fetches the long-lived operation.
    ///
    /// If the operation is running or if it completed within the previous 24 hours, the daemon returns a proxy for the long-lived operation. If the operation completed more than 24 hours previously, the daemon may stop returning it in fetch requests. 4. The app runs the long-lived operation again.
    ///
    /// The daemon sends the app all the saved callbacks (it doesn’t actually rerun the operation), and continues saving the callbacks and sending them to the running app. 5. The app receives the completion callback or the app cancels the operation.
    ///
    /// The daemon stops including the operation in future fetch results.
    ///
    ///
    #[unsafe(super(NSOperation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKOperation;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for CKOperation {}
);

impl CKOperation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// This defines per-operation configuration settings.
        ///
        ///
        /// See the CKOperationConfiguration class description for info on how this configuration composes with CKOperationGroup.defaultConfiguration
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub unsafe fn configuration(&self) -> Retained<CKOperationConfiguration>;

        /// Setter for [`configuration`][Self::configuration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(setConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConfiguration(&self, configuration: Option<&CKOperationConfiguration>);

        #[cfg(feature = "CKOperationGroup")]
        /// The group this operation is associated with
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(group))]
        #[unsafe(method_family = none)]
        pub unsafe fn group(&self) -> Option<Retained<CKOperationGroup>>;

        #[cfg(feature = "CKOperationGroup")]
        /// Setter for [`group`][Self::group].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(setGroup:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGroup(&self, group: Option<&CKOperationGroup>);

        /// This is an identifier unique to this CKOperation.
        ///
        ///
        /// This value is chosen by the system, and will be unique to this instance of a CKOperation.  This identifier will be sent to Apple's servers, and can be used to identify any server-side logging associated with this operation.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(operationID))]
        #[unsafe(method_family = none)]
        pub unsafe fn operationID(&self) -> Retained<CKOperationID>;

        #[cfg(feature = "block2")]
        /// This callback is called after a long lived operation has begun running and is persisted.
        ///
        ///
        /// Once this callback is called the operation will continue running even if the current process exits.
        /// Each
        /// `CKOperation`instance has a private serial queue. This queue is used for all callback block invocations.
        /// This block may share mutable state with other blocks assigned to this operation, but any such mutable state
        /// should not be concurrently used outside of blocks assigned to this operation.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(longLivedOperationWasPersistedBlock))]
        #[unsafe(method_family = none)]
        pub unsafe fn longLivedOperationWasPersistedBlock(&self)
            -> *mut block2::DynBlock<dyn Fn()>;

        #[cfg(feature = "block2")]
        /// Setter for [`longLivedOperationWasPersistedBlock`][Self::longLivedOperationWasPersistedBlock].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(setLongLivedOperationWasPersistedBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLongLivedOperationWasPersistedBlock(
            &self,
            long_lived_operation_was_persisted_block: Option<&block2::DynBlock<dyn Fn()>>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl CKOperation {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object that describes how a CloudKit operation behaves.
    ///
    /// ## Overview
    ///
    /// All of the properties in `CKOperationConfiguration` have a default value. When determining which properties to apply to a CloudKit operation, consult the operation’s configuration property, as well as the [`defaultConfiguration`](https://developer.apple.com/documentation/cloudkit/ckoperationgroup/defaultconfiguration) property of the group that the operation belongs to. These properties combine through the following rules:
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Group default configuration value" }] }], [Paragraph { inline_content: [Text { text: "Operation configuration value" }] }], [Paragraph { inline_content: [Text { text: "Value applied to operation" }] }]], [[Paragraph { inline_content: [Text { text: "default value" }] }], [Paragraph { inline_content: [Text { text: "default value" }] }], [Paragraph { inline_content: [Text { text: "default value" }] }]], [[Paragraph { inline_content: [Text { text: "default value" }] }], [Paragraph { inline_content: [Text { text: "explicit value" }] }], [Paragraph { inline_content: [Text { text: "operation.configuration explicit value" }] }]], [[Paragraph { inline_content: [Text { text: "explicit value" }] }], [Paragraph { inline_content: [Text { text: "default value" }] }], [Paragraph { inline_content: [Text { text: "group.defaultConfiguration explicit value" }] }]], [[Paragraph { inline_content: [Text { text: "explicit value" }] }], [Paragraph { inline_content: [Text { text: "explicit value" }] }], [Paragraph { inline_content: [Text { text: "operation.configuration explicit value" }] }]]], alignments: None, metadata: None })
    ///
    /// An operation configuration is a set of properties that describes how your operation should behave.  All properties have a default value.  When determining what properties to apply to an operation, we consult the operation's configuration property, as well as the operation->group->defaultConfiguration property.  We combine them following these rules:
    ///
    /// ```text
    ///    Group Default Configuration Value | Operation Configuration Value |        Value Applied To Operation
    ///   -----------------------------------+-------------------------------+-----------------------------------------
    ///              default value           |         default value         |                  default value
    ///              default value           |         explicit value        |       operation.configuration explicit value
    ///              explicit value          |         default value         | operation.group.defaultConfiguration explicit value
    ///              explicit value          |         explicit value        |       operation.configuration explicit value
    /// ```
    ///
    /// For example:
    /// CKOperationGroup -> defaultConfiguration -> allowsCellularAccess explicitly set to NO
    /// + CKOperation -> configuration -> allowsCellularAccess has default value of YES
    /// = disallow cellular access
    ///
    /// CKOperationGroup -> defaultConfiguration -> allowsCellularAccess explicitly set to NO
    /// + CKOperation -> configuration -> allowsCellularAccess explicitly set to YES
    /// = allow cellular access
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKOperationConfiguration;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for CKOperationConfiguration {}
);

impl CKOperationConfiguration {
    extern_methods!(
        #[cfg(feature = "CKContainer")]
        /// If no container is set, [CKContainer defaultContainer] is used
        #[unsafe(method(container))]
        #[unsafe(method_family = none)]
        pub unsafe fn container(&self) -> Option<Retained<CKContainer>>;

        #[cfg(feature = "CKContainer")]
        /// Setter for [`container`][Self::container].
        #[unsafe(method(setContainer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContainer(&self, container: Option<&CKContainer>);

        /// CKOperations behave differently depending on how you set qualityOfService.
        ///
        ///
        /// ```text
        ///   Quality of Service | timeoutIntervalForResource | Network Error Behavior | Discretionary Behavior
        ///   -------------------+----------------------------+------------------------+-----------------------
        ///   UserInteractive    | -1 (no enforcement)        | fail                   | nonDiscretionary
        ///   UserInitiated      | -1 (no enforcement)        | fail                   | nonDiscretionary
        ///   Default            | 1 week                     | fail                   | discretionary when app backgrounded
        ///   Utility            | 1 week                     | internally retried     | discretionary when app backgrounded
        ///   Background         | 1 week                     | internally retried     | discretionary
        /// ```
        ///
        /// timeoutIntervalForResource
        /// - the timeout interval for any network resources retrieved by this operation
        /// - this can be overridden via CKOperationConfiguration's timeoutIntervalForResource property
        ///
        /// Network Error Behavior
        /// - when a network request in service of a CKOperation fails due to a networking error, the operation may fail with that error, or internally retry the network request.  Only a subset of networking errors are retried, and limiting factors such as timeoutIntervalForResource are still applicable.
        ///
        /// Discretionary Behavior
        /// - network requests in service of a CKOperation may be marked as discretionary
        /// - discretionary network requests are scheduled at the description of the system for optimal performance
        ///
        /// CKOperations have a default qualityOfService of Default.
        #[unsafe(method(qualityOfService))]
        #[unsafe(method_family = none)]
        pub unsafe fn qualityOfService(&self) -> NSQualityOfService;

        /// Setter for [`qualityOfService`][Self::qualityOfService].
        #[unsafe(method(setQualityOfService:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setQualityOfService(&self, quality_of_service: NSQualityOfService);

        /// Defaults to
        /// `YES`
        #[unsafe(method(allowsCellularAccess))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsCellularAccess(&self) -> bool;

        /// Setter for [`allowsCellularAccess`][Self::allowsCellularAccess].
        #[unsafe(method(setAllowsCellularAccess:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsCellularAccess(&self, allows_cellular_access: bool);

        /// Long lived operations will continue running even if your process exits. If your process remains alive for the lifetime of the long lived operation its behavior is the same as a regular operation.
        ///
        /// Long lived operations can be fetched and replayed from the container via the
        /// `fetchAllLongLivedOperations:`and
        /// `fetchLongLivedOperationsWithIDs:`APIs. Your code should only fetch and re-enqueue long lived operations on app launch.
        ///
        /// Long lived operations persist until their -[NSOperation completionBlock] returns or until the operation is cancelled.
        /// Long lived operations may be garbage collected 24 hours after they finish running if no client has replayed them.
        ///
        /// The default value for longLived is NO. Changing the value of longLived on an already started operation or on an outstanding long lived operation fetched from CKContainer has no effect.
        #[unsafe(method(isLongLived))]
        #[unsafe(method_family = none)]
        pub unsafe fn isLongLived(&self) -> bool;

        /// Setter for [`isLongLived`][Self::isLongLived].
        #[unsafe(method(setLongLived:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLongLived(&self, long_lived: bool);

        /// If non-zero, overrides the timeout interval for any network requests issued by this operation.
        /// The default value is 60.
        ///
        ///
        /// See: NSURLSessionConfiguration.timeoutIntervalForRequest
        #[unsafe(method(timeoutIntervalForRequest))]
        #[unsafe(method_family = none)]
        pub unsafe fn timeoutIntervalForRequest(&self) -> NSTimeInterval;

        /// Setter for [`timeoutIntervalForRequest`][Self::timeoutIntervalForRequest].
        #[unsafe(method(setTimeoutIntervalForRequest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimeoutIntervalForRequest(
            &self,
            timeout_interval_for_request: NSTimeInterval,
        );

        /// If set, overrides the timeout interval for any network resources retrieved by this operation.
        /// If not explicitly set, defaults to a value based on the operation's
        /// `qualityOfService`
        ///
        /// See: NSURLSessionConfiguration.timeoutIntervalForResource
        #[unsafe(method(timeoutIntervalForResource))]
        #[unsafe(method_family = none)]
        pub unsafe fn timeoutIntervalForResource(&self) -> NSTimeInterval;

        /// Setter for [`timeoutIntervalForResource`][Self::timeoutIntervalForResource].
        #[unsafe(method(setTimeoutIntervalForResource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimeoutIntervalForResource(
            &self,
            timeout_interval_for_resource: NSTimeInterval,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl CKOperationConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// CKOperationDeprecated.
///
/// These deprecated properties now read and write from the CKOperation's configuration
impl CKOperation {
    extern_methods!(
        #[cfg(feature = "CKContainer")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(container))]
        #[unsafe(method_family = none)]
        pub unsafe fn container(&self) -> Option<Retained<CKContainer>>;

        #[cfg(feature = "CKContainer")]
        /// Setter for [`container`][Self::container].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(setContainer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContainer(&self, container: Option<&CKContainer>);

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(allowsCellularAccess))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowsCellularAccess(&self) -> bool;

        /// Setter for [`allowsCellularAccess`][Self::allowsCellularAccess].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(setAllowsCellularAccess:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowsCellularAccess(&self, allows_cellular_access: bool);

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(isLongLived))]
        #[unsafe(method_family = none)]
        pub unsafe fn isLongLived(&self) -> bool;

        /// Setter for [`isLongLived`][Self::isLongLived].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(setLongLived:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLongLived(&self, long_lived: bool);

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(timeoutIntervalForRequest))]
        #[unsafe(method_family = none)]
        pub unsafe fn timeoutIntervalForRequest(&self) -> NSTimeInterval;

        /// Setter for [`timeoutIntervalForRequest`][Self::timeoutIntervalForRequest].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(setTimeoutIntervalForRequest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimeoutIntervalForRequest(
            &self,
            timeout_interval_for_request: NSTimeInterval,
        );

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(timeoutIntervalForResource))]
        #[unsafe(method_family = none)]
        pub unsafe fn timeoutIntervalForResource(&self) -> NSTimeInterval;

        /// Setter for [`timeoutIntervalForResource`][Self::timeoutIntervalForResource].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[deprecated = "Use CKOperationConfiguration"]
        #[unsafe(method(setTimeoutIntervalForResource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTimeoutIntervalForResource(
            &self,
            timeout_interval_for_resource: NSTimeInterval,
        );
    );
}
