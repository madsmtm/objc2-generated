//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// The error domain for CloudKit errors.
    pub static CKErrorDomain: &'static NSString;
}

extern "C" {
    /// The key to retrieve partial errors.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a dictionary that maps an item ID to an error. The type of each ID depends on where the error occurs. For example, if you receive a partial error when modifying a record, the ID is an instance of [`CKRecordID`](https://developer.apple.com/documentation/cloudkit/ckrecord/id) that corresponds to the record that CloudKit can’t modify.
    ///
    ///
    /// When a CKErrorPartialFailure happens this key will be set in the error's userInfo dictionary.
    ///
    ///
    /// The value of this key will be a dictionary, and the values will be errors for individual items with the keys being the item IDs that failed.
    pub static CKPartialErrorsByItemIDKey: &'static NSString;
}

extern "C" {
    /// The key to retrieve the original version of the record.
    /// If the server rejects a record save because it has been modified since the last time it was read,
    /// a
    /// `CKErrorServerRecordChanged`will be returned.  The error's
    /// `userInfo`dictionary will contain
    /// a
    /// `CKRecord`keyed by
    /// `CKRecordChangedErrorAncestorRecordKey.`This is the original
    /// record used as a basis for making your changes.
    ///
    /// Note that if you had attempted to save a new
    /// `CKRecord`instance, this record may not have any
    /// key / value pairs set on it, as there was no
    /// `CKRecord`instance that represents an ancestor point.
    pub static CKRecordChangedErrorAncestorRecordKey: &'static NSString;
}

extern "C" {
    /// The key to retrieve the server’s version of the record.
    /// If the server rejects a record save because it has been modified since the last time it was read,
    /// a
    /// `CKErrorServerRecordChanged`will be returned.  The error's
    /// `userInfo`dictionary will contain
    /// a
    /// `CKRecord`keyed by
    /// `CKRecordChangedErrorServerRecordKey.`This is the record
    /// object that was found on the server.
    ///
    /// Use this record as the basis for merging your changes.
    pub static CKRecordChangedErrorServerRecordKey: &'static NSString;
}

extern "C" {
    /// The key to retrieve the local version of the record.
    /// If the server rejects a record save because it has been modified since the last time it was read,
    /// a
    /// `CKErrorServerRecordChanged`will be returned.  The error's
    /// `userInfo`dictionary will contain
    /// a
    /// `CKRecord`keyed by
    /// `CKRecordChangedErrorClientRecordKey.`This is the record
    /// object that you tried to save.
    pub static CKRecordChangedErrorClientRecordKey: &'static NSString;
}

extern "C" {
    /// The key that determines whether CloudKit deletes a record zone because of a user action.
    ///
    /// ## Discussion
    ///
    /// An [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) that represents a Boolean value you use to determine whether a user action causes CloudKit to delete a record zone. CloudKit adds this key to the error’s `userInfo` dictionary when the error code is [`CKErrorZoneNotFound`](https://developer.apple.com/documentation/cloudkit/ckerror/code/zonenotfound).
    ///
    ///
    pub static CKErrorUserDidResetEncryptedDataKey: &'static NSString;
}

extern "C" {
    /// The key to retrieve the number of seconds to wait before you retry a request.
    ///
    /// ## Discussion
    ///
    /// An [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) that contains the number of seconds until you can retry a request. CloudKit adds this key to the error’s [`userInfo`](https://developer.apple.com/documentation/foundation/nserror/userinfo) dictionary when the error code is [`CKErrorServiceUnavailable`](https://developer.apple.com/documentation/cloudkit/ckerror/code/serviceunavailable) or [`CKErrorRequestRateLimited`](https://developer.apple.com/documentation/cloudkit/ckerror/code/requestratelimited).
    ///
    ///
    /// On some errors, the userInfo dictionary may contain a NSNumber instance that specifies the period of time in seconds after which the client may retry the request. For example, this key will be on
    /// `CKErrorServiceUnavailable,``CKErrorRequestRateLimited,`and other errors for which the recommended resolution is to retry after a delay.
    pub static CKErrorRetryAfterKey: &'static NSString;
}

/// The error codes that CloudKit returns.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CKErrorCode(pub NSInteger);
impl CKErrorCode {
    /// A nonrecoverable error that CloudKit encounters.
    ///
    /// ## Discussion
    ///
    /// If you receive this error, file a [bug report](http://radar.apple.com) that includes the error log.
    ///
    ///
    /// CloudKit.framework encountered an error.  This is a non-recoverable error.
    #[doc(alias = "CKErrorInternalError")]
    pub const InternalError: Self = Self(1);
    /// An error that occurs when an operation completes with partial failures.
    ///
    /// ## Discussion
    ///
    /// Examine the specific item failures, and act on the failed items. Each specific item error is from the CloudKit error domain. You can inspect the [`userInfo`](https://developer.apple.com/documentation/foundation/nserror/userinfo) [`CKPartialErrorsByItemIDKey`](https://developer.apple.com/documentation/cloudkit/ckpartialerrorsbyitemidkey) to see per-item errors.
    ///
    /// Note that in a custom zone, the system processes all items in an operation atomically. As a result, you may get a [`CKErrorBatchRequestFailed`](https://developer.apple.com/documentation/cloudkit/ckerror/code/batchrequestfailed) error for all other items in an operation that don’t cause an error.
    ///
    ///
    /// Some items failed, but the operation succeeded overall. Check CKPartialErrorsByItemIDKey in the userInfo dictionary for more details.
    /// This error is only returned from CKOperation completion blocks, which are deprecated in swift.
    /// It will not be returned from (swift-only) CKOperation result blocks, which are their replacements
    #[doc(alias = "CKErrorPartialFailure")]
    pub const PartialFailure: Self = Self(2);
    /// An error that occurs when the network is unavailable.
    ///
    /// ## Discussion
    ///
    /// You can retry network failures immediately, but have your app implement a backoff period so that it doesn’t attempt the same operation repeatedly.
    ///
    /// If the network is unavailable, have your app monitor for network reachability and wait to reissue the operation when the network is available again. See [`CFNetworkErrors`](https://developer.apple.com/documentation/cfnetwork/cfnetworkerrors) for more information.
    ///
    ///
    /// Network not available
    #[doc(alias = "CKErrorNetworkUnavailable")]
    pub const NetworkUnavailable: Self = Self(3);
    /// An error that occurs when a network is available, but CloudKit is inaccessible.
    ///
    /// ## Discussion
    ///
    /// You can retry network failures immediately, but have your app implement a backoff period so that it doesn’t attempt the same operation repeatedly.
    ///
    /// If the network is unavailable, have your app monitor for network reachability and wait to reissue the operation when the network is available again. See [`CFNetworkErrors`](https://developer.apple.com/documentation/cfnetwork/cfnetworkerrors) for more information.
    ///
    ///
    /// Network error (available but CFNetwork gave us an error)
    #[doc(alias = "CKErrorNetworkFailure")]
    pub const NetworkFailure: Self = Self(4);
    /// An error that occurs when you use an unknown or unauthorized container.
    /// Un-provisioned or unauthorized container. Try provisioning the container before retrying the operation.
    #[doc(alias = "CKErrorBadContainer")]
    pub const BadContainer: Self = Self(5);
    /// An error that occurs when CloudKit is unavailable.
    /// Service unavailable
    #[doc(alias = "CKErrorServiceUnavailable")]
    pub const ServiceUnavailable: Self = Self(6);
    /// An error that occurs when CloudKit rate-limits requests.
    ///
    /// ## Discussion
    ///
    /// Check for a [`CKErrorRetryAfterKey`](https://developer.apple.com/documentation/cloudkit/ckerrorretryafterkey) key in the [`userInfo`](https://developer.apple.com/documentation/foundation/nserror/userinfo) dictionary of any CloudKit error that you receive. It’s especially important to check for it if you receive any of these errors. Use the value of the [`CKErrorRetryAfterKey`](https://developer.apple.com/documentation/cloudkit/ckerrorretryafterkey) key as the number of seconds to wait before retrying this operation.
    ///
    ///
    /// Client is being rate limited
    #[doc(alias = "CKErrorRequestRateLimited")]
    pub const RequestRateLimited: Self = Self(7);
    /// An error that occurs when the app is missing a required entitlement.
    /// Missing entitlement
    #[doc(alias = "CKErrorMissingEntitlement")]
    pub const MissingEntitlement: Self = Self(8);
    /// An error that occurs when the user is unauthenticated.
    /// Not authenticated (writing without being logged in, no user record)
    #[doc(alias = "CKErrorNotAuthenticated")]
    pub const NotAuthenticated: Self = Self(9);
    /// An error that occurs when the user doesn’t have permission to save or fetch data.
    ///
    /// ## Discussion
    ///
    /// This error typically occurs in the public database in one of these circumstances:
    ///
    /// - You have roles for record types.
    ///
    /// - Your app is trying to accept a share that the user doesn’t have an invitation for.
    ///
    /// Let users know they can’t perform this operation. This error is nonrecoverable and you can’t retry the operation.
    ///
    ///
    /// Access failure (save, fetch, or shareAccept)
    #[doc(alias = "CKErrorPermissionFailure")]
    pub const PermissionFailure: Self = Self(10);
    /// An error that occurs when the specified record doesn’t exist.
    /// Record does not exist
    #[doc(alias = "CKErrorUnknownItem")]
    pub const UnknownItem: Self = Self(11);
    /// An error that occurs when the request contains invalid information.
    ///
    /// ## Discussion
    ///
    /// Consult the error’s [`userInfo`](https://developer.apple.com/documentation/foundation/nserror/userinfo) dictionary for more information about the issue.
    ///
    ///
    /// Bad client request (bad record graph, malformed predicate)
    #[doc(alias = "CKErrorInvalidArguments")]
    pub const InvalidArguments: Self = Self(12);
    /// An error that occurs when CloudKit truncates a query’s results.
    /// Bad client request (bad record graph, malformed predicate)
    #[doc(alias = "CKErrorResultsTruncated")]
    #[deprecated = "Will not be returned"]
    pub const ResultsTruncated: Self = Self(13);
    /// An error that occurs when CloudKit rejects a record because the server’s version is different.
    ///
    /// ## Discussion
    ///
    /// This error indicates that the server’s version of the record is newer than the local version the client’s trying to save. Your app needs to handle this error, resolve any conflicts in the record, and attempt another save of the record, if necessary.
    ///
    /// CloudKit provides your app with three copies of the record in this error’s `userInfo` dictionary to assist with comparing and merging the changes:
    ///
    /// - [`CKRecordChangedErrorClientRecordKey`](https://developer.apple.com/documentation/cloudkit/ckrecordchangederrorclientrecordkey): The local record that the client’s trying to save.
    ///
    /// - [`CKRecordChangedErrorServerRecordKey`](https://developer.apple.com/documentation/cloudkit/ckrecordchangederrorserverrecordkey): The record that exists on the server.
    ///
    /// - [`CKRecordChangedErrorAncestorRecordKey`](https://developer.apple.com/documentation/cloudkit/ckrecordchangederrorancestorrecordkey): The original version of the record.
    ///
    /// When a conflict occurs, your app needs to merge all changes into the record for the [`CKRecordChangedErrorServerRecordKey`](https://developer.apple.com/documentation/cloudkit/ckrecordchangederrorserverrecordkey) key and attempt a new save using that record. Merging into either of the other two copies of the record results in another conflict error because those records have the old record change tag.
    ///
    ///
    /// The record was rejected because the version on the server was different
    #[doc(alias = "CKErrorServerRecordChanged")]
    pub const ServerRecordChanged: Self = Self(14);
    /// An error that occurs when CloudKit rejects the request.
    ///
    /// ## Discussion
    ///
    /// This error is nonrecoverable.
    ///
    ///
    /// The server rejected this request. This is a non-recoverable error
    #[doc(alias = "CKErrorServerRejectedRequest")]
    pub const ServerRejectedRequest: Self = Self(15);
    /// An error that occurs when the system can’t find the specified asset.
    /// Asset file was not found
    #[doc(alias = "CKErrorAssetFileNotFound")]
    pub const AssetFileNotFound: Self = Self(16);
    /// An error that occurs when the system modifies an asset while saving it.
    /// Asset file content was modified while being saved
    #[doc(alias = "CKErrorAssetFileModified")]
    pub const AssetFileModified: Self = Self(17);
    /// An error that occurs when the current app version is older than the oldest allowed version.
    /// App version is less than the minimum allowed version
    #[doc(alias = "CKErrorIncompatibleVersion")]
    pub const IncompatibleVersion: Self = Self(18);
    /// An error that occurs when the server rejects the request because of a unique constraint violation.
    /// The server rejected the request because there was a conflict with a unique field.
    #[doc(alias = "CKErrorConstraintViolation")]
    pub const ConstraintViolation: Self = Self(19);
    /// An error that occurs when an operation cancels.
    /// A CKOperation was explicitly cancelled
    #[doc(alias = "CKErrorOperationCancelled")]
    pub const OperationCancelled: Self = Self(20);
    /// An error that occurs when the change token expires.
    /// The previousServerChangeToken value is too old and the client must re-sync from scratch
    #[doc(alias = "CKErrorChangeTokenExpired")]
    pub const ChangeTokenExpired: Self = Self(21);
    /// An error that occurs when the system rejects the entire batch of changes.
    ///
    /// ## Discussion
    ///
    /// This error occurs when an operation attempts to save multiple items in a custom zone, but one of those items encounters an error. Because custom zones are atomic, the entire batch fails. The items that cause the problem have their own errors, and all other items in the batch have a [`CKErrorBatchRequestFailed`](https://developer.apple.com/documentation/cloudkit/ckerror/code/batchrequestfailed) error to indicate that the system can’t save them.
    ///
    /// This error indicates that the system can’t process the associated item due to an error in another item in the operation. Check the other per-item errors under [`CKPartialErrorsByItemIDKey`](https://developer.apple.com/documentation/cloudkit/ckpartialerrorsbyitemidkey) for any that aren’t [`CKErrorBatchRequestFailed`](https://developer.apple.com/documentation/cloudkit/ckerror/code/batchrequestfailed) errors. Handle those errors, and then retry all items in the operation.
    ///
    ///
    /// One of the items in this batch operation failed in a zone with atomic updates, so the entire batch was rejected.
    #[doc(alias = "CKErrorBatchRequestFailed")]
    pub const BatchRequestFailed: Self = Self(22);
    /// An error that occurs when the server is too busy to handle the record zone operation.
    ///
    /// ## Discussion
    ///
    /// Try the operation again in a few seconds. If you encounter this error again, increase the delay time exponentially for each subsequent retry to minimize server contention for the zone.
    ///
    /// Check for a [`CKErrorRetryAfterKey`](https://developer.apple.com/documentation/cloudkit/ckerrorretryafterkey) key in the [`userInfo`](https://developer.apple.com/documentation/foundation/nserror/userinfo) dictionary of any CloudKit error that you receive. Use the value of this key as the number of seconds to wait before retrying the operation.
    ///
    ///
    /// The server is too busy to handle this zone operation. Try the operation again in a few seconds.
    #[doc(alias = "CKErrorZoneBusy")]
    pub const ZoneBusy: Self = Self(23);
    /// An error that occurs when the operation can’t complete for the specified database.
    ///
    /// ## Discussion
    ///
    /// The system submitted the operation to the wrong database. Make sure you aren’t submitting a share operation to the public database, or a record zone create operation to the shared database.
    ///
    ///
    /// Operation could not be completed on the given database. Likely caused by attempting to modify zones in the public database.
    #[doc(alias = "CKErrorBadDatabase")]
    pub const BadDatabase: Self = Self(24);
    /// An error that occurs when saving a record exceeds the user’s storage quota.
    ///
    /// ## Discussion
    ///
    /// **In the public database**: Your app’s container doesn’t have enough storage. Individual users can’t do anything about this, but you can go to the CloudKit Dashboard to view and manage your container’s storage.
    ///
    /// **In the private database**: The user doesn’t have enough iCloud storage. Prompt the user to go to iCloud settings to manage their storage.
    ///
    /// **In the shared database**: The owner of the shared record zone doesn’t have enough iCloud storage. The user can’t do anything about this, but can contact the owner about upgrading their storage or cleaning up their iCloud account.
    ///
    ///
    /// Saving a record would exceed quota
    #[doc(alias = "CKErrorQuotaExceeded")]
    pub const QuotaExceeded: Self = Self(25);
    /// An error that occurs when the specified record zone doesn’t exist.
    /// The specified zone does not exist on the server
    #[doc(alias = "CKErrorZoneNotFound")]
    pub const ZoneNotFound: Self = Self(26);
    /// An error that occurs when a request’s size exceeds the limit.
    ///
    /// ## Discussion
    ///
    /// The server can change its limits at any time, but the following are general guidelines:
    ///
    /// - 400 items (records or shares) per operation
    ///
    /// - 2 MB per request (not counting asset sizes)
    ///
    /// If your app receives [`CKErrorLimitExceeded`](https://developer.apple.com/documentation/cloudkit/ckerror/code/limitexceeded), it must split the operation in half and try both requests again.
    ///
    ///
    /// The request to the server was too large. Retry this request as a smaller batch.
    #[doc(alias = "CKErrorLimitExceeded")]
    pub const LimitExceeded: Self = Self(27);
    /// An error that occurs when the user deletes a record zone using the Settings app.
    /// The user deleted this zone through the settings UI. Your client should either remove its local data or prompt the user before attempting to re-upload any data to this zone.
    #[doc(alias = "CKErrorUserDeletedZone")]
    pub const UserDeletedZone: Self = Self(28);
    /// An error that occurs when a share has too many participants.
    ///
    /// ## Discussion
    ///
    /// Remove some participants before you retry the operation. Limits can change at any time, but CloudKit generally enforces a maximum of 100 participants for a share.
    ///
    ///
    /// A share cannot be saved because there are too many participants attached to the share
    #[doc(alias = "CKErrorTooManyParticipants")]
    pub const TooManyParticipants: Self = Self(29);
    /// An error that occurs when CloudKit attempts to share a record with an existing share.
    ///
    /// ## Discussion
    ///
    /// A record can exist in only a single share at a time. This error means that one of the following conditions exists:
    ///
    /// - The record already has an existing share.
    ///
    /// - The record has a parent, and its parent has a share.
    ///
    /// - The record is a parent, and one of its children has a share.
    ///
    ///
    /// A record/share cannot be saved, doing so would cause a hierarchy of records to exist in multiple shares
    #[doc(alias = "CKErrorAlreadyShared")]
    pub const AlreadyShared: Self = Self(30);
    /// An error that occurs when CloudKit can’t find the target of a reference.
    /// The target of a record's parent or share reference was not found
    #[doc(alias = "CKErrorReferenceViolation")]
    pub const ReferenceViolation: Self = Self(31);
    /// An error that occurs when CloudKit rejects a request due to a managed-account restriction.
    ///
    /// ## Discussion
    ///
    /// The system restricts CloudKit access for this account. This is a nonrecoverable error.
    ///
    ///
    /// Request was rejected due to a managed account restriction
    #[doc(alias = "CKErrorManagedAccountRestricted")]
    pub const ManagedAccountRestricted: Self = Self(32);
    /// An error that occurs when the user isn’t a participant of the share.
    ///
    /// ## Discussion
    ///
    /// A fetch share metadata operation fails when the user isn’t a participant of the share. However, there are invited participants on the share with email addresses or phone numbers that don’t have associations with an iCloud account. The user may be able to join a share by associating one of those email addresses or phone numbers with the user’s iCloud account.
    ///
    /// Call [`openURL:`](https://developer.apple.com/documentation/uikit/uiapplication/openurl(_:)) on the share URL to have the user attempt to verify their information.
    ///
    ///
    /// Share Metadata cannot be determined, because the user is not a member of the share.  There are invited participants on the share with email addresses or phone numbers not associated with any iCloud account. The user may be able to join the share if they can associate one of those email addresses or phone numbers with their iCloud account via the system Share Accept UI. Call UIApplication's openURL on this share URL to have the user attempt to verify their information.
    #[doc(alias = "CKErrorParticipantMayNeedVerification")]
    pub const ParticipantMayNeedVerification: Self = Self(33);
    /// An error that occurs when CloudKit is unable to maintain the network connection and provide a response.
    /// The server received and processed this request, but the response was lost due to a network failure.  There is no guarantee that this request succeeded.  Your client should re-issue the request (if it is idempotent), or fetch data from the server to determine if the request succeeded.
    #[doc(alias = "CKErrorServerResponseLost")]
    pub const ServerResponseLost: Self = Self(34);
    /// An error that occurs when the system can’t access the specified asset.
    /// The file for this asset could not be accessed. It is likely your application does not have permission to open the file, or the file may be temporarily unavailable due to its data protection class. This operation can be retried after it is able to be opened in your process.
    #[doc(alias = "CKErrorAssetNotAvailable")]
    pub const AssetNotAvailable: Self = Self(35);
    /// An error that occurs when the user’s iCloud account is temporarily unavailable.
    ///
    /// ## Discussion
    ///
    /// You receive this error when the user’s iCloud account is available, but isn’t ready to support CloudKit operations. Don’t delete any cached data and don’t enqueue any additional CloudKit operations.
    ///
    /// Checking the account status after the operation fails, assuming there are no other changes to the account’s status, returns [`CKAccountStatusTemporarilyUnavailable`](https://developer.apple.com/documentation/cloudkit/ckaccountstatus/temporarilyunavailable). Use the [`CKAccountChanged`](https://developer.apple.com/documentation/foundation/nsnotification/name-swift.struct/ckaccountchanged) notification to listen for future account status changes, and retry the operation after the status becomes [`CKAccountStatusAvailable`](https://developer.apple.com/documentation/cloudkit/ckaccountstatus/available).
    ///
    ///
    /// The current account is in a state that may need user intervention to recover from. The user should be directed to check the Settings app. Listen for CKAccountChangedNotifications to know when to re-check account status and retry.
    #[doc(alias = "CKErrorAccountTemporarilyUnavailable")]
    pub const AccountTemporarilyUnavailable: Self = Self(36);
    /// The user is already an invited participant on this share. They must accept the existing share invitation before continuing.
    /// The user is already an invited participant on this share. They must accept the existing share invitation before continuing.
    #[doc(alias = "CKErrorParticipantAlreadyInvited")]
    pub const ParticipantAlreadyInvited: Self = Self(37);
}

unsafe impl Encode for CKErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CKErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}
