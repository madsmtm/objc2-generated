//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-location")]
use objc2_core_location::*;
use objc2_foundation::*;

use crate::*;

/// A data type that CloudKit requires for record types.
pub type CKRecordType = NSString;

/// A data type that CloudKit requires for record field names.
pub type CKRecordFieldKey = NSString;

extern "C" {
    /// The system type that identifies a user record.
    ///
    /// ## Discussion
    ///
    /// CloudKit automatically creates a user record for each unique user of the app. User records are empty initially. You can add data to the user record using the same rules that apply for all records. Specifically, the type of data for a particular field name must be the same in all user records. However, you can’t create new user records using this record type and you can’t query for records of this type. To locate user records, you must know the ID of the user record or use the methods that [`CKContainer`](https://developer.apple.com/documentation/cloudkit/ckcontainer) provides to discover user records.
    ///
    ///
    /// Use this constant for the recordType parameter when fetching User Records.
    pub static CKRecordTypeUserRecord: &'static CKRecordType;
}

extern "C" {
    /// For use in queries to match on record properties.  Matches `record.recordID`.  Value is a ``CKRecordID``
    pub static CKRecordRecordIDKey: &'static CKRecordFieldKey;
}

extern "C" {
    /// For use in queries to match on record properties.  Matches `record.creatorUserRecordID`.  Value is a ``CKRecordID``
    pub static CKRecordCreatorUserRecordIDKey: &'static CKRecordFieldKey;
}

extern "C" {
    /// For use in queries to match on record properties.  Matches `record.creationDate`.  Value is a `NSDate`
    pub static CKRecordCreationDateKey: &'static CKRecordFieldKey;
}

extern "C" {
    /// For use in queries to match on record properties.  Matches `record.lastModifiedUserRecordID`.  Value is a ``CKRecordID``
    pub static CKRecordLastModifiedUserRecordIDKey: &'static CKRecordFieldKey;
}

extern "C" {
    /// For use in queries to match on record properties.  Matches `record.modificationDate`.  Value is a `NSDate`
    pub static CKRecordModificationDateKey: &'static CKRecordFieldKey;
}

extern "C" {
    /// The key constant that a record uses for its parent reference.
    /// For use in queries to match on record properties.  Matches `record.parent`
    pub static CKRecordParentKey: &'static CKRecordFieldKey;
}

extern "C" {
    /// The key constant that a record uses for its share reference.
    /// For use in queries to match on record properties.  Matches `record.share`
    pub static CKRecordShareKey: &'static CKRecordFieldKey;
}

extern_protocol!(
    /// The protocol that provides strong type-checking for objects that the CloudKit framework stores on the server.
    ///
    /// ## Overview
    ///
    /// CloudKit supports the following classes that adopt this protocol:
    ///
    /// - [`NSString`](https://developer.apple.com/documentation/foundation/nsstring)
    ///
    /// - [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber)
    ///
    /// - [`NSArray`](https://developer.apple.com/documentation/foundation/nsarray)
    ///
    /// - [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate)
    ///
    /// - [`NSData`](https://developer.apple.com/documentation/foundation/nsdata)
    ///
    /// - [`CKRecord.Reference`](https://developer.apple.com/documentation/cloudkit/ckrecord/reference)
    ///
    /// - [`CKAsset`](https://developer.apple.com/documentation/cloudkit/ckasset)
    ///
    /// - [`CLLocation`](https://developer.apple.com/documentation/corelocation/cllocation)
    ///
    /// Don’t adopt this protocol in your custom classes. CloudKit doesn’t support writing custom data types to the server. Attempting to do so results in an error.
    ///
    ///
    pub unsafe trait CKRecordValue: NSObjectProtocol {}
);

extern_class!(
    /// A collection of key-value pairs that store your app’s data.
    ///
    /// ## Overview
    ///
    /// Records are the fundamental objects that manage data in CloudKit. You can define any number of record types for your app, with each record type corresponding to a different type of information. Within a record type, you then define one or more fields, each with a name and a value. Records can contain simple data types, such as strings and numbers, or more complex types, such as geographic locations or pointers to other records.
    ///
    /// An important step in using CloudKit is defining the record types your app supports. A new record object doesn’t contain any keys or values. During development, you can add new keys and values at any time. The first time you set a value for a key and save the record, the server associates that type with the key for all records of the same type. The `CKRecord` class doesn’t impose these type constraints or do any local validation of a record’s contents. CloudKit enforces these constraints when you save the records.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The ability to add new keys is only possible during development. When you deploy to a production environment, the server returns an error if you try to specify an unknown record type or try to save a record that contains unknown keys.
    ///
    ///
    ///
    /// </div>
    /// Although records behave like dictionaries, there are limitations to the types of values you can assign to keys. The following are the object types that the `CKRecord` class supports. Attempting to specify objects of any other type results in failure. Fields of all types are searchable unless otherwise noted.
    ///
    /// ### Supported Data Types
    ///
    /// `CKRecord` fields support the following data types:
    ///
    /// - [`NSString`](https://developer.apple.com/documentation/foundation/nsstring): Stores relatively small amounts of text. Although strings themselves can be any length, use a [`CKAsset`](https://developer.apple.com/documentation/cloudkit/ckasset) to store large amounts of text.
    ///
    /// - [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber): Stores any numerical information, including integers and floating-point numbers.
    ///
    /// - [`NSData`](https://developer.apple.com/documentation/foundation/nsdata): Stores arbitrary bytes of data. A typical use for data objects is to map the bytes that they contain to a `struct`. Don’t use data objects for storing large binary data files; use a [`CKAsset`](https://developer.apple.com/documentation/cloudkit/ckasset) instead. Data fields aren’t searchable.
    ///
    /// - [`NSDate`](https://developer.apple.com/documentation/foundation/nsdate): Stores day and time information in an accessible form.
    ///
    /// - [`NSArray`](https://developer.apple.com/documentation/foundation/nsarray): Stores one or more objects of any other type in this table. You can store arrays of strings, arrays of numbers, arrays of references, and so on.
    ///
    /// - [`CLLocation`](https://developer.apple.com/documentation/corelocation/cllocation): Stores geographic coordinate data. You use locations in conjunction with the Core Location framework and any other services that handle location information.
    ///
    /// - [`CKAsset`](https://developer.apple.com/documentation/cloudkit/ckasset): Associates a disk-based file with the record. Although assets have a close association with records, you manage them separately. For more information about using assets, see [`CKAsset`](https://developer.apple.com/documentation/cloudkit/ckasset).
    ///
    /// - [`CKReference`](https://developer.apple.com/documentation/cloudkit/ckrecord/reference): Creates a link to a related record. A reference stores the ID of the target record. The advantage of using a reference instead of storing the ID as a string is that references can initiate cascade deletions of dependent records. The disadvantage is that references can only link between records in the same record zone. For more information, see [`CKReference`](https://developer.apple.com/documentation/cloudkit/ckrecord/reference).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To ensure the speed of fetching and saving records, the data that a record stores must not exceed 1 MB. Assets don’t count toward this limit, but all other data types do.
    ///
    ///
    ///
    /// </div>
    /// ### Defining Records
    ///
    /// The process for defining your record types depends entirely on your app and the data you’re trying to represent. It’s best to design records that encapsulate data for one unit of information. For example, you might use one record type to store an employee’s name, job title, and date of hire, and use a separate record type to store the employee’s address information. Using different record types lets you manage, manipulate, and validate the two types of information separately.
    ///
    /// Use fields that contain [`CKReference`](https://developer.apple.com/documentation/cloudkit/ckrecord/reference) objects to establish relationships between different types of records. After you define your record types, use the iCloud Dashboard to set them up. During development, you can also create new record types programmatically.
    ///
    /// ### Indexing the Fields of a Record
    ///
    /// Indexes make it possible to search the contents of your records efficiently. During development, the server indexes all fields with data types it can use in the predicate of a query. This automatic indexing makes it easier to experiment with queries during development, but the indexes require space in a database and require time to generate and maintain.
    ///
    /// To manage the indexing behavior of your records in the production environment, use CloudKit Dashboard. When migrating your schema from the development environment to the production environment, enable indexing only for the fields that your app uses in queries, and disable it for all other fields.
    ///
    /// ### Customizing Records
    ///
    /// Use this class as-is to manage data coming from or going to the server, and don’t subclass it.
    ///
    /// ### Storing Records Locally
    ///
    /// If you store records in a local database, use the [`encodeSystemFieldsWithCoder:`](https://developer.apple.com/documentation/cloudkit/ckrecord/encodesystemfields(with:)) method to encode and store the record’s metadata. The metadata contains the record ID and the change tag, which you need later to sync records in a local database with those in CloudKit.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKRecord;
);

extern_conformance!(
    unsafe impl NSCoding for CKRecord {}
);

extern_conformance!(
    unsafe impl NSCopying for CKRecord {}
);

unsafe impl CopyingHelper for CKRecord {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKRecord {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CKRecord {}
);

impl CKRecord {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// This creates the record in the default zone.
        #[unsafe(method(initWithRecordType:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithRecordType(
            this: Allocated<Self>,
            record_type: &CKRecordType,
        ) -> Retained<Self>;

        #[cfg(feature = "CKRecordID")]
        #[unsafe(method(initWithRecordType:recordID:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithRecordType_recordID(
            this: Allocated<Self>,
            record_type: &CKRecordType,
            record_id: &CKRecordID,
        ) -> Retained<Self>;

        #[cfg(feature = "CKRecordZoneID")]
        #[unsafe(method(initWithRecordType:zoneID:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithRecordType_zoneID(
            this: Allocated<Self>,
            record_type: &CKRecordType,
            zone_id: &CKRecordZoneID,
        ) -> Retained<Self>;

        #[unsafe(method(recordType))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordType(&self) -> Retained<CKRecordType>;

        #[cfg(feature = "CKRecordID")]
        #[unsafe(method(recordID))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordID(&self) -> Retained<CKRecordID>;

        /// Change tags are updated by the server to a unique value every time a record is modified.  A different change tag necessarily means that the contents of the record are different.
        #[unsafe(method(recordChangeTag))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordChangeTag(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "CKRecordID")]
        /// This is a User Record recordID, identifying the user that created this record.
        #[unsafe(method(creatorUserRecordID))]
        #[unsafe(method_family = none)]
        pub unsafe fn creatorUserRecordID(&self) -> Option<Retained<CKRecordID>>;

        #[unsafe(method(creationDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn creationDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "CKRecordID")]
        /// This is a User Record recordID, identifying the user that last modified this record.
        #[unsafe(method(lastModifiedUserRecordID))]
        #[unsafe(method_family = none)]
        pub unsafe fn lastModifiedUserRecordID(&self) -> Option<Retained<CKRecordID>>;

        #[unsafe(method(modificationDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn modificationDate(&self) -> Option<Retained<NSDate>>;

        /// In addition to
        /// `objectForKey:`and
        /// `setObject:forKey:,`dictionary-style subscripting (
        /// `record[key]`and
        ///
        /// ```text
        ///  record[key] = value
        /// ```
        ///
        /// ) can be used to get and set values.
        /// Acceptable value object classes are:
        /// - CKReference
        /// - CKAsset
        /// - CLLocation
        /// - NSData
        /// - NSDate
        /// - NSNumber
        /// - NSString
        /// - NSArray containing objects of any of the types above
        ///
        /// Any other classes will result in an exception with name
        /// `NSInvalidArgumentException.`
        /// Whenever possible, value objects will be copied when set on a record.
        ///
        /// Field keys starting with '_' are reserved. Attempting to set a key prefixed with a '_' will result in an error.
        ///
        /// Key names roughly match C variable name restrictions. They must begin with an ASCII letter and can contain ASCII letters and numbers and the underscore character.
        /// The maximum key length is 255 characters.
        #[unsafe(method(objectForKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectForKey(
            &self,
            key: &CKRecordFieldKey,
        ) -> Option<Retained<ProtocolObject<dyn CKRecordValue>>>;

        #[unsafe(method(setObject:forKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setObject_forKey(
            &self,
            object: Option<&ProtocolObject<dyn CKRecordValue>>,
            key: &CKRecordFieldKey,
        );

        #[unsafe(method(allKeys))]
        #[unsafe(method_family = none)]
        pub unsafe fn allKeys(&self) -> Retained<NSArray<CKRecordFieldKey>>;

        /// A special property that returns an array of token generated from all the string field values in the record.
        ///
        ///
        /// These tokens have been normalized for the current locale, so they are suitable for performing full-text searches.
        #[unsafe(method(allTokens))]
        #[unsafe(method_family = none)]
        pub unsafe fn allTokens(&self) -> Retained<NSArray<NSString>>;

        #[unsafe(method(objectForKeyedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectForKeyedSubscript(
            &self,
            key: &CKRecordFieldKey,
        ) -> Option<Retained<ProtocolObject<dyn CKRecordValue>>>;

        #[unsafe(method(setObject:forKeyedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setObject_forKeyedSubscript(
            &self,
            object: Option<&ProtocolObject<dyn CKRecordValue>>,
            key: &CKRecordFieldKey,
        );

        /// A list of keys that have been modified on the local CKRecord instance
        #[unsafe(method(changedKeys))]
        #[unsafe(method_family = none)]
        pub unsafe fn changedKeys(&self) -> Retained<NSArray<CKRecordFieldKey>>;

        /// `CKRecord`supports
        /// `NSSecureCoding.`When you invoke
        /// `encodeWithCoder:`on a
        /// `CKRecord,`it encodes all its values.  Including the record values you've set.
        /// If you want to store a
        /// `CKRecord`instance locally, AND you're already storing the record values locally, that's overkill.  In that case, you can use
        /// `encodeSystemFieldsWithCoder:.`This will encode all parts of a
        /// `CKRecord`except the record keys / values you have access to via the
        /// `changedKeys`and
        /// `objectForKey:`methods.
        /// If you use
        /// `initWithCoder:`to reconstitute a
        /// `CKRecord`you encoded via
        /// `encodeSystemFieldsWithCoder:,`then be aware that
        /// - any record values you had set on the original instance, but had not saved, will be lost
        /// - the reconstituted CKRecord's
        /// `changedKeys`will be empty
        ///
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(encodeSystemFieldsWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeSystemFieldsWithCoder(&self, coder: &NSCoder);

        #[cfg(feature = "CKReference")]
        /// The share property on a record can be set by creating a share using
        ///
        /// ```text
        ///  -[CKShare initWithRootRecord:]
        /// ```
        ///
        /// .
        ///
        /// The share property on a record will be removed when the corresponding CKShare is deleted from the server. Send this record in the same batch as the share delete and this record's share property will be updated.
        ///
        /// Sharing is only supported in zones with the
        /// `CKRecordZoneCapabilitySharing`capability. The default zone does not support sharing.
        ///
        /// If any records have a parent reference to this record, they are implicitly shared alongside this record.
        ///
        /// Note that records in a parent chain must only exist within one share. If a child record already has a share reference set then you will get a
        /// `CKErrorAlreadyShared`error if you try to share any of that record's parents.
        ///
        /// Child records can be shared independently, even if they have a common parent.  For example:
        /// Record A has two child records, Record B and Record C.
        /// A
        /// /
        /// \
        /// B   C
        ///
        /// These configurations are supported:
        /// - Record A part of Share 1, or
        /// - Record B part of Share 1, or
        /// - Record C part of Share 1, or
        /// - Record B part of Share 1, Record C part of Share 2
        ///
        /// These configurations are not supported:
        /// Record A part of Share 1, Record B part of Share 2, or
        /// -- This is not allowed because Record B would then be in two shares; Share 1 by being Record A's child, and Share 2
        /// Record A part of Share 1, Record C part of Share 2, or
        /// -- This is not allowed because Record C would then be in two shares; Share 1 by being Record A's child, and Share 2
        /// Record A part of Share 1, Record B part of Share 2, Record C part of Share 3
        /// -- This is not allowed because both Record B and Record C would then each be in two shares.
        ///
        /// Whenever possible, it is suggested that you construct your parent hierarchies such that you will only need to share the topmost record of that hierarchy.
        #[unsafe(method(share))]
        #[unsafe(method_family = none)]
        pub unsafe fn share(&self) -> Option<Retained<CKReference>>;

        #[cfg(feature = "CKReference")]
        /// Use a parent reference to teach CloudKit about the hierarchy of your records.
        ///
        ///
        /// When a record is shared, all children of that record are also shared.
        ///
        /// A parent record reference must have
        /// `CKReferenceActionNone`set. You can create a separate reference with
        /// `CKReferenceActionDeleteSelf`if you would like your hierarchy cleaned up when the parent record is deleted.
        ///
        /// The target of a parent reference must exist at save time - either already on the server, or part of the same
        /// `CKModifyRecordsOperation`batch.
        ///
        /// You are encouraged to set up the
        /// `parent`relationships as part of normal record saves, even if you're not planning on sharing records at this time.
        /// This allows you to share and unshare a hierarchy of records at a later date by only modifying the "top level" record, setting or clearing its
        /// `share`reference.
        #[unsafe(method(parent))]
        #[unsafe(method_family = none)]
        pub unsafe fn parent(&self) -> Option<Retained<CKReference>>;

        #[cfg(feature = "CKReference")]
        /// Setter for [`parent`][Self::parent].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setParent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setParent(&self, parent: Option<&CKReference>);

        /// Convenience wrappers around creating a
        /// `CKReference`to a parent record. The resulting
        /// `CKReference`will have
        ///
        /// ```text
        ///  referenceAction = CKReferenceActionNone
        /// ```
        #[unsafe(method(setParentReferenceFromRecord:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setParentReferenceFromRecord(&self, parent_record: Option<&CKRecord>);

        #[cfg(feature = "CKRecordID")]
        #[unsafe(method(setParentReferenceFromRecordID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setParentReferenceFromRecordID(&self, parent_record_id: Option<&CKRecordID>);
    );
}

extern_conformance!(
    unsafe impl CKRecordValue for NSString {}
);

extern_conformance!(
    unsafe impl CKRecordValue for NSNumber {}
);

extern_conformance!(
    unsafe impl CKRecordValue for NSArray {}
);

extern_conformance!(
    unsafe impl CKRecordValue for NSDate {}
);

extern_conformance!(
    unsafe impl CKRecordValue for NSData {}
);

/// CKRecordValue.
#[cfg(feature = "CKReference")]
impl CKReference {
    extern_methods!();
}

#[cfg(feature = "CKReference")]
extern_conformance!(
    unsafe impl CKRecordValue for CKReference {}
);

/// CKRecordValue.
#[cfg(feature = "CKAsset")]
impl CKAsset {
    extern_methods!();
}

#[cfg(feature = "CKAsset")]
extern_conformance!(
    unsafe impl CKRecordValue for CKAsset {}
);

#[cfg(feature = "objc2-core-location")]
extern_conformance!(
    unsafe impl CKRecordValue for CLLocation {}
);

extern_protocol!(
    /// A protocol for managing the key-value pairs of a CloudKit record.
    /// Formalizes a protocol for getting and setting keys on a CKRecord.  Not intended to be used directly by client code
    pub unsafe trait CKRecordKeyValueSetting: NSObjectProtocol {
        #[unsafe(method(objectForKey:))]
        #[unsafe(method_family = none)]
        unsafe fn objectForKey(
            &self,
            key: &CKRecordFieldKey,
        ) -> Option<Retained<ProtocolObject<dyn CKRecordValue>>>;

        #[unsafe(method(setObject:forKey:))]
        #[unsafe(method_family = none)]
        unsafe fn setObject_forKey(
            &self,
            object: Option<&ProtocolObject<dyn CKRecordValue>>,
            key: &CKRecordFieldKey,
        );

        #[unsafe(method(objectForKeyedSubscript:))]
        #[unsafe(method_family = none)]
        unsafe fn objectForKeyedSubscript(
            &self,
            key: &CKRecordFieldKey,
        ) -> Option<Retained<ProtocolObject<dyn CKRecordValue>>>;

        #[unsafe(method(setObject:forKeyedSubscript:))]
        #[unsafe(method_family = none)]
        unsafe fn setObject_forKeyedSubscript(
            &self,
            object: Option<&ProtocolObject<dyn CKRecordValue>>,
            key: &CKRecordFieldKey,
        );

        #[unsafe(method(allKeys))]
        #[unsafe(method_family = none)]
        unsafe fn allKeys(&self) -> Retained<NSArray<CKRecordFieldKey>>;

        #[unsafe(method(changedKeys))]
        #[unsafe(method_family = none)]
        unsafe fn changedKeys(&self) -> Retained<NSArray<CKRecordFieldKey>>;
    }
);

/// CKRecordKeyValueSettingConformance.
impl CKRecord {
    extern_methods!(
        /// Any values set here will be locally encrypted before being saved to the server and locally decrypted when fetched from the server. Encryption and decryption is handled by the CloudKit framework.
        /// Key material necessary for decryption are available to the owner of the record, as well as any users that can access this record via a CKShare.
        /// All CKRecordValue types can be set here except CKAsset and CKReference.
        #[unsafe(method(encryptedValues))]
        #[unsafe(method_family = none)]
        pub unsafe fn encryptedValues(
            &self,
        ) -> Retained<ProtocolObject<dyn CKRecordKeyValueSetting>>;
    );
}

extern_conformance!(
    unsafe impl CKRecordKeyValueSetting for CKRecord {}
);
