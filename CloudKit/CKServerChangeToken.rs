//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An opaque token that represents a specific point in a database’s history.
    ///
    /// ## Overview
    ///
    /// CloudKit uses server change tokens to record significant events in a database’s history, such as record creation, modification, and deletion. Using change tokens helps reduce the cost of a fetch operation — both the time to execute the fetch and the overall number of records it returns.
    ///
    /// You don’t create change tokens. Instead, [`CKFetchDatabaseChangesOperation`](https://developer.apple.com/documentation/cloudkit/ckfetchdatabasechangesoperation) and [`CKFetchRecordZoneChangesOperation`](https://developer.apple.com/documentation/cloudkit/ckfetchrecordzonechangesoperation) provide them during their execution and when they complete. Cache each token as you receive it, overwriting any previous token for the database or record zone you’re fetching from. Then, pass the cached token with your next fetch and CloudKit returns only the changes that occur after that point. Don’t infer any behavior or order from a token’s contents.
    ///
    /// The change tokens that [`CKFetchDatabaseChangesOperation`](https://developer.apple.com/documentation/cloudkit/ckfetchdatabasechangesoperation) provides aren’t compatible with [`CKFetchRecordZoneChangesOperation`](https://developer.apple.com/documentation/cloudkit/ckfetchrecordzonechangesoperation) and vice versa, so segregate them in your cache.
    ///
    /// Change tokens conform to [`NSSecureCoding`](https://developer.apple.com/documentation/foundation/nssecurecoding) and are safe to cache on-disk, as the following example shows:
    ///
    /// ```swift
    /// func writeToken(_ token: CKServerChangeToken, to url: URL) throws {
    ///     // Use a keyed archiver to securely encode the provided token.
    ///     let coder = NSKeyedArchiver(requiringSecureCoding: true)
    ///     coder.encode(token, forKey: "token")
    ///         
    ///     // Write the encoded data to disk. The caller provides the
    ///     // location as a file URL.
    ///     let data = coder.encodedData
    ///     try data.write(to: url)
    /// }
    ///     
    /// func readToken(at url: URL) throws -> CKServerChangeToken? {
    ///     // Create a Data instance with the contents of the file at
    ///     // the provided URL.
    ///     let data = try Data(contentsOf: url)
    ///         
    ///     // Use a keyed unarchiver to decode the token and return
    ///     // it to the caller.
    ///     let coder = try NSKeyedUnarchiver(forReadingFrom: data)
    ///     return coder.decodeObject(of: CKServerChangeToken.self, forKey: "token")
    /// }
    /// ```
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKServerChangeToken;
);

unsafe impl Send for CKServerChangeToken {}

unsafe impl Sync for CKServerChangeToken {}

extern_conformance!(
    unsafe impl NSCoding for CKServerChangeToken {}
);

extern_conformance!(
    unsafe impl NSCopying for CKServerChangeToken {}
);

unsafe impl CopyingHelper for CKServerChangeToken {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKServerChangeToken {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for CKServerChangeToken {}
);

impl CKServerChangeToken {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
