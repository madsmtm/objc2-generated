//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Constants that represent the scope of a database.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CKDatabaseScope(pub NSInteger);
impl CKDatabaseScope {
    /// The public database.
    #[doc(alias = "CKDatabaseScopePublic")]
    pub const Public: Self = Self(1);
    /// The private database.
    #[doc(alias = "CKDatabaseScopePrivate")]
    pub const Private: Self = Self(2);
    /// The shared database.
    #[doc(alias = "CKDatabaseScopeShared")]
    pub const Shared: Self = Self(3);
}

unsafe impl Encode for CKDatabaseScope {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CKDatabaseScope {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that represents a collection of record zones and subscriptions.
    ///
    /// ## Overview
    ///
    /// A database takes requests and operations and applies them to the objects it contains, whether that’s record zones, records, or subscriptions. Each of your app’s users has access to the three separate databases:
    ///
    /// - A public database that’s accessible to all users of your app.
    ///
    /// - A private database that’s accessible only to the user of the current device.
    ///
    /// - A shared database that’s accessible only to the user of the current device, which contains records that other iCloud users share with them.
    ///
    /// The public database is always available, even when the device doesn’t have an active iCloud account. In this scenario, your app can fetch specific records and perform searches, but it can’t create or modify records. CloudKit requires an iCloud account for writing to the public database so it can identify the authors of any changes. All access to the private and shared databases requires an iCloud account.
    ///
    /// You don’t create instances of [`CKDatabase`](https://developer.apple.com/documentation/cloudkit/ckdatabase), nor do you subclass it. Instead, you access the required database using one of your app’s containers. For more information, see [`CKContainer`](https://developer.apple.com/documentation/cloudkit/ckcontainer).
    ///
    /// By default, CloudKit executes the methods in this class with a low-priority quality of service (QoS). To use a higher-priority QoS, perform the following:
    ///
    /// 1. Create an instance of [`CKOperationConfiguration`](https://developer.apple.com/documentation/cloudkit/ckoperation/configuration-swift.class) and set its [`qualityOfService`](https://developer.apple.com/documentation/cloudkit/ckoperation/configuration-swift.class/qualityofservice) property to the preferred value.
    ///
    /// 2. Call the databaseʼs [`configuredWith(configuration:group:body:)`](https://developer.apple.com/documentation/cloudkit/ckdatabase/configuredwith(configuration:group:body:)-637p1) method and provide the configuration and a trailing closure.
    ///
    /// 3. In the closure, use the provided database to execute the relevant methods at the preferred QoS.
    ///
    /// ```swift
    /// func fetchRecords(with ids: [CKRecord.ID]) async throws
    ///     -> [CKRecord.ID: Result<CKRecord, Error>] {
    ///
    ///     // Get a reference to the user's private database.
    ///     let database = CKContainer.default().privateCloudDatabase
    ///
    ///     // Create a configuration with a higher-priority quality of service.
    ///     let config = CKOperation.Configuration()
    ///     config.qualityOfService = .userInitiated
    ///
    ///     // Configure the database and execute the fetch.
    ///     return try await database.configuredWith(configuration: config) { db in
    ///         try await db.records(for: ids)
    ///     }
    /// }
    /// ```
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKDatabase;
);

unsafe impl Send for CKDatabase {}

unsafe impl Sync for CKDatabase {}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKDatabase {}
);

impl CKDatabase {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[cfg(all(feature = "CKDatabaseOperation", feature = "CKOperation"))]
        #[unsafe(method(addOperation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addOperation(&self, operation: &CKDatabaseOperation);

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(databaseScope))]
        #[unsafe(method_family = none)]
        pub unsafe fn databaseScope(&self) -> CKDatabaseScope;
    );
}

/// ConvenienceMethods.
///
/// Convenience APIs
///
///
/// These calls operate on a single item in the default zone and allow for simple operations.
/// If you'd like to batch your requests, add dependencies between requests, set priorities, or schedule operations on your own queue, take a look at the corresponding
/// `CKOperation.`This work is treated as having
/// `NSQualityOfServiceUserInitiated`quality of service.
impl CKDatabase {
    extern_methods!(
        #[cfg(all(feature = "CKRecord", feature = "CKRecordID", feature = "block2"))]
        /// `CKFetchRecordsOperation`and
        /// `CKModifyRecordsOperation`are the more configurable,
        /// `CKOperation`-based alternatives to these methods
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchRecordWithID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchRecordWithID_completionHandler(
            &self,
            record_id: &CKRecordID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKRecord, *mut NSError)>,
        );

        #[cfg(all(feature = "CKRecord", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(saveRecord:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveRecord_completionHandler(
            &self,
            record: &CKRecord,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKRecord, *mut NSError)>,
        );

        #[cfg(all(feature = "CKRecordID", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(deleteRecordWithID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteRecordWithID_completionHandler(
            &self,
            record_id: &CKRecordID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKRecordID, *mut NSError)>,
        );

        #[cfg(all(
            feature = "CKQuery",
            feature = "CKRecord",
            feature = "CKRecordZoneID",
            feature = "block2"
        ))]
        /// `CKQueryOperation`is the more configurable,
        /// `CKOperation`-based alternative to this method
        /// Queries can potentially return a large number of records, and the server will return those records in batches. This convenience API will only fetch the first batch of results (equivalent to using
        /// `CKQueryOperationMaximumResults).`If you would like to fetch all results, use
        /// `CKQueryOperation`and its
        /// `CKQueryCursor`instead.
        /// Queries invoked within a
        /// `sharedCloudDatabase`must specify a
        /// `zoneID.`Cross-zone queries are not supported in a
        /// `sharedCloudDatabase`Queries that do not specify a
        /// `zoneID`will perform a query across all zones in the database.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(performQuery:inZoneWithID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performQuery_inZoneWithID_completionHandler(
            &self,
            query: &CKQuery,
            zone_id: Option<&CKRecordZoneID>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSArray<CKRecord>, *mut NSError)>,
        );

        #[cfg(all(feature = "CKRecordZone", feature = "block2"))]
        /// `CKFetchRecordZonesOperation`and
        /// `CKModifyRecordZonesOperation`are the more configurable,
        /// `CKOperation`-based alternatives to these methods
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchAllRecordZonesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchAllRecordZonesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSArray<CKRecordZone>, *mut NSError)>,
        );

        #[cfg(all(
            feature = "CKRecordZone",
            feature = "CKRecordZoneID",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchRecordZoneWithID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchRecordZoneWithID_completionHandler(
            &self,
            zone_id: &CKRecordZoneID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKRecordZone, *mut NSError)>,
        );

        #[cfg(all(feature = "CKRecordZone", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(saveRecordZone:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveRecordZone_completionHandler(
            &self,
            zone: &CKRecordZone,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKRecordZone, *mut NSError)>,
        );

        #[cfg(all(feature = "CKRecordZoneID", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(deleteRecordZoneWithID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteRecordZoneWithID_completionHandler(
            &self,
            zone_id: &CKRecordZoneID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKRecordZoneID, *mut NSError)>,
        );

        #[cfg(all(feature = "CKSubscription", feature = "block2"))]
        /// `CKFetchSubscriptionsOperation`and
        /// `CKModifySubscriptionsOperation`are the more configurable,
        /// `CKOperation`-based alternative to these methods
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchSubscriptionWithID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchSubscriptionWithID_completionHandler(
            &self,
            subscription_id: &CKSubscriptionID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKSubscription, *mut NSError)>,
        );

        #[cfg(all(feature = "CKSubscription", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchAllSubscriptionsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchAllSubscriptionsWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<CKSubscription>, *mut NSError),
            >,
        );

        #[cfg(all(feature = "CKSubscription", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(saveSubscription:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveSubscription_completionHandler(
            &self,
            subscription: &CKSubscription,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKSubscription, *mut NSError)>,
        );

        #[cfg(all(feature = "CKSubscription", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(deleteSubscriptionWithID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteSubscriptionWithID_completionHandler(
            &self,
            subscription_id: &CKSubscriptionID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKSubscriptionID, *mut NSError)>,
        );
    );
}
