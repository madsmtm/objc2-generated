//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// A constant that provides the current user’s default name.
    /// Stand-in for the current user's ID; most often used in RecordZoneID->ownerName
    pub static CKCurrentUserDefaultName: &'static NSString;
}

extern "C" {
    /// A constant that provides the default owner’s name.
    #[deprecated]
    pub static CKOwnerDefaultName: &'static NSString;
}

extern_class!(
    /// A conduit to your app’s databases.
    ///
    /// ## Overview
    ///
    /// A container manages all explicit and implicit attempts to access its contents.
    ///
    /// Every app has a default container that manages its own content. If you develop a suite of apps, you can access any containers that you have the appropriate entitlements for. Each new container distinguishes between public and private data. CloudKit always stores private data in the appropriate container directory in the user’s iCloud account.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  `CKContainer` instances operate with a [`NSQualityOfServiceUserInitiated`](https://developer.apple.com/documentation/foundation/qualityofservice/userinitiated) quality of service level by default. For information about quality of service, see [Prioritize Work with Quality of Service Classes](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/PrioritizeWorkWithQoS.html#//apple_ref/doc/uid/TP40015243-CH39) in [Energy Efficiency Guide for iOS Apps](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/EnergyGuide-iOS/index.html#//apple_ref/doc/uid/TP40015243) and [Prioritize Work at the Task Level](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/PrioritizeWorkAtTheTaskLevel.html#//apple_ref/doc/uid/TP40013929-CH35) in [Energy Efficiency Guide for Mac Apps](https://developer.apple.com/library/archive/documentation/Performance/Conceptual/power_efficiency_guidelines_osx/index.html#//apple_ref/doc/uid/TP40013929).
    ///
    ///
    ///
    /// </div>
    /// ### Interacting with a Container
    ///
    /// A container coordinates all interactions between your app and the server. Most of these interactions involve the following tasks:
    ///
    /// - Determining whether the user has an iCloud account, which lets you know if you can write data to the user’s personal storage.
    ///
    /// - With the user’s permission, discovering other users who the current user knows, and making the current user’s information discoverable.
    ///
    /// - Getting the container or one of its databases to use with an operation.
    ///
    /// ### Public and Private Databases
    ///
    /// Each container provides a public and a private database for storing data. The contents of the public database are accessible to all users of the app, whereas the contents of the private database are, by default, visible only to the current user. Content that is specific to a single user usually belongs in that user’s private database, whereas app-related content that you provide (or that users want to share) belongs in the public database.
    ///
    /// The public database is always available, regardless of whether the device has an active iCloud account. When there isn’t an iCloud account, your app can fetch records from and query the public database, but it can’t save changes. Saving records to the public database requires an active iCloud account to identify the owner of those records. Access to the private database always requires an active iCloud account on the device.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The data in a public database counts toward the iCloud storage quota of the app that owns the container. That data doesn’t count toward the storage quota of any single user. Data in the private database counts toward the user’s iCloud storage quota.
    ///
    ///
    ///
    /// </div>
    /// ### Using iCloud
    ///
    /// Whenever possible, design your app to run gracefully with or without an active iCloud account. Even without an active iCloud account, apps can fetch records from the public database and display that information to the user. If your app requires the ability to write to the public database or requires access to the private database, notify the user of the reason and encourage them to enable iCloud. You can even provide a button that takes the user directly to Settings so that they can enable iCloud. To implement such a button, have the button’s action open the URL that the [`UIApplicationOpenSettingsURLString`](https://developer.apple.com/documentation/uikit/uiapplication/opensettingsurlstring) constant provides.
    ///
    /// ### User Records and Permissions
    ///
    /// When a user accesses a container for the first time, CloudKit assigns them a unique identifier and uses it to create two user records — one in the app’s public database and another in that user’s private database. By default, these records don’t contain any identifying personal information, but you can use the record in the user’s private database to store additional, nonsensitive information about that user. Because the public database’s user record is accessible to all users of your app, don’t use it to store information about the user.
    ///
    /// While a user record isn’t the same as the user’s [`CKUserIdentity`](https://developer.apple.com/documentation/cloudkit/ckuseridentity), the identity does provide the identifier of their user record that you can use to fetch that record from either the public database or the user’s private database. For more information, see [`userRecordID`](https://developer.apple.com/documentation/cloudkit/ckuseridentity/userrecordid).
    ///
    /// ### Testing Your Code Using the Development Container
    ///
    /// At runtime, CloudKit uses your app’s `com.apple.developer.icloud-container-environment` entitlement to discover whether you’re using a `Development` or `Production` version of your provisioning profile. When you configure the entitlement for development, CloudKit configures the app’s containers to use the development server. The development environment is a safe place to make changes during the development process without disrupting users of your app. You can add new fields to records programmatically, and you can delete or modify fields using iCloud Dashboard.
    ///
    /// Before shipping your app, always test your app’s behavior in the production environment. The production server generates errors when your app tries to add record types or add new fields to existing record types. Testing in the production environment helps you find and fix the places in your code where you’re making those types of changes. You can use CloudKit Dashboard to modify record types in the development environment, and then migrate those changes to the production environment.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Simulator works only with the development environment. When you’re ready to test your app in a production environment, do so from a device.
    ///
    ///
    ///
    /// </div>
    ///
    /// A CKContainer, and its CKDatabases, are the main entry points into the CloudKit framework.
    ///
    ///
    /// Several methods in CloudKit accept completion handlers to indicate when they're completed.
    /// All CKOperation subclasses include progress and completion blocks to report significant events in their lifecycles.
    /// Each of these handlers and blocks is invoked on a non-main serial queue.  The receiver is responsible for handling the message on a different queue or thread if it is required.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CKContainer;
);

unsafe impl Send for CKContainer {}

unsafe impl Sync for CKContainer {}

extern_conformance!(
    unsafe impl NSObjectProtocol for CKContainer {}
);

impl CKContainer {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        /// Convenience method that uses the calling process' "iCloud.\(application-identifier)" as the container identifier
        ///
        ///
        /// application-identifier is the calling process'
        /// `application-identifier`entitlement on iOS / tvOS / watchOS.
        /// application-identifier is the calling process'
        /// `com.apple.application-identifier`entitlement on macOS.
        /// On all OSes, if an
        /// `com.apple.developer.associated-application-identifier`entitlement is present, its value will be preferred over the
        /// `application-identifier`variants.
        #[unsafe(method(defaultContainer))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultContainer() -> Retained<CKContainer>;

        /// Obtain a CKContainer for the given containerIdentifier
        ///
        ///
        /// If the application is in production mode (aka,
        /// `com.apple.developer.icloud-container-environment`is set to Production in your entitlements plist, and you have no override in
        /// `com.apple.developer.icloud-container-development-container-identifiers),`then the production environment is used.
        #[unsafe(method(containerWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn containerWithIdentifier(
            container_identifier: &NSString,
        ) -> Retained<CKContainer>;

        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(containerIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn containerIdentifier(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "CKOperation")]
        #[unsafe(method(addOperation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addOperation(&self, operation: &CKOperation);
    );
}

/// Database.
///
/// Database properties:
/// Records in a public database
/// - By default are world readable, owner writable.
/// - Can be locked down by Roles, a process done in the Developer Portal, a web interface.  Roles are not present in the client API.
/// - Are visible to the application developer via the Developer Portal.
/// - Do not contribute to the owner's iCloud account storage quota.
/// Records in a private database
/// - By default are only owner readable and owner writable.
/// - Are not visible to the application developer via the Developer Portal.
/// - Are counted towards the owner's iCloud account storage quota.
/// Records in a shared database
/// - Are available to share participants based on the permissions of the enclosing CKShare
/// - Are not visible to the application developer via the Developer Portal.
/// - Are counted towards the originating owner's iCloud account storage quota.
impl CKContainer {
    extern_methods!(
        #[cfg(feature = "CKDatabase")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(privateCloudDatabase))]
        #[unsafe(method_family = none)]
        pub unsafe fn privateCloudDatabase(&self) -> Retained<CKDatabase>;

        #[cfg(feature = "CKDatabase")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(publicCloudDatabase))]
        #[unsafe(method_family = none)]
        pub unsafe fn publicCloudDatabase(&self) -> Retained<CKDatabase>;

        #[cfg(feature = "CKDatabase")]
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(sharedCloudDatabase))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedCloudDatabase(&self) -> Retained<CKDatabase>;

        #[cfg(feature = "CKDatabase")]
        /// Convenience methods
        ///
        ///
        /// Returns: a database that's pointer-equal to one of the above properties
        #[unsafe(method(databaseWithDatabaseScope:))]
        #[unsafe(method_family = none)]
        pub unsafe fn databaseWithDatabaseScope(
            &self,
            database_scope: CKDatabaseScope,
        ) -> Retained<CKDatabase>;
    );
}

/// Constants that indicate the availability of the user’s iCloud account.
/// credentials in Settings app.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CKAccountStatus(pub NSInteger);
impl CKAccountStatus {
    /// CloudKit can’t determine the status of the user’s iCloud account.
    #[doc(alias = "CKAccountStatusCouldNotDetermine")]
    pub const CouldNotDetermine: Self = Self(0);
    /// The user’s iCloud account is available.
    #[doc(alias = "CKAccountStatusAvailable")]
    pub const Available: Self = Self(1);
    /// The system denies access to the user’s iCloud account.
    ///
    /// ## Discussion
    ///
    /// Your app can’t access the user’s iCloud account due to restrictions that Parental Controls or Mobile Device Management impose.
    ///
    ///
    #[doc(alias = "CKAccountStatusRestricted")]
    pub const Restricted: Self = Self(2);
    /// The device doesn’t have an iCloud account.
    #[doc(alias = "CKAccountStatusNoAccount")]
    pub const NoAccount: Self = Self(3);
    /// The user’s iCloud account is temporarily unavailable.
    ///
    /// ## Discussion
    ///
    /// You receive this account status when the user’s iCloud account is available, but isn’t ready to support CloudKit operations. Don’t delete any cached data and don’t enqueue any CloudKit operations after receipt of this account status. Instead, use the [`CKAccountChanged`](https://developer.apple.com/documentation/foundation/nsnotification/name-swift.struct/ckaccountchanged) notification to listen for when the status changes to [`CKAccountStatusAvailable`](https://developer.apple.com/documentation/cloudkit/ckaccountstatus/available).
    ///
    ///
    #[doc(alias = "CKAccountStatusTemporarilyUnavailable")]
    pub const TemporarilyUnavailable: Self = Self(4);
}

unsafe impl Encode for CKAccountStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CKAccountStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A notification that a container posts when the status of an iCloud account changes.
    ///
    /// ## Discussion
    ///
    /// Create an instance of [`CKContainer`](https://developer.apple.com/documentation/cloudkit/ckcontainer) to receive this notification. The container posts the notification using an arbitrary queue. Use the [`accountStatus(completionHandler:)`](https://developer.apple.com/documentation/cloudkit/ckcontainer/accountstatus(completionhandler:)) method to obtain the account’s status.
    ///
    ///
    /// This local notification is posted when there has been any change to the logged in iCloud account.
    ///
    ///
    /// On receipt, an updated account status should be obtained by calling
    /// `accountStatusWithCompletionHandler:`
    pub static CKAccountChangedNotification: &'static NSString;
}

/// AccountStatus.
impl CKContainer {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(accountStatusWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn accountStatusWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(CKAccountStatus, *mut NSError)>,
        );
    );
}

/// Constants that represent the permissions that a user grants.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CKApplicationPermissions(pub NSUInteger);
bitflags::bitflags! {
    impl CKApplicationPermissions: NSUInteger {
/// The user is discoverable using their email address.
/// Allows the user's record in CloudKit to be discoverable via the user's email address
        #[doc(alias = "CKApplicationPermissionUserDiscoverability")]
#[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
        const UserDiscoverability = 1<<0;
    }
}

unsafe impl Encode for CKApplicationPermissions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for CKApplicationPermissions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that represent the status of a permission.
// NS_ENUM
#[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CKApplicationPermissionStatus(pub NSInteger);
impl CKApplicationPermissionStatus {
    /// The app is yet to request the permission.
    #[doc(alias = "CKApplicationPermissionStatusInitialState")]
    #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
    pub const InitialState: Self = Self(0);
    /// An error that occurs while processing the permission request.
    #[doc(alias = "CKApplicationPermissionStatusCouldNotComplete")]
    #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
    pub const CouldNotComplete: Self = Self(1);
    /// The user denies the permission.
    #[doc(alias = "CKApplicationPermissionStatusDenied")]
    #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
    pub const Denied: Self = Self(2);
    /// The user grants the permission.
    #[doc(alias = "CKApplicationPermissionStatusGranted")]
    #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
    pub const Granted: Self = Self(3);
}

unsafe impl Encode for CKApplicationPermissionStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CKApplicationPermissionStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A closure that processes the outcome of a permissions request.
///
/// ## Discussion
///
/// When you request or determine the status of a permission, use this closure to process the result. The closure has no return value and takes the following parameters:
///
/// - The permission’s status. For a list of possible values, see [`CKApplicationPermissionStatus`](https://developer.apple.com/documentation/cloudkit/ckcontainer/applicationpermissionstatus).
///
/// - An error if the system can’t fulfill the request, or `nil` if it successfully determines the status.
///
///
#[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
#[cfg(feature = "block2")]
pub type CKApplicationPermissionBlock =
    *mut block2::DynBlock<dyn Fn(CKApplicationPermissionStatus, *mut NSError)>;

/// ApplicationPermission.
impl CKContainer {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer.
        #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
        #[unsafe(method(statusForApplicationPermission:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn statusForApplicationPermission_completionHandler(
            &self,
            application_permission: CKApplicationPermissions,
            completion_handler: CKApplicationPermissionBlock,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer.
        #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
        #[unsafe(method(requestApplicationPermission:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestApplicationPermission_completionHandler(
            &self,
            application_permission: CKApplicationPermissions,
            completion_handler: CKApplicationPermissionBlock,
        );
    );
}

/// UserRecords.
impl CKContainer {
    extern_methods!(
        #[cfg(all(feature = "CKRecordID", feature = "block2"))]
        /// If there is no iCloud account configured, or if access is restricted, a
        /// `CKErrorNotAuthenticated`error will be returned.
        ///
        /// This work is treated as having
        /// `NSQualityOfServiceUserInitiated`quality of service.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchUserRecordIDWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchUserRecordIDWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKRecordID, *mut NSError)>,
        );

        #[cfg(all(feature = "CKUserIdentity", feature = "block2"))]
        /// Fetches all user identities that match an entry in the user's contacts database.
        ///
        ///
        /// `CKDiscoverAllUserIdentitiesOperation`is the more configurable,
        /// `CKOperation`-based alternative to this methods
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
        #[unsafe(method(discoverAllIdentitiesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn discoverAllIdentitiesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<CKUserIdentity>, *mut NSError),
            >,
        );

        #[cfg(all(feature = "CKUserIdentity", feature = "block2"))]
        /// Fetches the user identity that corresponds to the given email address.
        ///
        ///
        /// Only users who have opted-in to user discoverability will have their identities returned by this method.  If a user with the inputted email exists in iCloud, but has not opted-in to user discoverability, this method completes with a nil
        /// `userInfo.``CKDiscoverUserIdentitiesOperation`is the more configurable,
        /// `CKOperation`-based alternative to this method
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
        #[unsafe(method(discoverUserIdentityWithEmailAddress:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn discoverUserIdentityWithEmailAddress_completionHandler(
            &self,
            email: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKUserIdentity, *mut NSError)>,
        );

        #[cfg(all(feature = "CKUserIdentity", feature = "block2"))]
        /// Fetches the user identity that corresponds to the given phone number.
        ///
        ///
        /// Only users who have opted-in to user discoverability will have their identities returned by this method.  If a user with the inputted phone number exists in iCloud, but has not opted-in to user discoverability, this method completes with a nil
        /// `userInfo.``CKDiscoverUserIdentitiesOperation`is the more configurable,
        /// `CKOperation`-based alternative to this method
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
        #[unsafe(method(discoverUserIdentityWithPhoneNumber:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn discoverUserIdentityWithPhoneNumber_completionHandler(
            &self,
            phone_number: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKUserIdentity, *mut NSError)>,
        );

        #[cfg(all(feature = "CKRecordID", feature = "CKUserIdentity", feature = "block2"))]
        /// Fetches the user identity that corresponds to the given user record id.
        ///
        ///
        /// Only users who have opted-in to user discoverability will have their identities returned by this method.  If a user has not opted-in to user discoverability, this method completes with a nil
        /// `userInfo.``CKDiscoverUserIdentitiesOperation`is the more configurable,
        /// `CKOperation`-based alternative to this method
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[deprecated = "No longer supported. Please see Sharing CloudKit Data with Other iCloud Users."]
        #[unsafe(method(discoverUserIdentityWithUserRecordID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn discoverUserIdentityWithUserRecordID_completionHandler(
            &self,
            user_record_id: &CKRecordID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKUserIdentity, *mut NSError)>,
        );
    );
}

/// Sharing.
impl CKContainer {
    extern_methods!(
        #[cfg(all(feature = "CKShareParticipant", feature = "block2"))]
        /// Fetches share participants matching the provided info.
        ///
        ///
        /// `CKFetchShareParticipantsOperation`is the more configurable,
        /// `CKOperation`-based alternative to these methods.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchShareParticipantWithEmailAddress:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchShareParticipantWithEmailAddress_completionHandler(
            &self,
            email_address: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKShareParticipant, *mut NSError)>,
        );

        #[cfg(all(feature = "CKShareParticipant", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchShareParticipantWithPhoneNumber:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchShareParticipantWithPhoneNumber_completionHandler(
            &self,
            phone_number: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKShareParticipant, *mut NSError)>,
        );

        #[cfg(all(
            feature = "CKRecordID",
            feature = "CKShareParticipant",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchShareParticipantWithUserRecordID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchShareParticipantWithUserRecordID_completionHandler(
            &self,
            user_record_id: &CKRecordID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKShareParticipant, *mut NSError)>,
        );

        #[cfg(all(feature = "CKShareMetadata", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchShareMetadataWithURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchShareMetadataWithURL_completionHandler(
            &self,
            url: &NSURL,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKShareMetadata, *mut NSError)>,
        );

        #[cfg(all(
            feature = "CKRecord",
            feature = "CKShare",
            feature = "CKShareMetadata",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(acceptShareMetadata:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn acceptShareMetadata_completionHandler(
            &self,
            metadata: &CKShareMetadata,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKShare, *mut NSError)>,
        );
    );
}

/// CKLongLivedOperations.
impl CKContainer {
    extern_methods!(
        #[cfg(all(feature = "CKOperation", feature = "block2"))]
        /// Long lived CKOperations returned by this call must be started on an operation queue.
        /// Remember to set the callback blocks before starting the operation.
        /// If an operation has already completed against the server, and is subsequently resumed, that operation will replay all of its callbacks from the start of the operation, but the request will not be re-sent to the server.
        /// If a long lived operation is cancelled or finishes completely it is no longer returned by these calls.
        ///
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchAllLongLivedOperationIDsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchAllLongLivedOperationIDsWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<CKOperationID>, *mut NSError),
            >,
        );

        #[cfg(all(feature = "CKOperation", feature = "block2"))]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(fetchLongLivedOperationWithID:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchLongLivedOperationWithID_completionHandler(
            &self,
            operation_id: &CKOperationID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CKOperation, *mut NSError)>,
        );
    );
}
