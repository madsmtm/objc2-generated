//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// A filter that finds the maximum pixel value in a rectangular region centered around each pixel in the source image.
    ///
    /// ## Overview
    ///
    /// If there are multiple channels in the source image, each channel is processed independently. The [`edgeMode`](https://developer.apple.com/documentation/metalperformanceshaders/mpsunaryimagekernel/edgemode) property value is assumed to always be [`MPSImageEdgeModeClamp`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageedgemode/clamp) for this filter.
    ///
    ///
    /// The MPSImageAreaMax kernel finds the maximum pixel value in a rectangular region centered around each pixel
    /// in the source image. If there are multiple channels in the source image, each channel is processed independently.
    /// The edgeMode property is assumed to always be MPSImageEdgeModeClamp for this filter.
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageAreaMax;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageAreaMax {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageAreaMax {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageAreaMax {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageAreaMax {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageAreaMax {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAreaMax {
    extern_methods!(
        /// The height of the filter window. Must be an odd number.
        #[unsafe(method(kernelHeight))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelHeight(&self) -> NSUInteger;

        /// The width of the filter window. Must be an odd number.
        #[unsafe(method(kernelWidth))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelWidth(&self) -> NSUInteger;

        /// Set the kernel height and width
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel. Must be an odd number.
        ///
        /// Parameter `kernelHeight`: The height of the kernel. Must be an odd number.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAreaMax {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAreaMax {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A filter that finds the minimum pixel value in a rectangular region centered around each pixel in the source image.
    ///
    /// ## Overview
    ///
    /// An [`MPSImageAreaMin`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageareamin) filter has the same methods and properties as the [`MPSImageAreaMax`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageareamax) class.
    ///
    /// If there are multiple channels in the source image, each channel is processed independently. The [`edgeMode`](https://developer.apple.com/documentation/metalperformanceshaders/mpsunaryimagekernel/edgemode) property value is assumed to always be [`MPSImageEdgeModeClamp`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageedgemode/clamp) for this filter.
    ///
    ///
    /// The MPSImageAreaMin finds the minimum pixel value in a rectangular region centered around each pixel in the
    /// source image. If there are multiple channels in the source image, each channel is processed independently.
    /// It has the same methods as MPSImageAreaMax
    /// The edgeMode property is assumed to always be MPSImageEdgeModeClamp for this filter.
    #[unsafe(super(MPSImageAreaMax, MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageAreaMin;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageAreaMin {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageAreaMin {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageAreaMin {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageAreaMin {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageAreaMin {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAreaMin {
    extern_methods!();
}

/// Methods declared on superclass `MPSImageAreaMax`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAreaMin {
    extern_methods!(
        /// Set the kernel height and width
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel. Must be an odd number.
        ///
        /// Parameter `kernelHeight`: The height of the kernel. Must be an odd number.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAreaMin {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAreaMin {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A filter that finds the maximum pixel value in a rectangular region by applying a dilation function.
    ///
    /// ## Overview
    ///
    /// An [`MPSImageDilate`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagedilate) filter behaves like the [`MPSImageAreaMax`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageareamax) filter, except Metal calculates the intensity at each position relative to a different value before determining which is the maximum pixel value, allowing for shaped, nonrectangular morphological probes.
    ///
    /// The code example below shows pseudocode for the calculation that returns each pixel value:
    ///
    /// ```other
    /// for each pixel in the filter window
    ///     value = pixel[filterY][filterX] - filter[filterY*filter_width+filterX]
    ///     if( value > bestValue ){
    ///         result = value
    ///         bestValue = value
    ///     }
    /// ```
    ///
    /// A filter that contains all zeros is identical to an [`MPSImageAreaMax`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageareamax) filter. Metal handles the center filter element as `0` to avoid causing a general darkening of the image, and it handles the [`edgeMode`](https://developer.apple.com/documentation/metalperformanceshaders/mpsunaryimagekernel/edgemode) property  as [`MPSImageEdgeModeClamp`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageedgemode/clamp) for this filter.
    ///
    ///
    /// The MPSImageDilate finds the maximum pixel value in a rectangular region centered around each pixel in the
    /// source image. It is like the MPSImageAreaMax, except that the intensity at each position is calculated relative
    /// to a different value before determining which is the maximum pixel value, allowing for shaped, non-rectangular
    /// morphological probes.
    ///
    /// ```text
    ///           for each pixel in the filter window:
    ///               value =  pixel[filterY][filterX] - filter[filterY*filter_width+filterX]
    ///               if( value > bestValue ){
    ///                    result = value
    ///                    bestValue = value;
    ///               }
    /// ```
    ///
    /// A filter that contains all zeros and is identical to a MPSImageAreaMax filter.  The center filter element
    /// is assumed to be 0 to avoid causing a general darkening of the image.
    ///
    /// The edgeMode property is assumed to always be MPSImageEdgeModeClamp for this filter.
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageDilate;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageDilate {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageDilate {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageDilate {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageDilate {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageDilate {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageDilate {
    extern_methods!(
        /// The height of the filter window. Must be an odd number.
        #[unsafe(method(kernelHeight))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelHeight(&self) -> NSUInteger;

        /// The width of the filter window. Must be an odd number.
        #[unsafe(method(kernelWidth))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelWidth(&self) -> NSUInteger;

        /// Init a object with kernel height, width and weight values.
        ///
        /// Each dilate shape probe defines a 3D surface of values.
        /// These are arranged in order left to right, then top to bottom
        /// in a 1D array. (values[kernelWidth*y+x] = probe[y][x])
        /// Values should be generally be in the range [0,1] with the center
        /// pixel tending towards 0 and edges towards 1. However, any numerical
        /// value is allowed. Calculations are subject to the usual floating-point
        /// rounding error.
        ///
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel. Must be an odd number.
        ///
        /// Parameter `kernelHeight`: The height of the kernel. Must be an odd number.
        ///
        /// Parameter `values`: The set of values to use as the dilate probe.
        /// The values are copied into the filter. To avoid
        /// image ligthening or darkening, the center value should
        /// be 0.0f.
        ///
        /// # Safety
        ///
        /// `values` must be a valid pointer.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:values:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_values(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            values: NonNull<c_float>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageDilate {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageDilate {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A filter that finds the minimum pixel value in a rectangular region by applying an erosion function.
    ///
    /// ## Overview
    ///
    /// An [`MPSImageErode`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageerode) behaves like the [`MPSImageAreaMin`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageareamin) filter, except that Metal calculates the intensity at each position relative to a different value before determining which is the maximum pixel value, allowing for shaped, nonrectangular morphological probes.
    ///
    /// The code example below shows pseudocode for the calculation that returns each pixel value:
    ///
    /// ```other
    /// for each pixel in the filter window
    ///     value =  pixel[filterY][filterX] + filter[filterY*filter_width+filterX]
    ///     if( value < bestValue ){
    ///         result = value
    ///         bestValue = value
    ///     }
    /// ```
    ///
    /// The definition of the [`MPSImageErode`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageerode) filter is different from its `vImage` counterpart (`MPSImageErode_filter_value = 1.0f-vImageErode_filter_value.`). This allows [`MPSImageDilate`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagedilate) and [`MPSImageErode`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageerode) to use the same filter, making open and close operators easier to write.
    ///
    /// A filter that contains all zeros is identical to an [`MPSImageAreaMin`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageareamin) filter. Metal handles the center filter element as `0` to avoid causing a general lightening of the image, and it handles the [`edgeMode`](https://developer.apple.com/documentation/metalperformanceshaders/mpsunaryimagekernel/edgemode) property as [`MPSImageEdgeModeClamp`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageedgemode/clamp) for this filter.
    ///
    ///
    /// The MPSImageErode filter finds the minimum pixel value in a rectangular region centered around each pixel in the
    /// source image. It is like the MPSImageAreaMin, except that the intensity at each position is calculated relative
    /// to a different value before determining which is the maximum pixel value, allowing for shaped, non-rectangular
    /// morphological probes.
    ///
    /// ```text
    ///           for each pixel in the filter window:
    ///               value =  pixel[filterY][filterX] + filter[filterY*filter_width+filterX]
    ///               if( value < bestValue ){
    ///                    result = value
    ///                    bestValue = value;
    ///               }
    /// ```
    ///
    /// A filter that contains all zeros is identical to a MPSImageAreaMin filter. The center filter element
    /// is assumed to be 0, to avoid causing a general lightening of the image.
    ///
    /// The definition of the filter for MPSImageErode is different from vImage. (MPSErode_filter_value = 1.0f-vImageErode_filter_value.)
    /// This allows MPSImageDilate and MPSImageErode to use the same filter, making open and close operators easier to write.
    /// The edgeMode property is assumed to always be MPSImageEdgeModeClamp for this filter.
    #[unsafe(super(MPSImageDilate, MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageErode;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageErode {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageErode {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageErode {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageErode {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageErode {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageErode {
    extern_methods!();
}

/// Methods declared on superclass `MPSImageDilate`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageErode {
    extern_methods!(
        /// Init a object with kernel height, width and weight values.
        ///
        /// Each dilate shape probe defines a 3D surface of values.
        /// These are arranged in order left to right, then top to bottom
        /// in a 1D array. (values[kernelWidth*y+x] = probe[y][x])
        /// Values should be generally be in the range [0,1] with the center
        /// pixel tending towards 0 and edges towards 1. However, any numerical
        /// value is allowed. Calculations are subject to the usual floating-point
        /// rounding error.
        ///
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel. Must be an odd number.
        ///
        /// Parameter `kernelHeight`: The height of the kernel. Must be an odd number.
        ///
        /// Parameter `values`: The set of values to use as the dilate probe.
        /// The values are copied into the filter. To avoid
        /// image ligthening or darkening, the center value should
        /// be 0.0f.
        ///
        /// # Safety
        ///
        /// `values` must be a valid pointer.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:values:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_values(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            values: NonNull<c_float>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageErode {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageErode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
