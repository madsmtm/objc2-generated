//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Perform Guided Filter to produce a coefficients image
    /// The filter is broken into two stages:
    /// - Regression
    /// - Reconstruction
    ///
    /// The regression stage learns a 4-channel "coefficient" texture (typically at a very low resolution),
    /// and represents the per-pixel linear regression of the source texture to the guidance texture.
    ///
    /// The reconstruction stage upsamples the coefficeints to the same size as the final output and
    /// then at each pixel computes the inner product to produce the output.
    ///
    /// The filter is broken into two stages to allow coefficients to be filtered (such as for example - temporally filtering for video to prevent flicker).
    ///
    /// There is also support for an optional weight texture that can be used to discard values in the source data.
    ///
    /// Guided Filter is described at https://arxiv.org/pdf/1505.00996.pdf.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageguidedfilter?language=objc)
    #[unsafe(super(MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSImageGuidedFilter;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageGuidedFilter {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageGuidedFilter {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageGuidedFilter {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageGuidedFilter {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageGuidedFilter {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSImageGuidedFilter {
    extern_methods!(
        /// The local window size
        ///
        /// The local window size.
        #[unsafe(method(kernelDiameter))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelDiameter(&self) -> NSUInteger;

        /// The regularization parameter
        ///
        /// The parameter used when computing the linear coefficients a and b.
        #[unsafe(method(epsilon))]
        #[unsafe(method_family = none)]
        pub unsafe fn epsilon(&self) -> c_float;

        /// Setter for [`epsilon`][Self::epsilon].
        #[unsafe(method(setEpsilon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEpsilon(&self, epsilon: c_float);

        /// The scale parameter
        ///
        /// The parameter used to scale the result of the reconstruction operation.
        /// The default value is 1.0f.
        #[unsafe(method(reconstructScale))]
        #[unsafe(method_family = none)]
        pub unsafe fn reconstructScale(&self) -> c_float;

        /// Setter for [`reconstructScale`][Self::reconstructScale].
        #[unsafe(method(setReconstructScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setReconstructScale(&self, reconstruct_scale: c_float);

        /// The offset parameter
        ///
        /// The offset parameter added to the result of the scaled reconstructed value.
        /// The default value is 0.0f.
        #[unsafe(method(reconstructOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reconstructOffset(&self) -> c_float;

        /// Setter for [`reconstructOffset`][Self::reconstructOffset].
        #[unsafe(method(setReconstructOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setReconstructOffset(&self, reconstruct_offset: c_float);

        /// Specifies information to apply the guided filter regression.
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelDiameter`: The local window size
        ///
        /// Returns: A valid MPSImageGuidedFilterRegression object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelDiameter:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelDiameter(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_diameter: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        /// Perform Guided Filter Regression (correlation) to produce a coefficients texture
        ///
        /// The filter will not begin to execute until after the command buffer has been enqueued and committed.
        ///
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer.
        ///
        /// Parameter `sourceTexture`: Input source texture to be filtered (typically a mask).  This should be a single channel image.
        ///
        /// Parameter `guidanceTexture`: Input guidance texture.  This should be a color (RGB) image.
        ///
        /// Parameter `weightsTexture`: Optional input confidence texture.  This should also a single channel image.
        ///
        /// Parameter `destinationCoefficientsTexture`: Output texture with four coefficients that minimize the mean squared error between
        /// the source and an affine function of guidance R, G, B.
        /// Note: The destinationCoefficientsTexture computes the linear cofficients "a" and "b".  The "a" coefficient is
        /// stored in the RGB channels of destinationCoefficientsTexture and the "b" coefficient in the alpha chnanel.
        ///
        /// Set the MPSKernelOptionsAllowReducedPrecision in the "options" property for this kernel to peform the
        /// computations using half-precision arithmetic.  This can potentially improve performance and/or power usage.
        ///
        /// # Safety
        ///
        /// - `source_texture` may need to be synchronized.
        /// - `source_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `guidance_texture` may need to be synchronized.
        /// - `guidance_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `weights_texture` may need to be synchronized.
        /// - `weights_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `destination_coefficients_texture` may need to be synchronized.
        /// - `destination_coefficients_texture` may be unretained, you must ensure it is kept alive while in use.
        #[unsafe(method(encodeRegressionToCommandBuffer:sourceTexture:guidanceTexture:weightsTexture:destinationCoefficientsTexture:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRegressionToCommandBuffer_sourceTexture_guidanceTexture_weightsTexture_destinationCoefficientsTexture(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_texture: &ProtocolObject<dyn MTLTexture>,
            guidance_texture: &ProtocolObject<dyn MTLTexture>,
            weights_texture: Option<&ProtocolObject<dyn MTLTexture>>,
            destination_coefficients_texture: &ProtocolObject<dyn MTLTexture>,
        );

        /// Perform Guided Filter Reconstruction (inference) to produce the filtered output
        ///
        /// The filter will not begin to execute until after the command buffer has been enqueued and committed.
        ///
        /// Parameter sourceGuidanceTexture Input guidance pixel buffer.  This should be a color (RGB) image.
        /// Parameter coefficientsTexture   Input coefficients texture generated generated by a previous encodeRegressionToCommandBuffer
        ///
        /// Parameter `destinationTexture`: Output texture
        ///
        /// Note: The coefficients are upsampled at the reconstruction of the filtered data.
        /// Reconstruct(guidance RGB) = a.r * R + a.g * G + a.b * B + b, where a and b
        /// are the coefficients learnt using encodeRegressionToCommandBuffer.
        ///
        /// Final reconstructed value = value * reconstructScale + reconstructOffset
        ///
        /// # Safety
        ///
        /// - `guidance_texture` may need to be synchronized.
        /// - `guidance_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `coefficients_texture` may need to be synchronized.
        /// - `coefficients_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `destination_texture` may need to be synchronized.
        /// - `destination_texture` may be unretained, you must ensure it is kept alive while in use.
        #[unsafe(method(encodeReconstructionToCommandBuffer:guidanceTexture:coefficientsTexture:destinationTexture:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeReconstructionToCommandBuffer_guidanceTexture_coefficientsTexture_destinationTexture(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            guidance_texture: &ProtocolObject<dyn MTLTexture>,
            coefficients_texture: &ProtocolObject<dyn MTLTexture>,
            destination_texture: &ProtocolObject<dyn MTLTexture>,
        );

        /// Perform per-channel (non-color correlated) Guided Filter Regression (correlation) to produce a coefficients texture
        ///
        /// The filter will not begin to execute until after the command buffer has been enqueued and committed.
        /// This encode call differs from the one above in that the correlations are not computed across channels
        /// and therefore this filter computes two coefficient textures: ai and bi.
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer.
        ///
        /// Parameter `sourceTexture`: Input source texture to be filtered.
        ///
        /// Parameter `guidanceTexture`: Input guidance texture.  This should be a color (RGB) image.
        ///
        /// Parameter `weightsTexture`: Optional input confidence texture.  This should be a single channel image.
        ///
        /// Parameter `destinationCoefficientsTextureA`: Output texture with four coefficients A that minimize the mean squared error between
        /// the source channels and an affine function of guidance channels.
        ///
        /// Parameter `destinationCoefficientsTextureB`: Output texture with four coefficients B that minimize the mean squared error between
        /// the source channels and an affine function of guidance channels.
        ///
        /// Set the MPSKernelOptionsAllowReducedPrecision in the "options" property for this kernel to peform the
        /// computations using half-precision arithmetic.  This can potentially improve performance and/or power usage.
        ///
        /// # Safety
        ///
        /// - `source_texture` may need to be synchronized.
        /// - `source_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `guidance_texture` may need to be synchronized.
        /// - `guidance_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `weights_texture` may need to be synchronized.
        /// - `weights_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `destination_coefficients_texture_a` may need to be synchronized.
        /// - `destination_coefficients_texture_a` may be unretained, you must ensure it is kept alive while in use.
        /// - `destination_coefficients_texture_b` may need to be synchronized.
        /// - `destination_coefficients_texture_b` may be unretained, you must ensure it is kept alive while in use.
        #[unsafe(method(encodeRegressionToCommandBuffer:sourceTexture:guidanceTexture:weightsTexture:destinationCoefficientsTextureA:destinationCoefficientsTextureB:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRegressionToCommandBuffer_sourceTexture_guidanceTexture_weightsTexture_destinationCoefficientsTextureA_destinationCoefficientsTextureB(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_texture: &ProtocolObject<dyn MTLTexture>,
            guidance_texture: &ProtocolObject<dyn MTLTexture>,
            weights_texture: Option<&ProtocolObject<dyn MTLTexture>>,
            destination_coefficients_texture_a: &ProtocolObject<dyn MTLTexture>,
            destination_coefficients_texture_b: &ProtocolObject<dyn MTLTexture>,
        );

        /// Perform Guided Filter Reconstruction (inference) to produce the filtered output
        ///
        /// The filter will not begin to execute until after the command buffer has been enqueued and committed.
        ///
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer.
        ///
        /// Parameter `guidanceTexture`: Input guidance pixel buffer.
        ///
        /// Parameter `coefficientsTextureA`: Input coefficients A texture generated generated by a previous encodeRegressionToCommandBuffer.
        ///
        /// Parameter `coefficientsTextureB`: Input coefficients B texture generated generated by a previous encodeRegressionToCommandBuffer.
        ///
        /// Parameter `destinationTexture`: Output texture
        ///
        /// # Safety
        ///
        /// - `guidance_texture` may need to be synchronized.
        /// - `guidance_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `coefficients_texture_a` may need to be synchronized.
        /// - `coefficients_texture_a` may be unretained, you must ensure it is kept alive while in use.
        /// - `coefficients_texture_b` may need to be synchronized.
        /// - `coefficients_texture_b` may be unretained, you must ensure it is kept alive while in use.
        /// - `destination_texture` may need to be synchronized.
        /// - `destination_texture` may be unretained, you must ensure it is kept alive while in use.
        #[unsafe(method(encodeReconstructionToCommandBuffer:guidanceTexture:coefficientsTextureA:coefficientsTextureB:destinationTexture:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeReconstructionToCommandBuffer_guidanceTexture_coefficientsTextureA_coefficientsTextureB_destinationTexture(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            guidance_texture: &ProtocolObject<dyn MTLTexture>,
            coefficients_texture_a: &ProtocolObject<dyn MTLTexture>,
            coefficients_texture_b: &ProtocolObject<dyn MTLTexture>,
            destination_texture: &ProtocolObject<dyn MTLTexture>,
        );
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSImageGuidedFilter {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSImageGuidedFilter {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
