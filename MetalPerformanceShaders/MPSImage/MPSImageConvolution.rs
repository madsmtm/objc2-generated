//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// The MPSImageConvolution convolves an image with given filter of odd width and height.
    /// The center of the kernel aligns with the MPSImageConvolution.offset. That is, the position
    /// of the top left corner of the area covered by the kernel is given by
    /// MPSImageConvolution.offset - {kernel_width>>1, kernel_height>>1, 0}
    ///
    /// Optimized cases include 3x3,5x5,7x7,9x9,11x11, 1xN and Nx1. If a convolution kernel
    /// does not fall into one of these cases but is a rank-1 matrix (a.k.a. separable)
    /// then it will fall on an optimzied separable path. Other convolutions will execute with
    /// full MxN complexity.
    ///
    /// If there are multiple channels in the source image, each channel is processed independently.
    ///
    ///
    /// Performance: Separable convolution filters may perform better when done in two passes. A convolution filter
    /// is separable if the ratio of filter values between all rows is constant over the whole row. For
    /// example, this edge detection filter:
    ///
    /// ```text
    ///                       -1      0       1
    ///                       -2      0       2
    ///                       -1      0       1
    /// ```
    ///
    /// can be separated into the product of two vectors:
    ///
    /// ```text
    ///                       1
    ///                       2      x    [-1  0   1]
    ///                       1
    /// ```
    ///
    /// and consequently can be done as two, one-dimensional convolution passes back to back on the same image.
    /// In this way, the number of multiplies (ignoring the fact that we could skip zeros here) is reduced from
    /// 3*3=9 to 3+3 = 6. There are similar savings for addition. For large filters, the savings can be profound.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageconvolution?language=objc)
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageConvolution;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageConvolution {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageConvolution {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageConvolution {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageConvolution {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageConvolution {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageConvolution {
    extern_methods!(
        /// The height of the filter window. Must be an odd number.
        #[unsafe(method(kernelHeight))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelHeight(&self) -> NSUInteger;

        /// The width of the filter window. Must be an odd number.
        #[unsafe(method(kernelWidth))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelWidth(&self) -> NSUInteger;

        /// The bias is a value to be added to convolved pixel before it is converted back to the storage format.
        /// It can be used to convert negative values into a representable range for a unsigned MTLPixelFormat.
        /// For example, many edge detection filters produce results in the range [-k,k]. By scaling the filter
        /// weights by 0.5/k and adding 0.5, the results will be in range [0,1] suitable for use with unorm formats.
        /// It can be used in combination with renormalization of the filter weights to do video ranging as part
        /// of the convolution effect. It can also just be used to increase the brightness of the image.
        ///
        /// Default value is 0.0f.
        #[unsafe(method(bias))]
        #[unsafe(method_family = none)]
        pub unsafe fn bias(&self) -> c_float;

        /// Setter for [`bias`][Self::bias].
        #[unsafe(method(setBias:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBias(&self, bias: c_float);

        /// Initialize a convolution filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: the width of the kernel
        ///
        /// Parameter `kernelHeight`: the height of the kernel
        ///
        /// Parameter `kernelWeights`: A pointer to an array of kernelWidth * kernelHeight values to be used as the kernel.
        /// These are in row major order.
        ///
        /// Returns: A valid MPSImageConvolution object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `kernel_weights` must be a valid pointer.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:weights:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_weights(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            kernel_weights: NonNull<c_float>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSUnaryImageKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageConvolution {
    extern_methods!(
        /// Standard init with default properties per filter type
        ///
        /// Parameter `device`: The device that the filter will be used on. May not be NULL.
        ///
        /// Returns: a pointer to the newly initialized object. This will fail, returning
        /// nil if the device is not supported. Devices must be
        /// MTLFeatureSet_iOS_GPUFamily2_v1 or later.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageConvolution {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageConvolution {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The MPSImageLaplacian is an optimized variant of the MPSImageConvolution filter provided primarily for ease of use.
    /// This filter uses an optimized convolution filter with a 3 x 3 kernel with the following weights:
    /// [ 0  1  0
    /// 1 -4  1
    /// 0  1  0 ]
    ///
    /// The optimized convolution filter used by MPSImageLaplacian can also be used by creating a MPSImageConvolution
    /// object with kernelWidth = 3, kernelHeight = 3 and weights as specified above.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagelaplacian?language=objc)
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageLaplacian;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageLaplacian {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageLaplacian {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageLaplacian {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageLaplacian {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageLaplacian {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacian {
    extern_methods!(
        /// The bias is a value to be added to convolved pixel before it is converted back to the storage format.
        /// It can be used to convert negative values into a representable range for a unsigned MTLPixelFormat.
        /// For example, many edge detection filters produce results in the range [-k,k]. By scaling the filter
        /// weights by 0.5/k and adding 0.5, the results will be in range [0,1] suitable for use with unorm formats.
        /// It can be used in combination with renormalization of the filter weights to do video ranging as part
        /// of the convolution effect. It can also just be used to increase the brightness of the image.
        ///
        /// Default value is 0.0f.
        #[unsafe(method(bias))]
        #[unsafe(method_family = none)]
        pub unsafe fn bias(&self) -> c_float;

        /// Setter for [`bias`][Self::bias].
        #[unsafe(method(setBias:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBias(&self, bias: c_float);
    );
}

/// Methods declared on superclass `MPSUnaryImageKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacian {
    extern_methods!(
        /// Standard init with default properties per filter type
        ///
        /// Parameter `device`: The device that the filter will be used on. May not be NULL.
        ///
        /// Returns: a pointer to the newly initialized object. This will fail, returning
        /// nil if the device is not supported. Devices must be
        /// MTLFeatureSet_iOS_GPUFamily2_v1 or later.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacian {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacian {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The MPSImageBox convolves an image with given filter of odd width and height. The kernel elements
    /// all have equal weight, achieving a blur effect. (Each result is the unweighted average of the
    /// surrounding pixels.) This allows for much faster algorithms, espcially for larger blur radii.
    /// The box height and width must be odd numbers. The box blur is a separable filter. The implementation
    /// is aware of this and will act accordingly to give best performance for multi-dimensional blurs.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagebox?language=objc)
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageBox;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageBox {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageBox {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageBox {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageBox {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageBox {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageBox {
    extern_methods!(
        /// The height of the filter window.
        #[unsafe(method(kernelHeight))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelHeight(&self) -> NSUInteger;

        /// The width of the filter window.
        #[unsafe(method(kernelWidth))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelWidth(&self) -> NSUInteger;

        /// Initialize a filter for a particular kernel size and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: the width of the kernel.  Must be an odd number.
        ///
        /// Parameter `kernelHeight`: the height of the kernel. Must be an odd number.
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageBox {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageBox {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The box filter, while fast, may yield square-ish looking blur effects. However, multiple
    /// passes of the box filter tend to smooth out with each additional pass. For example, two 3-wide
    /// box blurs produces the same effective convolution as a 5-wide tent blur:
    ///
    /// ```text
    ///                       1   1   1
    ///                           1   1   1
    ///                       +       1   1   1
    ///                       =================
    ///                       1   2   3   2   1
    /// ```
    ///
    /// Addition passes tend to approximate a gaussian line shape.
    ///
    /// The MPSImageTent convolves an image with a tent filter. These form a tent shape with incrementally
    /// increasing sides, for example:
    ///
    /// 1   2   3   2   1
    ///
    /// 1   2   1
    /// 2   4   2
    /// 1   2   1
    ///
    /// Like the box filter, this arrangement allows for much faster algorithms, espcially for for larger blur
    /// radii but with a more pleasing appearance.
    ///
    /// The tent blur is a separable filter. The implementation is aware of this and will act accordingly
    /// to give best performance for multi-dimensional blurs.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagetent?language=objc)
    #[unsafe(super(MPSImageBox, MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageTent;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageTent {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageTent {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageTent {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageTent {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageTent {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageTent {
    extern_methods!();
}

/// Methods declared on superclass `MPSImageBox`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageTent {
    extern_methods!(
        /// Initialize a filter for a particular kernel size and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: the width of the kernel.  Must be an odd number.
        ///
        /// Parameter `kernelHeight`: the height of the kernel. Must be an odd number.
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageTent {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageTent {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The MPSImageGaussianBlur convolves an image with gaussian of given sigma in both x and y direction.
    ///
    /// The MPSImageGaussianBlur utilizes a very fast algorith that typically runs at approximately
    /// 1/2 of copy speeds. Notably, it is faster than either the tent or box blur except perhaps
    /// for very large filter windows. Mathematically, it is an approximate gaussian. Some
    /// non-gaussian behavior may be detectable with advanced analytical methods such as FFT.
    /// If a analytically clean gaussian filter is required, please use the MPSImageConvolution
    /// filter instead with an appropriate set of weights. The MPSImageGaussianBlur is intended
    /// to be suitable for all common image processing needs demanding ~10 bits of precision or
    /// less.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagegaussianblur?language=objc)
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageGaussianBlur;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageGaussianBlur {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageGaussianBlur {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageGaussianBlur {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageGaussianBlur {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageGaussianBlur {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageGaussianBlur {
    extern_methods!(
        /// Initialize a gaussian blur filter for a particular sigma and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `sigma`: The standard deviation of gaussian blur filter.
        /// Gaussian weight, centered at 0, at integer grid i is given as
        /// w(i) = 1/sqrt(2*pi*sigma) * exp(-i^2/(2*sigma^2))
        /// If we take cut off at 1% of w(0) (max weight) beyond which weights
        /// are considered 0, we have
        /// ceil (sqrt(-log(0.01)*2)*sigma) ~ ceil(3.7*sigma)
        /// as rough estimate of filter width
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:sigma:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sigma(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            sigma: c_float,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Read-only sigma value with which filter was created
        #[unsafe(method(sigma))]
        #[unsafe(method_family = none)]
        pub unsafe fn sigma(&self) -> c_float;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageGaussianBlur {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageGaussianBlur {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The MPSImageSobel implements the Sobel filter.
    /// When the color model (e.g. RGB, two-channel, grayscale, etc.) of source
    /// and destination textures match, the filter is applied to each channel
    /// separately. If the destination is monochrome (single channel) but source
    /// multichannel, the pixel values are converted to grayscale before applying Sobel
    /// operator using the linear gray color transform vector (v).
    ///
    /// Luminance = v[0] * pixel.x + v[1] * pixel.y + v[2] * pixel.z;
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagesobel?language=objc)
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageSobel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageSobel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageSobel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageSobel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageSobel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageSobel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageSobel {
    extern_methods!(
        /// Initialize a Sobel filter on a given device using the default color
        /// transform. Default: BT.601/JPEG {0.299f, 0.587f, 0.114f}
        ///
        /// For non-default conversion matrices, use -initWithDevice:linearGrayColorTransform:
        ///
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a Sobel filter on a given device with a non-default color transform
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `transform`: Array of three floats describing the rgb to gray scale color transform.
        ///
        /// ```text
        ///                           Luminance = transform[0] * pixel.x +
        ///                                       transform[1] * pixel.y +
        ///                                       transform[2] * pixel.z;
        /// ```
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `transform` must be a valid pointer.
        #[unsafe(method(initWithDevice:linearGrayColorTransform:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_linearGrayColorTransform(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            transform: NonNull<c_float>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        /// Returns a pointer to the array of three floats used to convert RGBA, RGB or RG images
        /// to the destination format when the destination is monochrome.
        #[unsafe(method(colorTransform))]
        #[unsafe(method_family = none)]
        pub unsafe fn colorTransform(&self) -> NonNull<c_float>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageSobel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageSobel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The MPSImageCanny implements the Canny edge detection algorithm.
    /// When the color model of the source and destination textures match, the
    /// filter is applied to each channel seperately. If the destination is monochrome
    /// but source multichannel, the source will be converted to grayscale using the
    /// linear gray color transform vector (v).
    /// Luminance = v[0] * pixel.x + v[1] * pixel.y + v[2] * pixel.z;
    ///
    /// The canny edge detection algorithm consists of 5 steps:
    /// 1. Blur the source image using a Gaussian blur with a sigma parameter
    /// 2. Use horizontal and vertical Sobel filters to find a gradient magnitude and
    /// direction.
    /// G = sqrt(Sx^2 + Sy^2)
    /// G_ang = arctan(Sy / Sx)
    /// 3. Perform non-maximum suppression to thin edges to single pixel widths.
    /// A pixel is considered to be a maxium along the edge if it has the largest
    /// gradient magnitude along the positive and negatve gradient direction. That
    /// is, if the gradient direction is 90°, if the gradient magnitude of a pixel is
    /// greater than its neighbors at -90° and 90° it is the maximum. Any pixel
    /// which is not a maximum will have its value suppressed, by setting it's
    /// magnitude to 0.
    /// 4. Double thresholding is preformed with two values ht and lt with ht > lt
    /// to classify a pixel as part of a weak or strong edge. A pixel with gradient
    /// value G is classified as:
    /// Strong edge: G > ht
    /// Weak edge: ht >= G > lt
    /// Not an edge: lt >= G
    /// 5. Edge tracking is performed along all weak edges to determine if they
    /// are part of a strong edge. Any weak edges which are connected to a
    /// strong edge are labelled true edges, along with strong edges themselves.
    /// A pixel can be connected through any of its 8 neighbors. Any pixel marked
    /// as a true edge is output with a high value, and all others are considered
    /// background and output with a low value.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagecanny?language=objc)
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageCanny;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageCanny {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageCanny {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageCanny {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageCanny {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageCanny {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageCanny {
    extern_methods!(
        /// Initialize a Canny filter on a given device using the default color
        /// transform and default sigma value for Gaussian blur.
        /// Default transform: BT.601/JPEG {0.299f, 0.587f, 0.114f}
        /// Default sigma: sqrt(2)
        ///
        /// For non-default parameters, use
        /// -initWithDevice:linearGrayColorTransform:sigma:
        ///
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a Canny filter on a given device with a non-default color transform and
        /// non-default sigma.
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `transform`: Array of three floats describing the rgb to gray scale color transform.
        ///
        /// ```text
        ///                           Luminance = transform[0] * pixel.x +
        ///                                       transform[1] * pixel.y +
        ///                                       transform[2] * pixel.z;
        /// ```
        ///
        ///
        /// Parameter `sigma`: The standard deviation of gaussian blur filter.
        /// Gaussian weight, centered at 0, at integer grid n is given as
        ///
        /// ```text
        ///                           w(i) = 1/sqrt(2*pi*sigma) * exp(-n^2/2*sigma^2)
        /// ```
        ///
        /// If we take cut off at 1% of w(0) (max weight) beyond which weights
        /// are considered 0, we have
        ///
        /// ```text
        ///                           ceil (sqrt(-log(0.01)*2)*sigma) ~ ceil(3.7*sigma)
        /// ```
        ///
        /// as rough estimate of filter width
        ///
        /// Returns: A valid object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `transform` must be a valid pointer.
        #[unsafe(method(initWithDevice:linearToGrayScaleTransform:sigma:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_linearToGrayScaleTransform_sigma(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            transform: NonNull<c_float>,
            sigma: c_float,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        /// Returns a pointer to the array of three floats used to convert RGBA, RGB or RG images
        /// to the destination format when the destination is monochrome.
        /// Value is readonly and user should not modify or free.
        #[unsafe(method(colorTransform))]
        #[unsafe(method_family = none)]
        pub unsafe fn colorTransform(&self) -> NonNull<c_float>;

        /// Read-only sigma value used in performing Gaussian blur of the image
        #[unsafe(method(sigma))]
        #[unsafe(method_family = none)]
        pub unsafe fn sigma(&self) -> c_float;

        /// Read-write value used to set the high threshold for double thresholding, value is normalized.
        /// Default is 0.4
        #[unsafe(method(highThreshold))]
        #[unsafe(method_family = none)]
        pub unsafe fn highThreshold(&self) -> c_float;

        /// Setter for [`highThreshold`][Self::highThreshold].
        #[unsafe(method(setHighThreshold:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHighThreshold(&self, high_threshold: c_float);

        /// Read-write value used to set the low threshold for double thresholding, value is normalized.
        /// Default is 0.2
        #[unsafe(method(lowThreshold))]
        #[unsafe(method_family = none)]
        pub unsafe fn lowThreshold(&self) -> c_float;

        /// Setter for [`lowThreshold`][Self::lowThreshold].
        #[unsafe(method(setLowThreshold:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLowThreshold(&self, low_threshold: c_float);

        /// Read-write value used to change algorithm to an approximation of the true Canny Edge detection Algorithm.
        /// When true, a limit is placed on how far a single strong edge can extend. The result will be similar to a true output
        /// but some edges may terminate early, resulting in minor differences for cases with long, weak edges. The performance
        /// for the approximate canny implementation is improved and should provide similar enough results for most cases.
        /// Extra tuning of the high and low thresholds as well as sigma may help achieve a more similar output in this mode.
        /// Default is YES
        #[unsafe(method(useFastMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn useFastMode(&self) -> bool;

        /// Setter for [`useFastMode`][Self::useFastMode].
        #[unsafe(method(setUseFastMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUseFastMode(&self, use_fast_mode: bool);
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageCanny {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageCanny {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The MPSImagePyramid is a base class for creating different kinds of pyramid images
    ///
    /// Currently supported pyramid-types are:
    /// MPSImageGaussianPyramid
    /// The Gaussian image pyramid kernel is enqueued as a in-place operation using
    /// MPSUnaryImageKernel::encodeToCommandBuffer:inPlaceTexture:fallbackCopyAllocator:and all mipmap levels after level=1, present in the provided image are filled using
    /// the provided filtering kernel. The fallbackCopyAllocator parameter is not used.
    ///
    /// The Gaussian image pyramid filter ignores
    /// clipRectand
    /// offsetand fills
    /// the entire mipmap levels.
    ///
    ///
    /// Note: Make sure your texture type is compatible with mipmapping and supports texture views
    /// (see
    /// MTLTextureUsagePixelFormatView).
    /// Note: Recall the size of the nth mipmap level:
    ///
    /// ```text
    ///                   w_n = max(1, floor(w_0 / 2^n))
    ///                   h_n = max(1, floor(h_0 / 2^n)),
    /// ```
    ///
    /// where w_0, h_0 are the zeroth level width and height. ie the image dimensions themselves.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagepyramid?language=objc)
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImagePyramid;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImagePyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImagePyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImagePyramid {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImagePyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImagePyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImagePyramid {
    extern_methods!(
        /// Initialize a downwards 5-tap image pyramid with the default filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        ///
        /// The filter kernel is the outer product of w = [ 1/16,  1/4,  3/8,  1/4,  1/16 ]^T, with itself
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a downwards 5-tap image pyramid with a central weight parameter and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `centerWeight`: Defines form of the filter-kernel  through the outer product ww^T, where
        /// w = [ (1/4 - a/2),  1/4,  a,  1/4,  (1/4 - a/2) ]^T and 'a' is centerWeight.
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:centerWeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_centerWeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            center_weight: c_float,
        ) -> Retained<Self>;

        /// Initialize a downwards n-tap pyramid with a custom filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelHeight`: The height of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelWeights`: A pointer to an array of kernelWidth * kernelHeight values to be
        /// used as the kernel.
        /// These are in row major order. See
        /// MPSImageConvolution.
        ///
        /// Returns: A valid object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `kernel_weights` must be a valid pointer.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:weights:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_weights(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            kernel_weights: NonNull<c_float>,
        ) -> Retained<Self>;

        /// The height of the filter window. Must be an odd number.
        #[unsafe(method(kernelHeight))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelHeight(&self) -> NSUInteger;

        /// The width of the filter window. Must be an odd number.
        #[unsafe(method(kernelWidth))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelWidth(&self) -> NSUInteger;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImagePyramid {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImagePyramid {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A Gaussian image pyramid is constructed as follows:
    /// The mipmap level zero is the source of the operation and is left untouched and
    /// the subsequent mipmap levels are constructed from it recursively:
    ///
    /// ```text
    ///                   mip[ level = n + 1 ] = Downsample( filter( mip[ level = n ] ) ), where
    /// ```
    ///
    /// "filter()" applies a filter with the specified convolution kernel and
    /// "Downsample()" removes odd rows and columns from the input image.
    /// The default convolution filter kernel for this operation is
    ///
    /// ```text
    ///                   k = w w^T, where w = [ 1/16,  1/4,  3/8,  1/4,  1/16 ]^T,
    /// ```
    ///
    /// but the user may also tweak this kernel with a
    /// centerWeightparameter: 'a':
    ///
    /// ```text
    ///                   k = w w^T, where w = [ (1/4 - a/2),  1/4,  a,  1/4,  (1/4 - a/2) ]^T
    /// ```
    ///
    /// or the user can provide a completely custom kernel.
    ///
    /// This procedure is continued until every mipmap level present in the image texture are
    /// filled with the pyramid levels.
    ///
    /// In case of the Gaussian pyramid the user must run the operation in-place using:
    /// MPSUnaryImageKernel::encodeToCommandBuffer:inPlaceTexture:fallbackCopyAllocator:,where the fallback allocator is ignored.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagegaussianpyramid?language=objc)
    #[unsafe(super(MPSImagePyramid, MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageGaussianPyramid;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageGaussianPyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageGaussianPyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageGaussianPyramid {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageGaussianPyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageGaussianPyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageGaussianPyramid {
    extern_methods!();
}

/// Methods declared on superclass `MPSImagePyramid`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageGaussianPyramid {
    extern_methods!(
        /// Initialize a downwards 5-tap image pyramid with the default filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        ///
        /// The filter kernel is the outer product of w = [ 1/16,  1/4,  3/8,  1/4,  1/16 ]^T, with itself
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a downwards 5-tap image pyramid with a central weight parameter and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `centerWeight`: Defines form of the filter-kernel  through the outer product ww^T, where
        /// w = [ (1/4 - a/2),  1/4,  a,  1/4,  (1/4 - a/2) ]^T and 'a' is centerWeight.
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:centerWeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_centerWeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            center_weight: c_float,
        ) -> Retained<Self>;

        /// Initialize a downwards n-tap pyramid with a custom filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelHeight`: The height of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelWeights`: A pointer to an array of kernelWidth * kernelHeight values to be
        /// used as the kernel.
        /// These are in row major order. See
        /// MPSImageConvolution.
        ///
        /// Returns: A valid object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `kernel_weights` must be a valid pointer.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:weights:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_weights(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            kernel_weights: NonNull<c_float>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageGaussianPyramid {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageGaussianPyramid {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Laplacian pyramid levels are constructed as difference between the current source level and 2x interpolated version of the
    /// half-resolution source level immediately above it.
    ///
    /// LaplacianMipLevel[l] := GaussianMipLevel[l] – Interpolate(GaussianMipLevel[l + 1])
    ///
    /// The Interpolate function is the classical 2x signal interpolation procedure applied
    /// to all color channels of the source mip-level in both dimensions.
    /// It is logically equivalent to the following two-step process :
    /// 1) Zero-stuffing (sometimes called "upsampling").
    /// It is the process of interleaving source pixel values with zero values:
    /// dst.at(x, y) := src.at(x, y) if even(x) and even(y) else 0
    /// 2) Filtering (sometimes called "interpolation").
    /// It is the same procedure as implemented by the MPSImageConvolution class,
    /// using filter weights provided by the initializer methods inherited from MPSImagePyramid.
    ///
    /// The source for Laplacian pyramid construction is typically produced
    /// by the Gaussian pyramid algorithm -- a closely related image processing technique,
    /// but the Laplacian pyramid construction itself makes no assumptions neither about
    /// the data stored in the source texture nor about the interpolation filter weights,
    /// so Gaussian pyramid is just a conventional name for the source texture.
    ///
    /// Please refer to the classical "The Laplacian Pyramid as a Compact Image Code" whitepaper
    /// by Burt
    /// &
    /// Anderson, originally published in 532 IEEE TRANSACTIONS ON COMMUNICATIONS, VOL. COM-3l, NO. 4, APRIL 1983
    /// for more detailed discussion.
    ///
    /// Since the subtraction operation extends the value range of LaplacianMipLevelRaw
    /// relative to the value range of GaussianMipLevel (even for the case of
    /// normalized interpolation filter), in order to avoid unwanted range clamping
    /// when working with normalized texture types, laplacianBias and laplacianScale class properties
    /// specify point-wise linear mapping of the LaplacianMipLevelRaw result data
    /// into the value range of the destination texture :
    /// LaplacianRangeScale(pixel, laplacianBias, laplacianScale) := laplacianBias + pixel * laplacianScale,
    /// LaplacianMipLevelStored[j]                                := LaplacianRangeScale(LaplacianMipLevel[j], laplacianBias, laplacianScale),
    /// with the default values being laplacianBias = 0.0, laplacianScale = 1.0
    ///
    /// Limitations of the current software revision :
    /// 1) In-place operation is not supported, e.g. source and destination textures need
    /// to have separate storage and can't be aliased.
    /// 2) The number of channels, bit depth and resolution of the source and destination textures need to match.
    /// 3) Values of the offset and clipRect properties are fixed to the defaults provided by MPSUnaryImageKernel
    /// (from which they are inherited), corresponding to no offset applied to the source and unbounded region of interest
    /// in every destination mip-level; all updates to these properties are ignored.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagelaplacianpyramid?language=objc)
    #[unsafe(super(MPSImagePyramid, MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageLaplacianPyramid;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageLaplacianPyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageLaplacianPyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageLaplacianPyramid {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageLaplacianPyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageLaplacianPyramid {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramid {
    extern_methods!(
        #[unsafe(method(getLaplacianBias))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLaplacianBias(&self) -> c_float;

        /// Setter for [`getLaplacianBias`][Self::getLaplacianBias].
        #[unsafe(method(setLaplacianBias:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLaplacianBias(&self, laplacian_bias: c_float);

        #[unsafe(method(getLaplacianScale))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLaplacianScale(&self) -> c_float;

        /// Setter for [`getLaplacianScale`][Self::getLaplacianScale].
        #[unsafe(method(setLaplacianScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLaplacianScale(&self, laplacian_scale: c_float);
    );
}

/// Methods declared on superclass `MPSImagePyramid`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramid {
    extern_methods!(
        /// Initialize a downwards 5-tap image pyramid with the default filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        ///
        /// The filter kernel is the outer product of w = [ 1/16,  1/4,  3/8,  1/4,  1/16 ]^T, with itself
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a downwards 5-tap image pyramid with a central weight parameter and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `centerWeight`: Defines form of the filter-kernel  through the outer product ww^T, where
        /// w = [ (1/4 - a/2),  1/4,  a,  1/4,  (1/4 - a/2) ]^T and 'a' is centerWeight.
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:centerWeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_centerWeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            center_weight: c_float,
        ) -> Retained<Self>;

        /// Initialize a downwards n-tap pyramid with a custom filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelHeight`: The height of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelWeights`: A pointer to an array of kernelWidth * kernelHeight values to be
        /// used as the kernel.
        /// These are in row major order. See
        /// MPSImageConvolution.
        ///
        /// Returns: A valid object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `kernel_weights` must be a valid pointer.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:weights:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_weights(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            kernel_weights: NonNull<c_float>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramid {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramid {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagelaplacianpyramidsubtract?language=objc)
    #[unsafe(super(
        MPSImageLaplacianPyramid,
        MPSImagePyramid,
        MPSUnaryImageKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageLaplacianPyramidSubtract;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageLaplacianPyramidSubtract {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageLaplacianPyramidSubtract {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageLaplacianPyramidSubtract {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageLaplacianPyramidSubtract {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageLaplacianPyramidSubtract {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramidSubtract {
    extern_methods!();
}

/// Methods declared on superclass `MPSImagePyramid`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramidSubtract {
    extern_methods!(
        /// Initialize a downwards 5-tap image pyramid with the default filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        ///
        /// The filter kernel is the outer product of w = [ 1/16,  1/4,  3/8,  1/4,  1/16 ]^T, with itself
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a downwards 5-tap image pyramid with a central weight parameter and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `centerWeight`: Defines form of the filter-kernel  through the outer product ww^T, where
        /// w = [ (1/4 - a/2),  1/4,  a,  1/4,  (1/4 - a/2) ]^T and 'a' is centerWeight.
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:centerWeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_centerWeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            center_weight: c_float,
        ) -> Retained<Self>;

        /// Initialize a downwards n-tap pyramid with a custom filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelHeight`: The height of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelWeights`: A pointer to an array of kernelWidth * kernelHeight values to be
        /// used as the kernel.
        /// These are in row major order. See
        /// MPSImageConvolution.
        ///
        /// Returns: A valid object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `kernel_weights` must be a valid pointer.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:weights:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_weights(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            kernel_weights: NonNull<c_float>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramidSubtract {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramidSubtract {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagelaplacianpyramidadd?language=objc)
    #[unsafe(super(
        MPSImageLaplacianPyramid,
        MPSImagePyramid,
        MPSUnaryImageKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageLaplacianPyramidAdd;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageLaplacianPyramidAdd {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageLaplacianPyramidAdd {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageLaplacianPyramidAdd {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageLaplacianPyramidAdd {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageLaplacianPyramidAdd {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramidAdd {
    extern_methods!();
}

/// Methods declared on superclass `MPSImagePyramid`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramidAdd {
    extern_methods!(
        /// Initialize a downwards 5-tap image pyramid with the default filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        ///
        /// The filter kernel is the outer product of w = [ 1/16,  1/4,  3/8,  1/4,  1/16 ]^T, with itself
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a downwards 5-tap image pyramid with a central weight parameter and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `centerWeight`: Defines form of the filter-kernel  through the outer product ww^T, where
        /// w = [ (1/4 - a/2),  1/4,  a,  1/4,  (1/4 - a/2) ]^T and 'a' is centerWeight.
        ///
        ///
        /// Returns: A valid object or nil, if failure.
        #[unsafe(method(initWithDevice:centerWeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_centerWeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            center_weight: c_float,
        ) -> Retained<Self>;

        /// Initialize a downwards n-tap pyramid with a custom filter kernel and device
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelHeight`: The height of the filtering kernel. See
        /// MPSImageConvolution.
        /// Parameter `kernelWeights`: A pointer to an array of kernelWidth * kernelHeight values to be
        /// used as the kernel.
        /// These are in row major order. See
        /// MPSImageConvolution.
        ///
        /// Returns: A valid object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `kernel_weights` must be a valid pointer.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:weights:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_weights(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            kernel_weights: NonNull<c_float>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramidAdd {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLaplacianPyramidAdd {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
