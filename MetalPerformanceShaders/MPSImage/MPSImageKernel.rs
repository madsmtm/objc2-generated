//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

/// A block to make a copy of a source texture for filters that can only execute out of place.
///
/// ## Discussion
///
/// The block takes the following parameters:
///
/// - `filter`: A valid pointer to the kernel that is calling the copy allocator.
///
/// - `commandBuffer`: A valid command buffer that can be used to obtain the device against which to allocate the new texture. You may also enqueue operations on the command buffer to initialize the texture on an encoder allocated in the block. You may not submit, enqueue, or wait for scheduling/completion of the command buffer.
///
/// - `sourceTexture`: The texture that is providing the source image for the filter. You may wish to use its size and pixel format for the next texture, but you are not required to do so.
///
/// The copy allocator returns a new valid texture to use as the destination for the kernel operation. If the calling function succeeds, its texture parameter will be overwritten with a pointer to this texture. If the calling function fails, then the texture will be released before the calling function returns.
///
/// Allocating a new texture each time is slow (they take up to 1 ms each). You can recycle old textures (or buffers and make texture from them) and reuse the memory inside the copy allocator block.
///
/// If there is any metadata associated with the source texture, such as colorspace information, resource label, CPU cache mode, purgeable state, etc., it may need to be similarly associated with the new texture to avoid losing your metadata.
///
/// If the kernel’s [`clipRect`](https://developer.apple.com/documentation/metalperformanceshaders/mpsunaryimagekernel/cliprect) property doesn’t cover the entire image, you may need to copy pixels from the source texture to the new texture, or regions of the next texture will be uninitialized. You can make a command encoder to encode work on the command buffer here, if necessary. It will be scheduled to run immediately before the kernel work. You may call any of the [`enqueue`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/enqueue()), [`commit`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/commit()), [`waitUntilCompleted`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/waituntilcompleted()), or [`waitUntilScheduled`](https://developer.apple.com/documentation/metal/mtlcommandbuffer/waituntilscheduled()) methods inside the copy allocator block. Make sure to call [`endEncoding`](https://developer.apple.com/documentation/metal/mtlcommandencoder/endencoding()) on the command encoder so that the command buffer has no active encoder before returning.
///
/// <div class="warning">
///
/// ### Note
///  The next command placed on the command buffer after the copy allocator returns is almost assuredly going to be encoded with a compute command encoder. Creating any other type of encoder in the copy allocator will probably cost an additional 0.5 ms of both CPU _and_ GPU time (or more!) due to a double mode switch penalty.
///
///
///
/// </div>
/// The following listing shows a minimal copy allocator implementation.
///
/// Listing 1. Minimal MPSCopyAllocator Implementation
///
/// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let copyAllocator: MPSCopyAllocator =", "{", "    (kernel: MPSKernel, buffer: MTLCommandBuffer, texture: MTLTexture) -> MTLTexture in", "    ", "    let descriptor = MTLTextureDescriptor.texture2DDescriptor(", "        pixelFormat: texture.pixelFormat,", "        width: texture.width,", "        height: texture.height,", "        mipmapped: false)", "    ", "    return buffer.device.makeTexture(descriptor: descriptor)", "}", ""], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["MPSCopyAllocator myAllocator = ^id <MTLTexture>(MPSKernel * __nonnull filter, __nonnull id <MTLCommandBuffer> cmdBuf, __nonnull id <MTLTexture> sourceTexture)", "{", "    MTLPixelFormat format = sourceTexture.pixelFormat;", "    MTLTextureDescriptor *d = [MTLTextureDescriptor texture2DDescriptorWithPixelFormat: format width: sourceTexture.width height: sourceTexture.height mipmapped: NO];", " ", "    id <MTLTexture> result = [cmdBuf.device newTextureWithDescriptor: d];", " ", "    return result;", "    // d is autoreleased.", "};"], metadata: None }] }] })
///
#[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "block2"))]
pub type MPSCopyAllocator = *mut block2::DynBlock<
    dyn Fn(
        NonNull<MPSKernel>,
        NonNull<ProtocolObject<dyn MTLCommandBuffer>>,
        NonNull<ProtocolObject<dyn MTLTexture>>,
    ) -> NonNull<ProtocolObject<dyn MTLTexture>>,
>;

extern_class!(
    /// A kernel that consumes one texture and produces one texture.
    ///
    /// ## Overview
    ///
    /// [`MPSUnaryImageKernel`](https://developer.apple.com/documentation/metalperformanceshaders/mpsunaryimagekernel) defines shared behavior for most image processing kernels (filters) such as edging modes, clipping, and tiling support for image operations that consumes a single source textures. It is not meant to be used directly, but provides API abstraction and in some cases may allow some level of polymorphic manipulation of image kernel objects.
    ///
    ///
    /// Dependencies: This depends on Metal.framework
    ///
    /// A MPSUnaryImageKernel consumes one MTLTexture and produces one MTLTexture.
    #[unsafe(super(MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSUnaryImageKernel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSUnaryImageKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSUnaryImageKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSUnaryImageKernel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSUnaryImageKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSUnaryImageKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSUnaryImageKernel {
    extern_methods!(
        #[cfg(feature = "MPSCoreTypes")]
        /// The position of the destination clip rectangle origin relative to the source buffer.
        ///
        /// The offset is defined to be the position of clipRect.origin in source coordinates.
        /// Default: {0,0,0}, indicating that the top left corners of the clipRect and source image align.
        ///
        /// See Also:
        /// MetalPerformanceShaders.hsubsubsection_mpsoffset
        #[unsafe(method(offset))]
        #[unsafe(method_family = none)]
        pub unsafe fn offset(&self) -> MPSOffset;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`offset`][Self::offset].
        #[unsafe(method(setOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOffset(&self, offset: MPSOffset);

        /// An optional clip rectangle to use when writing data. Only the pixels in the rectangle will be overwritten.
        ///
        /// A MTLRegion that indicates which part of the destination to overwrite. If the clipRect does not lie
        /// completely within the destination image, the intersection between clip rectangle and destination bounds is
        /// used.   Default: MPSRectNoClip (MPSKernel::MPSRectNoClip) indicating the entire image.
        ///
        /// See Also:
        /// MetalPerformanceShaders.hsubsubsection_clipRect
        #[unsafe(method(clipRect))]
        #[unsafe(method_family = none)]
        pub unsafe fn clipRect(&self) -> MTLRegion;

        /// Setter for [`clipRect`][Self::clipRect].
        #[unsafe(method(setClipRect:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setClipRect(&self, clip_rect: MTLRegion);

        #[cfg(feature = "MPSCoreTypes")]
        /// The MPSImageEdgeMode to use when texture reads stray off the edge of an image
        ///
        /// Most MPSKernel objects can read off the edge of the source image. This can happen because of a
        /// negative offset property, because the offset + clipRect.size is larger than the
        /// source image or because the filter looks at neighboring pixels, such as a Convolution
        /// or morphology filter.   Default: usually MPSImageEdgeModeZero. (Some MPSKernel types default
        /// to MPSImageEdgeModeClamp, because MPSImageEdgeModeZero is either not supported or
        /// would produce unexpected results.)
        ///
        /// See Also:
        /// MetalPerformanceShaders.hsubsubsection_edgemode
        #[unsafe(method(edgeMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn edgeMode(&self) -> MPSImageEdgeMode;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`edgeMode`][Self::edgeMode].
        #[unsafe(method(setEdgeMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEdgeMode(&self, edge_mode: MPSImageEdgeMode);

        /// Standard init with default properties per filter type
        ///
        /// Parameter `device`: The device that the filter will be used on. May not be NULL.
        ///
        /// Returns: a pointer to the newly initialized object. This will fail, returning
        /// nil if the device is not supported. Devices must be
        /// MTLFeatureSet_iOS_GPUFamily2_v1 or later.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "block2")]
        /// This method attempts to apply the MPSKernel in place on a texture.
        ///
        /// In-place operation means that the same texture is used both to hold the input
        /// image and the results. Operating in-place can be an excellent way to reduce
        /// resource utilization, and save time and energy. While simple Metal kernels can
        /// not operate in place because textures can not be readable and writable at the
        /// same time, some MPSKernels can operate in place because they use
        /// multi-pass algorithms. Whether a MPSKernel can operate in-place can
        /// depend on current hardware, operating system revision and the parameters
        /// and properties passed to it. You should never assume that a MPSKernel will
        /// continue to work in place, even if you have observed it doing so before.
        ///
        /// If the operation succeeds in-place, YES is returned.  If the in-place operation
        /// fails and no copyAllocator is provided, then NO is returned. Without a fallback
        /// MPSCopyAllocator, in neither case is the pointer held at *texture modified.
        ///
        /// Failure during in-place operation is very common and will occur inconsistently across
        /// different hardware platforms and OS releases. Without a fallback MPSCopyAllocator,
        /// operating in place may require significant error handling code to accompany each
        /// call to -encodeToCommandBuffer:..., complicating your code.
        ///
        /// You may find it simplifies your code to provide a fallback MPSCopyAllocator so
        /// that the operation can proceed reliably even when it can not proceed in-place.
        /// When an in-place filter fails, the MPSCopyAllocator (if any) will be
        /// invoked to create a new texture in which to write the results, allowing the
        /// filter to proceed reliably out-of-place. The original texture will be released,
        /// replaced with a pointer to the new texture and YES will be returned. If the
        /// allocator returns an invalid texture, it is released, *texture remains unmodified
        /// and NO is returned.  Please see the MPSCopyAllocator definition for a sample allocator
        /// implementation.
        ///
        /// Sample usage with a copy allocator:
        ///
        /// ```text
        ///   id <MTLTexture> inPlaceTex = ...;
        ///   MPSImageSobel *sobelFiler = [[MPSImageSobel alloc] initWithDevice: myDevice];
        ///
        ///   // With a fallback MPSCopyAllocator, failure should only occur in exceptional
        ///   // conditions such as MTLTexture allocation failure or programmer error.
        ///   // That is, the operation is roughly as robust as the MPSCopyAllocator.
        ///   // Depending on the quality of that, we might decide we are justified here
        ///   // in not checking the return value.
        ///   [sobelFilter encodeToCommandBuffer: myCommandBuffer
        ///                       inPlaceTexture: &inPlaceTex  // may be replaced!
        ///                fallbackCopyAllocator: myAllocator];
        ///
        ///   // If myAllocator was not called:
        ///   //
        ///   //      inPlaceTex holds the original texture with the result pixels in it
        ///   //
        ///   // else,
        ///   //
        ///   //      1) myAllocator creates a new texture.
        ///   //      2) The new texture pixel data is overwritten by MPSUnaryImageKernel.
        ///   //      3) The old texture passed in *inPlaceTex is released once.
        ///   //      4) *inPlaceTex = the new texture
        ///   //
        ///   // In either case, the caller should now hold one reference to the texture now held in
        ///   // inPlaceTex, whether it was replaced or not. Most of the time that means that nothing
        ///   // further needs to be done here, and you can proceed to the next image encoding operation.
        ///   // However, if other agents held references to the original texture, they still hold them
        ///   // and may need to be alerted that the texture has been replaced so that they can retain
        ///   // the new texture and release the old one.
        ///
        ///   [sobelFilter release];  // if not ARC, clean up the MPSImageSobel object
        /// ```
        ///
        /// Note: Image filters that look at neighboring pixel values may actually consume more
        /// memory when operating in place than out of place. Many such operations are
        /// tiled internally to save intermediate texture storage, but can not tile when
        /// operating in place. The memory savings for tiling is however very short term,
        /// typically the lifetime of the MTLCommandBuffer.
        ///
        ///
        /// Attempt to apply a MPSKernel to a texture in place.
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded filter
        ///
        /// Parameter `texture`: A pointer to a valid MTLTexture containing source image.
        /// On success, the image contents and possibly texture itself
        /// will be replaced with the result image.
        ///
        /// Parameter `copyAllocator`: An optional block to allocate a new texture to hold the
        /// results, in case in-place operation is not possible. The
        /// allocator may use a different MTLPixelFormat or size than
        /// the original texture. You may enqueue operations on the
        /// provided MTLCommandBuffer using the provided
        /// MTLComputeCommandEncoder to initialize the texture contents.
        ///
        /// Returns: On success, YES is returned. The texture may have been replaced with a new
        /// texture if a copyAllocator was provided.  On failure, NO is returned. The
        /// texture is unmodified.
        ///
        /// # Safety
        ///
        /// - `texture` must be a valid pointer.
        /// - `copy_allocator` must be a valid pointer or null.
        #[unsafe(method(encodeToCommandBuffer:inPlaceTexture:fallbackCopyAllocator:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_inPlaceTexture_fallbackCopyAllocator(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            texture: NonNull<NonNull<ProtocolObject<dyn MTLTexture>>>,
            copy_allocator: MPSCopyAllocator,
        ) -> bool;

        /// Encode a MPSKernel into a command Buffer.  The operation shall proceed out-of-place.
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded filter
        ///
        /// Parameter `sourceTexture`: A valid MTLTexture containing the source image.
        ///
        /// Parameter `destinationTexture`: A valid MTLTexture to be overwritten by result image. DestinationTexture may not alias sourceTexture.
        ///
        /// # Safety
        ///
        /// - `source_texture` may need to be synchronized.
        /// - `source_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `destination_texture` may need to be synchronized.
        /// - `destination_texture` may be unretained, you must ensure it is kept alive while in use.
        #[unsafe(method(encodeToCommandBuffer:sourceTexture:destinationTexture:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceTexture_destinationTexture(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_texture: &ProtocolObject<dyn MTLTexture>,
            destination_texture: &ProtocolObject<dyn MTLTexture>,
        );

        /// Encode a MPSKernel into a command Buffer.  The operation shall proceed out-of-place.
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded filter
        ///
        /// Parameter `sourceImage`: A valid MPSImage containing the source image.
        ///
        /// Parameter `destinationImage`: A valid MPSImage to be overwritten by result image. DestinationImage may not alias sourceImage.
        #[unsafe(method(encodeToCommandBuffer:sourceImage:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            destination_image: &MPSImage,
        );

        #[cfg(feature = "MPSCoreTypes")]
        /// sourceRegionForDestinationSize: is used to determine which region of the
        /// sourceTexture will be read by encodeToCommandBuffer:sourceTexture:destinationTexture
        /// (and similar) when the filter runs. This information may be needed if the
        /// source image is broken into multiple textures.  The size of the full
        /// (untiled) destination image is provided. The region of the full (untiled)
        /// source image that will be read is returned. You can then piece together an
        /// appropriate texture containing that information for use in your tiled context.
        ///
        /// The function will consult the MPSUnaryImageKernel offset and clipRect parameters,
        /// to determine the full region read by the function. Other parameters such as
        /// sourceClipRect, kernelHeight and kernelWidth will be consulted as necessary.
        /// All properties should be set to intended values prior to calling
        /// sourceRegionForDestinationSize:.
        ///
        /// Caution: This function operates using global image coordinates, but
        /// -encodeToCommandBuffer:... uses coordinates local to the source and
        /// destination image textures. Consequently, the offset and clipRect
        /// attached to this object will need to be updated using a global to
        /// local coordinate transform before -encodeToCommandBuffer:... is
        /// called.
        ///
        ///
        /// Determine the region of the source texture that will be read for a encode operation
        ///
        /// Parameter `destinationSize`: The size of the full virtual destination image.
        ///
        /// Returns: The area in the virtual source image that will be read.
        #[unsafe(method(sourceRegionForDestinationSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceRegionForDestinationSize(&self, destination_size: MTLSize)
            -> MPSRegion;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSUnaryImageKernel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSUnaryImageKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A kernel that consumes two textures and produces one texture.
    ///
    /// ## Overview
    ///
    /// [`MPSBinaryImageKernel`](https://developer.apple.com/documentation/metalperformanceshaders/mpsbinaryimagekernel) defines shared behavior for most image processing kernels (filters) such as edging modes, clipping, and tiling support for image operations that consume two source textures. It is not meant to be used directly, but provides API abstraction and in some cases may allow some level of polymorphic manipulation of image kernel objects.
    ///
    ///
    /// Dependencies: This depends on Metal.framework
    ///
    /// A MPSBinaryImageKernel consumes two MTLTextures and produces one MTLTexture.
    #[unsafe(super(MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSBinaryImageKernel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSBinaryImageKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSBinaryImageKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSBinaryImageKernel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSBinaryImageKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSBinaryImageKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSBinaryImageKernel {
    extern_methods!(
        #[cfg(feature = "MPSCoreTypes")]
        /// The position of the destination clip rectangle origin relative to the primary source buffer.
        ///
        /// The offset is defined to be the position of clipRect.origin in source coordinates.
        /// Default: {0,0,0}, indicating that the top left corners of the clipRect and primary source image align.
        ///
        /// See Also:
        /// MetalPerformanceShaders.hsubsubsection_mpsoffset
        #[unsafe(method(primaryOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryOffset(&self) -> MPSOffset;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`primaryOffset`][Self::primaryOffset].
        #[unsafe(method(setPrimaryOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrimaryOffset(&self, primary_offset: MPSOffset);

        #[cfg(feature = "MPSCoreTypes")]
        /// The position of the destination clip rectangle origin relative to the secondary source buffer.
        ///
        /// The offset is defined to be the position of clipRect.origin in source coordinates.
        /// Default: {0,0,0}, indicating that the top left corners of the clipRect and secondary source image align.
        ///
        /// See Also:
        /// MetalPerformanceShaders.hsubsubsection_mpsoffset
        #[unsafe(method(secondaryOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryOffset(&self) -> MPSOffset;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`secondaryOffset`][Self::secondaryOffset].
        #[unsafe(method(setSecondaryOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSecondaryOffset(&self, secondary_offset: MPSOffset);

        #[cfg(feature = "MPSCoreTypes")]
        /// The MPSImageEdgeMode to use when texture reads stray off the edge of the primary source image
        ///
        /// Most MPSKernel objects can read off the edge of a source image. This can happen because of a
        /// negative offset property, because the offset + clipRect.size is larger than the
        /// source image or because the filter looks at neighboring pixels, such as a Convolution
        /// or morphology filter.   Default: usually MPSImageEdgeModeZero. (Some MPSKernel types default
        /// to MPSImageEdgeModeClamp, because MPSImageEdgeModeZero is either not supported or
        /// would produce unexpected results.)
        ///
        /// See Also:
        /// MetalPerformanceShaders.hsubsubsection_edgemode
        #[unsafe(method(primaryEdgeMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryEdgeMode(&self) -> MPSImageEdgeMode;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`primaryEdgeMode`][Self::primaryEdgeMode].
        #[unsafe(method(setPrimaryEdgeMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrimaryEdgeMode(&self, primary_edge_mode: MPSImageEdgeMode);

        #[cfg(feature = "MPSCoreTypes")]
        /// The MPSImageEdgeMode to use when texture reads stray off the edge of the secondary source image
        ///
        /// Most MPSKernel objects can read off the edge of a source image. This can happen because of a
        /// negative offset property, because the offset + clipRect.size is larger than the
        /// source image or because the filter looks at neighboring pixels, such as a Convolution
        /// or morphology filter.   Default: usually MPSImageEdgeModeZero. (Some MPSKernel types default
        /// to MPSImageEdgeModeClamp, because MPSImageEdgeModeZero is either not supported or
        /// would produce unexpected results.)
        ///
        /// See Also:
        /// MetalPerformanceShaders.hsubsubsection_edgemode
        #[unsafe(method(secondaryEdgeMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryEdgeMode(&self) -> MPSImageEdgeMode;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`secondaryEdgeMode`][Self::secondaryEdgeMode].
        #[unsafe(method(setSecondaryEdgeMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSecondaryEdgeMode(&self, secondary_edge_mode: MPSImageEdgeMode);

        /// An optional clip rectangle to use when writing data. Only the pixels in the rectangle will be overwritten.
        ///
        /// A MTLRegion that indicates which part of the destination to overwrite. If the clipRect does not lie
        /// completely within the destination image, the intersection between clip rectangle and destination bounds is
        /// used.   Default: MPSRectNoClip (MPSKernel::MPSRectNoClip) indicating the entire image.
        ///
        /// See Also:
        /// MetalPerformanceShaders.hsubsubsection_clipRect
        #[unsafe(method(clipRect))]
        #[unsafe(method_family = none)]
        pub unsafe fn clipRect(&self) -> MTLRegion;

        /// Setter for [`clipRect`][Self::clipRect].
        #[unsafe(method(setClipRect:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setClipRect(&self, clip_rect: MTLRegion);

        /// Standard init with default properties per filter type
        ///
        /// Parameter `device`: The device that the filter will be used on. May not be NULL.
        ///
        /// Returns: a pointer to the newly initialized object. This will fail, returning
        /// nil if the device is not supported. Devices must be
        /// MTLFeatureSet_iOS_GPUFamily2_v1 or later.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "block2")]
        /// This method attempts to apply the MPSKernel in place on a texture.
        ///
        /// In-place operation means that the same texture is used both to hold the input
        /// image and the results. Operating in-place can be an excellent way to reduce
        /// resource utilization, and save time and energy. While simple Metal kernels can
        /// not operate in place because textures can not be readable and writable at the
        /// same time, some MPSKernels can operate in place because they use
        /// multi-pass algorithms. Whether a MPSKernel can operate in-place can
        /// depend on current hardware, operating system revision and the parameters
        /// and properties passed to it. You should never assume that a MPSKernel will
        /// continue to work in place, even if you have observed it doing so before.
        ///
        /// If the operation succeeds in-place, YES is returned.  If the in-place operation
        /// fails and no copyAllocator is provided, then NO is returned. In neither
        /// case is the pointer held at *texture modified.
        ///
        /// Failure during in-place operation is common. You may find it simplifies your
        /// code to provide a copyAllocator. When an in-place filter fails, your
        /// copyAllocator will be invoked to create a new texture in which to write
        /// the results, allowing the filter to proceed reliably out-of-place. The
        /// original texture will be released, replaced with a pointer to the new texture
        /// and YES will be returned. If the allocator returns an invalid texture, it is
        /// released, *texture remains unmodified and NO is returned.  Please see the
        /// MPSCopyAllocator definition for a sample allocator implementation.
        ///
        /// Note: Image filters that look at neighboring pixel values may actually consume more
        /// memory when operating in place than out of place. Many such operations are
        /// tiled internally to save intermediate texture storage, but can not tile when
        /// operating in place. The memory savings for tiling is however very short term,
        /// typically the lifetime of the MTLCommandBuffer.
        ///
        ///
        /// Attempt to apply a MPSKernel to a texture in place.
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded filter
        ///
        /// Parameter `primaryTexture`: A pointer to a valid MTLTexture containing the
        /// primary source image. It will not be overwritten.
        ///
        /// Parameter `inPlaceSecondaryTexture`: A pointer to a valid MTLTexture containing secondary image.
        /// On success, the image contents and possibly texture itself
        /// will be replaced with the result image.
        ///
        /// Parameter `copyAllocator`: An optional block to allocate a new texture to hold the
        /// results, in case in-place operation is not possible. The
        /// allocator may use a different MTLPixelFormat or size than
        /// the original texture. You may enqueue operations on the
        /// provided MTLCommandBuffer using the provided
        /// MTLComputeCommandEncoder to initialize the texture contents.
        ///
        /// Returns: On success, YES is returned. The texture may have been replaced with a new
        /// texture if a copyAllocator was provided.  On failure, NO is returned. The
        /// texture is unmodified.
        ///
        /// # Safety
        ///
        /// - `primary_texture` may need to be synchronized.
        /// - `primary_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `in_place_secondary_texture` must be a valid pointer.
        /// - `copy_allocator` must be a valid pointer or null.
        #[unsafe(method(encodeToCommandBuffer:primaryTexture:inPlaceSecondaryTexture:fallbackCopyAllocator:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primaryTexture_inPlaceSecondaryTexture_fallbackCopyAllocator(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_texture: &ProtocolObject<dyn MTLTexture>,
            in_place_secondary_texture: NonNull<NonNull<ProtocolObject<dyn MTLTexture>>>,
            copy_allocator: MPSCopyAllocator,
        ) -> bool;

        #[cfg(feature = "block2")]
        /// Attempt to apply a MPSKernel to a texture in place.
        ///
        /// This method attempts to apply the MPSKernel in place on a texture.
        ///
        /// ```text
        ///           In-place operation means that the same texture is used both to hold the input
        ///           image and the results. Operating in-place can be an excellent way to reduce
        ///           resource utilization, and save time and energy. While simple Metal kernels can
        ///           not operate in place because textures can not be readable and writable at the
        ///           same time, some MPSKernels can operate in place because they use
        ///           multi-pass algorithms. Whether a MPSKernel can operate in-place can
        ///           depend on current hardware, operating system revision and the parameters
        ///           and properties passed to it. You should never assume that a MPSKernel will
        ///           continue to work in place, even if you have observed it doing so before.
        /// ```
        ///
        /// If the operation succeeds in-place, YES is returned.  If the in-place operation
        /// fails and no copyAllocator is provided, then NO is returned. In neither
        /// case is the pointer held at *texture modified.
        ///
        /// Failure during in-place operation is common. You may find it simplifies your
        /// code to provide a copyAllocator. When an in-place filter fails, your
        /// copyAllocator will be invoked to create a new texture in which to write
        /// the results, allowing the filter to proceed reliably out-of-place. The
        /// original texture will be released, replaced with a pointer to the new texture
        /// and YES will be returned. If the allocator returns an invalid texture, it is
        /// released, *texture remains unmodified and NO is returned.  Please see the
        /// MPSCopyAllocator definition for a sample allocator implementation.
        ///
        /// Note: Image filters that look at neighboring pixel values may actually consume more
        /// memory when operating in place than out of place. Many such operations are
        /// tiled internally to save intermediate texture storage, but can not tile when
        /// operating in place. The memory savings for tiling is however very short term,
        /// typically the lifetime of the MTLCommandBuffer.
        ///
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded filter
        ///
        /// Parameter `inPlacePrimaryTexture`: A pointer to a valid MTLTexture containing secondary image.
        /// On success, the image contents and possibly texture itself
        /// will be replaced with the result image.
        ///
        /// Parameter `secondaryTexture`: A pointer to a valid MTLTexture containing the
        /// primary source image. It will not be overwritten.
        ///
        /// Parameter `copyAllocator`: An optional block to allocate a new texture to hold the
        /// results, in case in-place operation is not possible. The
        /// allocator may use a different MTLPixelFormat or size than
        /// the original texture. You may enqueue operations on the
        /// provided MTLCommandBuffer using the provided
        /// MTLComputeCommandEncoder to initialize the texture contents.
        ///
        /// Returns: On success, YES is returned. The texture may have been replaced with a new
        /// texture if a copyAllocator was provided.  On failure, NO is returned. The
        /// texture is unmodified.
        ///
        /// # Safety
        ///
        /// - `in_place_primary_texture` must be a valid pointer.
        /// - `secondary_texture` may need to be synchronized.
        /// - `secondary_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `copy_allocator` must be a valid pointer or null.
        #[unsafe(method(encodeToCommandBuffer:inPlacePrimaryTexture:secondaryTexture:fallbackCopyAllocator:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_inPlacePrimaryTexture_secondaryTexture_fallbackCopyAllocator(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            in_place_primary_texture: NonNull<NonNull<ProtocolObject<dyn MTLTexture>>>,
            secondary_texture: &ProtocolObject<dyn MTLTexture>,
            copy_allocator: MPSCopyAllocator,
        ) -> bool;

        /// Encode a MPSKernel into a command Buffer.  The operation shall proceed out-of-place.
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded filter
        ///
        /// Parameter `primaryTexture`: A valid MTLTexture containing the primary source image.
        ///
        /// Parameter `secondaryTexture`: A valid MTLTexture containing the secondary source image.
        ///
        /// Parameter `destinationTexture`: A valid MTLTexture to be overwritten by result image. destinationTexture may not alias the source textures.
        ///
        /// # Safety
        ///
        /// - `primary_texture` may need to be synchronized.
        /// - `primary_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `secondary_texture` may need to be synchronized.
        /// - `secondary_texture` may be unretained, you must ensure it is kept alive while in use.
        /// - `destination_texture` may need to be synchronized.
        /// - `destination_texture` may be unretained, you must ensure it is kept alive while in use.
        #[unsafe(method(encodeToCommandBuffer:primaryTexture:secondaryTexture:destinationTexture:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primaryTexture_secondaryTexture_destinationTexture(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_texture: &ProtocolObject<dyn MTLTexture>,
            secondary_texture: &ProtocolObject<dyn MTLTexture>,
            destination_texture: &ProtocolObject<dyn MTLTexture>,
        );

        /// Encode a MPSKernel into a command Buffer.  The operation shall proceed out-of-place.
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded filter
        ///
        /// Parameter `primaryImage`: A valid MPSImage containing the primary source image.
        ///
        /// Parameter `secondaryImage`: A valid MPSImage containing the secondary source image.
        ///
        /// Parameter `destinationImage`: A valid MPSImage to be overwritten by result image. destinationImage may not alias the source images.
        #[unsafe(method(encodeToCommandBuffer:primaryImage:secondaryImage:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primaryImage_secondaryImage_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_image: &MPSImage,
            secondary_image: &MPSImage,
            destination_image: &MPSImage,
        );

        #[cfg(feature = "MPSCoreTypes")]
        /// primarySourceRegionForDestinationSize: is used to determine which region of the
        /// primaryTexture will be read by encodeToCommandBuffer:primaryTexture:secondaryTexture:destinationTexture
        /// (and in-place variants) when the filter runs. This information may be needed if the
        /// primary source image is broken into multiple textures.  The size of the full
        /// (untiled) destination image is provided. The region of the full (untiled)
        /// source image that will be read is returned. You can then piece together an
        /// appropriate texture containing that information for use in your tiled context.
        ///
        /// The function will consult the MPSBinaryImageKernel primaryOffset and clipRect parameters,
        /// to determine the full region read by the function. Other parameters such as
        /// kernelHeight and kernelWidth will be consulted as necessary. All properties
        /// should be set to intended values prior to calling primarySourceRegionForDestinationSize:.
        ///
        /// Caution: This function operates using global image coordinates, but
        /// -encodeToCommandBuffer:... uses coordinates local to the source and
        /// destination image textures. Consequently, the primaryOffset and clipRect
        /// attached to this object will need to be updated using a global to
        /// local coordinate transform before -encodeToCommandBuffer:... is
        /// called.
        ///
        ///
        /// Determine the region of the source texture that will be read for a encode operation
        ///
        /// Parameter `destinationSize`: The size of the full virtual destination image.
        ///
        /// Returns: The area in the virtual source image that will be read.
        #[unsafe(method(primarySourceRegionForDestinationSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn primarySourceRegionForDestinationSize(
            &self,
            destination_size: MTLSize,
        ) -> MPSRegion;

        #[cfg(feature = "MPSCoreTypes")]
        /// secondarySourceRegionForDestinationSize: is used to determine which region of the
        /// sourceTexture will be read by encodeToCommandBuffer:primaryTexture:secondaryTexture:destinationTexture
        /// (and in-place variants) when the filter runs. This information may be needed if the
        /// secondary source image is broken into multiple textures.  The size of the full
        /// (untiled) destination image is provided. The region of the full (untiled)
        /// secondary source image that will be read is returned. You can then piece together an
        /// appropriate texture containing that information for use in your tiled context.
        ///
        /// The function will consult the MPSBinaryImageKernel secondaryOffset and clipRect
        /// parameters, to determine the full region read by the function. Other parameters
        /// such as kernelHeight and kernelWidth will be consulted as necessary.  All properties
        /// should be set to intended values prior to calling secondarySourceRegionForDestinationSize:.
        ///
        /// Caution: This function operates using global image coordinates, but
        /// -encodeToCommandBuffer:... uses coordinates local to the source and
        /// destination image textures. Consequently, the secondaryOffset and clipRect
        /// attached to this object will need to be updated using a global to
        /// local coordinate transform before -encodeToCommandBuffer:... is
        /// called.
        ///
        ///
        /// Determine the region of the source texture that will be read for a encode operation
        ///
        /// Parameter `destinationSize`: The size of the full virtual destination image.
        ///
        /// Returns: The area in the virtual source image that will be read.
        #[unsafe(method(secondarySourceRegionForDestinationSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondarySourceRegionForDestinationSize(
            &self,
            destination_size: MTLSize,
        ) -> MPSRegion;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSBinaryImageKernel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSBinaryImageKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
