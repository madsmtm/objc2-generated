//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Resize an image and / or change its aspect ratio
    ///
    /// The MPSImageScale filter can be used to resample an existing image
    /// using a different sampling frequency in each dimension. This can be
    /// used to enlarge or reduce the size of an image, or change the aspect
    /// ratio of an image.
    ///
    /// The resample methods supported are:
    /// Bilinear
    /// Bicubcic
    /// Lanczos
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagescale?language=objc)
    #[unsafe(super(MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageScale;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageScale {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageScale {
    extern_methods!(
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSCoreTypes")]
        /// An optional transform that describes how to scale and translate the source image
        ///
        /// If the scaleTransform is NULL, then any image scaling factor such as MPSImageLanczosScale
        /// will rescale the image so that the source image fits exactly into the destination
        /// texture.  If the transform is not NULL, then the transform is used for determining
        /// how to map the source image to the destination. Default: NULL
        ///
        /// When the scaleTransform is set to non-NULL, the values pointed to by the new
        /// scaleTransform are copied to object storage, and the pointer is updated to point
        /// to internal storage. Do not attempt to free it.  You may free your copy of
        /// the MPSScaleTransform as soon as the property set operation is complete.
        ///
        /// When calculating a scaleTransform, use the limits of the bounding box for the intended
        /// source region of interest and the destination clipRect. Adjustments for pixel center
        /// coordinates are handled internally to the function.  For example,
        /// the scale transform to convert the entire source image to the entire destination image
        /// size (clipRect = MPSRectNoClip) would be:
        ///
        ///
        /// ```text
        ///                   scaleTransform.scaleX = (double) dest.width / source.width;
        ///                   scaleTransform.scaleY = (double) dest.height / source.height;
        ///                   scaleTransform.translateX = scaleTransform.translateY = 0.0;
        /// ```
        ///
        /// The translation parameters allow you to adjust the region of the source image used
        /// to create the destination image. They are in destination coordinates. To place the
        /// top left corner of the destination clipRect to represent the position {x,y} in source
        /// coordinates, we solve for the translation based on the standard scale matrix operation
        /// for each axis:
        ///
        ///
        /// ```text
        ///                   dest_position = source_position * scale + translation;
        ///                   translation = dest_position - source_position * scale;
        /// ```
        ///
        /// For the top left corner of the clipRect, the dest_position is considered to be {0,0}.
        /// This gives us a translation of:
        ///
        ///
        /// ```text
        ///                   scaleTransform.translateX = -source_origin.x * scaleTransform.scaleX;
        ///                   scaleTransform.translateY = -source_origin.y * scaleTransform.scaleY;
        /// ```
        ///
        /// One would typically use non-zero translations to do tiling, or provide a resized
        /// view into a internal segment of an image.
        ///
        /// NOTE:  Changing the Lanczos scale factor may trigger recalculation of signficant state internal
        /// to the object when the filter is encoded to the command buffer. The scale factor is
        /// scaleTransform->scaleX,Y, or the ratio of source and destination image sizes if
        /// scaleTransform is NULL. Reuse a MPSImageLanczosScale object for frequently used scalings
        /// to avoid redundantly recreating expensive resampling state.
        #[unsafe(method(scaleTransform))]
        #[unsafe(method_family = none)]
        pub unsafe fn scaleTransform(&self) -> *const MPSScaleTransform;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`scaleTransform`][Self::scaleTransform].
        ///
        /// # Safety
        ///
        /// `scale_transform` must be a valid pointer or null.
        #[unsafe(method(setScaleTransform:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setScaleTransform(&self, scale_transform: *const MPSScaleTransform);

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageScale {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageScale {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Resize an image and / or change its aspect ratio
    ///
    /// The MPSImageLanczosScale filter can be used to resample an existing image
    /// using a different sampling frequency in each dimension. This can be
    /// used to enlarge or reduce the size of an image, or change the aspect
    /// ratio of an image.  The filter uses a Lanczos resampling algorithm
    /// which typically produces better quality for photographs, but is slower
    /// than linear sampling using the GPU texture units. Lanczos downsampling
    /// does not require a low pass filter to be applied before it is used.
    /// Because the resampling function has negative lobes, Lanczos can result
    /// in ringing near sharp edges, making it less suitable for vector art.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagelanczosscale?language=objc)
    #[unsafe(super(MPSImageScale, MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageLanczosScale;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageLanczosScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageLanczosScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageLanczosScale {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageLanczosScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageLanczosScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLanczosScale {
    extern_methods!(
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLanczosScale {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageLanczosScale {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Resize an image and / or change its aspect ratio
    ///
    /// The MPSImageBilinearScale filter can be used to resample an existing image
    /// using a bilinear filter. This is typically used to reduce the size of an image.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagebilinearscale?language=objc)
    #[unsafe(super(MPSImageScale, MPSUnaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageBilinearScale;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageBilinearScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageBilinearScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageBilinearScale {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageBilinearScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageBilinearScale {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageBilinearScale {
    extern_methods!(
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageBilinearScale {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageBilinearScale {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
