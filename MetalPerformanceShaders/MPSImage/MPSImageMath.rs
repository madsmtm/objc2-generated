//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Base class for basic arithmetic nodes
    /// Dependencies: This depends on Metal.framework.
    ///
    /// This filter takes two source images, a primary source image and a secondary source image,
    /// and outputs a single destination image. It applies an element-wise arithmetic operator to
    /// each pixel in a primary source image and a corresponding pixel in a secondary source image
    /// over a specified region.
    ///
    /// The supported arithmetic operators are the following:
    /// - Addition
    /// - Subtraction
    /// - Multiplication
    /// - Division
    ///
    /// This filter takes additional parameters: primaryScale, secondaryScale, and bias. The default
    /// value for primaryScale and secondaryScale is 1.0f. The default value for bias is 0.0f. This
    /// filter applies primaryScale, secondaryScale, and bias to the primary source pixel (x) and
    /// secondary source pixel (y) in the following way:
    /// - Addition:         result = ((primaryScale * x) + (secondaryScale * y)) + bias
    /// - Subtraction:      result = ((primaryScale * x) - (secondaryScale * y)) + bias
    /// - Multiplicaton:    result = ((primaryScale * x) * (secondaryScale * y)) + bias
    /// - Division:         result = ((primaryScale * x) / (secondaryScale * y)) + bias
    ///
    /// To clamp the result of an arithmetic operation, where
    /// result = clamp(result, minimumValue, maximumValue),
    /// set the minimumValue and maximumValue appropriately. The default value of minimumValue
    /// is -FLT_MAX. The default value of maximumValue is FLT_MAX.
    ///
    /// This filter also takes the following additional parameters:
    /// - primaryStrideInPixels
    /// - secondaryStrideInPixels
    /// These parameters can be used to control broadcasting for the data stored in the primary and
    /// secondary source images. For example, setting all strides for the primary source image to 0
    /// will result in the primarySource image being treated as a scalar value. The only supported
    /// values are 0 or 1. The default value of these parameters is 1.
    ///
    /// This filter accepts uint and int data in addition to unorm and floating-point data.
    ///
    /// You must use one of the sub-classes of MPSImageArithmetic.
    #[unsafe(super(MPSBinaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageArithmetic;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageArithmetic {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageArithmetic {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageArithmetic {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageArithmetic {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageArithmetic {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageArithmetic {
    extern_methods!(
        #[unsafe(method(primaryScale))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryScale(&self) -> c_float;

        /// Setter for [`primaryScale`][Self::primaryScale].
        #[unsafe(method(setPrimaryScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrimaryScale(&self, primary_scale: c_float);

        #[unsafe(method(secondaryScale))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryScale(&self) -> c_float;

        /// Setter for [`secondaryScale`][Self::secondaryScale].
        #[unsafe(method(setSecondaryScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSecondaryScale(&self, secondary_scale: c_float);

        #[unsafe(method(bias))]
        #[unsafe(method_family = none)]
        pub unsafe fn bias(&self) -> c_float;

        /// Setter for [`bias`][Self::bias].
        #[unsafe(method(setBias:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBias(&self, bias: c_float);

        /// The secondarySource stride in the x, y, and z dimensions. The only supported values are 0 or 1.
        /// The default value for each dimension is 1.
        #[unsafe(method(primaryStrideInPixels))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryStrideInPixels(&self) -> MTLSize;

        /// Setter for [`primaryStrideInPixels`][Self::primaryStrideInPixels].
        #[unsafe(method(setPrimaryStrideInPixels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrimaryStrideInPixels(&self, primary_stride_in_pixels: MTLSize);

        /// The secondarySource stride in the x, y, and z dimensions. The only supported values are 0 or 1.
        /// The default value for each dimension is 1.
        #[unsafe(method(secondaryStrideInPixels))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryStrideInPixels(&self) -> MTLSize;

        /// Setter for [`secondaryStrideInPixels`][Self::secondaryStrideInPixels].
        #[unsafe(method(setSecondaryStrideInPixels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSecondaryStrideInPixels(&self, secondary_stride_in_pixels: MTLSize);

        /// minimumValue is to clamp the result of an arithmetic operation:
        /// result = clamp(result, minimumValue, maximumValue).
        /// The default value of minimumValue is -FLT_MAX.
        #[unsafe(method(minimumValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumValue(&self) -> c_float;

        /// Setter for [`minimumValue`][Self::minimumValue].
        #[unsafe(method(setMinimumValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinimumValue(&self, minimum_value: c_float);

        /// maximumValue is used to clamp the result of an arithmetic operation:
        /// result = clamp(result, minimumValue, maximumValue).
        /// The default value of maximumValue is FLT_MAX.
        #[unsafe(method(maximumValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumValue(&self) -> c_float;

        /// Setter for [`maximumValue`][Self::maximumValue].
        #[unsafe(method(setMaximumValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumValue(&self, maximum_value: c_float);

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSBinaryImageKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageArithmetic {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageArithmetic {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageArithmetic {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A filter that returns the element-wise sum of its two input images.
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the addition operator.
    /// For each pixel in the primary source image (x) and each pixel in a secondary source image (y),
    /// it applies the following function: result = ((primaryScale * x) + (secondaryScale * y)) + bias.
    #[unsafe(super(MPSImageArithmetic, MPSBinaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageAdd;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageAdd {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageAdd {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageAdd {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageAdd {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageAdd {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAdd {
    extern_methods!(
        /// Initialize the addition operator
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSImageAdd object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSBinaryImageKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAdd {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAdd {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageAdd {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A filter that returns the element-wise difference of its two input images.
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the subtraction operator.
    /// For each pixel in the primary source image (x) and each pixel in a secondary source image (y),
    /// it applies the following function: result = ((primaryScale * x) - (secondaryScale * y)) + bias.
    #[unsafe(super(MPSImageArithmetic, MPSBinaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageSubtract;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageSubtract {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageSubtract {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageSubtract {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageSubtract {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageSubtract {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageSubtract {
    extern_methods!(
        /// Initialize the subtraction operator
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSImageSubtract object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSBinaryImageKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageSubtract {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageSubtract {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageSubtract {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A filter that returns the element-wise product of its two input images.
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the multiplication operator.
    /// For each pixel in the primary source image (x) and each pixel in a secondary source image (y),
    /// it applies the following function: result = ((primaryScale * x) * (secondaryScale * y)) + bias.
    #[unsafe(super(MPSImageArithmetic, MPSBinaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageMultiply;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageMultiply {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageMultiply {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageMultiply {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageMultiply {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageMultiply {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageMultiply {
    extern_methods!(
        /// Initialize the multiplication operator
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSImageMultiply object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSBinaryImageKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageMultiply {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageMultiply {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageMultiply {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A filter that returns the element-wise quotient of its two input images.
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the division operator.
    /// For each pixel in the primary source image (x) and each pixel in a secondary source image (y),
    /// it applies the following function: result = ((primaryScale * x) / (secondaryScale * y)) + bias.
    #[unsafe(super(MPSImageArithmetic, MPSBinaryImageKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
    pub struct MPSImageDivide;
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageDivide {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageDivide {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageDivide {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageDivide {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageDivide {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageDivide {
    extern_methods!(
        /// Initialize the division operator
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSImageDivide object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSBinaryImageKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageDivide {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageDivide {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSImageKernel", feature = "MPSKernel"))]
impl MPSImageDivide {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
