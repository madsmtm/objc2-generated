//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

/// Specifies information to find the keypoints in an image.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagekeypointrangeinfo?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MPSImageKeypointRangeInfo {
    /// maximum number of keypoints
    pub maximumKeypoints: NSUInteger,
    /// minimum threshold value -  value between 0.0 and 1.0f
    pub minimumThresholdValue: c_float,
}

unsafe impl Encode for MPSImageKeypointRangeInfo {
    const ENCODING: Encoding =
        Encoding::Struct("?", &[<NSUInteger>::ENCODING, <c_float>::ENCODING]);
}

unsafe impl RefEncode for MPSImageKeypointRangeInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The MPSImageFindKeypoints kernel is used to find a list of keypoints whose values are >= minimumPixelThresholdValue
    /// in MPSImageKeypointRangeInfo. The keypoints are generated for a specified region in the image.
    /// The pixel format of the source image must be MTLPixelFormatR8Unorm.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsimagefindkeypoints?language=objc)
    #[unsafe(super(MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSImageFindKeypoints;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSImageFindKeypoints {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSImageFindKeypoints {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSImageFindKeypoints {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSImageFindKeypoints {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSImageFindKeypoints {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSImageFindKeypoints {
    extern_methods!(
        /// Return a structure describing the keypoint range info
        ///
        /// Returns a MPSImageKeypointRangeInfo structure
        #[unsafe(method(keypointRangeInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn keypointRangeInfo(&self) -> MPSImageKeypointRangeInfo;

        /// Specifies information to find keypoints in an image.
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `info`: Pointer to the MPSImageKeypointRangeInfo struct
        ///
        /// Returns: A valid MPSImageFindKeypoints object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `info` must be a valid pointer.
        #[unsafe(method(initWithDevice:info:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_info(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            info: NonNull<MPSImageKeypointRangeInfo>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        /// Encode the filter to a command buffer using a MTLComputeCommandEncoder.
        ///
        /// The filter will not begin to execute until after the command
        /// buffer has been enqueued and committed.
        ///
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer.
        ///
        /// Parameter `source`: A valid MTLTexture containing the source image for the filter.
        ///
        /// Parameter `regions`: An array of rectangles that describe regions in the image.
        /// The list of keypoints is generated for each individual rectangle specifed.
        ///
        /// Parameter `keypointCountBuffer`: The list of keypoints for each specified region
        ///
        /// Parameter `keypointCountBufferOffset`: Byte offset into keypointCountBufferOffset buffer at which to write the keypoint results.
        /// Must be a multiple of 32 bytes.
        ///
        /// Parameter `keypointDataBuffer`: A valid MTLBuffer to receive the keypoint data results for each rectangle.
        /// The keypoint data for keypoints in each rectangle are stored consecutively.
        /// The keypoint data for each rectangle starts at the following offset:
        /// MPSImageKeypointRangeInfo.maximumKeyPoints * rectangle index
        ///
        /// Parameter `keypointDataBufferOffset`: Byte offset into keypointData buffer at which to write the keypoint results.
        /// Must be a multiple of 32 bytes.
        ///
        /// # Safety
        ///
        /// `regions` must be a valid pointer.
        #[unsafe(method(encodeToCommandBuffer:sourceTexture:regions:numberOfRegions:keypointCountBuffer:keypointCountBufferOffset:keypointDataBuffer:keypointDataBufferOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceTexture_regions_numberOfRegions_keypointCountBuffer_keypointCountBufferOffset_keypointDataBuffer_keypointDataBufferOffset(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source: &ProtocolObject<dyn MTLTexture>,
            regions: NonNull<MTLRegion>,
            number_of_regions: NSUInteger,
            keypoint_count_buffer: &ProtocolObject<dyn MTLBuffer>,
            keypoint_count_buffer_offset: NSUInteger,
            keypoint_data_buffer: &ProtocolObject<dyn MTLBuffer>,
            keypoint_data_buffer_offset: NSUInteger,
        );
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSImageFindKeypoints {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSImageFindKeypoints {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
