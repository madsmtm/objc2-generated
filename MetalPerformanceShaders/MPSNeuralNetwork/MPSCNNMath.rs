//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// The MPSCNNArithmeticGradientState is used to hold the clamp mask used by both
    /// MPSCNNArithmetic forward filter and MPSCNNArithmeticGradient backward filter.
    /// The MPSCNNArithmetic forward filter populates the MPSCNNArithmeticGradientState
    /// object and the MPSCNNArithmeticGradient backward filter consumes the state
    /// object.
    ///
    /// The clamp mask is stored internally and is not accessible by the user.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnarithmeticgradientstate?language=objc)
    #[unsafe(super(MPSNNBinaryGradientState, MPSState, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(
        feature = "MPSCore",
        feature = "MPSNNGradientState",
        feature = "MPSState"
    ))]
    pub struct MPSCNNArithmeticGradientState;
);

#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
unsafe impl NSObjectProtocol for MPSCNNArithmeticGradientState {}

#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
impl MPSCNNArithmeticGradientState {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSState`.
#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
impl MPSCNNArithmeticGradientState {
    extern_methods!(
        /// Create a MPSState holding a temporary MTLBuffer
        ///
        /// Parameter `cmdBuf`: The command buffer against which the temporary resource is allocated
        ///
        /// Parameter `bufferSize`: The size of the buffer in bytes
        #[unsafe(method(temporaryStateWithCommandBuffer:bufferSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_bufferSize(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            buffer_size: usize,
        ) -> Retained<Self>;

        /// Create a MPSState holding a temporary MTLTexture
        ///
        /// Parameter `cmdBuf`: The command buffer against which the temporary resource is allocated
        ///
        /// Parameter `descriptor`: A descriptor for the new temporary texture
        #[unsafe(method(temporaryStateWithCommandBuffer:textureDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_textureDescriptor(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        /// Create a new autoreleased temporary state object without underlying resource
        ///
        /// Parameter `cmdBuf`: The command buffer with which the temporary resource is associated
        #[unsafe(method(temporaryStateWithCommandBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:bufferSize:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_bufferSize(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            buffer_size: usize,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:textureDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_textureDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        /// Create a MPSState with a non-temporary MTLResource
        ///
        /// Parameter `resource`: A MTLBuffer or MTLTexture. May be nil.
        #[unsafe(method(initWithResource:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithResource(
            this: Allocated<Self>,
            resource: Option<&ProtocolObject<dyn MTLResource>>,
        ) -> Retained<Self>;

        /// Initialize a non-temporary state to hold a number of textures and buffers
        ///
        /// The allocation of each resource will be deferred  until it is needed.
        /// This occurs when -resource or -resourceAtIndex: is called.
        ///
        /// Parameter `resourceList`: The list of resources to create.
        #[unsafe(method(initWithDevice:resourceList:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_resourceList(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Initialize a temporary state to hold a number of textures and buffers
        ///
        /// The textures occur first in sequence
        #[unsafe(method(temporaryStateWithCommandBuffer:resourceList:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_resourceList(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Create a state object with a list of MTLResources
        ///
        /// Because MPS prefers deferred allocation of resources
        /// your application should use -initWithTextures:bufferSizes:bufferCount:
        /// whenever possible. This method is useful for cases when the
        /// MTLResources must be initialized by the CPU.
        #[unsafe(method(initWithResources:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithResources(
            this: Allocated<Self>,
            resources: Option<&NSArray<ProtocolObject<dyn MTLResource>>>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
impl MPSCNNArithmeticGradientState {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnarithmeticgradientstatebatch?language=objc)
#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
pub type MPSCNNArithmeticGradientStateBatch = NSArray<MPSCNNArithmeticGradientState>;

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// The MPSCNNArithmetic filter takes two source images, a primary source image and a
    /// secondary source image, and outputs a single destination image. It applies an
    /// element-wise arithmetic operator to each pixel in a primary source image and a
    /// corresponding pixel in a secondary source image over a specified region.
    ///
    /// The supported arithmetic operators are the following:
    /// - Addition
    /// - Subtraction
    /// - Multiplication
    /// - Division
    /// - Comparison
    ///
    /// This filter takes additional parameters: primaryScale, secondaryScale, and bias. The default
    /// value for primaryScale and secondaryScale is 1.0f. The default value for bias is 0.0f. This
    /// filter applies primaryScale, secondaryScale, and bias to the primary source pixel (x) and
    /// secondary source pixel (y) in the following way:
    /// - Addition:         result = ((primaryScale * x) + (secondaryScale * y)) + bias
    /// - Subtraction:      result = ((primaryScale * x) - (secondaryScale * y)) + bias
    /// - Multiplicaton:    result = ((primaryScale * x) * (secondaryScale * y)) + bias
    /// - Division:         result = ((primaryScale * x) / (secondaryScale * y)) + bias
    /// - Comparison:       Unused.
    ///
    /// To clamp the result of an arithmetic operation, where
    /// result = clamp(result, minimumValue, maximumValue),
    /// set the minimumValue and maximumValue appropriately. The default value of minimumValue
    /// is -FLT_MAX. The default value of maximumValue is FLT_MAX.
    ///
    /// This filter also takes the following additional parameters:
    /// - primaryStrideInPixelsX, primaryStrideInPixelsY, primaryStrideInFeatureChannels
    /// - secondaryStrideInPixelsX, secondaryStrideInPixelsY, secondaryStrideInFeatureChannels
    /// These parameters can be used to control broadcasting for the data stored in the primary and
    /// secondary source images. For example, setting all strides for the primary source image to 0
    /// will result in the primarySource image being treated as a scalar value. The only supported
    /// values are 0 or 1. The default value of these parameters is 1.
    ///
    /// The number of output feature channels remains the same as the number of input feature
    /// channels.
    ///
    /// You must use one of the sub-classes of MPSImageArithmetic.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnarithmetic?language=objc)
    #[unsafe(super(MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNArithmetic;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNArithmetic {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNArithmetic {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNArithmetic {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNArithmetic {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNArithmetic {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNArithmetic {
    extern_methods!(
        #[unsafe(method(primaryScale))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryScale(&self) -> c_float;

        /// Setter for [`primaryScale`][Self::primaryScale].
        #[unsafe(method(setPrimaryScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrimaryScale(&self, primary_scale: c_float);

        #[unsafe(method(secondaryScale))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryScale(&self) -> c_float;

        /// Setter for [`secondaryScale`][Self::secondaryScale].
        #[unsafe(method(setSecondaryScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSecondaryScale(&self, secondary_scale: c_float);

        #[unsafe(method(bias))]
        #[unsafe(method_family = none)]
        pub unsafe fn bias(&self) -> c_float;

        /// Setter for [`bias`][Self::bias].
        #[unsafe(method(setBias:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBias(&self, bias: c_float);

        /// The primarySource stride in the feature channel dimension. The only supported values are 0 or 1.
        /// The default value for each dimension is 1.
        #[unsafe(method(primaryStrideInFeatureChannels))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryStrideInFeatureChannels(&self) -> NSUInteger;

        /// Setter for [`primaryStrideInFeatureChannels`][Self::primaryStrideInFeatureChannels].
        #[unsafe(method(setPrimaryStrideInFeatureChannels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrimaryStrideInFeatureChannels(
            &self,
            primary_stride_in_feature_channels: NSUInteger,
        );

        /// The secondarySource stride in the feature channel dimension. The only supported values are 0 or 1.
        /// The default value for each dimension is 1.
        #[unsafe(method(secondaryStrideInFeatureChannels))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryStrideInFeatureChannels(&self) -> NSUInteger;

        /// Setter for [`secondaryStrideInFeatureChannels`][Self::secondaryStrideInFeatureChannels].
        #[unsafe(method(setSecondaryStrideInFeatureChannels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSecondaryStrideInFeatureChannels(
            &self,
            secondary_stride_in_feature_channels: NSUInteger,
        );

        /// minimumValue is to clamp the result of an arithmetic operation:
        /// result = clamp(result, minimumValue, maximumValue).
        /// The default value of minimumValue is -FLT_MAX.
        #[unsafe(method(minimumValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumValue(&self) -> c_float;

        /// Setter for [`minimumValue`][Self::minimumValue].
        #[unsafe(method(setMinimumValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinimumValue(&self, minimum_value: c_float);

        /// maximumValue is used to clamp the result of an arithmetic operation:
        /// result = clamp(result, minimumValue, maximumValue).
        /// The default value of maximumValue is FLT_MAX.
        #[unsafe(method(maximumValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumValue(&self) -> c_float;

        /// Setter for [`maximumValue`][Self::maximumValue].
        #[unsafe(method(setMaximumValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumValue(&self, maximum_value: c_float);

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode call that operates on a state for later consumption by a gradient kernel in training
        ///
        /// This is the older style of encode which reads the offset, doesn't change it,
        /// and ignores the padding method.
        ///
        /// Parameter `commandBuffer`: The command buffer
        ///
        /// Parameter `primaryImage`: A MPSImage to use as the source images for the filter.
        ///
        /// Parameter `secondaryImage`: A MPSImage to use as the source images for the filter.
        ///
        /// Parameter `destinationState`: MPSCNNArithmeticGradientState to be consumed by the gradient layer
        ///
        /// Parameter `destinationImage`: A valid MPSImage to be overwritten by result image. destinationImage
        /// may not alias primarySourceImage or secondarySourceImage.
        #[unsafe(method(encodeToCommandBuffer:primaryImage:secondaryImage:destinationState:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primaryImage_secondaryImage_destinationState_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_image: &MPSImage,
            secondary_image: &MPSImage,
            destination_state: &MPSCNNArithmeticGradientState,
            destination_image: &MPSImage,
        );

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNDArray",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode call that operates on a state for later consumption by a gradient kernel in training
        ///
        /// This is the older style of encode which reads the offset, doesn't change it,
        /// and ignores the padding method. Multiple images are processed concurrently.
        /// All images must have MPSImage.numberOfImages = 1.
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded filter
        ///
        /// Parameter `primaryImages`: An array of MPSImage objects containing the primary source images.
        ///
        /// Parameter `secondaryImages`: An array MPSImage objects containing the secondary source images.
        ///
        /// Parameter `destinationStates`: An array of MPSCNNArithmeticGradientStateBatch to be consumed by the gradient layer
        ///
        /// Parameter `destinationImages`: An array of MPSImage objects to contain the result images.
        /// destinationImages may not alias primarySourceImages or secondarySourceImages
        /// in any manner.
        #[unsafe(method(encodeBatchToCommandBuffer:primaryImages:secondaryImages:destinationStates:destinationImages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_primaryImages_secondaryImages_destinationStates_destinationImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_images: &MPSImageBatch,
            secondary_images: &MPSImageBatch,
            destination_states: &MPSCNNArithmeticGradientStateBatch,
            destination_images: &MPSImageBatch,
        );
    );
}

/// Methods declared on superclass `MPSCNNBinaryKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNArithmetic {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNArithmetic {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNArithmetic {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the addition operator.
    /// For each pixel in the primary source image (x) and each pixel in a secondary source image (y),
    /// it applies the following function: result = ((primaryScale * x) + (secondaryScale * y)) + bias.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnadd?language=objc)
    #[unsafe(super(MPSCNNArithmetic, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNAdd;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNAdd {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNAdd {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNAdd {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNAdd {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNAdd {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNAdd {
    extern_methods!(
        /// Initialize the addition operator.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSCNNAdd object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNBinaryKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNAdd {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNAdd {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNAdd {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the subtraction operator.
    /// For each pixel in the primary source image (x) and each pixel in a secondary source image (y),
    /// it applies the following function: result = ((primaryScale * x) - (secondaryScale * y)) + bias.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnsubtract?language=objc)
    #[unsafe(super(MPSCNNArithmetic, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNSubtract;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNSubtract {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNSubtract {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNSubtract {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNSubtract {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNSubtract {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNSubtract {
    extern_methods!(
        /// Initialize the subtraction operator
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSCNNSubtract object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNBinaryKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNSubtract {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNSubtract {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNSubtract {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the multiplication operator.
    /// For each pixel in the primary source image (x) and each pixel in a secondary source image (y),
    /// it applies the following function: result = ((primaryScale * x) * (secondaryScale * y)) + bias.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnmultiply?language=objc)
    #[unsafe(super(MPSCNNArithmetic, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNMultiply;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNMultiply {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNMultiply {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNMultiply {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNMultiply {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNMultiply {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNMultiply {
    extern_methods!(
        /// Initialize the multiplication operator
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSCNNMultiply object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNBinaryKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNMultiply {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNMultiply {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNMultiply {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the division operator.
    /// For each pixel in the primary source image (x) and each pixel in a secondary source image (y),
    /// it applies the following function: result = ((primaryScale * x) / (secondaryScale * y)) + bias.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnndivide?language=objc)
    #[unsafe(super(MPSCNNArithmetic, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNDivide;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNDivide {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNDivide {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNDivide {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNDivide {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNDivide {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDivide {
    extern_methods!(
        /// Initialize the division operator
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSCNNDivide object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNBinaryKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDivide {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDivide {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDivide {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnncomparisontype?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MPSNNComparisonType(pub NSUInteger);
bitflags::bitflags! {
    impl MPSNNComparisonType: NSUInteger {
        #[doc(alias = "MPSNNComparisonTypeEqual")]
        const Equal = 0;
        #[doc(alias = "MPSNNComparisonTypeNotEqual")]
        const NotEqual = 1;
        #[doc(alias = "MPSNNComparisonTypeLess")]
        const Less = 2;
        #[doc(alias = "MPSNNComparisonTypeLessOrEqual")]
        const LessOrEqual = 3;
        #[doc(alias = "MPSNNComparisonTypeGreater")]
        const Greater = 4;
        #[doc(alias = "MPSNNComparisonTypeGreaterOrEqual")]
        const GreaterOrEqual = 5;
    }
}

unsafe impl Encode for MPSNNComparisonType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MPSNNComparisonType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the elementwise comparison operator.
    /// For each pixel in the primary source image (x) and each pixel in a secondary source image (y),
    /// it applies the following function: result = (abs(x-y))
    /// <
    /// = threshold
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnncompare?language=objc)
    #[unsafe(super(MPSCNNArithmetic, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNNCompare;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSNNCompare {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSNNCompare {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNNCompare {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSNNCompare {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSNNCompare {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNCompare {
    extern_methods!(
        /// The comparison type to use
        #[unsafe(method(comparisonType))]
        #[unsafe(method_family = none)]
        pub unsafe fn comparisonType(&self) -> MPSNNComparisonType;

        /// Setter for [`comparisonType`][Self::comparisonType].
        #[unsafe(method(setComparisonType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setComparisonType(&self, comparison_type: MPSNNComparisonType);

        /// The threshold to use when comparing for equality.  Two values will
        /// be considered to be equal if the absolute value of their difference
        /// is less than, or equal, to the specified threshold:
        /// result = |b - a|
        /// <
        /// = threshold
        #[unsafe(method(threshold))]
        #[unsafe(method_family = none)]
        pub unsafe fn threshold(&self) -> c_float;

        /// Setter for [`threshold`][Self::threshold].
        #[unsafe(method(setThreshold:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setThreshold(&self, threshold: c_float);

        /// Initialize the comparison operator
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSNNCompare object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNBinaryKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNCompare {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNCompare {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNCompare {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// The MPSCNNArithmeticGradient filter is the backward filter for the MPSCNNArithmetic
    /// forward filter.
    ///
    /// The forward filter takes two inputs, primary and secondary source images, and produces
    /// a single output image. Thus, going backwards requires two separate filters (one for
    /// the primary source image and one for the secondary source image) that take multiple
    /// inputs and produce a single output. The secondarySourceFilter property is used to
    /// indicate whether the filter is operating on the primary or secondary source image from
    /// the forward pass.
    ///
    /// All the arithmetic gradient filters require the following inputs: gradient image from
    /// the previous layer (going backwards) and all the applicable input source images from
    /// the forward pass.
    ///
    /// The forward filter takes the following additional parameters:
    /// - primaryStrideInPixelsX, primaryStrideInPixelsY, primaryStrideInFeatureChannels
    /// - secondaryStrideInPixelsX, secondaryStrideInPixelsY, secondaryStrideInFeatureChannels
    /// These parameters can be used in the forward filter to control broadcasting for the data
    /// stored in the primary and secondary source images. For example, setting all strides for
    /// the primary source image to 0 will result in the primarySource image being treated as a
    /// single pixel. The only supported values are 0 or 1. The default value of these parameters
    /// is 1.
    ///
    /// The first input to the backward filter is the gradient image from the previous layer
    /// (going backwards), so there are no broadcasting parameters for this input. For the
    /// backward filter, the broadcasting parameters for the second input must match the
    /// broadcasting parameters set for the same image in the forward filter.
    ///
    /// In the backward pass, broadcasting results in a reduction operation (sum) across all of the
    /// applicable broadcasting dimensions (rows, columns, feature channels, or any combination
    /// thereof) to produce the destination image of the size that matches the primary/secondary
    /// input images used in the forward pass.
    ///
    /// In the case of no broadcasting, the following arithmetic gradient operations are copy
    /// operations (that can be optimized away by the graph interface):
    /// - Add (primarySource, secondarySource)
    /// - Subtract (primarySource)
    ///
    /// Similarly to the forward filter, this backward filter takes additional parameters:
    /// primaryScale, secondaryScale, and bias. The default value for primaryScale and secondaryScale
    /// is 1.0f. The default value for bias is 0.0f. This filter applies primaryScale to the primary
    /// source image, applies the secondaryScale to the secondary source image, where appropriate,
    /// and applies bias to the result, i.e.:
    /// result = ((primaryScale * x) [insert operation] (secondaryScale * y)) + bias.
    ///
    /// The subtraction gradient filter for the secondary source image requires that the primaryScale
    /// property is set to -1.0f (for x - y, d/dy(x - y) = -1).
    ///
    /// In the forward filter, there is support for clamping the result of the available operations,
    /// where result = clamp(result, minimumValue, maximumValue). The clamp backward operation is
    /// not supported in the arithmetic gradient filters. If you require this functionality, it can
    /// be implemented by performing a clamp backward operation before calling the arithmetic gradient
    /// filters. You would need to apply the following function on the incomping gradient input image:
    /// f(x) = ((minimumValue
    /// <
    /// x)
    /// &
    /// &
    /// (x
    /// <
    /// maximumValue)) ? 1 : 0, where x is the original result
    /// (before clamping) of the forward arithmetic filter.
    ///
    /// The number of output feature channels remains the same as the number of input feature
    /// channels.
    ///
    /// You must use one of the sub-classes of MPSImageArithmeticGradient.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnarithmeticgradient?language=objc)
    #[unsafe(super(MPSCNNGradientKernel, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNArithmeticGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNArithmeticGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNArithmeticGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNArithmeticGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNArithmeticGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNArithmeticGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNArithmeticGradient {
    extern_methods!(
        #[unsafe(method(primaryScale))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryScale(&self) -> c_float;

        /// Setter for [`primaryScale`][Self::primaryScale].
        #[unsafe(method(setPrimaryScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrimaryScale(&self, primary_scale: c_float);

        #[unsafe(method(secondaryScale))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryScale(&self) -> c_float;

        /// Setter for [`secondaryScale`][Self::secondaryScale].
        #[unsafe(method(setSecondaryScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSecondaryScale(&self, secondary_scale: c_float);

        #[unsafe(method(bias))]
        #[unsafe(method_family = none)]
        pub unsafe fn bias(&self) -> c_float;

        /// Setter for [`bias`][Self::bias].
        #[unsafe(method(setBias:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBias(&self, bias: c_float);

        /// The secondarySource stride in the feature channel dimension. The only supported values are 0 or 1.
        /// The default value for each dimension is 1.
        #[unsafe(method(secondaryStrideInFeatureChannels))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryStrideInFeatureChannels(&self) -> NSUInteger;

        /// Setter for [`secondaryStrideInFeatureChannels`][Self::secondaryStrideInFeatureChannels].
        #[unsafe(method(setSecondaryStrideInFeatureChannels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSecondaryStrideInFeatureChannels(
            &self,
            secondary_stride_in_feature_channels: NSUInteger,
        );

        /// minimumValue is to clamp the result of an arithmetic operation:
        /// result = clamp(result, minimumValue, maximumValue).
        /// The default value of minimumValue is -FLT_MAX.
        #[unsafe(method(minimumValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumValue(&self) -> c_float;

        /// Setter for [`minimumValue`][Self::minimumValue].
        #[unsafe(method(setMinimumValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinimumValue(&self, minimum_value: c_float);

        /// maximumValue is used to clamp the result of an arithmetic operation:
        /// result = clamp(result, minimumValue, maximumValue).
        /// The default value of maximumValue is FLT_MAX.
        #[unsafe(method(maximumValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumValue(&self) -> c_float;

        /// Setter for [`maximumValue`][Self::maximumValue].
        #[unsafe(method(setMaximumValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumValue(&self, maximum_value: c_float);

        /// The isSecondarySourceFilter property is used to indicate whether the arithmetic gradient
        /// filter is operating on the primary or secondary source image from the forward pass.
        #[unsafe(method(isSecondarySourceFilter))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSecondarySourceFilter(&self) -> bool;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:isSecondarySourceFilter:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_isSecondarySourceFilter(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            is_secondary_source_filter: bool,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNGradientKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNArithmeticGradient {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNArithmeticGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNArithmeticGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the addition gradient operator.
    /// This arithmetic gradient filter requires the following inputs: gradient image from
    /// the previous layer (going backwards) and either the primary or the secondary source
    /// image from the forward pass. You will need a separate filter for the primary and
    /// secondary source images.
    ///
    /// Without broadcasting, the arithmetic add gradient operation is a copy operation on
    /// the input gradient image. It is the same operation for both the primary and secondary
    /// source images (for x + y, d/dx(x + y) = 1, d/dy(x + y) = 1). This copy operation can
    /// be optimized away by the graph interface.
    ///
    /// Setting the broadcasting parameters results in a reduction operation (sum) across all
    /// of the applicable broadcasting dimensions (rows, columns, feature channels, or any
    /// combination thereof) to produce the destination image of the size that matches the
    /// primary/secondary input images used in the forward pass.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnaddgradient?language=objc)
    #[unsafe(super(
        MPSCNNArithmeticGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNAddGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNAddGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNAddGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNAddGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNAddGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNAddGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNAddGradient {
    extern_methods!(
        /// Initialize the addition gradient operator.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `isSecondarySourceFilter`: A boolean indicating whether the arithmetic gradient
        /// filter is operating on the primary or secondary source image from the forward pass.
        ///
        /// Returns: A valid MPSCNNAddGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:isSecondarySourceFilter:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_isSecondarySourceFilter(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            is_secondary_source_filter: bool,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNArithmeticGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNAddGradient {
    extern_methods!(
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNGradientKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNAddGradient {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNAddGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNAddGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the subtraction gradient operator.
    /// This arithmetic gradient filter requires the following inputs: gradient image from
    /// the previous layer (going backwards) and either the primary or the secondary source
    /// image from the forward pass. You will need a separate filter for the primary and
    /// secondary source images.
    ///
    /// Without broadcasting, the arithmetic subtract gradient operation for the primary
    /// source image is a copy operation on the input gradient image (for x - y, d/dx(x - y) = 1).
    /// This copy operation can be optimized away by the graph interface.
    ///
    /// For the secondary source image, the result is a negation of the gradient image from
    /// the previous layer (for x - y, d/dy(x - y) = -1).
    ///
    /// Setting the broadcasting parameters results in a reduction operation (sum) across all
    /// of the applicable broadcasting dimensions (rows, columns, feature channels, or any
    /// combination thereof) to produce the destination image of the size that matches the
    /// primary/secondary input images used in the forward pass.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnsubtractgradient?language=objc)
    #[unsafe(super(
        MPSCNNArithmeticGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNSubtractGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNSubtractGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNSubtractGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNSubtractGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNSubtractGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNSubtractGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNSubtractGradient {
    extern_methods!(
        /// Initialize the subtraction gradient operator.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `isSecondarySourceFilter`: A boolean indicating whether the arithmetic gradient
        /// filter is operating on the primary or secondary source image from the forward pass.
        ///
        /// Returns: A valid MPSCNNSubtractGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:isSecondarySourceFilter:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_isSecondarySourceFilter(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            is_secondary_source_filter: bool,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNArithmeticGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNSubtractGradient {
    extern_methods!(
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNGradientKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNSubtractGradient {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNSubtractGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNSubtractGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the multiplication gradient operator.
    /// This arithmetic gradient filter requires the following inputs: gradient image from
    /// the previous layer (going backwards) and either the primary or the secondary source
    /// image from the forward pass. You will need a separate filter for the primary and
    /// secondary source images.
    ///
    /// Without broadcasting, the arithmetic multiply gradient operation is an element-wise
    /// multiplication operation between the gradient image from the previous layer (going
    /// backwards) and:
    /// - The secondary source image from the forward pass for the primary source filter
    /// (for x * y, d/dx(x * y) = y).
    /// - The primary source image from the forward pass for the secondary source filter
    /// (for x * y, d/dy(x * y) = x).
    ///
    /// Setting the broadcasting parameters results in a reduction operation (sum) across all
    /// of the applicable broadcasting dimensions (rows, columns, feature channels, or any
    /// combination thereof) to produce the destination image of the size that matches the
    /// primary/secondary input images used in the forward pass.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnmultiplygradient?language=objc)
    #[unsafe(super(
        MPSCNNArithmeticGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNMultiplyGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNMultiplyGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNMultiplyGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNMultiplyGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNMultiplyGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNMultiplyGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNMultiplyGradient {
    extern_methods!(
        /// Initialize the multiplication gradient operator.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `isSecondarySourceFilter`: A boolean indicating whether the arithmetic gradient
        /// filter is operating on the primary or secondary source image from the forward pass.
        ///
        /// Returns: A valid MPSCNNMultiplyGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:isSecondarySourceFilter:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_isSecondarySourceFilter(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            is_secondary_source_filter: bool,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNArithmeticGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNMultiplyGradient {
    extern_methods!(
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNGradientKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNMultiplyGradient {
    extern_methods!(
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNMultiplyGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNMultiplyGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
