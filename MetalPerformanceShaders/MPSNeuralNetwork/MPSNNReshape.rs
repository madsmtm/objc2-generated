//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnnreshape?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNNReshape;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNNReshape {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNNReshape {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNNReshape {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNNReshape {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNNReshape {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNReshape {
    extern_methods!(
        /// Initialize a MPSNNReshape kernel
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Returns: A valid MPSNNReshape object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "MPSImage")]
        /// Encode a reshape to a command buffer for a given shape.
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the reshape operation.
        ///
        /// Parameter `sourceImage`: The input image to be reshaped.
        ///
        /// Parameter `reshapedWidth`: The width of the resulting reshaped image.
        ///
        /// Parameter `reshapedHeight`: The height of the resulting reshaped image.
        ///
        /// Parameter `reshapedFeatureChannels`: The number of feature channels in the resulting reshaped image.
        #[unsafe(method(encodeToCommandBuffer:sourceImage:reshapedWidth:reshapedHeight:reshapedFeatureChannels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_reshapedWidth_reshapedHeight_reshapedFeatureChannels(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            reshaped_width: NSUInteger,
            reshaped_height: NSUInteger,
            reshaped_feature_channels: NSUInteger,
        ) -> Retained<MPSImage>;

        #[cfg(all(feature = "MPSImage", feature = "MPSState"))]
        /// Encode a reshape to a command buffer for a given shape.
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the reshape operation.
        ///
        /// Parameter `outState`: A state to be created and autoreleased which will hold information about this execution
        /// to be provided to a subsequent gradient pass.
        ///
        /// Parameter `isTemporary`: YES if the state is to be created as a temporary state, NO otherwise.
        ///
        /// Parameter `sourceImage`: The input image to be reshaped.
        ///
        /// Parameter `reshapedWidth`: The width of the resulting reshaped image.
        ///
        /// Parameter `reshapedHeight`: The height of the resulting reshaped image.
        ///
        /// Parameter `reshapedFeatureChannels`: The number of feature channels in the resulting reshaped image.
        #[unsafe(method(encodeToCommandBuffer:sourceImage:destinationState:destinationStateIsTemporary:reshapedWidth:reshapedHeight:reshapedFeatureChannels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_destinationState_destinationStateIsTemporary_reshapedWidth_reshapedHeight_reshapedFeatureChannels(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            out_state: &mut Option<Retained<MPSState>>,
            is_temporary: bool,
            reshaped_width: NSUInteger,
            reshaped_height: NSUInteger,
            reshaped_feature_channels: NSUInteger,
        ) -> Retained<MPSImage>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray"))]
        /// Encode a reshape to a command buffer for a given shape.
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the reshape operation.
        ///
        /// Parameter `sourceImages`: The image batch containing images to be reshaped.
        ///
        /// Parameter `reshapedWidth`: The width of the resulting reshaped images.
        ///
        /// Parameter `reshapedHeight`: The height of the resulting reshaped images.
        ///
        /// Parameter `reshapedFeatureChannels`: The number of feature channels in each of the resulting reshaped images.
        #[unsafe(method(encodeBatchToCommandBuffer:sourceImages:reshapedWidth:reshapedHeight:reshapedFeatureChannels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_reshapedWidth_reshapedHeight_reshapedFeatureChannels(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
            reshaped_width: NSUInteger,
            reshaped_height: NSUInteger,
            reshaped_feature_channels: NSUInteger,
        ) -> Retained<MPSImageBatch>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        /// Encode a reshape to a command buffer for a given shape.
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the reshape operation.
        ///
        /// Parameter `outStates`: A batch of states to be created and autoreleased which will hold information about this execution
        /// to be provided to a subsequent gradient pass.
        ///
        /// Parameter `isTemporary`: YES if the states are to be created as temporary states, NO otherwise.
        ///
        /// Parameter `sourceImages`: The batch of input images to be reshaped.
        ///
        /// Parameter `reshapedWidth`: The width of the resulting reshaped images.
        ///
        /// Parameter `reshapedHeight`: The height of the resulting reshaped images.
        ///
        /// Parameter `reshapedFeatureChannels`: The number of feature channels in each of the resulting reshaped images.
        #[unsafe(method(encodeBatchToCommandBuffer:sourceImages:destinationStates:destinationStateIsTemporary:reshapedWidth:reshapedHeight:reshapedFeatureChannels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_destinationStates_destinationStateIsTemporary_reshapedWidth_reshapedHeight_reshapedFeatureChannels(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
            out_states: &mut Option<Retained<MPSStateBatch>>,
            is_temporary: bool,
            reshaped_width: NSUInteger,
            reshaped_height: NSUInteger,
            reshaped_feature_channels: NSUInteger,
        ) -> Retained<MPSImageBatch>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNReshape {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNReshape {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// The reshape gradient filter reshapes the incoming gradient into the dimensions
    /// of the forward reshape kernel's source image.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnnreshapegradient?language=objc)
    #[unsafe(super(MPSCNNGradientKernel, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNNReshapeGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNNReshapeGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNNReshapeGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNNReshapeGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNNReshapeGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNNReshapeGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNReshapeGradient {
    extern_methods!(
        /// Initializes a MPSNNReshapeGradient function
        ///
        /// Parameter `device`: The MTLDevice on which this filter will be used
        ///
        ///
        /// Returns: A valid MPSNNReshapeGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNReshapeGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNReshapeGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnnpad?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNNPad;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNNPad {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNNPad {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNNPad {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNNPad {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNNPad {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNPad {
    extern_methods!(
        #[cfg(feature = "MPSCoreTypes")]
        /// This property is used for automatically sizing the destination image
        /// for the function
        /// destinationImageDescriptorForSourceImages:sourceStates:.Defines
        /// how much padding to assign on the left, top and smaller feature channel indices
        /// of the image. NOTE: the x and y coordinates of this property are only
        /// used through
        /// destinationImageDescriptorForSourceImages:sourceStates:,since
        /// the clipRect and offset together define the padding sizes in those directions, but
        /// the 'channel' size defines the amount of padding to be applied in the feature
        /// channel dimension, before the feature channels starting from feature channel
        /// index
        /// sourceFeatureChannelOffset.Default: { 0, 0, 0 }
        #[unsafe(method(paddingSizeBefore))]
        #[unsafe(method_family = none)]
        pub unsafe fn paddingSizeBefore(&self) -> MPSImageCoordinate;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`paddingSizeBefore`][Self::paddingSizeBefore].
        #[unsafe(method(setPaddingSizeBefore:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPaddingSizeBefore(&self, padding_size_before: MPSImageCoordinate);

        #[cfg(feature = "MPSCoreTypes")]
        /// This property is used for automatically sizing the destination image
        /// for the function
        /// destinationImageDescriptorForSourceImages:sourceStates:.Defines
        /// how much padding to assign on the right, bottom and higher feature channel indices
        /// of the image. NOTE: the x and y coordinates of this property are only
        /// used through
        /// destinationImageDescriptorForSourceImages:sourceStates:,since
        /// the clipRect and offset together define the padding sizes in those directions, but
        /// the 'channel' size defines the amount of padding to be applied in the feature
        /// channel dimension after source feature channel index determined by the sum of
        /// sourceFeatureChannelOffsetand
        /// sourceFeatureChannelMaxCount,naturally
        /// clipped to fit the feature channels in the provided source image.
        /// Default: { 0, 0, 0 }
        #[unsafe(method(paddingSizeAfter))]
        #[unsafe(method_family = none)]
        pub unsafe fn paddingSizeAfter(&self) -> MPSImageCoordinate;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`paddingSizeAfter`][Self::paddingSizeAfter].
        #[unsafe(method(setPaddingSizeAfter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPaddingSizeAfter(&self, padding_size_after: MPSImageCoordinate);

        /// Determines the constant value to apply when using
        /// MPSImageEdgeModeConstant.Default: 0.0f.
        /// NOTE: this value is ignored if the filter is initialized with a per-channel fill value
        /// using
        /// initWithDevice:paddingSizeBefore:paddingSizeAfter:fillValueArray:.
        #[unsafe(method(fillValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn fillValue(&self) -> c_float;

        /// Setter for [`fillValue`][Self::fillValue].
        #[unsafe(method(setFillValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFillValue(&self, fill_value: c_float);

        /// Initialize a MPSNNPad kernel
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Returns: A valid MPSNNPad object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSCoreTypes")]
        /// Initialize a MPSNNPad kernel
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `paddingSizeBefore`: The amount of padding to add before the source image - see details above.
        ///
        /// Parameter `paddingSizeAfter`: The amount of padding to add after the source image - see details above.
        ///
        /// Returns: A valid MPSNNPad object or nil, if failure.
        #[unsafe(method(initWithDevice:paddingSizeBefore:paddingSizeAfter:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_paddingSizeBefore_paddingSizeAfter(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            padding_size_before: MPSImageCoordinate,
            padding_size_after: MPSImageCoordinate,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSCoreTypes")]
        /// Initialize a MPSNNPad kernel
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `paddingSizeBefore`: The amount of padding to add before the source image - see details above.
        ///
        /// Parameter `paddingSizeAfter`: The amount of padding to add after the source image - see details above.
        ///
        /// Parameter `fillValueArray`: A NSData containing a float array to use with
        /// MPSImageEdgeModeConstant.The first value of the array will correspond to the first feature channel
        /// written out to the destination image and the number of float values in the
        /// data must be at least as large as the number of feature channels written onto
        /// the destination by the filter. Failing to pass a large enough array will
        /// result in undefined behavior. Passing in nil is fine.
        ///
        /// Returns: A valid MPSNNPad object or nil, if failure.
        #[unsafe(method(initWithDevice:paddingSizeBefore:paddingSizeAfter:fillValueArray:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_paddingSizeBefore_paddingSizeAfter_fillValueArray(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            padding_size_before: MPSImageCoordinate,
            padding_size_after: MPSImageCoordinate,
            fill_value_array: Option<&NSData>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSNNPad
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSNNPad
        ///
        /// Returns: A new MPSNNPad object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNPad {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNPad {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Computes the gradient for the
    /// MPSNNPadlayer.
    /// Since the padding forward operation typically increases the size of the image, the gradient operation
    /// decreases it. In case of zero or constant padding forward operation the gradient operation slices the
    /// input gradient and in other edge modes the padded values copied in the forward operation are
    /// summed together in the gradient operation.
    /// For Example for the
    /// MPSImageEdgeModeClampthe forward operation with offset = -2, destSize = 8
    /// or
    /// paddingSizeBefore= 2,
    /// paddingSizeAfter= 3, sourceSize = 3:
    ///
    /// ```text
    ///               Source Image:
    ///                 |--------------|
    ///                 | x0 | x1 | x2 |
    ///                 |--------------|
    ///               Destination Image:
    ///                 |---------------------------------------|
    ///                 | x0 | x0 | x0 | x1 | x2 | x2 | x2 | x2 |
    ///                 |---------------------------------------|
    /// ```
    ///
    /// Then the gradient operation becomes:
    ///
    /// ```text
    ///               Source Gradient Image:
    ///                 |---------------------------------------|
    ///                 | d0 | d1 | d2 | d3 | d4 | d5 | d6 | d7 |
    ///                 |---------------------------------------|
    ///               Destination Gradient Image:
    ///                 |-----------------------------|
    ///                 | d0+d1+d2 | d3 | d4+d5+d6+d7 |
    ///                 |-----------------------------|
    /// ```
    ///
    /// Another example with
    /// MPSImageEdgeModeMirror,the forward operation with offset = -4, destSize = 8
    /// or
    /// paddingSizeBefore= 4,
    /// paddingSizeAfter= 1, sourceSize = 3:
    ///
    /// ```text
    ///               Source Image:
    ///                 |--------------|
    ///                 | x0 | x1 | x2 |
    ///                 |--------------|
    ///               Destination Image:
    ///                 |---------------------------------------|
    ///                 | x0 | x1 | x2 | x1 | x0 | x1 | x2 | x1 |
    ///                 |---------------------------------------|
    /// ```
    ///
    /// Then the gradient operation becomes:
    ///
    /// ```text
    ///               Source Gradient Image:
    ///                 |---------------------------------------|
    ///                 | d0 | d1 | d2 | d3 | d4 | d5 | d6 | d7 |
    ///                 |---------------------------------------|
    ///               Destination Gradient Image:
    ///                 |-----------------------------|
    ///                 | d0+d4 | d1+d3+d5+d7 | d2+d6 |
    ///                 |-----------------------------|
    /// ```
    ///
    /// NOTE: There are no channel fill-values to use with
    /// MPSImageEdgeModeConstantsince the gradient values are independent of the constant of the forward pass.
    /// NOTE: In case the forward pass defined a slice operation in feature channels then
    /// the channels not read in the forward pass will be filled with zeros in the gradient pass.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnnpadgradient?language=objc)
    #[unsafe(super(MPSCNNGradientKernel, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNNPadGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNNPadGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNNPadGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNNPadGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNNPadGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNNPadGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNPadGradient {
    extern_methods!(
        /// Initializes a MPSNNPadGradient filter
        ///
        /// Parameter `device`: The MTLDevice on which this filter will be used
        ///
        ///
        /// Returns: A valid MPSNNPadGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSNNPadGradient.
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSNNPadGradient.
        ///
        /// Returns: A new MPSNNPadGradient object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNPadGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNNPadGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
