//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// The MPSNNNeuronDescriptor specifies a neuron descriptor.
    /// Supported neuron types:
    ///
    /// Neuron type "none": f(x) = x
    /// Parameters: none
    ///
    /// ReLU neuron filter: f(x) = x >= 0 ? x : a * x
    /// This is called Leaky ReLU in literature. Some literature defines
    /// classical ReLU as max(0, x). If you want this behavior, simply pass a = 0.
    /// Parameters: a
    /// For default behavior, set the value of a to 0.0f.
    ///
    /// Linear neuron filter: f(x) = a * x + b
    /// Parameters: a, b
    /// For default behavior, set the value of a to 1.0f and the value of b to 0.0f.
    ///
    /// Sigmoid neuron filter: f(x) = 1 / (1 + e^-x)
    /// Parameters: none
    ///
    /// Hard Sigmoid filter: f(x) = clamp((x * a) + b, 0, 1)
    /// Parameters: a, b
    /// For default behavior, set the value of a to 0.2f and the value of b to 0.5f.
    ///
    /// Hyperbolic tangent (TanH) neuron filter: f(x) = a * tanh(b * x)
    /// Parameters: a, b
    /// For default behavior, set the value of a to 1.0f and the value of b to 1.0f.
    ///
    /// Absolute neuron filter: f(x) = fabs(x)
    /// Parameters: none
    ///
    /// Parametric Soft Plus neuron filter: f(x) = a * log(1 + e^(b * x))
    /// Parameters: a, b
    /// For default behavior, set the value of a to 1.0f and the value of b to 1.0f.
    ///
    /// Parametric Soft Sign neuron filter: f(x) = x / (1 + abs(x))
    /// Parameters: none
    ///
    /// Parametric ELU neuron filter: f(x) = x >= 0 ? x : a * (exp(x) - 1)
    /// Parameters: a
    /// For default behavior, set the value of a to 1.0f.
    ///
    /// Parametric ReLU (PReLU) neuron filter: Same as ReLU, except parameter
    /// aArray is per channel.
    /// For each pixel, applies the following function: f(x_i) = x_i, if x_i >= 0
    /// = a_i * x_i if x_i
    /// <
    /// 0
    /// i in [0...channels-1]
    /// i.e. parameters a_i are learned and applied to each channel separately. Compare
    /// this to ReLu where parameter a is shared across all channels.
    /// See https://arxiv.org/pdf/1502.01852.pdf for details.
    /// Parameters: aArray - Array of floats containing per channel value of PReLu parameter
    /// count - Number of float values in array aArray.
    ///
    /// ReLUN neuron filter: f(x) = min((x >= 0 ? x : a * x), b)
    /// Parameters: a, b
    /// As an example, the TensorFlow Relu6 activation layer can be implemented
    /// by setting the parameter b to 6.0f:
    /// https://www.tensorflow.org/api_docs/cc/class/tensorflow/ops/relu6.
    /// For default behavior, set the value of a to 1.0f and the value of b to 6.0f.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnnneurondescriptor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSNNNeuronDescriptor;
);

extern_conformance!(
    unsafe impl NSCoding for MPSNNNeuronDescriptor {}
);

extern_conformance!(
    unsafe impl NSCopying for MPSNNNeuronDescriptor {}
);

unsafe impl CopyingHelper for MPSNNNeuronDescriptor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNNNeuronDescriptor {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for MPSNNNeuronDescriptor {}
);

impl MPSNNNeuronDescriptor {
    extern_methods!(
        #[cfg(feature = "MPSCNNNeuronType")]
        #[unsafe(method(neuronType))]
        #[unsafe(method_family = none)]
        pub unsafe fn neuronType(&self) -> MPSCNNNeuronType;

        #[cfg(feature = "MPSCNNNeuronType")]
        /// Setter for [`neuronType`][Self::neuronType].
        #[unsafe(method(setNeuronType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNeuronType(&self, neuron_type: MPSCNNNeuronType);

        #[unsafe(method(a))]
        #[unsafe(method_family = none)]
        pub unsafe fn a(&self) -> c_float;

        /// Setter for [`a`][Self::a].
        #[unsafe(method(setA:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setA(&self, a: c_float);

        #[unsafe(method(b))]
        #[unsafe(method_family = none)]
        pub unsafe fn b(&self) -> c_float;

        /// Setter for [`b`][Self::b].
        #[unsafe(method(setB:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setB(&self, b: c_float);

        #[unsafe(method(c))]
        #[unsafe(method_family = none)]
        pub unsafe fn c(&self) -> c_float;

        /// Setter for [`c`][Self::c].
        #[unsafe(method(setC:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setC(&self, c: c_float);

        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Option<Retained<NSData>>;

        /// Setter for [`data`][Self::data].
        #[unsafe(method(setData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setData(&self, data: Option<&NSData>);

        /// You must use one of the interfaces below instead.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "MPSCNNNeuronType")]
        /// Make a descriptor for a MPSCNNNeuron object.
        ///
        /// Parameter `neuronType`: The type of a neuron filter.
        ///
        /// Returns: A valid MPSNNNeuronDescriptor object or nil, if failure.
        #[unsafe(method(cnnNeuronDescriptorWithType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cnnNeuronDescriptorWithType(
            neuron_type: MPSCNNNeuronType,
        ) -> Retained<MPSNNNeuronDescriptor>;

        #[cfg(feature = "MPSCNNNeuronType")]
        /// Make a descriptor for a MPSCNNNeuron object.
        ///
        /// Parameter `neuronType`: The type of a neuron filter.
        ///
        /// Parameter `a`: Parameter "a".
        ///
        /// Returns: A valid MPSNNNeuronDescriptor object or nil, if failure.
        #[unsafe(method(cnnNeuronDescriptorWithType:a:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cnnNeuronDescriptorWithType_a(
            neuron_type: MPSCNNNeuronType,
            a: c_float,
        ) -> Retained<MPSNNNeuronDescriptor>;

        #[cfg(feature = "MPSCNNNeuronType")]
        /// Initialize the neuron descriptor.
        ///
        /// Parameter `neuronType`: The type of a neuron filter.
        ///
        /// Parameter `a`: Parameter "a".
        ///
        /// Parameter `b`: Parameter "b".
        ///
        /// Returns: A valid MPSNNNeuronDescriptor object or nil, if failure.
        #[unsafe(method(cnnNeuronDescriptorWithType:a:b:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cnnNeuronDescriptorWithType_a_b(
            neuron_type: MPSCNNNeuronType,
            a: c_float,
            b: c_float,
        ) -> Retained<MPSNNNeuronDescriptor>;

        #[cfg(feature = "MPSCNNNeuronType")]
        /// Make a descriptor for a MPSCNNNeuron object.
        ///
        /// Parameter `neuronType`: The type of a neuron filter.
        ///
        /// Parameter `a`: Parameter "a".
        ///
        /// Parameter `b`: Parameter "b".
        ///
        /// Parameter `c`: Parameter "c".
        ///
        /// Returns: A valid MPSNNNeuronDescriptor object or nil, if failure.
        #[unsafe(method(cnnNeuronDescriptorWithType:a:b:c:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cnnNeuronDescriptorWithType_a_b_c(
            neuron_type: MPSCNNNeuronType,
            a: c_float,
            b: c_float,
            c: c_float,
        ) -> Retained<MPSNNNeuronDescriptor>;

        /// Make a descriptor for a neuron of type MPSCNNNeuronTypePReLU.
        ///
        /// The PReLU neuron is the same as a ReLU neuron, except parameter "a" is per feature channel.
        ///
        /// Parameter `data`: A NSData containing a float array with the per feature channel value
        /// of PReLu parameter. The number of float values in this array usually
        /// corresponds to number of output channels in a convolution layer.
        /// The descriptor retains the NSData object.
        ///
        /// Parameter `noCopy`: An optimization flag that tells us whether the NSData allocation is
        /// suitable for use directly with no copying of the data into internal
        /// storage. This allocation has to match the same restrictions as listed
        /// for the newBufferWithBytesNoCopy:length:options:deallocator: method of
        /// MTLBuffer.
        ///
        /// Returns: A valid MPSNNNeuronDescriptor object for a neuron of type MPSCNNNeuronTypePReLU or nil, if failure
        #[unsafe(method(cnnNeuronPReLUDescriptorWithData:noCopy:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cnnNeuronPReLUDescriptorWithData_noCopy(
            data: &NSData,
            no_copy: bool,
        ) -> Retained<MPSNNNeuronDescriptor>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MPSNNNeuronDescriptor {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// This filter applies a neuron activation function.
    /// You must use one of the sub-classes of MPSCNNNeuron.
    ///
    /// The following filter types are supported:
    /// MPSCNNNeuronTypeNone            ///
    /// <
    /// f(x) = x
    /// MPSCNNNeuronTypeLinear          ///
    /// <
    /// f(x) = a * x + b
    /// MPSCNNNeuronTypeReLU            ///
    /// <
    /// f(x) = x >= 0 ? x : a * x
    /// MPSCNNNeuronTypeSigmoid         ///
    /// <
    /// f(x) = 1 / (1 + e^-x)
    /// MPSCNNNeuronTypeHardSigmoid     ///
    /// <
    /// f(x) = clamp((x * a) + b, 0, 1)
    /// MPSCNNNeuronTypeTanH            ///
    /// <
    /// f(x) = a * tanh(b * x)
    /// MPSCNNNeuronTypeAbsolute        ///
    /// <
    /// f(x) = fabs(x)
    /// MPSCNNNeuronTypeSoftPlus        ///
    /// <
    /// f(x) = a * log(1 + e^(b * x))
    /// MPSCNNNeuronTypeSoftSign        ///
    /// <
    /// f(x) = x / (1 + abs(x))
    /// MPSCNNNeuronTypeELU             ///
    /// <
    /// f(x) = x >= 0 ? x : a * (exp(x) - 1)
    /// MPSCNNNeuronTypePReLU           ///
    /// <
    /// Same as ReLU except parameter a is per channel
    /// MPSCNNNeuronTypeReLUN           ///
    /// <
    /// f(x) = min((x >= 0 ? x : a * x), b)
    /// MPSCNNNeuronTypePower           ///
    /// <
    /// f(x) = (a * x + b) ^ c
    /// MPSCNNNeuronTypeExponential     ///
    /// <
    /// f(x) = c ^ (a * x + b)
    /// MPSCNNNeuronTypeLogarithm       ///
    /// <
    /// f(x) = log_c(a * x + b)
    /// MPSCNNNeuronTypeGeLU            ///
    /// <
    /// f(x) = (1.0 + erf(x * sqrt(0.5))) * 0.5 * x
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuron?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuron;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuron {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuron {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuron {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuron {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuron {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuron {
    extern_methods!(
        #[cfg(feature = "MPSCNNNeuronType")]
        #[unsafe(method(neuronType))]
        #[unsafe(method_family = none)]
        pub unsafe fn neuronType(&self) -> MPSCNNNeuronType;

        #[unsafe(method(a))]
        #[unsafe(method_family = none)]
        pub unsafe fn a(&self) -> c_float;

        #[unsafe(method(b))]
        #[unsafe(method_family = none)]
        pub unsafe fn b(&self) -> c_float;

        #[unsafe(method(c))]
        #[unsafe(method_family = none)]
        pub unsafe fn c(&self) -> c_float;

        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Option<Retained<NSData>>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuron {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuron {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// This filter is a backward filter for the neuron activation function filter.
    ///
    /// The following filter types are supported:
    /// MPSCNNNeuronTypeNone            ///
    /// <
    /// df/dx = 1
    /// MPSCNNNeuronTypeLinear          ///
    /// <
    /// df/dx = a
    /// MPSCNNNeuronTypeReLU            ///
    /// <
    /// df/dx = [ 1, if x >= 0
    /// [ a, if x
    /// <
    /// 0
    /// MPSCNNNeuronTypeSigmoid         ///
    /// <
    /// df/dx = e^x / (e^x + 1)^2
    /// MPSCNNNeuronTypeHardSigmoid     ///
    /// <
    /// df/dx = [ a, if ((x * a) + b >= 0) and ((x * a) + b
    /// <
    /// = 1)
    /// [ 0, otherwise
    /// MPSCNNNeuronTypeTanH            ///
    /// <
    /// df/dx = a * b * (1 - tanh^2(b * x))
    /// MPSCNNNeuronTypeAbsolute        ///
    /// <
    /// df/dx = sign(x)
    /// MPSCNNNeuronTypeSoftPlus        ///
    /// <
    /// df/dx = (a * b * exp(b * x)) / (exp(b * x) + 1)
    /// MPSCNNNeuronTypeSoftSign        ///
    /// <
    /// df/dx = 1 / (|x| + 1)^2
    /// MPSCNNNeuronTypeELU             ///
    /// <
    /// df/dx = [ a * exp(x), x
    /// <
    /// 0
    /// [          1, x >= 0
    /// MPSCNNNeuronTypePReLU           ///
    /// <
    /// df/dx = [  1, if x >= 0
    /// [ aV, if x
    /// <
    /// 0
    /// MPSCNNNeuronTypeReLUN           ///
    /// <
    /// df/dx = [ 1, if x >= 0
    /// [ a, if x
    /// <
    /// 0
    /// [ b, if x >= b
    /// MPSCNNNeuronTypePower           ///
    /// <
    /// df/dx = a * c * (a * x + b)^(c - 1)
    /// MPSCNNNeuronTypeExponential     ///
    /// <
    /// df/dx = [         a * exp(a * x + b), if c == -1
    /// [ a * log(c) * c^(a * x + b), if c != -1
    /// MPSCNNNeuronTypeLogarithm       ///
    /// <
    /// df/dx = [            a / (a * in + b), if c == -1
    /// [ a / (log(c) * (a * in + b)), if c != -1
    /// MPSCNNNeuronTypeGeLU            ///
    /// <
    /// df/dx = 0.5 * (1.0 + erf(x * sqrt(0.5))) + (sqrt(0.5) * M_2_SQRTPI * exp(-x*x * 0.5) * x) )
    ///
    /// The result of the above operation is multiplied with the gradient, computed
    /// by the preceeding filter (going backwards).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneurongradient?language=objc)
    #[unsafe(super(MPSCNNGradientKernel, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronGradient {
    extern_methods!(
        #[cfg(feature = "MPSCNNNeuronType")]
        #[unsafe(method(neuronType))]
        #[unsafe(method_family = none)]
        pub unsafe fn neuronType(&self) -> MPSCNNNeuronType;

        #[unsafe(method(a))]
        #[unsafe(method_family = none)]
        pub unsafe fn a(&self) -> c_float;

        #[unsafe(method(b))]
        #[unsafe(method_family = none)]
        pub unsafe fn b(&self) -> c_float;

        #[unsafe(method(c))]
        #[unsafe(method_family = none)]
        pub unsafe fn c(&self) -> c_float;

        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Option<Retained<NSData>>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize the neuron gradient filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuronGradient retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuronGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the linear neuron filter. For each pixel, applies the following function: f(x) = a * x + b
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronlinear?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronLinear;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronLinear {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronLinear {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronLinear {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronLinear {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronLinear {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronLinear {
    extern_methods!(
        /// Initialize the linear neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Parameter `b`: Filter property "b". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronLinear object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:b:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a_b(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
            b: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronLinear {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronLinear {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronLinear {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the ReLU neuron filter.
    /// For each pixel, applies the following function: f(x) = x, if x >= 0
    /// = a * x if x
    /// <
    /// 0
    /// This is called Leaky ReLU in literature. Some literature defines
    /// classical ReLU as max(0, x). If you want this behavior, simply pass a = 0
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronrelu?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronReLU;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronReLU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronReLU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronReLU {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronReLU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronReLU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronReLU {
    extern_methods!(
        /// Initialize the ReLU neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronReLU object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronReLU {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronReLU {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronReLU {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the parametric ReLU neuron filter.
    /// For each pixel, applies the following function: f(x_i) = x_i, if x_i >= 0
    /// = a_i * x_i if x_i
    /// <
    /// 0
    /// i in [0...channels-1]
    /// i.e. parameters a_i are learned and applied to each channel separately. Compare
    /// this to ReLu where parameter a is shared across all channels.
    /// See https://arxiv.org/pdf/1502.01852.pdf for details.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronprelu?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronPReLU;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronPReLU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronPReLU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronPReLU {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronPReLU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronPReLU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronPReLU {
    extern_methods!(
        /// Initialize the PReLU neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `a`: Array of floats containing per channel value of PReLu parameter
        ///
        /// Parameter `count`: Number of float values in array a.
        /// This usually corresponds to number of output channels in convolution layer
        ///
        /// Returns: A valid MPSCNNNeuronPReLU object or nil, if failure.
        ///
        /// # Safety
        ///
        /// `a` must be a valid pointer.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:count:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a_count(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: NonNull<c_float>,
            count: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronPReLU {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronPReLU {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronPReLU {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the sigmoid neuron filter.  For each pixel, applies the following function: f(x) = 1 / (1 + e^-x)
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronsigmoid?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronSigmoid;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronSigmoid {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronSigmoid {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronSigmoid {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronSigmoid {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronSigmoid {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSigmoid {
    extern_methods!(
        /// Initialize a neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Returns: A valid MPSCNNNeuronSigmoid object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSigmoid {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSigmoid {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSigmoid {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the hard sigmoid neuron filter.  For each pixel, applies the following function: f(x) = clamp((a * x) + b, 0, 1)
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronhardsigmoid?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronHardSigmoid;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronHardSigmoid {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronHardSigmoid {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronHardSigmoid {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronHardSigmoid {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronHardSigmoid {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronHardSigmoid {
    extern_methods!(
        /// Initialize a neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Parameter `b`: Filter property "b". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronHardSigmoid object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:b:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a_b(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
            b: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronHardSigmoid {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronHardSigmoid {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronHardSigmoid {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the hyperbolic tangent neuron filter.
    /// For each pixel, applies the following function: f(x) = a * tanh(b * x)
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneurontanh?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronTanH;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronTanH {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronTanH {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronTanH {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronTanH {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronTanH {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronTanH {
    extern_methods!(
        /// Initialize the hyperbolic tangent neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Parameter `b`: Filter property "b". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronTanH object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:b:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a_b(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
            b: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronTanH {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronTanH {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronTanH {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the absolute neuron filter.  For each pixel, applies the following function: f(x) = | x |
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronabsolute?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronAbsolute;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronAbsolute {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronAbsolute {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronAbsolute {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronAbsolute {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronAbsolute {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronAbsolute {
    extern_methods!(
        /// Initialize a neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Returns: A valid MPSCNNNeuronAbsolute object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronAbsolute {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronAbsolute {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronAbsolute {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the parametric softplus neuron filter.
    /// For each pixel, applies the following function: f(x) = a * log(1 + e^(b * x))
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronsoftplus?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronSoftPlus;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronSoftPlus {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronSoftPlus {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronSoftPlus {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronSoftPlus {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronSoftPlus {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSoftPlus {
    extern_methods!(
        /// Initialize a parametric softplus neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Parameter `b`: Filter property "b". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronSoftPlus object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:b:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a_b(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
            b: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSoftPlus {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSoftPlus {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSoftPlus {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the softsign neuron filter.
    /// For each pixel, applies the following function: f(x) = x / (1 + abs(x))
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronsoftsign?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronSoftSign;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronSoftSign {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronSoftSign {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronSoftSign {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronSoftSign {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronSoftSign {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSoftSign {
    extern_methods!(
        /// Initialize a softsign neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Returns: A valid MPSCNNNeuronSoftSign object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSoftSign {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSoftSign {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronSoftSign {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the parametric ELU neuron filter.
    /// For each pixel, applies the following function: f(x) = [ a * (exp(x) - 1), x
    /// <
    /// 0
    /// [ x               , x >= 0
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronelu?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronELU;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronELU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronELU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronELU {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronELU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronELU {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronELU {
    extern_methods!(
        /// Initialize a parametric ELU neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronELU object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronELU {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronELU {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronELU {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the ReLUN neuron filter.
    /// For each pixel, applies the following function: f(x) = [ x    , x >= 0
    /// [ a * x, x
    /// <
    /// 0
    /// [ b    , x >= b
    /// As an example, the TensorFlow Relu6 activation layer can be implemented
    /// by setting the parameter b to 6.0f:
    /// https://www.tensorflow.org/api_docs/cc/class/tensorflow/ops/relu6.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronrelun?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronReLUN;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronReLUN {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronReLUN {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronReLUN {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronReLUN {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronReLUN {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronReLUN {
    extern_methods!(
        /// Initialize a ReLUN neuron filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Parameter `b`: Filter property "b". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronReLUN object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:b:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a_b(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
            b: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronReLUN {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronReLUN {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronReLUN {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the Power neuron filter.
    /// For each pixel, applies the following function: f(x) = (a * x + b) ^ c.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronpower?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronPower;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronPower {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronPower {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronPower {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronPower {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronPower {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronPower {
    extern_methods!(
        /// Initialize a Power neuron filter.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Parameter `b`: Filter property "b". See class discussion.
        ///
        /// Parameter `c`: Filter property "c". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronPower object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:b:c:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a_b_c(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
            b: c_float,
            c: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronPower {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronPower {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronPower {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the Exponential neuron filter.
    /// For each pixel, applies the following function: f(x) = c ^ (a * x + b).
    ///
    /// If the value of c is -1.0f, the base (c) is set to e.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronexponential?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronExponential;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronExponential {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronExponential {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronExponential {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronExponential {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronExponential {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronExponential {
    extern_methods!(
        /// Initialize a Exponential neuron filter.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Parameter `b`: Filter property "b". See class discussion.
        ///
        /// Parameter `c`: Filter property "c". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronExponential object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:b:c:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a_b_c(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
            b: c_float,
            c: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronExponential {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronExponential {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronExponential {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// Specifies the Logarithm neuron filter.
    /// For each pixel, applies the following function: f(x) = log_c(a * x + b).
    ///
    /// If the value of c is -1.0f, the base (c) is set to e.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnneuronlogarithm?language=objc)
    #[unsafe(super(MPSCNNNeuron, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNNeuronLogarithm;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNNeuronLogarithm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNNeuronLogarithm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNNeuronLogarithm {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNNeuronLogarithm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNNeuronLogarithm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronLogarithm {
    extern_methods!(
        /// Initialize a Logarithm neuron filter.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `a`: Filter property "a". See class discussion.
        ///
        /// Parameter `b`: Filter property "b". See class discussion.
        ///
        /// Parameter `c`: Filter property "c". See class discussion.
        ///
        /// Returns: A valid MPSCNNNeuronLogarithm object or nil, if failure.
        #[deprecated]
        #[unsafe(method(initWithDevice:a:b:c:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_a_b_c(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            a: c_float,
            b: c_float,
            c: c_float,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSCNNNeuron`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronLogarithm {
    extern_methods!(
        /// Initialize the neuron filter with a neuron descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `neuronDescriptor`: The neuron descriptor.
        /// For the neuron of type MPSCNNNeuronTypePReLU, the neuron
        /// descriptor references an NSData object containing a float array
        /// with the per feature channel value of PReLu parameter and, in this
        /// case, the MPSCNNNeuron retains the NSData object.
        ///
        /// Returns: A valid MPSCNNNeuron object or nil, if failure.
        #[unsafe(method(initWithDevice:neuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_neuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            neuron_descriptor: &MPSNNNeuronDescriptor,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronLogarithm {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNNeuronLogarithm {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
