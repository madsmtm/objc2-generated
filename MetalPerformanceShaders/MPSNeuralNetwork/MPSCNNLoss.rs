//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// The MPSCNNLossDataDescriptor specifies a loss data descriptor.
    /// The same descriptor can be used to initialize both the
    /// labels and the optional weights data.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnlossdatadescriptor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSCNNLossDataDescriptor;
);

unsafe impl NSCopying for MPSCNNLossDataDescriptor {}

unsafe impl CopyingHelper for MPSCNNLossDataDescriptor {
    type Result = Self;
}

unsafe impl NSObjectProtocol for MPSCNNLossDataDescriptor {}

extern_methods!(
    unsafe impl MPSCNNLossDataDescriptor {
        #[cfg(all(feature = "MPSCore", feature = "MPSImage"))]
        /// Data layout of loss data. See MPSImage.h for more information.
        ///
        /// This parameter specifies the layout of loss data.
        #[method(layout)]
        pub unsafe fn layout(&self) -> MPSDataLayout;

        /// Size of loss data: (width, height, feature channels}.
        ///
        /// This parameter specifies the size of loss data.
        #[method(size)]
        pub unsafe fn size(&self) -> MTLSize;

        /// Row bytes of loss data.
        ///
        /// This parameter specifies the row bytes of loss data.
        #[method(bytesPerRow)]
        pub unsafe fn bytesPerRow(&self) -> NSUInteger;

        /// Setter for [`bytesPerRow`][Self::bytesPerRow].
        #[method(setBytesPerRow:)]
        pub unsafe fn setBytesPerRow(&self, bytes_per_row: NSUInteger);

        /// Slice bytes of loss data.
        ///
        /// This parameter specifies the slice bytes of loss data.
        #[method(bytesPerImage)]
        pub unsafe fn bytesPerImage(&self) -> NSUInteger;

        /// Setter for [`bytesPerImage`][Self::bytesPerImage].
        #[method(setBytesPerImage:)]
        pub unsafe fn setBytesPerImage(&self, bytes_per_image: NSUInteger);

        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "MPSCore", feature = "MPSImage"))]
        /// Make a descriptor loss data. The bytesPerRow and bytesPerImage
        /// are automatically calculated assuming a dense array. If it is
        /// not a dense array, adjust bytesPerRow and bytesPerImage to the
        /// right value by changing properties.
        ///
        /// Parameter `data`: The per-element loss data. The data must be in floating point format.
        ///
        /// Parameter `layout`: The data layout of loss data.
        ///
        /// Parameter `size`: The size of loss data.
        ///
        /// Returns: A valid MPSCNNLossDataDescriptor object or nil, if failure.
        #[method_id(@__method_family Other cnnLossDataDescriptorWithData:layout:size:)]
        pub unsafe fn cnnLossDataDescriptorWithData_layout_size(
            data: &NSData,
            layout: MPSDataLayout,
            size: MTLSize,
        ) -> Option<Retained<MPSCNNLossDataDescriptor>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MPSCNNLossDataDescriptor {
        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// The MPSCNNLossLabels is used to hold the per-element weights buffer
    /// used by both MPSCNNLoss forward filter and MPSNNLossGradient backward filter.
    /// The MPSCNNLoss forward filter populates the MPSCNNLossLabels object
    /// and the MPSNNLossGradient backward filter consumes the state object.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnlosslabels?language=objc)
    #[unsafe(super(MPSState, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSState"))]
    pub struct MPSCNNLossLabels;
);

#[cfg(all(feature = "MPSCore", feature = "MPSState"))]
unsafe impl NSObjectProtocol for MPSCNNLossLabels {}

extern_methods!(
    #[cfg(all(feature = "MPSCore", feature = "MPSState"))]
    unsafe impl MPSCNNLossLabels {
        /// Use one of the interfaces below instead.
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Set labels (aka targets, ground truth) for the MPSCNNLossLabels object.
        ///
        /// The labels and weights data are copied into internal storage. The computed loss can either be a
        /// scalar value (in batch mode, a single value per image in a batch) or it
        /// can be one value per feature channel. Thus, the size of the loss image
        /// must either match the size of the input source image or be {1, 1, 1},
        /// which results in a scalar value. In this convinience initializer, the
        /// assumed size of the loss image is {1, 1, 1}.
        ///
        /// Parameter `device`: Device the state resources will be created on.
        ///
        /// Parameter `labelsDescriptor`: Describes the labels data. This includes:
        /// - The per-element labels data. The data must be in floating point format.
        /// - Data layout of labels data. See MPSImage.h for more information.
        /// - Size of labels data: (width, height, feature channels}.
        /// - Optionally, row bytes of labels data.
        /// - Optionally, slice bytes of labels data.
        #[method_id(@__method_family Init initWithDevice:labelsDescriptor:)]
        pub unsafe fn initWithDevice_labelsDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            labels_descriptor: &MPSCNNLossDataDescriptor,
        ) -> Retained<Self>;

        /// Set labels (aka targets, ground truth) and weights for the MPSCNNLossLabels object.
        /// Weights are optional.
        ///
        /// The labels and weights data are copied into internal storage.
        ///
        /// Parameter `device`: Device the state resources will be created on.
        ///
        /// Parameter `lossImageSize`: The size of the resulting loss image: { width, height, featureChannels }.
        /// The computed loss can either be a scalar value (in batch mode, a single
        /// value per image in a batch) or it can be one value per feature channel.
        /// Thus, the size of the loss image must either match the size of the input
        /// source image or be {1, 1, 1}, which results in a scalar value.
        ///
        /// Parameter `labelsDescriptor`: Describes the labels data. This includes:
        /// - The per-element labels data. The data must be in floating point format.
        /// - Data layout of labels data. See MPSImage.h for more information.
        /// - Size of labels data: (width, height, feature channels}.
        /// - Optionally, row bytes of labels data.
        /// - Optionally, slice bytes of labels data.
        ///
        /// Parameter `weightsDescriptor`: Describes the weights data. This includes:
        /// - The per-element weights data. The data must be in floating point format.
        /// - Data layout of weights data. See MPSImage.h for more information.
        /// - Size of weights data: (width, height, feature channels}.
        /// - Optionally, row bytes of weights data.
        /// - Optionally, slice bytes of weights data.
        /// This parameter is optional. If you are using a single weight, please use the
        /// weight property of the MPSCNNLossDescriptor object.
        #[method_id(@__method_family Init initWithDevice:lossImageSize:labelsDescriptor:weightsDescriptor:)]
        pub unsafe fn initWithDevice_lossImageSize_labelsDescriptor_weightsDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            loss_image_size: MTLSize,
            labels_descriptor: &MPSCNNLossDataDescriptor,
            weights_descriptor: Option<&MPSCNNLossDataDescriptor>,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSImage")]
        /// Set labels (aka targets, ground truth) and weights for the MPSCNNLossLabels object.
        /// Weights are optional.
        ///
        /// The labels and weights images are retained - it is the users responsibility to make sure that they contain
        /// the right data when the loss filter is run on the device.
        ///
        /// Parameter `device`: Device the state resources will be created on.
        ///
        /// Parameter `lossImageSize`: The size of the resulting loss image: { width, height, featureChannels }.
        /// The computed loss can either be a scalar value (in batch mode, a single
        /// value per image in a batch) or it can be one value per feature channel.
        /// Thus, the size of the loss image must either match the size of the input
        /// source image or be {1, 1, 1}, which results in a scalar value.
        ///
        /// Parameter `labelsImage`: Describes the labels data.
        ///
        /// Parameter `weightsImage`: Describes the weights data.
        /// This parameter is optional. If you are using a single weight, please use the
        /// weight property of the MPSCNNLossDescriptor object.
        #[method_id(@__method_family Init initWithDevice:lossImageSize:labelsImage:weightsImage:)]
        pub unsafe fn initWithDevice_lossImageSize_labelsImage_weightsImage(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            loss_image_size: MTLSize,
            labels_image: &MPSImage,
            weights_image: Option<&MPSImage>,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSImage")]
        /// Loss image accessor method.
        ///
        /// Returns: An autoreleased MPSImage object, containing the loss data.
        /// The loss data is populated in the -encode call, thus the contents
        /// are undefined until you -encode the filter.
        ///
        /// In order to guarantee that the image is correctly synchronized for CPU side access,
        /// it is the application's responsibility to call the [gradientState synchronizeOnCommandBuffer:]
        /// method before accessing the data in the image.
        #[method_id(@__method_family Other lossImage)]
        pub unsafe fn lossImage(&self) -> Retained<MPSImage>;

        #[cfg(feature = "MPSImage")]
        /// Labels image accessor method.
        ///
        /// Returns: An autoreleased MPSImage object, containing the labels data.
        /// The labels data is populated in the -initWithDevice call.
        ///
        /// In order to guarantee that the image is correctly synchronized for CPU side access,
        /// it is the application's responsibility to call the [gradientState synchronizeOnCommandBuffer:]
        /// method before accessing the data in the image.
        #[method_id(@__method_family Other labelsImage)]
        pub unsafe fn labelsImage(&self) -> Retained<MPSImage>;

        #[cfg(feature = "MPSImage")]
        /// Weights image accessor method.
        ///
        /// Returns: An autoreleased MPSImage object, containing the weights data.
        /// The weights data is populated in the -initWithDevice call.
        ///
        /// In order to guarantee that the image is correctly synchronized for CPU side access,
        /// it is the application's responsibility to call the [gradientState synchronizeOnCommandBuffer:]
        /// method before accessing the data in the image.
        #[method_id(@__method_family Other weightsImage)]
        pub unsafe fn weightsImage(&self) -> Retained<MPSImage>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSState`
    #[cfg(all(feature = "MPSCore", feature = "MPSState"))]
    unsafe impl MPSCNNLossLabels {
        /// Create a MPSState holding a temporary MTLBuffer
        ///
        /// Parameter `cmdBuf`: The command buffer against which the temporary resource is allocated
        ///
        /// Parameter `bufferSize`: The size of the buffer in bytes
        #[method_id(@__method_family Other temporaryStateWithCommandBuffer:bufferSize:)]
        pub unsafe fn temporaryStateWithCommandBuffer_bufferSize(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            buffer_size: usize,
        ) -> Retained<Self>;

        /// Create a MPSState holding a temporary MTLTexture
        ///
        /// Parameter `cmdBuf`: The command buffer against which the temporary resource is allocated
        ///
        /// Parameter `descriptor`: A descriptor for the new temporary texture
        #[method_id(@__method_family Other temporaryStateWithCommandBuffer:textureDescriptor:)]
        pub unsafe fn temporaryStateWithCommandBuffer_textureDescriptor(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        /// Create a new autoreleased temporary state object without underlying resource
        ///
        /// Parameter `cmdBuf`: The command buffer with which the temporary resource is associated
        #[method_id(@__method_family Other temporaryStateWithCommandBuffer:)]
        pub unsafe fn temporaryStateWithCommandBuffer(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
        ) -> Retained<Self>;

        #[method_id(@__method_family Init initWithDevice:bufferSize:)]
        pub unsafe fn initWithDevice_bufferSize(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            buffer_size: usize,
        ) -> Retained<Self>;

        #[method_id(@__method_family Init initWithDevice:textureDescriptor:)]
        pub unsafe fn initWithDevice_textureDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        /// Create a MPSState with a non-temporary MTLResource
        ///
        /// Parameter `resource`: A MTLBuffer or MTLTexture. May be nil.
        #[method_id(@__method_family Init initWithResource:)]
        pub unsafe fn initWithResource(
            this: Allocated<Self>,
            resource: Option<&ProtocolObject<dyn MTLResource>>,
        ) -> Retained<Self>;

        /// Initialize a non-temporary state to hold a number of textures and buffers
        ///
        /// The allocation of each resource will be deferred  until it is needed.
        /// This occurs when -resource or -resourceAtIndex: is called.
        ///
        /// Parameter `resourceList`: The list of resources to create.
        #[method_id(@__method_family Init initWithDevice:resourceList:)]
        pub unsafe fn initWithDevice_resourceList(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Initialize a temporary state to hold a number of textures and buffers
        ///
        /// The textures occur first in sequence
        #[method_id(@__method_family Other temporaryStateWithCommandBuffer:resourceList:)]
        pub unsafe fn temporaryStateWithCommandBuffer_resourceList(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Create a state object with a list of MTLResources
        ///
        /// Because MPS prefers deferred allocation of resources
        /// your application should use -initWithTextures:bufferSizes:bufferCount:
        /// whenever possible. This method is useful for cases when the
        /// MTLResources must be initialized by the CPU.
        #[method_id(@__method_family Init initWithResources:)]
        pub unsafe fn initWithResources(
            this: Allocated<Self>,
            resources: Option<&NSArray<ProtocolObject<dyn MTLResource>>>,
        ) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCore", feature = "MPSState"))]
    unsafe impl MPSCNNLossLabels {
        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

/// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnlosslabelsbatch?language=objc)
#[cfg(all(feature = "MPSCore", feature = "MPSState"))]
pub type MPSCNNLossLabelsBatch = NSArray<MPSCNNLossLabels>;

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// The MPSCNNLossDescriptor specifies a loss filter descriptor.
    /// The same descriptor can be used to initialize both the
    /// MPSCNNLoss and the MPSNNLossGradient filters.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnlossdescriptor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSCNNLossDescriptor;
);

unsafe impl NSCopying for MPSCNNLossDescriptor {}

unsafe impl CopyingHelper for MPSCNNLossDescriptor {
    type Result = Self;
}

unsafe impl NSObjectProtocol for MPSCNNLossDescriptor {}

extern_methods!(
    unsafe impl MPSCNNLossDescriptor {
        #[cfg(feature = "MPSCNNTypes")]
        /// The type of a loss filter.
        ///
        /// This parameter specifies the type of a loss filter.
        #[method(lossType)]
        pub unsafe fn lossType(&self) -> MPSCNNLossType;

        #[cfg(feature = "MPSCNNTypes")]
        /// Setter for [`lossType`][Self::lossType].
        #[method(setLossType:)]
        pub unsafe fn setLossType(&self, loss_type: MPSCNNLossType);

        #[cfg(feature = "MPSCNNTypes")]
        /// The type of a reduction operation performed in the loss filter.
        ///
        /// This parameter specifies the type of a reduction operation
        /// performed in the loss filter.
        #[method(reductionType)]
        pub unsafe fn reductionType(&self) -> MPSCNNReductionType;

        #[cfg(feature = "MPSCNNTypes")]
        /// Setter for [`reductionType`][Self::reductionType].
        #[method(setReductionType:)]
        pub unsafe fn setReductionType(&self, reduction_type: MPSCNNReductionType);

        /// If set to YES then the reduction operation is applied also across the batch-index dimension,
        /// ie. the loss value is summed over images in the batch and the result of the reduction is written
        /// on the first loss image in the batch while the other loss images will be set to zero.
        /// If set to NO, then no reductions are performed across the batch dimension and each image in the batch
        /// will contain the loss value associated with that one particular image.
        /// NOTE: If reductionType == MPSCNNReductionTypeNone, then this flag has no effect on results,
        /// that is no reductions are done in this case.
        /// NOTE: If reduceAcrossBatch is set to YES and reductionType == MPSCNNReductionTypeMean then
        /// the final forward loss value is computed by first summing over the components and then by
        /// dividing the result with: number of feature channels * width * height * number of images in the batch.
        /// The default value is NO.
        #[method(reduceAcrossBatch)]
        pub unsafe fn reduceAcrossBatch(&self) -> bool;

        /// Setter for [`reduceAcrossBatch`][Self::reduceAcrossBatch].
        #[method(setReduceAcrossBatch:)]
        pub unsafe fn setReduceAcrossBatch(&self, reduce_across_batch: bool);

        /// The scale factor to apply to each element of a result.
        ///
        /// Each element of a result is multiplied by the weight value.
        /// The default value is 1.0f.
        #[method(weight)]
        pub unsafe fn weight(&self) -> c_float;

        /// Setter for [`weight`][Self::weight].
        #[method(setWeight:)]
        pub unsafe fn setWeight(&self, weight: c_float);

        /// The label smoothing parameter. The default value is 0.0f.
        ///
        /// This parameter is valid only for the loss functions of the following type(s):
        /// MPSCNNLossFunctionTypeSoftmaxCrossEntropy, MPSCNNLossFunctionTypeSigmoidCrossEntropy.
        ///
        /// MPSCNNLossFunctionTypeSoftmaxCrossEntropy: given labels (ground truth), it is applied in the following way:
        /// labels = labelSmoothing > 0 ? labels * (1 - labelSmoothing) + labelSmoothing / numberOfClasses : labels
        ///
        /// MPSCNNLossFunctionTypeSigmoidCrossEntropy: given labels (ground truth), it is applied in the following way:
        /// labels = labelSmoothing > 0 ? labels * (1 - labelSmoothing) + 0.5 * labelSmoothing : labels
        #[method(labelSmoothing)]
        pub unsafe fn labelSmoothing(&self) -> c_float;

        /// Setter for [`labelSmoothing`][Self::labelSmoothing].
        #[method(setLabelSmoothing:)]
        pub unsafe fn setLabelSmoothing(&self, label_smoothing: c_float);

        /// The number of classes parameter. The default value is 1.
        ///
        /// This parameter is valid only for the loss functions of the following type(s):
        /// MPSCNNLossFunctionTypeSoftmaxCrossEntropy.
        ///
        /// Given labels (ground truth), it is applied in the following way:
        /// labels = labelSmoothing > 0 ? labels * (1 - labelSmoothing) + labelSmoothing / numberOfClasses : labels
        #[method(numberOfClasses)]
        pub unsafe fn numberOfClasses(&self) -> NSUInteger;

        /// Setter for [`numberOfClasses`][Self::numberOfClasses].
        #[method(setNumberOfClasses:)]
        pub unsafe fn setNumberOfClasses(&self, number_of_classes: NSUInteger);

        /// The epsilon parameter. The default value is 1e-7.
        ///
        /// This parameter is valid only for the loss functions of the following type(s):
        /// MPSCNNLossTypeLog.
        ///
        /// Given predictions and labels (ground truth), it is applied in the following way:
        /// -(labels * log(predictions + epsilon)) - ((1 - labels) * log(1 - predictions + epsilon))
        #[method(epsilon)]
        pub unsafe fn epsilon(&self) -> c_float;

        /// Setter for [`epsilon`][Self::epsilon].
        #[method(setEpsilon:)]
        pub unsafe fn setEpsilon(&self, epsilon: c_float);

        /// The delta parameter. The default value is 1.0f.
        ///
        /// This parameter is valid only for the loss functions of the following type(s):
        /// MPSCNNLossTypeHuber.
        ///
        /// Given predictions and labels (ground truth), it is applied in the following way:
        /// if (|predictions - labels|
        /// <
        /// = delta, loss = 0.5f * predictions^2
        /// if (|predictions - labels| >  delta, loss = 0.5 * delta^2 + delta * (|predictions - labels| - delta)
        #[method(delta)]
        pub unsafe fn delta(&self) -> c_float;

        /// Setter for [`delta`][Self::delta].
        #[method(setDelta:)]
        pub unsafe fn setDelta(&self, delta: c_float);

        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "MPSCNNTypes")]
        /// Make a descriptor for a MPSCNNLoss or MPSNNLossGradient object.
        ///
        /// Parameter `lossType`: The type of a loss filter.
        ///
        /// Parameter `reductionType`: The type of a reduction operation to apply.
        /// This argument is ignored in the MPSNNLossGradient filter.
        ///
        /// Returns: A valid MPSCNNLossDescriptor object or nil, if failure.
        #[method_id(@__method_family Other cnnLossDescriptorWithType:reductionType:)]
        pub unsafe fn cnnLossDescriptorWithType_reductionType(
            loss_type: MPSCNNLossType,
            reduction_type: MPSCNNReductionType,
        ) -> Retained<MPSCNNLossDescriptor>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MPSCNNLossDescriptor {
        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// The MPSCNNLoss filter is only used for training. This filter performs both the forward and
    /// backward pass computations. Specifically, it computes the loss between the input (predictions)
    /// and target data (labels) and the loss gradient. The loss value can be a 1 x 1 x 1 image containing
    /// a scalar loss value or an image (of the same size as the input source image) with per feature
    /// channel losses. The loss value is used to determine whether to continue the training operation or
    /// to terminate it, once satisfactory results are achieved. The loss gradient is the first gradient
    /// computed for the backward pass and serves as input to the next gradient filter (in the backward
    /// direction).
    ///
    /// The MPSCNNLoss filter is created with a MPSCNNLossDescriptor describing the type of a loss filter
    /// and the type of a reduction to use for computing the overall loss.
    ///
    /// The MPSCNNLoss filter takes the output of the inference pass (predictions) as input. It also
    /// requires the target data (labels) and optionally, weights for the labels. If per-label weights
    /// are not supplied, there is an option to use a single weight value by setting the 'weight' properly
    /// on the MPSCNNLossDescriptor object. The labels and optional weights need to be supplied by the user
    /// using the MPSCNNLossLabels object. The labels and weights are described via the MPSCNNLossDataDescriptor
    /// objects, which are in turn used to initialize the MPSCNNLossLabels object.
    ///
    /// If the specified reduction operation is MPSCNNReductionTypeNone, the destinationImage should be
    /// at least as large as the specified clipRect. The destinationImage will then contain per-element
    /// losses. Otherse, a reduction operation will be performed, according to the specified reduction
    /// type, and the filter will return a scalar value containing the overall loss. For more information
    /// on the available reduction types, see MPSCNNTypes.h. Also see MPSCNNLossDescriptor for the
    /// description of optional parameters.
    ///
    /// Here is a code example:
    ///
    /// // Setup
    /// MPSCNNLossDataDescriptor* labelsDescriptor =
    /// [MPSCNNLossDataDescriptor cnnLossDataDescriptorWithData: labelsData
    /// layout: MPSDataLayoutHeightxWidthxFeatureChannels
    /// size: labelsDataSize];
    /// MPSCNNLossLabels* labels = [[MPSCNNLossLabels alloc] initWithDevice: device
    /// labelsDescriptor: labelsDescriptor];
    /// MPSCNNLossDescriptor *lossDescriptor =
    /// [MPSCNNLossDescriptor cnnLossDescriptorWithType: (MPSCNNLossType)MPSCNNLossTypeMeanAbsoluteError
    /// reductionType: (MPSCNNReductionType)MPSCNNReductionTypeSum];
    /// MPSCNNLoss* lossFilter = [[MPSCNNLoss alloc] initWithDevice: device lossDescriptor: lossDescriptor];
    ///
    /// // Encode loss filter.
    /// // The sourceImage is the output of a previous layer, for example, the SoftMax layer. The lossGradientsImage
    /// // is the sourceGradient input image to the first gradient layer (in the backward direction), for example,
    /// // the SoftMax gradient filter.
    /// [lossFilter encodeToCommandBuffer: commandBuffer sourceImage: sourceImage
    /// labels: labels
    /// destinationImage: lossGradientsImage];
    ///
    /// // In order to guarantee that the loss image data is correctly synchronized for CPU side access,
    /// // it is the application's responsibility to call the [labels synchronizeOnCommandBuffer:]
    /// // method before accessing the loss image data.
    /// [labels synchronizeOnCommandBuffer:commandBuffer];
    /// MPSImage* lossImage = [labels lossImage];
    ///
    /// For predictions (y) and labels (t), the available loss filter types are the following:
    ///
    /// Mean Absolute Error loss filter. This filter measures the absolute error of the element-wise
    /// difference between the predictions and labels.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          losses = |y - t|
    /// Compute weighted losses: weighted_losses = weight(s) * losses
    /// Compute overall loss:    loss = reduce(weighted_losses, reductionType)
    ///
    /// Mean Squared Error loss filter. This filter measures the squared error of the element-wise
    /// difference between the predictions and labels.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          losses = (y - t)^2
    /// Compute weighted losses: weighted_losses = weight(s) * losses
    /// Compute overall loss:    loss = reduce(weighted_losses, reductionType)
    ///
    /// SoftMax Cross Entropy loss filter. This loss filter is applied element-wise.
    /// This loss filter combines the LogSoftMax and Negative Log Likelihood operations in a
    /// single filter. It is useful for training a classification problem with multiple classes.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          losses = -t * LogSoftMax(y)
    /// Compute weighted losses: weighted_losses = weight(s) * losses
    /// Compute overall loss:    loss = reduce(weighted_losses, reductionType)
    /// If reductionType is MPSCNNReductionTypeMean, the accumulated
    /// loss value is divided by width * height instead of
    /// width * height * featureChannels.
    ///
    /// Sigmoid Cross Entropy loss filter. This loss filter is applied element-wise.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          losses = max(y, 0) - y * t + log(1 + exp(-|y|))
    /// Compute weighted losses: weighted_losses = weight(s) * losses
    /// Compute overall loss:    loss = reduce(weighted_losses, reductionType)
    ///
    /// Categorical Cross Entropy loss filter. This loss filter is applied element-wise.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          losses = -t * log(y)
    /// Compute weighted losses: weighted_losses = weight(s) * losses
    /// Compute overall loss:    loss = reduce(weighted_losses, reductionType)
    ///
    /// Hinge loss filter. This loss filter is applied element-wise.
    /// The labels are expected to be 0.0 or 1.0.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          losses = max(1 - (t * y), 0.0f)
    /// Compute weighted losses: weighted_losses = weight(s) * losses
    /// Compute overall loss:    loss = reduce(weighted_losses, reductionType)
    ///
    /// Huber loss filter. This loss filter is applied element-wise.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          if (|y - t|
    /// <
    /// = delta, losses = 0.5 * y^2
    /// if (|y - t| >  delta, losses = 0.5 * delta^2 + delta * (|y - t| - delta)
    /// Compute weighted losses: weighted_losses = weight(s) * losses
    /// Compute overall loss:    loss = reduce(weighted_losses, reductionType)
    ///
    /// Cosine Distance loss filter. This loss filter is applied element-wise.
    /// The only valid reduction type for this loss filter is MPSCNNReductionTypeSum.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          loss = 1 - reduce_sum(y * t)
    /// Compute overall loss:    weighted_loss = weight * loss
    ///
    /// Log loss filter. This loss filter is applied element-wise.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          losses = -(t * log(y + epsilon)) - ((1 - t) * log(1 - y + epsilon))
    /// Compute weighted losses: weighted_losses = weight(s) * losses
    /// Compute overall loss:    loss = reduce(weighted_losses, reductionType)
    ///
    /// Kullback-Leibler Divergence loss filter. This loss filter is applied element-wise.
    /// The input (predictions) is expected to contain log-probabilities.
    /// This loss function is computed according to the following formulas:
    /// Compute losses:          losses = t * (log(t) - y)
    /// Compute weighted losses: weighted_losses = weight(s) * losses
    /// Compute overall loss:    loss = reduce(weighted_losses, reductionType)
    ///
    /// For predictions (y) and labels (t), the loss gradient for each available loss filter type
    /// is computed as follows:
    ///
    /// Mean Absolute Error loss.
    /// The loss gradient is computed according to the following formulas:
    /// Compute gradient:          d/dy = (y - t) / |y - t|
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// Mean Squared Error loss.
    /// The loss gradient is computed according to the following formulas:
    /// Compute gradient:          d/dy = 2 * (y - t)
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// SoftMax Cross Entropy loss.
    /// The loss gradient is computed according to the following formulas:
    /// First, apply the same label smoothing as in the MPSCNNLoss filter.
    /// Compute gradient:          d/dy = y - t
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// Sigmoid Cross Entropy loss.
    /// The loss gradient is computed according to the following formulas:
    /// First, apply the same label smoothing as in the MPSCNNLoss filter.
    /// Compute gradient:          d/dy = (1 / (1 + exp(-y)) - t
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// Categorical Cross Entropy loss.
    /// The loss gradient is computed according to the following formulas:
    /// Compute gradient:          d/dy = -t / y
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// Hinge loss.
    /// The loss gradient is computed according to the following formulas:
    /// Compute gradient:          d/dy = ((1 + ((1 - (2 * t)) * y)) > 0) ? 1 - (2 * t) : 0
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// Huber loss.
    /// The loss gradient is computed according to the following formulas:
    /// Compute gradient:          d/dy = |y - t| > delta ? delta : y - t
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// Cosine Distance loss.
    /// The loss gradient is computed according to the following formulas:
    /// Compute gradient:          d/dy = -t
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// Log loss.
    /// The loss gradient is computed according to the following formulas:
    /// Compute gradient:          d/dy = (-2 * epsilon * t - t + y + epsilon) / (y * (1 - y) + epsilon * (epsilon + 1))
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// Kullback-Leibler Divergence loss.
    /// The loss gradient is computed according to the following formulas:
    /// Compute gradient:          d/dy = -t / y
    /// Compute weighted gradient: weighted_gradient = weight(s) * gradient
    ///
    /// The number of output feature channels remains the same as the number of input feature
    /// channels.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnloss?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNLoss;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNLoss {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNLoss {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNLoss {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNLoss {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNLoss {}

extern_methods!(
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNLoss {
        #[cfg(feature = "MPSCNNTypes")]
        /// See MPSCNNLossDescriptor for information about the following properties.
        #[method(lossType)]
        pub unsafe fn lossType(&self) -> MPSCNNLossType;

        #[cfg(feature = "MPSCNNTypes")]
        #[method(reductionType)]
        pub unsafe fn reductionType(&self) -> MPSCNNReductionType;

        #[method(weight)]
        pub unsafe fn weight(&self) -> c_float;

        #[method(labelSmoothing)]
        pub unsafe fn labelSmoothing(&self) -> c_float;

        #[method(numberOfClasses)]
        pub unsafe fn numberOfClasses(&self) -> NSUInteger;

        #[method(epsilon)]
        pub unsafe fn epsilon(&self) -> c_float;

        #[method(delta)]
        pub unsafe fn delta(&self) -> c_float;

        #[method(reduceAcrossBatch)]
        pub unsafe fn reduceAcrossBatch(&self) -> bool;

        #[method_id(@__method_family Init initWithDevice:)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize the loss filter with a loss descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `lossDescriptor`: The loss descriptor.
        ///
        /// Returns: A valid MPSCNNLoss object or nil, if failure.
        #[method_id(@__method_family Init initWithDevice:lossDescriptor:)]
        pub unsafe fn initWithDevice_lossDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            loss_descriptor: &MPSCNNLossDescriptor,
        ) -> Retained<Self>;

        /// <NSSecureCoding
        /// > support
        #[method_id(@__method_family Init initWithCoder:device:)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "MPSImage", feature = "MPSState"))]
        /// Encode a MPSCNNLoss filter and return a gradient in the destinationImage.
        ///
        /// This filter consumes the output of a previous layer, for example, the SoftMax layer containing
        /// predictions, and the MPSCNNLossLabels object containing the target data (labels) and optionally,
        /// weights for the labels. The destinationImage contains the computed gradient for the loss layer.
        /// It serves as a source gradient input image to the first gradient layer (in the backward direction),
        /// in our example, the SoftMax gradient layer.
        ///
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which to encode.
        ///
        /// Parameter `sourceImage`: The source image from the previous filter in the graph (in the inference direction).
        ///
        /// Parameter `labels`: The object containing the target data (labels) and optionally, weights for the labels.
        ///
        /// Parameter `destinationImage`: The MPSImage into which to write the gradient result.
        #[method(encodeToCommandBuffer:sourceImage:labels:destinationImage:)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_labels_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            labels: &MPSCNNLossLabels,
            destination_image: &MPSImage,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSState"))]
        /// Encode a MPSCNNLoss filter and return a gradient.
        ///
        /// This -encode call is similar to the encodeToCommandBuffer:sourceImage:labels:destinationImage: above,
        /// except that it creates and returns the MPSImage with the loss gradient result.
        ///
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which to encode.
        ///
        /// Parameter `sourceImage`: The source image from the previous filter in the graph (in the inference direction).
        ///
        /// Parameter `labels`: The object containing the target data (labels) and optionally, weights for the labels.
        ///
        /// Returns: The MPSImage containing the gradient result.
        #[method_id(@__method_family Other encodeToCommandBuffer:sourceImage:labels:)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_labels(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            labels: &MPSCNNLossLabels,
        ) -> Retained<MPSImage>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        #[method(encodeBatchToCommandBuffer:sourceImages:labels:destinationImages:)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_labels_destinationImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImageBatch,
            labels: &MPSCNNLossLabelsBatch,
            destination_image: &MPSImageBatch,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        #[method_id(@__method_family Other encodeBatchToCommandBuffer:sourceImages:labels:)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_labels(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImageBatch,
            labels: &MPSCNNLossLabelsBatch,
        ) -> Retained<MPSImageBatch>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNLoss {
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[method_id(@__method_family Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNLoss {
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// The MPSCNNYOLOLossDescriptor specifies a loss filter descriptor
    /// that is used to create a MPSCNNLoss filter. The MPSCNNYOLOLoss is a filter that
    /// has been specialized for object detection tasks and follows a specific layout
    /// for the feature-channels of the input, output, weight and label data.
    ///
    /// The layout of the data within the feature-channels is as follows:
    ///
    /// Each anchorbox uses ( 2+2+1 + numberOfClasses = 5 + numberOfClasses ) feature channels.
    ///
    /// Therefore the total number of feature channels used is: (5 + numberOfClasses) * numberOfAnchorBoxes.
    /// The first feature channel for anchorbox index 'anchorIdx' is at fcIndex = (5 + numberOfClasses) * anchorIdx,
    /// and the feature channels within each anchorbox are stored in the layout: 'XYWHCFFFFFF...', where (XY) are
    /// the so-called raw x and y coordinates of the bounding box within each gridcell and (WH) are the corresponding
    /// width and height. 'C' signifies a confidence for having an object in the cell and FFFFF... are the feature channel
    /// values for each class of object to be classified in the object detector.
    ///
    /// The YOLO-loss filter works by operating mostly independently on each anchorbox:
    /// *   The XY-channels of the inputs are first transformed to relative XY-values by applying the sigmoid-neuron on them,
    /// after which they are passed through the loss function defined by
    /// XYLossDescriptor,which is typically chosen
    /// to be the
    /// MPSCNNLossTypeMeanSquaredErrortype loss function.
    /// *   The WH-channels contain the raw width and height of the bounding box and they are operated with the
    /// loss function defined by
    /// WHLossDescriptor,which is typically of type
    /// MPSCNNLossTypeHuber.*   The C-channel contains the confidence value of having an object in the bounding box and it is operated
    /// by the loss function defined by
    /// confidenceLossDescriptor,which is typically chosen to be
    /// MPSCNNLossTypeSigmoidCrossEntropy.*   The FFFFF... (number of channels is number of classes) channels contains the raw feature channels for
    /// object classes, used to identify which objects are the most probable ones in the bounding box and
    /// these channels are passed through the loss function defined by
    /// classesLossDescriptor,which in
    /// typical cases is of the type
    /// MPSCNNLossTypeSoftMaxCrossEntropy.
    /// For details on how to set up the label values and anchorboxes see https://arxiv.org/abs/1612.08242
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnyololossdescriptor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSCNNYOLOLossDescriptor;
);

unsafe impl NSCopying for MPSCNNYOLOLossDescriptor {}

unsafe impl CopyingHelper for MPSCNNYOLOLossDescriptor {
    type Result = Self;
}

unsafe impl NSObjectProtocol for MPSCNNYOLOLossDescriptor {}

extern_methods!(
    unsafe impl MPSCNNYOLOLossDescriptor {
        /// The type of a loss filter.
        ///
        /// This parameter specifies the type of a loss filter.
        #[method_id(@__method_family Other XYLossDescriptor)]
        pub unsafe fn XYLossDescriptor(&self) -> Retained<MPSCNNLossDescriptor>;

        /// Setter for [`XYLossDescriptor`][Self::XYLossDescriptor].
        #[method(setXYLossDescriptor:)]
        pub unsafe fn setXYLossDescriptor(&self, xy_loss_descriptor: &MPSCNNLossDescriptor);

        /// The type of a loss filter.
        ///
        /// This parameter specifies the type of a loss filter.
        #[method_id(@__method_family Other WHLossDescriptor)]
        pub unsafe fn WHLossDescriptor(&self) -> Retained<MPSCNNLossDescriptor>;

        /// Setter for [`WHLossDescriptor`][Self::WHLossDescriptor].
        #[method(setWHLossDescriptor:)]
        pub unsafe fn setWHLossDescriptor(&self, wh_loss_descriptor: &MPSCNNLossDescriptor);

        /// The type of a loss filter.
        ///
        /// This parameter specifies the type of a loss filter.
        #[method_id(@__method_family Other confidenceLossDescriptor)]
        pub unsafe fn confidenceLossDescriptor(&self) -> Retained<MPSCNNLossDescriptor>;

        /// Setter for [`confidenceLossDescriptor`][Self::confidenceLossDescriptor].
        #[method(setConfidenceLossDescriptor:)]
        pub unsafe fn setConfidenceLossDescriptor(
            &self,
            confidence_loss_descriptor: &MPSCNNLossDescriptor,
        );

        /// The type of a loss filter.
        ///
        /// This parameter specifies the type of a loss filter.
        #[method_id(@__method_family Other classesLossDescriptor)]
        pub unsafe fn classesLossDescriptor(&self) -> Retained<MPSCNNLossDescriptor>;

        /// Setter for [`classesLossDescriptor`][Self::classesLossDescriptor].
        #[method(setClassesLossDescriptor:)]
        pub unsafe fn setClassesLossDescriptor(
            &self,
            classes_loss_descriptor: &MPSCNNLossDescriptor,
        );

        #[cfg(feature = "MPSCNNTypes")]
        /// ReductionType shared accross all losses (so they may generate same sized output)
        #[method(reductionType)]
        pub unsafe fn reductionType(&self) -> MPSCNNReductionType;

        #[cfg(feature = "MPSCNNTypes")]
        /// Setter for [`reductionType`][Self::reductionType].
        #[method(setReductionType:)]
        pub unsafe fn setReductionType(&self, reduction_type: MPSCNNReductionType);

        /// If set to YES then the reduction operation is applied also across the batch-index dimension,
        /// ie. the loss value is summed over images in the batch and the result of the reduction is written
        /// on the first loss image in the batch while the other loss images will be set to zero.
        /// If set to NO, then no reductions are performed across the batch dimension and each image in the batch
        /// will contain the loss value associated with that one particular image.
        /// NOTE: If reductionType == MPSCNNReductionTypeNone, then this flag has no effect on results,
        /// that is no reductions are done in this case.
        /// NOTE: If reduceAcrossBatch is set to YES and reductionType == MPSCNNReductionTypeMean then
        /// the final forward loss value is computed by first summing over the components and then by
        /// dividing the result with: number of feature channels * width * height * number of images in the batch.
        /// The default value is NO.
        #[method(reduceAcrossBatch)]
        pub unsafe fn reduceAcrossBatch(&self) -> bool;

        /// Setter for [`reduceAcrossBatch`][Self::reduceAcrossBatch].
        #[method(setReduceAcrossBatch:)]
        pub unsafe fn setReduceAcrossBatch(&self, reduce_across_batch: bool);

        /// Rescore pertains to multiplying the confidence groundTruth with IOU (intersection over union)
        /// of predicted bounding box and the groundTruth boundingBox. Default is YES
        #[method(rescore)]
        pub unsafe fn rescore(&self) -> bool;

        /// Setter for [`rescore`][Self::rescore].
        #[method(setRescore:)]
        pub unsafe fn setRescore(&self, rescore: bool);

        /// scale factor for XY loss and loss gradient default is 10.0
        #[method(scaleXY)]
        pub unsafe fn scaleXY(&self) -> c_float;

        /// Setter for [`scaleXY`][Self::scaleXY].
        #[method(setScaleXY:)]
        pub unsafe fn setScaleXY(&self, scale_xy: c_float);

        /// scale factor for WH loss and loss gradient default is 10.0
        #[method(scaleWH)]
        pub unsafe fn scaleWH(&self) -> c_float;

        /// Setter for [`scaleWH`][Self::scaleWH].
        #[method(setScaleWH:)]
        pub unsafe fn setScaleWH(&self, scale_wh: c_float);

        /// scale factor for no object confidence loss and loss gradient default is 5.0
        #[method(scaleNoObject)]
        pub unsafe fn scaleNoObject(&self) -> c_float;

        /// Setter for [`scaleNoObject`][Self::scaleNoObject].
        #[method(setScaleNoObject:)]
        pub unsafe fn setScaleNoObject(&self, scale_no_object: c_float);

        /// scale factor for no object confidence loss and loss gradient default is 100.0
        #[method(scaleObject)]
        pub unsafe fn scaleObject(&self) -> c_float;

        /// Setter for [`scaleObject`][Self::scaleObject].
        #[method(setScaleObject:)]
        pub unsafe fn setScaleObject(&self, scale_object: c_float);

        /// scale factor for no object classes loss and loss gradient default is 2.0
        #[method(scaleClass)]
        pub unsafe fn scaleClass(&self) -> c_float;

        /// Setter for [`scaleClass`][Self::scaleClass].
        #[method(setScaleClass:)]
        pub unsafe fn setScaleClass(&self, scale_class: c_float);

        /// If the prediction IOU with groundTruth is higher than this
        /// value we consider it a confident object presence, default is 0.7
        #[method(minIOUForObjectPresence)]
        pub unsafe fn minIOUForObjectPresence(&self) -> c_float;

        /// Setter for [`minIOUForObjectPresence`][Self::minIOUForObjectPresence].
        #[method(setMinIOUForObjectPresence:)]
        pub unsafe fn setMinIOUForObjectPresence(&self, min_iou_for_object_presence: c_float);

        /// If the prediction IOU with groundTruth is lower than this
        /// value we consider it a confident object absence, default is 0.3
        #[method(maxIOUForObjectAbsence)]
        pub unsafe fn maxIOUForObjectAbsence(&self) -> c_float;

        /// Setter for [`maxIOUForObjectAbsence`][Self::maxIOUForObjectAbsence].
        #[method(setMaxIOUForObjectAbsence:)]
        pub unsafe fn setMaxIOUForObjectAbsence(&self, max_iou_for_object_absence: c_float);

        /// number of anchor boxes used to detect object per grid cell
        #[method(numberOfAnchorBoxes)]
        pub unsafe fn numberOfAnchorBoxes(&self) -> NSUInteger;

        /// Setter for [`numberOfAnchorBoxes`][Self::numberOfAnchorBoxes].
        #[method(setNumberOfAnchorBoxes:)]
        pub unsafe fn setNumberOfAnchorBoxes(&self, number_of_anchor_boxes: NSUInteger);

        /// NSData containing the width and height for numberOfAnchorBoxes anchor boxes
        /// This NSData should have 2 float values per anchor box which represent the width
        /// and height of the anchor box.
        ///
        /// ```text
        ///               typedef struct anchorBox{
        ///                   float width;
        ///                   float height;
        ///               }anchorBox;
        ///
        ///
        ///               anchorBox_t gAnchorBoxes[MAX_NUM_ANCHOR_BOXES] = {
        ///                   {.width = 1.f, .height = 2.f},
        ///                   {.width = 1.f, .height = 1.f},
        ///                   {.width = 2.f, .height = 1.f},
        ///               };
        ///               NSData* labelsInputData = [NSData dataWithBytes: gAnchorBoxes length: MAX_NUM_ANCHOR_BOXES * sizeof(anchorBox)];
        /// ```
        #[method_id(@__method_family Other anchorBoxes)]
        pub unsafe fn anchorBoxes(&self) -> Retained<NSData>;

        /// Setter for [`anchorBoxes`][Self::anchorBoxes].
        #[method(setAnchorBoxes:)]
        pub unsafe fn setAnchorBoxes(&self, anchor_boxes: &NSData);

        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "MPSCNNTypes")]
        /// Make a descriptor for a MPSCNNYOLOLoss object.
        ///
        /// Parameter `XYLossType`: The type of spatial position loss filter.
        ///
        /// Parameter `WHLossType`: The type of spatial size loss filter.
        ///
        /// Parameter `confidenceLossType`: The type of confidence filter.
        ///
        /// Parameter `classesLossType`: The type of classes filter.
        ///
        /// Parameter `reductionType`: The type of a reduction operation to apply.
        ///
        /// Parameter `anchorBoxes`: This is an NSData which has an array of anchorBoxes defined as a struct{ float width; float height; };
        ///
        /// Returns: A valid MPSCNNYOLOLossDescriptor object or nil, if failure.
        #[method_id(@__method_family Other cnnLossDescriptorWithXYLossType:WHLossType:confidenceLossType:classesLossType:reductionType:anchorBoxes:numberOfAnchorBoxes:)]
        pub unsafe fn cnnLossDescriptorWithXYLossType_WHLossType_confidenceLossType_classesLossType_reductionType_anchorBoxes_numberOfAnchorBoxes(
            xy_loss_type: MPSCNNLossType,
            wh_loss_type: MPSCNNLossType,
            confidence_loss_type: MPSCNNLossType,
            classes_loss_type: MPSCNNLossType,
            reduction_type: MPSCNNReductionType,
            anchor_boxes: &NSData,
            number_of_anchor_boxes: NSUInteger,
        ) -> Retained<MPSCNNYOLOLossDescriptor>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MPSCNNYOLOLossDescriptor {
        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnyololoss?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNYOLOLoss;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNYOLOLoss {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNYOLOLoss {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNYOLOLoss {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNYOLOLoss {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNYOLOLoss {}

extern_methods!(
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNYOLOLoss {
        /// loss filter for prediction of bounding box position
        #[method_id(@__method_family Other lossXY)]
        pub unsafe fn lossXY(&self) -> Retained<MPSCNNLoss>;

        /// loss filter for prediction of bounding box size
        #[method_id(@__method_family Other lossWH)]
        pub unsafe fn lossWH(&self) -> Retained<MPSCNNLoss>;

        /// loss filter for prediction of bounding box probability of presence of object
        #[method_id(@__method_family Other lossConfidence)]
        pub unsafe fn lossConfidence(&self) -> Retained<MPSCNNLoss>;

        /// loss filter for prediction of bounding box predicted class of the detected object
        #[method_id(@__method_family Other lossClasses)]
        pub unsafe fn lossClasses(&self) -> Retained<MPSCNNLoss>;

        /// See MPSCNNYOLOLossDescriptor for information about the following properties.
        #[method(scaleXY)]
        pub unsafe fn scaleXY(&self) -> c_float;

        #[method(scaleWH)]
        pub unsafe fn scaleWH(&self) -> c_float;

        #[method(scaleNoObject)]
        pub unsafe fn scaleNoObject(&self) -> c_float;

        #[method(scaleObject)]
        pub unsafe fn scaleObject(&self) -> c_float;

        #[method(scaleClass)]
        pub unsafe fn scaleClass(&self) -> c_float;

        #[method(minIOUForObjectPresence)]
        pub unsafe fn minIOUForObjectPresence(&self) -> c_float;

        #[method(maxIOUForObjectAbsence)]
        pub unsafe fn maxIOUForObjectAbsence(&self) -> c_float;

        #[cfg(feature = "MPSCNNTypes")]
        #[method(reductionType)]
        pub unsafe fn reductionType(&self) -> MPSCNNReductionType;

        #[method(numberOfAnchorBoxes)]
        pub unsafe fn numberOfAnchorBoxes(&self) -> NSUInteger;

        #[method_id(@__method_family Other anchorBoxes)]
        pub unsafe fn anchorBoxes(&self) -> Retained<NSData>;

        #[method(reduceAcrossBatch)]
        pub unsafe fn reduceAcrossBatch(&self) -> bool;

        #[method_id(@__method_family Init initWithDevice:)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize the loss filter with a loss descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `lossDescriptor`: The loss descriptor.
        ///
        /// Returns: A valid MPSCNNLoss object or nil, if failure.
        #[method_id(@__method_family Init initWithDevice:lossDescriptor:)]
        pub unsafe fn initWithDevice_lossDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            loss_descriptor: &MPSCNNYOLOLossDescriptor,
        ) -> Retained<Self>;

        /// <NSSecureCoding
        /// > support
        #[method_id(@__method_family Init initWithCoder:device:)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "MPSImage", feature = "MPSState"))]
        /// Encode a MPSCNNYOLOLoss filter and return a gradient in the destinationImage.
        ///
        /// This filter consumes the output of a previous layer and the MPSCNNLossLabels object containing
        /// the target data (labels) and optionally, weights for the labels.
        /// The destinationImage contains the computed gradient for the loss layer.
        /// It serves as a source gradient input image to the first gradient layer (in the backward direction).
        /// For information on the data-layout see
        /// MPSCNNYOLOLossDescriptor.
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which to encode.
        ///
        /// Parameter `sourceImage`: The source image from the previous filter in the graph (in the inference direction).
        ///
        /// Parameter `labels`: The object containing the target data (labels) and optionally, weights for the labels.
        ///
        /// Parameter `destinationImage`: The MPSImage into which to write the gradient result.
        #[method(encodeToCommandBuffer:sourceImage:labels:destinationImage:)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_labels_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            labels: &MPSCNNLossLabels,
            destination_image: &MPSImage,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSState"))]
        /// Encode a MPSCNNLoss filter and return a gradient.
        ///
        /// This -encode call is similar to the encodeToCommandBuffer:sourceImage:labels:destinationImage: above,
        /// except that it creates and returns the MPSImage with the loss gradient result.
        ///
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which to encode.
        ///
        /// Parameter `sourceImage`: The source image from the previous filter in the graph (in the inference direction).
        ///
        /// Parameter `labels`: The object containing the target data (labels) and optionally, weights for the labels.
        ///
        /// Returns: The MPSImage containing the gradient result.
        #[method_id(@__method_family Other encodeToCommandBuffer:sourceImage:labels:)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_labels(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            labels: &MPSCNNLossLabels,
        ) -> Retained<MPSImage>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        #[method(encodeBatchToCommandBuffer:sourceImages:labels:destinationImages:)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_labels_destinationImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImageBatch,
            labels: &MPSCNNLossLabelsBatch,
            destination_image: &MPSImageBatch,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        #[method_id(@__method_family Other encodeBatchToCommandBuffer:sourceImages:labels:)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_labels(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImageBatch,
            labels: &MPSCNNLossLabelsBatch,
        ) -> Retained<MPSImageBatch>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNYOLOLoss {
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[method_id(@__method_family Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNYOLOLoss {
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// The MPSNNForwardLoss filter specifies a version of the loss filter which separates the forward
    /// computation from the gradient computation. In order to compute gradients for the loss filter
    /// use
    /// MPSNNLossGradientfilter and in order to start the gradient computation of an arbitrary
    /// image use the
    /// MPSNNInitialGradientfilter.
    /// NOTE: This filter does not support non-default offset or cliprects and setting them to other
    /// than default values will result in undefined results.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnnforwardloss?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNNForwardLoss;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSNNForwardLoss {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSNNForwardLoss {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNNForwardLoss {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSNNForwardLoss {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSNNForwardLoss {}

extern_methods!(
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNForwardLoss {
        #[cfg(feature = "MPSCNNTypes")]
        /// See MPSCNNLossDescriptor for information about the following properties.
        #[method(lossType)]
        pub unsafe fn lossType(&self) -> MPSCNNLossType;

        #[cfg(feature = "MPSCNNTypes")]
        #[method(reductionType)]
        pub unsafe fn reductionType(&self) -> MPSCNNReductionType;

        #[method(reduceAcrossBatch)]
        pub unsafe fn reduceAcrossBatch(&self) -> bool;

        #[method(numberOfClasses)]
        pub unsafe fn numberOfClasses(&self) -> NSUInteger;

        #[method(weight)]
        pub unsafe fn weight(&self) -> c_float;

        /// Setter for [`weight`][Self::weight].
        #[method(setWeight:)]
        pub unsafe fn setWeight(&self, weight: c_float);

        #[method(labelSmoothing)]
        pub unsafe fn labelSmoothing(&self) -> c_float;

        /// Setter for [`labelSmoothing`][Self::labelSmoothing].
        #[method(setLabelSmoothing:)]
        pub unsafe fn setLabelSmoothing(&self, label_smoothing: c_float);

        #[method(epsilon)]
        pub unsafe fn epsilon(&self) -> c_float;

        /// Setter for [`epsilon`][Self::epsilon].
        #[method(setEpsilon:)]
        pub unsafe fn setEpsilon(&self, epsilon: c_float);

        #[method(delta)]
        pub unsafe fn delta(&self) -> c_float;

        /// Setter for [`delta`][Self::delta].
        #[method(setDelta:)]
        pub unsafe fn setDelta(&self, delta: c_float);

        #[method_id(@__method_family Init initWithDevice:)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize the loss forward pass filter with a loss descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `lossDescriptor`: The loss descriptor.
        ///
        /// Returns: A valid MPSNNForwardLoss object or nil, if failure.
        #[method_id(@__method_family Init initWithDevice:lossDescriptor:)]
        pub unsafe fn initWithDevice_lossDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            loss_descriptor: &MPSCNNLossDescriptor,
        ) -> Retained<Self>;

        /// <NSSecureCoding
        /// > support
        #[method_id(@__method_family Init initWithCoder:device:)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        /// Encode a MPSNNForwardLoss filter and return the result in the destinationImage.
        ///
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which to encode.
        ///
        /// Parameter `sourceImages`: The source images that contains the network prediction (logits).
        ///
        /// Parameter `labels`: The source images that contains the labels (targets).
        ///
        /// Parameter `weights`: The object containing weights for the labels. Optional.
        ///
        /// Parameter `destinationStates`: Optional gradient state - carries dynamical property values to the gradient pass
        /// (weight, labelSmoothing, epsilon, delta). Create state using resultStateBatchForSourceImage: or
        /// temporaryResultStateBatchForCommandBuffer:.
        ///
        /// Parameter `destinationImages`: The MPSImages into which to write the loss results.
        #[method(encodeBatchToCommandBuffer:sourceImages:labels:weights:destinationStates:destinationImages:)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_labels_weights_destinationStates_destinationImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
            labels: &MPSImageBatch,
            weights: Option<&MPSImageBatch>,
            destination_states: Option<&MPSStateBatch>,
            destination_images: &MPSImageBatch,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        /// Encode a MPSNNForwardLoss filter and return the loss result image(s).
        ///
        /// This -encode call is similar to the encodeBatchToCommandBuffer:sourceImages:labels:destinationImages: above,
        /// except that it creates and returns the MPSImages with the loss result.
        ///
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which to encode.
        ///
        /// Parameter `sourceImages`: The source images that contains the network prediction (logits).
        ///
        /// Parameter `labels`: The source images that contains the labels (targets).
        ///
        /// Parameter `weights`: The object containing weights for the labels. Optional.
        ///
        /// Parameter `outStates`: Optional gradient state - carries dynamical property values to the gradient pass
        /// (weight, labelSmoothing, epsilon, delta).
        ///
        /// Parameter `isTemporary`: Whether the returned state (if any) should be temporary or not.
        ///
        /// Returns: The MPSImages containing the loss computation results.
        #[method_id(@__method_family Other encodeBatchToCommandBuffer:sourceImages:labels:weights:destinationStates:destinationStateIsTemporary:)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_labels_weights_destinationStates_destinationStateIsTemporary(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
            labels: &MPSImageBatch,
            weights: Option<&MPSImageBatch>,
            out_states: Option<&mut Option<Retained<MPSStateBatch>>>,
            is_temporary: bool,
        ) -> Retained<MPSImageBatch>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNForwardLoss {
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[method_id(@__method_family Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNForwardLoss {
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    /// The MPSNNLossGradient filter specifies the gradient filter for
    /// MPSNNForwardLoss.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnnlossgradient?language=objc)
    #[unsafe(super(MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNNLossGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSNNLossGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSNNLossGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNNLossGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSNNLossGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSNNLossGradient {}

extern_methods!(
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNLossGradient {
        #[cfg(feature = "MPSCNNTypes")]
        /// See MPSCNNLossDescriptor for information about the following properties.
        #[method(lossType)]
        pub unsafe fn lossType(&self) -> MPSCNNLossType;

        #[cfg(feature = "MPSCNNTypes")]
        #[method(reductionType)]
        pub unsafe fn reductionType(&self) -> MPSCNNReductionType;

        #[method(reduceAcrossBatch)]
        pub unsafe fn reduceAcrossBatch(&self) -> bool;

        #[method(numberOfClasses)]
        pub unsafe fn numberOfClasses(&self) -> NSUInteger;

        #[method(weight)]
        pub unsafe fn weight(&self) -> c_float;

        /// Setter for [`weight`][Self::weight].
        #[method(setWeight:)]
        pub unsafe fn setWeight(&self, weight: c_float);

        #[method(labelSmoothing)]
        pub unsafe fn labelSmoothing(&self) -> c_float;

        /// Setter for [`labelSmoothing`][Self::labelSmoothing].
        #[method(setLabelSmoothing:)]
        pub unsafe fn setLabelSmoothing(&self, label_smoothing: c_float);

        #[method(epsilon)]
        pub unsafe fn epsilon(&self) -> c_float;

        /// Setter for [`epsilon`][Self::epsilon].
        #[method(setEpsilon:)]
        pub unsafe fn setEpsilon(&self, epsilon: c_float);

        #[method(delta)]
        pub unsafe fn delta(&self) -> c_float;

        /// Setter for [`delta`][Self::delta].
        #[method(setDelta:)]
        pub unsafe fn setDelta(&self, delta: c_float);

        /// The computeLabelGradients property is used to control whether the loss gradient
        /// filter computes gradients for the primary (predictions) or secondary (labels) source image from the forward pass.
        /// Default: NO.
        #[method(computeLabelGradients)]
        pub unsafe fn computeLabelGradients(&self) -> bool;

        /// Setter for [`computeLabelGradients`][Self::computeLabelGradients].
        #[method(setComputeLabelGradients:)]
        pub unsafe fn setComputeLabelGradients(&self, compute_label_gradients: bool);

        #[method_id(@__method_family Init initWithDevice:)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize the loss gradient filter with a loss descriptor.
        ///
        /// Parameter `device`: The device the filter will run on.
        ///
        /// Parameter `lossDescriptor`: The loss descriptor.
        ///
        /// Returns: A valid MPSNNLossGradient object or nil, if failure.
        #[method_id(@__method_family Init initWithDevice:lossDescriptor:)]
        pub unsafe fn initWithDevice_lossDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            loss_descriptor: &MPSCNNLossDescriptor,
        ) -> Retained<Self>;

        /// <NSSecureCoding
        /// > support
        #[method_id(@__method_family Init initWithCoder:device:)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        /// Encode the loss gradient filter and return a gradient
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which to encode
        ///
        /// Parameter `sourceGradients`: The gradient images from the "next" filter in the graph
        ///
        /// Parameter `sourceImages`: The images used as source image from the forward pass
        ///
        /// Parameter `labels`: The source images that contains the labels (targets).
        ///
        /// Parameter `weights`: The object containing weights for the labels. Optional.
        ///
        /// Parameter `sourceStates`: Optional gradient state - carries dynamical property values from the forward pass
        /// (weight, labelSmoothing, epsilon, delta).
        #[method_id(@__method_family Other encodeBatchToCommandBuffer:sourceGradients:sourceImages:labels:weights:sourceStates:)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceGradients_sourceImages_labels_weights_sourceStates(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradients: &MPSImageBatch,
            source_images: &MPSImageBatch,
            labels: &MPSImageBatch,
            weights: Option<&MPSImageBatch>,
            source_states: Option<&MPSStateBatch>,
        ) -> Retained<MPSImageBatch>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        /// Encode the loss gradient filter and return a gradient
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which to encode
        ///
        /// Parameter `sourceGradients`: The gradient images from the "next" filter in the graph
        ///
        /// Parameter `sourceImages`: The image used as source images from the forward pass
        ///
        /// Parameter `labels`: The source images that contains the labels (targets).
        ///
        /// Parameter `weights`: The object containing weights for the labels. Optional.
        ///
        /// Parameter `sourceStates`: Optional gradient state - carries dynamical property values from the forward pass
        /// (weight, labelSmoothing, epsilon, delta).
        ///
        /// Parameter `destinationGradients`: The MPSImages into which to write the filter result
        #[method(encodeBatchToCommandBuffer:sourceGradients:sourceImages:labels:weights:sourceStates:destinationGradients:)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceGradients_sourceImages_labels_weights_sourceStates_destinationGradients(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradients: &MPSImageBatch,
            source_images: &MPSImageBatch,
            labels: &MPSImageBatch,
            weights: Option<&MPSImageBatch>,
            source_states: Option<&MPSStateBatch>,
            destination_gradients: &MPSImageBatch,
        );
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNLossGradient {
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[method_id(@__method_family Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNLossGradient {
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// The MPSCNNInitialGradient filter specifies a layer which computes the initial gradient for
    /// an aribitrary input image. The operation itself is extremely simple: it computes the gradient of the input image
    /// with itself, resulting in an output image which is filled with '1's for all the inputs that were used.
    /// This serves as the starting point for the computation of gradients between arbitrary images in a network.
    /// Example:
    /// Suppose that we want to compute gradients for a function that multiplies together two losses:
    /// f = f(L1, L2) = L1 * L2
    /// The losses themselves are computed from some inputs x1,x2:
    /// L1 = L1(x1),
    /// L2 = L2(x2)
    /// The filters to compute f, L1, L2 are:
    /// f = MPSCNNMultiply(L1, L2), where
    /// L1 = MPSNNForwardLoss1(x1) and
    /// L2 = MPSNNForwardLoss1(x2)
    ///
    /// To compute df/dx1 we apply the chain rule:
    ///
    /// df/dx1 = d(L1 * L2)/dx1 = d(L1 * L2)/dL1 * dL1/dx1 + d(L1 * L2)/dL2 * dL2/dx1
    /// = d(L1 * L2)/dL1 * dL1/dx1 = L2 * dL1/dx1
    ///
    /// The MPSCNNMultiplyGradient filter computes for f = L1 * L2 forward op:
    /// dL/dL1 = dL/df * df/dL1 = dL/df * L2 and
    /// dL/dL2 = dL/df * df/dL2 = dL/df * L1 where
    /// dL/df is the input gradient of the chain rule / backpropagation algorithm.
    /// But in our case we want MPSCNNMultiplyGradient to compute the gradient:
    /// df/dL1 = d(L1 * L2)/dL1 = L2,
    /// which shows that
    /// L = f, which means that dL/dL1 = df/df * df/dL1 = 1 * L2, which
    /// shows that we get the correct gradient by providing unit input as input gradient to
    /// the MPSCNNMultiplyGradient.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsnninitialgradient?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNNInitialGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSNNInitialGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSNNInitialGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNNInitialGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSNNInitialGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSNNInitialGradient {}

extern_methods!(
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNInitialGradient {
        /// Initializes a MPSNNInitialGradient kernel.
        ///
        ///
        /// Parameter `device`: The MTLDevice on which this MPSNNInitialGradient filter will be used.
        ///
        /// Returns: A valid MPSNNInitialGradient object or nil, if failure.
        #[method_id(@__method_family Init initWithDevice:)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSCNNKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNInitialGradient {
        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        #[method_id(@__method_family Init initWithCoder:device:)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNInitialGradient {
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[method_id(@__method_family Init initWithCoder:)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSNNInitialGradient {
        #[method_id(@__method_family Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__method_family New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
