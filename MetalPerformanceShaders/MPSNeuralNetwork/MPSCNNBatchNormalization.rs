//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// MPSCNNBatchNormalizationState encapsulates the data necessary
    /// to execute batch normalization.
    ///
    /// MPSCNNBatchNormalizationState cannot initialize the size of its own
    /// underlying resources.  Use [MPSCNNBatchNormalizationStatistics resultStateForSourceImages:]
    /// or [MPSCNNBatchNormalizationStatistics temporaryResultStateForCommandBuffer:sourceImages:].
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnbatchnormalizationstate?language=objc)
    #[unsafe(super(MPSNNGradientState, MPSState, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(
        feature = "MPSCore",
        feature = "MPSNNGradientState",
        feature = "MPSState"
    ))]
    pub struct MPSCNNBatchNormalizationState;
);

#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
unsafe impl NSObjectProtocol for MPSCNNBatchNormalizationState {}

extern_methods!(
    #[cfg(all(
        feature = "MPSCore",
        feature = "MPSNNGradientState",
        feature = "MPSState"
    ))]
    unsafe impl MPSCNNBatchNormalizationState {
        #[cfg(all(feature = "MPSCNNKernel", feature = "MPSKernel"))]
        #[unsafe(method(batchNormalization))]
        #[unsafe(method_family = none)]
        pub unsafe fn batchNormalization(&self) -> Retained<MPSCNNBatchNormalization>;

        /// Unavailable.  Use MPSCNNBatchNormalizationStatistics methods to initialize the state object.
        #[unsafe(method(initWithResource:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithResource(
            this: Allocated<Self>,
            resource: Option<&ProtocolObject<dyn MTLResource>>,
        ) -> Retained<Self>;

        /// Unavailable.  Use MPSCNNBatchNormalizationStatistics methods to create the temporary state object.
        #[unsafe(method(temporaryStateWithCommandBuffer:bufferSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_bufferSize(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            buffer_size: usize,
        ) -> Retained<Self>;

        #[unsafe(method(temporaryStateWithCommandBuffer:textureDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_textureDescriptor(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        /// Reset any accumulated state data to its initial values.
        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub unsafe fn reset(&self);

        /// Return an MTLBuffer object with the state's current gamma values.
        #[unsafe(method(gamma))]
        #[unsafe(method_family = none)]
        pub unsafe fn gamma(&self) -> Option<Retained<ProtocolObject<dyn MTLBuffer>>>;

        /// Return an MTLBuffer object with the state's current beta values..
        #[unsafe(method(beta))]
        #[unsafe(method_family = none)]
        pub unsafe fn beta(&self) -> Option<Retained<ProtocolObject<dyn MTLBuffer>>>;

        /// Return an MTLBuffer object with the most recently computed batch mean values.
        #[unsafe(method(mean))]
        #[unsafe(method_family = none)]
        pub unsafe fn mean(&self) -> Option<Retained<ProtocolObject<dyn MTLBuffer>>>;

        /// Return an MTLBuffer object with the most recently computed batch variance values.
        #[unsafe(method(variance))]
        #[unsafe(method_family = none)]
        pub unsafe fn variance(&self) -> Option<Retained<ProtocolObject<dyn MTLBuffer>>>;

        /// Return an MTLBuffer object containing the values of the gradient of the loss function
        /// with respect to the scale factors.  If a MPSCNNBatchNormalizationGradient kernel
        /// has not successfully generated these values nil will be returned.
        #[unsafe(method(gradientForGamma))]
        #[unsafe(method_family = none)]
        pub unsafe fn gradientForGamma(&self) -> Option<Retained<ProtocolObject<dyn MTLBuffer>>>;

        /// Return an MTLBuffer object containing the values of the gradient of the loss function
        /// with respect to the bias terms.  If a MPSCNNBatchNormalizationGradient kernel
        /// has not successfully generated these values nil will be returned.
        #[unsafe(method(gradientForBeta))]
        #[unsafe(method_family = none)]
        pub unsafe fn gradientForBeta(&self) -> Option<Retained<ProtocolObject<dyn MTLBuffer>>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSState`
    #[cfg(all(
        feature = "MPSCore",
        feature = "MPSNNGradientState",
        feature = "MPSState"
    ))]
    unsafe impl MPSCNNBatchNormalizationState {
        /// Create a new autoreleased temporary state object without underlying resource
        ///
        /// Parameter `cmdBuf`: The command buffer with which the temporary resource is associated
        #[unsafe(method(temporaryStateWithCommandBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:bufferSize:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_bufferSize(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            buffer_size: usize,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:textureDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_textureDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Option<Retained<Self>>;

        /// Initialize a non-temporary state to hold a number of textures and buffers
        ///
        /// The allocation of each resource will be deferred  until it is needed.
        /// This occurs when -resource or -resourceAtIndex: is called.
        ///
        /// Parameter `resourceList`: The list of resources to create.
        #[unsafe(method(initWithDevice:resourceList:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_resourceList(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Initialize a temporary state to hold a number of textures and buffers
        ///
        /// The textures occur first in sequence
        #[unsafe(method(temporaryStateWithCommandBuffer:resourceList:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_resourceList(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Create a state object with a list of MTLResources
        ///
        /// Because MPS prefers deferred allocation of resources
        /// your application should use -initWithTextures:bufferSizes:bufferCount:
        /// whenever possible. This method is useful for cases when the
        /// MTLResources must be initialized by the CPU.
        #[unsafe(method(initWithResources:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithResources(
            this: Allocated<Self>,
            resources: Option<&NSArray<ProtocolObject<dyn MTLResource>>>,
        ) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(
        feature = "MPSCore",
        feature = "MPSNNGradientState",
        feature = "MPSState"
    ))]
    unsafe impl MPSCNNBatchNormalizationState {
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// A state which contains mean and variance terms used to apply a
    /// normalization in a MPSCNNBatchNormalization operation.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnnormalizationmeanandvariancestate?language=objc)
    #[unsafe(super(MPSState, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSState"))]
    pub struct MPSCNNNormalizationMeanAndVarianceState;
);

#[cfg(all(feature = "MPSCore", feature = "MPSState"))]
unsafe impl NSObjectProtocol for MPSCNNNormalizationMeanAndVarianceState {}

extern_methods!(
    #[cfg(all(feature = "MPSCore", feature = "MPSState"))]
    unsafe impl MPSCNNNormalizationMeanAndVarianceState {
        /// A MTLBuffer containing the mean terms.
        #[unsafe(method(mean))]
        #[unsafe(method_family = none)]
        pub unsafe fn mean(&self) -> Retained<ProtocolObject<dyn MTLBuffer>>;

        /// A MTLBuffer containing the variance terms.
        #[unsafe(method(variance))]
        #[unsafe(method_family = none)]
        pub unsafe fn variance(&self) -> Retained<ProtocolObject<dyn MTLBuffer>>;

        /// Initialize a MPSCNNNormalizationMeanAndVarianceState object using values
        /// contained in MTLBuffers.
        ///
        ///
        /// Parameter `mean`: The MTLBuffer containing mean terms.
        ///
        ///
        /// Parameter `variance`: The MTLBuffer containing variance terms.
        #[unsafe(method(initWithMean:variance:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMean_variance(
            this: Allocated<Self>,
            mean: &ProtocolObject<dyn MTLBuffer>,
            variance: &ProtocolObject<dyn MTLBuffer>,
        ) -> Retained<Self>;

        /// Create a temporary MPSCNNNormalizationMeanAndVarianceState suitable
        /// for a normalization operation on images containing no more than
        /// the specified number of feature channels.
        ///
        ///
        /// Parameter `commandBuffer`: The command buffer on which the temporary state will
        /// be used.
        ///
        ///
        /// Parameter `numberOfFeatureChannels`: The number of feature channels used to size the
        /// state.
        #[unsafe(method(temporaryStateWithCommandBuffer:numberOfFeatureChannels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_numberOfFeatureChannels(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            number_of_feature_channels: NSUInteger,
        ) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSState`
    #[cfg(all(feature = "MPSCore", feature = "MPSState"))]
    unsafe impl MPSCNNNormalizationMeanAndVarianceState {
        /// Create a MPSState holding a temporary MTLBuffer
        ///
        /// Parameter `cmdBuf`: The command buffer against which the temporary resource is allocated
        ///
        /// Parameter `bufferSize`: The size of the buffer in bytes
        #[unsafe(method(temporaryStateWithCommandBuffer:bufferSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_bufferSize(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            buffer_size: usize,
        ) -> Retained<Self>;

        /// Create a MPSState holding a temporary MTLTexture
        ///
        /// Parameter `cmdBuf`: The command buffer against which the temporary resource is allocated
        ///
        /// Parameter `descriptor`: A descriptor for the new temporary texture
        #[unsafe(method(temporaryStateWithCommandBuffer:textureDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_textureDescriptor(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        /// Create a new autoreleased temporary state object without underlying resource
        ///
        /// Parameter `cmdBuf`: The command buffer with which the temporary resource is associated
        #[unsafe(method(temporaryStateWithCommandBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:bufferSize:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_bufferSize(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            buffer_size: usize,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:textureDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_textureDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        /// Create a MPSState with a non-temporary MTLResource
        ///
        /// Parameter `resource`: A MTLBuffer or MTLTexture. May be nil.
        #[unsafe(method(initWithResource:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithResource(
            this: Allocated<Self>,
            resource: Option<&ProtocolObject<dyn MTLResource>>,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Option<Retained<Self>>;

        /// Initialize a non-temporary state to hold a number of textures and buffers
        ///
        /// The allocation of each resource will be deferred  until it is needed.
        /// This occurs when -resource or -resourceAtIndex: is called.
        ///
        /// Parameter `resourceList`: The list of resources to create.
        #[unsafe(method(initWithDevice:resourceList:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_resourceList(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Initialize a temporary state to hold a number of textures and buffers
        ///
        /// The textures occur first in sequence
        #[unsafe(method(temporaryStateWithCommandBuffer:resourceList:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_resourceList(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Create a state object with a list of MTLResources
        ///
        /// Because MPS prefers deferred allocation of resources
        /// your application should use -initWithTextures:bufferSizes:bufferCount:
        /// whenever possible. This method is useful for cases when the
        /// MTLResources must be initialized by the CPU.
        #[unsafe(method(initWithResources:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithResources(
            this: Allocated<Self>,
            resources: Option<&NSArray<ProtocolObject<dyn MTLResource>>>,
        ) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCore", feature = "MPSState"))]
    unsafe impl MPSCNNNormalizationMeanAndVarianceState {
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_protocol!(
    /// The MPSCNNBatchNormalizationDataSource protocol declares the methods that an
    /// instance of MPSCNNBatchNormalizationState uses to initialize the
    /// scale factors, bias terms, and batch statistics.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnbatchnormalizationdatasource?language=objc)
    pub unsafe trait MPSCNNBatchNormalizationDataSource:
        NSObjectProtocol + NSCopying
    {
        /// Returns the number of feature channels within images to be normalized
        /// using the supplied parameters.
        #[unsafe(method(numberOfFeatureChannels))]
        #[unsafe(method_family = none)]
        unsafe fn numberOfFeatureChannels(&self) -> NSUInteger;

        /// Returns a pointer to the scale factors for the batch normalization.
        #[unsafe(method(gamma))]
        #[unsafe(method_family = none)]
        unsafe fn gamma(&self) -> *mut c_float;

        /// Returns a pointer to the bias terms for the batch normalization.
        /// If NULL then no bias is to be applied.
        #[unsafe(method(beta))]
        #[unsafe(method_family = none)]
        unsafe fn beta(&self) -> *mut c_float;

        /// Returns a pointer to batch mean values with which to initialize
        /// the state for a subsequent batch normalization.
        #[unsafe(method(mean))]
        #[unsafe(method_family = none)]
        unsafe fn mean(&self) -> *mut c_float;

        /// Returns a pointer to batch variance values with which to initialize
        /// the state for a subsequent batch normalization.
        #[unsafe(method(variance))]
        #[unsafe(method_family = none)]
        unsafe fn variance(&self) -> *mut c_float;

        /// Alerts the data source that the data will be needed soon
        ///
        /// Each load alert will be balanced by a purge later, when MPS
        /// no longer needs the data from this object.
        /// Load will always be called atleast once after initial construction
        /// or each purge of the object before anything else is called.
        ///
        /// Returns: Returns YES on success.  If NO is returned, expect MPS
        /// object construction to fail.
        #[unsafe(method(load))]
        #[unsafe(method_family = none)]
        unsafe fn load(&self) -> bool;

        /// Alerts the data source that the data is no longer needed
        ///
        /// Each load alert will be balanced by a purge later, when MPS
        /// no longer needs the data from this object.
        #[unsafe(method(purge))]
        #[unsafe(method_family = none)]
        unsafe fn purge(&self);

        /// A label that is transferred to the batch normalization filter at init time
        ///
        /// Overridden by a MPSCNNBatchNormalizationNode.label if it is non-nil.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        unsafe fn label(&self) -> Option<Retained<NSString>>;

        #[cfg(all(
            feature = "MPSCNNNormalizationWeights",
            feature = "MPSCore",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Compute new gamma and beta values using current values and gradients contained within a
        /// MPSCNNBatchNormalizationState.  Perform the update using a GPU.
        ///
        /// This operation is expected to also decrement the read count of batchNormalizationState by 1.
        ///
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the update.
        ///
        ///
        /// Parameter `batchNormalizationState`: The MPSCNNBatchNormalizationState object containing the current gamma and
        /// beta values and the gradient values.
        ///
        ///
        /// Returns: A MPSCNNNormalizationMeanAndVarianceState object containing updated mean and variance values.  If NULL, the MPSNNGraph
        /// batch normalization filter gamma and beta values will remain unmodified.
        #[optional]
        #[unsafe(method(updateGammaAndBetaWithCommandBuffer:batchNormalizationState:))]
        #[unsafe(method_family = none)]
        unsafe fn updateGammaAndBetaWithCommandBuffer_batchNormalizationState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
        ) -> Option<Retained<MPSCNNNormalizationGammaAndBetaState>>;

        #[cfg(all(
            feature = "MPSCore",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Compute new mean and variance values using current batch statistics contained within a
        /// MPSCNNBatchNormalizationState.  Perform the update using a GPU.
        ///
        /// This operation is expected to also decrement the read count of batchNormalizationState by 1.
        ///
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the update.
        ///
        ///
        /// Parameter `batchNormalizationState`: The MPSCNNBatchNormalizationState object containing the current batch statistics.
        ///
        ///
        /// Returns: A MPSCNNNormalizationMeanAndVarianceState object containing updated mean and variance values.  If NULL, the MPSNNGraph
        /// batch normalization filter mean and variance values will remain unmodified.
        #[optional]
        #[unsafe(method(updateMeanAndVarianceWithCommandBuffer:batchNormalizationState:))]
        #[unsafe(method_family = none)]
        unsafe fn updateMeanAndVarianceWithCommandBuffer_batchNormalizationState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
        ) -> Option<Retained<MPSCNNNormalizationMeanAndVarianceState>>;

        #[cfg(all(
            feature = "MPSCore",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Compute new gamma and beta values using current values and gradients contained within a
        /// MPSCNNBatchNormalizationState.  Perform the update using the CPU.
        ///
        ///
        /// Parameter `batchNormalizationState`: The MPSCNNBatchNormalizationState object containing the current gamma and
        /// beta values and the gradient values.
        ///
        ///
        /// Returns: A boolean value indicating if the update was performed.
        #[optional]
        #[unsafe(method(updateGammaAndBetaWithBatchNormalizationState:))]
        #[unsafe(method_family = none)]
        unsafe fn updateGammaAndBetaWithBatchNormalizationState(
            &self,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
        ) -> bool;

        #[cfg(all(
            feature = "MPSCore",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Compute new mean and variance values using current batch statistics contained within a
        /// MPSCNNBatchNormalizationState.  Perform the update using the CPU.
        ///
        ///
        /// Parameter `batchNormalizationState`: The MPSCNNBatchNormalizationState object containing the current batch statistics.
        ///
        ///
        /// Returns: A boolean value indicating if the update was performed.
        #[optional]
        #[unsafe(method(updateMeanAndVarianceWithBatchNormalizationState:))]
        #[unsafe(method_family = none)]
        unsafe fn updateMeanAndVarianceWithBatchNormalizationState(
            &self,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
        ) -> bool;

        /// An optional tiny number to use to maintain numerical stability.
        ///
        /// output_image = (input_image - mean[c]) * gamma[c] / sqrt(variance[c] + epsilon) + beta[c];
        /// Defalt value if method unavailable: FLT_MIN
        #[optional]
        #[unsafe(method(epsilon))]
        #[unsafe(method_family = none)]
        unsafe fn epsilon(&self) -> c_float;

        /// NSSecureCoding compatibility.
        #[optional]
        #[unsafe(method(encodeWithCoder:))]
        #[unsafe(method_family = none)]
        unsafe fn encodeWithCoder(&self, a_coder: &NSCoder);

        /// NSSecureCoding compatibility.
        #[optional]
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;

        /// NSSecureCoding compatibility.
        #[optional]
        #[unsafe(method(supportsSecureCoding))]
        #[unsafe(method_family = none)]
        unsafe fn supportsSecureCoding() -> bool;

        /// Optional copy method to create a copy of the data source for use with a new device.
        ///
        ///
        /// Parameter `zone`: The NSZone on which to allocate.
        ///
        /// Parameter `device`: The device where the kernel which uses this data source will be used.
        ///
        ///
        /// Returns: A pointer to a copy of this data source.
        #[optional]
        #[unsafe(method(copyWithZone:device:))]
        #[unsafe(method_family = copy)]
        unsafe fn copyWithZone_device(
            &self,
            zone: *mut NSZone,
            device: Option<&ProtocolObject<dyn MTLDevice>>,
        ) -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// MPSCNNBatchNormalization normalizes input images using per-channel
    /// means and variances.
    ///
    /// for (c = 0; c
    /// <
    /// numberOfFeatureChannels; ++c)
    /// {
    /// input_image = in(:,:,c,:);
    /// output_image = (input_image - mean[c]) * gamma[c] / sqrt(variance[c] + epsilon) + beta[c];
    /// out(:,:,c,:) = output_image;
    /// }
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnbatchnormalization?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNBatchNormalization;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNBatchNormalization {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNBatchNormalization {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNBatchNormalization {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNBatchNormalization {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNBatchNormalization {}

extern_methods!(
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalization {
        /// The number of feature channels in an image to be normalized.
        #[unsafe(method(numberOfFeatureChannels))]
        #[unsafe(method_family = none)]
        pub unsafe fn numberOfFeatureChannels(&self) -> NSUInteger;

        /// The epsilon value used in the batch normalization formula to
        /// bias the variance when normalizing.
        #[unsafe(method(epsilon))]
        #[unsafe(method_family = none)]
        pub unsafe fn epsilon(&self) -> c_float;

        /// Setter for [`epsilon`][Self::epsilon].
        #[unsafe(method(setEpsilon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEpsilon(&self, epsilon: c_float);

        /// The data source the batch normalization was initialized with
        #[unsafe(method(dataSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataSource(
            &self,
        ) -> Retained<ProtocolObject<dyn MPSCNNBatchNormalizationDataSource>>;

        /// Initializes a batch normalization kernel using a data source.
        ///
        /// Parameter `device`: The MTLDevice on which this filter will be used
        ///
        /// Parameter `dataSource`: A pointer to a object that conforms to the MPSCNNBatchNormalizationDataSource
        /// protocol.  The data source provides filter weights and bias terms and, optionally,
        /// image statistics which may be used to perform the normalization.
        ///
        ///
        /// Returns: A valid MPSCNNBatchNormalization object or nil, if failure.
        #[unsafe(method(initWithDevice:dataSource:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_dataSource(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            data_source: &ProtocolObject<dyn MPSCNNBatchNormalizationDataSource>,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSCNNNeuron")]
        /// Initializes a batch normalization kernel using a data source and a neuron descriptor.
        ///
        /// Parameter `device`: The MTLDevice on which this filter will be used
        ///
        /// Parameter `dataSource`: A pointer to a object that conforms to the MPSCNNBatchNormalizationDataSource
        /// protocol.  The data source provides filter weights and bias terms and, optionally,
        /// image statistics which may be used to perform the normalization.
        ///
        /// Parameter `fusedNeuronDescriptor`: A MPSNNNeuronDescriptor object which specifies a neuron activation function to
        /// be applied to the result of the batch normalization.
        ///
        ///
        /// Returns: A valid MPSCNNBatchNormalization object or nil, if failure.
        #[unsafe(method(initWithDevice:dataSource:fusedNeuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_dataSource_fusedNeuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            data_source: &ProtocolObject<dyn MPSCNNBatchNormalizationDataSource>,
            fused_neuron_descriptor: Option<&MPSNNNeuronDescriptor>,
        ) -> Retained<Self>;

        /// Use initWithDevice:dataSource instead
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use a subclass of NSCoder that
        /// implements the
        /// <MPSDeviceProvider
        /// > protocol  to
        /// tell MPS the MTLDevice to use.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSCNNBatchNormalization object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode this kernel to a command buffer for a single image using
        /// a batch normalization state.
        ///
        ///
        /// Parameter `commandBuffer`: A valid command buffer to receive the kernel.
        ///
        /// Parameter `sourceImage`: The source MPSImage.
        ///
        /// Parameter `batchNormalizationState`: A MPSCNNBatchNormalizationState containing weights and/or
        /// statistics to use for the batch normalization. If the state
        /// is temporary its read count will be decremented.
        ///
        /// Parameter `destinationImage`: An MPSImage to contain the resulting normalized and scaled
        /// image.
        #[unsafe(method(encodeToCommandBuffer:sourceImage:batchNormalizationState:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_batchNormalizationState_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
            destination_image: &MPSImage,
        );

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNDArray",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode this kernel to a command buffer for a batch of images using
        /// a batch normalization state.
        ///
        ///
        /// Parameter `commandBuffer`: A valid command buffer to receive the kernel.
        ///
        /// Parameter `sourceImages`: The batch of source images.
        ///
        /// Parameter `batchNormalizationState`: A MPSCNNBatchNormalizationState containing weights and/or
        /// statistics to use for the batch normalization. If the state
        /// is temporary its read count will be decremented.
        ///
        /// Parameter `destinationImages`: The batch of images to contain the normalized and scaled
        /// result images.
        #[unsafe(method(encodeBatchToCommandBuffer:sourceImages:batchNormalizationState:destinationImages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_batchNormalizationState_destinationImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
            destination_images: &MPSImageBatch,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSState"))]
        #[unsafe(method(encodeToCommandBuffer:sourceImage:destinationState:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_destinationState_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            destination_state: &MPSState,
            destination_image: &MPSImage,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSState"))]
        #[unsafe(method(encodeToCommandBuffer:sourceImage:destinationState:destinationStateIsTemporary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_destinationState_destinationStateIsTemporary(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            out_state: &mut Option<Retained<MPSState>>,
            is_temporary: bool,
        ) -> Retained<MPSImage>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        #[unsafe(method(encodeBatchToCommandBuffer:sourceImages:destinationStates:destinationImages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_destinationStates_destinationImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
            destination_states: Option<&MPSStateBatch>,
            destination_images: &MPSImageBatch,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        #[unsafe(method(encodeBatchToCommandBuffer:sourceImages:destinationStates:destinationStateIsTemporary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_destinationStates_destinationStateIsTemporary(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
            out_states: &mut Option<Retained<MPSStateBatch>>,
            is_temporary: bool,
        ) -> Retained<MPSImageBatch>;

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Return an MPSCNNBatchNormalizationState object which may be used with a MPSCNNBatchNormalization filter.
        #[unsafe(method(resultStateForSourceImage:sourceStates:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn resultStateForSourceImage_sourceStates_destinationImage(
            &self,
            source_image: &MPSImage,
            source_states: Option<&NSArray<MPSState>>,
            destination_image: &MPSImage,
        ) -> Option<Retained<MPSCNNBatchNormalizationState>>;

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Return a temporary MPSCNNBatchNormalizationState object which may be used with
        /// a MPSCNNBatchNormalization filter.
        #[unsafe(method(temporaryResultStateForCommandBuffer:sourceImage:sourceStates:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryResultStateForCommandBuffer_sourceImage_sourceStates_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            source_states: Option<&NSArray<MPSState>>,
            destination_image: &MPSImage,
        ) -> Option<Retained<MPSCNNBatchNormalizationState>>;

        /// Reinitialize the filter using a data source.
        ///
        ///
        /// Parameter `dataSource`: The data source which will provide the weights and, optionally, the
        /// image batch statistics with which to normalize.
        #[deprecated]
        #[unsafe(method(reloadDataSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn reloadDataSource(
            &self,
            data_source: &ProtocolObject<dyn MPSCNNBatchNormalizationDataSource>,
        );

        /// Reinitialize the filter's gamma and beta values using the data source provided at kernel initialization.
        #[unsafe(method(reloadGammaAndBetaFromDataSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn reloadGammaAndBetaFromDataSource(&self);

        /// Reinitialize the filter's mean and variance values using the data source provided at kernel initialization.
        #[unsafe(method(reloadMeanAndVarianceFromDataSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn reloadMeanAndVarianceFromDataSource(&self);

        #[cfg(all(feature = "MPSCNNNormalizationWeights", feature = "MPSState"))]
        /// Reload data using new gamma and beta terms contained within an
        /// MPSCNNNormalizationGammaAndBetaState object.
        ///
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the reload.
        ///
        ///
        /// Parameter `gammaAndBetaState`: The state containing the updated weights which are to
        /// be reloaded.
        #[unsafe(method(reloadGammaAndBetaWithCommandBuffer:gammaAndBetaState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn reloadGammaAndBetaWithCommandBuffer_gammaAndBetaState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            gamma_and_beta_state: &MPSCNNNormalizationGammaAndBetaState,
        );

        #[cfg(feature = "MPSState")]
        /// Reload data using new mean and variance terms contained within an
        /// MPSCNNNormalizationMeanAndVarianceState object.
        ///
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the reload.
        ///
        ///
        /// Parameter `meanAndVarianceState`: The state containing the updated statistics which are to
        /// be reloaded.
        #[unsafe(method(reloadMeanAndVarianceWithCommandBuffer:meanAndVarianceState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn reloadMeanAndVarianceWithCommandBuffer_meanAndVarianceState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            mean_and_variance_state: &MPSCNNNormalizationMeanAndVarianceState,
        );
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalization {
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalization {
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// MPSCNNBatchNormalizationStatistics updates a MPSCNNBatchNormalizationState
    /// with the batch statistics necessary to perform a batch normalization.
    /// MPSCNNBatchNormalizationStatistics may be executed multiple times with
    /// multiple images to accumulate all the statistics necessary to perform
    /// a batch normalization as described in  https://arxiv.org/pdf/1502.03167v3.pdf.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnbatchnormalizationstatistics?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNBatchNormalizationStatistics;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNBatchNormalizationStatistics {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNBatchNormalizationStatistics {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNBatchNormalizationStatistics {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNBatchNormalizationStatistics {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNBatchNormalizationStatistics {}

extern_methods!(
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationStatistics {
        /// Initialize this kernel on a device.
        ///
        ///
        /// Parameter `device`: The MTLDevice on which to initialize the kernel.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSCNNBatchNormalizationStatistics object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNDArray",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode this operation to a command buffer.
        ///
        /// Parameter `commandBuffer`: The command buffer.
        ///
        /// Parameter `sourceImages`: An MPSImageBatch containing the source images.
        ///
        /// Parameter `batchNormalizationState`: A valid MPSCNNBatchNormalizationState object which
        /// will be updated with the image batch statistics.
        #[unsafe(method(encodeBatchToCommandBuffer:sourceImages:batchNormalizationState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_batchNormalizationState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray"))]
        #[unsafe(method(encodeBatchToCommandBuffer:sourceImages:destinationImages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages_destinationImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
            destination_images: &MPSImageBatch,
        );

        #[cfg(feature = "MPSImage")]
        #[unsafe(method(encodeToCommandBuffer:sourceImage:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceImage_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            destination_image: &MPSImage,
        );

        #[cfg(feature = "MPSImage")]
        #[unsafe(method(encodeToCommandBuffer:sourceImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
        ) -> Retained<MPSImage>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray"))]
        #[unsafe(method(encodeBatchToCommandBuffer:sourceImages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_images: &MPSImageBatch,
        ) -> Retained<MPSImageBatch>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationStatistics {
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationStatistics {
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    ///
    /// MPSCNNBatchNormalizationGradient computes the gradients of a
    /// loss function resulting from a network containing a corresponding
    /// MPSCNNBatchNormalization kernel.
    ///
    /// Two sets of values are computed: the gradient of the loss function
    /// with respect to the batch normalization source images, and the
    /// gradient of the loss function with respect to the scale and bias
    /// terms used to compute the batch normalization.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnbatchnormalizationgradient?language=objc)
    #[unsafe(super(MPSCNNGradientKernel, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNBatchNormalizationGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNBatchNormalizationGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNBatchNormalizationGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNBatchNormalizationGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNBatchNormalizationGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNBatchNormalizationGradient {}

extern_methods!(
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationGradient {
        #[cfg(feature = "MPSCNNNeuron")]
        /// Initializes a batch normalization gradient kernel using a device and neuron descriptor.
        ///
        /// Parameter `device`: The MTLDevice on which this filter will be used
        ///
        /// Parameter `fusedNeuronDescriptor`: A MPSNNNeuronDescriptor object which specifies a neuron activation function whose
        /// gradient should be applied prior to computing the resulting gradient.
        /// This neuron descriptor should match that used in the corresponding forward batch
        /// normalization kernel as well as the preceeding batch normalization statistics gradient
        /// kernel.
        ///
        ///
        /// Returns: A valid MPSCNNBatchNormalizationGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:fusedNeuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_fusedNeuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            fused_neuron_descriptor: Option<&MPSNNNeuronDescriptor>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use a subclass of NSCoder that
        /// implements the
        /// <MPSDeviceProvider
        /// > protocol  to
        /// tell MPS the MTLDevice to use.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSCNNBatchNormalizationGradient object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode this operation to a command buffer for a single image.
        ///
        /// Parameter `commandBuffer`: The command buffer.
        ///
        /// Parameter `sourceGradient`: An MPSImage containing the gradient of the loss function with
        /// respect to the results of batch normalization on the source image.
        ///
        /// Parameter `sourceImage`: An MPSImage containing the source image for batch normalization.
        ///
        /// Parameter `batchNormalizationState`: A valid MPSCNNBatchNormalizationState object which
        /// has been previously updated using a MPSCNNBatchNormalizationStatisticsGradient
        /// kernel and the source images. If the state is temporary its read count will be decremented.
        ///
        /// Parameter `destinationGradient`: An MPSImage which contains the gradient of the loss function with respect to the source image.
        #[unsafe(method(encodeToCommandBuffer:sourceGradient:sourceImage:batchNormalizationState:destinationGradient:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceGradient_sourceImage_batchNormalizationState_destinationGradient(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradient: &MPSImage,
            source_image: &MPSImage,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
            destination_gradient: &MPSImage,
        );

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNDArray",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode this operation to a command buffer.
        ///
        /// Parameter `commandBuffer`: The command buffer.
        ///
        /// Parameter `sourceGradients`: An MPSImageBatch containing the gradient of the
        /// loss function with respect to the results of batch normalization
        /// on the source images.
        ///
        /// Parameter `sourceImages`: An MPSImageBatch containing the source images for
        /// batch normalization.
        ///
        /// Parameter `batchNormalizationState`: A valid MPSCNNBatchNormalizationState object which
        /// has been previously updated using a MPSCNNBatchNormalizationStatisticsGradient
        /// kernel and the source images. If the state is temporary its read count will be decremented.
        ///
        /// Parameter `destinationGradients`: An MPSImageBatch whose images will contain the gradient
        /// of the loss function with respect to the source images.
        #[unsafe(method(encodeBatchToCommandBuffer:sourceGradients:sourceImages:batchNormalizationState:destinationGradients:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceGradients_sourceImages_batchNormalizationState_destinationGradients(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradients: &MPSImageBatch,
            source_images: &MPSImageBatch,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
            destination_gradients: &MPSImageBatch,
        );

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode this operation to a command buffer.  Create an MPSImage to contain
        /// the result and return it.
        /// See encodeToCommandBuffer:sourceImage:sourceGradient:sourceImage:batchNormalizationState:destinationGradient
        /// for further details.
        #[unsafe(method(encodeToCommandBuffer:sourceGradient:sourceImage:batchNormalizationState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceGradient_sourceImage_batchNormalizationState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradient: &MPSImage,
            source_image: &MPSImage,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
        ) -> Retained<MPSImage>;

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNDArray",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode this operation to a command buffer.  Create an MPSImageBatch to contain
        /// the result and return it.
        /// See encodeBatchToCommandBuffer:sourceGradients:sourceImages:batchNormalizationState:destinationGradients
        /// for further details.
        #[unsafe(method(encodeBatchToCommandBuffer:sourceGradients:sourceImages:batchNormalizationState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceGradients_sourceImages_batchNormalizationState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradients: &MPSImageBatch,
            source_images: &MPSImageBatch,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
        ) -> Retained<MPSImageBatch>;

        #[cfg(feature = "MPSImage")]
        #[unsafe(method(encodeToCommandBuffer:primaryImage:secondaryImage:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primaryImage_secondaryImage_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_image: &MPSImage,
            secondary_image: &MPSImage,
            destination_image: &MPSImage,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray"))]
        #[unsafe(method(encodeBatchToCommandBuffer:primaryImages:secondaryImages:destinationImages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_primaryImages_secondaryImages_destinationImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_images: &MPSImageBatch,
            secondary_images: &MPSImageBatch,
            destination_images: &MPSImageBatch,
        );

        #[cfg(feature = "MPSImage")]
        #[unsafe(method(encodeToCommandBuffer:primaryImage:secondaryImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primaryImage_secondaryImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_image: &MPSImage,
            secondary_image: &MPSImage,
        ) -> Retained<MPSImage>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray"))]
        #[unsafe(method(encodeBatchToCommandBuffer:primaryImages:secondaryImages:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_primaryImages_secondaryImages(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_image: &MPSImageBatch,
            secondary_image: &MPSImageBatch,
        ) -> Retained<MPSImageBatch>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSCNNGradientKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationGradient {
        /// Standard init with default properties per filter type
        ///
        /// Parameter `device`: The device that the filter will be used on. May not be NULL.
        ///
        /// Returns: A pointer to the newly initialized object. This will fail, returning
        /// nil if the device is not supported. Devices must be
        /// MTLFeatureSet_iOS_GPUFamily2_v1 or later.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationGradient {
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationGradient {
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// MPSCNNBatchNormalizationStatisticsGradient updates a MPSCNNBatchNormalizationState
    /// with the gradient of the loss function with respect to the batch statistics and
    /// batch normalization weights used to perform a batch normalization.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnbatchnormalizationstatisticsgradient?language=objc)
    #[unsafe(super(MPSCNNGradientKernel, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNBatchNormalizationStatisticsGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCoding for MPSCNNBatchNormalizationStatisticsGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSCopying for MPSCNNBatchNormalizationStatisticsGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNBatchNormalizationStatisticsGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSObjectProtocol for MPSCNNBatchNormalizationStatisticsGradient {}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl NSSecureCoding for MPSCNNBatchNormalizationStatisticsGradient {}

extern_methods!(
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationStatisticsGradient {
        #[cfg(feature = "MPSCNNNeuron")]
        /// Initializes a batch normalization statistics gradient kernel using a device and neuron descriptor.
        ///
        /// Parameter `device`: The MTLDevice on which this filter will be used
        ///
        /// Parameter `fusedNeuronDescriptor`: A MPSNNNeuronDescriptor object which specifies a neuron activation function whose
        /// gradient should be applied prior to computing the statistics of the input gradient.
        /// This neuron descriptor should match that used in the corresponding forward batch
        /// normalization kernel.
        ///
        ///
        /// Returns: A valid MPSCNNBatchNormalizationStatisticsGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:fusedNeuronDescriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_fusedNeuronDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            fused_neuron_descriptor: Option<&MPSNNNeuronDescriptor>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use a subclass of NSCoder that
        /// implements the
        /// <MPSDeviceProvider
        /// > protocol  to
        /// tell MPS the MTLDevice to use.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSCNNBatchNormalizationStatisticsGradient object, or nil if failure.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNDArray",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Encode this operation to a command buffer.
        ///
        /// Parameter `commandBuffer`: The command buffer.
        ///
        /// Parameter `sourceGradients`: An MPSImageBatch containing the gradient of the
        /// loss function with respect to the results of batch normalization
        /// on the source images.
        ///
        /// Parameter `sourceImages`: An MPSImageBatch containing the source images for
        /// batch normalization.
        ///
        /// Parameter `batchNormalizationState`: A valid MPSCNNBatchNormalizationState object which
        /// has been previously updated using a MPSCNNBatchNormalizationStatistics
        /// kernel and the source images.  Upon completion of the
        /// command buffer, will contain the (possibly partially updated)
        /// gradients for the loss function with respect to the scale and
        /// bias parameters used to compute the batch normalization.  The
        /// state will be considered to be completely updated when all
        /// MPSImages in the training batch have been processed.  If the state
        /// is temporary its read count will be decremented.
        #[unsafe(method(encodeBatchToCommandBuffer:sourceGradients:sourceImages:batchNormalizationState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceGradients_sourceImages_batchNormalizationState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradients: &MPSImageBatch,
            source_images: &MPSImageBatch,
            batch_normalization_state: &MPSCNNBatchNormalizationState,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSState"))]
        #[unsafe(method(encodeToCommandBuffer:sourceGradient:sourceImage:gradientState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceGradient_sourceImage_gradientState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradient: &MPSImage,
            source_image: &MPSImage,
            gradient_state: &MPSState,
        ) -> Retained<MPSImage>;

        #[cfg(all(feature = "MPSImage", feature = "MPSState"))]
        #[unsafe(method(encodeToCommandBuffer:sourceGradient:sourceImage:gradientState:destinationGradient:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceGradient_sourceImage_gradientState_destinationGradient(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradient: &MPSImage,
            source_image: &MPSImage,
            gradient_state: &MPSState,
            destination_gradient: &MPSImage,
        );

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        #[unsafe(method(encodeBatchToCommandBuffer:sourceGradients:sourceImages:gradientStates:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceGradients_sourceImages_gradientStates(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradients: &MPSImageBatch,
            source_images: &MPSImageBatch,
            gradient_states: &MPSStateBatch,
        ) -> Retained<MPSImageBatch>;

        #[cfg(all(feature = "MPSImage", feature = "MPSNDArray", feature = "MPSState"))]
        #[unsafe(method(encodeBatchToCommandBuffer:sourceGradients:sourceImages:gradientStates:destinationGradients:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeBatchToCommandBuffer_sourceGradients_sourceImages_gradientStates_destinationGradients(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_gradients: &MPSImageBatch,
            source_images: &MPSImageBatch,
            gradient_states: &MPSStateBatch,
            destination_gradients: &MPSImageBatch,
        );
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSCNNGradientKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationStatisticsGradient {
        /// Standard init with default properties per filter type
        ///
        /// Parameter `device`: The device that the filter will be used on. May not be NULL.
        ///
        /// Returns: A pointer to the newly initialized object. This will fail, returning
        /// nil if the device is not supported. Devices must be
        /// MTLFeatureSet_iOS_GPUFamily2_v1 or later.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    }
);

extern_methods!(
    /// Methods declared on superclass `MPSKernel`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationStatisticsGradient {
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    unsafe impl MPSCNNBatchNormalizationStatisticsGradient {
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);
