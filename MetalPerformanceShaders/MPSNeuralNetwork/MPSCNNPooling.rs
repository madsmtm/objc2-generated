//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Pooling is a form of non-linear sub-sampling. Pooling partitions the input image into a set of
    /// rectangles (overlapping or non-overlapping) and, for each such sub-region, outputs a value.
    /// The pooling operation is used in computer vision to reduce the dimensionality of intermediate representations.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpooling?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPooling;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPooling {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPooling {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPooling {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPooling {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPooling {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPooling {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPooling {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPooling {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the max pooling filter.  For each pixel, returns the maximum value of pixels
    /// in the kernelWidth x kernelHeight filter region.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpoolingmax?language=objc)
    #[unsafe(super(MPSCNNPooling, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingMax;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingMax {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMax {
    extern_methods!(
        /// Initialize a MPSCNNPoolingMax pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPooling`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMax {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMax {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMax {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the average pooling filter.  For each pixel, returns the mean value of pixels
    /// in the kernelWidth x kernelHeight filter region.
    /// When
    /// edgeModeis
    /// MPSImageEdgeModeClampthe filtering window is shrunk to remain
    /// within the source image borders. What this means is that close to image borders the filtering window
    /// will be smaller in order to fit inside the source image and less values will be used to compute the
    /// average. In case the filtering window is entirely outside the source image border the
    /// outputted value will be zero.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpoolingaverage?language=objc)
    #[unsafe(super(MPSCNNPooling, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingAverage;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingAverage {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingAverage {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingAverage {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingAverage {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingAverage {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverage {
    extern_methods!(
        /// How much zero padding to apply to both left and right borders of the input image for average pooling,
        /// when using
        ///
        /// See: edgeMode MPSImageEdgeModeClamp. For
        ///
        /// See: edgeMode MPSImageEdgeModeZero this property is
        /// ignored and the area outside the image is interpreted to contain zeros.
        /// The zero padding size is used to shrink the pooling window to fit inside the area bound by the source image
        /// and its padding region, but the effect is that the normalization factor of the average computation is computed
        /// also for the zeros in the padding region.
        #[unsafe(method(zeroPadSizeX))]
        #[unsafe(method_family = none)]
        pub unsafe fn zeroPadSizeX(&self) -> NSUInteger;

        /// Setter for [`zeroPadSizeX`][Self::zeroPadSizeX].
        #[unsafe(method(setZeroPadSizeX:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setZeroPadSizeX(&self, zero_pad_size_x: NSUInteger);

        /// How much zero padding to apply to both top and bottom borders of the input image for average pooling,
        /// when using
        ///
        /// See: edgeMode MPSImageEdgeModeClamp. For
        ///
        /// See: edgeMode MPSImageEdgeModeZero this property is
        /// ignored and the area outside the image is interpreted to contain zeros.
        /// The zero padding size is used to shrink the pooling window to fit inside the area bound by the source image
        /// and its padding region, but the effect is that the normalization factor of the average computation is computed
        /// also for the zeros in the padding region.
        #[unsafe(method(zeroPadSizeY))]
        #[unsafe(method_family = none)]
        pub unsafe fn zeroPadSizeY(&self) -> NSUInteger;

        /// Setter for [`zeroPadSizeY`][Self::zeroPadSizeY].
        #[unsafe(method(setZeroPadSizeY:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setZeroPadSizeY(&self, zero_pad_size_y: NSUInteger);

        /// Initialize a MPSCNNPoolingAverage pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPooling`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverage {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverage {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverage {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the L2-norm pooling filter.  For each pixel, returns L2-Norm of pixels
    /// in the kernelWidth x kernelHeight filter region.
    /// out[c,x,y] = sqrt ( sum_{dx,dy} in[c,x+dx,y+dy] * in[c,x+dx,y+dy] ).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpoolingl2norm?language=objc)
    #[unsafe(super(MPSCNNPooling, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingL2Norm;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingL2Norm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingL2Norm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingL2Norm {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingL2Norm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingL2Norm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2Norm {
    extern_methods!(
        /// Initialize a MPSCNNPoolingL2Norm pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPooling`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2Norm {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2Norm {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2Norm {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the dilated max pooling filter.  For each pixel, returns the maximum value of pixels
    /// in the kernelWidth x kernelHeight filter region by step size dilationRateX x dilationRateY.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnndilatedpoolingmax?language=objc)
    #[unsafe(super(MPSCNNPooling, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNDilatedPoolingMax;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNDilatedPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNDilatedPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNDilatedPoolingMax {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNDilatedPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNDilatedPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMax {
    extern_methods!(
        /// dilationRateX for accessing the image passed in as source
        #[unsafe(method(dilationRateX))]
        #[unsafe(method_family = none)]
        pub unsafe fn dilationRateX(&self) -> NSUInteger;

        /// dilationRateY for accessing the image passed in as source
        #[unsafe(method(dilationRateY))]
        #[unsafe(method_family = none)]
        pub unsafe fn dilationRateY(&self) -> NSUInteger;

        /// Initialize a MPSCNNDilatedPoolingMax pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `dilationRateX`: The dilation rate in the x dimension.
        ///
        /// Parameter `dilationRateY`: The dilation rate in the y dimension.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNDilatedPoolingMax object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:dilationRateX:dilationRateY:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_dilationRateX_dilationRateY_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            dilation_rate_x: NSUInteger,
            dilation_rate_y: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel.hinitWithCoder.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNDilatedPoolingMax
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNDilatedPoolingMax
        ///
        /// Returns: A new MPSCNNDilatedPoolingMax object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPooling`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMax {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMax {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMax {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the base class for computing the gradient of the pooling filters.
    /// The operation backpropagates a gradient vector using the chain rule.
    ///
    /// Given the input gradient vector dL(x) = dL/d out(x), which is the derivative of the
    /// loss-function wrt. (original) pooling filter output the output gradient at position y
    /// (dL/d in(y)) is computed as follows:
    ///
    /// dL/d in(y) = sum_x (dL/d out(x)) * (d out(x)/d in(y)), where
    ///
    /// the sum runs over the input gradient pixels starting from primaryOffset
    /// extending to primaryOffset + sourceSize. Note here that we need a separate
    /// variable 'sourceSize' to specify which input gradients are included in the output
    /// gradient computation as this information cannot be deduced directly from the cliprect
    /// size due to fractional striding or simply because the user wants to examine a subset
    /// of the contributions to the gradients. In normal operation the sourceSize is specified
    /// as the cliprect.size of the forward pooling filter in order to compute the gradients for
    /// all outputs the forward direction produced and the primaryOffset is set to
    /// cliprect.origin of the original forward pooling operation for the same reason.
    ///
    /// The cliprect property of the filter allows the user to send the gradients to a new location,
    /// which may not match the original forward pooling filter window locations:
    /// The index 'y' in the formula above refers to the pixel location in the secondary source,
    /// which is the source image of the original forward pooling filter and secondaryOffset specifies
    /// the center of the first pooling window as specified in MPSCNNPooling filter specification.
    /// The first (top leftmost) pixel written into the cliprect computes the derivative of the first pixel
    /// within the first pooling window that is contained within the secondary source image and
    /// subsequent values are defined by normal striding rules from secondary source to primary source.
    /// This means that typically the cliprect is set to fill the effective source area of the original forward
    /// operation, clamped to edges of the original source image, which in the normal case is the same size
    /// as the size of the gradient destination image.
    ///
    /// If there are any values in the destination cliprect that do not contribute to the forward
    /// pooling result in the area specified by primaryOffset and sourceSize,
    /// due to large strides or dilation factors or simply because all forward pass induced values would be
    /// outside the source area, then those result values are set to zero.
    ///
    /// The actual value of d out(x) / d in(y) depends on the pooling operation and these are defined in the
    /// subclasses of MPSCNNPoolingGradient.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpoolinggradient?language=objc)
    #[unsafe(super(MPSCNNGradientKernel, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingGradient {
    extern_methods!(
        /// An optional source size which defines together with primaryOffset, the set of input gradient
        /// pixels to take into account in the gradient computations.
        ///
        /// A MTLSize that together with primaryOffset indicates which part of the source gradient to consider.
        /// If the area does not lie completely within the primary source image, the intersection between
        /// source area rectangle and primary source bounds is used.
        /// Default: A size where every component is NSUIntegerMax indicating the entire rest of the image,
        /// starting from an offset (see primaryOffset).
        #[unsafe(method(sourceSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceSize(&self) -> MTLSize;

        /// Setter for [`sourceSize`][Self::sourceSize].
        #[unsafe(method(setSourceSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSourceSize(&self, source_size: MTLSize);

        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The input stride (upsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The input stride (upsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingGradient
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the filter for computing the gradient of the average pooling filter.
    /// The operation backpropagates a gradient vector using chain rule.
    ///
    /// Average pooling forward pass is defined as:
    ///
    /// out(x) = sum_{dx
    /// \in Window(x)} in(s*x+dx) / N(x), where
    ///
    /// the pooling window definition 'Window(x)' follows MPSCNNPooling specification,
    /// 'N(x)' is effective pooling window size in pixels as specified in MPSCNNPoolingAverage,
    /// 's' is the pixel stride and in() is the source input image.
    ///
    /// Hence the partial derivative of the output value wrt. to the input value needed in the
    /// gradient backpropagation in MPSCNNPoolingGradient is:
    ///
    /// d out(x)/d in(y) = sum_{dx
    /// \in Window(x)} delta_{s*x+dx, y} / N(x), where
    ///
    /// delta_{x,y} is the Kronecker delta symbol for which
    ///
    /// delta_{x,y} =  {  1, when x == y
    /// {  0, otherwise.
    ///
    /// In practice this means that the gradient value for the destination image at pixel 'x' is
    /// the sum over these contributions coming from all pooling windows that contribute
    /// to the average pooling computation in the forward pass, multiplied by the input
    /// gradient value in the source area of the corresponding pooling window.
    ///
    /// Note: As average pooling is a linear operation of its inputs, the gradient does not
    /// depend at all on the original input values, but the original input image size is needed
    /// so that we know the limits where the input values seize to exist to inhibit accumulation
    /// of gradient values for those pixels. Therefore, as secondary input, any correctly sized
    /// image will produce correct results for the gradient backpropagation and hence it is
    /// recommended to use a temporary image of correct size (see MPSTemporaryImage) for the
    /// secondary source image parameter.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpoolingaveragegradient?language=objc)
    #[unsafe(super(
        MPSCNNPoolingGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingAverageGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingAverageGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingAverageGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingAverageGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingAverageGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingAverageGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverageGradient {
    extern_methods!(
        /// How much zero padding to apply to both left and right borders of the input image for average pooling,
        /// when using
        ///
        /// See: edgeMode MPSImageEdgeModeClamp. For
        ///
        /// See: edgeMode MPSImageEdgeModeZero this property is
        /// ignored and the area outside the image is interpreted to contain zeros.
        /// The zero padding size is used to shrink the pooling window to fit inside the area bound by the source image
        /// and its padding region, but the effect is that the normalization factor of the average computation is computed
        /// also for the zeros in the padding region.
        #[unsafe(method(zeroPadSizeX))]
        #[unsafe(method_family = none)]
        pub unsafe fn zeroPadSizeX(&self) -> NSUInteger;

        /// Setter for [`zeroPadSizeX`][Self::zeroPadSizeX].
        #[unsafe(method(setZeroPadSizeX:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setZeroPadSizeX(&self, zero_pad_size_x: NSUInteger);

        /// How much zero padding to apply to both top and bottom borders of the input image for average pooling,
        /// when using
        ///
        /// See: edgeMode MPSImageEdgeModeClamp. For
        ///
        /// See: edgeMode MPSImageEdgeModeZero this property is
        /// ignored and the area outside the image is interpreted to contain zeros.
        /// The zero padding size is used to shrink the pooling window to fit inside the area bound by the source image
        /// and its padding region, but the effect is that the normalization factor of the average computation is computed
        /// also for the zeros in the padding region.
        #[unsafe(method(zeroPadSizeY))]
        #[unsafe(method_family = none)]
        pub unsafe fn zeroPadSizeY(&self) -> NSUInteger;

        /// Setter for [`zeroPadSizeY`][Self::zeroPadSizeY].
        #[unsafe(method(setZeroPadSizeY:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setZeroPadSizeY(&self, zero_pad_size_y: NSUInteger);

        /// Initialize a gradient average pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The input stride (upsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The input stride (upsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingAverageGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingAverageGradient
        ///
        /// Returns: A new MPSCNNPoolingAverageGradient object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPoolingGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverageGradient {
    extern_methods!(
        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverageGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverageGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the filter for computing the gradient of the max pooling filter.
    /// The operation backpropagates a gradient vector using chain rule.
    ///
    /// Dilated Max pooling forward pass is defined as:
    ///
    /// out(x) = max_{dx
    /// \in Window(x)} in(s*x+D*dx), where
    ///
    /// the pooling window definition 'Window(x)' follows MPSCNNPooling specification,
    /// 's' is the pixel stride and in() is the source input image and D is the dilation factor.
    /// For MPSCNNPoolingMaxGradient the dilationRate 'D' is one. NOTE: For even-sized pooling
    /// windows with dilation rate greater than one the effective pooling window is centered
    /// around s*x with non-even windows leaning towards top-left corner. For example if
    /// kernel width = 2, dilation rate = 3, then the pooling considers positions '-2' and '+1'
    /// relative to the pooling window center 's*x'.
    ///
    /// Hence the partial derivative of the output value wrt. to the input value needed in the
    /// gradient backpropagation in MPSCNNPoolingGradient is:
    ///
    /// d out(x)/d in(y) = delta_{x_m, y}, where
    ///
    /// delta_{x,y} is the Kronecker delta symbol (see MPSCNNPoolingAverageGradient) and x_m
    /// is the index of the maximum value in the corresponding pooling window.
    ///
    /// In practice this means that the gradient value for the destination image at pixel 'x' is
    /// the sum over these contributions coming from all pooling windows that contribute
    /// to the max pooling computation in the forward pass, multiplied by the input
    /// gradient value in the source area of the corresponding pooling window. If there are
    /// multiple maximal values within a single pooling window one of them is picked for the
    /// gradient and this decision is implementation specific, which means that it can vary
    /// between different architectures and even between different filter parameters.
    ///
    /// Note: The gradient max pooling needs the secondary input image in order to compute
    /// the indices of maximal values for each pooling window, but this means redundant computations.
    /// Later we may add encode calls to MPSCNNPoolingMax that produce a state that contains the
    /// coordinates of the maximal values to be consumed by the gradient filters.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpoolingmaxgradient?language=objc)
    #[unsafe(super(
        MPSCNNPoolingGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingMaxGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingMaxGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMaxGradient {
    extern_methods!(
        /// Initialize a gradient max pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The input stride (upsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The input stride (upsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingMaxGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingMaxGradient
        ///
        /// Returns: A new MPSCNNPoolingMaxGradient object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPoolingGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMaxGradient {
    extern_methods!(
        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMaxGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMaxGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the filter for computing the gradient of the L2-Norm pooling filter.
    /// The operation backpropagates a gradient vector using chain rule.
    ///
    /// L2-Norm pooling forward pass is defined as:
    ///
    /// out(x) = sqrt( sum_{dx
    /// \in Window(x)} in(s*x+dx) * in(s*x+dx) ), where
    ///
    /// the pooling window definition 'Window(x)' follows MPSCNNPooling specification and
    /// 's' is the pixel stride and in() is the source input image.
    ///
    /// Hence the partial derivative of the output value wrt. to the input value needed in the
    /// gradient backpropagation in MPSCNNPoolingGradient is:
    ///
    /// d out(x)/d in(y) = sum_{dx
    /// \in Window(x)} delta_{s*x+dx, y} in(s*x+dx) / out(x), where
    ///
    /// delta_{x,y} is the Kronecker delta symbol for which
    ///
    /// delta_{x,y} =  {  1, when x == y
    /// {  0, otherwise,
    /// and out(x) is the L2-norm pooling value at point 'x' defined above.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpoolingl2normgradient?language=objc)
    #[unsafe(super(
        MPSCNNPoolingGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingL2NormGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingL2NormGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingL2NormGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingL2NormGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingL2NormGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingL2NormGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2NormGradient {
    extern_methods!(
        /// Initialize a gradient L2-norm pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The input stride (upsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The input stride (upsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPoolingL2NormGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingL2NormGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingL2NormGradient
        ///
        /// Returns: A new MPSCNNPoolingL2NormGradient object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPoolingGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2NormGradient {
    extern_methods!(
        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2NormGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2NormGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the filter for computing the gradient of the dilated max pooling filter.
    /// For details see comments on MPSCNNPoolingMaxGradient.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnndilatedpoolingmaxgradient?language=objc)
    #[unsafe(super(
        MPSCNNPoolingGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNDilatedPoolingMaxGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNDilatedPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNDilatedPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNDilatedPoolingMaxGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNDilatedPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNDilatedPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMaxGradient {
    extern_methods!(
        /// Initialize a MPSCNNDilatedPoolingMaxGradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `dilationRateX`: The dilation rate in the x dimension.
        ///
        /// Parameter `dilationRateY`: The dilation rate in the y dimension.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNDilatedPoolingMax object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:dilationRateX:dilationRateY:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_dilationRateX_dilationRateY_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            dilation_rate_x: NSUInteger,
            dilation_rate_y: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingMaxGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingMaxGradient
        ///
        /// Returns: A new MPSCNNPoolingMaxGradient object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPoolingGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMaxGradient {
    extern_methods!(
        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMaxGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMaxGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
