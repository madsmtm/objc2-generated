//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// A pooling kernel.
    ///
    /// ## Overview
    ///
    /// Pooling is a form of non-linear sub-sampling. Pooling partitions the input image into a set of rectangles (overlapping or non-overlapping) and, for each such sub-region, outputs a value. The pooling operation is used in computer vision to reduce the dimensionality of intermediate representations.
    ///
    /// The encode methods in the [`MPSCNNKernel`](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnkernel) class can be used to encode an [`MPSCNNPooling`](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpooling) object to a [`MTLCommandBuffer`](https://developer.apple.com/documentation/metal/mtlcommandbuffer) object. The exact location of the pooling window for each output value is determined as follows:
    ///
    /// - The pooling window center for the first (top left) output pixel of the clip rectangle is at spatial coordinates `(offset.x, offset.y)` in the input image.
    ///
    /// - From this, the top left corner of the pooling window is at `(offset.x - floor(kernelWidth/2)`, `offset.y - floor(kernelHeight/2))` and extends `(kernelWidth, kernelHeight)` pixels to the right and down direction, which means that the last pixel to be included into the pooling window is at `(offset.x + floor((kernelWidth-1)/2)`, `offset.y + floor((kernelHeight-1)/2))`, so that for even kernel sizes the pooling window extends one pixel more into the left and up direction.
    ///
    /// - The following pooling windows can be then easily deduced from the first one by simple shifting the source coordinates according to the values of the `strideInPixelsX` and `strideInPixelsY` properties.
    ///
    /// For example,  the pooling window center `w(x,y)` for the output value at coordinate `(x,y)` of the destination clip rectangle (`(x,y)` computed with regard to clipping rectangle origin) is at `w(x,y) = (offset.x + strideInPixelsX * x , offset.y + strideInPixelsY * y)`.
    ///
    /// Quite often it is desirable to distribute the pooling windows as evenly as possible in the input image. As explained above, if the `offset` is zero, then the center of the first pooling window is at the top left corner of the input image, which means that the left and top stripes of the pooling window are read from outside the input image boundaries (when filter size is larger than unity). Also it may mean that some values from the bottom and right stripes are not included at all in the pooling, resulting in loss of valuable information.
    ///
    /// A scheme used in some common libraries is to shift the source `offset` according to the following formula:
    ///
    /// - `offset.xy += {(int)ceil(((L.xy - 1) % s.xy) / 2)}`, for odd `f.xy`
    ///
    /// - `offset.xy += {(int)floor(((L.xy - 1) % s.xy) / 2) + 1},` for even `f.xy`
    ///
    /// Where `L` is the size of the input image (or more accurately the size corresponding to the scaled `clipRect` value in source coordinates, which commonly coincides with the source image itself), `s.xy` is `(``strideInPixelsX`, `strideInPixelsY``)` and `f.xy` is `(kernelWidth, kernelHeight)`.
    ///
    /// This offset distributes the pooling window centers evenly in the effective source `clipRect`, when the output size is rounded up with regards to stride (`output size = ceil(input size / stride)`) and is commonly used in CNN libraries (for example _TensorFlow_ uses this offset scheme in its maximum pooling implementation `tf.nn.max_pool` with `'S``AME``'` - padding, for `'VALID'` padding one can simply set `offset.xy += floor(f.xy/2)` to get the first pooling window inside the source image completely).
    ///
    /// For an [`MPSCNNPoolingMax`](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpoolingmax) object, the way the input image borders are handled can become important: if there are negative values in the source image near the borders of the image and the pooling window crosses the borders, then using a [`MPSImageEdgeModeZero`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageedgemode/zero) edge modemay cause the maximum pooling operation to override the negative input data values with zeros coming from outside the source image borders, resulting in large boundary effects. A simple way to avoid this is to use a [`MPSImageEdgeModeClamp`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageedgemode/clamp) edge mode, which for an [`MPSCNNPoolingMax`](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnpoolingmax) object effectively causes all pooling windows to remain within the source image.
    ///
    ///
    /// Dependencies: This depends on Metal.framework
    ///
    /// Pooling is a form of non-linear sub-sampling. Pooling partitions the input image into a set of
    /// rectangles (overlapping or non-overlapping) and, for each such sub-region, outputs a value.
    /// The pooling operation is used in computer vision to reduce the dimensionality of intermediate representations.
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPooling;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPooling {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPooling {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPooling {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPooling {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPooling {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPooling {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPooling {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPooling {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A max pooling filter.
    ///
    /// ## Overview
    ///
    /// For each pixel in an image, the filter returns the maximum value of the pixels in the filter region defined by `kernelWidth` x `kernelHeight`.
    ///
    ///
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the max pooling filter.  For each pixel, returns the maximum value of pixels
    /// in the kernelWidth x kernelHeight filter region.
    #[unsafe(super(MPSCNNPooling, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingMax;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingMax {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMax {
    extern_methods!(
        /// Initialize a MPSCNNPoolingMax pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPooling`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMax {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMax {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMax {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An average pooling filter.
    ///
    /// ## Overview
    ///
    /// For each pixel in an image, the filter returns the average value of the pixels in the filter region defined by `kernelWidth` `x` `kernelHeight`.
    ///
    /// When the value of the [`edgeMode`](https://developer.apple.com/documentation/metalperformanceshaders/mpscnnkernel/edgemode) property is set to [`MPSImageEdgeModeClamp`](https://developer.apple.com/documentation/metalperformanceshaders/mpsimageedgemode/clamp), the filtering window is shrunk to remain within the source image borders. For pixels close to the image borders, the filtering window will be smaller in order to fit inside the source image and less values will be used to compute the average value. In case the filtering window is entirely outside the source image border, the output value will be `0`.
    ///
    ///
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the average pooling filter.  For each pixel, returns the mean value of pixels
    /// in the kernelWidth x kernelHeight filter region.
    /// When
    /// edgeModeis
    /// MPSImageEdgeModeClampthe filtering window is shrunk to remain
    /// within the source image borders. What this means is that close to image borders the filtering window
    /// will be smaller in order to fit inside the source image and less values will be used to compute the
    /// average. In case the filtering window is entirely outside the source image border the
    /// outputted value will be zero.
    #[unsafe(super(MPSCNNPooling, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingAverage;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingAverage {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingAverage {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingAverage {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingAverage {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingAverage {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverage {
    extern_methods!(
        /// How much zero padding to apply to both left and right borders of the input image for average pooling,
        /// when using
        ///
        /// See: edgeMode MPSImageEdgeModeClamp. For
        ///
        /// See: edgeMode MPSImageEdgeModeZero this property is
        /// ignored and the area outside the image is interpreted to contain zeros.
        /// The zero padding size is used to shrink the pooling window to fit inside the area bound by the source image
        /// and its padding region, but the effect is that the normalization factor of the average computation is computed
        /// also for the zeros in the padding region.
        #[unsafe(method(zeroPadSizeX))]
        #[unsafe(method_family = none)]
        pub unsafe fn zeroPadSizeX(&self) -> NSUInteger;

        /// Setter for [`zeroPadSizeX`][Self::zeroPadSizeX].
        #[unsafe(method(setZeroPadSizeX:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setZeroPadSizeX(&self, zero_pad_size_x: NSUInteger);

        /// How much zero padding to apply to both top and bottom borders of the input image for average pooling,
        /// when using
        ///
        /// See: edgeMode MPSImageEdgeModeClamp. For
        ///
        /// See: edgeMode MPSImageEdgeModeZero this property is
        /// ignored and the area outside the image is interpreted to contain zeros.
        /// The zero padding size is used to shrink the pooling window to fit inside the area bound by the source image
        /// and its padding region, but the effect is that the normalization factor of the average computation is computed
        /// also for the zeros in the padding region.
        #[unsafe(method(zeroPadSizeY))]
        #[unsafe(method_family = none)]
        pub unsafe fn zeroPadSizeY(&self) -> NSUInteger;

        /// Setter for [`zeroPadSizeY`][Self::zeroPadSizeY].
        #[unsafe(method(setZeroPadSizeY:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setZeroPadSizeY(&self, zero_pad_size_y: NSUInteger);

        /// Initialize a MPSCNNPoolingAverage pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPooling`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverage {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverage {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverage {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An L2-norm pooling filter.
    ///
    /// ## Overview
    ///
    /// For each pixel, returns L2-Norm of pixels in the `kernelWidth * kernelHeight` filter region:
    ///
    ///
    /// ![out[c,x,y] = sqrt ( sum_{dx,dy} in[c,x+dx,y+dy] * in[c,x+dx,y+dy] )](https://docs-assets.developer.apple.com/published/ad86372e61a5349468f50e9f214fd2be/media-2903549%402x.png)
    ///
    ///
    ///
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the L2-norm pooling filter.  For each pixel, returns L2-Norm of pixels
    /// in the kernelWidth x kernelHeight filter region.
    /// out[c,x,y] = sqrt ( sum_{dx,dy} in[c,x+dx,y+dy] * in[c,x+dx,y+dy] ).
    #[unsafe(super(MPSCNNPooling, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingL2Norm;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingL2Norm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingL2Norm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingL2Norm {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingL2Norm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingL2Norm {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2Norm {
    extern_methods!(
        /// Initialize a MPSCNNPoolingL2Norm pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPooling
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPooling
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPooling`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2Norm {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2Norm {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2Norm {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A dilated max pooling filter.
    ///
    /// ## Overview
    ///
    /// For each pixel, returns the maximum value of pixels in the `kernelWidth * kernelHeight` filter region by step size `dilationFactorX` `*` `dilationFactorY`.
    ///
    ///
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the dilated max pooling filter.  For each pixel, returns the maximum value of pixels
    /// in the kernelWidth x kernelHeight filter region by step size dilationRateX x dilationRateY.
    #[unsafe(super(MPSCNNPooling, MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNDilatedPoolingMax;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNDilatedPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNDilatedPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNDilatedPoolingMax {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNDilatedPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNDilatedPoolingMax {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMax {
    extern_methods!(
        /// dilationRateX for accessing the image passed in as source
        #[unsafe(method(dilationRateX))]
        #[unsafe(method_family = none)]
        pub unsafe fn dilationRateX(&self) -> NSUInteger;

        /// dilationRateY for accessing the image passed in as source
        #[unsafe(method(dilationRateY))]
        #[unsafe(method_family = none)]
        pub unsafe fn dilationRateY(&self) -> NSUInteger;

        /// Initialize a MPSCNNDilatedPoolingMax pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `dilationRateX`: The dilation rate in the x dimension.
        ///
        /// Parameter `dilationRateY`: The dilation rate in the y dimension.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNDilatedPoolingMax object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:dilationRateX:dilationRateY:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_dilationRateX_dilationRateY_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            dilation_rate_x: NSUInteger,
            dilation_rate_y: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel.hinitWithCoder.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNDilatedPoolingMax
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNDilatedPoolingMax
        ///
        /// Returns: A new MPSCNNDilatedPoolingMax object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPooling`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMax {
    extern_methods!(
        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// Initialize a pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPooling object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMax {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMax {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A gradient pooling kernel.
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the base class for computing the gradient of the pooling filters.
    /// The operation backpropagates a gradient vector using the chain rule.
    ///
    /// Given the input gradient vector dL(x) = dL/d out(x), which is the derivative of the
    /// loss-function wrt. (original) pooling filter output the output gradient at position y
    /// (dL/d in(y)) is computed as follows:
    ///
    /// dL/d in(y) = sum_x (dL/d out(x)) * (d out(x)/d in(y)), where
    ///
    /// the sum runs over the input gradient pixels starting from primaryOffset
    /// extending to primaryOffset + sourceSize. Note here that we need a separate
    /// variable 'sourceSize' to specify which input gradients are included in the output
    /// gradient computation as this information cannot be deduced directly from the cliprect
    /// size due to fractional striding or simply because the user wants to examine a subset
    /// of the contributions to the gradients. In normal operation the sourceSize is specified
    /// as the cliprect.size of the forward pooling filter in order to compute the gradients for
    /// all outputs the forward direction produced and the primaryOffset is set to
    /// cliprect.origin of the original forward pooling operation for the same reason.
    ///
    /// The cliprect property of the filter allows the user to send the gradients to a new location,
    /// which may not match the original forward pooling filter window locations:
    /// The index 'y' in the formula above refers to the pixel location in the secondary source,
    /// which is the source image of the original forward pooling filter and secondaryOffset specifies
    /// the center of the first pooling window as specified in MPSCNNPooling filter specification.
    /// The first (top leftmost) pixel written into the cliprect computes the derivative of the first pixel
    /// within the first pooling window that is contained within the secondary source image and
    /// subsequent values are defined by normal striding rules from secondary source to primary source.
    /// This means that typically the cliprect is set to fill the effective source area of the original forward
    /// operation, clamped to edges of the original source image, which in the normal case is the same size
    /// as the size of the gradient destination image.
    ///
    /// If there are any values in the destination cliprect that do not contribute to the forward
    /// pooling result in the area specified by primaryOffset and sourceSize,
    /// due to large strides or dilation factors or simply because all forward pass induced values would be
    /// outside the source area, then those result values are set to zero.
    ///
    /// The actual value of d out(x) / d in(y) depends on the pooling operation and these are defined in the
    /// subclasses of MPSCNNPoolingGradient.
    #[unsafe(super(MPSCNNGradientKernel, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingGradient {
    extern_methods!(
        /// An optional source size which defines together with primaryOffset, the set of input gradient
        /// pixels to take into account in the gradient computations.
        ///
        /// A MTLSize that together with primaryOffset indicates which part of the source gradient to consider.
        /// If the area does not lie completely within the primary source image, the intersection between
        /// source area rectangle and primary source bounds is used.
        /// Default: A size where every component is NSUIntegerMax indicating the entire rest of the image,
        /// starting from an offset (see primaryOffset).
        #[unsafe(method(sourceSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceSize(&self) -> MTLSize;

        /// Setter for [`sourceSize`][Self::sourceSize].
        #[unsafe(method(setSourceSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSourceSize(&self, source_size: MTLSize);

        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The input stride (upsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The input stride (upsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingGradient
        ///
        /// Returns: A new MPSCNNPooling object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A gradient average pooling filter.
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the filter for computing the gradient of the average pooling filter.
    /// The operation backpropagates a gradient vector using chain rule.
    ///
    /// Average pooling forward pass is defined as:
    ///
    /// out(x) = sum_{dx
    /// \in Window(x)} in(s*x+dx) / N(x), where
    ///
    /// the pooling window definition 'Window(x)' follows MPSCNNPooling specification,
    /// 'N(x)' is effective pooling window size in pixels as specified in MPSCNNPoolingAverage,
    /// 's' is the pixel stride and in() is the source input image.
    ///
    /// Hence the partial derivative of the output value wrt. to the input value needed in the
    /// gradient backpropagation in MPSCNNPoolingGradient is:
    ///
    /// d out(x)/d in(y) = sum_{dx
    /// \in Window(x)} delta_{s*x+dx, y} / N(x), where
    ///
    /// delta_{x,y} is the Kronecker delta symbol for which
    ///
    /// delta_{x,y} =  {  1, when x == y
    /// {  0, otherwise.
    ///
    /// In practice this means that the gradient value for the destination image at pixel 'x' is
    /// the sum over these contributions coming from all pooling windows that contribute
    /// to the average pooling computation in the forward pass, multiplied by the input
    /// gradient value in the source area of the corresponding pooling window.
    ///
    /// Note: As average pooling is a linear operation of its inputs, the gradient does not
    /// depend at all on the original input values, but the original input image size is needed
    /// so that we know the limits where the input values seize to exist to inhibit accumulation
    /// of gradient values for those pixels. Therefore, as secondary input, any correctly sized
    /// image will produce correct results for the gradient backpropagation and hence it is
    /// recommended to use a temporary image of correct size (see MPSTemporaryImage) for the
    /// secondary source image parameter.
    #[unsafe(super(
        MPSCNNPoolingGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingAverageGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingAverageGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingAverageGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingAverageGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingAverageGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingAverageGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverageGradient {
    extern_methods!(
        /// How much zero padding to apply to both left and right borders of the input image for average pooling,
        /// when using
        ///
        /// See: edgeMode MPSImageEdgeModeClamp. For
        ///
        /// See: edgeMode MPSImageEdgeModeZero this property is
        /// ignored and the area outside the image is interpreted to contain zeros.
        /// The zero padding size is used to shrink the pooling window to fit inside the area bound by the source image
        /// and its padding region, but the effect is that the normalization factor of the average computation is computed
        /// also for the zeros in the padding region.
        #[unsafe(method(zeroPadSizeX))]
        #[unsafe(method_family = none)]
        pub unsafe fn zeroPadSizeX(&self) -> NSUInteger;

        /// Setter for [`zeroPadSizeX`][Self::zeroPadSizeX].
        #[unsafe(method(setZeroPadSizeX:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setZeroPadSizeX(&self, zero_pad_size_x: NSUInteger);

        /// How much zero padding to apply to both top and bottom borders of the input image for average pooling,
        /// when using
        ///
        /// See: edgeMode MPSImageEdgeModeClamp. For
        ///
        /// See: edgeMode MPSImageEdgeModeZero this property is
        /// ignored and the area outside the image is interpreted to contain zeros.
        /// The zero padding size is used to shrink the pooling window to fit inside the area bound by the source image
        /// and its padding region, but the effect is that the normalization factor of the average computation is computed
        /// also for the zeros in the padding region.
        #[unsafe(method(zeroPadSizeY))]
        #[unsafe(method_family = none)]
        pub unsafe fn zeroPadSizeY(&self) -> NSUInteger;

        /// Setter for [`zeroPadSizeY`][Self::zeroPadSizeY].
        #[unsafe(method(setZeroPadSizeY:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setZeroPadSizeY(&self, zero_pad_size_y: NSUInteger);

        /// Initialize a gradient average pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The input stride (upsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The input stride (upsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingAverageGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingAverageGradient
        ///
        /// Returns: A new MPSCNNPoolingAverageGradient object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPoolingGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverageGradient {
    extern_methods!(
        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverageGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingAverageGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A gradient max pooling filter.
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the filter for computing the gradient of the max pooling filter.
    /// The operation backpropagates a gradient vector using chain rule.
    ///
    /// Dilated Max pooling forward pass is defined as:
    ///
    /// out(x) = max_{dx
    /// \in Window(x)} in(s*x+D*dx), where
    ///
    /// the pooling window definition 'Window(x)' follows MPSCNNPooling specification,
    /// 's' is the pixel stride and in() is the source input image and D is the dilation factor.
    /// For MPSCNNPoolingMaxGradient the dilationRate 'D' is one. NOTE: For even-sized pooling
    /// windows with dilation rate greater than one the effective pooling window is centered
    /// around s*x with non-even windows leaning towards top-left corner. For example if
    /// kernel width = 2, dilation rate = 3, then the pooling considers positions '-2' and '+1'
    /// relative to the pooling window center 's*x'.
    ///
    /// Hence the partial derivative of the output value wrt. to the input value needed in the
    /// gradient backpropagation in MPSCNNPoolingGradient is:
    ///
    /// d out(x)/d in(y) = delta_{x_m, y}, where
    ///
    /// delta_{x,y} is the Kronecker delta symbol (see MPSCNNPoolingAverageGradient) and x_m
    /// is the index of the maximum value in the corresponding pooling window.
    ///
    /// In practice this means that the gradient value for the destination image at pixel 'x' is
    /// the sum over these contributions coming from all pooling windows that contribute
    /// to the max pooling computation in the forward pass, multiplied by the input
    /// gradient value in the source area of the corresponding pooling window. If there are
    /// multiple maximal values within a single pooling window one of them is picked for the
    /// gradient and this decision is implementation specific, which means that it can vary
    /// between different architectures and even between different filter parameters.
    ///
    /// Note: The gradient max pooling needs the secondary input image in order to compute
    /// the indices of maximal values for each pooling window, but this means redundant computations.
    /// Later we may add encode calls to MPSCNNPoolingMax that produce a state that contains the
    /// coordinates of the maximal values to be consumed by the gradient filters.
    #[unsafe(super(
        MPSCNNPoolingGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingMaxGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingMaxGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMaxGradient {
    extern_methods!(
        /// Initialize a gradient max pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The input stride (upsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The input stride (upsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingMaxGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingMaxGradient
        ///
        /// Returns: A new MPSCNNPoolingMaxGradient object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPoolingGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMaxGradient {
    extern_methods!(
        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMaxGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingMaxGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A gradient L2-norm pooling filter.
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the filter for computing the gradient of the L2-Norm pooling filter.
    /// The operation backpropagates a gradient vector using chain rule.
    ///
    /// L2-Norm pooling forward pass is defined as:
    ///
    /// out(x) = sqrt( sum_{dx
    /// \in Window(x)} in(s*x+dx) * in(s*x+dx) ), where
    ///
    /// the pooling window definition 'Window(x)' follows MPSCNNPooling specification and
    /// 's' is the pixel stride and in() is the source input image.
    ///
    /// Hence the partial derivative of the output value wrt. to the input value needed in the
    /// gradient backpropagation in MPSCNNPoolingGradient is:
    ///
    /// d out(x)/d in(y) = sum_{dx
    /// \in Window(x)} delta_{s*x+dx, y} in(s*x+dx) / out(x), where
    ///
    /// delta_{x,y} is the Kronecker delta symbol for which
    ///
    /// delta_{x,y} =  {  1, when x == y
    /// {  0, otherwise,
    /// and out(x) is the L2-norm pooling value at point 'x' defined above.
    #[unsafe(super(
        MPSCNNPoolingGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNPoolingL2NormGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNPoolingL2NormGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNPoolingL2NormGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNPoolingL2NormGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNPoolingL2NormGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNPoolingL2NormGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2NormGradient {
    extern_methods!(
        /// Initialize a gradient L2-norm pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `strideInPixelsX`: The input stride (upsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The input stride (upsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNPoolingL2NormGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingL2NormGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingL2NormGradient
        ///
        /// Returns: A new MPSCNNPoolingL2NormGradient object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPoolingGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2NormGradient {
    extern_methods!(
        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2NormGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNPoolingL2NormGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A gradient dilated max pooling filter.
    ///
    /// ## Overview
    ///
    /// A gradient max pooling filter but the pixels selected in each application of the max pooling operation are exactly the same pixels that would be selected with dilated convolution
    ///
    ///
    /// Dependencies: This depends on Metal.framework
    ///
    /// Specifies the filter for computing the gradient of the dilated max pooling filter.
    /// For details see comments on MPSCNNPoolingMaxGradient.
    #[unsafe(super(
        MPSCNNPoolingGradient,
        MPSCNNGradientKernel,
        MPSCNNBinaryKernel,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNDilatedPoolingMaxGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNDilatedPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNDilatedPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNDilatedPoolingMaxGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNDilatedPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNDilatedPoolingMaxGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMaxGradient {
    extern_methods!(
        /// Initialize a MPSCNNDilatedPoolingMaxGradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `dilationRateX`: The dilation rate in the x dimension.
        ///
        /// Parameter `dilationRateY`: The dilation rate in the y dimension.
        ///
        /// Parameter `strideInPixelsX`: The output stride (downsampling factor) in the x dimension.
        ///
        /// Parameter `strideInPixelsY`: The output stride (downsampling factor) in the y dimension.
        ///
        /// Returns: A valid MPSCNNDilatedPoolingMax object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:dilationRateX:dilationRateY:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_dilationRateX_dilationRateY_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            dilation_rate_x: NSUInteger,
            dilation_rate_y: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:strideInPixelsX:strideInPixelsY:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight_strideInPixelsX_strideInPixelsY(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
            stride_in_pixels_x: NSUInteger,
            stride_in_pixels_y: NSUInteger,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// See
        /// MPSKernel#initWithCoder.
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSCNNPoolingMaxGradient
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSCNNPoolingMaxGradient
        ///
        /// Returns: A new MPSCNNPoolingMaxGradient object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSCNNPoolingGradient`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMaxGradient {
    extern_methods!(
        /// Initialize a gradient pooling filter
        ///
        /// Parameter `device`: The device the filter will run on
        ///
        /// Parameter `kernelWidth`: The width of the kernel.  Can be an odd or even value.
        ///
        /// Parameter `kernelHeight`: The height of the kernel.  Can be an odd or even value.
        ///
        /// Returns: A valid MPSCNNPoolingGradient object or nil, if failure.
        #[unsafe(method(initWithDevice:kernelWidth:kernelHeight:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_kernelWidth_kernelHeight(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            kernel_width: NSUInteger,
            kernel_height: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMaxGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNDilatedPoolingMaxGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
