//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// A state to hold information necessary to execute a gradient
    /// pass for MPSCNNGroupNormalization.  Gradient states should
    /// be created by using the forward kernel's methods.  This will
    /// ensure that the state captures all information necessary to
    /// execute the corresponding gradient pass.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnngroupnormalizationgradientstate?language=objc)
    #[unsafe(super(MPSNNGradientState, MPSState, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(
        feature = "MPSCore",
        feature = "MPSNNGradientState",
        feature = "MPSState"
    ))]
    pub struct MPSCNNGroupNormalizationGradientState;
);

#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNGroupNormalizationGradientState {}
);

#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
impl MPSCNNGroupNormalizationGradientState {
    extern_methods!(
        #[cfg(all(feature = "MPSCNNKernel", feature = "MPSKernel"))]
        /// The MPSCNNGroupNormalization object that created this state object.
        #[unsafe(method(groupNormalization))]
        #[unsafe(method_family = none)]
        pub unsafe fn groupNormalization(&self) -> Retained<MPSCNNGroupNormalization>;

        /// Return an MTLBuffer object with the state's current gamma values.
        #[unsafe(method(gamma))]
        #[unsafe(method_family = none)]
        pub unsafe fn gamma(&self) -> Option<Retained<ProtocolObject<dyn MTLBuffer>>>;

        /// Return an MTLBuffer object with the state's current beta values..
        #[unsafe(method(beta))]
        #[unsafe(method_family = none)]
        pub unsafe fn beta(&self) -> Option<Retained<ProtocolObject<dyn MTLBuffer>>>;

        #[unsafe(method(gradientForGamma))]
        #[unsafe(method_family = none)]
        pub unsafe fn gradientForGamma(&self) -> Retained<ProtocolObject<dyn MTLBuffer>>;

        #[unsafe(method(gradientForBeta))]
        #[unsafe(method_family = none)]
        pub unsafe fn gradientForBeta(&self) -> Retained<ProtocolObject<dyn MTLBuffer>>;

        /// Unavailable.  Use MPSCNNGroupNormalization state creation methods.
        #[unsafe(method(temporaryStateWithCommandBuffer:textureDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_textureDescriptor(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        #[unsafe(method(temporaryStateWithCommandBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
        ) -> Retained<Self>;

        #[unsafe(method(temporaryStateWithCommandBuffer:bufferSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_bufferSize(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            buffer_size: usize,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSState`.
#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
impl MPSCNNGroupNormalizationGradientState {
    extern_methods!(
        // -init (unavailable)

        /// Initialize a non-temporary state to hold a number of textures and buffers
        ///
        /// The allocation of each resource will be deferred  until it is needed.
        /// This occurs when -resource or -resourceAtIndex: is called.
        ///
        /// Parameter `resourceList`: The list of resources to create.
        #[unsafe(method(initWithDevice:resourceList:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_resourceList(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Initialize a temporary state to hold a number of textures and buffers
        ///
        /// The textures occur first in sequence
        #[unsafe(method(temporaryStateWithCommandBuffer:resourceList:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_resourceList(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Create a state object with a list of MTLResources
        ///
        /// Because MPS prefers deferred allocation of resources
        /// your application should use -initWithTextures:bufferSizes:bufferCount:
        /// whenever possible. This method is useful for cases when the
        /// MTLResources must be initialized by the CPU.
        ///
        /// # Safety
        ///
        /// - `resources` generic may need to be synchronized.
        /// - `resources` generic may be unretained, you must ensure it is kept alive while in use.
        #[unsafe(method(initWithResources:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithResources(
            this: Allocated<Self>,
            resources: Option<&NSArray<ProtocolObject<dyn MTLResource>>>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
impl MPSCNNGroupNormalizationGradientState {
    extern_methods!(
        // +new (unavailable)

    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnngroupnormalizationgradientstatebatch?language=objc)
#[cfg(all(
    feature = "MPSCore",
    feature = "MPSNNGradientState",
    feature = "MPSState"
))]
pub type MPSCNNGroupNormalizationGradientStateBatch =
    NSArray<MPSCNNGroupNormalizationGradientState>;

extern_protocol!(
    /// The MPSCNNGroupNormalizationDataSource protocol declares the methods that an
    /// group of MPSCNNGroupNormalization uses to initialize the
    /// scale factors (gamma) and bias terms (beta).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnngroupnormalizationdatasource?language=objc)
    pub unsafe trait MPSCNNGroupNormalizationDataSource:
        NSObjectProtocol + NSCopying
    {
        /// Return a pointer to an array containing the gamma terms.
        ///
        /// Must have numberOfFeatureChannels values since scaling is done per feature channel.
        #[unsafe(method(gamma))]
        #[unsafe(method_family = none)]
        unsafe fn gamma(&self) -> *mut c_float;

        /// Return a pointer to an array containing the beta terms.
        ///
        /// Must have numberOfFeatureChannels values since scaling is done per feature channel.
        #[unsafe(method(beta))]
        #[unsafe(method_family = none)]
        unsafe fn beta(&self) -> *mut c_float;

        #[unsafe(method(numberOfFeatureChannels))]
        #[unsafe(method_family = none)]
        unsafe fn numberOfFeatureChannels(&self) -> NSUInteger;

        /// numberOfFeatureChannels/numberOfGroups channels are normalized together.
        #[unsafe(method(numberOfGroups))]
        #[unsafe(method_family = none)]
        unsafe fn numberOfGroups(&self) -> NSUInteger;

        /// Setter for [`numberOfGroups`][Self::numberOfGroups].
        #[unsafe(method(setNumberOfGroups:))]
        #[unsafe(method_family = none)]
        unsafe fn setNumberOfGroups(&self, number_of_groups: NSUInteger);

        /// A label that is transferred to the group normalization filter at init time
        ///
        /// Overridden by a MPSCNNGroupNormalizationNode.label if it is non-nil.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        unsafe fn label(&self) -> Option<Retained<NSString>>;

        #[cfg(all(
            feature = "MPSCNNNormalizationWeights",
            feature = "MPSCore",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Compute new gamma and beta values using current values and gradients contained within a
        /// MPSCNNGroupNormalizationStateBatch.
        ///
        /// This is for use in the context of training a network within a MPSNNGraph. If you are
        /// writing your own graph using the low level interface or aren't training group normalization
        /// it isn't needed.
        ///
        /// In this mathod, you should perform the update on a GPU, because at the time it is called
        /// the data isn't in the state objects yet and the CPU can't do the work. You should not attempt
        /// to update the MPSCNNGroupNormalization kernel directly with the results. The state object
        /// returned from the function will be used for that.  A batch of states will be passed in.
        /// You should accumulate the gradients and then update the weights.
        ///
        /// This operation is expected to also decrement the read count of groupNormalizationStateBatch by 1,
        /// if the states are temporary.
        ///
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the update.
        ///
        ///
        /// Parameter `groupNormalizationStateBatch`: A batch of MPSCNNGroupNormalizationGradientState objects containing
        /// current weights and gradients.
        ///
        ///
        /// Returns: A MPSCNNNormalizationGammaAndBetaState object containing updated gamma and beta values.  If NULL no
        /// update was performed.
        #[optional]
        #[unsafe(method(updateGammaAndBetaWithCommandBuffer:groupNormalizationStateBatch:))]
        #[unsafe(method_family = none)]
        unsafe fn updateGammaAndBetaWithCommandBuffer_groupNormalizationStateBatch(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            group_normalization_state_batch: &MPSCNNGroupNormalizationGradientStateBatch,
        ) -> Option<Retained<MPSCNNNormalizationGammaAndBetaState>>;

        #[cfg(all(
            feature = "MPSCore",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Compute new gamma and beta values using current values and gradients contained within a
        /// batch MPSCNNGroupNormalizationState objects.  Perform the update on the CPU.
        ///
        ///
        /// Parameter `groupNormalizationStateBatch`: A batch of MPSCNNGroupNormalizationGradientState objects containing
        /// current gamma and beta values and gradients.
        ///
        ///
        /// Returns: A boolean value indicating if the update was performed.
        #[optional]
        #[unsafe(method(updateGammaAndBetaWithGroupNormalizationStateBatch:))]
        #[unsafe(method_family = none)]
        unsafe fn updateGammaAndBetaWithGroupNormalizationStateBatch(
            &self,
            group_normalization_state_batch: &MPSCNNGroupNormalizationGradientStateBatch,
        ) -> bool;

        /// An optional tiny number to use to maintain numerical stability.
        ///
        /// output_image = (input_image - mean[c]) * gamma[c] / sqrt(variance[c] + epsilon) + beta[c];
        /// Defalt value if method unavailable: FLT_MIN
        #[optional]
        #[unsafe(method(epsilon))]
        #[unsafe(method_family = none)]
        unsafe fn epsilon(&self) -> c_float;

        /// Optional NSSecureCoding compatibility.
        ///
        /// # Safety
        ///
        /// `a_coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(encodeWithCoder:))]
        #[unsafe(method_family = none)]
        unsafe fn encodeWithCoder(&self, a_coder: &NSCoder);

        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[optional]
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[optional]
        #[unsafe(method(supportsSecureCoding))]
        #[unsafe(method_family = none)]
        unsafe fn supportsSecureCoding() -> bool;

        /// Optional copy method to create a copy of the data source for use with a new device.
        ///
        ///
        /// Parameter `zone`: The NSZone on which to allocate.
        ///
        /// Parameter `device`: The device where the kernel which uses this data source will be used.
        ///
        ///
        /// Returns: A pointer to a copy of this data source.
        ///
        /// # Safety
        ///
        /// `zone` must be a valid pointer or null.
        #[optional]
        #[unsafe(method(copyWithZone:device:))]
        #[unsafe(method_family = copy)]
        unsafe fn copyWithZone_device(
            &self,
            zone: *mut NSZone,
            device: Option<&ProtocolObject<dyn MTLDevice>>,
        ) -> Retained<Self>;
    }
);

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// This kernel normalizes each image, on a per-group basis, to
    /// have zero mean and unit variance:
    ///
    /// for each image:
    /// for each channel:
    /// y = (x - mean) * gamma / sqrt(variance + epsilon) + beta;
    ///
    /// The mean and variance are computed per group of channels, as given by the dataSource.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnngroupnormalization?language=objc)
    #[unsafe(super(MPSCNNKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNGroupNormalization;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNGroupNormalization {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNGroupNormalization {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNGroupNormalization {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNGroupNormalization {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNGroupNormalization {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNGroupNormalization {
    extern_methods!(
        /// The epsilon value used to bias the variance when normalizing.
        #[unsafe(method(epsilon))]
        #[unsafe(method_family = none)]
        pub unsafe fn epsilon(&self) -> c_float;

        /// Setter for [`epsilon`][Self::epsilon].
        #[unsafe(method(setEpsilon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEpsilon(&self, epsilon: c_float);

        /// The data source that the object was initialized with
        #[unsafe(method(dataSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataSource(
            &self,
        ) -> Retained<ProtocolObject<dyn MPSCNNGroupNormalizationDataSource>>;

        /// Initialize a MPSCNNGroupNormalization kernel on a device.
        ///
        /// Parameter `dataSource`: An object conforming to the MPSCNNGroupNormalizationDataSource
        /// protocol which
        #[unsafe(method(initWithDevice:dataSource:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_dataSource(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            data_source: &ProtocolObject<dyn MPSCNNGroupNormalizationDataSource>,
        ) -> Retained<Self>;

        // -initWithDevice: (unavailable)

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSCNNGroupNormalization object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;

        /// Reinitialize the filter using the data source provided at kernel initialization.
        #[unsafe(method(reloadGammaAndBetaFromDataSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn reloadGammaAndBetaFromDataSource(&self);

        #[cfg(all(feature = "MPSCNNNormalizationWeights", feature = "MPSState"))]
        /// Reload data using new gamma and beta terms contained within an
        /// MPSCNNGroupNormalizationGradientState object.
        ///
        ///
        /// Parameter `commandBuffer`: The command buffer on which to encode the reload.
        ///
        ///
        /// Parameter `gammaAndBetaState`: The state containing the updated weights which are to
        /// be reloaded.
        #[unsafe(method(reloadGammaAndBetaWithCommandBuffer:gammaAndBetaState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn reloadGammaAndBetaWithCommandBuffer_gammaAndBetaState(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            gamma_and_beta_state: &MPSCNNNormalizationGammaAndBetaState,
        );

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Return a MPSCNNGroupNormalizationGradientState object for the provided
        /// source image, source states, and destination image.
        #[unsafe(method(resultStateForSourceImage:sourceStates:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn resultStateForSourceImage_sourceStates_destinationImage(
            &self,
            source_image: &MPSImage,
            source_states: Option<&NSArray<MPSState>>,
            destination_image: &MPSImage,
        ) -> Option<Retained<MPSCNNGroupNormalizationGradientState>>;

        #[cfg(all(
            feature = "MPSImage",
            feature = "MPSNNGradientState",
            feature = "MPSState"
        ))]
        /// Return a temporary MPSCNNGroupNormalizationGradientState object which may be used with
        /// a MPSCNNGroupNormalization filter.
        #[unsafe(method(temporaryResultStateForCommandBuffer:sourceImage:sourceStates:destinationImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryResultStateForCommandBuffer_sourceImage_sourceStates_destinationImage(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_image: &MPSImage,
            source_states: Option<&NSArray<MPSState>>,
            destination_image: &MPSImage,
        ) -> Option<Retained<MPSCNNGroupNormalizationGradientState>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNGroupNormalization {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNGroupNormalization {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    /// This kernel executes a gradient pass corresponding to MPSCNNGroupNormalization.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpscnngroupnormalizationgradient?language=objc)
    #[unsafe(super(MPSCNNGradientKernel, MPSCNNBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSCNNGroupNormalizationGradient;
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSCNNGroupNormalizationGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSCNNGroupNormalizationGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSCNNGroupNormalizationGradient {
    type Result = Self;
}

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSCNNGroupNormalizationGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSCNNGroupNormalizationGradient {}
);

#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNGroupNormalizationGradient {
    extern_methods!();
}

/// Methods declared on superclass `MPSCNNGradientKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNGroupNormalizationGradient {
    extern_methods!(
        /// Standard init with default properties per filter type
        ///
        /// Parameter `device`: The device that the filter will be used on. May not be NULL.
        ///
        /// Returns: A pointer to the newly initialized object. This will fail, returning
        /// nil if the device is not supported. Devices must be
        /// MTLFeatureSet_iOS_GPUFamily2_v1 or later.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNGroupNormalizationGradient {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCNNKernel", feature = "MPSCore", feature = "MPSKernel"))]
impl MPSCNNGroupNormalizationGradient {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
