//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    ///
    /// A matrix multiplication kernel.
    ///
    ///
    /// A MPSMatrixMultiplication object computes:
    ///
    /// C = alpha * op(A) * op(B) + beta * C
    ///
    /// A, B, and C are matrices which are represented by MPSMatrix
    /// objects. alpha and beta are scalar values (of the same data type
    /// as values of C) which are applied as shown above.  A and B may
    /// each have an optional transposition operation applied.
    ///
    /// A, B, and C (also referred to in later discussions as the left input
    /// matrix, the right input matrix, and the result matrix respectively).
    ///
    /// A MPSMatrixMultiplication object is initialized with the transpose
    /// operators to apply to A and B, sizes for the operation to perform,
    /// and the scalar values alpha and beta.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsmatrixmultiplication?language=objc)
    #[unsafe(super(MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSMatrixMultiplication;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSMatrixMultiplication {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSMatrixMultiplication {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSMatrixMultiplication {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSMatrixMultiplication {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSMatrixMultiplication {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSMatrixMultiplication {
    extern_methods!(
        /// The origin, relative to [0, 0] in the result matrix, at which to
        /// start writing (and reading if necessary) results.  This property is
        /// modifiable and defaults to [0, 0] at initialization time.  If a
        /// different origin is desired then this should be modified prior to
        /// encoding the kernel.  The z value must be 0.
        #[unsafe(method(resultMatrixOrigin))]
        #[unsafe(method_family = none)]
        pub unsafe fn resultMatrixOrigin(&self) -> MTLOrigin;

        /// Setter for [`resultMatrixOrigin`][Self::resultMatrixOrigin].
        #[unsafe(method(setResultMatrixOrigin:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setResultMatrixOrigin(&self, result_matrix_origin: MTLOrigin);

        /// The origin, relative to [0, 0] in the left input matrix, at which to
        /// start reading values.  This property is modifiable and defaults to
        /// [0, 0] at initialization time.  If a different origin is desired then
        /// this should be modified prior to encoding the kernel.  The z value
        /// must be 0.
        #[unsafe(method(leftMatrixOrigin))]
        #[unsafe(method_family = none)]
        pub unsafe fn leftMatrixOrigin(&self) -> MTLOrigin;

        /// Setter for [`leftMatrixOrigin`][Self::leftMatrixOrigin].
        #[unsafe(method(setLeftMatrixOrigin:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLeftMatrixOrigin(&self, left_matrix_origin: MTLOrigin);

        /// The origin, relative to [0, 0] in the right input matrix, at which to
        /// start reading values.  This property is modifiable and defaults to
        /// [0, 0] at initialization time.  If a different origin is desired then
        /// this should be modified prior to encoding the kernel.  The z value
        /// must be 0.
        #[unsafe(method(rightMatrixOrigin))]
        #[unsafe(method_family = none)]
        pub unsafe fn rightMatrixOrigin(&self) -> MTLOrigin;

        /// Setter for [`rightMatrixOrigin`][Self::rightMatrixOrigin].
        #[unsafe(method(setRightMatrixOrigin:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRightMatrixOrigin(&self, right_matrix_origin: MTLOrigin);

        /// The index of the first matrix in the batch.  This property is
        /// modifiable and defaults to 0 at initialization time.  If
        /// batch processing should begin at a different matrix this value
        /// should be modified prior to encoding the kernel.
        #[unsafe(method(batchStart))]
        #[unsafe(method_family = none)]
        pub unsafe fn batchStart(&self) -> NSUInteger;

        /// Setter for [`batchStart`][Self::batchStart].
        #[unsafe(method(setBatchStart:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBatchStart(&self, batch_start: NSUInteger);

        /// The number of matrices in the batch to process.  This property
        /// is modifiable and by default allows all matrices available at
        /// encoding time to be processed.
        #[unsafe(method(batchSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn batchSize(&self) -> NSUInteger;

        /// Setter for [`batchSize`][Self::batchSize].
        #[unsafe(method(setBatchSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBatchSize(&self, batch_size: NSUInteger);

        /// Initialize an MPSMatrixMultiplication object on a device for a given size
        /// and desired transpose and scale values.
        ///
        ///
        /// Parameter `device`: The device on which the kernel will execute.
        ///
        ///
        /// Parameter `transposeLeft`: A boolean value which indicates if the left input matrix should be
        /// used in transposed form.  If 'YES' then op(A) = A**T, otherwise
        /// op(A) = A.
        ///
        ///
        /// Parameter `transposeRight`: A boolean value which indicates if the right input matrix should be
        /// used in transposed form.  If 'YES' then op(B) = B**T, otherwise
        /// op(B) = B.
        ///
        ///
        /// Parameter `resultRows`: The number of rows in the result matrix, M in BLAS GEMM description.
        ///
        ///
        /// Parameter `resultColumns`: The number of columns in the result matrix, N in BLAS GEMM description.
        ///
        ///
        /// Parameter `interiorColumns`: The number of columns of the left input matrix after the
        /// appropriate transpose operation has been applied. K in BLAS
        /// GEMM description.
        ///
        ///
        /// Parameter `alpha`: The scale factor to apply to the product.  Specified in double
        /// precision.  Will be converted to the appropriate precision in the
        /// implementation subject to rounding and/or clamping as necessary.
        ///
        ///
        /// Parameter `beta`: The scale factor to apply to the initial values of C.  Specified
        /// in double precision.  Will be converted to the appropriate precision in the
        /// implementation subject to rounding and/or clamping as necessary.
        ///
        ///
        /// Returns: A valid MPSMatrixMultiplication object or nil, if failure.
        #[unsafe(method(initWithDevice:transposeLeft:transposeRight:resultRows:resultColumns:interiorColumns:alpha:beta:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_transposeLeft_transposeRight_resultRows_resultColumns_interiorColumns_alpha_beta(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            transpose_left: bool,
            transpose_right: bool,
            result_rows: NSUInteger,
            result_columns: NSUInteger,
            interior_columns: NSUInteger,
            alpha: c_double,
            beta: c_double,
        ) -> Retained<Self>;

        /// Convenience initialization for a matrix-matrix multiplication
        /// with no transpositions, unit scaling of the product, and no
        /// accumulation of the result.  The scaling factors alpha and beta
        /// are taken to be 1.0 and 0.0 respectively.
        ///
        ///
        /// Parameter `device`: The device on which the kernel will execute.
        ///
        ///
        /// Parameter `resultRows`: The number of rows in the result matrix, M in BLAS GEMM description.
        ///
        ///
        /// Parameter `resultColumns`: The number of columns in the result matrix, N in BLAS GEMM description.
        ///
        ///
        /// Parameter `interiorColumns`: The number of columns of the left input matrix. K in BLAS
        /// GEMM description.
        ///
        ///
        /// Returns: A valid MPSMatrixMultiplication object or nil, if failure.
        #[unsafe(method(initWithDevice:resultRows:resultColumns:interiorColumns:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_resultRows_resultColumns_interiorColumns(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            result_rows: NSUInteger,
            result_columns: NSUInteger,
            interior_columns: NSUInteger,
        ) -> Retained<Self>;

        /// Use the above initialization method instead.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Encode a MPSMatrixMultiplication object to a command buffer.
        ///
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded kernel.
        ///
        ///
        /// Parameter `leftMatrix`: A valid MPSMatrix object which specifies the left input matrix.
        ///
        ///
        /// Parameter `rightMatrix`: A valid MPSMatrix object which specifies the right input matrix.
        ///
        ///
        /// Parameter `resultMatrix`: A valid MPSMatrix object which specifies the addend matrix which will
        /// also be overwritten by the result.
        ///
        ///
        /// Certain constraints apply to the sizes of the matrices depending on the transposition
        /// operations and sizes requested at initialization time as well as the origins at the time
        /// this routine is called:
        ///
        /// The left input matrix must be large enough to hold an array of size resultRows x interiorColumns
        /// elements beginning at leftMatrixOrigin.
        ///
        /// The right input matrix must be large enough to hold an array of size interiorColumns x resultColumns
        /// elements beginning at rightMatrixOrigin.
        ///
        /// The result matrix must be large enough to hold an array of size resultRows x resultColumns
        /// elements beginning at resultMatrixOrigin.
        ///
        /// Each matrix within the range specified by batchStart and batchSize, which also specifies
        /// a valid set of matrices within leftMatrix, rightMatrix, and resultMatrix, will
        /// be processed.
        #[unsafe(method(encodeToCommandBuffer:leftMatrix:rightMatrix:resultMatrix:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_leftMatrix_rightMatrix_resultMatrix(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            left_matrix: &MPSMatrix,
            right_matrix: &MPSMatrix,
            result_matrix: &MPSMatrix,
        );
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSMatrixMultiplication {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSMatrixMultiplication {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    ///
    ///
    /// A matrix-vector multiplication kernel.
    ///
    ///
    /// A MPSMatrixVectorMultiplication object computes:
    ///
    /// y = alpha * op(A) * x + beta * y
    ///
    /// A is a matrix represented by a MPSMatrix object. alpha and beta
    /// are scalar values (of the same data type as values of y) which are
    /// applied as shown above.  A may have an optional transposition
    /// operation applied.
    ///
    /// A MPSMatrixVectorMultiplication object is initialized with the transpose
    /// operator to apply to A, sizes for the operation to perform,
    /// and the scalar values alpha and beta.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsmatrixvectormultiplication?language=objc)
    #[unsafe(super(MPSMatrixBinaryKernel, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "MPSMatrixTypes"))]
    pub struct MPSMatrixVectorMultiplication;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "MPSMatrixTypes"))]
extern_conformance!(
    unsafe impl NSCoding for MPSMatrixVectorMultiplication {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "MPSMatrixTypes"))]
extern_conformance!(
    unsafe impl NSCopying for MPSMatrixVectorMultiplication {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "MPSMatrixTypes"))]
unsafe impl CopyingHelper for MPSMatrixVectorMultiplication {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "MPSMatrixTypes"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSMatrixVectorMultiplication {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "MPSMatrixTypes"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSMatrixVectorMultiplication {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "MPSMatrixTypes"))]
impl MPSMatrixVectorMultiplication {
    extern_methods!(
        /// Initialize an MPSMatrixVectorMultiplication object on a device for a given size
        /// and desired transpose and scale values.
        ///
        ///
        /// Parameter `device`: The device on which the kernel will execute.
        ///
        ///
        /// Parameter `transpose`: A boolean value which indicates if the input matrix should be
        /// used in transposed form.  if 'YES' then op(A) == A**T, otherwise
        /// op(A) == A.
        ///
        ///
        /// Parameter `rows`: The number of rows in the input matrix op(A), and the number of elements
        /// in the vector y.
        ///
        ///
        /// Parameter `columns`: The number of columns in the input matrix op(A), and the number of
        /// elements in the input vector x.
        ///
        ///
        /// Parameter `alpha`: The scale factor to apply to the product.  Specified in double
        /// precision.  Will be converted to the appropriate precision in the
        /// implementation subject to rounding and/or clamping as necessary.
        ///
        ///
        /// Parameter `beta`: The scale factor to apply to the initial values of y.  Specified
        /// in double precision.  Will be converted to the appropriate precision in the
        /// implementation subject to rounding and/or clamping as necessary.
        ///
        ///
        /// Returns: A valid MPSMatrixVectorMultiplication object or nil, if failure.
        #[unsafe(method(initWithDevice:transpose:rows:columns:alpha:beta:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_transpose_rows_columns_alpha_beta(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            transpose: bool,
            rows: NSUInteger,
            columns: NSUInteger,
            alpha: c_double,
            beta: c_double,
        ) -> Retained<Self>;

        /// Convenience initialization for a matrix-vector multiplication
        /// with no transposition, unit scaling of the product, and no
        /// accumulation of the result.  The scaling factors alpha and beta
        /// are taken to be 1.0 and 0.0 respectively.
        ///
        ///
        /// Parameter `device`: The device on which the kernel will execute.
        ///
        ///
        /// Parameter `rows`: The number of rows in the input matrix A, and the number of elements
        /// in the vector y.
        ///
        ///
        /// Parameter `columns`: The number of columns in the input matrix A, and the number of
        /// elements in the input vector x.
        ///
        ///
        /// Returns: A valid MPSMatrixVectorMultiplication object or nil, if failure.
        #[unsafe(method(initWithDevice:rows:columns:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_rows_columns(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            rows: NSUInteger,
            columns: NSUInteger,
        ) -> Retained<Self>;

        /// Use the above initialization method instead.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Encode a MPSMatrixVectorMultiplication object to a command buffer.
        ///
        ///
        /// Parameter `commandBuffer`: A valid MTLCommandBuffer to receive the encoded kernel.
        ///
        ///
        /// Parameter `inputMatrix`: A valid MPSMatrix object which specifies the input matrix A.
        ///
        ///
        /// Parameter `inputVector`: A valid MPSVector object which specifies the input vector x.
        ///
        ///
        /// Parameter `resultVector`: A valid MPSVector object which specifies the addend vector which will
        /// also be overwritten by the result.
        ///
        ///
        /// The left input matrix must be large enough to hold an array of size (rows x columns)
        /// elements beginning at primarySourceMatrixOrigin.
        ///
        /// The input vector must be large enough to hold an array of size (columns)
        /// elements beginning at secondarySourceMatrixOrigin.x  secondarySourceMatrixOrigin.y and
        /// secondarySourceMatrixOrigin.z must be zero.
        ///
        /// The result vector must be large enough to hold an array of size (rows)
        /// elements beginning at resultMatrixOrigin.x.  resultMatrixOrigin.y and
        /// resultMatrixOrigin.z must be zero.
        #[unsafe(method(encodeToCommandBuffer:inputMatrix:inputVector:resultVector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_inputMatrix_inputVector_resultVector(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            input_matrix: &MPSMatrix,
            input_vector: &MPSVector,
            result_vector: &MPSVector,
        );
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "MPSMatrixTypes"))]
impl MPSMatrixVectorMultiplication {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel", feature = "MPSMatrixTypes"))]
impl MPSMatrixVectorMultiplication {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
