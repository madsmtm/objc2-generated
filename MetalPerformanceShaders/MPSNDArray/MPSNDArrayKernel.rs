//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    #[unsafe(super(MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNDArrayMultiaryBase;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNDArrayMultiaryBase {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNDArrayMultiaryBase {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNDArrayMultiaryBase {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNDArrayMultiaryBase {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNDArrayMultiaryBase {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryBase {
    extern_methods!(
        #[cfg(feature = "MPSNDArrayTypes")]
        /// Read offsets to use when addressing a source NDArray
        ///
        /// The coordinate of the position read from this source array which is
        /// used to calculate the result value at [0,0,0,....]
        /// If the position read is actually a contiguous region (e.g. the area covered by
        /// a convolution kernel) then this is the center of that region, rounded down, for
        /// each dimension.
        ///
        /// Parameter `sourceIndex`: The index of the source MPSNDArray to which the list of offsets is applied
        #[deprecated]
        #[unsafe(method(offsetsAtSourceIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn offsetsAtSourceIndex(&self, source_index: NSUInteger) -> MPSNDArrayOffsets;

        #[cfg(feature = "MPSCoreTypes")]
        /// The edge mode used for each source NDArray
        ///
        /// Parameter `sourceIndex`: The index of the source image
        ///
        /// Returns: The MPSImageEdgeMode for that image
        #[deprecated]
        #[unsafe(method(edgeModeAtSourceIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn edgeModeAtSourceIndex(&self, source_index: NSUInteger) -> MPSImageEdgeMode;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// Get the diameters of the point spread function (PSF) in each dimension
        ///
        /// Parameter `sourceIndex`: The MPSNDArrayMultiaryKernel source NDArray to which the kernel will be applied
        ///
        /// Returns: A list of kernel diameters in each dimension
        #[deprecated]
        #[unsafe(method(kernelSizesForSourceIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelSizesForSourceIndex(&self, source_index: NSUInteger)
            -> MPSNDArraySizes;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// Return the downsampling ratio for the kernel in each dimension
        ///
        /// If the filter is a "backwards" filter such as a gradient filter
        /// or convolution transpose, then this is the upsampling ratio and
        /// zeros are inserted in the result.
        ///
        /// Parameter `sourceIndex`: The index of the source for which the strides apply
        ///
        /// Returns: The strides from one destination sample to the next in each
        /// dimension of the corresponding source NDArray
        #[deprecated]
        #[unsafe(method(stridesForSourceIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stridesForSourceIndex(&self, source_index: NSUInteger) -> MPSNDArrayOffsets;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// Get the kernel dilation rate for each dimension
        ///
        /// Parameter `sourceIndex`: The index of the source image for which this applies
        ///
        /// Returns: The kernel dilation rate for each dimension.
        #[deprecated]
        #[unsafe(method(dilationRatesForSourceIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dilationRatesForSourceIndex(
            &self,
            source_index: NSUInteger,
        ) -> MPSNDArraySizes;

        /// Method to allocate the result image for -encodeToCommandBuffer:sourceImage:
        ///
        /// Default: MPSTemporaryImage.defaultAllocator
        #[unsafe(method(destinationArrayAllocator))]
        #[unsafe(method_family = none)]
        pub unsafe fn destinationArrayAllocator(
            &self,
        ) -> Retained<ProtocolObject<dyn MPSNDArrayAllocator>>;

        /// Setter for [`destinationArrayAllocator`][Self::destinationArrayAllocator].
        #[unsafe(method(setDestinationArrayAllocator:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDestinationArrayAllocator(
            &self,
            destination_array_allocator: &ProtocolObject<dyn MPSNDArrayAllocator>,
        );

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a MPSNDArrayMultiaryKernel
        ///
        /// Parameter `device`: The device on which the kernel will run
        ///
        /// Parameter `count`: The maximum number of NDArrays read by the kernel
        ///
        /// Returns: A valid MPSNDArrayMultiaryKernel, or nil if allocation failure.
        #[unsafe(method(initWithDevice:sourceCount:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
        ) -> Retained<Self>;

        /// Initialize a MPSNDArrayMultiaryKernel from a NSCoder
        ///
        /// Parameter `coder`: The NSCoder that contains the serialized object
        ///
        /// Parameter `device`: The device on which the kernel will run
        ///
        /// Returns: A valid MPSNDArrayMultiaryKernel, or nil if allocation failure.
        ///
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            coder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a MPSNDArrayMultiaryKernel from a NSCoder
        ///
        /// Parameter `coder`: The NSCoder that contains the serialized object
        ///
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(encodeWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeWithCoder(&self, coder: &NSCoder);

        /// Create a copy with
        ///
        /// Parameter `zone`: The NSZone in which to allocate the MPSNDArrayMultiaryKernel object
        ///
        /// Parameter `device`: The device on which the new kernel will run. Pass nil for same device.
        ///
        /// Returns: A valid MPSNDArrayMultiaryKernel, or nil if allocation failure.
        ///
        /// # Safety
        ///
        /// `zone` must be a valid pointer or null.
        #[unsafe(method(copyWithZone:device:))]
        #[unsafe(method_family = copy)]
        pub unsafe fn copyWithZone_device(
            &self,
            zone: *mut NSZone,
            device: Option<&ProtocolObject<dyn MTLDevice>>,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSState")]
        #[unsafe(method(resultStateForSourceArrays:sourceStates:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn resultStateForSourceArrays_sourceStates_destinationArray(
            &self,
            source_arrays: &NSArray<MPSNDArray>,
            source_states: Option<&NSArray<MPSState>>,
            destination_array: &MPSNDArray,
        ) -> Option<Retained<MPSState>>;

        #[cfg(feature = "MPSState")]
        /// Return a descriptor suitable for allocating a NSArray to receive the result
        ///
        /// The object properties (kernelSize, offsets, edgeMode, etc.) should be properly
        /// configured as if the -encode call was about to be made, before this method is
        /// called. Those properties may affect the results.
        ///
        /// Parameter `sources`: The list of sources passed into the -encode call
        ///
        /// Parameter `state`: The source state object, if any passed to the -encode call
        ///
        /// Returns: a valid MPSNDArrayDescriptor that may be used to create a MPSNDArray to used to
        /// hold the results of this kernel.
        #[unsafe(method(destinationArrayDescriptorForSourceArrays:sourceState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn destinationArrayDescriptorForSourceArrays_sourceState(
            &self,
            sources: &NSArray<MPSNDArray>,
            state: Option<&MPSState>,
        ) -> Retained<MPSNDArrayDescriptor>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryBase {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryBase {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    #[unsafe(super(MPSNDArrayMultiaryBase, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNDArrayMultiaryKernel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNDArrayMultiaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNDArrayMultiaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNDArrayMultiaryKernel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNDArrayMultiaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNDArrayMultiaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:sourceCount:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            coder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `sourceArrays`: The list of sources for the filter in a NSArray.
        /// Ordering to be defined by subclass
        ///
        /// Returns: A newly allocated MPSNDArray that will contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandBuffer:sourceArrays:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArrays(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_arrays: &NSArray<MPSNDArray>,
        ) -> Retained<MPSNDArray>;

        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `sourceArrays`: The list of sources for the filter in a NSArray.
        /// Ordering to be defined by subclass
        ///
        /// Parameter `destination`: The NDArray to receive the result
        #[unsafe(method(encodeToCommandBuffer:sourceArrays:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArrays_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_arrays: &NSArray<MPSNDArray>,
            destination: &MPSNDArray,
        );

        #[cfg(feature = "MPSState")]
        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `sourceArrays`: The list of sources for the filter in a NSArray.
        /// Ordering to be defined by subclass
        ///
        /// Parameter `outGradientState`: If non-nil, the address output gradient state is written to this address
        ///
        /// Parameter `outputStateIsTemporary`: If YES, the state if any will be allocated to contain temporary textures and buffers as needed
        ///
        /// Returns: A newly allocated MPSNDArray that will contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandBuffer:sourceArrays:resultState:outputStateIsTemporary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArrays_resultState_outputStateIsTemporary(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_arrays: &NSArray<MPSNDArray>,
            out_gradient_state: Option<&mut Option<Retained<MPSState>>>,
            output_state_is_temporary: bool,
        ) -> Retained<MPSNDArray>;

        #[cfg(feature = "MPSState")]
        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `sourceArrays`: The list of sources for the filter in a NSArray.
        /// Ordering to be defined by subclass
        ///
        /// Parameter `outGradientState`: The output gradient state to record the operation for later use by gradient
        ///
        /// Parameter `destination`: A destination array to contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandBuffer:sourceArrays:resultState:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArrays_resultState_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_arrays: &NSArray<MPSNDArray>,
            out_gradient_state: Option<&MPSState>,
            destination: &MPSNDArray,
        );

        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `encoder`: The MTLComputeCommandEncoder that the kernel will be encoded on
        ///
        /// Parameter `commandBuffer`: The command buffer into which to encode the kernel
        ///
        /// Parameter `sourceArrays`: The list of sources for the filter in a NSArray.
        /// Ordering to be defined by subclass
        ///
        /// Parameter `destination`: A destination array to contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandEncoder:commandBuffer:sourceArrays:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandEncoder_commandBuffer_sourceArrays_destinationArray(
            &self,
            encoder: Option<&ProtocolObject<dyn MTLComputeCommandEncoder>>,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            source_arrays: &NSArray<MPSNDArray>,
            destination: &MPSNDArray,
        );
    );
}

/// Methods declared on superclass `MPSNDArrayMultiaryBase`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryKernel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    #[unsafe(super(MPSNDArrayMultiaryBase, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNDArrayMultiaryGradientKernel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNDArrayMultiaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNDArrayMultiaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNDArrayMultiaryGradientKernel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNDArrayMultiaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNDArrayMultiaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryGradientKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:sourceCount:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            coder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Initialize a MPSNDArrayMultiaryKernel
        ///
        /// Parameter `device`: The device on which the kernel will run
        ///
        /// Parameter `count`: The maximum number of NDArrays read by the kernel
        ///
        /// Parameter `sourceGradientIndex`: The source index for which gradient will be calculated
        ///
        /// Returns: A valid MPSNDArrayMultiaryKernel, or nil if allocation failure.
        #[unsafe(method(initWithDevice:sourceCount:sourceGradientIndex:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount_sourceGradientIndex(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
            source_gradient_index: NSUInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSState")]
        #[unsafe(method(encodeToCommandBuffer:sourceArrays:sourceGradient:gradientState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArrays_sourceGradient_gradientState(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            sources: &NSArray<MPSNDArray>,
            gradient: &MPSNDArray,
            state: &MPSState,
        ) -> Retained<MPSNDArray>;

        #[cfg(feature = "MPSState")]
        #[unsafe(method(encodeToCommandBuffer:sourceArrays:sourceGradient:gradientState:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArrays_sourceGradient_gradientState_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            sources: &NSArray<MPSNDArray>,
            gradient: &MPSNDArray,
            state: &MPSState,
            destination: &MPSNDArray,
        );
    );
}

/// Methods declared on superclass `MPSNDArrayMultiaryBase`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryGradientKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryGradientKernel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayMultiaryGradientKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    #[unsafe(super(MPSNDArrayMultiaryKernel, MPSNDArrayMultiaryBase, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNDArrayUnaryKernel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNDArrayUnaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNDArrayUnaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNDArrayUnaryKernel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNDArrayUnaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNDArrayUnaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayUnaryKernel {
    extern_methods!(
        #[cfg(feature = "MPSNDArrayTypes")]
        /// The coordinate of the position read from this source array which is
        /// used to calculate the result value at [0,0,0,....]
        /// If the position read is actually a contiguous region (e.g. the area covered by
        /// a convolution kernel) then this is the center of that region, rounded down, for
        /// each dimension.
        /// Default: 0,0,0...
        #[deprecated]
        #[unsafe(method(offsets))]
        #[unsafe(method_family = none)]
        pub unsafe fn offsets(&self) -> MPSNDArrayOffsets;

        #[cfg(feature = "MPSCoreTypes")]
        /// The edge mode used for a source NDArray
        /// Default: MPSImageEdgeModeZero
        #[deprecated]
        #[unsafe(method(edgeMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn edgeMode(&self) -> MPSImageEdgeMode;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// The diameters of the point spread function in each dimension for a source NDArray
        /// Default: 1
        #[deprecated]
        #[unsafe(method(kernelSizes))]
        #[unsafe(method_family = none)]
        pub unsafe fn kernelSizes(&self) -> MPSNDArraySizes;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// If the filter is a "backwards" filter such as a gradient filter
        /// or convolution transpose, then this is the upsampling ratio and
        /// zeros are inserted in the result.
        /// Default: 1
        #[deprecated]
        #[unsafe(method(strides))]
        #[unsafe(method_family = none)]
        pub unsafe fn strides(&self) -> MPSNDArrayOffsets;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// The stride in each dimension from one PSF tap to an adjacent
        /// PSF tap. Default: 1
        #[deprecated]
        #[unsafe(method(dilationRates))]
        #[unsafe(method_family = none)]
        pub unsafe fn dilationRates(&self) -> MPSNDArraySizes;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:sourceCount:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            coder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `sourceArray`: The source for the filter in an NSArray.
        ///
        /// Returns: A newly allocated MPSNDArray that will contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandBuffer:sourceArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_array: &MPSNDArray,
        ) -> Retained<MPSNDArray>;

        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `sourceArray`: The source for the filter in an NSArray.
        ///
        /// Parameter `destination`: The NDArray to receive the result
        #[unsafe(method(encodeToCommandBuffer:sourceArray:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArray_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_array: &MPSNDArray,
            destination: &MPSNDArray,
        );

        #[cfg(feature = "MPSState")]
        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `sourceArray`: The source for the filter in an NSArray.
        ///
        /// Parameter `outGradientState`: If non-nil, the address output gradient state is written to this address
        ///
        /// Parameter `outputStateIsTemporary`: If YES, the state if any will be allocated to contain temporary textures and buffers as needed
        ///
        /// Returns: A newly allocated MPSNDArray that will contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandBuffer:sourceArray:resultState:outputStateIsTemporary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArray_resultState_outputStateIsTemporary(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_array: &MPSNDArray,
            out_gradient_state: Option<&mut Option<Retained<MPSState>>>,
            output_state_is_temporary: bool,
        ) -> Retained<MPSNDArray>;

        #[cfg(feature = "MPSState")]
        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `sourceArray`: The source for the filter in an NSArray.
        ///
        /// Parameter `outGradientState`: The output gradient state to record the operation for later use by gradient
        ///
        /// Parameter `destination`: A destination array to contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandBuffer:sourceArray:resultState:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArray_resultState_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_array: &MPSNDArray,
            out_gradient_state: Option<&MPSState>,
            destination: &MPSNDArray,
        );
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayUnaryKernel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayUnaryKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    #[unsafe(super(
        MPSNDArrayMultiaryGradientKernel,
        MPSNDArrayMultiaryBase,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNDArrayUnaryGradientKernel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNDArrayUnaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNDArrayUnaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNDArrayUnaryGradientKernel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNDArrayUnaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNDArrayUnaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayUnaryGradientKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:sourceCount:sourceGradientIndex:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount_sourceGradientIndex(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
            source_gradient_index: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            coder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSState")]
        #[unsafe(method(encodeToCommandBuffer:sourceArray:sourceGradient:gradientState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArray_sourceGradient_gradientState(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_array: &MPSNDArray,
            gradient: &MPSNDArray,
            state: &MPSState,
        ) -> Retained<MPSNDArray>;

        #[cfg(feature = "MPSState")]
        #[unsafe(method(encodeToCommandBuffer:sourceArray:sourceGradient:gradientState:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_sourceArray_sourceGradient_gradientState_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            source_array: &MPSNDArray,
            gradient: &MPSNDArray,
            state: &MPSState,
            destination: &MPSNDArray,
        );
    );
}

/// Methods declared on superclass `MPSNDArrayMultiaryGradientKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayUnaryGradientKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:sourceCount:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayUnaryGradientKernel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayUnaryGradientKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    #[unsafe(super(MPSNDArrayMultiaryKernel, MPSNDArrayMultiaryBase, MPSKernel, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNDArrayBinaryKernel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNDArrayBinaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNDArrayBinaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNDArrayBinaryKernel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNDArrayBinaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNDArrayBinaryKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinaryKernel {
    extern_methods!(
        #[cfg(feature = "MPSNDArrayTypes")]
        /// The coordinate of the position read from this source array which is
        /// used to calculate the result value at [0,0,0,....]
        /// If the position read is actually a contiguous region (e.g. the area covered by
        /// a convolution kernel) then this is the center of that region, rounded down, for
        /// each dimension.
        /// Default: 0,0,0...
        #[deprecated]
        #[unsafe(method(primaryOffsets))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryOffsets(&self) -> MPSNDArrayOffsets;

        #[cfg(feature = "MPSCoreTypes")]
        /// The edge mode used for a source NDArray
        /// Default: MPSImageEdgeModeZero
        #[deprecated]
        #[unsafe(method(primaryEdgeMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryEdgeMode(&self) -> MPSImageEdgeMode;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// The diameters of the point spread function in each dimension for a source NDArray
        /// Default: 1
        #[deprecated]
        #[unsafe(method(primaryKernelSizes))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryKernelSizes(&self) -> MPSNDArraySizes;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// If the filter is a "backwards" filter such as a gradient filter
        /// or convolution transpose, then this is the upsampling ratio and
        /// zeros are inserted in the result.
        /// Default: 1
        #[deprecated]
        #[unsafe(method(primaryStrides))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryStrides(&self) -> MPSNDArrayOffsets;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// The stride in each dimension from one PSF tap to an adjacent
        /// PSF tap. Default: 1
        #[deprecated]
        #[unsafe(method(primaryDilationRates))]
        #[unsafe(method_family = none)]
        pub unsafe fn primaryDilationRates(&self) -> MPSNDArraySizes;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// The coordinate of the position read from this source array which is
        /// used to calculate the result value at [0,0,0,....]
        /// If the position read is actually a contiguous region (e.g. the area covered by
        /// a convolution kernel) then this is the center of that region, rounded down, for
        /// each dimension.
        /// Default: 0,0,0...
        #[deprecated]
        #[unsafe(method(secondaryOffsets))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryOffsets(&self) -> MPSNDArrayOffsets;

        #[cfg(feature = "MPSCoreTypes")]
        /// The edge mode used for a source NDArray
        /// Default: MPSImageEdgeModeZero
        #[deprecated]
        #[unsafe(method(secondaryEdgeMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryEdgeMode(&self) -> MPSImageEdgeMode;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// The diameters of the point spread function in each dimension for a source NDArray
        /// Default: 1
        #[deprecated]
        #[unsafe(method(secondaryKernelSizes))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryKernelSizes(&self) -> MPSNDArraySizes;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// If the filter is a "backwards" filter such as a gradient filter
        /// or convolution transpose, then this is the upsampling ratio and
        /// zeros are inserted in the result.
        /// Default: 1
        #[deprecated]
        #[unsafe(method(secondaryStrides))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryStrides(&self) -> MPSNDArrayOffsets;

        #[cfg(feature = "MPSNDArrayTypes")]
        /// The stride in each dimension from one PSF tap to an adjacent
        /// PSF tap. Default: 1
        #[deprecated]
        #[unsafe(method(secondaryDilationRates))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondaryDilationRates(&self) -> MPSNDArraySizes;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:sourceCount:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            coder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `primarySourceArray`: The primary source for the filter in an NSArray.
        ///
        /// Parameter `secondarySourceArray`: The secondary source for the filter in an NSArray.
        ///
        /// Returns: A newly allocated MPSNDArray that will contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandBuffer:primarySourceArray:secondarySourceArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primarySourceArray_secondarySourceArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_source_array: &MPSNDArray,
            secondary_source_array: &MPSNDArray,
        ) -> Retained<MPSNDArray>;

        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `primarySourceArray`: The primary source for the filter in an NSArray.
        ///
        /// Parameter `secondarySourceArray`: The secondary source for the filter in an NSArray.
        ///
        /// Parameter `destination`: The NDArray to receive the result
        #[unsafe(method(encodeToCommandBuffer:primarySourceArray:secondarySourceArray:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primarySourceArray_secondarySourceArray_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_source_array: &MPSNDArray,
            secondary_source_array: &MPSNDArray,
            destination: &MPSNDArray,
        );

        #[cfg(feature = "MPSState")]
        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `primarySourceArray`: The primary source for the filter in an NSArray.
        ///
        /// Parameter `secondarySourceArray`: The secondary source for the filter in an NSArray.
        ///
        /// Parameter `outGradientState`: If non-nil, the address output gradient state is written to this address
        ///
        /// Parameter `outputStateIsTemporary`: If YES, the state if any will be allocated to contain temporary textures and buffers as needed
        ///
        /// Returns: A newly allocated MPSNDArray that will contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandBuffer:primarySourceArray:secondarySourceArray:resultState:outputStateIsTemporary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primarySourceArray_secondarySourceArray_resultState_outputStateIsTemporary(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_source_array: &MPSNDArray,
            secondary_source_array: &MPSNDArray,
            out_gradient_state: Option<&mut Option<Retained<MPSState>>>,
            output_state_is_temporary: bool,
        ) -> Retained<MPSNDArray>;

        #[cfg(feature = "MPSState")]
        /// Encode a simple inference NDArray kernel and return a NDArray to hold the result
        ///
        /// Parameter `cmdBuf`: The command buffer into which to encode the kernel
        ///
        /// Parameter `primarySourceArray`: The primary source for the filter in an NSArray.
        ///
        /// Parameter `secondarySourceArray`: The secondary source for the filter in an NSArray.
        ///
        /// Parameter `outGradientState`: The output gradient state to record the operation for later use by gradient
        ///
        /// Parameter `destination`: A destination array to contain the result of the calculation
        /// when the command buffer completes successfully.
        #[unsafe(method(encodeToCommandBuffer:primarySourceArray:secondarySourceArray:resultState:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primarySourceArray_secondarySourceArray_resultState_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_source_array: &MPSNDArray,
            secondary_source_array: &MPSNDArray,
            out_gradient_state: Option<&MPSState>,
            destination: &MPSNDArray,
        );
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinaryKernel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinaryKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    #[unsafe(super(
        MPSNDArrayMultiaryGradientKernel,
        MPSNDArrayMultiaryBase,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNDArrayBinaryPrimaryGradientKernel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNDArrayBinaryPrimaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNDArrayBinaryPrimaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNDArrayBinaryPrimaryGradientKernel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNDArrayBinaryPrimaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNDArrayBinaryPrimaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinaryPrimaryGradientKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:sourceCount:sourceGradientIndex:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount_sourceGradientIndex(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
            source_gradient_index: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            coder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSState")]
        #[unsafe(method(encodeToCommandBuffer:primarySourceArray:secondarySourceArray:sourceGradient:gradientState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primarySourceArray_secondarySourceArray_sourceGradient_gradientState(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_source_array: &MPSNDArray,
            secondary_source_array: &MPSNDArray,
            gradient: &MPSNDArray,
            state: &MPSState,
        ) -> Retained<MPSNDArray>;

        #[cfg(feature = "MPSState")]
        #[unsafe(method(encodeToCommandBuffer:primarySourceArray:secondarySourceArray:sourceGradient:gradientState:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primarySourceArray_secondarySourceArray_sourceGradient_gradientState_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_source_array: &MPSNDArray,
            secondary_source_array: &MPSNDArray,
            gradient: &MPSNDArray,
            state: &MPSState,
            destination: &MPSNDArray,
        );
    );
}

/// Methods declared on superclass `MPSNDArrayMultiaryGradientKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinaryPrimaryGradientKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:sourceCount:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinaryPrimaryGradientKernel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinaryPrimaryGradientKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework.
    #[unsafe(super(
        MPSNDArrayMultiaryGradientKernel,
        MPSNDArrayMultiaryBase,
        MPSKernel,
        NSObject
    ))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
    pub struct MPSNDArrayBinarySecondaryGradientKernel;
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCoding for MPSNDArrayBinarySecondaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSCopying for MPSNDArrayBinarySecondaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
unsafe impl CopyingHelper for MPSNDArrayBinarySecondaryGradientKernel {
    type Result = Self;
}

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for MPSNDArrayBinarySecondaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
extern_conformance!(
    unsafe impl NSSecureCoding for MPSNDArrayBinarySecondaryGradientKernel {}
);

#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinarySecondaryGradientKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:sourceCount:sourceGradientIndex:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount_sourceGradientIndex(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
            source_gradient_index: NSUInteger,
        ) -> Retained<Self>;

        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            coder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSState")]
        #[unsafe(method(encodeToCommandBuffer:primarySourceArray:secondarySourceArray:sourceGradient:gradientState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primarySourceArray_secondarySourceArray_sourceGradient_gradientState(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_source_array: &MPSNDArray,
            secondary_source_array: &MPSNDArray,
            gradient: &MPSNDArray,
            state: &MPSState,
        ) -> Retained<MPSNDArray>;

        #[cfg(feature = "MPSState")]
        #[unsafe(method(encodeToCommandBuffer:primarySourceArray:secondarySourceArray:sourceGradient:gradientState:destinationArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeToCommandBuffer_primarySourceArray_secondarySourceArray_sourceGradient_gradientState_destinationArray(
            &self,
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            primary_source_array: &MPSNDArray,
            secondary_source_array: &MPSNDArray,
            gradient: &MPSNDArray,
            state: &MPSState,
            destination: &MPSNDArray,
        );
    );
}

/// Methods declared on superclass `MPSNDArrayMultiaryGradientKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinarySecondaryGradientKernel {
    extern_methods!(
        #[unsafe(method(initWithDevice:sourceCount:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_sourceCount(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            count: NSUInteger,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `MPSKernel`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinarySecondaryGradientKernel {
    extern_methods!(
        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "MPSCore", feature = "MPSKernel"))]
impl MPSNDArrayBinarySecondaryGradientKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
