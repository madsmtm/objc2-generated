//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    ///
    /// A MPSMatrixDescriptor describes the sizes, strides, and data type of a
    /// an array of 2-dimensional matrices.  All storage is assumed to be in
    /// "matrix-major".  See the description for MPSMatrix for further details.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsmatrixdescriptor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSMatrixDescriptor;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSMatrixDescriptor {}
);

impl MPSMatrixDescriptor {
    extern_methods!(
        /// The number of rows in a matrix.
        #[unsafe(method(rows))]
        #[unsafe(method_family = none)]
        pub unsafe fn rows(&self) -> NSUInteger;

        /// Setter for [`rows`][Self::rows].
        #[unsafe(method(setRows:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRows(&self, rows: NSUInteger);

        /// The number of columns in a matrix.
        #[unsafe(method(columns))]
        #[unsafe(method_family = none)]
        pub unsafe fn columns(&self) -> NSUInteger;

        /// Setter for [`columns`][Self::columns].
        #[unsafe(method(setColumns:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setColumns(&self, columns: NSUInteger);

        /// The number of matrices.
        #[unsafe(method(matrices))]
        #[unsafe(method_family = none)]
        pub unsafe fn matrices(&self) -> NSUInteger;

        #[cfg(feature = "MPSCoreTypes")]
        /// The type of the data which makes up the values of the matrix.
        #[unsafe(method(dataType))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataType(&self) -> MPSDataType;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`dataType`][Self::dataType].
        #[unsafe(method(setDataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDataType(&self, data_type: MPSDataType);

        /// The stride, in bytes, between corresponding elements of
        /// consecutive rows.  Must be a multiple of the element size.
        #[unsafe(method(rowBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn rowBytes(&self) -> NSUInteger;

        /// Setter for [`rowBytes`][Self::rowBytes].
        #[unsafe(method(setRowBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRowBytes(&self, row_bytes: NSUInteger);

        /// The stride, in bytes, between corresponding elements of
        /// consecutive matrices.  Must be a multiple of rowBytes.
        #[unsafe(method(matrixBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn matrixBytes(&self) -> NSUInteger;

        #[cfg(feature = "MPSCoreTypes")]
        /// Create a MPSMatrixDescriptor with the specified dimensions and data type.
        ///
        ///
        /// Parameter `rows`: The number of rows of the matrix.
        ///
        ///
        /// Parameter `columns`: The number of columns of the matrix.
        ///
        ///
        /// Parameter `rowBytes`: The number of bytes between starting elements of consecutive
        /// rows.  Must be a multiple of the element size.
        ///
        ///
        /// Parameter `dataType`: The type of the data to be stored in the matrix.
        ///
        ///
        /// For performance considerations the optimal row stride may not necessarily be equal
        /// to the number of columns in the matrix.  The MPSMatrix class provides a method which
        /// may be used to determine this value, see the rowBytesForColumns API in the MPSMatrix
        /// class.
        /// The number of matrices described is initialized to 1.
        #[deprecated]
        #[unsafe(method(matrixDescriptorWithDimensions:columns:rowBytes:dataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn matrixDescriptorWithDimensions_columns_rowBytes_dataType(
            rows: NSUInteger,
            columns: NSUInteger,
            row_bytes: NSUInteger,
            data_type: MPSDataType,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSCoreTypes")]
        #[unsafe(method(matrixDescriptorWithRows:columns:rowBytes:dataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn matrixDescriptorWithRows_columns_rowBytes_dataType(
            rows: NSUInteger,
            columns: NSUInteger,
            row_bytes: NSUInteger,
            data_type: MPSDataType,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSCoreTypes")]
        /// Create a MPSMatrixDescriptor with the specified dimensions and data type.
        ///
        ///
        /// Parameter `rows`: The number of rows of a single matrix.
        ///
        ///
        /// Parameter `columns`: The number of columns of a single matrix.
        ///
        ///
        /// Parameter `matrices`: The number of matrices in the MPSMatrix object.
        ///
        ///
        /// Parameter `rowBytes`: The number of bytes between starting elements of consecutive
        /// rows.  Must be a multiple of the element size.
        ///
        ///
        /// Parameter `matrixBytes`: The number of bytes between starting elements of consecutive
        /// matrices.  Must be a multiple of rowBytes.
        ///
        ///
        /// Parameter `dataType`: The type of the data to be stored in the matrix.
        ///
        ///
        /// For performance considerations the optimal row stride may not necessarily be equal
        /// to the number of columns in the matrix.  The MPSMatrix class provides a method which
        /// may be used to determine this value, see the rowBytesForColumns API in the MPSMatrix
        /// class.
        #[unsafe(method(matrixDescriptorWithRows:columns:matrices:rowBytes:matrixBytes:dataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn matrixDescriptorWithRows_columns_matrices_rowBytes_matrixBytes_dataType(
            rows: NSUInteger,
            columns: NSUInteger,
            matrices: NSUInteger,
            row_bytes: NSUInteger,
            matrix_bytes: NSUInteger,
            data_type: MPSDataType,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSCoreTypes")]
        /// Return the recommended row stride, in bytes, for a given number of
        /// columns.
        ///
        ///
        /// Parameter `columns`: The number of columns in the matrix for which the recommended
        /// row stride, in bytes, is to be determined.
        ///
        ///
        /// Parameter `dataType`: The type of matrix data values.
        ///
        ///
        /// To achieve best performance the optimal stride between rows of a matrix is not
        /// necessarily equivalent to the number of columns.  This method returns the row stride, in
        /// bytes, which gives best performance for a given number of columns.  Using this row stride
        /// to construct your array is recommended, but not required (provided that the stride
        /// used is still large enough to allocate a full row of data).
        #[deprecated]
        #[unsafe(method(rowBytesFromColumns:dataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rowBytesFromColumns_dataType(
            columns: NSUInteger,
            data_type: MPSDataType,
        ) -> usize;

        #[cfg(feature = "MPSCoreTypes")]
        #[unsafe(method(rowBytesForColumns:dataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rowBytesForColumns_dataType(
            columns: NSUInteger,
            data_type: MPSDataType,
        ) -> usize;
    );
}

/// Methods declared on superclass `NSObject`.
impl MPSMatrixDescriptor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    ///
    /// A MPSVectorDescriptor describes the length and data type of a
    /// an array of 1-dimensional vectors.  All vectors are stored as
    /// contiguous arrays of data.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsvectordescriptor?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSVectorDescriptor;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSVectorDescriptor {}
);

impl MPSVectorDescriptor {
    extern_methods!(
        /// The number of elements in the vector.
        #[unsafe(method(length))]
        #[unsafe(method_family = none)]
        pub unsafe fn length(&self) -> NSUInteger;

        /// Setter for [`length`][Self::length].
        #[unsafe(method(setLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLength(&self, length: NSUInteger);

        /// The number of vectors.
        #[unsafe(method(vectors))]
        #[unsafe(method_family = none)]
        pub unsafe fn vectors(&self) -> NSUInteger;

        #[cfg(feature = "MPSCoreTypes")]
        /// The type of the data which makes up the values of the vector.
        #[unsafe(method(dataType))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataType(&self) -> MPSDataType;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`dataType`][Self::dataType].
        #[unsafe(method(setDataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDataType(&self, data_type: MPSDataType);

        /// The stride, in bytes, between corresponding elements of
        /// consecutive vectors.  Must be a multiple of the element size
        #[unsafe(method(vectorBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn vectorBytes(&self) -> NSUInteger;

        #[cfg(feature = "MPSCoreTypes")]
        /// Create a MPSVectorDescriptor with the specified length and data type.
        ///
        ///
        /// Parameter `length`: The number of elements in a single vector.
        ///
        ///
        /// Parameter `dataType`: The type of the data to be stored in the vector.
        ///
        ///
        /// Use this function for creating a descriptor of a MPSVector object
        /// containing a single vector.
        #[unsafe(method(vectorDescriptorWithLength:dataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn vectorDescriptorWithLength_dataType(
            length: NSUInteger,
            data_type: MPSDataType,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSCoreTypes")]
        /// Create a MPSVectorDescriptor with the specified length and data type.
        ///
        ///
        /// Parameter `length`: The number of elements in a single vector.
        ///
        ///
        /// Parameter `vectors`: The number of vectors in the MPSVector object.
        ///
        ///
        /// Parameter `vectorBytes`: The number of bytes between starting elements of consecutive
        /// vectors.
        ///
        ///
        /// Parameter `dataType`: The type of the data to be stored in the vector.
        ///
        ///
        /// For performance considerations the optimal stride between vectors may not necessarily be equal
        /// to the vector length.  The MPSVectorDescriptor class provides a method which
        /// may be used to determine this value, see the vectorBytesForLength API.
        #[unsafe(method(vectorDescriptorWithLength:vectors:vectorBytes:dataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn vectorDescriptorWithLength_vectors_vectorBytes_dataType(
            length: NSUInteger,
            vectors: NSUInteger,
            vector_bytes: NSUInteger,
            data_type: MPSDataType,
        ) -> Retained<Self>;

        #[cfg(feature = "MPSCoreTypes")]
        /// Return the recommended stride, in bytes, to be used for an array
        /// of vectors of a given length.
        ///
        ///
        /// Parameter `length`: The number of elements in a single vector.
        ///
        ///
        /// Parameter `dataType`: The type of vector data values.
        ///
        ///
        /// To achieve best performance the optimal stride between vectors within an array of
        /// vectors is not necessarily equivalent to the number of elements per vector.  This method
        /// returns the stride, in bytes, which gives best performance for a given vector length.
        /// Using this stride to construct your array is recommended, but not required (provided that
        /// the stride used is still large enough to allocate a full vector of data).
        #[unsafe(method(vectorBytesForLength:dataType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn vectorBytesForLength_dataType(
            length: NSUInteger,
            data_type: MPSDataType,
        ) -> usize;
    );
}

/// Methods declared on superclass `NSObject`.
impl MPSVectorDescriptor {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    ///
    /// A MPSMatrix object describes a set of 2-dimensional arrays of data and provides storage
    /// for its values.  MPSMatrix objects serve as inputs and outputs of MPSMatrixKernel
    /// objects.
    ///
    /// Implementation note:
    /// A MPSMatrix object maintains its internal storage using a MTLBuffer object and thus
    /// the same rules for maintaining coherency of a MTLBuffer's data between CPU memory and GPU
    /// memory apply to a MPSMatrix.  An MPSMatrix object's data refers to an array of matrices.
    /// Data is assumed to be ordered by matrix first, followed by row, followed by column.
    ///
    /// For example, index [i,j] of the k'th matrix of an MPSMatrix is located at byte offset:
    /// k * matrixBytes + i * rowBytes + j * sizeof(dataType)
    ///
    /// Where matrixBytes is a multiple of rowBytes at least equal to rows * rowBytes.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsmatrix?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSMatrix;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSMatrix {}
);

impl MPSMatrix {
    extern_methods!(
        /// The device on which the MPSMatrix will be used.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        pub unsafe fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        /// The number of rows in a matrix in the MPSMatrix.
        #[unsafe(method(rows))]
        #[unsafe(method_family = none)]
        pub unsafe fn rows(&self) -> NSUInteger;

        /// The number of columns in a matrix in the MPSMatrix.
        #[unsafe(method(columns))]
        #[unsafe(method_family = none)]
        pub unsafe fn columns(&self) -> NSUInteger;

        /// The number of matrices in the MPSMatrix.
        #[unsafe(method(matrices))]
        #[unsafe(method_family = none)]
        pub unsafe fn matrices(&self) -> NSUInteger;

        #[cfg(feature = "MPSCoreTypes")]
        /// The type of the MPSMatrix data.
        #[unsafe(method(dataType))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataType(&self) -> MPSDataType;

        /// The stride, in bytes, between corresponding elements of
        /// consecutive rows.
        #[unsafe(method(rowBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn rowBytes(&self) -> NSUInteger;

        /// The stride, in bytes, between corresponding elements of
        /// consecutive matrices.
        #[unsafe(method(matrixBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn matrixBytes(&self) -> NSUInteger;

        /// Byte-offset to the buffer where the matrix data begins - see
        /// initWithBuffer:offset: descriptor: .
        #[unsafe(method(offset))]
        #[unsafe(method_family = none)]
        pub unsafe fn offset(&self) -> NSUInteger;

        /// An MTLBuffer to store the data.
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Retained<ProtocolObject<dyn MTLBuffer>>;

        /// Initialize a MPSMatrix object with a MTLBuffer.
        ///
        ///
        /// Parameter `buffer`: The MTLBuffer object which contains the data to use for the
        /// MPSMatrix. May not be NULL.
        ///
        ///
        /// Parameter `descriptor`: The MPSMatrixDescriptor. May not be NULL.
        ///
        ///
        /// Returns: A valid MPSMatrix object or nil, if failure.
        ///
        ///
        /// This function returns a MPSMatrix object which uses the supplied MTLBuffer.  The
        /// dimensions and stride of the matrix are specified by the MPSMatrixDescriptor object.
        ///
        /// The provided MTLBuffer must have enough storage to hold
        ///
        /// (descriptor.matrices-1) * descriptor.matrixBytes +
        /// (descriptor.rows-1) * descriptor.rowBytes +
        /// descriptor.columns * (element size) bytes.
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(initWithBuffer:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBuffer_descriptor(
            this: Allocated<Self>,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            descriptor: &MPSMatrixDescriptor,
        ) -> Retained<Self>;

        /// Initialize a MPSMatrix object with a MTLBuffer at a given offset.
        ///
        ///
        /// Parameter `buffer`: The MTLBuffer object which contains the data to use for the
        /// MPSMatrix.  May not be NULL.
        ///
        ///
        /// Parameter `offset`: The offset, in bytes, into the buffer at which the data begins.
        ///
        ///
        /// Parameter `descriptor`: The MPSMatrixDescriptor describing the shape of the matrix.
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(initWithBuffer:offset:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBuffer_offset_descriptor(
            this: Allocated<Self>,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            descriptor: &MPSMatrixDescriptor,
        ) -> Retained<Self>;

        /// Initialize a MPSMatrix object with a descriptor. Allocate the buffer.
        ///
        /// Parameter `device`: The device with which it will be used
        ///
        /// Parameter `descriptor`: The shape and style of the matrix
        ///
        /// Returns: A valid MPSMatrix object or nil
        ///
        /// The matrix object will be created, but the storage to hold the
        /// matrix data will only be allocated when it is needed, typically
        /// when the data property is invoked.  In conjunction
        /// with -resourceSize, this will allow you to estimate storage needs
        /// without actually creating the backing store for the matrix.
        #[unsafe(method(initWithDevice:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_descriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            descriptor: &MPSMatrixDescriptor,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Flush the underlying MTLBuffer from the device's caches, and invalidate any CPU caches if needed.
        ///
        /// This will call [id
        /// <MTLBlitEncoder
        /// > synchronizeResource: ] on the matrix's MTLBuffer, if any.
        /// This is necessary for all MTLStorageModeManaged resources. For other resources, including temporary
        /// resources (these are all MTLStorageModePrivate), and buffers that have not yet been allocated, nothing is done.
        /// It is more efficient to use this method than to attempt to do this yourself with the data property.
        ///
        /// Parameter `commandBuffer`: The commandbuffer on which to synchronize
        #[unsafe(method(synchronizeOnCommandBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn synchronizeOnCommandBuffer(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
        );

        /// Get the number of bytes used to allocate underyling MTLResources
        ///
        /// This is the size of the backing store of underlying MTLResources.
        /// It does not include all storage used by the object, for example
        /// the storage used to hold the MPSMatrix instantiation and MTLBuffer
        /// is not included. It only measures the size of the allocation used
        /// to hold the matrix data in the buffer. This value is subject to
        /// change between different devices and operating systems.
        ///
        /// Except when -initWithBuffer:descriptor: is used, most MPSMatrixes are allocated
        /// without a backing store. The backing store is allocated lazily when
        /// it is needed, typically when the .texture property is called.
        /// Consequently, in most cases, it should be inexpensive to make
        /// a MPSImage to see how much memory it will need, and release it
        /// if it is too large.
        ///
        /// This method may fail in certain circumstances, such as when the
        /// MPSImage is created with -initWithTexture:featureChannels:. In
        /// such cases, 0 will be returned.
        #[unsafe(method(resourceSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn resourceSize(&self) -> NSUInteger;
    );
}

/// Methods declared on superclass `NSObject`.
impl MPSMatrix {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Dependencies: This depends on Metal.framework
    ///
    ///
    /// A MPSVector object describes a 1-dimensional array of data and provides storage
    /// for its values.  Some MPSMatrixKernel objects operate on MPSVector objects
    /// for convenience.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsvector?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSVector;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSVector {}
);

impl MPSVector {
    extern_methods!(
        /// The device on which the MPSVector will be used.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        pub unsafe fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        /// The number of elements in the vector.
        #[unsafe(method(length))]
        #[unsafe(method_family = none)]
        pub unsafe fn length(&self) -> NSUInteger;

        /// The number of vectors in the MPSVector.
        #[unsafe(method(vectors))]
        #[unsafe(method_family = none)]
        pub unsafe fn vectors(&self) -> NSUInteger;

        #[cfg(feature = "MPSCoreTypes")]
        /// The type of the MPSVector data.
        #[unsafe(method(dataType))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataType(&self) -> MPSDataType;

        /// The stride, in bytes, between corresponding elements of
        /// consecutive vectors.
        #[unsafe(method(vectorBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn vectorBytes(&self) -> NSUInteger;

        /// Byte-offset to the buffer where the vector data begins - see
        /// initWithBuffer:offset: descriptor: .
        #[unsafe(method(offset))]
        #[unsafe(method_family = none)]
        pub unsafe fn offset(&self) -> NSUInteger;

        /// An MTLBuffer to store the data.
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Retained<ProtocolObject<dyn MTLBuffer>>;

        /// Initialize a MPSVector object with a MTLBuffer.
        ///
        ///
        /// Parameter `buffer`: The MTLBuffer object which contains the data to use for the
        /// MPSVector. May not be NULL.
        ///
        ///
        /// Parameter `descriptor`: The MPSVectorDescriptor. May not be NULL.
        ///
        ///
        /// Returns: A valid MPSVector object or nil, if failure.
        ///
        ///
        /// This function returns a MPSVector object which uses the supplied MTLBuffer.  The
        /// length, number of vectors, and stride between vectors are specified by the
        /// MPSVectorDescriptor object.
        ///
        /// The provided MTLBuffer must have enough storage to hold
        ///
        /// (descriptor.vectors-1) * descriptor.vectorBytes +
        /// descriptor.length * (element size) bytes.
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(initWithBuffer:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBuffer_descriptor(
            this: Allocated<Self>,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            descriptor: &MPSVectorDescriptor,
        ) -> Retained<Self>;

        /// Initialize a MPSVector object with a MTLBuffer and an offset.
        ///
        ///
        /// Parameter `buffer`: The MTLBuffer containing the data.
        ///
        ///
        /// Parameter `offset`: The offset, in bytes, into the buffer at which data begins.
        ///
        ///
        /// Parameter `descriptor`: The MPSVectorDescriptor.
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(initWithBuffer:offset:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBuffer_offset_descriptor(
            this: Allocated<Self>,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            descriptor: &MPSVectorDescriptor,
        ) -> Retained<Self>;

        /// Initialize a lazily backed MPSVector object with a descriptor
        ///
        /// Parameter `device`: The device with which it will be used
        ///
        /// Parameter `descriptor`: The shape and style of the matrix
        ///
        /// Returns: A valid MPSVector object or nil
        ///
        /// The vector object will be created, but the storage to hold the
        /// vector data will only be allocated when it is needed, typically
        /// when the data property is invoked.  In conjunction
        /// with -resourceSize, this will allow you to estimate storage needs
        /// without actually creating the backing store for the vector.
        #[unsafe(method(initWithDevice:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_descriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            descriptor: &MPSVectorDescriptor,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Flush the underlying MTLBuffer from the device's caches, and invalidate any CPU caches if needed.
        ///
        /// This will call [id
        /// <MTLBlitEncoder
        /// > synchronizeResource: ] on the vector's MTLBuffer, if any.
        /// This is necessary for all MTLStorageModeManaged resources. For other resources, including temporary
        /// resources (these are all MTLStorageModePrivate), and buffers that have not yet been allocated, nothing is done.
        /// It is more efficient to use this method than to attempt to do this yourself with the data property.
        ///
        /// Parameter `commandBuffer`: The commandbuffer on which to synchronize
        #[unsafe(method(synchronizeOnCommandBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn synchronizeOnCommandBuffer(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
        );

        /// Get the number of bytes used to allocate underyling MTLResources
        ///
        /// This is the size of the backing store of underlying MTLResources.
        /// It does not include all storage used by the object, for example
        /// the storage used to hold the MPSVector instantiation and MTLBuffer
        /// is not included. It only measures the size of the allocation used
        /// to hold the vector data in the buffer. This value is subject to
        /// change between different devices and operating systems.
        ///
        /// Except when -initWithBuffer:descriptor: is used, most MPSVectors are allocated
        /// without a backing store. The backing store is allocated lazily when
        /// it is needed, typically when the .texture property is called.
        /// Consequently, in most cases, it should be inexpensive to make
        /// a MPSMatrix to see how much memory it will need, and release it
        /// if it is too large.
        ///
        /// This method may fail in certain circumstances, such as when the
        /// MPSMatrix is created with -initWithBuffer:descriptor:. In
        /// such cases, 0 will be returned.
        #[unsafe(method(resourceSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn resourceSize(&self) -> NSUInteger;
    );
}

/// Methods declared on superclass `NSObject`.
impl MPSVector {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A MPSMatrix allocated on GPU private memory.
    ///
    /// It may alias one or more other MPSTemporaryMatrices. Undesired data destruction
    /// due to aliasing is avoided using the readCount property.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpstemporarymatrix?language=objc)
    #[unsafe(super(MPSMatrix, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSTemporaryMatrix;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSTemporaryMatrix {}
);

impl MPSTemporaryMatrix {
    extern_methods!(
        /// Initialize a MPSTemporaryMatrix for use on a MTLCommandBuffer
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which the MPSTemporaryMatrix will be exclusively used
        ///
        /// Parameter `matrixDescriptor`: A valid MPSMatrixDescriptor describing the MPSMatrix format to create
        ///
        /// Returns: A valid MPSTemporaryMatrix.  The object is not managed by a NSAutoreleasePool. The object will be
        /// released when the command buffer is committed. The underlying buffer will become invalid before
        /// this time due to the action of the readCount property.  Please read and understand the use of
        /// the readCount property before using this object.
        #[unsafe(method(temporaryMatrixWithCommandBuffer:matrixDescriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryMatrixWithCommandBuffer_matrixDescriptor(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            matrix_descriptor: &MPSMatrixDescriptor,
        ) -> Retained<Self>;

        /// Help MPS decide which allocations to make ahead of time
        ///
        /// The buffer cache that underlies the MPSTemporaryMatrix can automatically allocate new storage as
        /// needed as you create new temporary matrices.  However, sometimes a more global view of what you
        /// plan to make is useful for maximizing memory reuse to get the most efficient operation.
        /// This class method hints to the cache what the list of matrices will be.
        ///
        /// It is never necessary to call this method. It is purely a performance and memory optimization.
        ///
        ///
        /// Parameter `commandBuffer`: The command buffer on which the MPSTemporaryMatrix will be used
        ///
        /// Parameter `descriptorList`: A NSArray of MPSMatrixDescriptor, indicating matrices that will be created
        #[unsafe(method(prefetchStorageWithCommandBuffer:matrixDescriptorList:))]
        #[unsafe(method_family = none)]
        pub unsafe fn prefetchStorageWithCommandBuffer_matrixDescriptorList(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            descriptor_list: &NSArray<MPSMatrixDescriptor>,
        );

        /// *** unavailable
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(initWithBuffer:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBuffer_descriptor(
            this: Allocated<Self>,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            descriptor: &MPSMatrixDescriptor,
        ) -> Retained<Self>;

        /// The number of times a temporary matrix may be read by a MPSMatrix... kernel
        /// before its contents become undefined.
        ///
        ///
        /// MPSTemporaryMatrices must release their underlying buffers for reuse
        /// immediately after last use. So as to facilitate *prompt* convenient
        /// memory recycling, each time a MPSTemporaryMatrix is read by a
        /// MPSMatrix... -encode... method, its readCount is automatically
        /// decremented. When the readCount reaches 0, the underlying buffer is
        /// automatically made available for reuse to MPS for its own needs and for
        /// other MPSTemporaryMatrices prior to return from the -encode.. function.
        /// The contents of the buffer become undefined at this time.
        ///
        /// By default, the readCount is initialized to 1, indicating a matrix that
        /// may be overwritten any number of times, but read only once.
        ///
        /// You may change the readCount as desired to allow MPSMatrixKernels to read
        /// the MPSTemporaryMatrix additional times. However, it is an error to change
        /// the readCount once it is zero. It is an error to read or write to a
        /// MPSTemporaryMatrix with a zero readCount. You may set the readCount to 0
        /// yourself to cause the underlying buffer to be returned to MPS. Writing
        /// to a MPSTemporaryMatrix does not adjust the readCount.
        ///
        /// The Metal API Validation layer will assert if a MPSTemporaryMatrix is
        /// deallocated with non-zero readCount to help identify cases when resources
        /// are not returned promptly.
        #[unsafe(method(readCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn readCount(&self) -> NSUInteger;

        /// Setter for [`readCount`][Self::readCount].
        #[unsafe(method(setReadCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setReadCount(&self, read_count: NSUInteger);
    );
}

/// Methods declared on superclass `MPSMatrix`.
impl MPSTemporaryMatrix {
    extern_methods!(
        /// Initialize a MPSMatrix object with a MTLBuffer at a given offset.
        ///
        ///
        /// Parameter `buffer`: The MTLBuffer object which contains the data to use for the
        /// MPSMatrix.  May not be NULL.
        ///
        ///
        /// Parameter `offset`: The offset, in bytes, into the buffer at which the data begins.
        ///
        ///
        /// Parameter `descriptor`: The MPSMatrixDescriptor describing the shape of the matrix.
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(initWithBuffer:offset:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBuffer_offset_descriptor(
            this: Allocated<Self>,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            descriptor: &MPSMatrixDescriptor,
        ) -> Retained<Self>;

        /// Initialize a MPSMatrix object with a descriptor. Allocate the buffer.
        ///
        /// Parameter `device`: The device with which it will be used
        ///
        /// Parameter `descriptor`: The shape and style of the matrix
        ///
        /// Returns: A valid MPSMatrix object or nil
        ///
        /// The matrix object will be created, but the storage to hold the
        /// matrix data will only be allocated when it is needed, typically
        /// when the data property is invoked.  In conjunction
        /// with -resourceSize, this will allow you to estimate storage needs
        /// without actually creating the backing store for the matrix.
        #[unsafe(method(initWithDevice:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_descriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            descriptor: &MPSMatrixDescriptor,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MPSTemporaryMatrix {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A MPSVector allocated on GPU private memory.
    ///
    /// It may alias one or more other MPSTemporaryVector objects. Undesired data destruction
    /// due to aliasing is avoided using the readCount property.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpstemporaryvector?language=objc)
    #[unsafe(super(MPSVector, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSTemporaryVector;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSTemporaryVector {}
);

impl MPSTemporaryVector {
    extern_methods!(
        /// Initialize a MPSTemporaryVector for use on a MTLCommandBuffer
        ///
        /// Parameter `commandBuffer`: The MTLCommandBuffer on which the MPSTemporaryMatrix will be exclusively used
        ///
        /// Parameter `descriptor`: A valid MPSVectorDescriptor describing the MPSVector format to create
        ///
        /// Returns: A valid MPSTemporaryVector.  The object is not managed by a NSAutoreleasePool. The object will be
        /// released when the command buffer is committed. The underlying buffer will become invalid before
        /// this time due to the action of the readCount property.  Please read and understand the use of
        /// the readCount property before using this object.
        #[unsafe(method(temporaryVectorWithCommandBuffer:descriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryVectorWithCommandBuffer_descriptor(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            descriptor: &MPSVectorDescriptor,
        ) -> Retained<Self>;

        /// Help MPS decide which allocations to make ahead of time
        ///
        /// The buffer cache that underlies the MPSTemporaryVector can automatically allocate new storage as
        /// needed as you create new temporary vectors.  However, sometimes a more global view of what you
        /// plan to make is useful for maximizing memory reuse to get the most efficient operation.
        /// This class method hints to the cache what the list of matrices will be.
        ///
        /// It is never necessary to call this method. It is purely a performance and memory optimization.
        ///
        ///
        /// Parameter `commandBuffer`: The command buffer on which the MPSTemporaryVector will be used
        ///
        /// Parameter `descriptorList`: A NSArray of MPSVectorDescriptor objects, indicating vectors that will be created
        #[unsafe(method(prefetchStorageWithCommandBuffer:descriptorList:))]
        #[unsafe(method_family = none)]
        pub unsafe fn prefetchStorageWithCommandBuffer_descriptorList(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            descriptor_list: &NSArray<MPSVectorDescriptor>,
        );

        /// *** unavailable
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(initWithBuffer:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBuffer_descriptor(
            this: Allocated<Self>,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            descriptor: &MPSVectorDescriptor,
        ) -> Retained<Self>;

        /// The number of times a temporary vector may be read by a MPSMatrix... kernel
        /// before its contents become undefined.
        ///
        ///
        /// MPSTemporaryVector objects must release their underlying buffers for reuse
        /// immediately after last use. So as to facilitate *prompt* convenient
        /// memory recycling, each time a MPSTemporaryVector is read by a
        /// MPSMatrix... -encode... method, its readCount is automatically
        /// decremented. When the readCount reaches 0, the underlying buffer is
        /// automatically made available for reuse to MPS for its own needs and for
        /// other MPSTemporaryVector objects prior to return from the -encode.. function.
        /// The contents of the buffer become undefined at this time.
        ///
        /// By default, the readCount is initialized to 1, indicating a matrix that
        /// may be overwritten any number of times, but read only once.
        ///
        /// You may change the readCount as desired to allow MPSMatrix kernels to read
        /// the MPSTemporaryVector additional times. However, it is an error to change
        /// the readCount once it is zero. It is an error to read or write to a
        /// MPSTemporaryVector with a zero readCount. You may set the readCount to 0
        /// yourself to cause the underlying buffer to be returned to MPS. Writing
        /// to a MPSTemporaryVector does not adjust the readCount.
        ///
        /// The Metal API Validation layer will assert if a MPSTemporaryVector is
        /// deallocated with non-zero readCount to help identify cases when resources
        /// are not returned promptly.
        #[unsafe(method(readCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn readCount(&self) -> NSUInteger;

        /// Setter for [`readCount`][Self::readCount].
        #[unsafe(method(setReadCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setReadCount(&self, read_count: NSUInteger);
    );
}

/// Methods declared on superclass `MPSVector`.
impl MPSTemporaryVector {
    extern_methods!(
        /// Initialize a MPSVector object with a MTLBuffer and an offset.
        ///
        ///
        /// Parameter `buffer`: The MTLBuffer containing the data.
        ///
        ///
        /// Parameter `offset`: The offset, in bytes, into the buffer at which data begins.
        ///
        ///
        /// Parameter `descriptor`: The MPSVectorDescriptor.
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(initWithBuffer:offset:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBuffer_offset_descriptor(
            this: Allocated<Self>,
            buffer: &ProtocolObject<dyn MTLBuffer>,
            offset: NSUInteger,
            descriptor: &MPSVectorDescriptor,
        ) -> Retained<Self>;

        /// Initialize a lazily backed MPSVector object with a descriptor
        ///
        /// Parameter `device`: The device with which it will be used
        ///
        /// Parameter `descriptor`: The shape and style of the matrix
        ///
        /// Returns: A valid MPSVector object or nil
        ///
        /// The vector object will be created, but the storage to hold the
        /// vector data will only be allocated when it is needed, typically
        /// when the data property is invoked.  In conjunction
        /// with -resourceSize, this will allow you to estimate storage needs
        /// without actually creating the backing store for the vector.
        #[unsafe(method(initWithDevice:descriptor:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_descriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            descriptor: &MPSVectorDescriptor,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MPSTemporaryVector {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
