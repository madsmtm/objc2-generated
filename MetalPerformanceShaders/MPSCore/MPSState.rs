//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsstateresourcelist?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSStateResourceList;
);

unsafe impl NSObjectProtocol for MPSStateResourceList {}

extern_methods!(
    unsafe impl MPSStateResourceList {
        /// Init an empty autoreleased resource list
        #[method_id(resourceList)]
        #[unsafe(method_family = none)]
        pub unsafe fn resourceList() -> Retained<Self>;

        /// Init an empty list
        #[method_id(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// append a texture to the resource list
        #[method(appendTexture:)]
        pub unsafe fn appendTexture(&self, descriptor: &MTLTextureDescriptor);

        /// append a buffer to the resource list
        #[method(appendBuffer:)]
        pub unsafe fn appendBuffer(&self, size: NSUInteger);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MPSStateResourceList {
        #[method_id(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

/// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsstatetextureinfo?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct MPSStateTextureInfo {
    pub width: NSUInteger,
    pub height: NSUInteger,
    pub depth: NSUInteger,
    pub arrayLength: NSUInteger,
    pub pixelFormat: MTLPixelFormat,
    pub textureType: MTLTextureType,
    pub usage: MTLTextureUsage,
    pub(crate) _reserved: [NSUInteger; 4],
}

unsafe impl Encode for MPSStateTextureInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "MPSStateTextureInfo",
        &[
            <NSUInteger>::ENCODING,
            <NSUInteger>::ENCODING,
            <NSUInteger>::ENCODING,
            <NSUInteger>::ENCODING,
            <MTLPixelFormat>::ENCODING,
            <MTLTextureType>::ENCODING,
            <MTLTextureUsage>::ENCODING,
            <[NSUInteger; 4]>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for MPSStateTextureInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsstateresourcetype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MPSStateResourceType(pub NSUInteger);
impl MPSStateResourceType {
    #[doc(alias = "MPSStateResourceTypeNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "MPSStateResourceTypeBuffer")]
    pub const Buffer: Self = Self(1);
    #[doc(alias = "MPSStateResourceTypeTexture")]
    pub const Texture: Self = Self(2);
}

unsafe impl Encode for MPSStateResourceType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MPSStateResourceType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Dependencies: This depends on Metal Framework
    ///
    /// A semi-opaque data container for large storage in MPS CNN filters
    ///
    /// Some MPS CNN kernels produce additional information beyond a
    /// MPSImage. These may be pooling indices where the result came from,
    /// convolution weights, or other information not contained in the
    /// usual MPSImage result from a MPSCNNKernel. A MPSState object
    /// typically contains one or more expensive MTLResources such as
    /// textures or buffers to store this information.  It provides a
    /// base class with interfaces for managing this storage. Child
    /// classes may add additional functionality specific to their
    /// contents.
    ///
    /// Some MPSState objects are temporary. Temporary state objects,
    /// like MPSTemporaryImages and Matrices, are for very short lived storage,
    /// perhaps just a few lines of code within the scope of a single
    /// MTLCommandBuffer.  They are very efficient for storage, as several
    /// temporary objects can share the same memory over the course of a
    /// MTLCommandBuffer. This can improve both memory usage and time spent
    /// in the kernel wiring down memory and such. You may find that some
    /// large CNN tasks can not be computed without them, as non-temporary
    /// storage would simply take up too much memory.
    ///
    /// In exchange, the lifetime of the underlying storage in temporary
    /// MPSState objects needs to be carefully managed. ARC often waits
    /// until the end of scope to release objects. Temporary storage often
    /// needs to be released sooner than that. Consequently the lifetime of
    /// the data in the underlying MTLResources is managed by a readCount
    /// property. Each time a MPSCNNKernel reads a temporary MPSState object
    /// the readCount is automatically decremented. When it reaches zero, the
    /// underlying storage is recycled for use by other MPS temporary objects,
    /// and the data is becomes undefined.  If you need to consume the data
    /// multiple times, you should set the readCount to a larger number to
    /// prevent the data from becomming undefined.  You may set the readCount
    /// to 0 yourself to return the storage to MPS, if for any reason, you
    /// realize that the MPSState object will no longer be used.
    ///
    /// The contents of a temporary MPSState object are only valid from
    /// creation to the time the readCount reaches 0. The data is only valid
    /// for the MTLCommandBuffer on which it was created.  Non-temporary
    /// MPSState objects are valid on any MTLCommandBuffer on the same
    /// device until they are released.
    ///
    /// Finally, temporary MPSState objects are complicated to use with blit encoders.
    /// Your application should assume that the temporary MPSState is backed by a MTLHeap,
    /// and consequently needs a MTLFence to ensure that compute command encoders and other
    /// encoders do not trip over one another with heap based memory. MPS will almost never
    /// use a blit encoder for this reason. If you do need one, then you will need to make
    /// a new compute encoder to block on whatever previous compute encoder last used the
    /// heap block. (MPS will not tell you who previously used the heap block. That encoder
    /// is almost certainly long dead anyway.) If concurrent encoders are involved, then a
    /// barrier might be needed. Within that compute encoder, you will call -updateFence.
    /// End the compute encoder, make a blit encoder wait for the fence, do the blit, update
    /// a new fence, then make a new compute encoder, wait for the second fence, then you
    /// can continue. Possibly the second do-nothing compute encoder needs to be ended so
    /// MPS can be called. Frankly, we don't bother with blit encoders and just write a compute
    /// operation for copy / clear as needed, or better yet find a way to eliminate the
    /// clear / copy pass so we don't have to pay for it. Your application needs to use
    /// temporary MPSStates and MPSTemporaryImages. Memory costs skyrocket, otherwise.
    /// It is the blit encoder that is hopefully optional. Note: the most common use of a
    /// blit encoder, -synchronizeResource: can not encounter this problem because temporary
    /// images and states live in GPU private memory and can not be read by the CPU.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsstate?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSState;
);

unsafe impl NSObjectProtocol for MPSState {}

extern_methods!(
    unsafe impl MPSState {
        /// Create a MPSState holding a temporary MTLBuffer
        ///
        /// Parameter `cmdBuf`: The command buffer against which the temporary resource is allocated
        ///
        /// Parameter `bufferSize`: The size of the buffer in bytes
        #[method_id(temporaryStateWithCommandBuffer:bufferSize:)]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_bufferSize(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            buffer_size: usize,
        ) -> Retained<Self>;

        /// Create a MPSState holding a temporary MTLTexture
        ///
        /// Parameter `cmdBuf`: The command buffer against which the temporary resource is allocated
        ///
        /// Parameter `descriptor`: A descriptor for the new temporary texture
        #[method_id(temporaryStateWithCommandBuffer:textureDescriptor:)]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_textureDescriptor(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        /// Create a new autoreleased temporary state object without underlying resource
        ///
        /// Parameter `cmdBuf`: The command buffer with which the temporary resource is associated
        #[method_id(temporaryStateWithCommandBuffer:)]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer(
            cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
        ) -> Retained<Self>;

        #[method_id(initWithDevice:bufferSize:)]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_bufferSize(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            buffer_size: usize,
        ) -> Retained<Self>;

        #[method_id(initWithDevice:textureDescriptor:)]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_textureDescriptor(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            descriptor: &MTLTextureDescriptor,
        ) -> Retained<Self>;

        /// Create a MPSState with a non-temporary MTLResource
        ///
        /// Parameter `resource`: A MTLBuffer or MTLTexture. May be nil.
        #[method_id(initWithResource:)]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithResource(
            this: Allocated<Self>,
            resource: Option<&ProtocolObject<dyn MTLResource>>,
        ) -> Retained<Self>;

        #[method_id(init)]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Option<Retained<Self>>;

        /// Initialize a non-temporary state to hold a number of textures and buffers
        ///
        /// The allocation of each resource will be deferred  until it is needed.
        /// This occurs when -resource or -resourceAtIndex: is called.
        ///
        /// Parameter `resourceList`: The list of resources to create.
        #[method_id(initWithDevice:resourceList:)]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_resourceList(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Initialize a temporary state to hold a number of textures and buffers
        ///
        /// The textures occur first in sequence
        #[method_id(temporaryStateWithCommandBuffer:resourceList:)]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryStateWithCommandBuffer_resourceList(
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
            resource_list: &MPSStateResourceList,
        ) -> Retained<Self>;

        /// Create a state object with a list of MTLResources
        ///
        /// Because MPS prefers deferred allocation of resources
        /// your application should use -initWithTextures:bufferSizes:bufferCount:
        /// whenever possible. This method is useful for cases when the
        /// MTLResources must be initialized by the CPU.
        #[method_id(initWithResources:)]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithResources(
            this: Allocated<Self>,
            resources: Option<&NSArray<ProtocolObject<dyn MTLResource>>>,
        ) -> Retained<Self>;

        /// Return the number of MTLResource objects held by the state
        #[method(resourceCount)]
        pub unsafe fn resourceCount(&self) -> NSUInteger;

        /// Get the MTLResource at the indicated index
        ///
        /// By convention, except where otherwise documented, the MTLResources
        /// held by the MPSState are private to the MPSState object, owned
        /// by the MPSState subclass author. If the MPSState subclass
        /// author is MPS, then the identity (e.g. texture vs. buffer)
        /// and information contained in the resource should be considered
        /// implementation dependent. It may change by operating system
        /// version or device. If you are the author of the subclass then it
        /// is for your own use, and MPS will not look at it, except perhaps
        /// so as to pass it to a custom kernel.  Otherwise, the method is made
        /// available to facilitate debugging and to allow you to write your own
        /// state objects. Provide accessors to read this information
        /// in a defined format.
        ///
        ///
        /// Parameter `index`: The index of the MTLResource to retrieve
        ///
        /// Parameter `allocateMemory`: It is very important to avoid allocating memory to hold
        /// MTLResources until it is absolutely necessary, especially when working
        /// with temporary MPSStates. When allocateMemory is set to NO and the
        /// resource has not yet been allocated, nil will be returned instead.
        /// If you just need information about the resource such as buffer size
        /// or MTLTexture properties, but not the resource itself, please use
        /// -bufferSizeAtIndex: or -textureInfoAtIndex: instead, as these will
        /// not force the creation of the MTLResource.
        #[method_id(resourceAtIndex:allocateMemory:)]
        #[unsafe(method_family = none)]
        pub unsafe fn resourceAtIndex_allocateMemory(
            &self,
            index: NSUInteger,
            allocate_memory: bool,
        ) -> Option<Retained<ProtocolObject<dyn MTLResource>>>;

        #[method(readCount)]
        pub unsafe fn readCount(&self) -> NSUInteger;

        /// Setter for [`readCount`][Self::readCount].
        #[method(setReadCount:)]
        pub unsafe fn setReadCount(&self, read_count: NSUInteger);

        #[method(isTemporary)]
        pub unsafe fn isTemporary(&self) -> bool;

        /// A string to help identify this object.
        #[method_id(label)]
        #[unsafe(method_family = none)]
        pub unsafe fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        #[method(setLabel:)]
        pub unsafe fn setLabel(&self, label: Option<&NSString>);

        /// Return the buffer size of the MTLBuffer at index or 0 if it is not a MTLBuffer
        ///
        /// Does not force allocation of the MTLResource
        #[method(bufferSizeAtIndex:)]
        pub unsafe fn bufferSizeAtIndex(&self, index: NSUInteger) -> NSUInteger;

        /// Return the texture size {width,height,depth} or {0,0,0} if it is not a MTLTexture
        ///
        /// Does not force allocation of the MTLResource
        #[method(textureInfoAtIndex:)]
        pub unsafe fn textureInfoAtIndex(&self, index: NSUInteger) -> MPSStateTextureInfo;

        /// Return YES if the resource at index is a buffer
        ///
        /// Does not force allocation of the MTLResource
        #[method(resourceTypeAtIndex:)]
        pub unsafe fn resourceTypeAtIndex(&self, index: NSUInteger) -> MPSStateResourceType;

        /// Flush any copy of MTLResources held by the state from the device's caches, and invalidate any CPU caches if needed.
        ///
        /// This will call [id
        /// <MTLBlitEncoder
        /// > synchronizeResource: ] on the state's MTLResources.
        /// This is necessary for all MTLStorageModeManaged resources. For other resources, including temporary
        /// resources (these are all MTLStorageModePrivate), nothing is done.
        ///
        /// Parameter `commandBuffer`: The commandbuffer on which to synchronize
        #[method(synchronizeOnCommandBuffer:)]
        pub unsafe fn synchronizeOnCommandBuffer(
            &self,
            command_buffer: &ProtocolObject<dyn MTLCommandBuffer>,
        );

        /// Get the number of bytes used to allocate underyling MTLResources
        ///
        /// This is the size of the backing store of underlying MTLResources.
        /// It does not include all storage used by the object, for example
        /// the storage used to hold the MPSState instantiation and MTLTexture
        /// or MTLBuffer is not included. It only measures the size of the
        /// allocation used to hold the texels in the texture or bytes in the
        /// buffer. This value is subject to change between different devices
        /// and operating systems.
        ///
        /// Except when -initWithResource: is used, most MPSStates are allocated
        /// without a backing store. The backing store is allocated lazily when
        /// it is needed, typically when the .texture property is called.
        /// Consequently, in most cases, it should be inexpensive to make
        /// a MPSImage to see how much memory it will need, and release it
        /// if it is too large.
        ///
        /// This method may fail in certain circumstances, such as when the
        /// MPSImage is created with -initWithTexture:featureChannels:, in
        /// which case 0 will be returned.
        #[method(resourceSize)]
        pub unsafe fn resourceSize(&self) -> NSUInteger;

        #[cfg(all(feature = "MPSImage", feature = "MPSKernel"))]
        /// Determine padding and sizing of result images
        ///
        /// A MPSState has the opportunity to reconfigure the MPSImageDescriptor
        /// used to create the filter result state and set the MPSKernel.offset
        /// to the correct value.  By default, the MPSState does not modify the
        /// descriptor.
        ///
        /// There is a order of operations defined for who may update the descriptor:
        ///
        /// 1) Default padding code runs based on the MPSNNPaddingMethod in
        /// the MPSCNNKernel.padding. This creates the descriptor and
        /// picks a starting value for the MPSCNNKernel.offset.
        /// 2) MPSStates are called in order to apply this function and update
        /// the offset.
        /// 3) The MPSNNPadding custom padding method of the same name is called.
        /// 4)
        ///
        /// Some code that may prove helpful:
        ///
        ///
        /// ```text
        ///                   const int centeringPolicy = 0;  // When kernelSize is even: 0 pad bottom right. 1 pad top left.    Centers the kernel for even sized kernels.
        ///
        ///                   typedef enum Style{
        ///                       StyleValidOnly = -1,
        ///                       StyleSame = 0,
        ///                       StyleFull = 1
        ///                   }Style;
        ///
        ///                   // Typical destination size in one dimension for forward filters (most filters)
        ///                   static int DestSize( int sourceSize, int stride, int filterWindowSize, Style style ){
        ///                       sourceSize += style * (filterWindowSize - 1);       // adjust how many pixels we are allowed to read
        ///                       return (sourceSize + stride - 1) / stride;          // sourceSize / stride, round up
        ///                   }
        ///
        ///                   // Typical destination size in one dimension for reverse filters (e.g. convolution transpose)
        ///                   static int DestSizeReverse( int sourceSize, int stride, int filterWindowSize, Style style ){
        ///                       return (sourceSize-1) * stride +        // center tap for the last N-1 results. Take stride into account
        ///                               1 +                             // center tap for the first result
        ///                               style * (filterWindowSize-1);   // add or subtract (or ignore) the filter extent
        ///                   }
        ///
        ///                   // Find the MPSOffset in one dimension
        ///                   static int Offset( int sourceSize, int stride, int filterWindowSize, Style style ){
        ///                       // The correction needed to adjust from position of left edge to center per MPSOffset definition
        ///                       int correction = filterWindowSize / 2;
        ///
        ///                       // exit if all we want is to start consuming pixels at the left edge of the image.
        ///                       if( 0 )
        ///                           return correction;
        ///
        ///                       // Center the area consumed in the source image:
        ///                       // Calculate the size of the destination image
        ///                       int destSize = DestSize( sourceSize, stride, filterWindowSize, style ); // use DestSizeReverse here instead as appropriate
        ///
        ///                       // calculate extent of pixels we need to read in source to populate the destination
        ///                       int readSize = (destSize-1) * stride + filterWindowSize;
        ///
        ///                       // calculate number of missing pixels in source
        ///                       int extraSize = readSize - sourceSize;
        ///
        ///                       // number of missing pixels on left side
        ///                       int leftExtraPixels = (extraSize + centeringPolicy) / 2;
        ///
        ///                       // account for the fact that the offset is based on the center pixel, not the left edge
        ///                       return correction - leftExtraPixels;
        ///                   }
        /// ```
        ///
        ///
        /// Parameter `sourceImages`: The list of source images to be used
        ///
        /// Parameter `sourceStates`: The list of source states to be used
        ///
        /// Parameter `kernel`: The MPSKernel the padding method will be applied to. Set the kernel.offset
        ///
        /// Parameter `inDescriptor`: MPS will prepare a starting guess based on the padding policy (exclusive of
        /// MPSNNPaddingMethodCustom) set for the object. You should adjust the offset
        /// and image size accordingly. It is on an autoreleasepool.
        ///
        ///
        /// Returns: The MPSImageDescriptor to use to make a MPSImage to capture the results from the filter.
        /// The MPSImageDescriptor is assumed to be on an autoreleasepool. Your method must also set the
        /// kernel.offset property.
        #[method_id(destinationImageDescriptorForSourceImages:sourceStates:forKernel:suggestedDescriptor:)]
        #[unsafe(method_family = none)]
        pub unsafe fn destinationImageDescriptorForSourceImages_sourceStates_forKernel_suggestedDescriptor(
            &self,
            source_images: &NSArray<MPSImage>,
            source_states: Option<&NSArray<MPSState>>,
            kernel: &MPSKernel,
            in_descriptor: &MPSImageDescriptor,
        ) -> Retained<MPSImageDescriptor>;

        /// Get the private MTLResource underlying the MPSState
        ///
        /// When the state is not directly initialized with a MTLResource,
        /// the actuall MTLResource creation is deferred. Especially with
        /// temporary resources, it is important to delay this creation
        /// as late as possible to avoid increasing the memory footprint.
        /// The memory is returned for reuse when the readCount = 0. Calling
        /// the -resource method will force the resource to be allocated,
        /// so you should not use it lightly, for purposes such as finding
        /// the MTLPixelFormat of a texture in the state.
        ///
        /// By convention, except where otherwise documented, the MTLResources
        /// held by the MPSState are private to the MPSState object, owned
        /// by the MPSState subclass author. If the MPSState subclass
        /// author is MPS, then the identity (e.g. texture vs. buffer)
        /// and information contained in the resource should be considered
        /// implementation dependent. It may change by operating system
        /// version or device. If you are the author of the subclass then it
        /// is for your own use, and MPS will not look at it, except perhaps
        /// so as to pass it to a custom kernel.  Otherwise, the method is made
        /// available to facilitate debugging and to allow you to write your own
        /// state objects.
        #[deprecated]
        #[method_id(resource)]
        #[unsafe(method_family = none)]
        pub unsafe fn resource(&self) -> Option<Retained<ProtocolObject<dyn MTLResource>>>;
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl MPSState {
        #[method_id(new)]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

/// [Apple's documentation](https://developer.apple.com/documentation/metalperformanceshaders/mpsstatebatch?language=objc)
pub type MPSStateBatch = NSArray<MPSState>;

extern "C-unwind" {
    /// raise or lower the readcount of a batch by a set amount
    ///
    /// In some circumstances, a MPSState may appear in a MPSStateBatch
    /// multiple times. This is particularly common when the MPSState serves
    /// as an accumulator across the entire batch, such as when accumulating
    /// gradients for convolution weight update or batch statistics for
    /// batch normalization.  A naive function would then end up incrementing
    /// the state multiple times, probably leading to an error.
    ///
    /// MPSStateBatchIncrementReadCount() will efficiently increment the
    /// readCounts of each object in the batch only once, avoiding this problem.
    ///
    ///
    /// Parameter `batch`: The MPSStateBatch to increment
    ///
    /// Parameter `amount`: The value to add to the read count for each unique state in the batch
    ///
    /// Returns: The number of different objects in the batch
    pub fn MPSStateBatchIncrementReadCount(
        batch: Option<&MPSStateBatch>,
        amount: NSInteger,
    ) -> NSUInteger;
}

extern "C-unwind" {
    /// Call [MTLBlitEncoder synchronizeResource:] on unique resources
    pub fn MPSStateBatchSynchronize(
        batch: &MPSStateBatch,
        cmd_buf: &ProtocolObject<dyn MTLCommandBuffer>,
    );
}

extern "C-unwind" {
    /// Call [MTLBlitEncoder resourceSize] on unique resources
    pub fn MPSStateBatchResourceSize(batch: Option<&MPSStateBatch>) -> NSUInteger;
}
