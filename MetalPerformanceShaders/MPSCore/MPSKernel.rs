//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
use objc2_metal::*;

use crate::*;

extern_class!(
    /// A standard interface for Metal Performance Shaders kernels.
    ///
    /// ## Overview
    ///
    /// You should not use the [`MPSKernel`](https://developer.apple.com/documentation/metalperformanceshaders/mpskernel) class directly. Instead, a number of subclasses are available that define specific high-performance data-parallel operations.
    ///
    /// The basic sequence for applying a kernel to an image is as follows:
    ///
    /// 1. Initialize a kernel corresponding to the operation you wish to perform:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let sobel = MPSImageSobel(device: mtlDevice)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["MPSImageSobel *sobel = [[MPSImageSobel alloc] initWithDevice: mtlDevice];"], metadata: None }] }] })
    /// 2. Encode the kernel into a command buffer.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["sobel.offset = ...", "sobel.clipRect = ...", "sobel.options = ...", "sobel.encode(commandBuffer: commandBuffer,", "             sourceTexture: inputImage,", "             destinationTexture: resultImage)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["sobel.offset = ...;", "sobel.clipRect = ...;", "sobel.options = ...;", "[sobel encodeToCommandBuffer: commandBuffer sourceTexture: inputImage destinationTexture: resultImage;", " ", "if(returnVal < 0)", "    MyShowError(returnVal);"], metadata: None }] }] })
    /// Encoding the kernel merely encodes the operation into a command buffer. It does not modify any pixels, yet. All kernel state has been copied to the command buffer. Kernels may be reused. If the texture was previously operated on by another command encoder (e.g. a render command encoder), you should call the [`endEncoding`](https://developer.apple.com/documentation/metal/mtlcommandencoder/endencoding()) method on the other encoder before encoding the filter.
    ///
    /// Some kernels work in place, even in situations where Metal might not normally allow in-place operation on textures. If in-place operation is desired, you may attempt to call the [`encodeToCommandBuffer:inPlaceTexture:fallbackCopyAllocator:`](https://developer.apple.com/documentation/metalperformanceshaders/mpsunaryimagekernel/encode(commandbuffer:inplacetexture:fallbackcopyallocator:)) method. If the operation cannot be completed in place, then [`false`](https://developer.apple.com/documentation/swift/false) will be returned and you will have to create a new result texture and try again. To make an in-place image filter reliable, pass a fallback [`MPSCopyAllocator`](https://developer.apple.com/documentation/metalperformanceshaders/mpscopyallocator) block to the method to create a new texture to write to in the event that a filter cannot operate in place.
    ///
    /// You may repeat step 2 to encode more kernels, as desired. 3. After encoding any additional work to the command buffer using other encoders, submit the command buffer to your command queue, using:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["commandBuffer.commit()"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[commandBuffer commit];"], metadata: None }] }] })
    /// <div class="warning">
    ///
    /// ### Note
    ///  It should be self evident that step 2 may not be thread safe. That is, you can not have multiple threads manipulating the same properties on the same kernel object at the same time and achieve coherent output. In common usage, the kernel properties donâ€™t often need to be changed from their default values, but if you need to apply the same filter to multiple images on multiple threads with cropping/tiling, make additional kernel objects per thread (they are cheap). You can use multiple kernel objects on multiple threads, as long as only one thread is operating on any particular kernel object at a time.
    ///
    ///
    ///
    /// </div>
    ///
    /// Dependencies: This depends on Metal.framework
    ///
    /// The MPSKernel class is the base class for all MPS objects.  It defines a standard interface for
    /// MPS kernels.   You should not use the MPSKernel class directly. Instead, a  number of MPSKernel
    /// subclasses are available in MetalPerformanceShaders.framework that define specific high-performance
    /// image processing operations.
    ///
    /// The basic sequence for applying a MPSKernel to an image is as follows:
    ///
    /// 1.  Create a MPSKernel corresponding to the operation you wish to perform:
    ///
    /// ```text
    ///                   MPSImageSobel *sobel = [[MPSImageSobel alloc] initWithDevice: mtlDevice];
    /// ```
    ///
    /// 2.  Encode the filter into a command buffer:
    ///
    /// ```text
    ///                   sobel.offset = ...;
    ///                   sobel.clipRect = ...;
    ///                   sobel.options = ...;
    ///                   [sobel encodeToCommandBuffer: commandBuffer
    ///                                  sourceTexture: inputImage
    ///                             destinationTexture: resultImage ];
    /// ```
    ///
    /// Encoding the kernel merely encodes the operation into a MTLCommandBuffer. It does not modify any pixels, yet.
    /// All MPSKernel state has been copied to the command buffer. MPSKernels may be reused.  If the texture was previously
    /// operated on by another command encoder (e.g. MTLRenderCommandEncoder), you should call -endEncoding on the other
    /// encoder before encoding the filter.
    ///
    /// Some MPS filters work in place (inputImage = resultImage) even in situations where Metal might not
    /// normally allow in place operation on textures. If in-place operation is desired, you may attempt to call
    /// [MPSKernel encodeKernelInPlace...]. If the operation can not be completed in place, then
    /// NO will be returned and you will have to create a new result texture and try again. To make an in-place
    /// image filter reliable, pass a fallback MPSCopyAllocator to the method to create a new texture to write
    /// to in the event that a filter can not operate in place.
    ///
    /// (Repeat steps 2 for more filters, as desired.)
    ///
    /// It should be self evident that step 2 may not be thread safe. That is, you can not have
    /// multiple threads manipulating the same properties on the same MPSKernel object at the
    /// same time and achieve coherent output. In common usage, the MPSKernel properties don't
    /// often need to be changed from their default values, but if you need to apply the same
    /// filter to multiple images on multiple threads with cropping / tiling, make additional
    /// MPSKernel objects per thread. They are cheap. You can use multiple MPSKernel objects on
    /// multiple threads, as long as only one thread is operating on any particular MPSKernel
    /// object at a time.
    ///
    /// 3.  After encoding any additional work to the command buffer using other encoders, submit the MTLCommandBuffer
    /// to your MTLCommandQueue, using:
    ///
    /// ```text
    ///                   [mtlCommandBuffer commit];
    /// ```
    ///
    /// A MPSKernel can be saved to disk / network using NSCoders such as NSKeyedArchiver.
    /// When decoding, the system default MTLDevice will be chosen unless the NSCoder adopts
    /// the
    /// <MPSDeviceProvider
    /// > protocol.  To accomplish this, subclass or extend your unarchiver
    /// to add this method.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MPSKernel;
);

extern_conformance!(
    unsafe impl NSCoding for MPSKernel {}
);

extern_conformance!(
    unsafe impl NSCopying for MPSKernel {}
);

unsafe impl CopyingHelper for MPSKernel {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MPSKernel {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for MPSKernel {}
);

impl MPSKernel {
    extern_methods!(
        #[cfg(feature = "MPSCoreTypes")]
        /// The set of options used to run the kernel.
        /// subsubsection_options
        #[unsafe(method(options))]
        #[unsafe(method_family = none)]
        pub unsafe fn options(&self) -> MPSKernelOptions;

        #[cfg(feature = "MPSCoreTypes")]
        /// Setter for [`options`][Self::options].
        #[unsafe(method(setOptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOptions(&self, options: MPSKernelOptions);

        /// The device on which the kernel will be used
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        pub unsafe fn device(&self) -> Retained<ProtocolObject<dyn MTLDevice>>;

        /// A string to help identify this object.
        #[unsafe(method(label))]
        #[unsafe(method_family = none)]
        pub unsafe fn label(&self) -> Option<Retained<NSString>>;

        /// Setter for [`label`][Self::label].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLabel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLabel(&self, label: Option<&NSString>);

        /// Standard init with default properties per filter type
        ///
        /// Parameter `device`: The device that the filter will be used on. May not be NULL.
        ///
        /// Returns: a pointer to the newly initialized object. This will fail, returning
        /// nil if the device is not supported. Devices must be
        /// MTLFeatureSet_iOS_GPUFamily2_v1 or later.
        #[unsafe(method(initWithDevice:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice(
            this: Allocated<Self>,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Retained<Self>;

        /// Make a copy of this MPSKernel for a new device
        ///
        /// -copyWithZone: will call this API to make a copy of the
        /// MPSKernel on the same device.  This interface may also be
        /// called directly to make a copy of the MPSKernel on a new
        /// device. Typically, the same MPSKernels should not be used
        /// to encode kernels on multiple command buffers from multiple
        /// threads. Many MPSKernels have mutable properties that might
        /// be changed by the other thread while this one is trying to
        /// encode. If you need to use a MPSKernel from multiple threads
        /// make a copy of it for each additional thread using -copyWithZone:
        /// or -copyWithZone:device:
        ///
        /// Parameter `zone`: The NSZone in which to allocate the object
        ///
        /// Parameter `device`: The device for the new MPSKernel. If nil, then use
        /// self.device.
        ///
        /// Returns: a pointer to a copy of this MPSKernel. This will fail, returning
        /// nil if the device is not supported. Devices must be
        /// MTLFeatureSet_iOS_GPUFamily2_v1 or later.
        ///
        /// # Safety
        ///
        /// `zone` must be a valid pointer or null.
        #[unsafe(method(copyWithZone:device:))]
        #[unsafe(method_family = copy)]
        pub unsafe fn copyWithZone_device(
            &self,
            zone: *mut NSZone,
            device: Option<&ProtocolObject<dyn MTLDevice>>,
        ) -> Retained<Self>;

        /// Called by NSCoder to decode MPSKernels
        ///
        /// This isn't the right interface to decode a MPSKernel, but
        /// it is the one that NSCoder uses. To enable your NSCoder
        /// (e.g. NSKeyedUnarchiver) to set which device to use
        /// extend the object to adopt the MPSDeviceProvider
        /// protocol. Otherwise, the Metal system default device
        /// will be used.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
        ) -> Option<Retained<Self>>;

        /// NSSecureCoding compatability
        ///
        /// While the standard NSSecureCoding/NSCoding method
        /// -initWithCoder: should work, since the file can't
        /// know which device your data is allocated on, we
        /// have to guess and may guess incorrectly.  To avoid
        /// that problem, use initWithCoder:device instead.
        ///
        /// Parameter `aDecoder`: The NSCoder subclass with your serialized MPSKernel
        ///
        /// Parameter `device`: The MTLDevice on which to make the MPSKernel
        ///
        /// Returns: A new MPSKernel object, or nil if failure.
        ///
        /// # Safety
        ///
        /// `a_decoder` possibly has further requirements.
        #[unsafe(method(initWithCoder:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder_device(
            this: Allocated<Self>,
            a_decoder: &NSCoder,
            device: &ProtocolObject<dyn MTLDevice>,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MPSKernel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
