// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "NetworkExtension", kind = "framework")]
extern "C" {}

use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-accessory-setup-kit")]
#[cfg(target_os = "ios")]
use objc2_accessory_setup_kit::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-security")]
use objc2_security::*;

use crate::*;

/// Error codes that the app proxy flow API declares.
/// Flow error codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEAppProxyFlowError(pub NSInteger);
impl NEAppProxyFlowError {
    /// The flow is not fully opened.
    #[doc(alias = "NEAppProxyFlowErrorNotConnected")]
    pub const NotConnected: Self = Self(1);
    /// The remote peer closed the flow.
    #[doc(alias = "NEAppProxyFlowErrorPeerReset")]
    pub const PeerReset: Self = Self(2);
    /// An attempt to reach the remote endpoint of the flow failed.
    #[doc(alias = "NEAppProxyFlowErrorHostUnreachable")]
    pub const HostUnreachable: Self = Self(3);
    /// A proxy flow method received an invalid argument.
    #[doc(alias = "NEAppProxyFlowErrorInvalidArgument")]
    pub const InvalidArgument: Self = Self(4);
    /// The flow was aborted.
    #[doc(alias = "NEAppProxyFlowErrorAborted")]
    pub const Aborted: Self = Self(5);
    /// Connecting the flow to its remote endpoint failed.
    #[doc(alias = "NEAppProxyFlowErrorRefused")]
    pub const Refused: Self = Self(6);
    /// The flow timed out.
    #[doc(alias = "NEAppProxyFlowErrorTimedOut")]
    pub const TimedOut: Self = Self(7);
    /// An internal error occurred while handling the flow.
    #[doc(alias = "NEAppProxyFlowErrorInternal")]
    pub const Internal: Self = Self(8);
    /// A caller attempted to write a datagram that was larger than the socket’s receive window.
    #[doc(alias = "NEAppProxyFlowErrorDatagramTooLarge")]
    pub const DatagramTooLarge: Self = Self(9);
    /// A read operation on the flow is already pending.
    #[doc(alias = "NEAppProxyFlowErrorReadAlreadyPending")]
    pub const ReadAlreadyPending: Self = Self(10);
}

unsafe impl Encode for NEAppProxyFlowError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEAppProxyFlowError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The domain used for app proxy errors.
    pub static NEAppProxyErrorDomain: &'static NSString;
}

extern_class!(
    /// An abstract base class shared by NEAppProxyTCPFlow and NEAppProxyUDPFlow.
    ///
    /// ## Overview
    ///
    /// App Proxy Providers receive network connections to be proxied in the form of `NEAppProxyFlow` objects, which are passed to the App Proxy Provider via the [`handleNewFlow:`](https://developer.apple.com/documentation/networkextension/neappproxyprovider/handlenewflow(_:)) method.
    ///
    /// `NEAppProxyFlow` objects are initially in an unopened state. Before they can be used to transmit network data, they must be opened using the [`openWithLocalEndpoint:completionHandler:`](https://developer.apple.com/documentation/networkextension/neappproxyflow/open(withlocalendpoint:completionhandler:)) method. When you are finished with a flow, you should call [`closeReadWithError:`](https://developer.apple.com/documentation/networkextension/neappproxyflow/closereadwitherror(_:)) and [`closeWriteWithError:`](https://developer.apple.com/documentation/networkextension/neappproxyflow/closewritewitherror(_:)), and then release the `NEAppProxyFlow` object.
    ///
    ///
    /// The NEAppProxyFlow class is an abstract base class that declares the programmatic interface for a flow of network data.
    ///
    /// NEAppProxyFlow is part of NetworkExtension.framework.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEAppProxyFlow;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEAppProxyFlow {}
);

impl NEAppProxyFlow {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function is used by an NEProvider implementation to indicate that it is ready to handle flow data.
        ///
        /// Parameter `localEndpoint`: The address and port that should be used as the local endpoint of the socket associated with this flow. If the source application already specified a local endpoint by binding the socket then this parameter is ignored.
        ///
        /// Parameter `completionHandler`: A block that is called when the process of opening flow is complete. A nil value passed to this block indicates that the flow was opened successfully. A non-nil NSError value indicates that the flow failed to open successfully.
        #[deprecated]
        #[unsafe(method(openWithLocalEndpoint:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openWithLocalEndpoint_completionHandler(
            &self,
            local_endpoint: Option<&NWHostEndpoint>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// This function is used by an NEProvider implementation to indicate that it does not want to receive any more data from the flow.
        ///
        /// Parameter `error`: An error in NEAppProxyErrorDomain that should be passed to the flow's source application.
        #[unsafe(method(closeReadWithError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn closeReadWithError(&self, error: Option<&NSError>);

        /// This functions is used by an NEProvider implementation to indicate that it does not have any more data to write to the flow.
        ///
        /// Parameter `error`: An error in NEAppProxyErrorDomain that should be passed to the flow's source application.
        #[unsafe(method(closeWriteWithError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn closeWriteWithError(&self, error: Option<&NSError>);

        /// An NEFlowMetaData object containing meta data for the flow.
        #[unsafe(method(metaData))]
        #[unsafe(method_family = none)]
        pub unsafe fn metaData(&self) -> Retained<NEFlowMetaData>;

        /// If the flow was created by passing a hostname to a "connect by name" API such as NSURLSession or Network.framework, this property is set to the
        /// remote hostname.
        #[unsafe(method(remoteHostname))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteHostname(&self) -> Option<Retained<NSString>>;

        /// YES if the flow was bound by the application to a specific interface (contained in the networkInterface property), NO otherwise.
        #[unsafe(method(isBound))]
        #[unsafe(method_family = none)]
        pub unsafe fn isBound(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEAppProxyFlow {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Reasons why the provider extension was stopped.
///
/// ## Overview
///
/// `NEProviderStopReasonUserLogout` and `NEProviderStopReasonUserSwitch` are available only in macOS.
///
///
/// Provider stop reasons
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEProviderStopReason(pub NSInteger);
impl NEProviderStopReason {
    /// No specific reason.
    #[doc(alias = "NEProviderStopReasonNone")]
    pub const None: Self = Self(0);
    /// The user stopped the provider extension.
    #[doc(alias = "NEProviderStopReasonUserInitiated")]
    pub const UserInitiated: Self = Self(1);
    /// The provider failed to function correctly.
    #[doc(alias = "NEProviderStopReasonProviderFailed")]
    pub const ProviderFailed: Self = Self(2);
    /// No network connectivity is currently available.
    #[doc(alias = "NEProviderStopReasonNoNetworkAvailable")]
    pub const NoNetworkAvailable: Self = Self(3);
    /// The device’s network connectivity changed.
    #[doc(alias = "NEProviderStopReasonUnrecoverableNetworkChange")]
    pub const UnrecoverableNetworkChange: Self = Self(4);
    /// The provider was disabled.
    #[doc(alias = "NEProviderStopReasonProviderDisabled")]
    pub const ProviderDisabled: Self = Self(5);
    /// The authentication process was canceled.
    #[doc(alias = "NEProviderStopReasonAuthenticationCanceled")]
    pub const AuthenticationCanceled: Self = Self(6);
    /// The configuration is invalid.
    #[doc(alias = "NEProviderStopReasonConfigurationFailed")]
    pub const ConfigurationFailed: Self = Self(7);
    /// The session timed out.
    #[doc(alias = "NEProviderStopReasonIdleTimeout")]
    pub const IdleTimeout: Self = Self(8);
    /// The configuration was disabled.
    #[doc(alias = "NEProviderStopReasonConfigurationDisabled")]
    pub const ConfigurationDisabled: Self = Self(9);
    /// The configuration was removed.
    #[doc(alias = "NEProviderStopReasonConfigurationRemoved")]
    pub const ConfigurationRemoved: Self = Self(10);
    /// The configuration was superceded by a higher-priority configuration.
    #[doc(alias = "NEProviderStopReasonSuperceded")]
    pub const Superceded: Self = Self(11);
    /// The user logged out.
    #[doc(alias = "NEProviderStopReasonUserLogout")]
    pub const UserLogout: Self = Self(12);
    /// The current console user changed.
    #[doc(alias = "NEProviderStopReasonUserSwitch")]
    pub const UserSwitch: Self = Self(13);
    /// The connection failed.
    #[doc(alias = "NEProviderStopReasonConnectionFailed")]
    pub const ConnectionFailed: Self = Self(14);
    /// A stop reason indicating the configuration enabled disconnect on sleep and the device went to sleep.
    #[doc(alias = "NEProviderStopReasonSleep")]
    pub const Sleep: Self = Self(15);
    #[doc(alias = "NEProviderStopReasonAppUpdate")]
    pub const AppUpdate: Self = Self(16);
    /// The provider encountered an internal error.
    #[doc(alias = "NEProviderStopReasonInternalError")]
    pub const InternalError: Self = Self(17);
}

unsafe impl Encode for NEProviderStopReason {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEProviderStopReason {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An abstract base class for all NetworkExtension providers.
    ///
    /// ## Overview
    ///
    /// See the documentation for the `NEProvider` subclasses for details about how to create Network Extension Provider extensions.
    ///
    /// The `NEProvider` class and its subclasses expose methods and properties that allow Network Extension Provider extensions to participate in and affect the network data path on iOS and macOS. For example, the `handleNewFlow:` method in [`NEFilterDataProvider`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider) allows Filter Data Provider extensions to make pass/block decisions on TCP connections as the connections are established on the system.
    ///
    /// ### Subclassing Notes
    ///
    /// The `NEProvider` class should not be subclassed directly. Instead, you should create subclasses of `NEProvider` subclasses (and in some cases subsubclasses).
    ///
    /// #### Methods to Override
    ///
    /// - [`sleepWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/neprovider/sleep(completionhandler:))
    ///
    /// - [`wake`](https://developer.apple.com/documentation/networkextension/neprovider/wake())
    ///
    ///
    /// The NEProvider class declares the programmatic interface that is common for all Network Extension providers.
    ///
    /// See the sub classes of NEProvider for more details. Developers of Network Extension providers should create sub classes of the sub classes of NEProvider.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEProvider {}
);

impl NEProvider {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function is called by the framework when the system is about to go to sleep. Subclass developers can override this method to implement custom behavior such as closing connections or pausing some network activity.
        ///
        /// Parameter `completionHandler`: When the method is finished handling the sleep event it must execute this completion handler.
        #[unsafe(method(sleepWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sleepWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        /// This function is called by the framework immediately after the system wakes up from sleep. Subclass developers can override this method to implement custom behavior such as re-establishing connections or resuming some network activity.
        #[unsafe(method(wake))]
        #[unsafe(method_family = none)]
        pub unsafe fn wake(&self);

        /// This function can be called by subclass implementations to create a TCP connection to a given network endpoint. This function should not be overridden by subclasses.
        ///
        /// Parameter `remoteEndpoint`: An NWEndpoint object that specifies the remote network endpoint to connect to.
        ///
        /// Parameter `enableTLS`: A flag indicating if a TLS session should be negotiated on the connection.
        ///
        /// Parameter `TLSParameters`: A set of optional TLS parameters. Only valid if enableTLS is YES. If TLSParameters is nil, the default system parameters will be used for TLS negotiation.
        ///
        /// Parameter `delegate`: An object to use as the connections delegate. This object should conform to the NWTCPConnectionAuthenticationDelegate protocol.
        ///
        /// Returns: An NWTCPConnection object.
        ///
        /// # Safety
        ///
        /// `delegate` should be of the correct type.
        #[deprecated = "Use nw_connection_t in Network framework instead"]
        #[unsafe(method(createTCPConnectionToEndpoint:enableTLS:TLSParameters:delegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createTCPConnectionToEndpoint_enableTLS_TLSParameters_delegate(
            &self,
            remote_endpoint: &NWEndpoint,
            enable_tls: bool,
            tls_parameters: Option<&NWTLSParameters>,
            delegate: Option<&AnyObject>,
        ) -> Retained<NWTCPConnection>;

        /// This function can be called by subclass implementations to create a UDP session between a local network endpoint and a remote network endpoint. This function should not be overridden by subclasses.
        ///
        /// Parameter `remoteEndpoint`: An NWEndpoint object that specifies the remote endpoint to which UDP datagrams will be sent by the UDP session.
        ///
        /// Parameter `localEndpoint`: An NWHostEndpoint object that specifies the local IP address endpoint to use as the source endpoint of the UDP session.
        ///
        /// Returns: An NWUDPSession object.
        #[deprecated = "Use nw_connection_t in Network framework instead"]
        #[unsafe(method(createUDPSessionToEndpoint:fromEndpoint:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createUDPSessionToEndpoint_fromEndpoint(
            &self,
            remote_endpoint: &NWEndpoint,
            local_endpoint: Option<&NWHostEndpoint>,
        ) -> Retained<NWUDPSession>;

        #[cfg(feature = "block2")]
        /// This method can be called by subclass implementations to display a message to the user.
        ///
        /// Parameter `message`: The message to be displayed.
        ///
        /// Parameter `completionHandler`: A block that is executed when the user acknowledges the message. If this method is called on a NEFilterDataProvider instance or the message cannot be displayed, then the completion handler block will be executed immediately with success parameter set to NO. If the message was successfully displayed to the user, then the completion handler block is executed with the success parameter set to YES when the user dismisses the message.
        #[deprecated]
        #[unsafe(method(displayMessage:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayMessage_completionHandler(
            &self,
            message: &NSString,
            completion_handler: &block2::DynBlock<dyn Fn(Bool)>,
        );

        /// Start the Network Extension machinery in a system extension (.system bundle). This class method will cause the calling system extension to start handling
        /// requests from nesessionmanager to instantiate appropriate NEProvider sub-class instances. The system extension must declare a mapping of Network Extension extension points to
        /// NEProvider sub-class instances in its Info.plist:
        /// Key: NetworkExtension
        /// Type: Dictionary containing information about the NetworkExtension capabilities of the system extension.
        ///
        /// Key: NEProviderClasses
        /// Type: Dictionary mapping NetworkExtension extension point identifiers to NEProvider sub-classes
        ///
        /// Example:
        ///
        /// <key
        /// >NetworkExtension
        /// </key
        /// >
        /// <dict
        /// >
        /// <key
        /// >NEProviderClasses
        /// </key
        /// >
        /// <dict
        /// >
        /// <key
        /// >com.apple.networkextension.app-proxy
        /// </key
        /// >
        /// <string
        /// >$(PRODUCT_MODULE_NAME).AppProxyProvider
        /// </string
        /// >
        /// <key
        /// >com.apple.networkextension.filter-data
        /// </key
        /// >
        /// <string
        /// >$(PRODUCT_MODULE_NAME).FilterDataProvider
        /// </string
        /// >
        /// </dict
        /// >
        /// </dict
        /// >
        ///
        /// This method should be called as early as possible after the system extension starts.
        #[unsafe(method(startSystemExtensionMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn startSystemExtensionMode();

        /// The current default path for connections created by the provider. Use KVO to watch for network changes.
        #[deprecated = "Use nw_path_monitor_t in Network framework instead"]
        #[unsafe(method(defaultPath))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultPath(&self) -> Option<Retained<NWPath>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Error codes that the tunnel provider declares.
/// Tunnel Provider error codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NETunnelProviderError(pub NSInteger);
impl NETunnelProviderError {
    /// The provided tunnel network settings are invalid.
    #[doc(alias = "NETunnelProviderErrorNetworkSettingsInvalid")]
    pub const NetworkSettingsInvalid: Self = Self(1);
    /// The request to set or clear the tunnel network settings was canceled.
    #[doc(alias = "NETunnelProviderErrorNetworkSettingsCanceled")]
    pub const NetworkSettingsCanceled: Self = Self(2);
    /// The request to set or clear the tunnel network settings failed.
    #[doc(alias = "NETunnelProviderErrorNetworkSettingsFailed")]
    pub const NetworkSettingsFailed: Self = Self(3);
}

unsafe impl Encode for NETunnelProviderError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NETunnelProviderError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Network traffic routing methods.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NETunnelProviderRoutingMethod(pub NSInteger);
impl NETunnelProviderRoutingMethod {
    /// Route network traffic to the tunnel based on destination IP.
    #[doc(alias = "NETunnelProviderRoutingMethodDestinationIP")]
    pub const DestinationIP: Self = Self(1);
    /// Route network traffic to the tunnel based on source application.
    #[doc(alias = "NETunnelProviderRoutingMethodSourceApplication")]
    pub const SourceApplication: Self = Self(2);
    /// A routing method that routes traffic based on network rule objects specified by the provider.
    #[doc(alias = "NETunnelProviderRoutingMethodNetworkRule")]
    pub const NetworkRule: Self = Self(3);
}

unsafe impl Encode for NETunnelProviderRoutingMethod {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NETunnelProviderRoutingMethod {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The domain used for Tunnel Provider errors.
    pub static NETunnelProviderErrorDomain: &'static NSString;
}

extern_class!(
    /// An abstract base class shared by NEPacketTunnelProvider and NEAppProxyProvider.
    ///
    /// ## Overview
    ///
    /// Each [`NETunnelProvider`](https://developer.apple.com/documentation/networkextension/netunnelprovider) instance corresponds to a single tunneling session, with a single associated configuration.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The `com.apple.developer.networking.networkextension` entitlement is required in order to use the [`NETunnelProvider`](https://developer.apple.com/documentation/networkextension/netunnelprovider) class. Enable this entitlement when creating an App ID in your developer account.
    ///
    ///
    ///
    /// </div>
    /// ### Subclassing Notes
    ///
    /// The `NETunnelProvider` class should not be subclassed directly. Instead, you should create subclasses of `NETunnelProvider` subclasses.
    ///
    /// #### Methods to Override
    ///
    /// - [`handleAppMessage:completionHandler:`](https://developer.apple.com/documentation/networkextension/netunnelprovider/handleappmessage(_:completionhandler:))
    ///
    ///
    /// The NETunnelProvider class declares the programmatic interface for an object that provides a network tunnel service.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NETunnelProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NETunnelProvider {}
);

impl NETunnelProvider {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function is called by the framework when the container app sends a message to the provider. Subclasses should override this method to handle the message and optionally send a response.
        ///
        /// Parameter `messageData`: An NSData object containing the message sent by the container app.
        ///
        /// Parameter `completionHandler`: A block that the method can execute to send a response to the container app. If this parameter is non-nil then the method implementation should always execute the block. If this parameter is nil then the method implementation should treat this as an indication that the container app is not expecting a response.
        #[unsafe(method(handleAppMessage:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleAppMessage_completionHandler(
            &self,
            message_data: &NSData,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSData)>>,
        );

        #[cfg(feature = "block2")]
        /// This function is called by tunnel provider implementations to set the network settings of the tunnel, including IP routes, DNS servers, and virtual interface addresses depending on the tunnel type. Subclasses should not override this method. This method can be called multiple times during the lifetime of a particular tunnel. It is not necessary to call this function with nil to clear out the existing settings before calling this function with a non-nil configuration.
        ///
        /// Parameter `tunnelNetworkSettings`: An NETunnelNetworkSettings object containing all of the desired network settings for the tunnel. Pass nil to clear out the current network settings.
        ///
        /// Parameter `completionHandler`: A block that will be called by the framework when the process of setting or clearing the network settings is complete. If an error occurred during the process of setting or clearing the IP network settings then a non-nill NSError object will be passed to this block containing error details.
        #[unsafe(method(setTunnelNetworkSettings:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTunnelNetworkSettings_completionHandler(
            &self,
            tunnel_network_settings: Option<&NETunnelNetworkSettings>,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        /// An NEVPNProtocol object containing the provider's current configuration. The value of this property may change during the lifetime of the tunnel provided by this NETunnelProvider, KVO can be used to detect when changes occur.  For different protocol types, this property will contain the corresponding subclass.   For NEVPNProtocolTypePlugin protocol type, this property will contain the NETunnelProviderProtocol subclass.  For NEVPNProtocolTypeIKEv2 protocol type, this property will contain the NEVPNProtocolIKEv2 subclass.
        #[unsafe(method(protocolConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocolConfiguration(&self) -> Retained<NEVPNProtocol>;

        /// An array of NEAppRule objects specifying which applications are currently being routed through the tunnel provided by this NETunnelProvider. If application-based routing is not enabled for the tunnel, then this property is set to nil.
        #[unsafe(method(appRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn appRules(&self) -> Option<Retained<NSArray<NEAppRule>>>;

        /// The method by which network traffic is routed to the tunnel. The default is NETunnelProviderRoutingMethodDestinationIP.
        #[unsafe(method(routingMethod))]
        #[unsafe(method_family = none)]
        pub unsafe fn routingMethod(&self) -> NETunnelProviderRoutingMethod;

        /// A flag that indicates to the framework if this NETunnelProvider is currently re-establishing the tunnel. Setting this flag will cause the session status visible to the user to change to "Reasserting". Clearing this flag will change the user-visible status of the session back to "Connected". Setting and clearing this flag only has an effect if the session is in the "Connected" state.
        #[unsafe(method(reasserting))]
        #[unsafe(method_family = none)]
        pub unsafe fn reasserting(&self) -> bool;

        /// Setter for [`reasserting`][Self::reasserting].
        #[unsafe(method(setReasserting:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setReasserting(&self, reasserting: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl NETunnelProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The principal class for an app proxy provider app extension.
    ///
    /// ## Overview
    ///
    /// The [`NEAppProxyProvider`](https://developer.apple.com/documentation/networkextension/neappproxyprovider) class provides access to flows of network data in the form of [`NEAppProxyFlow`](https://developer.apple.com/documentation/networkextension/neappproxyflow) objects. Each [`NEAppProxyFlow`](https://developer.apple.com/documentation/networkextension/neappproxyflow) object corresponds to a socket opened by an app that matches the app rules specified in the current App Proxy configuration. Your App Proxy Provider acts as a transparent network proxy for the flows of network data that it receives.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The `com.apple.developer.networking.networkextension` entitlement is required to use the [`NEAppProxyProvider`](https://developer.apple.com/documentation/networkextension/neappproxyprovider) class. Enable this entitlement when creating an App ID in your developer account.
    ///
    ///
    ///
    /// </div>
    /// ### DNS Handling
    ///
    /// In addition to flows of raw network data from applications, the App Proxy Provider also receives flows of DNS queries in the form of [`NEAppProxyUDPFlow`](https://developer.apple.com/documentation/networkextension/neappproxyudpflow) objects. DNS query flows are received only for applications that use low-level DNS resolution APIs such as [`DNSServiceGetAddrInfo`](https://developer.apple.com/documentation/dnssd/dnsservicegetaddrinfo(_:_:_:_:_:_:_:))(). The App Proxy Provider can specify the DNS resolver configuration that will be used by these applications using the [`setTunnelNetworkSettings:completionHandler:`](https://developer.apple.com/documentation/networkextension/netunnelprovider/settunnelnetworksettings(_:completionhandler:)) method.
    ///
    /// Applications that use higher-level networking APIs such as [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession) and [`NSURLConnection`](https://developer.apple.com/documentation/foundation/nsurlconnection) do not generate DNS queries. Instead the destination hostname for the connection is included in the endpoint information of the [`NEAppProxyFlow`](https://developer.apple.com/documentation/networkextension/neappproxyflow) object.
    ///
    /// ### Creating an App Proxy Provider Extension
    ///
    /// App Proxy Providers run as App Extensions for the `com.apple.networkextension.app-proxy` extension point.
    ///
    /// To create a App Proxy Provider extension, first create a new App Extension target in your project.
    ///
    /// For an example of an Xcode build target for this app extension, see the [SimpleTunnel: Customized Networking Using the NetworkExtension Framework](https://developer.apple.com/library/archive/samplecode/SimpleTunnel/Introduction/Intro.html#//apple_ref/doc/uid/TP40016140) sample code project.
    ///
    /// Once you have a App Proxy Provider extension target, create a sub-class of `NEAppProxyProvider`. Then, set the `NSExtensionPrincipalClass` key in the the extension’s `Info.plist` to the name of your sub-class.
    ///
    /// If it is not already done, set the `NSExtensionPointIdentifier` key in the extension’s `Info.plist` to `com.apple.networkextension.app-proxy`.
    ///
    /// Here is an example of the NSExtension dictionary in a App Proxy Provider extension’s `Info.plist`:
    ///
    /// ```xml
    /// <key>NSExtension</key>
    /// <dict>
    ///     <key>NSExtensionPointIdentifier</key>
    ///     <string>com.apple.networkextension.app-proxy</string>
    ///     <key>NSExtensionPrincipalClass</key>
    ///     <string>MyCustomAppProxyProvider</string>
    /// </dict>
    /// ```
    ///
    /// Finally, add your App Proxy Provider extension target to your app’s Embed App Extensions build phase.
    ///
    /// ### Subclassing Notes
    ///
    /// In order to create a App Proxy Provider extension, you must create a subclass of `NEAppProxyProvider` and override the methods listed below.
    ///
    /// #### Methods to Override
    ///
    /// - [`startProxyWithOptions:completionHandler:`](https://developer.apple.com/documentation/networkextension/neappproxyprovider/startproxy(options:completionhandler:))
    ///
    /// - [`stopProxyWithReason:completionHandler:`](https://developer.apple.com/documentation/networkextension/neappproxyprovider/stopproxy(with:completionhandler:))
    ///
    /// - [`handleNewFlow:`](https://developer.apple.com/documentation/networkextension/neappproxyprovider/handlenewflow(_:))
    ///
    ///
    /// The NEAppProxyProvider class declares the programmatic interface for an object that implements the client side of a custom network proxy solution.
    ///
    /// NEAppProxyProvider is part of NetworkExtension.framework
    #[unsafe(super(NETunnelProvider, NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEAppProxyProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEAppProxyProvider {}
);

impl NEAppProxyProvider {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function is called by the framework when a new proxy instance is being created. Subclasses must override this method to perform whatever steps are necessary to ready the proxy for handling flows of network data.
        ///
        /// Parameter `options`: A dictionary containing keys and values passed by the provider's containing app. If the containing app did not start the proxy then this parameter will be nil.
        ///
        /// Parameter `completionHandler`: A block that must be called when the process of starting the proxy is complete. If the proxy cannot be started then the subclass' implementation of this method must pass a non-nil NSError object to this block. A value of nil passed to the completion handler indicates that the proxy was successfully started.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(startProxyWithOptions:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startProxyWithOptions_completionHandler(
            &self,
            options: Option<&NSDictionary<NSString, AnyObject>>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function is called by the framework when the proxy is being stopped. Subclasses must override this method to perform whatever steps are necessary to stop the proxy.
        ///
        /// Parameter `reason`: An NEProviderStopReason indicating why the proxy is being stopped.
        ///
        /// Parameter `completionHandler`: A block that must be called when the proxy is completely stopped.
        #[unsafe(method(stopProxyWithReason:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopProxyWithReason_completionHandler(
            &self,
            reason: NEProviderStopReason,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        /// This function is called by proxy provider implementations to stop the proxy when a network error is encountered that renders the proxy no longer viable. Subclasses should not override this method.
        ///
        /// Parameter `error`: An NSError object containing details about the error that the proxy provider implementation encountered.
        #[unsafe(method(cancelProxyWithError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelProxyWithError(&self, error: Option<&NSError>);

        /// This function is called by the framework to deliver a new network data flow to the proxy provider implementation. Subclasses must override this method to perform whatever steps are necessary to ready the proxy to receive data from the flow. The proxy provider implementation indicates that the proxy is ready to handle flow data by calling -[NEAppProxyFlow openWithLocalFlowEndpoint:completionHandler:] on the flow. If the proxy implementation decides to not handle the flow and instead terminate it, the subclass implementation of this method should return NO. If the proxy implementation decides to handle the flow, the subclass implementation of this method should return YES. In this case the proxy implementation is responsible for retaining the NEAppProxyFlow object.
        ///
        /// Parameter `flow`: The new flow
        ///
        /// Returns: YES if the proxy implementation has retained the flow and intends to handle the flow data. NO if the proxy implementation has not retained the flow and will not handle the flow data. In NETransparentProxyProvider sub-classes returning NO causes the flow to be handled by the networking stack without any proxy. In all other cases the flow is terminated when NO is returned.
        #[unsafe(method(handleNewFlow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleNewFlow(&self, flow: &NEAppProxyFlow) -> bool;

        /// This function is called by the framework to deliver a new UDP data flow to the proxy provider implementation. Subclasses can override this method to perform whatever steps are necessary to ready the proxy to receive
        /// data from the flow. The proxy provider implementation indicates that the proxy is ready to handle flow data by calling -[NEAppProxyFlow openWithLocalEndpoint:completionHandler:] on the flow. If the proxy implementation decides
        /// to not handle the flow and instead terminate it, the subclass implementation of this method should return NO. If the proxy implementation decides to handle the flow, the subclass implementation of this method should return YES.
        /// In this case the proxy implementation is responsible for retaining the NEAppProxyUDPFlow object.
        /// The default implementation of this method calls -[NEAppProxyProvider handleNewFlow:] and returns its result.
        ///
        /// Parameter `flow`: The new UDP flow
        ///
        /// Parameter `remoteEndpoint`: The initial remote endpoint provided by the proxied app when the flow was opened.
        ///
        /// Returns: YES if the proxy implementation has retained the flow and intends to handle the flow data. NO if the proxy implementation has not retained the flow and will not handle the flow data. In NETransparentProxyProvider sub-classes returning NO causes the flow to be handled by the networking stack without any proxy. In all other cases the flow is terminated when NO is returned.
        #[deprecated]
        #[unsafe(method(handleNewUDPFlow:initialRemoteEndpoint:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleNewUDPFlow_initialRemoteEndpoint(
            &self,
            flow: &NEAppProxyUDPFlow,
            remote_endpoint: &NWEndpoint,
        ) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEAppProxyProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Codes that indicate the source of an error.
/// VPN error codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEVPNError(pub NSInteger);
impl NEVPNError {
    /// An error code indicating the VPN configuration associated with the VPN manager object is invalid.
    ///
    /// ## Discussion
    ///
    /// This error can occur in the following situations:
    ///
    /// - The app or extension tried to save the configuration, but the configuration has missing or invalid configuration properties.
    ///
    /// - The app or extension tried to use the configuration before being successfully saved to the Network Extension preferences.
    ///
    /// - The app or extension tried to use the configuration before being successfully loaded from the Network Extension preferences.
    ///
    ///
    #[doc(alias = "NEVPNErrorConfigurationInvalid")]
    pub const ConfigurationInvalid: Self = Self(1);
    /// An error code indicating the VPN configuration associated with the VPN manager isn’t enabled.
    ///
    /// ## Discussion
    ///
    /// This error can occur when trying to start the VPN connection.
    ///
    ///
    #[doc(alias = "NEVPNErrorConfigurationDisabled")]
    pub const ConfigurationDisabled: Self = Self(2);
    /// The connection to the VPN server failed.
    #[doc(alias = "NEVPNErrorConnectionFailed")]
    pub const ConnectionFailed: Self = Self(3);
    /// An error code that indicates another process modfied the VPN configuration since the last time the app loaded the configuration.
    ///
    /// ## Discussion
    ///
    /// This error also occurs if the app tries to save the VPN configuration before loading it from the Network Extension preferences the first time after the app launches.
    ///
    ///
    #[doc(alias = "NEVPNErrorConfigurationStale")]
    pub const ConfigurationStale: Self = Self(4);
    /// An error code that indicates an error occurred while reading or writing the Network Extension preferences.
    #[doc(alias = "NEVPNErrorConfigurationReadWriteFailed")]
    pub const ConfigurationReadWriteFailed: Self = Self(5);
    /// An error code that indicates that unspecified error occurred.
    #[doc(alias = "NEVPNErrorConfigurationUnknown")]
    pub const ConfigurationUnknown: Self = Self(6);
}

unsafe impl Encode for NEVPNError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    pub static NEVPNErrorDomain: &'static NSString;
}

extern "C" {
    /// Posted after the VPN configuration stored in the Network Extension preferences changes.
    pub static NEVPNConfigurationChangeNotification: &'static NSString;
}

extern_class!(
    /// An object to create and manage a Personal VPN configuration.
    ///
    /// ## Overview
    ///
    /// The [`NEVPNManager`](https://developer.apple.com/documentation/networkextension/nevpnmanager) API gives apps the ability to create and manage a Personal VPN configuration on iOS and macOS. Personal VPN configurations are typically used to provide a service to users that protects their Internet browsing activity on insecure networks such as public Wi-Fi networks.
    ///
    ///
    /// The NEVPNManager class declares the programmatic interface for an object that manages Virtual Private Network (VPN) configurations.
    ///
    /// NEVPNManager declares methods and properties for configuring and controlling a VPN.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEVPNManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEVPNManager {}
);

impl NEVPNManager {
    extern_methods!(
        /// Returns: The singleton NEVPNManager object for the calling process.
        #[unsafe(method(sharedManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedManager() -> Retained<NEVPNManager>;

        #[cfg(feature = "block2")]
        /// This function loads the current VPN configuration from the caller's VPN preferences.
        ///
        /// Parameter `completionHandler`: A block that will be called on the main thread when the load operation is completed. The NSError passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function removes the VPN configuration from the caller's VPN preferences. If the VPN is enabled, has VPN On Demand enabled, and has VPN On Demand rules, the VPN is disabled and the VPN On Demand rules are de-activated.
        ///
        /// Parameter `completionHandler`: A block that will be called on the main thread when the remove operation is completed. The NSError passed to this block will be nil if the remove operation succeeded, non-nil otherwise.
        #[unsafe(method(removeFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// This function saves the VPN configuration in the caller's VPN preferences. If the VPN is enabled, has VPN On Demand enabled, and has VPN On Demand rules, the VPN On Demand rules are activated.
        ///
        ///
        /// Parameter `completionHandler`: A block that will be called on the main thread when the save operation is completed. The NSError passed to this block will be nil if the save operation succeeded, non-nil otherwise.
        #[unsafe(method(saveToPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveToPreferencesWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "objc2-security")]
        /// This function sets an authorization object that can be used to obtain the authorization rights necessary to modify the system VPN configuration.
        ///
        /// Parameter `authorization`: The AuthorizationRef to use to obtain rights.
        ///
        /// # Safety
        ///
        /// `authorization` must be a valid pointer.
        #[unsafe(method(setAuthorization:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAuthorization(&self, authorization: AuthorizationRef);

        /// An array of NEOnDemandRule objects.
        #[unsafe(method(onDemandRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn onDemandRules(&self) -> Option<Retained<NSArray<NEOnDemandRule>>>;

        /// Setter for [`onDemandRules`][Self::onDemandRules].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setOnDemandRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOnDemandRules(&self, on_demand_rules: Option<&NSArray<NEOnDemandRule>>);

        /// Toggles VPN On Demand.
        #[unsafe(method(isOnDemandEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isOnDemandEnabled(&self) -> bool;

        /// Setter for [`isOnDemandEnabled`][Self::isOnDemandEnabled].
        #[unsafe(method(setOnDemandEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOnDemandEnabled(&self, on_demand_enabled: bool);

        /// A string containing a description of the VPN.
        #[unsafe(method(localizedDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedDescription(&self) -> Option<Retained<NSString>>;

        /// Setter for [`localizedDescription`][Self::localizedDescription].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedDescription(&self, localized_description: Option<&NSString>);

        /// An NEVPNProtocol object containing the protocol-specific portion of the VPN configuration.
        #[deprecated]
        #[unsafe(method(protocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocol(&self) -> Option<Retained<NEVPNProtocol>>;

        /// Setter for [`protocol`][Self::protocol].
        #[deprecated]
        #[unsafe(method(setProtocol:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProtocol(&self, protocol: Option<&NEVPNProtocol>);

        /// An NEVPNProtocol object containing the protocol-specific portion of the VPN configuration.
        #[unsafe(method(protocolConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocolConfiguration(&self) -> Option<Retained<NEVPNProtocol>>;

        /// Setter for [`protocolConfiguration`][Self::protocolConfiguration].
        #[unsafe(method(setProtocolConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProtocolConfiguration(
            &self,
            protocol_configuration: Option<&NEVPNProtocol>,
        );

        /// The NEVPNConnection object used for controlling the VPN tunnel.
        #[unsafe(method(connection))]
        #[unsafe(method_family = none)]
        pub unsafe fn connection(&self) -> Retained<NEVPNConnection>;

        /// Toggles the enabled status of the VPN. Setting this property will disable VPN configurations of other apps. This property will be set to NO  when other VPN configurations are enabled.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEVPNManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object to create and manage the tunnel provider’s VPN configuration.
    ///
    /// ## Overview
    ///
    /// Like its superclass [`NEVPNManager`](https://developer.apple.com/documentation/networkextension/nevpnmanager), you use the [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) class to configure and control VPN connections. The difference is that [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) is used to to configure and control VPN connections that use a custom VPN protocol. The client side of the custom protocol implementation is implemented as a Packet Tunnel Provider extension. The Packet Tunnel Provider extension’s containing app uses [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) to create and manage VPN configurations that use the custom protocol, and to control the VPN connections specified by the configurations.
    ///
    /// The [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) class inherits most of its functionality from the [`NEVPNManager`](https://developer.apple.com/documentation/networkextension/nevpnmanager) class. The key differences to be aware of when using [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) are:
    ///
    /// - The [`protocolConfiguration`](https://developer.apple.com/documentation/networkextension/nevpnmanager/protocolconfiguration) property can only be set to instances of the [`NETunnelProviderProtocol`](https://developer.apple.com/documentation/networkextension/netunnelproviderprotocol) class
    ///
    /// - The [`connection`](https://developer.apple.com/documentation/networkextension/nevpnmanager/connection) read-only property is set to an instance of the [`NETunnelProviderSession`](https://developer.apple.com/documentation/networkextension/netunnelprovidersession) class.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The `com.apple.developer.networking.networkextension` entitlement is required to use the [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) class. Enable this entitlement when creating an App ID in your developer account.
    ///
    ///
    ///
    /// </div>
    /// ### Configuration Model
    ///
    /// Each [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) instance corresponds to a single VPN configuration stored in the Network Extension preferences. Multiple VPN configurations can be created and managed by creating multiple [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) instances.
    ///
    /// Each VPN configuration is associated with the app that created it. The app’s view of the Network Extension preferences is limited to include only the configurations that were created by the app.
    ///
    /// VPN configurations created using [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) are classified as regular enterprise VPN configurations (as opposed to the Personal VPN configurations created by `NEVPNManager`). Only one enterprise VPN configuration can be enabled on the system at a time. If both a Personal VPN and an enterprise VPN are active on the system simultaneously, the enterprise VPN takes precedence, meaning that if the routes for the two VPNs conflict then the routes for the enterprise VPN will take precedence. The Personal VPN will remain active and connected while the enterprise VPN is active and connected, and any traffic that is routed to the Personal VPN and is not routed to the enterprise VPN will continue to traverse the Personal VPN.
    ///
    /// ### Profile Configuration
    ///
    /// It is possible to create Packet Tunnel Provider configurations using configuration profiles. See the `com.apple.vpn.managed` and `com.apple.vpn.managed.applayer` payload types in [Configuration Profile Reference](https://developer.apple.com/library/archive/featuredarticles/iPhoneConfigurationProfileRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010206). To specify that a configuration created via a profile payload is associated with a particular app (and therefore allow the app to use `NETunnelProviderManager` to manage the configuration), the app’s bundle identifier must be set as the value of the `VPNSubType` field in the profile payload.
    ///
    /// Credential Storage
    ///
    /// VPN credentials such as private keys and passwords that are imported into the system via configuration profiles are stored in the keychain in a special access group called `com.apple.managed.vpn.shared`. In order to use these credentials the app and Packet Tunnel Provider extension must have the `com.apple.managed.vpn.shared` keychain access group entitlement.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The app and Packet Tunnel Provider extension must not write to the `com.apple.managed.vpn.shared` keychain access group. When writing to the keychain, the app and Packet Tunnel Provider must target a different keychain access group.
    ///
    ///
    ///
    /// </div>
    /// ### Routing Network Data to the VPN
    ///
    /// There are two ways or methods by which network data is routed to the VPN:
    ///
    /// - By destination IP address
    ///
    /// - By source application (Per-App VPN)
    ///
    /// Routing by Destination IP
    ///
    /// This is the default routing method. The IP routes are specified by the Packet Tunnel Provider extension at the time that the VPN tunnel is fully established. See [`NETunnelProvider`](https://developer.apple.com/documentation/networkextension/netunnelprovider) for more details.
    ///
    /// Per-App VPN
    ///
    /// The only way to configure Per-App VPN is by enrolling the device in a Mobile Device Management (MDM) system, and then linking apps that are managed by the MDM system with a VPN configuration created from a `com.apple.vpn.managed.applayer` configuration profile payload. Here are some details about how this works:
    ///
    /// - The MDM server creates a configuration profile containing a `com.apple.vpn.managed.applayer` payload. The `com.apple.vpn.managed.applayer` payload contains all of the usual VPN configuration profile payload fields, and also must contain a `VPNUUID` field, containing a unique string defined by the MDM server.
    ///
    /// - If the VPN provider extension is a Packet Tunnel Provider extension, then the `ProviderType` field in the `com.apple.vpn.managed.applayer` payload should be set to `packet-tunnel`. If the VPN provider extension is an App Proxy Provider extension, then the `ProviderType` field in the `com.apple.vpn.managed.applayer` should be set to `app-proxy`.
    ///
    /// - The MDM server adds a `VPNUUID` key to the attributes dictionary of all of the managed apps that will use the VPN. The value of the `VPNUUID` key must be set to the same unique string contained in the `VPNUUID` field in the `com.apple.vpn.managed.applayer` payload.
    ///
    /// - The MDM server pushes the configuration profile and the managed apps to the iOS device using the MDM protocol.
    ///
    /// The MDM client running on the device creates one app rule in the VPN configuration for each managed app that is linked to the VPN configuration via the `VPNUUID` app attribute.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  It is not possible to create app rules for Apple system apps. The one exception to this rule is Safari. In the case of Safari, the VPN can only tunnel the network traffic for web sites in certain domains, not all web sites. See the `SafariDomains` field in [Configuration Profile Reference](https://developer.apple.com/library/archive/featuredarticles/iPhoneConfigurationProfileRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010206).
    ///
    ///
    ///
    /// </div>
    /// Per-App VPN On Demand
    ///
    /// The Per-App VPN app rules serve as both routing rules and VPN On Demand rules. This is in contrast to IP destination-based routing, where the VPN On Demand rules are configured separately from the routing rules. When the `onDemandEnabled` property is set to [`true`](https://developer.apple.com/documentation/swift/true) and an app that matches the Per-App VPN rules attempts to communicate over the network, the VPN will be started automatically.
    ///
    /// It is possible to set regular VPN On Demand rules in a Per-App VPN configuration via the [`onDemandRules`](https://developer.apple.com/documentation/networkextension/nevpnmanager/ondemandrules) property, but only [`NEOnDemandRuleDisconnect`](https://developer.apple.com/documentation/networkextension/neondemandruledisconnect) rules will be used. When a `NEOnDemandRuleDisconnect` rule matches, apps which match the Per-App VPN rules will bypass the VPN.
    ///
    /// Testing Per-App VPN
    ///
    /// As described above, an MDM server is required to configure Per-App VPN for VPN apps distributed via the App Store. To make testing Per-App VPN easier, it is possible to configure Per-App VPN without an MDM server during development by using the `NETestAppMapping` `Info.plist` key.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The `NETestAppMapping Info.plist` key can only be used to create app rules in apps that are signed with a Development provisioning profile. In apps that are signed with Distribution provisioning profiles the `NETestAppMapping Info.plist` key has no effect.
    ///
    ///
    ///
    /// </div>
    /// Here is what you need to do to make use of this capability:
    ///
    /// - Create a configuration profile containing a `com.apple.vpn.managed.applayer` payload as described in [Configuration Profile Reference](https://developer.apple.com/library/archive/featuredarticles/iPhoneConfigurationProfileRef/Introduction/Introduction.html#//apple_ref/doc/uid/TP40010206). In addition to all of the usual VPN configuration payload fields, the payload must also contain a `VPNUUID` field, containing a unique string defined by you.
    ///
    /// - Add the `NETestAppMapping` key to your app’s `Info.plist`. The value of this key should be a dictionary that maps `VPNUUID` values to arrays of app bundle identifiers. Here is a sample:
    ///
    /// ```xml
    ///   <key>NETestAppMapping</key
    ///   <dict>
    ///       <key>3D7A07D8-97D0-4E5A-BB04-1EB82DD12A35</key>
    ///       <array>
    ///           <string>my.greatenterprise.SuperApp</string>
    ///       </array>
    ///   <dict>
    /// ```
    ///
    /// - Rebuild the app.
    ///
    /// - Install the app and the configuration profile on the device.
    ///
    /// The system will create one app rule in the VPN configuration for each bundle identifier listed in the array in the `NETestAppMapping` dictionary corresponding to the value of the `VPNUUID` field in the `com.apple.vpn.managed.applayer` payload.
    ///
    ///
    /// The NETunnelProviderManager class declares the programmatic interface for an object that is used to configure and control network tunnels provided by NETunnelProviders.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEVPNManager, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NETunnelProviderManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NETunnelProviderManager {}
);

impl NETunnelProviderManager {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function asynchronously reads all of the NETunnelProvider configurations created by the calling app that have previously been saved to disk and returns them as NETunnelProviderManager objects.
        ///
        /// Parameter `completionHandler`: A block that takes an array NETunnelProviderManager objects. The array passed to the block may be empty if no NETunnelProvider configurations were successfully read from the disk.  The NSError passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadAllFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadAllFromPreferencesWithCompletionHandler(
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<NETunnelProviderManager>, *mut NSError),
            >,
        );

        /// Create a NETunnelProviderManager instance that is used to manage a per-app VPN configuration.
        #[unsafe(method(forPerAppVPN))]
        #[unsafe(method_family = none)]
        pub unsafe fn forPerAppVPN() -> Retained<Self>;

        /// This function returns an array of NEAppRule objects.
        #[unsafe(method(copyAppRules))]
        #[unsafe(method_family = copy)]
        pub unsafe fn copyAppRules(&self) -> Option<Retained<NSArray<NEAppRule>>>;

        /// The method by which network traffic is routed to the tunnel. The default is NETunnelProviderRoutingMethodDestinationIP.
        #[unsafe(method(routingMethod))]
        #[unsafe(method_family = none)]
        pub unsafe fn routingMethod(&self) -> NETunnelProviderRoutingMethod;

        /// An array of domain strings. Only applies to per-app VPN configurations. When the per-app VPN is enabled and the user navigates in Safari to a web site within one of these domains,
        /// the web site network traffic is routed through the per-app VPN.
        #[unsafe(method(safariDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn safariDomains(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`safariDomains`][Self::safariDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSafariDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSafariDomains(&self, safari_domains: &NSArray<NSString>);

        /// An array of domain strings. Only applies to per-app VPN configurations. When the per-app VPN is enabled, connections from the Mail app to mail servers within
        /// one of these domains are routed through the per-app VPN.
        #[unsafe(method(mailDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn mailDomains(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`mailDomains`][Self::mailDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMailDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMailDomains(&self, mail_domains: &NSArray<NSString>);

        /// An array of domain strings. Only applies to per-app VPN configurations. When the per-app VPN is enabled, connections from the Calendar app to calendar servers within one of
        /// these domains are routed through the per-app VPN.
        #[unsafe(method(calendarDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn calendarDomains(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`calendarDomains`][Self::calendarDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCalendarDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCalendarDomains(&self, calendar_domains: &NSArray<NSString>);

        /// An array of domain strings. Only applies to per-app VPN configurations. When the per-app VPN is enabled, connections from the Contacts app to contacts servers within one of these
        /// domains are routed through the per-app VPN.
        #[unsafe(method(contactsDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn contactsDomains(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`contactsDomains`][Self::contactsDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setContactsDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContactsDomains(&self, contacts_domains: &NSArray<NSString>);

        #[unsafe(method(appRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn appRules(&self) -> Retained<NSArray<NEAppRule>>;

        /// Setter for [`appRules`][Self::appRules].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAppRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAppRules(&self, app_rules: &NSArray<NEAppRule>);

        /// per-app VPN.
        #[unsafe(method(excludedDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludedDomains(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`excludedDomains`][Self::excludedDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExcludedDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludedDomains(&self, excluded_domains: &NSArray<NSString>);

        #[unsafe(method(associatedDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn associatedDomains(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`associatedDomains`][Self::associatedDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAssociatedDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAssociatedDomains(&self, associated_domains: &NSArray<NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NETunnelProviderManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object to create and manage the app proxy provider’s VPN configuration.
    ///
    /// ## Overview
    ///
    /// Objects cannot be directly instantiated. Instead, App Proxy configurations are created exclusively from `com.apple.vpn.managed.applayer` payloads in configuration profiles.
    ///
    /// App Proxy configurations can only be used with Per-App VPN routing rules. For more details about how to create App Proxy configurations and configure Per-App VPN, see [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The `com.apple.developer.networking.networkextension` entitlement is required in order to use the [`NEAppProxyProviderManager`](https://developer.apple.com/documentation/networkextension/neappproxyprovidermanager) class. Enable this entitlement when creating an App ID in your developer account.
    ///
    ///
    ///
    /// </div>
    ///
    /// The NEAppProxyProviderManager class declares the programmatic interface for an object that is used to configure and control network tunnels provided by NEAppProxyProviders.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NETunnelProviderManager, NEVPNManager, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEAppProxyProviderManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEAppProxyProviderManager {}
);

impl NEAppProxyProviderManager {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function asynchronously reads all of the NEAppProxy configurations associated with the calling app that have previously been saved to disk and returns them as NEAppProxyProviderManager objects.
        ///
        /// Parameter `completionHandler`: A block that takes an array NEAppProxyProviderManager objects. The array passed to the block may be empty if no NETunnelProvider configurations were successfully read from the disk.  The NSError passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadAllFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadAllFromPreferencesWithCompletionHandler(
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<NEAppProxyProviderManager>, *mut NSError),
            >,
        );
    );
}

/// Methods declared on superclass `NETunnelProviderManager`.
impl NEAppProxyProviderManager {
    extern_methods!(
        /// Create a NETunnelProviderManager instance that is used to manage a per-app VPN configuration.
        #[unsafe(method(forPerAppVPN))]
        #[unsafe(method_family = none)]
        pub unsafe fn forPerAppVPN() -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEAppProxyProviderManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object for reading and writing data to and from a TCP connection being proxied by the provider.
    ///
    /// ## Overview
    ///
    /// App Proxy Providers receive TCP connections to be proxied in the form of `NEAppProxyTCPFlow` objects.
    ///
    ///
    /// The NEAppProxyTCPFlow class declares the programmatic interface of an object that is used by NEAppProxyProvider implementations to proxy the payload of TCP connections.
    ///
    /// NEAppProxyTCPFlow is part of NetworkExtension.framework
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEAppProxyFlow, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEAppProxyTCPFlow;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEAppProxyTCPFlow {}
);

impl NEAppProxyTCPFlow {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// Read data from the flow.
        ///
        /// Parameter `completionHandler`: A block that will be executed when some data is read from the flow. The block is passed either the data that was read or a non-nil error if an error occurred. If data has a length of 0 then no data can be subsequently read from the flow. The completion handler is only called for the single read operation that was initiated by calling this method. If the caller wants to read more data then it should call this method again to schedule another read operation and another execution of the completion handler block.
        #[unsafe(method(readDataWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readDataWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Write data to the flow.
        ///
        /// Parameter `data`: The data to write.
        ///
        /// Parameter `completionHandler`: A block that will be executed when the data is written into the associated socket's receive buffer. The caller should use this callback as an indication that it is possible to write more data to the flow without using up excessive buffer memory. If an error occurs while writing the data then a non-nil NSError object is passed to the block.
        #[unsafe(method(writeData:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeData_withCompletionHandler(
            &self,
            data: &NSData,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// An NWEndpoint object containing information about the intended remote endpoint of the flow.
        #[deprecated]
        #[unsafe(method(remoteEndpoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteEndpoint(&self) -> Retained<NWEndpoint>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEAppProxyTCPFlow {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object for reading and writing data to and from a UDP conversation being proxied by the provider.
    ///
    /// ## Overview
    ///
    /// App Proxy Providers receive UDP connections to be proxied in the form of `NEAppProxyUDPFlow` objects.
    ///
    ///
    /// The NEAppProxyUDPFlow class declares the programmatic interface of an object that is used by NEAppProxyProvider implementations to proxy the payload of UDP datagrams.
    ///
    /// NEAppProxyUDPFlow is part of NetworkExtension.framework.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEAppProxyFlow, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEAppProxyUDPFlow;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEAppProxyUDPFlow {}
);

impl NEAppProxyUDPFlow {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// Read datagrams from the flow.
        ///
        /// Parameter `completionHandler`: A block that will be executed when datagrams have been read from the flow. The block takes the datagrams that were read, the destination endpoints of the datagrams, and an NSError. If an error occurred while reading then the error parameter will be non-nil.
        #[deprecated]
        #[unsafe(method(readDatagramsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readDatagramsWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<NSData>, *mut NSArray<NWEndpoint>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Write datagrams to the flow.
        ///
        /// Parameter `datagrams`: An array of NSData objects containing the data to be written.
        ///
        /// Parameter `remoteEndpoints`: The source endpoints of the datagrams.
        ///
        /// Parameter `completionHandler`: A block that will be executed when the datagrams have been written to the corresponding socket's receive buffer.
        #[deprecated]
        #[unsafe(method(writeDatagrams:sentByEndpoints:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeDatagrams_sentByEndpoints_completionHandler(
            &self,
            datagrams: &NSArray<NSData>,
            remote_endpoints: &NSArray<NWEndpoint>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// An NWEndpoint object containing the local endpoint of the flow's corresponding socket.
        #[deprecated]
        #[unsafe(method(localEndpoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn localEndpoint(&self) -> Option<Retained<NWEndpoint>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEAppProxyUDPFlow {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The identity of an app whose traffic is to be routed through the tunnel.
    /// The NEAppRule class declares the programmatic interface for an object that contains the match conditions for a rule that is used to match network traffic originated by applications.
    ///
    /// NEAppRule is used in the context of a Network Extension configuration to specify what traffic should be made available to the Network Extension.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEAppRule;
);

extern_conformance!(
    unsafe impl NSCoding for NEAppRule {}
);

extern_conformance!(
    unsafe impl NSCopying for NEAppRule {}
);

unsafe impl CopyingHelper for NEAppRule {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEAppRule {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEAppRule {}
);

impl NEAppRule {
    extern_methods!(
        /// Initializes a newly-allocated NEAppRule object.
        ///
        /// Parameter `signingIdentifier`: The signing identifier of the executable that matches the rule.
        #[unsafe(method(initWithSigningIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSigningIdentifier(
            this: Allocated<Self>,
            signing_identifier: &NSString,
        ) -> Retained<Self>;

        /// Initializes a newly-allocated NEAppRule object.
        ///
        /// Parameter `signingIdentifier`: The signing identifier of the executable that matches the rule.
        ///
        /// Parameter `designatedRequirement`: The designated requirement of the executable that matches the rule.
        #[unsafe(method(initWithSigningIdentifier:designatedRequirement:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSigningIdentifier_designatedRequirement(
            this: Allocated<Self>,
            signing_identifier: &NSString,
            designated_requirement: &NSString,
        ) -> Retained<Self>;

        /// A string containing a signing identifier. If the code signature of the executable being evaluated has a signing identifier equal to this string and all other conditions of the rule match, then the rule matches.
        #[unsafe(method(matchSigningIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchSigningIdentifier(&self) -> Retained<NSString>;

        /// A string containing a designated requirement. If the code signature of the exectuable being evaluated has a designated requirement equal to this string and all other conditions of the rule match, then the rule matches. This property is required on Mac OS X.
        #[unsafe(method(matchDesignatedRequirement))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchDesignatedRequirement(&self) -> Retained<NSString>;

        /// A string containing a file system path. If the file system path of the executable being evaluated is equal to this string and all other conditions of the rule match, then the rule matches. This property is optional.
        #[unsafe(method(matchPath))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchPath(&self) -> Option<Retained<NSString>>;

        /// Setter for [`matchPath`][Self::matchPath].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMatchPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchPath(&self, match_path: Option<&NSString>);

        /// An array of strings. This property is actually read-only. If the destination host of the network traffic being evaluated has a suffix equal to one of the strings in this array and all other conditions of the rule match, then the rule matches. This property is optional.
        #[unsafe(method(matchDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchDomains(&self) -> Option<Retained<NSArray>>;

        /// Setter for [`matchDomains`][Self::matchDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `match_domains` generic should be of the correct type.
        #[unsafe(method(setMatchDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchDomains(&self, match_domains: Option<&NSArray>);

        /// An array of NEAppRule objects. Use this property to restrict this rule to only match network traffic that is generated by one or more "helper tool" processes that are spawned by the app that matches this rule.
        /// For example, to match network traffic generated by the "curl" command line tool when the tool is run from Terminal.app, create an NEAppRule for Terminal.app and set the app rule's matchTools property to an array that
        /// contains an NEAppRule for the "curl" command line tool.
        /// Set this property to nil (which is the default) to match all network traffic generated by the matching app and all helper tool processes spawned by the matching app.
        #[unsafe(method(matchTools))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchTools(&self) -> Option<Retained<NSArray<NEAppRule>>>;

        /// Setter for [`matchTools`][Self::matchTools].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMatchTools:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchTools(&self, match_tools: Option<&NSArray<NEAppRule>>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEAppRule {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The possible DNS proxy manager errors.
///
/// ## Overview
///
/// These errors appear as the parameter in the completion handler of the methods that you use to manage DNS proxy configuration: [`loadFromPreferencesWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nednsproxymanager/loadfrompreferences(completionhandler:)), [`removeFromPreferencesWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nednsproxymanager/removefrompreferences(completionhandler:)), and [`saveToPreferencesWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nednsproxymanager/savetopreferences(completionhandler:)).
///
///
/// DNS proxy error codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEDNSProxyManagerError(pub NSInteger);
impl NEDNSProxyManagerError {
    /// Invalid DNS proxy configuration that cannot be stored.
    #[doc(alias = "NEDNSProxyManagerErrorConfigurationInvalid")]
    pub const ConfigurationInvalid: Self = Self(1);
    /// Disabled DNS proxy configuration.
    #[doc(alias = "NEDNSProxyManagerErrorConfigurationDisabled")]
    pub const ConfigurationDisabled: Self = Self(2);
    /// Outdated DNS proxy configuration that needs to be loaded.
    ///
    /// ## Discussion
    ///
    /// You must load the configuration with a call to [`loadFromPreferencesWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nednsproxymanager/loadfrompreferences(completionhandler:)) before you can save it.
    ///
    ///
    #[doc(alias = "NEDNSProxyManagerErrorConfigurationStale")]
    pub const ConfigurationStale: Self = Self(3);
    /// Unremovable DNS proxy configuration.
    ///
    /// ## Discussion
    ///
    /// This error occurs if you attempt to use a call to the [`removeFromPreferencesWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nednsproxymanager/removefrompreferences(completionhandler:)) method to remove the DNS proxy configuration when an installed configuration profile specifies a baseline DNS proxy configuration. You can only call the removal method in a development environment where no configuration profile exists.
    ///
    ///
    #[doc(alias = "NEDNSProxyManagerErrorConfigurationCannotBeRemoved")]
    pub const ConfigurationCannotBeRemoved: Self = Self(4);
}

unsafe impl Encode for NEDNSProxyManagerError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEDNSProxyManagerError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The DNS proxy error domain.
    pub static NEDNSProxyErrorDomain: &'static NSString;
}

extern "C" {
    /// A notification that is posted when the DNS proxy configuration changes.
    pub static NEDNSProxyConfigurationDidChangeNotification: &'static NSString;
}

extern_class!(
    /// An object to create and manage an DNS proxy provider’s configuration.
    ///
    /// ## Overview
    ///
    /// A DNS proxy allows your app to intercept all DNS traffic generated on a device. You can use this capability to provide services like DNS traffic encryption, typically by redirecting DNS traffic to your own server. You usually do this in the context of managed devices, such as those owned by a school or an enterprise.
    ///
    /// You create a DNS proxy as an app extension based on a custom subclass of the [`NEDNSProxyProvider`](https://developer.apple.com/documentation/networkextension/nednsproxyprovider) class. You enable and configure this proxy from within your app using the singleton proxy manager instance provided by the [`sharedManager`](https://developer.apple.com/documentation/networkextension/nednsproxymanager/shared()) type method of the [`NEDNSProxyManager`](https://developer.apple.com/documentation/networkextension/nednsproxymanager) class. For example, for a proxy that performs a simple redirect, you can use the proxy manager to define and dynamically configure the destination IP address of the redirected traffic.
    ///
    /// Instances of the proxy manager are thread safe.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To use the [`NEDNSProxyManager`](https://developer.apple.com/documentation/networkextension/nednsproxymanager) class, you must enable the Network Extensions capability in Xcode and select the DNS Proxy capability. See [Configure network extensions](http://help.apple.com/xcode/mac/current/#/dev0b2ef6f08).
    ///
    ///
    ///
    /// </div>
    ///
    /// The NEDNSProxyManager class declares the programmatic interface for an object that manages DNS proxy configurations.
    ///
    /// NEDNSProxyManager declares methods and properties for configuring and controlling a DNS proxy.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEDNSProxyManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEDNSProxyManager {}
);

impl NEDNSProxyManager {
    extern_methods!(
        /// Returns: The singleton NEDNSProxyManager object for the calling process.
        #[unsafe(method(sharedManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedManager() -> Retained<NEDNSProxyManager>;

        #[cfg(feature = "block2")]
        /// This function loads the current DNS proxy configuration from the caller's DNS proxy preferences.
        ///
        /// Parameter `completionHandler`: A block that will be called when the load operation is completed. The NSError passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function removes the DNS proxy configuration from the caller's DNS proxy preferences. If the DNS proxy is enabled, the DNS proxy becomes disabled.
        ///
        /// Parameter `completionHandler`: A block that will be called when the remove operation is completed. The NSError passed to this block will be nil if the remove operation succeeded, non-nil otherwise.
        #[unsafe(method(removeFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function saves the DNS proxy configuration in the caller's DNS proxy preferences. If the DNS proxy is enabled, it will become active.
        ///
        /// Parameter `completionHandler`: A block that will be called when the save operation is completed. The NSError passed to this block will be nil if the save operation succeeded, non-nil otherwise.
        #[unsafe(method(saveToPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveToPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// A string containing a description of the DNS proxy.
        #[unsafe(method(localizedDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedDescription(&self) -> Option<Retained<NSString>>;

        /// Setter for [`localizedDescription`][Self::localizedDescription].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedDescription(&self, localized_description: Option<&NSString>);

        /// An NEDNSProxyProviderProtocol object containing the provider-specific portion of the DNS proxy configuration.
        #[unsafe(method(providerProtocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn providerProtocol(&self) -> Option<Retained<NEDNSProxyProviderProtocol>>;

        /// Setter for [`providerProtocol`][Self::providerProtocol].
        #[unsafe(method(setProviderProtocol:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProviderProtocol(
            &self,
            provider_protocol: Option<&NEDNSProxyProviderProtocol>,
        );

        /// Toggles the enabled status of the DNS proxy. Setting this property will disable DNS proxy configurations of other apps. This property will be set to NO when other DNS proxy configurations are enabled.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEDNSProxyManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The principal class for a DNS proxy provider app extension.
    ///
    /// ## Overview
    ///
    /// A DNS proxy allows your app to intercept all DNS traffic generated on a device. You can use this capability to provide services like DNS traffic encryption, typically by redirecting DNS traffic to your own server. You usually do this in the context of managed devices, such as those owned by a school or an enterprise.
    ///
    /// You create a DNS proxy as an app extension based on a custom subclass of the [`NEDNSProxyProvider`](https://developer.apple.com/documentation/networkextension/nednsproxyprovider) class. Once active, the proxy receives access to flows of DNS traffic in the form of [`NEAppProxyFlow`](https://developer.apple.com/documentation/networkextension/neappproxyflow) instances. Each flow corresponds to a socket opened by an app to UDP port 53 or TCP port 53. Your DNS proxy provider acts as a transparent DNS proxy for the flows of network data that it receives.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To use the [`NEDNSProxyProvider`](https://developer.apple.com/documentation/networkextension/nednsproxyprovider) class, you must enable the Network Extensions capability in Xcode and select the DNS Proxy capability. See [Configure network extensions](http://help.apple.com/xcode/mac/current/#/dev0b2ef6f08).
    ///
    ///
    ///
    /// </div>
    /// When you subclass [`NEDNSProxyProvider`](https://developer.apple.com/documentation/networkextension/nednsproxyprovider), you must provide implementations for the following methods:
    ///
    /// - [`startProxyWithOptions:completionHandler:`](https://developer.apple.com/documentation/networkextension/nednsproxyprovider/startproxy(options:completionhandler:))
    ///
    /// - [`stopProxyWithReason:completionHandler:`](https://developer.apple.com/documentation/networkextension/nednsproxyprovider/stopproxy(with:completionhandler:))
    ///
    /// - [`handleNewFlow:`](https://developer.apple.com/documentation/networkextension/nednsproxyprovider/handlenewflow(_:))
    ///
    ///
    /// The NEDNSProxyProvider class declares the programmatic interface for an object that implements the client side of a custom DNS proxy solution.
    ///
    /// NEDNSProxyProvider is part of NetworkExtension.framework
    #[unsafe(super(NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEDNSProxyProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEDNSProxyProvider {}
);

impl NEDNSProxyProvider {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function is called by the framework when a new proxy instance is being created. Subclasses must override this method to perform whatever steps are necessary to ready the proxy for handling flows of network data.
        ///
        /// Parameter `options`: A dictionary containing keys and values passed by the provider's containing app. If the containing app did not start the proxy then this parameter will be nil.
        ///
        /// Parameter `completionHandler`: A block that must be called when the process of starting the proxy is complete. If the proxy cannot be started then the subclass' implementation of this method must pass a non-nil NSError object to this block. A value of nil passed to the completion handler indicates that the proxy was successfully started.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(startProxyWithOptions:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startProxyWithOptions_completionHandler(
            &self,
            options: Option<&NSDictionary<NSString, AnyObject>>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function is called by the framework when the proxy is being stopped. Subclasses must override this method to perform whatever steps are necessary to stop the proxy.
        ///
        /// Parameter `reason`: An NEProviderStopReason indicating why the proxy is being stopped.
        ///
        /// Parameter `completionHandler`: A block that must be called when the proxy is completely stopped.
        #[unsafe(method(stopProxyWithReason:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopProxyWithReason_completionHandler(
            &self,
            reason: NEProviderStopReason,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        /// This function is called by proxy provider implementations to stop the proxy when a network error is encountered that renders the proxy no longer viable. Subclasses should not override this method.
        ///
        /// Parameter `error`: An NSError object containing details about the error that the proxy provider implementation encountered.
        #[unsafe(method(cancelProxyWithError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelProxyWithError(&self, error: Option<&NSError>);

        /// This function is called by the framework to deliver a new network data flow to the proxy provider implementation. Subclasses must override this method to perform whatever steps are necessary to ready the proxy to receive data from the flow. The proxy provider implementation indicates that the proxy is ready to handle flow data by calling -[NEAppProxyFlow openWithLocalFlowEndpoint:completionHandler:] on the flow. If the proxy implementation decides to not handle the flow and instead terminate it, the subclass implementation of this method should return NO. If the proxy implementation decides to handle the flow, the subclass implementation of this method should return YES. In this case the proxy implementation is responsible for retaining the NEAppProxyFlow object.
        ///
        /// Parameter `flow`: The new flow
        ///
        /// Returns: YES if the proxy implementation has retained the flow and intends to handle the flow data. NO if the proxy implementation has not retained the flow and will not handle the flow data. In this case the flow is terminated.
        #[unsafe(method(handleNewFlow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleNewFlow(&self, flow: &NEAppProxyFlow) -> bool;

        /// This function is called by the framework to deliver a new UDP data flow to the proxy provider implementation. Subclasses can override this method to perform whatever steps are necessary to ready the proxy to receive
        /// data from the flow. The proxy provider implementation indicates that the proxy is ready to handle flow data by calling -[NEAppProxyFlow openWithLocalEndpoint:completionHandler:] on the flow. If the proxy implementation decides
        /// to not handle the flow and instead terminate it, the subclass implementation of this method should return NO. If the proxy implementation decides to handle the flow, the subclass implementation of this method should return YES.
        /// In this case the proxy implementation is responsible for retaining the NEAppProxyUDPFlow object.
        /// The default implementation of this method calls -[NEAppProxyProvider handleNewFlow:] and returns its result.
        ///
        /// Parameter `flow`: The new UDP flow
        ///
        /// Parameter `remoteEndpoint`: The initial remote endpoint provided by the proxied app when the flow was opened.
        ///
        /// Returns: YES if the proxy implementation has retained the flow and intends to handle the flow data. NO if the proxy implementation has not retained the flow and will not handle the flow data. In this case the flow is terminated.
        #[deprecated]
        #[unsafe(method(handleNewUDPFlow:initialRemoteEndpoint:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleNewUDPFlow_initialRemoteEndpoint(
            &self,
            flow: &NEAppProxyUDPFlow,
            remote_endpoint: &NWEndpoint,
        ) -> bool;

        /// The current system DNS settings. Use KVO to watch for changes.
        #[unsafe(method(systemDNSSettings))]
        #[unsafe(method_family = none)]
        pub unsafe fn systemDNSSettings(&self) -> Option<Retained<NSArray<NEDNSSettings>>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEDNSProxyProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// `NEProxyServer` contains settings for a proxy server.
    ///
    /// ## Overview
    ///
    /// `NEProxyServer` instances are used inside of [`NEProxySettings`](https://developer.apple.com/documentation/networkextension/neproxysettings) instances to configure proxy settings for VPN connections.
    ///
    ///
    /// The NEProxyServer class declares the programmatic interface for an object that contains settings for a proxy server.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEProxyServer;
);

extern_conformance!(
    unsafe impl NSCoding for NEProxyServer {}
);

extern_conformance!(
    unsafe impl NSCopying for NEProxyServer {}
);

unsafe impl CopyingHelper for NEProxyServer {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEProxyServer {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEProxyServer {}
);

impl NEProxyServer {
    extern_methods!(
        /// This function initializes a newly-allocated NEProxyServer object
        ///
        /// Parameter `address`: The string representation of the proxy server IP address.
        ///
        /// Parameter `port`: The TCP port of the proxy server.
        #[unsafe(method(initWithAddress:port:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAddress_port(
            this: Allocated<Self>,
            address: &NSString,
            port: NSInteger,
        ) -> Retained<Self>;

        /// The string representation of the proxy server IP address.
        #[unsafe(method(address))]
        #[unsafe(method_family = none)]
        pub unsafe fn address(&self) -> Retained<NSString>;

        /// The TCP port of the proxy server.
        #[unsafe(method(port))]
        #[unsafe(method_family = none)]
        pub unsafe fn port(&self) -> NSInteger;

        /// A flag indicating if the server requires authentication credentials.
        #[unsafe(method(authenticationRequired))]
        #[unsafe(method_family = none)]
        pub unsafe fn authenticationRequired(&self) -> bool;

        /// Setter for [`authenticationRequired`][Self::authenticationRequired].
        #[unsafe(method(setAuthenticationRequired:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAuthenticationRequired(&self, authentication_required: bool);

        /// The username portion of the authentication credential to use when communicating with the proxy server.
        #[unsafe(method(username))]
        #[unsafe(method_family = none)]
        pub unsafe fn username(&self) -> Option<Retained<NSString>>;

        /// Setter for [`username`][Self::username].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setUsername:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUsername(&self, username: Option<&NSString>);

        /// The password portion of the authentication credential to use when communicating with the proxy server. This property is only saved persistently if the username property is non-nil and non-empty and if the authenticationRequired flag is set.
        #[unsafe(method(password))]
        #[unsafe(method_family = none)]
        pub unsafe fn password(&self) -> Option<Retained<NSString>>;

        /// Setter for [`password`][Self::password].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPassword:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPassword(&self, password: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEProxyServer {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// `NEProxySettings` contains HTTP proxy settings.
    ///
    /// ## Overview
    ///
    /// `NEProxySettings` is used in the context of a VPN configuration to specify the proxy that should be used for network traffic when the VPN is active.
    ///
    /// Instances of this class are thread safe.
    ///
    ///
    /// The NEProxySettings class declares the programmatic interface for an object that contains proxy settings.
    ///
    /// NEProxySettings is used in the context of a Network Extension configuration to specify the proxy that should be used for network traffic when the Network Extension is active.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEProxySettings;
);

extern_conformance!(
    unsafe impl NSCoding for NEProxySettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEProxySettings {}
);

unsafe impl CopyingHelper for NEProxySettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEProxySettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEProxySettings {}
);

impl NEProxySettings {
    extern_methods!(
        /// A boolean indicating if proxy auto-configuration is enabled.
        #[unsafe(method(autoProxyConfigurationEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn autoProxyConfigurationEnabled(&self) -> bool;

        /// Setter for [`autoProxyConfigurationEnabled`][Self::autoProxyConfigurationEnabled].
        #[unsafe(method(setAutoProxyConfigurationEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAutoProxyConfigurationEnabled(
            &self,
            auto_proxy_configuration_enabled: bool,
        );

        /// A URL specifying where the PAC script is located.
        #[unsafe(method(proxyAutoConfigurationURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn proxyAutoConfigurationURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`proxyAutoConfigurationURL`][Self::proxyAutoConfigurationURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProxyAutoConfigurationURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProxyAutoConfigurationURL(
            &self,
            proxy_auto_configuration_url: Option<&NSURL>,
        );

        /// A string containing the PAC JavaScript source code.
        #[unsafe(method(proxyAutoConfigurationJavaScript))]
        #[unsafe(method_family = none)]
        pub unsafe fn proxyAutoConfigurationJavaScript(&self) -> Option<Retained<NSString>>;

        /// Setter for [`proxyAutoConfigurationJavaScript`][Self::proxyAutoConfigurationJavaScript].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProxyAutoConfigurationJavaScript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProxyAutoConfigurationJavaScript(
            &self,
            proxy_auto_configuration_java_script: Option<&NSString>,
        );

        /// A boolean indicating if the static HTTP proxy is enabled.
        #[unsafe(method(HTTPEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn HTTPEnabled(&self) -> bool;

        /// Setter for [`HTTPEnabled`][Self::HTTPEnabled].
        #[unsafe(method(setHTTPEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHTTPEnabled(&self, http_enabled: bool);

        /// A NEProxyServer object containing the HTTP proxy server settings.
        #[unsafe(method(HTTPServer))]
        #[unsafe(method_family = none)]
        pub unsafe fn HTTPServer(&self) -> Option<Retained<NEProxyServer>>;

        /// Setter for [`HTTPServer`][Self::HTTPServer].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setHTTPServer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHTTPServer(&self, http_server: Option<&NEProxyServer>);

        /// A boolean indicating if the static HTTPS proxy is enabled.
        #[unsafe(method(HTTPSEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn HTTPSEnabled(&self) -> bool;

        /// Setter for [`HTTPSEnabled`][Self::HTTPSEnabled].
        #[unsafe(method(setHTTPSEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHTTPSEnabled(&self, https_enabled: bool);

        /// A NEProxyServer object containing the HTTPS proxy server settings.
        #[unsafe(method(HTTPSServer))]
        #[unsafe(method_family = none)]
        pub unsafe fn HTTPSServer(&self) -> Option<Retained<NEProxyServer>>;

        /// Setter for [`HTTPSServer`][Self::HTTPSServer].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setHTTPSServer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHTTPSServer(&self, https_server: Option<&NEProxyServer>);

        /// A flag indicating if the proxy settings should not be used for network destinations specified using single-label host names.
        #[unsafe(method(excludeSimpleHostnames))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludeSimpleHostnames(&self) -> bool;

        /// Setter for [`excludeSimpleHostnames`][Self::excludeSimpleHostnames].
        #[unsafe(method(setExcludeSimpleHostnames:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludeSimpleHostnames(&self, exclude_simple_hostnames: bool);

        /// An array of domain strings. If the destination host name of a connection shares a suffix with one of these strings then the proxy settings will not be used for the connection.
        #[unsafe(method(exceptionList))]
        #[unsafe(method_family = none)]
        pub unsafe fn exceptionList(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`exceptionList`][Self::exceptionList].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExceptionList:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExceptionList(&self, exception_list: Option<&NSArray<NSString>>);

        /// An array of domain strings. If the destination host name of a connection shares a suffix with one of these strings then the proxy settings will be used for the connection. Otherwise the proxy settings will not be used. If this property is nil then all connections to which the Network Extension applies will use the proxy settings.
        #[unsafe(method(matchDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchDomains(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`matchDomains`][Self::matchDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMatchDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchDomains(&self, match_domains: Option<&NSArray<NSString>>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEProxySettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Settings common to both IKEv2 and IPsec VPN configurations.
    ///
    /// ## Overview
    ///
    /// The [`NEVPNProtocol`](https://developer.apple.com/documentation/networkextension/nevpnprotocol) class is an abstract base class with one subclass for each type of supported VPN configuration. This class provides properties for configuring the VPN, authenticating network connections, and routing network traffic. You can include all network traffic, with some exceptions, and selectively exclude types of network traffic.
    ///
    /// Instances of this class are thread-safe.
    ///
    ///
    /// The NEVPNProtocol class declares the programmatic interface of an object that manages the protocol-specific portion of a VPN configuration.
    ///
    /// NEVPNProtocol is an abstract base class from which other protocol-specific classes are derived.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEVPNProtocol;
);

extern_conformance!(
    unsafe impl NSCoding for NEVPNProtocol {}
);

extern_conformance!(
    unsafe impl NSCopying for NEVPNProtocol {}
);

unsafe impl CopyingHelper for NEVPNProtocol {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEVPNProtocol {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEVPNProtocol {}
);

impl NEVPNProtocol {
    extern_methods!(
        /// The VPN server. Depending on the protocol, may be an IP address, host name, or URL.
        #[unsafe(method(serverAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn serverAddress(&self) -> Option<Retained<NSString>>;

        /// Setter for [`serverAddress`][Self::serverAddress].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setServerAddress:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServerAddress(&self, server_address: Option<&NSString>);

        /// The username component of the VPN authentication credential.
        #[unsafe(method(username))]
        #[unsafe(method_family = none)]
        pub unsafe fn username(&self) -> Option<Retained<NSString>>;

        /// Setter for [`username`][Self::username].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setUsername:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUsername(&self, username: Option<&NSString>);

        /// The password component of the VPN authentication credential. The value is a persistent reference to a keychain item with the kSecClassGenericPassword class.
        #[unsafe(method(passwordReference))]
        #[unsafe(method_family = none)]
        pub unsafe fn passwordReference(&self) -> Option<Retained<NSData>>;

        /// Setter for [`passwordReference`][Self::passwordReference].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPasswordReference:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPasswordReference(&self, password_reference: Option<&NSData>);

        /// The certificate and private key component of the VPN authentication credential. The value is a persistent reference to a keychain item with the kSecClassIdentity class.
        #[unsafe(method(identityReference))]
        #[unsafe(method_family = none)]
        pub unsafe fn identityReference(&self) -> Option<Retained<NSData>>;

        /// Setter for [`identityReference`][Self::identityReference].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentityReference:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentityReference(&self, identity_reference: Option<&NSData>);

        /// The PKCS12 data for the VPN authentication identity. The value is a NSData in PKCS12 format.
        #[unsafe(method(identityData))]
        #[unsafe(method_family = none)]
        pub unsafe fn identityData(&self) -> Option<Retained<NSData>>;

        /// Setter for [`identityData`][Self::identityData].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentityData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentityData(&self, identity_data: Option<&NSData>);

        /// The password to be used to decrypt the PKCS12 identity data.
        #[unsafe(method(identityDataPassword))]
        #[unsafe(method_family = none)]
        pub unsafe fn identityDataPassword(&self) -> Option<Retained<NSString>>;

        /// Setter for [`identityDataPassword`][Self::identityDataPassword].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentityDataPassword:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentityDataPassword(&self, identity_data_password: Option<&NSString>);

        /// If YES, the VPN connection will be disconnected when the device goes to sleep. The default is NO.
        #[unsafe(method(disconnectOnSleep))]
        #[unsafe(method_family = none)]
        pub unsafe fn disconnectOnSleep(&self) -> bool;

        /// Setter for [`disconnectOnSleep`][Self::disconnectOnSleep].
        #[unsafe(method(setDisconnectOnSleep:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisconnectOnSleep(&self, disconnect_on_sleep: bool);

        /// An NEProxySettings object containing the proxy settings to use for connections routed through the tunnel.
        #[unsafe(method(proxySettings))]
        #[unsafe(method_family = none)]
        pub unsafe fn proxySettings(&self) -> Option<Retained<NEProxySettings>>;

        /// Setter for [`proxySettings`][Self::proxySettings].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProxySettings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProxySettings(&self, proxy_settings: Option<&NEProxySettings>);

        /// If this property is set to YES then all network traffic is routed through the tunnel, with some exclusions. Several of the exclusions
        /// can be controlled with the excludeLocalNetworks, excludeCellularServices, excludeAPNs and excludeDeviceCommunication properties. See the documentation for those properties.
        /// The following traffic is always excluded from the tunnel:
        /// - Traffic necessary for connecting and maintaining the device's network connection, such as DHCP.
        /// - Traffic necessary for connecting to captive networks.
        /// - Certain cellular services traffic that is not routable over the internet and is instead directly routed to the cellular network. See the
        /// excludeCellularServices property for more details.
        /// - Network communication with a companion device such as a watchOS device.
        /// The default value of this property is NO.
        #[unsafe(method(includeAllNetworks))]
        #[unsafe(method_family = none)]
        pub unsafe fn includeAllNetworks(&self) -> bool;

        /// Setter for [`includeAllNetworks`][Self::includeAllNetworks].
        #[unsafe(method(setIncludeAllNetworks:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIncludeAllNetworks(&self, include_all_networks: bool);

        /// If YES, all traffic destined for local networks will be excluded from the tunnel. The default is NO on macOS and YES on iOS.
        #[unsafe(method(excludeLocalNetworks))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludeLocalNetworks(&self) -> bool;

        /// Setter for [`excludeLocalNetworks`][Self::excludeLocalNetworks].
        #[unsafe(method(setExcludeLocalNetworks:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludeLocalNetworks(&self, exclude_local_networks: bool);

        /// If includeAllNetworks is set to YES and this property is set to YES, then internet-routable network traffic for cellular services
        /// (VoLTE, Wi-Fi Calling, IMS, MMS, Visual Voicemail, etc.) is excluded from the tunnel. Note that some cellular carriers route cellular services traffic
        /// directly to the carrier network, bypassing the internet. Such cellular services traffic is always excluded from the tunnel. The default value of this
        /// property is YES.
        #[unsafe(method(excludeCellularServices))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludeCellularServices(&self) -> bool;

        /// Setter for [`excludeCellularServices`][Self::excludeCellularServices].
        #[unsafe(method(setExcludeCellularServices:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludeCellularServices(&self, exclude_cellular_services: bool);

        /// If includeAllNetworks is set to YES and this property is set to YES, then network traffic for the Apple Push Notification service (APNs)
        /// is excluded from the tunnel. The default value of this property is YES.
        #[unsafe(method(excludeAPNs))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludeAPNs(&self) -> bool;

        /// Setter for [`excludeAPNs`][Self::excludeAPNs].
        #[unsafe(method(setExcludeAPNs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludeAPNs(&self, exclude_ap_ns: bool);

        /// If includeAllNetworks is set to YES and this property is set to YES, then network traffic used for communicating with devices connected via USB or Wi-Fi is excluded
        /// from the tunnel. For example, Xcode uses a network tunnel to communicate with connected development devices like iPhone, iPad and TV. The default value of this
        /// property is YES.
        #[unsafe(method(excludeDeviceCommunication))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludeDeviceCommunication(&self) -> bool;

        /// Setter for [`excludeDeviceCommunication`][Self::excludeDeviceCommunication].
        #[unsafe(method(setExcludeDeviceCommunication:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludeDeviceCommunication(&self, exclude_device_communication: bool);

        /// If YES, route rules for this tunnel will take precendence over any locally-defined routes. The default is NO.
        #[unsafe(method(enforceRoutes))]
        #[unsafe(method_family = none)]
        pub unsafe fn enforceRoutes(&self) -> bool;

        /// Setter for [`enforceRoutes`][Self::enforceRoutes].
        #[unsafe(method(setEnforceRoutes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnforceRoutes(&self, enforce_routes: bool);

        /// Identification string of the associated Cellular slice.  If present, VPN tunnel will be scoped to the associated Cellular slice whenever slice is active.
        /// Otherwise, VPN tunnel will fallback onto the primary interface.
        #[unsafe(method(sliceUUID))]
        #[unsafe(method_family = none)]
        pub unsafe fn sliceUUID(&self) -> Option<Retained<NSString>>;

        /// Setter for [`sliceUUID`][Self::sliceUUID].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSliceUUID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSliceUUID(&self, slice_uuid: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEVPNProtocol {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Configuration parameters for a DNS proxy.
    /// The NEDNSProxyProviderProtocol class declares the programmatic interface for an object that contains NEDNSProxyProvider-specific configuration settings.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEVPNProtocol, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEDNSProxyProviderProtocol;
);

extern_conformance!(
    unsafe impl NSCoding for NEDNSProxyProviderProtocol {}
);

extern_conformance!(
    unsafe impl NSCopying for NEDNSProxyProviderProtocol {}
);

unsafe impl CopyingHelper for NEDNSProxyProviderProtocol {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEDNSProxyProviderProtocol {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEDNSProxyProviderProtocol {}
);

impl NEDNSProxyProviderProtocol {
    extern_methods!(
        /// A dictionary containing NEDNSProxyProvider vendor-specific configuration parameters. This dictionary is passed as-is to NEDNSProxyProviders when a DNS proxy is started.
        #[unsafe(method(providerConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn providerConfiguration(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        /// Setter for [`providerConfiguration`][Self::providerConfiguration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `provider_configuration` generic should be of the correct type.
        #[unsafe(method(setProviderConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProviderConfiguration(
            &self,
            provider_configuration: Option<&NSDictionary<NSString, AnyObject>>,
        );

        /// A string containing the bundle identifier of the NEDNSProxyProvider to be used by this configuration.
        #[unsafe(method(providerBundleIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn providerBundleIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`providerBundleIdentifier`][Self::providerBundleIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProviderBundleIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProviderBundleIdentifier(
            &self,
            provider_bundle_identifier: Option<&NSString>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NEDNSProxyProviderProtocol {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// DNS protocol variants
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEDNSProtocol(pub NSInteger);
impl NEDNSProtocol {
    /// The DNS server uses cleartext UDP or TCP over port 53.
    #[doc(alias = "NEDNSProtocolCleartext")]
    pub const Cleartext: Self = Self(1);
    /// The DNS server uses DNS-over-TLS.
    #[doc(alias = "NEDNSProtocolTLS")]
    pub const TLS: Self = Self(2);
    /// The DNS server uses DNS-over-HTTPS.
    #[doc(alias = "NEDNSProtocolHTTPS")]
    pub const HTTPS: Self = Self(3);
}

unsafe impl Encode for NEDNSProtocol {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEDNSProtocol {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The DNS resolver settings of a network tunnel or a system-wide configuration.
    /// The NEDNSSettings class declares the programmatic interface for an object that contains DNS settings.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEDNSSettings;
);

extern_conformance!(
    unsafe impl NSCoding for NEDNSSettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEDNSSettings {}
);

unsafe impl CopyingHelper for NEDNSSettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEDNSSettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEDNSSettings {}
);

impl NEDNSSettings {
    extern_methods!(
        /// The DNS protocol used by the settings.
        #[unsafe(method(dnsProtocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn dnsProtocol(&self) -> NEDNSProtocol;

        /// Initialize a newly-allocated NEDNSSettings object.
        ///
        /// Parameter `servers`: An array of DNS server IP address strings.
        #[unsafe(method(initWithServers:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithServers(
            this: Allocated<Self>,
            servers: &NSArray<NSString>,
        ) -> Retained<Self>;

        /// An array of DNS server address strings.
        #[unsafe(method(servers))]
        #[unsafe(method_family = none)]
        pub unsafe fn servers(&self) -> Retained<NSArray<NSString>>;

        /// An array of DNS server search domain strings.
        #[unsafe(method(searchDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn searchDomains(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`searchDomains`][Self::searchDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSearchDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSearchDomains(&self, search_domains: Option<&NSArray<NSString>>);

        /// A string containing the DNS domain.
        #[unsafe(method(domainName))]
        #[unsafe(method_family = none)]
        pub unsafe fn domainName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`domainName`][Self::domainName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDomainName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDomainName(&self, domain_name: Option<&NSString>);

        /// An array of strings containing domain strings. If this property is non-nil, the DNS settings will only be used to resolve host names within the specified domains.
        #[unsafe(method(matchDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchDomains(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`matchDomains`][Self::matchDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMatchDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchDomains(&self, match_domains: Option<&NSArray<NSString>>);

        /// A boolean indicating if the match domains should be appended to the search domain list.  Default is NO (match domains will be appended to the search domain list).
        #[unsafe(method(matchDomainsNoSearch))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchDomainsNoSearch(&self) -> bool;

        /// Setter for [`matchDomainsNoSearch`][Self::matchDomainsNoSearch].
        #[unsafe(method(setMatchDomainsNoSearch:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchDomainsNoSearch(&self, match_domains_no_search: bool);

        /// A boolean indicating if failover to the default system resolver is permitted on resolution failure.
        #[unsafe(method(allowFailover))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowFailover(&self) -> bool;

        /// Setter for [`allowFailover`][Self::allowFailover].
        #[unsafe(method(setAllowFailover:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowFailover(&self, allow_failover: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEDNSSettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The DNS resolver settings for a DNS-over-TLS server.
    #[unsafe(super(NEDNSSettings, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEDNSOverTLSSettings;
);

extern_conformance!(
    unsafe impl NSCoding for NEDNSOverTLSSettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEDNSOverTLSSettings {}
);

unsafe impl CopyingHelper for NEDNSOverTLSSettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEDNSOverTLSSettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEDNSOverTLSSettings {}
);

impl NEDNSOverTLSSettings {
    extern_methods!(
        /// The name of the server to use for TLS certificate validation.
        #[unsafe(method(serverName))]
        #[unsafe(method_family = none)]
        pub unsafe fn serverName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`serverName`][Self::serverName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setServerName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServerName(&self, server_name: Option<&NSString>);

        /// The optional certificate identity keychain reference to use as a TLS client certificate.
        #[unsafe(method(identityReference))]
        #[unsafe(method_family = none)]
        pub unsafe fn identityReference(&self) -> Option<Retained<NSData>>;

        /// Setter for [`identityReference`][Self::identityReference].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentityReference:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentityReference(&self, identity_reference: Option<&NSData>);
    );
}

/// Methods declared on superclass `NEDNSSettings`.
impl NEDNSOverTLSSettings {
    extern_methods!(
        /// Initialize a newly-allocated NEDNSSettings object.
        ///
        /// Parameter `servers`: An array of DNS server IP address strings.
        #[unsafe(method(initWithServers:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithServers(
            this: Allocated<Self>,
            servers: &NSArray<NSString>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEDNSOverTLSSettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The DNS resolver settings for a DNS-over-HTTPS server.
    #[unsafe(super(NEDNSSettings, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEDNSOverHTTPSSettings;
);

extern_conformance!(
    unsafe impl NSCoding for NEDNSOverHTTPSSettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEDNSOverHTTPSSettings {}
);

unsafe impl CopyingHelper for NEDNSOverHTTPSSettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEDNSOverHTTPSSettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEDNSOverHTTPSSettings {}
);

impl NEDNSOverHTTPSSettings {
    extern_methods!(
        /// The URL to which to make DNS-over-HTTPS requests. The format should be an HTTPS URL with the path indicating the location of the DNS-over-HTTPS server, such as: "https://dnsserver.example.net/dns-query".
        #[unsafe(method(serverURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn serverURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`serverURL`][Self::serverURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setServerURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServerURL(&self, server_url: Option<&NSURL>);

        /// The optional certificate identity keychain reference to use as a TLS client certificate.
        #[unsafe(method(identityReference))]
        #[unsafe(method_family = none)]
        pub unsafe fn identityReference(&self) -> Option<Retained<NSData>>;

        /// Setter for [`identityReference`][Self::identityReference].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentityReference:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentityReference(&self, identity_reference: Option<&NSData>);
    );
}

/// Methods declared on superclass `NEDNSSettings`.
impl NEDNSOverHTTPSSettings {
    extern_methods!(
        /// Initialize a newly-allocated NEDNSSettings object.
        ///
        /// Parameter `servers`: An array of DNS server IP address strings.
        #[unsafe(method(initWithServers:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithServers(
            this: Allocated<Self>,
            servers: &NSArray<NSString>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEDNSOverHTTPSSettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Error codes specific to DNS managers.
/// DNS Settings Manager error codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEDNSSettingsManagerError(pub NSInteger);
impl NEDNSSettingsManagerError {
    /// An error code that indicates the DNS settings manager is invalid.
    #[doc(alias = "NEDNSSettingsManagerErrorConfigurationInvalid")]
    pub const ConfigurationInvalid: Self = Self(1);
    /// An error code that indicates the DNS settings manager isn’t enabled.
    #[doc(alias = "NEDNSSettingsManagerErrorConfigurationDisabled")]
    pub const ConfigurationDisabled: Self = Self(2);
    /// An error code that indicates the DNS settings manager isn’t loaded.
    #[doc(alias = "NEDNSSettingsManagerErrorConfigurationStale")]
    pub const ConfigurationStale: Self = Self(3);
    /// An error code that indicates removing the DNS settings manager failed.
    #[doc(alias = "NEDNSSettingsManagerErrorConfigurationCannotBeRemoved")]
    pub const ConfigurationCannotBeRemoved: Self = Self(4);
}

unsafe impl Encode for NEDNSSettingsManagerError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEDNSSettingsManagerError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The domain for errors resulting from calls to the DNS settings manager.
    ///
    /// ## Discussion
    ///
    /// Match this constant to the [`domain`](https://developer.apple.com/documentation/foundation/nserror/domain) of an [`NSError`](https://developer.apple.com/documentation/foundation/nserror) encountered when calling methods on [`NEDNSSettingsManager`](https://developer.apple.com/documentation/networkextension/nednssettingsmanager). The [`NEDNSSettingsManagerError`](https://developer.apple.com/documentation/networkextension/nednssettingsmanagererror) enumeration defines possible [`code`](https://developer.apple.com/documentation/foundation/nserror/code) values for these errors.
    ///
    ///
    pub static NEDNSSettingsErrorDomain: &'static NSString;
}

extern "C" {
    pub static NEDNSSettingsConfigurationDidChangeNotification: &'static NSString;
}

extern_class!(
    /// An object you use to create and manage a DNS settings configuration.
    ///
    /// ## Overview
    ///
    /// When your app starts up, access the shared instance of the DNS settings manager, and load existing settings from the preferences using [`loadFromPreferencesWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nednssettingsmanager/loadfrompreferences(completionhandler:)). You can define your DNS server configuration, and persist it by calling [`saveToPreferencesWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nednssettingsmanager/savetopreferences(completionhandler:)).
    ///
    /// In order to use your DNS settings, the user needs to enable it in the Settings app on iOS or in System Preferences on macOS.
    ///
    ///
    /// The NEDNSSettingsManager class declares the programmatic interface for an object that manages DNS settings configurations.
    ///
    /// NEDNSSettingsManager declares methods and properties for configuring and controlling DNS settings on the system.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEDNSSettingsManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEDNSSettingsManager {}
);

impl NEDNSSettingsManager {
    extern_methods!(
        /// Returns: The singleton NEDNSSettingsManager object for the calling process.
        #[unsafe(method(sharedManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedManager() -> Retained<NEDNSSettingsManager>;

        #[cfg(feature = "block2")]
        /// This function loads the current DNS settings configuration from the caller's DNS settings preferences.
        ///
        /// Parameter `completionHandler`: A block that will be called when the load operation is completed. The NSError passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function removes the DNS settings configuration from the caller's DNS settings preferences. If the DNS settings are enabled, the DNS settings becomes disabled.
        ///
        /// Parameter `completionHandler`: A block that will be called when the remove operation is completed. The NSError passed to this block will be nil if the remove operation succeeded, non-nil otherwise.
        #[unsafe(method(removeFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function saves the DNS settingsconfiguration in the caller's DNS settings preferences. If the DNS settings are enabled, they will become active.
        ///
        /// Parameter `completionHandler`: A block that will be called when the save operation is completed. The NSError passed to this block will be nil if the save operation succeeded, non-nil otherwise.
        #[unsafe(method(saveToPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveToPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// A string containing a description of the DNS settings.
        #[unsafe(method(localizedDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedDescription(&self) -> Option<Retained<NSString>>;

        /// Setter for [`localizedDescription`][Self::localizedDescription].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedDescription(&self, localized_description: Option<&NSString>);

        /// An NEDNSSettings object containing the DNS resolver configuration to apply to the system.
        #[unsafe(method(dnsSettings))]
        #[unsafe(method_family = none)]
        pub unsafe fn dnsSettings(&self) -> Option<Retained<NEDNSSettings>>;

        /// Setter for [`dnsSettings`][Self::dnsSettings].
        #[unsafe(method(setDnsSettings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDnsSettings(&self, dns_settings: Option<&NEDNSSettings>);

        /// An array of NEOnDemandRule objects. If nil, the associated DNS settings will always apply. If non-nil, the array describes the networks on which the DNS configuration should take effect or not.
        #[unsafe(method(onDemandRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn onDemandRules(&self) -> Option<Retained<NSArray<NEOnDemandRule>>>;

        /// Setter for [`onDemandRules`][Self::onDemandRules].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setOnDemandRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOnDemandRules(&self, on_demand_rules: Option<&NSArray<NEOnDemandRule>>);

        /// Checks the enabled status of the DNS settings. DNS settings must be enabled by the user in Settings or System Preferences.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEDNSSettingsManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// A type to represent network protocols used by routing rules.
/// IP protocols
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NENetworkRuleProtocol(pub NSInteger);
impl NENetworkRuleProtocol {
    /// A rule protocol to match TCP and UDP traffic.
    #[doc(alias = "NENetworkRuleProtocolAny")]
    pub const Any: Self = Self(0);
    /// A rule protocol to match TCP traffic.
    #[doc(alias = "NENetworkRuleProtocolTCP")]
    pub const TCP: Self = Self(1);
    /// A rule protocol to match UDP traffic.
    #[doc(alias = "NENetworkRuleProtocolUDP")]
    pub const UDP: Self = Self(2);
}

unsafe impl Encode for NENetworkRuleProtocol {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NENetworkRuleProtocol {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A type to represent the direction of network traffic.
/// The direction of network traffic
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NETrafficDirection(pub NSInteger);
impl NETrafficDirection {
    /// A direction that matches either inbound or outbound traffic.
    #[doc(alias = "NETrafficDirectionAny")]
    pub const Any: Self = Self(0);
    /// The inbound traffic direction.
    #[doc(alias = "NETrafficDirectionInbound")]
    pub const Inbound: Self = Self(1);
    /// The outbound traffic direction.
    #[doc(alias = "NETrafficDirectionOutbound")]
    pub const Outbound: Self = Self(2);
}

unsafe impl Encode for NETrafficDirection {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NETrafficDirection {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A rule to match attributes of network traffic.
    /// The NENetworkRule class declares the programmatic interface of an object that contains a specification of a rule that matches the attributes of network traffic.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NENetworkRule;
);

extern_conformance!(
    unsafe impl NSCoding for NENetworkRule {}
);

extern_conformance!(
    unsafe impl NSCopying for NENetworkRule {}
);

unsafe impl CopyingHelper for NENetworkRule {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NENetworkRule {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NENetworkRule {}
);

impl NENetworkRule {
    extern_methods!(
        /// Initialize a newly-allocated NENetworkRule object that matches network traffic destined for a host within a specific network.
        ///
        /// Parameter `networkEndpoint`: An endpoint object that contains the port and address or network that the rule matches. This endpoint must contain an address, not a hostname.
        /// If the address is a wildcard address (0.0.0.0 or ::) then the rule will match all destinations except for loopback (127.0.0.1 or ::1). To match loopback traffic set the address to the loopback address.
        /// If the port string of the endpoint is "0" or is the empty string, then the rule will match traffic on any port destined for the given address or network.
        ///
        /// Parameter `destinationPrefix`: An integer that in combination with the address in the endpoint specifies the destination network that the rule matches.
        ///
        /// Parameter `protocol`: A NENetworkRuleProtocol value indicating the protocol that the rule matches.
        ///
        /// Returns: The initialized NENetworkRule instance.
        #[deprecated]
        #[unsafe(method(initWithDestinationNetwork:prefix:protocol:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDestinationNetwork_prefix_protocol(
            this: Allocated<Self>,
            network_endpoint: &NWHostEndpoint,
            destination_prefix: NSUInteger,
            protocol: NENetworkRuleProtocol,
        ) -> Retained<Self>;

        /// Initialize a newly-allocated NENetworkRule object that matches network traffic destined for a host within a specific DNS domain.
        ///
        /// Parameter `hostEndpoint`: An endpoint object that contains the port and hostname or domain that the rule matches. This endpoint must contain a hostname, not an address.
        /// If the port string of the NWHostEndpoint is "0" or is the empty string, then the rule will match traffic on any port destined for the given hostname or domain.
        /// If the hostname string of the endpoint consists of a single label, then the rule will match traffic destined to the specific host with that single label as its name.
        /// If the hostname string of the endpoint consists of 2 or more labels, then the rule will match traffic destined to hosts within the domain specified by the hostname string.
        /// Examples:
        /// [[NENetworkRule alloc] initWithDestinationHost:[NWHostEndpoint endpointWithHostname:
        /// "
        /// com" port:@"0"] protocol:NENetworkRuleProtocolAny] - matches all TCP and UDP traffic to the host named "com".
        /// [[NENetworkRule alloc] initWithDestinationHost:[NWHostEndpoint endpointWithHostname:
        /// "
        /// example.com" port:@"0"] protocol:NENetworkRuleProtocolAny] - matches all TCP and UDP traffic to hosts in the "example.com" DNS domain, including all DNS queries for names in the example.com DNS domain.
        /// [[NENetworkRule alloc] initWithDestinationHost:[NWHostEndpoint endpointWithHostname:
        /// "
        /// example.com" port:@"53"] protocol:NENetworkRuleProtocolAny] - matches all DNS queries/responses for hosts in the "example.com" domain.
        /// [[NENetworkRule alloc] initWithDestinationHost:[NWHostEndpoint endpointWithHostname:
        /// "
        /// example.com" port:@"443"] protocol:NENetworkRuleProtocolTCP] - matches all TCP port 443 traffic to hosts in the "example.com" domain.
        ///
        /// Parameter `protocol`: A NENetworkRuleProtocol value indicating the protocol that the rule matches.
        ///
        /// Returns: The initialized NENetworkRule instance.
        #[deprecated]
        #[unsafe(method(initWithDestinationHost:protocol:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDestinationHost_protocol(
            this: Allocated<Self>,
            host_endpoint: &NWHostEndpoint,
            protocol: NENetworkRuleProtocol,
        ) -> Retained<Self>;

        /// Initialize a newly-allocated NENetworkRule object that matches traffic by remote network, local network, protocol, and direction. If both remoteNetwork and localNetwork are nil
        /// then the rule will match all traffic of the given protocol and direction, except for loopback traffic. To match loopback traffic create a NENetworkRule with remoteNetwork and/or localNetwork properties that
        /// explicitly match traffic to the loopback address (127.0.0.1 or ::1).
        ///
        /// Parameter `remoteNetwork`: An endpoint object that contains the remote port and the remote address or network that the rule matches. This endpoint must contain an address, not a hostname.
        /// If the address is a wildcard address (0.0.0.0 or ::) then the rule will match all destinations except for loopback (127.0.0.1 or ::1). To match loopback traffic set the address to the loopback address.
        /// If the port string of the endpoint is "0" or is the empty string, then the rule will match traffic on any port coming from the remote network.
        /// Pass nil to cause the rule to match any remote network.
        ///
        /// Parameter `remotePrefix`: An integer that in combination with the address in remoteNetwork specifies the remote network that the rule matches.
        ///
        /// Parameter `localNetwork`: An endpoint object that contains the local port and the local address or network that the rule matches. This endpoint must contain an address, not a hostname.
        /// If the address is a wildcard address (0.0.0.0 or ::) then the rule will match all local networks except for loopback (127.0.0.1 or ::1). To match loopback traffic set the address to the loopback address.
        /// If the port string of the endpoint is "0" or is the empty string, then the rule will match traffic on any port coming from the local network.
        /// Pass nil to cause the rule to match any local network.
        ///
        /// Parameter `localPrefix`: An integer that in combination with the address in localNetwork specifies the local network that the rule matches. This parameter
        /// is ignored if localNetwork is nil.
        ///
        /// Parameter `protocol`: A NENetworkRuleProtocol value indicating the protocol that the rule matches.
        ///
        /// Parameter `direction`: A NETrafficDirection value indicating the direction of network traffic that the rule matches.
        ///
        /// Returns: The initialized NENetworkRule instance.
        #[deprecated]
        #[unsafe(method(initWithRemoteNetwork:remotePrefix:localNetwork:localPrefix:protocol:direction:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithRemoteNetwork_remotePrefix_localNetwork_localPrefix_protocol_direction(
            this: Allocated<Self>,
            remote_network: Option<&NWHostEndpoint>,
            remote_prefix: NSUInteger,
            local_network: Option<&NWHostEndpoint>,
            local_prefix: NSUInteger,
            protocol: NENetworkRuleProtocol,
            direction: NETrafficDirection,
        ) -> Retained<Self>;

        /// The remote endpoint that the rule matches.
        #[deprecated]
        #[unsafe(method(matchRemoteEndpoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchRemoteEndpoint(&self) -> Option<Retained<NWHostEndpoint>>;

        /// A number that specifies the remote sub-network that the rule matches. This property is set to NSNotFound for rules where matchRemoteEndpoint does not contain an IP address.
        #[unsafe(method(matchRemotePrefix))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchRemotePrefix(&self) -> NSUInteger;

        /// The local network that the rule matches.
        #[deprecated]
        #[unsafe(method(matchLocalNetwork))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchLocalNetwork(&self) -> Option<Retained<NWHostEndpoint>>;

        /// A number that specifies the local sub-network that the rule matches. This property is set to NSNotFound for rules with a nil matchLocalNetwork property.
        #[unsafe(method(matchLocalPrefix))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchLocalPrefix(&self) -> NSUInteger;

        /// A NENetworkRuleProtocol value containing the protocol that the rule matches.
        #[unsafe(method(matchProtocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchProtocol(&self) -> NENetworkRuleProtocol;

        /// A NETrafficDirection value indicating the network traffic direction that the rule matches.
        #[unsafe(method(matchDirection))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchDirection(&self) -> NETrafficDirection;
    );
}

/// Methods declared on superclass `NSObject`.
impl NENetworkRule {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The abstract base class for types that represent flows of network data.
    /// The NEFilterFlow class declares the programmatic interface of an object that represents a flow of network data to be filtered.
    ///
    /// NEFilterFlow is part of NetworkExtension.framework
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterFlow;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterFlow {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterFlow {}
);

unsafe impl CopyingHelper for NEFilterFlow {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterFlow {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterFlow {}
);

impl NEFilterFlow {
    extern_methods!(
        /// The flow's HTTP request URL. Will be nil if the flow did not originate from WebKit.
        #[unsafe(method(URL))]
        #[unsafe(method_family = none)]
        pub unsafe fn URL(&self) -> Option<Retained<NSURL>>;

        /// A byte string that uniquely identifies the binary for each build of the source application of the flow.
        #[unsafe(method(sourceAppUniqueIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceAppUniqueIdentifier(&self) -> Option<Retained<NSData>>;

        /// A string containing the identifier of the source application of the flow. This identifier stays the same for all versions and builds of the application. This identifier is unique among all applications.
        #[unsafe(method(sourceAppIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceAppIdentifier(&self) -> Option<Retained<NSString>>;

        /// The short version string of the source application. Will be nil if the app info is unavailable.
        #[unsafe(method(sourceAppVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceAppVersion(&self) -> Option<Retained<NSString>>;

        /// Initial direction of the flow (outgoing or incoming flow)
        #[unsafe(method(direction))]
        #[unsafe(method_family = none)]
        pub unsafe fn direction(&self) -> NETrafficDirection;

        /// Audit token of the source application of the flow.
        #[unsafe(method(sourceAppAuditToken))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceAppAuditToken(&self) -> Option<Retained<NSData>>;

        /// The audit token of the process that created the flow. In cases where the connection was created by a system process on behalf of the source application,
        /// sourceProcessAuditToken will be different from sourceAppAuditToken and will contain the audit token of the system process. In cases where the source application directly
        /// created the connection sourceAppAuditToken and sourceProcessAuditToken will be identical.
        #[unsafe(method(sourceProcessAuditToken))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceProcessAuditToken(&self) -> Option<Retained<NSData>>;

        /// The unique identifier of the flow.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSUUID>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterFlow {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A flow of network data, originating from a WebKit-based browser, that the filter examines.
    /// The NEFilterBrowserFlow class declares the programmatic interface of an object that represents a flow of network data to be filtered, which is originated from NEFilterSource.
    ///
    /// NEFilterBrowserFlow is part of NetworkExtension.framework
    #[unsafe(super(NEFilterFlow, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterBrowserFlow;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterBrowserFlow {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterBrowserFlow {}
);

unsafe impl CopyingHelper for NEFilterBrowserFlow {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterBrowserFlow {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterBrowserFlow {}
);

impl NEFilterBrowserFlow {
    extern_methods!(
        /// The NSURLRequest of the flow. This property is always nil for the control providers.
        #[unsafe(method(request))]
        #[unsafe(method_family = none)]
        pub unsafe fn request(&self) -> Option<Retained<NSURLRequest>>;

        /// The NSURLResponse of the flow. This will be nil until the request is sent to the server and the response headers are received. And this property is always nil for the control providers.
        #[unsafe(method(response))]
        #[unsafe(method_family = none)]
        pub unsafe fn response(&self) -> Option<Retained<NSURLResponse>>;

        /// The parent URL for the current flow which is created to load the sub frames because the flow with the parent URL was allowed. Will be nil if the parent flow does not exist.
        #[unsafe(method(parentURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn parentURL(&self) -> Option<Retained<NSURL>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterBrowserFlow {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A flow of network data that the filter examines.
    /// The NEFilterSocketFlow class declares the programmatic interface of an object that represents a flow of network data to be filtered, which is originated from the socket.
    ///
    /// NEFilterSocketFlow is part of NetworkExtension.framework
    #[unsafe(super(NEFilterFlow, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterSocketFlow;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterSocketFlow {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterSocketFlow {}
);

unsafe impl CopyingHelper for NEFilterSocketFlow {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterSocketFlow {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterSocketFlow {}
);

impl NEFilterSocketFlow {
    extern_methods!(
        /// The flow's remote endpoint. This endpoint object may be nil when [NEFilterDataProvider handleNewFlow:] is invoked and if so will be populated upon receiving network data.
        /// In such a case, filtering on the flow may still be performed based on its socket type, socket family or socket protocol.
        #[deprecated]
        #[unsafe(method(remoteEndpoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteEndpoint(&self) -> Option<Retained<NWEndpoint>>;

        /// The flow's remote hostname. This property is only non-nil if the flow was created using Network.framework or NSURLSession.
        #[unsafe(method(remoteHostname))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteHostname(&self) -> Option<Retained<NSString>>;

        /// The flow's local endpoint. This endpoint object may be nil when [NEFilterDataProvider handleNewFlow:] is invoked and if so will be populated upon receiving network data.
        /// In such a case, filtering on the flow may still be performed based on its socket type, socket family or socket protocol.
        #[deprecated]
        #[unsafe(method(localEndpoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn localEndpoint(&self) -> Option<Retained<NWEndpoint>>;

        /// Socket family of the socket flow, such as PF_INET.
        #[unsafe(method(socketFamily))]
        #[unsafe(method_family = none)]
        pub unsafe fn socketFamily(&self) -> c_int;

        /// Socket type of the socket flow, such as SOCK_STREAM.
        #[unsafe(method(socketType))]
        #[unsafe(method_family = none)]
        pub unsafe fn socketType(&self) -> c_int;

        /// Socket protocol of the socket flow, such as IPPROTO_TCP.
        #[unsafe(method(socketProtocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn socketProtocol(&self) -> c_int;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterSocketFlow {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern "C" {
    /// A key in the [`remediationMap`](https://developer.apple.com/documentation/networkextension/nefiltercontrolprovider/remediationmap) dictionary. The value of this key should be set to a dictionary that maps URL identifiers to remediation URLs to be inserted into the block page. The URL identifiers are defined by the Filter Control Provider app extension.
    /// Key to specify in the NSDictionary which is returned as a value in remediationMap.
    /// This key is used to indicate the Remediation URL. The URL should follow the scheme
    /// http or https to be used by the content filter.
    pub static NEFilterProviderRemediationMapRemediationURLs: &'static NSString;
}

extern "C" {
    /// A key in the [`remediationMap`](https://developer.apple.com/documentation/networkextension/nefiltercontrolprovider/remediationmap) dictionary. The value of this key should be set to a dictionary that maps button text string identifiers to the text to display for the remediation URL link in the block page. The button text string identifiers are defined by the Filter Control Provider app extension.
    pub static NEFilterProviderRemediationMapRemediationButtonTexts: &'static NSString;
}

extern_class!(
    /// An abstract base class shared by content filters.
    ///
    /// ## Overview
    ///
    /// A Network Content Filter is made up of two Filter Provider extensions:
    ///
    /// The **Filter Data Provider extension** examines network content as it passes through the network stack on the device and decides if the network content should be blocked or allowed to pass on to its final destination.
    ///
    /// Because the Filter Data Provider extension has access to all of the network content flowing through the device, it runs in a very restrictive sandbox. The sandbox prevents the Filter Data Provider extension from moving network content outside of its address space by blocking all network access, IPC, and disk write operations.
    ///
    /// The Filter Data Provider extension is implemented by creating a custom subclass of the [`NEFilterDataProvider`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider) class.
    ///
    /// The **Filter Control Provider extension** is responsible for feeding information to the Filter Data Provider extension so that the Filter Data Provider extension can do its job.
    ///
    /// For example, the Filter Control Provider extension can be notified by the Filter Data Provider extension that it does not have enough information to make a decision about a particular flow of network content. The Filter Control Provider extension can then download more filtering rules from a server and write the rules to a location where the Filter Data Provider can access them.
    ///
    /// The Filter Control Provider extension is implemented by creating a custom subclass of the [`NEFilterControlProvider`](https://developer.apple.com/documentation/networkextension/nefiltercontrolprovider) class.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To use the [`NEFilterProvider`](https://developer.apple.com/documentation/networkextension/nefilterprovider) class, you must enable the Network Extensions capability in Xcode and select the Content Filter capability. See [Configure network extensions](http://help.apple.com/xcode/mac/current/#/dev0b2ef6f08).
    ///
    ///
    ///
    /// </div>
    /// ### Subclassing Notes
    ///
    /// `NEFilterProvider` should not be subclassed directly. Instead, you should create subclasses of `NEFilterProvider’s` subclasses and override the following methods:
    ///
    /// #### Methods to Override
    ///
    /// - [`startFilterWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nefilterprovider/startfilter(completionhandler:))
    ///
    /// - [`stopFilterWithReason:completionHandler:`](https://developer.apple.com/documentation/networkextension/nefilterprovider/stopfilter(with:completionhandler:))
    ///
    ///
    /// The NEFilterProvider class is an abstract base class that declares the programmatic interface of an
    /// object that implements a socket filter.
    ///
    /// NEFilterProvider is part of NetworkExtension.framework
    #[unsafe(super(NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterProvider {}
);

impl NEFilterProvider {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function is called by the framework when the content filter is being started. Subclasses must
        /// override this method and perform whatever steps are necessary to start the filter.
        ///
        /// Parameter `completionHandler`: A block that must be called when the process of starting the filter is complete. If the
        /// filter was started successfully, subclass implementations must pass the nil value to this block. If an error occurred
        /// while starting the filter, sublcass implementations must pass a non-nil NSError containing more details about the error.
        #[unsafe(method(startFilterWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startFilterWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function is called by the framework when the content filter is being stopped. Subclasses must
        /// override this method and perform whatever steps are necessary to stop the filter.
        ///
        /// Parameter `reason`: An NEProviderStopReason indicating why the filter is being stopped.
        ///
        /// Parameter `completionHandler`: A block that must be called when the process of stopping the filter is complete.
        #[unsafe(method(stopFilterWithReason:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopFilterWithReason_completionHandler(
            &self,
            reason: NEProviderStopReason,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        /// An NEContentFilterConfiguration object containing the current filter configuration. The value of this
        /// property can change during the lifetime of a filter. Filter implementations can use KVO to be notified when the
        /// configuration changes.
        #[unsafe(method(filterConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn filterConfiguration(&self) -> Retained<NEFilterProviderConfiguration>;

        /// This function is called by the framework when the data provider extension returns a verdict with the report property set to True.
        /// Subclass implementations may override this method to handle the flow report.
        ///
        /// Parameter `report`: The report being delivered.
        #[unsafe(method(handleReport:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleReport(&self, report: &NEFilterReport);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// An enumeration that represents the frequency of filter report delivery.
/// A NEFilterReportFrequency controls the frequency of periodic reports.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEFilterReportFrequency(pub NSInteger);
impl NEFilterReportFrequency {
    /// A frequency value that indicates no report delivery.
    #[doc(alias = "NEFilterReportFrequencyNone")]
    pub const None: Self = Self(0);
    /// A low frequency of reports, about once every five seconds.
    #[doc(alias = "NEFilterReportFrequencyLow")]
    pub const Low: Self = Self(1);
    /// A low frequency of reports, about once every second.
    #[doc(alias = "NEFilterReportFrequencyMedium")]
    pub const Medium: Self = Self(2);
    /// A low frequency of reports, about once every half-second.
    #[doc(alias = "NEFilterReportFrequencyHigh")]
    pub const High: Self = Self(3);
}

unsafe impl Encode for NEFilterReportFrequency {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEFilterReportFrequency {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The abstract base class for filter verdict classes.
    ///
    /// ## Overview
    ///
    /// Filter providers use instances this class to inform the system about how to handle flows of network data.
    ///
    ///
    /// The NEFilterVerdict class declares the programmatic interface for an object that is the verdict for a
    /// flow of network data.
    ///
    /// NEFilterVerdict is part of NetworkExtension.framework
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterVerdict;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterVerdict {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterVerdict {}
);

unsafe impl CopyingHelper for NEFilterVerdict {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterVerdict {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterVerdict {}
);

impl NEFilterVerdict {
    extern_methods!(
        /// Whether or not to send a report to the control provider's -[NEFilterProvider handleReport:]
        /// method when processing this verdict and when the flow is closed. Since the data provider does not need to wait
        /// for a response from the control provider before continuing to process the flow, this is a more efficient way to
        /// report a flow to the control provider than returning a "need rules" verdict. If the verdict originates in the
        /// control provider, this property has no effect. This property applies when the action taken upon a flow is allow,
        /// deny, remediate, or filterData (filterData for new flows only). Setting this flag on a verdict for a socket
        /// flow will also cause the data provider's -[NEFilterProvider handleReport:] method to be called when the flow
        /// is closed.
        #[unsafe(method(shouldReport))]
        #[unsafe(method_family = none)]
        pub unsafe fn shouldReport(&self) -> bool;

        /// Setter for [`shouldReport`][Self::shouldReport].
        #[unsafe(method(setShouldReport:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setShouldReport(&self, should_report: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterVerdict {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The result from a filter data provder after the initial examination of a flow.
    /// The NEFilterNewFlowVerdict declares the programmatic interface of an object that is the verdict for a
    /// new flow of network data before any of the flow's data has been seen by the filter.
    ///
    /// NEFilterNewFlowVerdict is part of NetworkExtension.framework
    #[unsafe(super(NEFilterVerdict, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterNewFlowVerdict;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterNewFlowVerdict {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterNewFlowVerdict {}
);

unsafe impl CopyingHelper for NEFilterNewFlowVerdict {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterNewFlowVerdict {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterNewFlowVerdict {}
);

impl NEFilterNewFlowVerdict {
    extern_methods!(
        /// The frequency at which the data provider's -[NEFilterProvider handleReport:] method is called with a NEFilterReport instance with an event of NEFilterReportEventFlowStatistics.
        /// The default value is NEFilterReportFrequencyNone, so by default no statistics are reported.
        #[unsafe(method(statisticsReportFrequency))]
        #[unsafe(method_family = none)]
        pub unsafe fn statisticsReportFrequency(&self) -> NEFilterReportFrequency;

        /// Setter for [`statisticsReportFrequency`][Self::statisticsReportFrequency].
        #[unsafe(method(setStatisticsReportFrequency:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStatisticsReportFrequency(
            &self,
            statistics_report_frequency: NEFilterReportFrequency,
        );

        /// This class method returns a verdict indicating that control provider needs to be asked how to handle
        /// the new flow. The control provider can either drop or allow the flow, or update the rules and ask the data provider
        /// to decide on the new flow again.
        ///
        /// Returns: The NEFilterNewFlowVerdict object.
        #[unsafe(method(needRulesVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn needRulesVerdict() -> Retained<NEFilterNewFlowVerdict>;

        /// This class method returns a verdict indicating that the flow should be allowed.
        ///
        /// Returns: The NEFilterNewFlowVerdict object.
        #[unsafe(method(allowVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowVerdict() -> Retained<NEFilterNewFlowVerdict>;

        /// This class method returns a verdict indicating that the flow should be dropped.
        ///
        /// Returns: The NEFilterNewFlowVerdict object.
        #[unsafe(method(dropVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn dropVerdict() -> Retained<NEFilterNewFlowVerdict>;

        /// This class method returns a verdict indicating that a "content blocked" page should be displayed to
        /// the user. The block page should contain a link to the given URL.
        ///
        /// Parameter `remediationURLMapKey`: Remediation map key used by data plugin to get remediation url
        ///
        /// Returns: The NEFilterNewFlowVerdict object.
        #[unsafe(method(remediateVerdictWithRemediationURLMapKey:remediationButtonTextMapKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn remediateVerdictWithRemediationURLMapKey_remediationButtonTextMapKey(
            remediation_url_map_key: &NSString,
            remediation_button_text_map_key: &NSString,
        ) -> Retained<NEFilterNewFlowVerdict>;

        /// This class method returns a verdict indicating that safe search URL for the new should be specified
        ///
        /// Parameter `urlAppendMapKey`: URL Append map key to be used by the data plugin to notify what the url should be appended with
        ///
        /// Returns: The NEFilterNewFlowVerdict object.
        #[unsafe(method(URLAppendStringVerdictWithMapKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn URLAppendStringVerdictWithMapKey(
            url_append_map_key: &NSString,
        ) -> Retained<NEFilterNewFlowVerdict>;

        /// This class method returns a new flow verdict indicating that the filter needs to make a decision about
        /// a new flow after seeing a portion of the flow's data.
        ///
        /// Parameter `filterInbound`: A boolean indicating if the filter needs to see inbound data
        ///
        /// Parameter `peekInboundBytes`: The number of inbound bytes that the filter needs to see in the subsequent call to
        /// -[NEFilterDataProvider handleInboundDataFromFlow:readBytesStartOffset:readBytes:].
        ///
        /// Parameter `filterOutbound`: boolean indicating if the filter needs to see outbound data
        ///
        /// Parameter `peekOutboundBytes`: The number of outbound bytes that the filter needs to see in the subsequent call to
        /// -[NEFilterDataProvider handleOutboundDataFromFlow:readBytesStartOffset:readBytes:].
        ///
        /// Returns: The new flow verdict.
        #[unsafe(method(filterDataVerdictWithFilterInbound:peekInboundBytes:filterOutbound:peekOutboundBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn filterDataVerdictWithFilterInbound_peekInboundBytes_filterOutbound_peekOutboundBytes(
            filter_inbound: bool,
            peek_inbound_bytes: NSUInteger,
            filter_outbound: bool,
            peek_outbound_bytes: NSUInteger,
        ) -> Retained<NEFilterNewFlowVerdict>;

        /// This class method returns a verdict indicating that none of the data provider's handler callbacks shall be called for the flow until after the flow is resumed
        /// by a call to -[NEFilterDataProvider resumeFlow:withVerdict:]. TCP flows may be paused indefinitely. UDP flows will be dropped if not resumed within 10 seconds of
        /// being paused. It is invalid to pause a flow that is already paused.
        ///
        /// Returns: The NEFilterNewFlowVerdict object.
        #[unsafe(method(pauseVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn pauseVerdict() -> Retained<NEFilterNewFlowVerdict>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterNewFlowVerdict {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The result from a filter control provider.
    /// The NEFilterControlVerdict declares the programmatic interface of an object that is the verdict for a
    /// new flow of network data by the control provider.
    ///
    /// NEFilterControlVerdict is part of NetworkExtension.framework
    #[unsafe(super(NEFilterNewFlowVerdict, NEFilterVerdict, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterControlVerdict;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterControlVerdict {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterControlVerdict {}
);

unsafe impl CopyingHelper for NEFilterControlVerdict {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterControlVerdict {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterControlVerdict {}
);

impl NEFilterControlVerdict {
    extern_methods!(
        /// This class method returns a verdict indicating that the flow should be allowed to go through, and also
        /// tell the data provider whether to update its rules or not.
        ///
        /// Parameter `updateRules`: YES if the control provider has updated the rules and wants to communicate that to the data provider
        ///
        /// Returns: The NEFilterControlVerdict object.
        #[unsafe(method(allowVerdictWithUpdateRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowVerdictWithUpdateRules(
            update_rules: bool,
        ) -> Retained<NEFilterControlVerdict>;

        /// This class method returns a verdict indicating that the flow should be dropped, and also tell the data
        /// provider whether to update its rules or not.
        ///
        /// Parameter `updateRules`: YES if the control provider has updated the rules and wants to communicate that to the data provider
        ///
        /// Returns: The NEFilterControlVerdict object.
        #[unsafe(method(dropVerdictWithUpdateRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dropVerdictWithUpdateRules(
            update_rules: bool,
        ) -> Retained<NEFilterControlVerdict>;

        /// This class method returns a verdict indicating that the flow should be handled by the data provider,
        /// and the rules needed by the data provider have been set.
        ///
        /// Returns: The NEFilterControlVerdict object.
        #[unsafe(method(updateRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateRules() -> Retained<NEFilterControlVerdict>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterControlVerdict {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The actions a data provider can take on a filter flow.
///
/// ## Overview
///
/// The control provider receives a filter report when the data provider issues a verdict with the [`shouldReport`](https://developer.apple.com/documentation/networkextension/nefilterverdict/shouldreport) property set to [`true`](https://developer.apple.com/documentation/swift/true). The report contains an [`action`](https://developer.apple.com/documentation/networkextension/nefilterreport/action) property set to one of the values listed here.
///
///
/// A NEFilterAction represents the possible actions taken upon a NEFilterFlow that can be reported by the
/// data provider extension to the control provider extension.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEFilterAction(pub NSInteger);
impl NEFilterAction {
    /// Invalid action used to represent an error.
    #[doc(alias = "NEFilterActionInvalid")]
    pub const Invalid: Self = Self(0);
    /// Allow the flow.
    #[doc(alias = "NEFilterActionAllow")]
    pub const Allow: Self = Self(1);
    /// Drop the flow.
    #[doc(alias = "NEFilterActionDrop")]
    pub const Drop: Self = Self(2);
    /// Remediate the flow.
    ///
    /// ## Discussion
    ///
    /// This action results in a “content blocked” page being displayed to the user.
    ///
    ///
    #[doc(alias = "NEFilterActionRemediate")]
    pub const Remediate: Self = Self(3);
    /// Filter data on the flow.
    #[doc(alias = "NEFilterActionFilterData")]
    pub const FilterData: Self = Self(4);
}

unsafe impl Encode for NEFilterAction {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEFilterAction {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A type that represents the kind of event indicated by a report.
/// A NEFilterReportEvent represents the event that is being reported by the NEFilterReport.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEFilterReportEvent(pub NSInteger);
impl NEFilterReportEvent {
    /// A type of event indicating the report is for a new flow.
    #[doc(alias = "NEFilterReportEventNewFlow")]
    pub const NewFlow: Self = Self(1);
    /// A type of event indicating the report is about a pass/block decision made after analyzing some amount of a flow’s data.
    #[doc(alias = "NEFilterReportEventDataDecision")]
    pub const DataDecision: Self = Self(2);
    /// A type of event indicating the report is for a flow’s closing.
    #[doc(alias = "NEFilterReportEventFlowClosed")]
    pub const FlowClosed: Self = Self(3);
    /// A type of event indicating the report is for the latest statistics of the flow.
    #[doc(alias = "NEFilterReportEventStatistics")]
    pub const Statistics: Self = Self(4);
}

unsafe impl Encode for NEFilterReportEvent {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEFilterReportEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The report of the data provider’s action on a flow.
    ///
    /// ## Overview
    ///
    /// The system issues a report by calling your control provider’s [`handleReport:`](https://developer.apple.com/documentation/networkextension/nefilterprovider/handle(_:)) method with a report instance when the data provider issues a verdict whose [`shouldReport`](https://developer.apple.com/documentation/networkextension/nefilterverdict/shouldreport) property is set to [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    ///
    /// The NEFilterReport declares the programmatic interface of an object that is a report of actions taken by
    /// the data provider.
    ///
    /// NEFilterReport is part of NetworkExtension.framework
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterReport;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterReport {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterReport {}
);

unsafe impl CopyingHelper for NEFilterReport {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterReport {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterReport {}
);

impl NEFilterReport {
    extern_methods!(
        /// The flow on which the described action was taken.
        #[unsafe(method(flow))]
        #[unsafe(method_family = none)]
        pub unsafe fn flow(&self) -> Option<Retained<NEFilterFlow>>;

        /// The action taken upon the reported flow.
        #[unsafe(method(action))]
        #[unsafe(method_family = none)]
        pub unsafe fn action(&self) -> NEFilterAction;

        /// The type of event that the report is reporting.
        #[unsafe(method(event))]
        #[unsafe(method_family = none)]
        pub unsafe fn event(&self) -> NEFilterReportEvent;

        /// The number of inbound bytes received from the flow. This property is only non-zero when the report event is NEFilterReportEventFlowClosed or NEFilterReportEventFlowStatistics.
        #[unsafe(method(bytesInboundCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn bytesInboundCount(&self) -> NSUInteger;

        /// The number of outbound bytes sent on the flow. This property is only non-zero when the report event is NEFilterReportEventFlowClosed or NEFilterReportEventFlowStatistics.
        #[unsafe(method(bytesOutboundCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn bytesOutboundCount(&self) -> NSUInteger;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterReport {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The principal class for a filter control provider extension.
    ///
    /// ## Overview
    ///
    /// The Filter Control Provider’s primary responsibility is to provide information to the associated Filter Data Provider so that it can perform its task of accurately filtering network content. There are several ways in which the Filter Control Provider provides data to the associated Filter Data Provider:
    ///
    /// - By writing information to disk. For example, the Filter Control Provider can maintain a database of filtering rules on disk in a location where the Filter Data Provider can read from the database.
    ///
    /// - By defining a dictionary that maps keys to sets of customization parameters to be used when generating the block page. The Filter Data Provider gives the system the key for the desired customization parameters, and the system uses that key to get the customization parameters from the Filter Control Provider and generate the customized block page.
    ///
    /// - By defining a dictionary that maps keys to strings to be appended to URLs. The Filter Data Provider gives the system the key for the string to be appended, and the system uses that key to get the string to be appended from the Filter Control Provider and appends the string to the URL.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To use the [`NEFilterControlProvider`](https://developer.apple.com/documentation/networkextension/nefiltercontrolprovider) class, you must enable the Network Extensions capability in Xcode and select the Content Filter capability. See [Configure network extensions](http://help.apple.com/xcode/mac/current/#/dev0b2ef6f08).
    ///
    ///
    ///
    /// </div>
    /// ### Creating a Filter Control Provider Extension
    ///
    /// Filter Control Providers run as App Extensions for the `com.apple.networkextension.filter-control` extension point.
    ///
    /// To create a Filter Control Provider extension, first create a new App Extension target in your project.
    ///
    /// For an example of an Xcode build target for this app extension, see the [SimpleTunnel: Customized Networking Using the NetworkExtension Framework](https://developer.apple.com/library/archive/samplecode/SimpleTunnel/Introduction/Intro.html#//apple_ref/doc/uid/TP40016140) sample code project.
    ///
    /// Once you have a Filter Control Provider extension target, create a sub-class of `NEFilterControlProvider`. Then, set the `NSExtensionPrincipalClass` key in the the extension’s `Info.plist` to the name of your subclass.
    ///
    /// If it is not already, set the `NSExtensionPointIdentifier` key in the extension’s `Info.plist` to `com.apple.networkextension.filter-control`.
    ///
    /// Here is an example of the `NSExtension` dictionary in a Filter Control Provider extension’s `Info.plist`:
    ///
    /// ```xml
    /// <key>NSExtension</key>
    /// <dict>
    ///     <key>NSExtensionPointIdentifier</key>
    ///     <string>com.apple.networkextension.filter-control</string>
    ///     <key>NSExtensionPrincipalClass</key>
    ///     <string>MyCustomFilterControlProvider</string>
    /// </dict>
    /// ```
    ///
    /// Finally, add your Filter Control Provider extension target to your app’s Embed App Extensions build phase.
    ///
    ///
    /// The NEFilterControlProvider class declares the programmatic interface for an object that is responsible for installing filtering rules on the device.
    #[unsafe(super(NEFilterProvider, NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterControlProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterControlProvider {}
);

impl NEFilterControlProvider {
    extern_methods!(
        /// A dictionary containing custom strings to be inserted into the "content blocked" page displayed in WebKit. Each key in this dictionary corresponds to a string in the "content blocked" page. The value of each key is a dictionary that maps keys to the custom strings to be inserted into the "content blocked" page. The keys for the sub-dictionaries are defined by the control provider. When the data provider creates a "remediate" verdict using [NEFilterDataVerdict remediateVerdictWithRemediationURLMapKey:remediationButtonTextMapKey:], it passes the key corresponding to the custom string to be inserted into the "content blocked" page.
        ///
        /// Here is a sample remediationMap dictionary:
        ///
        /// remediationMap =
        /// @
        /// { NEFilterProviderRemediationMapRemediationURLs :
        /// @
        /// {
        /// "
        /// RemediateKey1" : @"http://www.remediation_url_1.com",
        /// "
        /// RemediateKey2" : @"http://www.remediation_url_2.com"
        /// },
        /// NEFilterProviderRemediationMapRemediationButtonTexts :
        /// @
        /// {
        /// "
        /// RemediationButtonText1" : @"Remediate URL"
        /// }
        /// };
        #[unsafe(method(remediationMap))]
        #[unsafe(method_family = none)]
        pub unsafe fn remediationMap(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, NSDictionary<NSString, NSObject>>>>;

        /// Setter for [`remediationMap`][Self::remediationMap].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `remediation_map` generic generic should be of the correct type.
        #[unsafe(method(setRemediationMap:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRemediationMap(
            &self,
            remediation_map: Option<&NSDictionary<NSString, NSDictionary<NSString, NSObject>>>,
        );

        /// A dictionary containing strings to be appended to URLs.
        #[unsafe(method(URLAppendStringMap))]
        #[unsafe(method_family = none)]
        pub unsafe fn URLAppendStringMap(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, NSString>>>;

        /// Setter for [`URLAppendStringMap`][Self::URLAppendStringMap].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setURLAppendStringMap:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setURLAppendStringMap(
            &self,
            url_append_string_map: Option<&NSDictionary<NSString, NSString>>,
        );

        #[cfg(feature = "block2")]
        /// This function is called by the framework when the NEFilterDataProvider indicates that the filtering verdict for the given flow is NEFilterRemediateVerdictNeedRules. Subclass implementations must override this method and implement whatever steps are necessary to remediate the given flow.
        ///
        /// Parameter `flow`: An NEFilterFlow object containing details about the flow that requires remediation.
        ///
        /// Parameter `completionHandler`: A block that must be called when the NEFilterControlProvider is ready for the NEFilterDataProvider to re-process the new flow. NEFilterControlVerdict stores the verdict through which the control provider determines if a flow needs to be dropped or allowed. The verdict also indicates if the control plugin wants the data plugin to update its rules and handle the verdict.
        #[unsafe(method(handleRemediationForFlow:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleRemediationForFlow_completionHandler(
            &self,
            flow: &NEFilterFlow,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NEFilterControlVerdict>)>,
        );

        #[cfg(feature = "block2")]
        /// This function is called by the framework when the NEFilterDataProvider indicates that the filtering verdict for the given flow is NEFilterNewFlowVerdictNeedRules. Subclass implementations must override this method and implement whatever steps are necessary to fetch new rules pertaining to the given flow and place them on disk in a location accessible by the NEFilterDataProvider.
        ///
        /// Parameter `flow`: An NEFilterFlow object containing details about the flow that requires a rules update.
        ///
        /// Parameter `completionHandler`: A block that must be called when the NEFilterControlProvider is ready for the NEFilterDataProvider to re-process the new flow. NEFilterControlVerdict stores the verdict through which the control provider determines if a flow needs to be dropped or allowed. The verdict also indicates if the control plugin wants the data plugin to update its rules and handle the verdict.
        #[unsafe(method(handleNewFlow:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleNewFlow_completionHandler(
            &self,
            flow: &NEFilterFlow,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NEFilterControlVerdict>)>,
        );

        /// This function is called by filter control implementations to notify the data provider "out of band" that the rules changed.
        #[unsafe(method(notifyRulesChanged))]
        #[unsafe(method_family = none)]
        pub unsafe fn notifyRulesChanged(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterControlProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Attribute flags that describe the data handled by a filter.
/// Attribute flags describing data
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEFilterDataAttribute(pub NSInteger);
impl NEFilterDataAttribute {
    /// An attribute that indicates the data includes an IP header.
    #[doc(alias = "NEFilterDataAttributeHasIPHeader")]
    pub const HasIPHeader: Self = Self(0x00000001);
}

unsafe impl Encode for NEFilterDataAttribute {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEFilterDataAttribute {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The principal class for a filter data provider extension.
    ///
    /// ## Overview
    ///
    /// Network content is delivered to the Filter Data Provider in the form of [`NEFilterFlow`](https://developer.apple.com/documentation/networkextension/nefilterflow) objects. Each [`NEFilterFlow`](https://developer.apple.com/documentation/networkextension/nefilterflow) object corresponds to a network connection opened by an application running on the device. The Filter Data Provider can choose to pass or block the data when it receives a new flow, or it can ask the system to see more of the flow’s data in either the outbound or inbound direction before making a pass or block decision.
    ///
    /// In addition to passing or blocking network data, the Filter Data Provider can tell the system that it needs more information before it can make a decision about a particular flow of data. The system will then ask the Filter Control Provider to update the current set of rules and place them in a location on disk that is readable from the Filter Data Provider extension.
    ///
    /// When a [`NEFilterFlow`](https://developer.apple.com/documentation/networkextension/nefilterflow) object is originated from a WebKit browser object, the Filter Data Provider can affect the user experience in the following ways:
    ///
    /// - If the Filter Data Provider chooses to block the web page, then a special “block” page is displayed in the WebKit browser object informing the user that their attempt to access the content was blocked. The Filter Data Provider can choose to add a link to this block page, giving the user the option of requesting access to the content.
    ///
    /// - If the Filter Data Provider chooses to allow the web page, then it can also specify that a string be appended to the web page URL. This allows the Filter Data Provider to direct the WebKit browser object to a “safe” version of the web page.
    ///
    /// To protect the user’s privacy, the Filter Data Provider extension sandbox prevents the extension from moving network content outside of its address space.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To use the [`handleNewFlow:`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider/handlenewflow(_:)) method, you must enable the Network Extensions capability in Xcode and select the Content Filter capability. See [Configure network extensions](http://help.apple.com/xcode/mac/current/#/dev0b2ef6f08).
    ///
    ///
    ///
    /// </div>
    /// ### Creating a Filter Data Provider Extension
    ///
    /// Filter Data Providers run as App Extensions for the `com.apple.networkextension.filter-data` extension point.
    ///
    /// To create a Filter Data Provider extension, first create a new App Extension target in your project.
    ///
    /// For an example of an Xcode build target for this app extension, see the [SimpleTunnel: Customized Networking Using the NetworkExtension Framework](https://developer.apple.com/library/archive/samplecode/SimpleTunnel/Introduction/Intro.html#//apple_ref/doc/uid/TP40016140) sample code project.
    ///
    /// Once you have a Filter Data Provider extension target, create a subclass of `NEFilterDataProvider`. Then set the `NSExtensionPrincipalClass` key in the the extension’s `Info.plist` to the name of your subclass.
    ///
    /// If it is not done already, set the `NSExtensionPointIdentifier` key in the extension’s `Info.plist` to `com.apple.networkextension.filter-data`.
    ///
    /// Here is an example of the `NSExtension` dictionary in a Filter Data Provider extension’s `Info.plist`:
    ///
    /// ```xml
    /// <key>NSExtension</key>
    /// <dict>
    ///     <key>NSExtensionPointIdentifier</key>
    ///     <string>com.apple.networkextension.filter-data</string>
    ///     <key>NSExtensionPrincipalClass</key>
    ///     <string>MyCustomFilterDataProvider</string>
    /// </dict>
    /// ```
    ///
    /// Finally, add your Filter Data Provider extension target to your app’s Embed App Extensions build phase.
    ///
    /// ### Subclassing Notes
    ///
    /// To create a Filter Data Provider extension, you must first create a subclass of `NEFilterDataProvider` and override the methods listed below.
    ///
    /// #### Methods to Override
    ///
    /// - [`handleNewFlow:`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider/handlenewflow(_:))
    ///
    /// - [`handleInboundDataFromFlow:readBytesStartOffset:readBytes:`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider/handleinbounddata(from:readbytesstartoffset:readbytes:))
    ///
    /// - [`handleOutboundDataFromFlow:readBytesStartOffset:readBytes:`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider/handleoutbounddata(from:readbytesstartoffset:readbytes:))
    ///
    /// - [`handleInboundDataCompleteForFlow:`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider/handleinbounddatacomplete(for:))
    ///
    /// - [`handleOutboundDataCompleteForFlow:`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider/handleoutbounddatacomplete(for:))
    ///
    /// - [`handleRemediationForFlow:`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider/handleremediation(for:))
    ///
    /// - [`handleRulesChanged`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider/handleruleschanged())
    ///
    ///
    /// The NEFilterDataProvider class declares the programmatic interface for an object that evaluates network data flows based on a set of locally-available rules and makes decisions about whether to block or allow the flows.
    #[unsafe(super(NEFilterProvider, NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterDataProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterDataProvider {}
);

impl NEFilterDataProvider {
    extern_methods!(
        /// This function is called by the framework when a filtering decision needs to be made about a new network data flow. Subclasses must override this method to implement the steps necessary to match the flow against some locally stored rules and return an appropriate verdict.
        ///
        /// Parameter `flow`: An NEFilterFlow object containing details about the new flow.
        ///
        /// Returns: An NEFilterNewFlowVerdict object containing the verdict for the new flow.
        #[unsafe(method(handleNewFlow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleNewFlow(&self, flow: &NEFilterFlow)
            -> Retained<NEFilterNewFlowVerdict>;

        /// This function is called by the framework when a filtering decision needs to be made about some inbound data that the filter previously requested access to via the NEFilterFlowDataVerdict or the NEFilterNewFlowVerdict. Subclasses must override this method.
        ///
        /// Parameter `flow`: The NEFilterFlow from which the data was read.
        ///
        /// Parameter `offset`: The offset in bytes from the start of the flow's inbound data at which readBytes begins.
        ///
        /// Parameter `readBytes`: The data that was read.  For non-UDP/TCP flows, since data may optionally include the IP header, readBytes includes a 4-bytes NEFilterDataAttribute field preceding the user data.  Handler must examine the NEFilterDataAttribute field and handle the data accordingly.
        ///
        /// Returns: An NEFilterFlowDataVerdict containing the verdict for the flow.
        #[unsafe(method(handleInboundDataFromFlow:readBytesStartOffset:readBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleInboundDataFromFlow_readBytesStartOffset_readBytes(
            &self,
            flow: &NEFilterFlow,
            offset: NSUInteger,
            read_bytes: &NSData,
        ) -> Retained<NEFilterDataVerdict>;

        /// This function is called by the framework when a filtering decision needs to be made about some outbound data that the filter previously requested access to via the NEFilterFlowDataVerdict or the NEFilterNewFlowVerdict. Subclasses must override this method.
        ///
        /// Parameter `flow`: The NEFilterFlow from which the data was read.
        ///
        /// Parameter `offset`: The offset in bytes from the start of the flow's outbound data at which readBytes begins.
        ///
        /// Parameter `readBytes`: The data that was read.  For non-UDP/TCP flows, since data may optionally include the IP header, readBytes includes a 4-bytes NEFilterDataAttribute field preceding the user data.  Handler must examine the NEFilterDataAttribute field and handle the data accordingly.
        ///
        /// Returns: An NEFilterFlowDataVerdict containing the verdict for the flow.
        #[unsafe(method(handleOutboundDataFromFlow:readBytesStartOffset:readBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleOutboundDataFromFlow_readBytesStartOffset_readBytes(
            &self,
            flow: &NEFilterFlow,
            offset: NSUInteger,
            read_bytes: &NSData,
        ) -> Retained<NEFilterDataVerdict>;

        /// This function is called by the framework after all of the inbound data for a flow has been seen by the filter. Subclasses must override this method to return an appropriate pass/block result.
        ///
        /// Parameter `flow`: The flow
        ///
        /// Returns: The final NEFilterFlowDataVerdict verdict for the flow.
        #[unsafe(method(handleInboundDataCompleteForFlow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleInboundDataCompleteForFlow(
            &self,
            flow: &NEFilterFlow,
        ) -> Retained<NEFilterDataVerdict>;

        /// This function is called by the framework after all of the outbound data for a flow has been seen by the filter. Subclasses must override this method to return an appropriate pass/block result.
        ///
        /// Parameter `flow`: The flow
        ///
        /// Returns: The final NEFilterFlowDataVerdict verdict for the flow.
        #[unsafe(method(handleOutboundDataCompleteForFlow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleOutboundDataCompleteForFlow(
            &self,
            flow: &NEFilterFlow,
        ) -> Retained<NEFilterDataVerdict>;

        /// This function is called by the framework after the user requests remediation for a blocked flow. Subclasses must override this method to return an appropriate pass/block result.
        ///
        /// Parameter `flow`: The flow
        ///
        /// Returns: The final NEFilterRemediationVerdict verdict for the flow.
        #[unsafe(method(handleRemediationForFlow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleRemediationForFlow(
            &self,
            flow: &NEFilterFlow,
        ) -> Retained<NEFilterRemediationVerdict>;

        /// This function is called by the framework when -[NEFilterControlProvider notifyRulesChanged] is called. Subclasses should override this method to reload new rules from disk.
        #[unsafe(method(handleRulesChanged))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleRulesChanged(&self);

        #[cfg(feature = "block2")]
        /// The provider calls this function to apply the current set of filtering rules associated with the provider and also change the default filtering action.
        ///
        /// Parameter `settings`: A NEFilterSettings object containing the filter settings to apply to the system. Pass nil to revert to the default settings, which are an
        /// empty list of rules and a default action of NEFilterActionFilterData.
        ///
        /// Parameter `completionHandler`: A block that will be executed when the settings have been applied to the system. If an error occurs then the error parameter will be non-nil.
        #[unsafe(method(applySettings:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn applySettings_completionHandler(
            &self,
            settings: Option<&NEFilterSettings>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// This function is called by the provider to resume a flow that was previously paused by the provider returning a pause verdict.
        ///
        /// Parameter `flow`: The flow to resume
        ///
        /// Parameter `verdict`: The next NEFilterDataVerdict for the flow. This verdict is used as the verdict corresponding to the
        /// flow handler callback (handleNewFlow:, handleInboundDataFromFlow:, etc.) that returned the pause verdict that
        /// paused the flow. This must be either a NEFilterDataVerdict or a NEFilterNewFlowVerdict. It is invalid to resume
        /// a flow that is not paused.
        #[unsafe(method(resumeFlow:withVerdict:))]
        #[unsafe(method_family = none)]
        pub unsafe fn resumeFlow_withVerdict(&self, flow: &NEFilterFlow, verdict: &NEFilterVerdict);

        /// This function is called by the provider to update the verdict for a flow outside the context of any NEFilterDataProvider callback.
        ///
        /// Parameter `flow`: The NEFilterSocketFlow to update the verdict for.
        ///
        /// Parameter `verdict`: The NEFilterDataVerdict. Must be a +[NEFilterDataVerdict allowVerdict], a +[NEFilterDataVerdict dropVerdict], or a +[NEFilterDataVerdict dataVerdictWithPassBytes:peekBytes:].
        ///
        /// Parameter `direction`: The direction to which the verdict applies. Pass NETrafficDirectionAny to update the verdict for both the inbound and outbound directions. This parameter is ignored if the verdict is +[NEFilterDataVerdict dropVerdict].
        #[unsafe(method(updateFlow:usingVerdict:forDirection:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateFlow_usingVerdict_forDirection(
            &self,
            flow: &NEFilterSocketFlow,
            verdict: &NEFilterDataVerdict,
            direction: NETrafficDirection,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterDataProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The result from a filter data provder for subsequent chunks of data on a flow.
    ///
    /// ## Overview
    ///
    /// Return this verdict type from the various methods of [`NEFilterDataProvider`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider).
    ///
    ///
    /// The NEFilterDataVerdict class declares the programmatic interface of an object that is the verdict for a flow of network data after some of the data has been seen by the filter.
    ///
    /// NEFilterDataVerdict is part of NetworkExtension.framework
    #[unsafe(super(NEFilterVerdict, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterDataVerdict;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterDataVerdict {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterDataVerdict {}
);

unsafe impl CopyingHelper for NEFilterDataVerdict {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterDataVerdict {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterDataVerdict {}
);

impl NEFilterDataVerdict {
    extern_methods!(
        /// The frequency at which the data provider's -[NEFilterProvider handleReport:] method is called with a NEFilterReport instance with an event of NEFilterReportEventFlowStatistics.
        /// The default value is NEFilterReportFrequencyNone, so by default no statistics are reported.
        #[unsafe(method(statisticsReportFrequency))]
        #[unsafe(method_family = none)]
        pub unsafe fn statisticsReportFrequency(&self) -> NEFilterReportFrequency;

        /// Setter for [`statisticsReportFrequency`][Self::statisticsReportFrequency].
        #[unsafe(method(setStatisticsReportFrequency:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStatisticsReportFrequency(
            &self,
            statistics_report_frequency: NEFilterReportFrequency,
        );

        /// This class method returns a verdict indicating that the flow should be allowed.
        ///
        /// Returns: The NEFilterDataVerdict object.
        #[unsafe(method(allowVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowVerdict() -> Retained<NEFilterDataVerdict>;

        /// This class method returns a verdict indicating that the flow should be dropped.
        ///
        /// Returns: The NEFilterDataVerdict object.
        #[unsafe(method(dropVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn dropVerdict() -> Retained<NEFilterDataVerdict>;

        /// This class method returns a verdict indicating that a "content blocked" page should be displayed to the user. The block page should contain a link to the given URL.
        ///
        /// Parameter `remediationURLMapKey`: Remediation map key used by data plugin to get remediation url. Passing nil will result into data provider being notified with the callback handleRemediationForFlow:
        ///
        /// Parameter `remediationButtonTextMapKey`: Remediation button map key used by the data plugin to get the remediation button text. Passing nil will set the button text to "Request Access"
        ///
        /// Returns: The NEFilterDataVerdict object.
        #[unsafe(method(remediateVerdictWithRemediationURLMapKey:remediationButtonTextMapKey:))]
        #[unsafe(method_family = none)]
        pub unsafe fn remediateVerdictWithRemediationURLMapKey_remediationButtonTextMapKey(
            remediation_url_map_key: Option<&NSString>,
            remediation_button_text_map_key: Option<&NSString>,
        ) -> Retained<NEFilterDataVerdict>;

        /// This class method returns a data verdict indicating that the filter is passing a given number of bytes through the filter and needs to see a given number of bytes after the bytes that are passed.
        ///
        /// Parameter `passBytes`: The number of bytes to pass through the filter.
        ///
        /// Parameter `peekBytes`: The number of bytes after the end of the bytes passed that the filter wants to see in the next call to -[NEFilterDataProvider handleOutboundDataFromFlow:readBytesStartOffset:readBytes:] or -[NEFilterDataProvider handleInboundDataFromFlow:readBytesStartOffset:readBytes:].
        ///
        /// Returns: The data flow verdict.
        #[unsafe(method(dataVerdictWithPassBytes:peekBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataVerdictWithPassBytes_peekBytes(
            pass_bytes: NSUInteger,
            peek_bytes: NSUInteger,
        ) -> Retained<NEFilterDataVerdict>;

        /// This class method returns a verdict indicating that control provider needs to be asked how to handle the data flow. The control provider can either drop or allow the flow, or update the rules and ask the data provider to decide on the data flow again.
        ///
        /// Returns: The NEFilterDataVerdict object.
        #[unsafe(method(needRulesVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn needRulesVerdict() -> Retained<NEFilterDataVerdict>;

        /// This class method returns a verdict indicating that none of the data provider's handler callbacks shall be called for the flow until after the flow is resumed
        /// by a call to -[NEFilterDataProvider resumeFlow:withVerdict:]. TCP flows may be paused indefinitely. UDP flows will be dropped if not resumed within 10 seconds of
        /// being paused. It is invalid to pause a flow that is already paused.
        ///
        /// Returns: The NEFilterDataVerdict object.
        #[unsafe(method(pauseVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn pauseVerdict() -> Retained<NEFilterDataVerdict>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterDataVerdict {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The result from a filter data provider after the user requests remediation for a blocked flow.
    /// The NEFilterRemediationVerdict class declares the programmatic interface of an object that is the verdict for a flow which has been blocked by the filter, but the user has made a request for remediation.
    ///
    /// NEFilterRemediationVerdict is part of NetworkExtension.framework
    #[unsafe(super(NEFilterVerdict, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterRemediationVerdict;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterRemediationVerdict {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterRemediationVerdict {}
);

unsafe impl CopyingHelper for NEFilterRemediationVerdict {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterRemediationVerdict {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterRemediationVerdict {}
);

impl NEFilterRemediationVerdict {
    extern_methods!(
        /// This class method returns a verdict indicating that the flow should be allowed.
        ///
        /// Returns: The NEFilterRemediationVerdict object.
        #[unsafe(method(allowVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowVerdict() -> Retained<NEFilterRemediationVerdict>;

        /// This class method returns a verdict indicating that the flow should be dropped.
        ///
        /// Returns: The NEFilterRemediationVerdict object.
        #[unsafe(method(dropVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn dropVerdict() -> Retained<NEFilterRemediationVerdict>;

        /// This class method returns a verdict indicating that control provider needs to be asked how to handle the remediation. The control provider can either drop or allow the flow, or update the rules and ask the data provider to decide on the data flow again.
        ///
        /// Returns: The NEFilterRemediationVerdict object.
        #[unsafe(method(needRulesVerdict))]
        #[unsafe(method_family = none)]
        pub unsafe fn needRulesVerdict() -> Retained<NEFilterRemediationVerdict>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterRemediationVerdict {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Error codes specific to filter managers.
/// Filter error codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEFilterManagerError(pub NSInteger);
impl NEFilterManagerError {
    /// An error code that indicates the filter configuration is invalid.
    #[doc(alias = "NEFilterManagerErrorConfigurationInvalid")]
    pub const ConfigurationInvalid: Self = Self(1);
    /// An error code that indicates the filter configuration isn’t enabled.
    #[doc(alias = "NEFilterManagerErrorConfigurationDisabled")]
    pub const ConfigurationDisabled: Self = Self(2);
    /// An error code that indicates another process modfied the filter configuration since the last time the app loaded the configuration.
    ///
    /// ## Discussion
    ///
    /// This error also occurs if the app tries to save the filter configuration before loading it from the Network Extension preferences the first time after the app launches.
    ///
    ///
    #[doc(alias = "NEFilterManagerErrorConfigurationStale")]
    pub const ConfigurationStale: Self = Self(3);
    /// An error code that indicates removing the configuration isn’t allowed.
    #[doc(alias = "NEFilterManagerErrorConfigurationCannotBeRemoved")]
    pub const ConfigurationCannotBeRemoved: Self = Self(4);
    /// An error code that indicates the configuration lacks permission.
    #[doc(alias = "NEFilterManagerErrorConfigurationPermissionDenied")]
    pub const ConfigurationPermissionDenied: Self = Self(5);
    /// An error code that indicates an internal configuration error occurred.
    #[doc(alias = "NEFilterManagerErrorConfigurationInternalError")]
    pub const ConfigurationInternalError: Self = Self(6);
}

unsafe impl Encode for NEFilterManagerError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEFilterManagerError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The domain for errors resulting from calls to the filter manager.
    ///
    /// ## Discussion
    ///
    /// Match this constant to the [`domain`](https://developer.apple.com/documentation/foundation/nserror/domain) of an [`NSError`](https://developer.apple.com/documentation/foundation/nserror) encountered when calling methods on [`NEFilterManager`](https://developer.apple.com/documentation/networkextension/nefiltermanager). The [`NEFilterManagerError`](https://developer.apple.com/documentation/networkextension/nefiltermanagererror) enumeration defines possible [`code`](https://developer.apple.com/documentation/foundation/nserror/code) values for these errors.
    ///
    ///
    pub static NEFilterErrorDomain: &'static NSString;
}

extern "C" {
    /// Posted after the filter configuration stored in the Network Extension preferences changes.
    pub static NEFilterConfigurationDidChangeNotification: &'static NSString;
}

/// A type for the grade or priority of the filter.
/// Filter grade
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEFilterManagerGrade(pub NSInteger);
impl NEFilterManagerGrade {
    /// A grade for filters that act as firewalls, blocking some network traffic.
    ///
    /// ## Discussion
    ///
    /// Firewall grade filters see network traffic before other filter grades.
    ///
    ///
    #[doc(alias = "NEFilterManagerGradeFirewall")]
    pub const Firewall: Self = Self(1);
    /// A grade for filters that act as inspectors of network traffic.
    ///
    /// ## Discussion
    ///
    /// Inspector grade filters see network traffic after firewall grade filters.
    ///
    ///
    #[doc(alias = "NEFilterManagerGradeInspector")]
    pub const Inspector: Self = Self(2);
}

unsafe impl Encode for NEFilterManagerGrade {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEFilterManagerGrade {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object to create and manage a content filter’s configuration.
    ///
    /// ## Overview
    ///
    /// Each app is allowed to create a single filter configuration. The [`NEFilterManager`](https://developer.apple.com/documentation/networkextension/nefiltermanager) class has a class method ([`sharedManager`](https://developer.apple.com/documentation/networkextension/nefiltermanager/shared())) that provides access to a single [`NEFilterManager`](https://developer.apple.com/documentation/networkextension/nefiltermanager) instance. This single instance corresponds to a single filter configuration.
    ///
    /// The filter configuration is stored in the Network Extension preferences which are managed by the Network Extension framework. The filter configuration must be explicitly loaded into memory from the Network Extension preferences before it can be used, and any changes must be explicitly saved to the Network Extension preferences before taking effect on the system.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  In product builds for distribution, Network Content Filter configurations can be created only on supervised devices. During development and testing you can temporarily override this restriction by signing your build with the `get-task-allow` entitlement.
    ///
    ///
    ///
    /// </div>
    /// <div class="warning">
    ///
    /// ### Important
    ///  To use the [`NEFilterManager`](https://developer.apple.com/documentation/networkextension/nefiltermanager) class, you must enable the Network Extensions capability in Xcode and select the Content Filter capability. See [Configure network extensions](http://help.apple.com/xcode/mac/current/#/dev0b2ef6f08).
    ///
    ///
    ///
    /// </div>
    /// ### Profile Configuration
    ///
    /// Filter configurations are created using configuration profiles. See [`WebContentFilter`](https://developer.apple.com/documentation/devicemanagement/webcontentfilter) for more information. To specify that a filter configuration created via a profile payload is associated with a particular app (and therefore allow the app to use `NEFilterManager` to manage the configuration), the app’s bundle identifier must be set as the value of the `PluginBundleID` field in the profile payload.
    ///
    /// ### Filter Provider Extensions
    ///
    /// Apps that use `NEFilterManager` are required to contain two Filter Provider extensions that together perform the task of examining network content and making pass and block decisions. See the [`NEFilterControlProvider`](https://developer.apple.com/documentation/networkextension/nefiltercontrolprovider) and [`NEFilterDataProvider`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider) classes for more details about these extensions.
    ///
    ///
    /// The NEFilterManager class declares the programmatic interface for an object that manages content filtering configurations.
    ///
    /// NEFilterManager declares methods and properties for configuring and controlling a filter.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterManager {}
);

impl NEFilterManager {
    extern_methods!(
        /// Returns: The singleton NEFilterManager object for the calling process.
        #[unsafe(method(sharedManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedManager() -> Retained<NEFilterManager>;

        #[cfg(feature = "block2")]
        /// This function loads the current filter configuration from the caller's filter preferences.
        ///
        /// Parameter `completionHandler`: A block that will be called when the load operation is completed. The NSError passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function removes the filter configuration from the caller's filter preferences. If the filter is enabled, the filter becomes disabled.
        ///
        /// Parameter `completionHandler`: A block that will be called when the remove operation is completed. The NSError passed to this block will be nil if the remove operation succeeded, non-nil otherwise.
        #[unsafe(method(removeFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function saves the filter configuration in the caller's filter preferences. If the filter is enabled, it will become active.
        ///
        /// Parameter `completionHandler`: A block that will be called when the save operation is completed. The NSError passed to this block will be nil if the save operation succeeded, non-nil otherwise.
        #[unsafe(method(saveToPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveToPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// A string containing a description of the filter.
        #[unsafe(method(localizedDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedDescription(&self) -> Option<Retained<NSString>>;

        /// Setter for [`localizedDescription`][Self::localizedDescription].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedDescription(&self, localized_description: Option<&NSString>);

        /// An NEFilterProviderConfiguration object containing the provider-specific portion of the filter configuration.
        #[unsafe(method(providerConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn providerConfiguration(
            &self,
        ) -> Option<Retained<NEFilterProviderConfiguration>>;

        /// Setter for [`providerConfiguration`][Self::providerConfiguration].
        #[unsafe(method(setProviderConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProviderConfiguration(
            &self,
            provider_configuration: Option<&NEFilterProviderConfiguration>,
        );

        /// Toggles the enabled status of the filter. On iOS, setting this property will disable filter configurations of other apps, and this property will be set to NO when other filter configurations are enabled.
        /// On macOS, up to 4 filter configurations of the same grade can be enabled simultaneously.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);

        /// The grade of the filter. The default grade is NEFilterManagerGradeFirewall.
        #[unsafe(method(grade))]
        #[unsafe(method_family = none)]
        pub unsafe fn grade(&self) -> NEFilterManagerGrade;

        /// Setter for [`grade`][Self::grade].
        #[unsafe(method(setGrade:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGrade(&self, grade: NEFilterManagerGrade);

        /// Causes the content filter to disable any other installed encrypted DNS settings, including iCloud Private Relay system-wide DNS encryption. This should only be used if
        /// the content filter expects to intercept cleartext UDP DNS packets.
        #[unsafe(method(disableEncryptedDNSSettings))]
        #[unsafe(method_family = none)]
        pub unsafe fn disableEncryptedDNSSettings(&self) -> bool;

        /// Setter for [`disableEncryptedDNSSettings`][Self::disableEncryptedDNSSettings].
        #[unsafe(method(setDisableEncryptedDNSSettings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisableEncryptedDNSSettings(&self, disable_encrypted_dns_settings: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The context object provided to the filter packet handler.
    /// The NEFilterPacketContext class identifies the current filtering context.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterPacketContext;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterPacketContext {}
);

impl NEFilterPacketContext {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NEFilterPacketContext {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The verdict returned by a packet handler indicating what the framework should do with a packet.
/// Verdict for a packet
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEFilterPacketProviderVerdict(pub NSInteger);
impl NEFilterPacketProviderVerdict {
    /// A verdict to allow a packet.
    #[doc(alias = "NEFilterPacketProviderVerdictAllow")]
    pub const Allow: Self = Self(0);
    /// A verdict to drop a packet.
    #[doc(alias = "NEFilterPacketProviderVerdictDrop")]
    pub const Drop: Self = Self(1);
    /// A verdict to delay a packet until a future verdict.
    #[doc(alias = "NEFilterPacketProviderVerdictDelay")]
    pub const Delay: Self = Self(2);
}

unsafe impl Encode for NEFilterPacketProviderVerdict {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEFilterPacketProviderVerdict {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A filter provider that evaluates network packets and decides whether to block, allow, or delay the packets.
    /// The NEFilterPacketProvider class declares the programmatic interface for an object that evaluates network packets decisions about whether to block, allow, or delay the packets.
    #[unsafe(super(NEFilterProvider, NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterPacketProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterPacketProvider {}
);

impl NEFilterPacketProvider {
    extern_methods!(
        /// This function is used to delay a packet currently presented by packetHandler.
        /// This function is only valid within the packetHandler block and a verdict of
        /// NEFilterPacketProviderVerdictDelay must be returned after a packet is delayed.  A delayed
        /// packet will be prevented from continuing its journey through the networking stack until
        /// it is either allowed by calling allow() or is dropped by being released.
        ///
        /// Parameter `context`: The context of the current packet filter which is passed to the packetHandler block.
        /// The packetHandler block must pass this context when calling delayCurrentPacket().
        #[unsafe(method(delayCurrentPacket:))]
        #[unsafe(method_family = none)]
        pub unsafe fn delayCurrentPacket(
            &self,
            context: &NEFilterPacketContext,
        ) -> Retained<NEPacket>;

        /// This function is used to allow a previously-delayed packet to continue its journey into or out of the networking stack.
        ///
        /// Parameter `packet`: A NEPacket object that contains the data of the packet that was previously delayed by the NEFilterPacketProvider.
        #[unsafe(method(allowPacket:))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowPacket(&self, packet: &NEPacket);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterPacketProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Configuration parameters for a content filter.
    /// The NEFilterProviderConfiguration class declares the programmatic interface of an object that configures a plugin-based content filter.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterProviderConfiguration;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterProviderConfiguration {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterProviderConfiguration {}
);

unsafe impl CopyingHelper for NEFilterProviderConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterProviderConfiguration {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterProviderConfiguration {}
);

impl NEFilterProviderConfiguration {
    extern_methods!(
        /// If YES, the filter plugin will be allowed to filter browser traffic. If NO, the filter plugin will not see any browser flows. Defaults to NO. At least one of filterBrowsers and filterSockets should be set to YES to make the filter take effect.
        #[deprecated = "filterBrowsers is not supported on macOS"]
        #[unsafe(method(filterBrowsers))]
        #[unsafe(method_family = none)]
        pub unsafe fn filterBrowsers(&self) -> bool;

        /// Setter for [`filterBrowsers`][Self::filterBrowsers].
        #[deprecated = "filterBrowsers is not supported on macOS"]
        #[unsafe(method(setFilterBrowsers:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFilterBrowsers(&self, filter_browsers: bool);

        /// If YES, the filter plugin will be allowed to filter socket traffic. If NO, the filter plugin will not see any socket flows. Defaults to NO. At least one of filterBrowsers and filterSockets should be set to YES to make the filter take effect.
        #[unsafe(method(filterSockets))]
        #[unsafe(method_family = none)]
        pub unsafe fn filterSockets(&self) -> bool;

        /// Setter for [`filterSockets`][Self::filterSockets].
        #[unsafe(method(setFilterSockets:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFilterSockets(&self, filter_sockets: bool);

        /// If YES, a NEFilterPacketProvider will be instantiated and will be allowed to filter packets.
        #[unsafe(method(filterPackets))]
        #[unsafe(method_family = none)]
        pub unsafe fn filterPackets(&self) -> bool;

        /// Setter for [`filterPackets`][Self::filterPackets].
        #[unsafe(method(setFilterPackets:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFilterPackets(&self, filter_packets: bool);

        /// An optional dictionary of plugin-specific keys to be passed to the plugin.
        #[unsafe(method(vendorConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn vendorConfiguration(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        /// Setter for [`vendorConfiguration`][Self::vendorConfiguration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `vendor_configuration` generic should be of the correct type.
        #[unsafe(method(setVendorConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVendorConfiguration(
            &self,
            vendor_configuration: Option<&NSDictionary<NSString, AnyObject>>,
        );

        /// The optional address of the server used to support the filter.
        #[unsafe(method(serverAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn serverAddress(&self) -> Option<Retained<NSString>>;

        /// Setter for [`serverAddress`][Self::serverAddress].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setServerAddress:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServerAddress(&self, server_address: Option<&NSString>);

        /// The optional username associated with the filter.
        #[unsafe(method(username))]
        #[unsafe(method_family = none)]
        pub unsafe fn username(&self) -> Option<Retained<NSString>>;

        /// Setter for [`username`][Self::username].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setUsername:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUsername(&self, username: Option<&NSString>);

        /// The optional organization associated with the filter.
        #[unsafe(method(organization))]
        #[unsafe(method_family = none)]
        pub unsafe fn organization(&self) -> Option<Retained<NSString>>;

        /// Setter for [`organization`][Self::organization].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setOrganization:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOrganization(&self, organization: Option<&NSString>);

        /// The optional password keychain reference associated with the filter.
        #[unsafe(method(passwordReference))]
        #[unsafe(method_family = none)]
        pub unsafe fn passwordReference(&self) -> Option<Retained<NSData>>;

        /// Setter for [`passwordReference`][Self::passwordReference].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPasswordReference:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPasswordReference(&self, password_reference: Option<&NSData>);

        /// The optional certificate identity keychain reference associated with the filter.
        #[unsafe(method(identityReference))]
        #[unsafe(method_family = none)]
        pub unsafe fn identityReference(&self) -> Option<Retained<NSData>>;

        /// Setter for [`identityReference`][Self::identityReference].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentityReference:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentityReference(&self, identity_reference: Option<&NSData>);

        /// A string containing the bundle identifier of the NEFilterDataProvider app extension or system extension.
        /// If this property is nil, then the bundle identifier of the NEFilterDataProvider extension in the calling app's
        /// bundle is used, and if the calling app's bundle contains more than one NEFilterDataProvider extension then which one will
        /// be used is undefined.
        #[unsafe(method(filterDataProviderBundleIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn filterDataProviderBundleIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`filterDataProviderBundleIdentifier`][Self::filterDataProviderBundleIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFilterDataProviderBundleIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFilterDataProviderBundleIdentifier(
            &self,
            filter_data_provider_bundle_identifier: Option<&NSString>,
        );

        /// A string containing the bundle identifier of the NEFilterPacketProvider app extension or system extension.
        /// If this property is nil, then the bundle identifier of the NEFilterPacketProvider extension in the calling app's
        /// bundle is used, and if the calling app's bundle contains more than one NEFilterPacketProvider extension then which one will
        /// be used is undefined.
        #[unsafe(method(filterPacketProviderBundleIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn filterPacketProviderBundleIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`filterPacketProviderBundleIdentifier`][Self::filterPacketProviderBundleIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFilterPacketProviderBundleIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFilterPacketProviderBundleIdentifier(
            &self,
            filter_packet_provider_bundle_identifier: Option<&NSString>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterProviderConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A rule for filters that combines a rule to match network traffic and an action to take when the rule matches.
    /// The NEFilterRule class declares the programmatic interface of an object that defines a rule for matching network traffic and the action to take when the rule matches.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterRule;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterRule {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterRule {}
);

unsafe impl CopyingHelper for NEFilterRule {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterRule {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterRule {}
);

impl NEFilterRule {
    extern_methods!(
        /// Initialize a newly-allocated NEFilterRule object
        ///
        /// Parameter `networkRule`: A NENetworkRule object that defines the network traffic characteristics that this rule matches.
        ///
        /// Parameter `action`: The action to take when this rule matches.
        #[unsafe(method(initWithNetworkRule:action:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithNetworkRule_action(
            this: Allocated<Self>,
            network_rule: &NENetworkRule,
            action: NEFilterAction,
        ) -> Retained<Self>;

        /// The NENetworkRule that defines the network traffic characteristics that this rule matches.
        #[unsafe(method(networkRule))]
        #[unsafe(method_family = none)]
        pub unsafe fn networkRule(&self) -> Retained<NENetworkRule>;

        /// The action to take when this rule matches network traffic.
        #[unsafe(method(action))]
        #[unsafe(method_family = none)]
        pub unsafe fn action(&self) -> NEFilterAction;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterRule {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The rules and other settings that define the operation of a filter.
    ///
    /// ## Overview
    ///
    /// [`NEFilterDataProvider`](https://developer.apple.com/documentation/networkextension/nefilterdataprovider) instances use [`NEFilterSettings`](https://developer.apple.com/documentation/networkextension/nefiltersettings) to communicate the desired settings for the filter to the framework. The framework takes care of applying the contained settings to the system.
    ///
    ///
    /// The NEFilterSettings class declares the programmatic interface for an object that contains filter settings.
    ///
    /// NEFilterSettings is used by NEFilterDataProviders to communicate the desired settings for the filter to the framework. The framework takes care of applying the contained settings to the system.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFilterSettings;
);

extern_conformance!(
    unsafe impl NSCoding for NEFilterSettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFilterSettings {}
);

unsafe impl CopyingHelper for NEFilterSettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFilterSettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFilterSettings {}
);

impl NEFilterSettings {
    extern_methods!(
        /// Initialize a newly-allocated NEFilterSettings object with a set of filtering rules and a default filter action to takke if none
        /// of the rules match.
        ///
        /// Parameter `rules`: An NSArray containing an ordered list of NEFilterRule objects. The maximum number of rules that this array can contain is 1000.
        ///
        /// Parameter `defaultAction`: The NEFilterAction to take for flows of network (non-loopback) data that do not match any of the specified rules. The default defaultAction is
        /// NEFilterActionFilterData. If defaultAction is NEFilterActionAllow or NEFilterActionDrop, then the rules array must contain at least one NEFilterRule.
        /// The default action for loopback traffic is NEFilterActionAllow and cannot be changed. To filter loopback traffic you must include rules in the rules array that specifically match loopback traffic
        /// and have an action of NEFilterActionFilterData.
        ///
        /// Returns: the newly-initialized NEFilterSettings object.
        #[unsafe(method(initWithRules:defaultAction:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithRules_defaultAction(
            this: Allocated<Self>,
            rules: &NSArray<NEFilterRule>,
            default_action: NEFilterAction,
        ) -> Retained<Self>;

        /// An NSArray containing an ordered list of NEFilterRuleObjects. After the NEFilterSettings are applied to the system,
        /// each network flow is matched against these rules in order, and the NEFilterAction of the first rule that matches is taken:
        /// NEFilterActionAllow: Allow the flow of data to proceed on its journey through the networking stack without consulting this provider.
        /// NEFilterActionDrop: Drop the flow without consulting this provider.
        /// NEFilterActionFilterData: Call this provider's handleNewFlow: method with the flow.
        #[unsafe(method(rules))]
        #[unsafe(method_family = none)]
        pub unsafe fn rules(&self) -> Retained<NSArray<NEFilterRule>>;

        /// An NEFilterAction containing the default action to take for flows of network data that do not match any of the specified rules.
        #[unsafe(method(defaultAction))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultAction(&self) -> NEFilterAction;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFilterSettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Additional information about data flowing through a per-app VPN provider.
    ///
    /// ## Overview
    ///
    /// This metadata is only present for data flowing through per-app VPN providers, that is, app proxy providers and packet tunnel providers in per-app VPN mode, as indicated by the [`routingMethod`](https://developer.apple.com/documentation/networkextension/netunnelprovider/routingmethod) property.
    ///
    ///
    /// The NEFlowMetaData class declares the programmatic interface for an object that contains extra information about a flow.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEFlowMetaData;
);

extern_conformance!(
    unsafe impl NSCoding for NEFlowMetaData {}
);

extern_conformance!(
    unsafe impl NSCopying for NEFlowMetaData {}
);

unsafe impl CopyingHelper for NEFlowMetaData {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEFlowMetaData {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEFlowMetaData {}
);

impl NEFlowMetaData {
    extern_methods!(
        /// A byte string that uniquely identifies the binary for each build of the source application of the flow. The data object may be empty in cases where the flow originates from a system process.
        #[unsafe(method(sourceAppUniqueIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceAppUniqueIdentifier(&self) -> Retained<NSData>;

        /// A string containing the signing identifier (almost always equivalent to the bundle identifier) of the source app of the flow. The string may be empty in cases where the flow originates from a system process.
        #[unsafe(method(sourceAppSigningIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceAppSigningIdentifier(&self) -> Retained<NSString>;

        /// Audit token of the source application of the flow.
        #[unsafe(method(sourceAppAuditToken))]
        #[unsafe(method_family = none)]
        pub unsafe fn sourceAppAuditToken(&self) -> Option<Retained<NSData>>;

        /// The identifier of the content filter flow corresponding to this flow.
        #[unsafe(method(filterFlowIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn filterFlowIdentifier(&self) -> Option<Retained<NSUUID>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEFlowMetaData {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// An enumeration of constants that define Wi-Fi hotspot network security types.
/// Wi-Fi network security type
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEHotspotNetworkSecurityType(pub NSInteger);
impl NEHotspotNetworkSecurityType {
    /// A security type to represent an open network with no security protocol.
    #[doc(alias = "NEHotspotNetworkSecurityTypeOpen")]
    pub const Open: Self = Self(0);
    /// A security type to represent use of Wired Equivalent Privacy (WEP).
    #[doc(alias = "NEHotspotNetworkSecurityTypeWEP")]
    pub const WEP: Self = Self(1);
    /// A security type to represent use of Wi-Fi protected access (WPA), WPA2, and WPA3 standards using a pre-shared secret.
    #[doc(alias = "NEHotspotNetworkSecurityTypePersonal")]
    pub const Personal: Self = Self(2);
    /// A security type to represent use of Wi-Fi protected access (WPA), WPA2, and WPA3 standards using enterprise-level seciurity.
    #[doc(alias = "NEHotspotNetworkSecurityTypeEnterprise")]
    pub const Enterprise: Self = Self(3);
    /// A value that represents an unknown security type.
    #[doc(alias = "NEHotspotNetworkSecurityTypeUnknown")]
    pub const Unknown: Self = Self(4);
}

unsafe impl Encode for NEHotspotNetworkSecurityType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEHotspotNetworkSecurityType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Information about a Wi-Fi network associated with a command or a response.
    ///
    /// ## Overview
    ///
    /// When the Hotspot Helper app is asked to evaluate the a network or filter the Wi-Fi scan list, it annotates the  `NEHotspotNetwork` object via the `setConfidence:` method.
    ///
    ///
    /// The NEHotspotNetwork class provides a class method to get the SSID and BSSID of
    /// the current Wi-Fi network.
    ///
    /// NEHotspotNetwork is part of NetworkExtension.framework
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEHotspotNetwork;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEHotspotNetwork {}
);

impl NEHotspotNetwork {
    extern_methods!(
        /// The SSID of the Wi-Fi network.
        #[unsafe(method(SSID))]
        #[unsafe(method_family = none)]
        pub unsafe fn SSID(&self) -> Retained<NSString>;

        /// The BSSID of the Wi-Fi network.
        #[unsafe(method(BSSID))]
        #[unsafe(method_family = none)]
        pub unsafe fn BSSID(&self) -> Retained<NSString>;

        /// The security type of the Wi-Fi network.
        #[unsafe(method(securityType))]
        #[unsafe(method_family = none)]
        pub unsafe fn securityType(&self) -> NEHotspotNetworkSecurityType;

        #[cfg(feature = "block2")]
        /// This method returns SSID, BSSID and security type of the current Wi-Fi network when the
        /// requesting application meets one of following 4 requirements -.
        /// 1. application is using CoreLocation API and has user's authorization to access precise location.
        /// 2. application has used NEHotspotConfiguration API to configure the current Wi-Fi network.
        /// 3. application has active VPN configurations installed.
        /// 4. application has active NEDNSSettingsManager configuration installed.
        /// An application will receive nil if it fails to meet any of the above 4 requirements.
        /// An application will receive nil if does not have the "com.apple.developer.networking.wifi-info" entitlement.
        ///
        /// Parameter `completionHandler`: A block that will be executed when current Wi-Fi network details are
        /// obtained from the system. The NEHotspotNetwork object passed to this block will be nil if the requesting
        /// application fails to meet above requirements, non-nil otherwise. NEHotspotNetwork object contains only valid
        /// SSID, BSSID and security type values, when the block is passed non-nil object.This block is executed on application's
        /// main queue.
        #[unsafe(method(fetchCurrentWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchCurrentWithCompletionHandler(
            completion_handler: &block2::DynBlock<dyn Fn(*mut NEHotspotNetwork)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NEHotspotNetwork {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// An enumeration of hotspot command types.
/// The type of the NEHotspotHelperCommand object.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEHotspotHelperCommandType(pub NSInteger);
impl NEHotspotHelperCommandType {
    /// Placeholder for the null command.
    #[doc(alias = "kNEHotspotHelperCommandTypeNone")]
    pub const None: Self = Self(0);
    /// Filter the Wi-Fi scan list.
    #[doc(alias = "kNEHotspotHelperCommandTypeFilterScanList")]
    pub const FilterScanList: Self = Self(1);
    /// Evaluate the network.
    #[doc(alias = "kNEHotspotHelperCommandTypeEvaluate")]
    pub const Evaluate: Self = Self(2);
    /// Authenticate to the network.
    #[doc(alias = "kNEHotspotHelperCommandTypeAuthenticate")]
    pub const Authenticate: Self = Self(3);
    /// Present user interface.
    #[doc(alias = "kNEHotspotHelperCommandTypePresentUI")]
    pub const PresentUI: Self = Self(4);
    /// Maintain the connection to the network.
    #[doc(alias = "kNEHotspotHelperCommandTypeMaintain")]
    pub const Maintain: Self = Self(5);
    /// Logoff the network.
    #[doc(alias = "kNEHotspotHelperCommandTypeLogoff")]
    pub const Logoff: Self = Self(6);
}

unsafe impl Encode for NEHotspotHelperCommandType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEHotspotHelperCommandType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The result of handling a hotspot command.
/// The result of processing the NEHotspotHelperCommand.
///
/// The HotspotHelper provides the result of
/// processing the NEHotspotHelperCommand when it instantiates
/// its NEHotspotHelperResponse.
///
///
///
/// interaction. This result is only valid in response to a command with type
/// kNEHotspotHelperCommandTypeAuthenticate.
///
/// recognize the command type.
///
/// authentication again. This result is only valid in response to a
/// command with type kNEHotspotHelperCommandTypeMaintain.
///
/// authenticate, the helper determined that it can't perform the
/// authentication. This result is only valid in response to commands of type
/// kNEHotspotHelperCommandTypeAuthenticate and
/// kNEHotspotHelperCommandTypePresentUI.
///
/// it is temporarily unable to perform the authentication.
/// This result is only valid in response to commands of type
/// kNEHotspotHelperCommandTypeAuthenticate and
/// kNEHotspotHelperCommandTypePresentUI.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEHotspotHelperResult(pub NSInteger);
impl NEHotspotHelperResult {
    /// The command was handled successfully.
    #[doc(alias = "kNEHotspotHelperResultSuccess")]
    pub const Success: Self = Self(0);
    /// The command failed to be handled.
    #[doc(alias = "kNEHotspotHelperResultFailure")]
    pub const Failure: Self = Self(1);
    /// The operation requires user interaction. This result is only valid in response to a command with type [`kNEHotspotHelperCommandTypeAuthenticate`](https://developer.apple.com/documentation/networkextension/nehotspothelpercommandtype/authenticate).
    #[doc(alias = "kNEHotspotHelperResultUIRequired")]
    pub const UIRequired: Self = Self(2);
    /// The helper did not recognize the command type.
    #[doc(alias = "kNEHotspotHelperResultCommandNotRecognized")]
    pub const CommandNotRecognized: Self = Self(3);
    /// The network requires authentication again. This result is only valid in response to a command with type [`kNEHotspotHelperCommandTypeMaintain`](https://developer.apple.com/documentation/networkextension/nehotspothelpercommandtype/maintain).
    #[doc(alias = "kNEHotspotHelperResultAuthenticationRequired")]
    pub const AuthenticationRequired: Self = Self(4);
    /// After attempting to authenticate, the Hotspot Helper app determined that it can’t perform the authentication. This result is only valid in response to commands of type [`kNEHotspotHelperCommandTypeAuthenticate`](https://developer.apple.com/documentation/networkextension/nehotspothelpercommandtype/authenticate) and [`kNEHotspotHelperCommandTypePresentUI`](https://developer.apple.com/documentation/networkextension/nehotspothelpercommandtype/presentui).
    #[doc(alias = "kNEHotspotHelperResultUnsupportedNetwork")]
    pub const UnsupportedNetwork: Self = Self(5);
    /// The Hotspot Helper app determined that it is temporarily unable to perform the authentication. This result is only valid in response to commands of type [`kNEHotspotHelperCommandTypeAuthenticate`](https://developer.apple.com/documentation/networkextension/nehotspothelpercommandtype/authenticate) and [`kNEHotspotHelperCommandTypePresentUI`](https://developer.apple.com/documentation/networkextension/nehotspothelpercommandtype/presentui).
    #[doc(alias = "kNEHotspotHelperResultTemporaryFailure")]
    pub const TemporaryFailure: Self = Self(6);
}

unsafe impl Encode for NEHotspotHelperResult {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEHotspotHelperResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A type that indicates the hotspot helper’s confidence in its ability to handle the network.
/// The HotspotHelper's confidence in its ability to handle the network.
///
/// The HotspotHelper indicates its confidence in being able to handle the
/// given hotspot network.
///
/// the network.
///
/// in being able to handle the network.
///
/// in being able to handle the network.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEHotspotHelperConfidence(pub NSInteger);
impl NEHotspotHelperConfidence {
    /// The helper is unable to handle the network.
    #[doc(alias = "kNEHotspotHelperConfidenceNone")]
    pub const None: Self = Self(0);
    /// The helper has some confidence in being able to handle the network.
    #[doc(alias = "kNEHotspotHelperConfidenceLow")]
    pub const Low: Self = Self(1);
    /// The helper has high confidence in being able to handle the network.
    #[doc(alias = "kNEHotspotHelperConfidenceHigh")]
    pub const High: Self = Self(2);
}

unsafe impl Encode for NEHotspotHelperConfidence {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEHotspotHelperConfidence {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// HotspotHelper.
///
/// Extends NEHotspotNetwork class to support conveying information about the
/// network to the HotspotHelper. When the HotspotHelper is asked to evaluate
/// the current network or filter the Wi-Fi scan list, it annotates the NEHotspotNetwork
/// via the setConfidence method.
impl NEHotspotNetwork {
    extern_methods!(
        /// The signal strength for the Wi-Fi network. The value lies within
        /// the range 0.0 (weak/no signal) to 1.0 (strong signal).
        #[unsafe(method(signalStrength))]
        #[unsafe(method_family = none)]
        pub unsafe fn signalStrength(&self) -> c_double;

        /// Indicates whether the network is secure
        #[unsafe(method(isSecure))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSecure(&self) -> bool;

        /// Indicates whether the network was joined automatically
        /// (YES) or joined by the user (NO).
        #[unsafe(method(didAutoJoin))]
        #[unsafe(method_family = none)]
        pub unsafe fn didAutoJoin(&self) -> bool;

        /// Indicates whether the network was just joined. Useful in the
        /// Maintaining state to differentiate whether the Maintain command
        /// is for the initial join, or the subsequent periodic callback.
        #[unsafe(method(didJustJoin))]
        #[unsafe(method_family = none)]
        pub unsafe fn didJustJoin(&self) -> bool;

        /// Indicates whether the HotspotHelper is the chosen helper for
        /// the network. The NEHotspotNetwork must have been instantiated via a
        /// call to the +[NEHotspotHelper supportedNetworkInterfaces] method. This
        /// is useful to restore state after the HotspotHelper application is quit
        /// and restarted.
        #[unsafe(method(isChosenHelper))]
        #[unsafe(method_family = none)]
        pub unsafe fn isChosenHelper(&self) -> bool;

        /// Indicate the confidence in being able to handle the network.
        ///
        /// Use this method to indicate the confidence in being able to
        /// successfully authenticate to the given network. Used in the response
        /// to the kNEHotspotHelperCommandTypeEvaluate and
        /// kNEHotspotHelperCommandTypeFilterScanList commands.
        #[unsafe(method(setConfidence:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConfidence(&self, confidence: NEHotspotHelperConfidence);

        /// Provide the password for a secure network
        ///
        /// The HotspotHelper may set a password for a secure network. The format
        /// password string must adhere to IEEE 802.11 guidelines appropriate for
        /// the particular security scheme.
        ///
        /// Used only in the response to the kNEHotspotHelperCommandTypeFilterScanList
        /// command.
        #[unsafe(method(setPassword:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPassword(&self, password: &NSString);
    );
}

extern_class!(
    /// A command for the hotspot helper to handle.
    ///
    /// ## Overview
    ///
    /// NEHotspostHelperCommand objects are passed to the the Hotspot Helper app’s command handler block. The Hotspot Helper app processes the command, instantiates an [`NEHotspotHelperResponse`](https://developer.apple.com/documentation/networkextension/nehotspothelperresponse) object, sets the annotated `network` or `networkList` (`Evaluate` or `FilterScanList` commands only), and then delivers the response to the system.
    ///
    ///
    /// An NEHotspotHelperCommand object is provided to the helper's
    /// command handler block. The HotspotHelper processes the command
    /// instantiates an NEHotspotHelperResponse object, sets the annotated
    /// network or networkList (Evaluate/FilterScanList only),
    /// then delivers it.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEHotspotHelperCommand;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEHotspotHelperCommand {}
);

impl NEHotspotHelperCommand {
    extern_methods!(
        /// The type of the command.
        #[unsafe(method(commandType))]
        #[unsafe(method_family = none)]
        pub unsafe fn commandType(&self) -> NEHotspotHelperCommandType;

        /// The network associated with the command. May be nil.
        #[unsafe(method(network))]
        #[unsafe(method_family = none)]
        pub unsafe fn network(&self) -> Option<Retained<NEHotspotNetwork>>;

        /// The list of networks associated with a command. Will be nil unless
        /// the command type is kNEHotspotHelperCommandTypeFilterScanList.
        /// This property returns an NSArray of NEHotspotNetwork.
        #[unsafe(method(networkList))]
        #[unsafe(method_family = none)]
        pub unsafe fn networkList(&self) -> Option<Retained<NSArray<NEHotspotNetwork>>>;

        /// Create a response to the command.
        ///
        /// Instantiate an NEHotspotHelperResponse for the command.
        ///
        /// Returns: NEHotspotHelperResponse with the specified result.
        #[unsafe(method(createResponse:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createResponse(
            &self,
            result: NEHotspotHelperResult,
        ) -> Retained<NEHotspotHelperResponse>;

        /// Create a new TCP connection over the interface associated with the command.
        ///
        /// Instantiate an NWTCPConnection to the specified endpoint
        /// bound to the network interface associated with the command.
        ///
        /// Returns: non-nil NWTCPConnection object if successful, nil otherwise
        #[deprecated = "Use the `interface` property with `nw_parameters_require_interface`"]
        #[unsafe(method(createTCPConnection:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createTCPConnection(
            &self,
            endpoint: &NWEndpoint,
        ) -> Retained<NWTCPConnection>;

        /// Create a new UDP session over the interface associated with the command.
        ///
        /// Instantiate an NWUDPSession to the specified endpoint
        /// bound to the network interface associated with the command.
        ///
        /// Returns: non-nil NWUDPSession object if successful, nil otherwise
        #[deprecated = "Use the `interface` property with `nw_parameters_require_interface`"]
        #[unsafe(method(createUDPSession:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createUDPSession(&self, endpoint: &NWEndpoint) -> Retained<NWUDPSession>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEHotspotHelperCommand {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The hotspot helper’s response to a command.
    /// The HotspotHelper creates an NEHotspotHelperResponse object to provide
    /// the results of running the corresponding NEHotspotHelperCommand.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEHotspotHelperResponse;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEHotspotHelperResponse {}
);

impl NEHotspotHelperResponse {
    extern_methods!(
        /// Set the network that conveys the confidence level.
        ///
        /// Provide the annotated NEHotspotNetwork object in the response to the
        /// kNEHotspotHelperCommandTypeEvaluate command. The helper sets the
        /// confidence in the network object to indicate its ability to handle
        /// the current network.
        #[unsafe(method(setNetwork:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNetwork(&self, network: &NEHotspotNetwork);

        /// Set the list of handled networks.
        ///
        /// Provide an NSArray of annotated NEHotspotNetwork objects in response
        /// to the kNEHotspotHelperCommandTypeFilterScanList command.
        /// The helper provides the list of network objects that it is capable of
        /// handling with at least low confidence. Networks that it has no
        /// confidence in handling should not be specified.
        #[unsafe(method(setNetworkList:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNetworkList(&self, network_list: &NSArray<NEHotspotNetwork>);

        /// Delivers the response to the command.
        ///
        /// Deliver the NEHotspotHelperResponse to the HotspotHelper infrastructure.
        #[deprecated = "Use handleCommand in NEHotspotEvaluationProvider or NEHotspotAuthenticationProvider API"]
        #[unsafe(method(deliver))]
        #[unsafe(method_family = none)]
        pub unsafe fn deliver(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEHotspotHelperResponse {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The type definition for the Hotspot Helper’s command handler block.
///
/// ## Discussion
///
/// The Hotspot Helper app provides a block of this type when it invokes the `registerWithOptions:queue:handler:` method.
///
/// The block is invoked every time there is a command to be processed.
///
///
/// The type definition for the HotspotHelper's command handler block.
///
/// The application provides a block of this type when it
/// invokes the +[NEHotspotHelper registerWithOptions:queue:handler] method.
/// The block is invoked every time there is a command to be processed.
#[cfg(feature = "block2")]
pub type NEHotspotHelperHandler = *mut block2::DynBlock<dyn Fn(NonNull<NEHotspotHelperCommand>)>;

extern "C" {
    /// The string displayed in Wi-Fi Settings for a network handled by the application.
    ///
    /// ## Discussion
    ///
    /// This key specifies the display name for the application, if an alternate name is desired. If this property is not specified, the application’s name is used.
    ///
    /// This name appears in Settings -> Wi-Fi underneath the Wi-Fi network name if the helper indicated that it was able to handle the network.
    ///
    ///
    /// The string displayed in Wi-Fi Settings for a network handled by
    /// the application.
    ///
    /// This key specifies the display name for the application, if an alternate
    /// name is desired.  If this property is not specified, the application's
    /// name is used.
    ///
    /// This name appears in Settings -> Wi-Fi underneath the Wi-Fi network
    /// name if the helper indicated that it was able to handle the network.
    pub static kNEHotspotHelperOptionDisplayName: &'static NSString;
}

extern_class!(
    /// A class to register a hotspot helper.
    ///
    /// ## Overview
    ///
    /// The [`NEHotspotHelper`](https://developer.apple.com/documentation/networkextension/nehotspothelper) API gives your app the ability to perform custom authentication for Wi-Fi Hotspots. It gives users a way to seamlessly connect to a large aggregated network of Wi-Fi Hotspots. The [`NEHotspotConfiguration`](https://developer.apple.com/documentation/networkextension/nehotspotconfiguration) API lets your app configure those hotspots.
    ///
    ///
    /// The NEHotspotHelper class allows an application to register itself as a
    /// HotspotHelper.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use NEHotspotManager API"]
    pub struct NEHotspotHelper;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEHotspotHelper {}
);

impl NEHotspotHelper {
    extern_methods!(
        #[cfg(all(feature = "block2", feature = "dispatch2"))]
        /// Register the application as a HotspotHelper.
        ///
        /// Once this API is invoked successfully, the application becomes
        /// eligible to be launched in the background and participate in
        /// various hotspot related functions.
        ///
        /// This function should be called once when the application starts up.
        /// Invoking it again will have no effect and result in FALSE being returned.
        ///
        /// The 'options' dictionary may be nil, or contain the single property
        /// kNEHotspotHelperOptionDisplayName.
        ///
        ///
        /// Parameter `options`: If not nil, 'options' is an NSDictionary containing
        /// kNEHotspotHelperOption* keys (currently just
        /// kNEHotspotHelperOptionDisplayName).
        ///
        /// Parameter `queue`: The dispatch_queue_t to invoke the handle block on.
        ///
        /// Parameter `handler`: The NEHotspotHelperHandler block to execute to process
        /// helper commands.
        ///
        /// Returns: YES if the registration was successful, NO otherwise.
        ///
        /// Note: Notes
        ///
        /// Note: 1
        /// The application's Info.plist MUST include a UIBackgroundModes array
        /// containing 'network-authentication'.
        ///
        /// Note: 2
        /// The application MUST set 'com.apple.developer.networking.HotspotHelper'
        /// as one of its entitlements. The value of the entitlement is a boolean
        /// value true.
        ///
        /// # Safety
        ///
        /// - `options` generic should be of the correct type.
        /// - `queue` possibly has additional threading requirements.
        /// - `handler` must be a valid pointer.
        #[deprecated = "Use NEHotspotManager API"]
        #[unsafe(method(registerWithOptions:queue:handler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerWithOptions_queue_handler(
            options: Option<&NSDictionary<NSString, NSObject>>,
            queue: &DispatchQueue,
            handler: NEHotspotHelperHandler,
        ) -> bool;

        /// Terminate the authentication session.
        ///
        /// The application invokes this method when it wants to logoff from the
        /// current network. Invoking this method causes an NEHotspotHelperCommand
        /// of type kNEHotspotHelperCommandTypeLogoff to be issued to the application's
        /// 'handler' block (see +[NEHotspotHelper registerWithOptions:queue:handler]).
        ///
        /// 'network' must correspond to the currently associated Wi-Fi network
        /// i.e. it must have come from the NEHotspotHelperCommand's 'network' property
        /// or from the +[NEHotspotHelper supportedInterfaces] method.
        ///
        /// Returns: YES if the logoff command was successfully queued, NO otherwise.
        ///
        /// Note: Notes
        ///
        /// Note: 1
        /// The application MUST NOT actually logoff from the network until it
        /// receives the command to logoff.
        ///
        /// Note: 2
        /// After the application invokes -[NEHotspotHelperResponse deliver] indicating
        /// kNEHotspotHelperResultSuccess, the Wi-Fi network is disassociated.
        #[deprecated = "Use NEHotspotManager API"]
        #[unsafe(method(logoff:))]
        #[unsafe(method_family = none)]
        pub unsafe fn logoff(network: &NEHotspotNetwork) -> bool;

        /// Return the list of network interfaces managed by the
        /// HotspotHelper infrastructure.
        ///
        /// Each network interface is represented by an NEHotspotNetwork object.
        /// Currently, the returned array contains exactly one NEHotspotNetwork
        /// object representing the Wi-Fi interface.
        ///
        /// The main purpose of this method is to allow a HotspotHelper to provide
        /// accurate status in its UI at times when it has not been given a command
        /// to process. This method coupled with -[NEHotspotNetwork isChosenHelper]
        /// allows the application to know whether it is the one that is handling
        /// the current network.
        ///
        /// Returns: nil if no network interfaces are being managed,
        /// non-nil NSArray of NEHotspotNetwork objects otherwise.
        #[deprecated = "Use NEHotspotManager API"]
        #[unsafe(method(supportedNetworkInterfaces))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedNetworkInterfaces() -> Option<Retained<NSArray>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEHotspotHelper {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

mod private_NSMutableURLRequestNEHotspotHelper {
    pub trait Sealed {}
}

/// Category "NEHotspotHelper" on [`NSMutableURLRequest`].
///
/// Extend NSMutableURLRequest to include a method to bind the
/// request to the network interface associated with the specified
/// NEHotspotHelperCommand object.
#[doc(alias = "NEHotspotHelper")]
pub unsafe trait NSMutableURLRequestNEHotspotHelper:
    ClassType + Sized + private_NSMutableURLRequestNEHotspotHelper::Sealed
{
    extern_methods!(
        /// Binds the NSMutableURLRequest to the network interface associated with
        /// the NEHotspotHelperCommand object.
        #[unsafe(method(bindToHotspotHelperCommand:))]
        #[unsafe(method_family = none)]
        unsafe fn bindToHotspotHelperCommand(&self, command: &NEHotspotHelperCommand);
    );
}

impl private_NSMutableURLRequestNEHotspotHelper::Sealed for NSMutableURLRequest {}
unsafe impl NSMutableURLRequestNEHotspotHelper for NSMutableURLRequest {}

/// The EAP types that may be specified in [`supportedEAPTypes`](https://developer.apple.com/documentation/networkextension/nehotspoteapsettings/supportedeaptypes).
/// EAP Type.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEHotspotConfigurationEAPType(pub NSInteger);
impl NEHotspotConfigurationEAPType {
    /// Network EAP type is `EAPTLS`.
    #[doc(alias = "NEHotspotConfigurationEAPTypeEAPTLS")]
    pub const EAPTLS: Self = Self(13);
    /// Network EAP type is `EAPTTLS`.
    #[doc(alias = "NEHotspotConfigurationEAPTypeEAPTTLS")]
    pub const EAPTTLS: Self = Self(21);
    /// Network EAP type is `EAPPEAP`.
    #[doc(alias = "NEHotspotConfigurationEAPTypeEAPPEAP")]
    pub const EAPPEAP: Self = Self(25);
    /// Network EAP type is `EAPFAST`.
    #[doc(alias = "NEHotspotConfigurationEAPTypeEAPFAST")]
    pub const EAPFAST: Self = Self(43);
}

unsafe impl Encode for NEHotspotConfigurationEAPType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEHotspotConfigurationEAPType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The TTLS Inner Authentication Types that may be specified by [`NEHotspotConfigurationTTLSInnerAuthenticationType`](https://developer.apple.com/documentation/networkextension/nehotspoteapsettings/ttlsinnerauthenticationtype-swift.enum).
/// TTLS Inner Authentication Type.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEHotspotConfigurationTTLSInnerAuthenticationType(pub NSInteger);
impl NEHotspotConfigurationTTLSInnerAuthenticationType {
    /// Network EAPTTLS inner authentication type is PAP.
    #[doc(alias = "NEHotspotConfigurationEAPTTLSInnerAuthenticationPAP")]
    pub const EAPTTLSInnerAuthenticationPAP: Self = Self(0);
    /// Network EAPTTLS inner authentication type is CHAP.
    #[doc(alias = "NEHotspotConfigurationEAPTTLSInnerAuthenticationCHAP")]
    pub const EAPTTLSInnerAuthenticationCHAP: Self = Self(1);
    /// Network EAPTTLS inner authentication type is MSCHAP.
    #[doc(alias = "NEHotspotConfigurationEAPTTLSInnerAuthenticationMSCHAP")]
    pub const EAPTTLSInnerAuthenticationMSCHAP: Self = Self(2);
    /// Network EAPTTLS inner authentication type is MSCHAP, version 2.
    #[doc(alias = "NEHotspotConfigurationEAPTTLSInnerAuthenticationMSCHAPv2")]
    pub const EAPTTLSInnerAuthenticationMSCHAPv2: Self = Self(3);
    /// Network EAPTTLS inner authentication type is EAP.
    #[doc(alias = "NEHotspotConfigurationEAPTTLSInnerAuthenticationEAP")]
    pub const EAPTTLSInnerAuthenticationEAP: Self = Self(4);
}

unsafe impl Encode for NEHotspotConfigurationTTLSInnerAuthenticationType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEHotspotConfigurationTTLSInnerAuthenticationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The EAPTLS Version identifiers that may be specified by [`preferredTLSVersion`](https://developer.apple.com/documentation/networkextension/nehotspoteapsettings/preferredtlsversion).
/// TLS version to use during TLS handshke.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEHotspotConfigurationEAPTLSVersion(pub NSInteger);
impl NEHotspotConfigurationEAPTLSVersion {
    /// Network EAPTLS version 1.0.
    #[doc(alias = "NEHotspotConfigurationEAPTLSVersion_1_0")]
    pub const Version_1_0: Self = Self(0);
    /// Network EAPTLS version 1.1.
    #[doc(alias = "NEHotspotConfigurationEAPTLSVersion_1_1")]
    pub const Version_1_1: Self = Self(1);
    /// Network EAPTLS version 1.2.
    #[doc(alias = "NEHotspotConfigurationEAPTLSVersion_1_2")]
    pub const Version_1_2: Self = Self(2);
}

unsafe impl Encode for NEHotspotConfigurationEAPTLSVersion {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEHotspotConfigurationEAPTLSVersion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Settings for configuring Hotspot 2.0 Wi-Fi networks.
    /// NEHotspotHS20Settings class provides a set of properties that are required
    /// to discover and negotiate Hotspot 2.0 Wi-Fi networks.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEHotspotHS20Settings;
);

extern_conformance!(
    unsafe impl NSCoding for NEHotspotHS20Settings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEHotspotHS20Settings {}
);

unsafe impl CopyingHelper for NEHotspotHS20Settings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEHotspotHS20Settings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEHotspotHS20Settings {}
);

impl NEHotspotHS20Settings {
    extern_methods!(
        /// Domain Name of Legacy Hotspot or Hotspot 2.0 Wi-Fi Network.
        /// This Domain Name is used for Wi-Fi Hotspot 2.0 negotiation.
        #[unsafe(method(domainName))]
        #[unsafe(method_family = none)]
        pub unsafe fn domainName(&self) -> Retained<NSString>;

        /// If set to YES, allows connection to networks of roaming service
        /// providers. Defaults to NO.
        #[unsafe(method(isRoamingEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isRoamingEnabled(&self) -> bool;

        /// Setter for [`isRoamingEnabled`][Self::isRoamingEnabled].
        #[unsafe(method(setRoamingEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRoamingEnabled(&self, roaming_enabled: bool);

        /// Array of Roaming Consortium Organization Identifiers used
        /// for Wi-Fi Hotspot 2.0 negotiation.
        #[unsafe(method(roamingConsortiumOIs))]
        #[unsafe(method_family = none)]
        pub unsafe fn roamingConsortiumOIs(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`roamingConsortiumOIs`][Self::roamingConsortiumOIs].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRoamingConsortiumOIs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRoamingConsortiumOIs(&self, roaming_consortium_o_is: &NSArray<NSString>);

        /// Array of Network Access Identifier Realm names used for
        /// Wi-Fi Hotspot 2.0 negotiation.
        #[unsafe(method(naiRealmNames))]
        #[unsafe(method_family = none)]
        pub unsafe fn naiRealmNames(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`naiRealmNames`][Self::naiRealmNames].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setNaiRealmNames:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNaiRealmNames(&self, nai_realm_names: &NSArray<NSString>);

        /// Array of Mobile Country Code (MCC)/Mobile Network Code (MNC)
        /// pairs used for Wi-Fi Hotspot 2.0 negotiation. Each string must contain
        /// exactly six digits.
        #[unsafe(method(MCCAndMNCs))]
        #[unsafe(method_family = none)]
        pub unsafe fn MCCAndMNCs(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`MCCAndMNCs`][Self::MCCAndMNCs].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMCCAndMNCs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMCCAndMNCs(&self, mcc_and_mn_cs: &NSArray<NSString>);

        /// A designated initializer to instantiate a new NEHotspotHSSettings object.
        /// This initializer is used to configure Legacy Hotspot or HS2.0 Wi-Fi Networks.
        ///
        ///
        /// Parameter `domainName`: The domain name of HS2.0 Wi-Fi Network
        ///
        /// Parameter `roamingEnabled`: If YES, allows connections to networks of roaming service providers.
        #[unsafe(method(initWithDomainName:roamingEnabled:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDomainName_roamingEnabled(
            this: Allocated<Self>,
            domain_name: &NSString,
            roaming_enabled: bool,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEHotspotHS20Settings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Extensible Authentication Protocol settings for configuring WPA and WPA2 enterprise Wi-Fi networks.
    /// NEHotspotEAPSettings class provides a set of properties that are required
    /// to configure a WPA/WPA2 Enterprise or Hotspot 2.0 Wi-Fi networks.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEHotspotEAPSettings;
);

extern_conformance!(
    unsafe impl NSCoding for NEHotspotEAPSettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEHotspotEAPSettings {}
);

unsafe impl CopyingHelper for NEHotspotEAPSettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEHotspotEAPSettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEHotspotEAPSettings {}
);

impl NEHotspotEAPSettings {
    extern_methods!(
        /// Array of supported EAP Types. Refer to NEHotspotConfigurationEAPType
        /// for valid values.
        #[unsafe(method(supportedEAPTypes))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedEAPTypes(&self) -> Retained<NSArray<NSNumber>>;

        /// Setter for [`supportedEAPTypes`][Self::supportedEAPTypes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSupportedEAPTypes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportedEAPTypes(&self, supported_eap_types: &NSArray<NSNumber>);

        /// A UTF-8 encoded string containing username component of the user authentication
        /// credentials. Length of this property must be between 1 and 253 characters.
        #[unsafe(method(username))]
        #[unsafe(method_family = none)]
        pub unsafe fn username(&self) -> Retained<NSString>;

        /// Setter for [`username`][Self::username].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setUsername:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUsername(&self, username: &NSString);

        /// Identity string to be used in EAP-Response/Identity of the outer phase. This key is only
        /// relevant to TTLS, PEAP, and EAP-FAST.
        #[unsafe(method(outerIdentity))]
        #[unsafe(method_family = none)]
        pub unsafe fn outerIdentity(&self) -> Retained<NSString>;

        /// Setter for [`outerIdentity`][Self::outerIdentity].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setOuterIdentity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOuterIdentity(&self, outer_identity: &NSString);

        /// Specifies the inner authentication used by the TTLS module.
        /// Possible values are PAP, CHAP, MSCHAP, MSCHAPv2, and EAP. Defaults to EAP.
        #[unsafe(method(ttlsInnerAuthenticationType))]
        #[unsafe(method_family = none)]
        pub unsafe fn ttlsInnerAuthenticationType(
            &self,
        ) -> NEHotspotConfigurationTTLSInnerAuthenticationType;

        /// Setter for [`ttlsInnerAuthenticationType`][Self::ttlsInnerAuthenticationType].
        #[unsafe(method(setTtlsInnerAuthenticationType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTtlsInnerAuthenticationType(
            &self,
            ttls_inner_authentication_type: NEHotspotConfigurationTTLSInnerAuthenticationType,
        );

        /// The password component of the 802.1X authentication credential.
        /// Length of this property must be between 1 and 64 characters.
        #[unsafe(method(password))]
        #[unsafe(method_family = none)]
        pub unsafe fn password(&self) -> Retained<NSString>;

        /// Setter for [`password`][Self::password].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPassword:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPassword(&self, password: &NSString);

        /// Array of server certificate common names that will be used to verify server's certificate.
        /// The string could have wildcards to specify the name, such as "*.mycompany.net". If a server presents
        /// a certificate with DNSName or Common Name that isn't in this list, it won't be trusted.
        #[unsafe(method(trustedServerNames))]
        #[unsafe(method_family = none)]
        pub unsafe fn trustedServerNames(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`trustedServerNames`][Self::trustedServerNames].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTrustedServerNames:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTrustedServerNames(&self, trusted_server_names: &NSArray<NSString>);

        /// If YES, supports two-factor authentication for EAP-TTLS, PEAP, or EAP-FAST.
        /// If NO, allows for zero-factor authentication for EAP-TLS. The default is YES for EAP-TLS,
        /// and NO for other EAP types.
        #[unsafe(method(isTLSClientCertificateRequired))]
        #[unsafe(method_family = none)]
        pub unsafe fn isTLSClientCertificateRequired(&self) -> bool;

        /// Setter for [`isTLSClientCertificateRequired`][Self::isTLSClientCertificateRequired].
        #[unsafe(method(setTlsClientCertificateRequired:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTlsClientCertificateRequired(&self, tls_client_certificate_required: bool);

        /// TLS version to use during the TLS handshake.
        /// Default value is NEHotspotConfigurationEAPTLSVersion_1_2.
        #[unsafe(method(preferredTLSVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredTLSVersion(&self) -> NEHotspotConfigurationEAPTLSVersion;

        /// Setter for [`preferredTLSVersion`][Self::preferredTLSVersion].
        #[unsafe(method(setPreferredTLSVersion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredTLSVersion(
            &self,
            preferred_tls_version: NEHotspotConfigurationEAPTLSVersion,
        );

        #[cfg(feature = "objc2-security")]
        /// Setter to configure the EAP peer identity. The application needs to store
        /// this identity in keychain access group "$(TeamIdentifierPrefix)com.apple.networkextensionsharing".
        /// The API uses SecItemCopyMatching to obtain persistent reference for this identity from application's
        /// keychain and uses that at the time of EAP authentication.
        /// This property is mandatory when EAP-TLS is desired or tlsClientCertificateRequired is set to YES.
        ///
        ///
        /// Parameter `identity`: The identity of the EAP Peer. This is a SecIdentityRef object that contains
        /// a SecKeyRef object and an associated SecCertificateRef object.
        ///
        /// Returns: returns NO if the parameter is not an object of SecIdentityRef type or if the persistent reference
        /// is not found in the application's keychain else returns YES.
        #[unsafe(method(setIdentity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentity(&self, identity: &SecIdentity) -> bool;

        /// Setter to configure an array of trusted server certificates used for trust evaluation of
        /// the server certificate.
        ///
        ///
        /// Parameter `certificates`: Each value in the array is a SecCertificateRef object. Application needs to store
        /// the certificates in keychain access group "$(TeamIdentifierPrefix)com.apple.networkextensionsharing".
        /// The API uses SecItemCopyMatching to obtain persistent reference for each certificate from application's
        /// keychain and uses that at the time os EAP authentication.
        /// Number of elements in the array cannot be more than 10.
        ///
        ///
        /// Returns: returns NO if any element in the array is not an object of type SecCertificateRef or if API
        /// fails to find persistent reference for each element from the application's keychain else return YES.
        ///
        /// # Safety
        ///
        /// `certificates` generic should be of the correct type.
        #[unsafe(method(setTrustedServerCertificates:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTrustedServerCertificates(&self, certificates: &NSArray) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEHotspotEAPSettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Configuration settings for a Wi-Fi network.
    ///
    /// ## Overview
    ///
    /// The `NEHotspotConfiguration` class contains configuration properties and credentials required to connect to Wi-Fi networks.
    ///
    ///
    /// The NEHotspotConfiguration class represents set of properties that are required
    /// to configure a Wi-Fi Network.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEHotspotConfiguration;
);

extern_conformance!(
    unsafe impl NSCoding for NEHotspotConfiguration {}
);

extern_conformance!(
    unsafe impl NSCopying for NEHotspotConfiguration {}
);

unsafe impl CopyingHelper for NEHotspotConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEHotspotConfiguration {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEHotspotConfiguration {}
);

impl NEHotspotConfiguration {
    extern_methods!(
        /// SSID of the Wi-Fi Network.
        #[unsafe(method(SSID))]
        #[unsafe(method_family = none)]
        pub unsafe fn SSID(&self) -> Retained<NSString>;

        /// Prefix string of SSID of the Wi-Fi Network.
        #[unsafe(method(SSIDPrefix))]
        #[unsafe(method_family = none)]
        pub unsafe fn SSIDPrefix(&self) -> Retained<NSString>;

        /// if set to YES the configuration will not be persisted. Default is NO.
        #[unsafe(method(joinOnce))]
        #[unsafe(method_family = none)]
        pub unsafe fn joinOnce(&self) -> bool;

        /// Setter for [`joinOnce`][Self::joinOnce].
        #[unsafe(method(setJoinOnce:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setJoinOnce(&self, join_once: bool);

        /// The lifetime of the configuration in days. The configuration is stored for the
        /// number of days specified by this property. The minimum value is 1 day and maximum value is 365 days.
        /// A configuration does not get deleted automatically if this property is not set or set to an invalid value.
        /// This property does not apply to Enterprise and HS2.0 networks.
        #[unsafe(method(lifeTimeInDays))]
        #[unsafe(method_family = none)]
        pub unsafe fn lifeTimeInDays(&self) -> Retained<NSNumber>;

        /// Setter for [`lifeTimeInDays`][Self::lifeTimeInDays].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLifeTimeInDays:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLifeTimeInDays(&self, life_time_in_days: &NSNumber);

        /// if set to YES the system will perform active scan of the SSID. Default is NO.
        #[unsafe(method(hidden))]
        #[unsafe(method_family = none)]
        pub unsafe fn hidden(&self) -> bool;

        /// Setter for [`hidden`][Self::hidden].
        #[unsafe(method(setHidden:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHidden(&self, hidden: bool);

        /// A designated initializer to instantiate a new NEHotspotConfiguration object.
        /// This initializer is used to configure open Wi-Fi Networks.
        ///
        ///
        /// Parameter `SSID`: The SSID of the open Wi-Fi Network.
        /// Length of SSID must be between 1 and 32 characters.
        #[unsafe(method(initWithSSID:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSSID(this: Allocated<Self>, ssid: &NSString) -> Retained<Self>;

        /// A designated initializer to instantiate a new NEHotspotConfiguration object.
        /// This initializer is used configure either WEP or WPA/WPA2 Personal Wi-Fi Networks.
        ///
        ///
        /// Parameter `SSID`: The SSID of the WEP or WPA/WPA2 Personal Wi-Fi Network
        ///
        /// Parameter `passphrase`: The passphrase credential.
        /// For WPA/WPA2 Personal networks: between 8 and 63 characters.
        /// For Static WEP(64bit)  : 10 Hex Digits
        /// For Static WEP(128bit) : 26 Hex Digits
        ///
        /// Parameter `isWEP`: YES specifies WEP Wi-Fi Network else WPA/WPA2 Personal Wi-Fi Network
        #[unsafe(method(initWithSSID:passphrase:isWEP:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSSID_passphrase_isWEP(
            this: Allocated<Self>,
            ssid: &NSString,
            passphrase: &NSString,
            is_wep: bool,
        ) -> Retained<Self>;

        /// A designated initializer to instantiate a new NEHotspotConfiguration object.
        /// This initializer is used configure WPA/WPA2 Enterprise Wi-Fi Networks.
        ///
        ///
        /// Parameter `SSID`: The SSID of WPA/WPA2 Enterprise Wi-Fi Network
        ///
        /// Parameter `eapSettings`: EAP configuration
        #[unsafe(method(initWithSSID:eapSettings:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSSID_eapSettings(
            this: Allocated<Self>,
            ssid: &NSString,
            eap_settings: &NEHotspotEAPSettings,
        ) -> Retained<Self>;

        /// A designated initializer to instantiate a new NEHotspotConfiguration object.
        /// This initializer is used configure HS2.0 Wi-Fi Networks.
        ///
        ///
        /// Parameter `hs20Settings`: Hotspot 2.0 configuration
        ///
        /// Parameter `eapSettings`: EAP configuration
        #[unsafe(method(initWithHS20Settings:eapSettings:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithHS20Settings_eapSettings(
            this: Allocated<Self>,
            hs20_settings: &NEHotspotHS20Settings,
            eap_settings: &NEHotspotEAPSettings,
        ) -> Retained<Self>;

        /// A designated initializer to instantiate a new NEHotspotConfiguration object.
        /// This initializer is used to configure open Wi-Fi Networks.
        ///
        ///
        /// Parameter `SSIDPrefix`: The prefix string of SSID of the open Wi-Fi Network.
        /// Length of SSIDPrefix must be between 3 and 32 characters.
        #[unsafe(method(initWithSSIDPrefix:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSSIDPrefix(
            this: Allocated<Self>,
            ssid_prefix: &NSString,
        ) -> Retained<Self>;

        /// A designated initializer to instantiate a new NEHotspotConfiguration object.
        /// This initializer is used configure either WEP or WPA/WPA2 Personal Wi-Fi Networks.
        ///
        ///
        /// Parameter `SSIDPrefix`: The prefix string of SSID of the WEP or WPA/WPA2 Personal Wi-Fi Network.
        /// Length of SSIDPrefix must be between 3 and 32 characters.
        ///
        /// Parameter `passphrase`: The passphrase credential.
        /// For WPA/WPA2 Personal networks: between 8 and 63 characters.
        /// For Static WEP(64bit)  : 10 Hex Digits
        /// For Static WEP(128bit) : 26 Hex Digits
        ///
        /// Parameter `isWEP`: YES specifies WEP Wi-Fi Network else WPA/WPA2 Personal Wi-Fi Network
        #[unsafe(method(initWithSSIDPrefix:passphrase:isWEP:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSSIDPrefix_passphrase_isWEP(
            this: Allocated<Self>,
            ssid_prefix: &NSString,
            passphrase: &NSString,
            is_wep: bool,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEHotspotConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern "C" {
    /// The domain string for errors involving hotspot configuration.
    pub static NEHotspotConfigurationErrorDomain: &'static NSString;
}

/// Error values returned by hotspot configuration manager methods.
/// Hotspot Configuration error codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEHotspotConfigurationError(pub NSInteger);
impl NEHotspotConfigurationError {
    /// The configuration is not valid.
    #[doc(alias = "NEHotspotConfigurationErrorInvalid")]
    pub const Invalid: Self = Self(0);
    /// The SSID value is not valid.
    #[doc(alias = "NEHotspotConfigurationErrorInvalidSSID")]
    pub const InvalidSSID: Self = Self(1);
    /// The WPA passphrase is not valid.
    #[doc(alias = "NEHotspotConfigurationErrorInvalidWPAPassphrase")]
    pub const InvalidWPAPassphrase: Self = Self(2);
    /// The WEP passphrase is not valid.
    #[doc(alias = "NEHotspotConfigurationErrorInvalidWEPPassphrase")]
    pub const InvalidWEPPassphrase: Self = Self(3);
    /// EAP settings are not valid.
    #[doc(alias = "NEHotspotConfigurationErrorInvalidEAPSettings")]
    pub const InvalidEAPSettings: Self = Self(4);
    /// The HS 2.0 settings are not valid.
    #[doc(alias = "NEHotspotConfigurationErrorInvalidHS20Settings")]
    pub const InvalidHS20Settings: Self = Self(5);
    /// The HS 2.0 domain name is not valid.
    #[doc(alias = "NEHotspotConfigurationErrorInvalidHS20DomainName")]
    pub const InvalidHS20DomainName: Self = Self(6);
    /// The user has refused the network configuration.
    #[doc(alias = "NEHotspotConfigurationErrorUserDenied")]
    pub const UserDenied: Self = Self(7);
    /// Internal error, otherwise undefined.
    #[doc(alias = "NEHotspotConfigurationErrorInternal")]
    pub const Internal: Self = Self(8);
    /// The network configuration action has not completed.
    #[doc(alias = "NEHotspotConfigurationErrorPending")]
    pub const Pending: Self = Self(9);
    /// The system configuration is not valid.
    #[doc(alias = "NEHotspotConfigurationErrorSystemConfiguration")]
    pub const SystemConfiguration: Self = Self(10);
    /// An unknown error has occurred.
    #[doc(alias = "NEHotspotConfigurationErrorUnknown")]
    pub const Unknown: Self = Self(11);
    /// The join-once option isn’t support for EAP configuration.
    #[doc(alias = "NEHotspotConfigurationErrorJoinOnceNotSupported")]
    pub const JoinOnceNotSupported: Self = Self(12);
    /// The configuration is already associated with the hotspot.
    #[doc(alias = "NEHotspotConfigurationErrorAlreadyAssociated")]
    pub const AlreadyAssociated: Self = Self(13);
    /// The application is not running in the foreground.
    #[doc(alias = "NEHotspotConfigurationErrorApplicationIsNotInForeground")]
    pub const ApplicationIsNotInForeground: Self = Self(14);
    /// The SSID prefix used to create the hotspot configuration is invalid.
    #[doc(alias = "NEHotspotConfigurationErrorInvalidSSIDPrefix")]
    pub const InvalidSSIDPrefix: Self = Self(15);
    #[doc(alias = "NEHotspotConfigurationErrorUserUnauthorized")]
    pub const UserUnauthorized: Self = Self(16);
    #[doc(alias = "NEHotspotConfigurationErrorSystemDenied")]
    pub const SystemDenied: Self = Self(17);
}

unsafe impl Encode for NEHotspotConfigurationError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEHotspotConfigurationError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A manager that applies and removes hotspot configurations of Wi-Fi networks.
    ///
    /// ## Overview
    ///
    /// When your app creates a new hotspot configuration using [`NEHotspotConfiguration`](https://developer.apple.com/documentation/networkextension/nehotspotconfiguration) and applies it to a Wi-Fi network or attempts to update a previously configured network, the device prompts the user for approval. Without explicit user consent, your app can’t make configuration changes.
    ///
    /// Your app can use [`removeConfigurationForHS20DomainName:`](https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager/removeconfiguration(forhs20domainname:)) or [`removeConfigurationForSSID:`](https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager/removeconfiguration(forssid:)) to delete a configuration that it has added, but not a configuration added by another app or user. The user can also delete configured networks using Settings > Wi-Fi.
    ///
    /// When your app is uninstalled, iOS removes the configurations of all networks your app has configured, including their keychain entries.
    ///
    /// Hotspot Configuration Manager errors are listed in [`NEHotspotConfigurationError`](https://developer.apple.com/documentation/networkextension/nehotspotconfigurationerror).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To use the [`NEHotspotConfigurationManager`](https://developer.apple.com/documentation/networkextension/nehotspotconfigurationmanager) class, you must enable the Hotspot Configuration capability in Xcode. For more information, see [`Hotspot Configuration Entitlement`](https://developer.apple.com/documentation/bundleresources/entitlements/com.apple.developer.networking.hotspotconfiguration).
    ///
    ///
    ///
    /// </div>
    ///
    /// The NEHotspotConfigurationManager class allows an application to
    /// Add/Update/Remove Wi-Fi Network Configuraton.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEHotspotConfigurationManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEHotspotConfigurationManager {}
);

impl NEHotspotConfigurationManager {
    extern_methods!(
        #[unsafe(method(sharedManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedManager() -> Retained<NEHotspotConfigurationManager>;

        #[cfg(feature = "block2")]
        /// This function adds or updates a Wi-Fi network configuration.
        ///
        /// Parameter `configuration`: NEHotspotConfiguration object containing the Wi-Fi network configuration.
        ///
        /// Parameter `completionHandler`: A block that will be called when add/update operation is completed.
        /// Pass nil if application does not intend to receive the result.
        /// The NSError passed to this block will be nil if the configuration is successfully stored, non-nil otherwise.
        /// If the configuration is found invalid or API encounters some other error then completionHandler is called
        /// with instance of NSError containing appropriate error code. This API attempts to join the Wi-Fi network
        /// if the configuration is successfully added or updated and the network is found nearby.
        #[unsafe(method(applyConfiguration:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn applyConfiguration_completionHandler(
            &self,
            configuration: &NEHotspotConfiguration,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        /// This function removes Wi-Fi configuration.
        /// If the joinOnce property was set to YES, invoking this method will disassociate from the Wi-Fi network
        /// after the configuration is removed.
        ///
        /// Parameter `SSID`: Wi-Fi SSID for which the configuration is to be deleted.
        #[unsafe(method(removeConfigurationForSSID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeConfigurationForSSID(&self, ssid: &NSString);

        /// This function removes Wi-Fi configuration.
        ///
        /// Parameter `domainName`: HS2.0 domainName for which the configuration is to be deleted.
        #[unsafe(method(removeConfigurationForHS20DomainName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeConfigurationForHS20DomainName(&self, domain_name: &NSString);

        #[cfg(feature = "block2")]
        /// This function returns array of SSIDs and HS2.0 Domain Names that the calling application has configured.
        /// It returns nil if there are no networks configurred by the calling application.
        #[unsafe(method(getConfiguredSSIDsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getConfiguredSSIDsWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSString>>)>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-accessory-setup-kit"))]
        #[cfg(target_os = "ios")]
        /// This function performs a one-time join of a Wi-Fi network configuration defined by an ASAccessory.
        /// This function implicitly sets joinOnce to YES. The network must support WPA/WPA2/WPA3 Personal security type.
        ///
        /// Parameter `accessory`: Object of type ASAccessory class.
        /// This parameter is required to specify the Accessory Wi-Fi network.
        ///
        /// Parameter `passphrase`: The required passphrase credential.
        /// The passphrase with a length between 8 and 63 characters to join WPA/WPA2/WPA3 Personal networks.
        ///
        /// Parameter `completionHandler`: A block that will be called when join operation is completed.
        /// Pass nil if application does not intend to receive the result.
        /// The NSError passed to this block will be nil if the hotspot is successfully joined, non-nil otherwise.
        /// If the configuration is found to be invalid or some other error is encountered then the completionHandler
        /// block is executed with with an instance of NSError containing an appropriate error code.
        #[unsafe(method(joinAccessoryHotspot:passphrase:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn joinAccessoryHotspot_passphrase_completionHandler(
            &self,
            accessory: &ASAccessory,
            passphrase: &NSString,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-accessory-setup-kit"))]
        #[cfg(target_os = "ios")]
        /// This function performs a one-time join of an open Wi-Fi network configuration defined by an ASAccessory.
        /// This function implicitly sets joinOnce to YES.
        ///
        /// Parameter `accessory`: Object of type ASAccessory class.
        /// This parameter is required to specify the Accessory Wi-Fi network.
        ///
        /// Parameter `completionHandler`: A block that will be called when join operation is completed.
        /// Pass nil if application does not intend to receive the result.
        /// The NSError passed to this block will be nil if the hotspot is successfully joined, non-nil otherwise.
        /// If the configuration is found to be invalid or some other error is encountered then the completionHandler
        /// block is executed with with an instance of NSError containing an appropriate error code.
        #[unsafe(method(joinAccessoryHotspotWithoutSecurity:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn joinAccessoryHotspotWithoutSecurity_completionHandler(
            &self,
            accessory: &ASAccessory,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NEHotspotConfigurationManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The IPv4 settings of an IP layer network tunnel.
    ///
    /// ## Overview
    ///
    /// To specify the IPv4 settings of a packet tunnel, set its [`NEPacketTunnelNetworkSettings`](https://developer.apple.com/documentation/networkextension/nepackettunnelnetworksettings).[`IPv4Settings`](https://developer.apple.com/documentation/networkextension/nepackettunnelnetworksettings/ipv4settings) property to an instance of this class.
    ///
    ///
    /// The NEIPv4Settings class declares the programmatic interface for an object that contains IPv4 settings.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEIPv4Settings;
);

extern_conformance!(
    unsafe impl NSCoding for NEIPv4Settings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEIPv4Settings {}
);

unsafe impl CopyingHelper for NEIPv4Settings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEIPv4Settings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEIPv4Settings {}
);

impl NEIPv4Settings {
    extern_methods!(
        /// Initialize a newly-allocated NEIPv4Settings object.
        ///
        /// Parameter `addresses`: An array of IPv4 addresses represented as dotted decimal strings.
        ///
        /// Parameter `subnetMasks`: An array of IPv4 subnet masks represented as dotted decimal strings.
        ///
        /// Returns: The initialized object.
        #[unsafe(method(initWithAddresses:subnetMasks:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAddresses_subnetMasks(
            this: Allocated<Self>,
            addresses: &NSArray<NSString>,
            subnet_masks: &NSArray<NSString>,
        ) -> Retained<Self>;

        /// Create a NEIPv4Settings object that will obtain IP addresses and netmasks using DHCP.
        ///
        /// Returns: The initialized object.
        #[unsafe(method(settingsWithAutomaticAddressing))]
        #[unsafe(method_family = none)]
        pub unsafe fn settingsWithAutomaticAddressing() -> Retained<Self>;

        /// An array of IPv4 addresses represented as dotted decimal strings. These addresses will be set on the virtual interface used by the VPN tunnel.
        #[unsafe(method(addresses))]
        #[unsafe(method_family = none)]
        pub unsafe fn addresses(&self) -> Retained<NSArray<NSString>>;

        /// An array of IPv4 subnet masks represented as dotted decimal strings. These subnet masks will be set along with their corresponding addresses from the addresses array on the virtual interface used by the VPN tunnel.
        #[unsafe(method(subnetMasks))]
        #[unsafe(method_family = none)]
        pub unsafe fn subnetMasks(&self) -> Retained<NSArray<NSString>>;

        /// The address of the next-hop gateway router represented as a dotted decimal string. This property is ignored for TUN interfaces.
        #[unsafe(method(router))]
        #[unsafe(method_family = none)]
        pub unsafe fn router(&self) -> Option<Retained<NSString>>;

        /// Setter for [`router`][Self::router].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRouter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRouter(&self, router: Option<&NSString>);

        /// An array of NEIPv4Route objects. Traffic matching these routes will be routed through the virtual interface used by the VPN tunnel.
        #[unsafe(method(includedRoutes))]
        #[unsafe(method_family = none)]
        pub unsafe fn includedRoutes(&self) -> Option<Retained<NSArray<NEIPv4Route>>>;

        /// Setter for [`includedRoutes`][Self::includedRoutes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIncludedRoutes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIncludedRoutes(&self, included_routes: Option<&NSArray<NEIPv4Route>>);

        /// An array of NEIPv4Route objects. Traffic matching these routes will be routed through the current primary physical interface of the device.
        #[unsafe(method(excludedRoutes))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludedRoutes(&self) -> Option<Retained<NSArray<NEIPv4Route>>>;

        /// Setter for [`excludedRoutes`][Self::excludedRoutes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExcludedRoutes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludedRoutes(&self, excluded_routes: Option<&NSArray<NEIPv4Route>>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEIPv4Settings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The settings for an IPv4 route.
    /// The NEIPv4Route class declares the programmatic interface for an object that contains settings for an IPv4 route.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEIPv4Route;
);

extern_conformance!(
    unsafe impl NSCoding for NEIPv4Route {}
);

extern_conformance!(
    unsafe impl NSCopying for NEIPv4Route {}
);

unsafe impl CopyingHelper for NEIPv4Route {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEIPv4Route {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEIPv4Route {}
);

impl NEIPv4Route {
    extern_methods!(
        /// Initialize a newly-allocated NEIPv4Route.
        ///
        /// Parameter `address`: The IPv4 address of the destination network.
        ///
        /// Parameter `subnetMask`: The subnet mask of the destination network.
        ///
        /// Returns: The initialized NEIPv4Route.
        #[unsafe(method(initWithDestinationAddress:subnetMask:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDestinationAddress_subnetMask(
            this: Allocated<Self>,
            address: &NSString,
            subnet_mask: &NSString,
        ) -> Retained<Self>;

        /// An IPv4 address represented as a dotted decimal string.
        #[unsafe(method(destinationAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn destinationAddress(&self) -> Retained<NSString>;

        /// An IPv4 subnet mask represented as a dotted decimal string. This mask in combination with the destinationAddress property is used to determine the destination network of the route.
        #[unsafe(method(destinationSubnetMask))]
        #[unsafe(method_family = none)]
        pub unsafe fn destinationSubnetMask(&self) -> Retained<NSString>;

        /// The IPv4 address of the route's gateway. If this property is nil then the route's gateway will be set to the tunnel's virtual interface.
        #[unsafe(method(gatewayAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn gatewayAddress(&self) -> Option<Retained<NSString>>;

        /// Setter for [`gatewayAddress`][Self::gatewayAddress].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setGatewayAddress:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGatewayAddress(&self, gateway_address: Option<&NSString>);

        /// Returns: A route object that represents the IPv4 default route.
        #[unsafe(method(defaultRoute))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultRoute() -> Retained<NEIPv4Route>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEIPv4Route {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The IPv6 settings of an IP layer network tunnel.
    ///
    /// ## Overview
    ///
    /// To specify the IPv6 settings of a packet tunnel, set its [`NEPacketTunnelNetworkSettings`](https://developer.apple.com/documentation/networkextension/nepackettunnelnetworksettings).[`IPv6Settings`](https://developer.apple.com/documentation/networkextension/nepackettunnelnetworksettings/ipv6settings) property to an instance of this class.
    ///
    ///
    /// The NEIPv6Settings class declares the programmatic interface for an object that contains IPv6 settings.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEIPv6Settings;
);

extern_conformance!(
    unsafe impl NSCoding for NEIPv6Settings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEIPv6Settings {}
);

unsafe impl CopyingHelper for NEIPv6Settings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEIPv6Settings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEIPv6Settings {}
);

impl NEIPv6Settings {
    extern_methods!(
        /// Initialize a newly-allocated NEIPv6Settings object.
        ///
        /// Parameter `addresses`: An array of IPv6 addresses represented as dotted decimal strings.
        ///
        /// Parameter `networkPrefixLengths`: An array of NSNumber objects each containing the length in bits of the network prefix of the corresponding address in the addresses parameter.
        ///
        /// Returns: The initialized object.
        #[unsafe(method(initWithAddresses:networkPrefixLengths:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAddresses_networkPrefixLengths(
            this: Allocated<Self>,
            addresses: &NSArray<NSString>,
            network_prefix_lengths: &NSArray<NSNumber>,
        ) -> Retained<Self>;

        /// Create a NEIPv6Settings object that will obtain IP addresses and netmasks automatically.
        #[unsafe(method(settingsWithAutomaticAddressing))]
        #[unsafe(method_family = none)]
        pub unsafe fn settingsWithAutomaticAddressing() -> Retained<Self>;

        /// Create a NEIPv6Settings object that will only use link-local IPv6 addresses.
        #[unsafe(method(settingsWithLinkLocalAddressing))]
        #[unsafe(method_family = none)]
        pub unsafe fn settingsWithLinkLocalAddressing() -> Retained<Self>;

        /// An array of IPv6 addresses represented strings. These addresses will be set on the virtual interface used by the VPN tunnel.
        #[unsafe(method(addresses))]
        #[unsafe(method_family = none)]
        pub unsafe fn addresses(&self) -> Retained<NSArray<NSString>>;

        /// An array of NSNumber objects each representing the length in bits of the network prefix of the corresponding address in the addresses property.
        #[unsafe(method(networkPrefixLengths))]
        #[unsafe(method_family = none)]
        pub unsafe fn networkPrefixLengths(&self) -> Retained<NSArray<NSNumber>>;

        /// An array of NEIPv6Route objects. Traffic matching these routes will be routed through the virtual interface used by the VPN tunnel.
        #[unsafe(method(includedRoutes))]
        #[unsafe(method_family = none)]
        pub unsafe fn includedRoutes(&self) -> Option<Retained<NSArray<NEIPv6Route>>>;

        /// Setter for [`includedRoutes`][Self::includedRoutes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIncludedRoutes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIncludedRoutes(&self, included_routes: Option<&NSArray<NEIPv6Route>>);

        /// An array of NEIPv6Route objects. Traffic matching these routes will be routed through the current primary physical interface of the device.
        #[unsafe(method(excludedRoutes))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludedRoutes(&self) -> Option<Retained<NSArray<NEIPv6Route>>>;

        /// Setter for [`excludedRoutes`][Self::excludedRoutes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExcludedRoutes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludedRoutes(&self, excluded_routes: Option<&NSArray<NEIPv6Route>>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEIPv6Settings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The settings for an IPv6 route.
    /// The NEIPv6Route class declares the programmatic interface for an object that contains settings for an IPv6 route.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEIPv6Route;
);

extern_conformance!(
    unsafe impl NSCoding for NEIPv6Route {}
);

extern_conformance!(
    unsafe impl NSCopying for NEIPv6Route {}
);

unsafe impl CopyingHelper for NEIPv6Route {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEIPv6Route {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEIPv6Route {}
);

impl NEIPv6Route {
    extern_methods!(
        /// Initialize a newly-allocated NEIPv6Route.
        ///
        /// Parameter `address`: The IPv6 address of the destination network.
        ///
        /// Parameter `networkPrefixLength`: A number containing the length in bits of the network prefix of the destination network.
        ///
        /// Returns: The initialized NEIPv6Route.
        #[unsafe(method(initWithDestinationAddress:networkPrefixLength:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDestinationAddress_networkPrefixLength(
            this: Allocated<Self>,
            address: &NSString,
            network_prefix_length: &NSNumber,
        ) -> Retained<Self>;

        /// An IPv6 address represented as a string.
        #[unsafe(method(destinationAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn destinationAddress(&self) -> Retained<NSString>;

        /// A number containing the length in bits of the network prefix of the destination network. This prefix in combination with the destinationAddress property is used to determine the destination network of the route.
        #[unsafe(method(destinationNetworkPrefixLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn destinationNetworkPrefixLength(&self) -> Retained<NSNumber>;

        /// The IPv6 address of the route's gateway. If this property is nil then the route's gateway will be set to the tunnel's virtual interface.
        #[unsafe(method(gatewayAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn gatewayAddress(&self) -> Option<Retained<NSString>>;

        /// Setter for [`gatewayAddress`][Self::gatewayAddress].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setGatewayAddress:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGatewayAddress(&self, gateway_address: Option<&NSString>);

        /// Returns: A route object that represents the IPv6 default route.
        #[unsafe(method(defaultRoute))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultRoute() -> Retained<NEIPv6Route>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEIPv6Route {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The configuration for a tunnel provider’s virtual interface.
    /// The NETunnelNetworkSettings class declares the programmatic interface for an object that contains network settings.
    ///
    /// NETunnelNetworkSettings is used by NETunnelProviders to communicate the desired network settings for the tunnel to the framework. The framework takes care of applying the contained settings to the system.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NETunnelNetworkSettings;
);

extern_conformance!(
    unsafe impl NSCoding for NETunnelNetworkSettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NETunnelNetworkSettings {}
);

unsafe impl CopyingHelper for NETunnelNetworkSettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NETunnelNetworkSettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NETunnelNetworkSettings {}
);

impl NETunnelNetworkSettings {
    extern_methods!(
        /// This function initializes a newly-allocated NETunnelNetworkSettings object with a given tunnel remote address.
        ///
        /// Parameter `address`: The address of the remote endpoint that is providing the tunnel service.
        #[unsafe(method(initWithTunnelRemoteAddress:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTunnelRemoteAddress(
            this: Allocated<Self>,
            address: &NSString,
        ) -> Retained<Self>;

        /// A string containing the IP address of the remote endpoint that is providing the tunnel service.
        #[unsafe(method(tunnelRemoteAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn tunnelRemoteAddress(&self) -> Retained<NSString>;

        /// An NEDNSSettings object that contains the desired tunnel DNS settings.
        #[unsafe(method(DNSSettings))]
        #[unsafe(method_family = none)]
        pub unsafe fn DNSSettings(&self) -> Option<Retained<NEDNSSettings>>;

        /// Setter for [`DNSSettings`][Self::DNSSettings].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDNSSettings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDNSSettings(&self, dns_settings: Option<&NEDNSSettings>);

        /// An NEProxySettings object that contains the desired tunnel proxy settings.
        #[unsafe(method(proxySettings))]
        #[unsafe(method_family = none)]
        pub unsafe fn proxySettings(&self) -> Option<Retained<NEProxySettings>>;

        /// Setter for [`proxySettings`][Self::proxySettings].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProxySettings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProxySettings(&self, proxy_settings: Option<&NEProxySettings>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NETunnelNetworkSettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The configuration for a packet tunnel provider’s virtual interface.
    /// The NEPacketTunnelNetworkSettings class declares the programmatic interface for an object that contains IP network settings.
    ///
    /// NEPacketTunnelNetworkSettings is used by NEPacketTunnelProviders to communicate the desired IP network settings for the packet tunnel to the framework. The framework takes care of applying the contained settings to the system.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NETunnelNetworkSettings, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEPacketTunnelNetworkSettings;
);

extern_conformance!(
    unsafe impl NSCoding for NEPacketTunnelNetworkSettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEPacketTunnelNetworkSettings {}
);

unsafe impl CopyingHelper for NEPacketTunnelNetworkSettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEPacketTunnelNetworkSettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEPacketTunnelNetworkSettings {}
);

impl NEPacketTunnelNetworkSettings {
    extern_methods!(
        /// An NEIPv4Settings object that contains the desired tunnel IPv4 settings.
        #[unsafe(method(IPv4Settings))]
        #[unsafe(method_family = none)]
        pub unsafe fn IPv4Settings(&self) -> Option<Retained<NEIPv4Settings>>;

        /// Setter for [`IPv4Settings`][Self::IPv4Settings].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIPv4Settings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIPv4Settings(&self, i_pv4_settings: Option<&NEIPv4Settings>);

        /// An NEIPv6Settings object that contains the desired tunnel IPv6 settings.
        #[unsafe(method(IPv6Settings))]
        #[unsafe(method_family = none)]
        pub unsafe fn IPv6Settings(&self) -> Option<Retained<NEIPv6Settings>>;

        /// Setter for [`IPv6Settings`][Self::IPv6Settings].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIPv6Settings:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIPv6Settings(&self, i_pv6_settings: Option<&NEIPv6Settings>);

        /// An NSNumber object containing the number of bytes of overhead appended to each outbound packet through the tunnel. The MTU for the TUN interface is computed by subtracting this value from the MTU of the primary physical interface.
        #[unsafe(method(tunnelOverheadBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn tunnelOverheadBytes(&self) -> Option<Retained<NSNumber>>;

        /// Setter for [`tunnelOverheadBytes`][Self::tunnelOverheadBytes].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTunnelOverheadBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTunnelOverheadBytes(&self, tunnel_overhead_bytes: Option<&NSNumber>);

        /// An NSNumber object containing the Maximum Transmission Unit (MTU) size in bytes to assign to the TUN interface. If this property is set, the tunnelOverheadBytes property is ignored.
        #[unsafe(method(MTU))]
        #[unsafe(method_family = none)]
        pub unsafe fn MTU(&self) -> Option<Retained<NSNumber>>;

        /// Setter for [`MTU`][Self::MTU].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMTU:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMTU(&self, mtu: Option<&NSNumber>);
    );
}

/// Methods declared on superclass `NETunnelNetworkSettings`.
impl NEPacketTunnelNetworkSettings {
    extern_methods!(
        /// This function initializes a newly-allocated NETunnelNetworkSettings object with a given tunnel remote address.
        ///
        /// Parameter `address`: The address of the remote endpoint that is providing the tunnel service.
        #[unsafe(method(initWithTunnelRemoteAddress:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTunnelRemoteAddress(
            this: Allocated<Self>,
            address: &NSString,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEPacketTunnelNetworkSettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The network settings for an ethernet-based VPN tunnel.
    ///
    /// ## Overview
    ///
    /// You use this type with [`NEEthernetTunnelProvider`](https://developer.apple.com/documentation/networkextension/neethernettunnelprovider) instances to communicate the desired network settings for the packet tunnel to the framework. The framework takes care of applying the contained settings to the system.
    ///
    /// Instances of this class are thread-safe.
    ///
    ///
    /// The NEEthernetTunnelNetworkSettings class declares the programmatic interface for an object that contains network settings.
    ///
    /// NEEthernetTunnelNetworkSettings is used by NEEthernetTunnelProviders to communicate the desired network settings for the packet tunnel to the framework. The framework takes care of applying the contained settings to the system.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEPacketTunnelNetworkSettings, NETunnelNetworkSettings, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEEthernetTunnelNetworkSettings;
);

extern_conformance!(
    unsafe impl NSCoding for NEEthernetTunnelNetworkSettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NEEthernetTunnelNetworkSettings {}
);

unsafe impl CopyingHelper for NEEthernetTunnelNetworkSettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEEthernetTunnelNetworkSettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEEthernetTunnelNetworkSettings {}
);

impl NEEthernetTunnelNetworkSettings {
    extern_methods!(
        /// This function initializes a newly-allocated NEEthernetTunnelNetworkSettings object with a given tunnel remote address and MAC address.
        ///
        /// Parameter `address`: The address of the remote endpoint that is providing the tunnel service.
        ///
        /// Parameter `ethernetAddress`: The ethernet address to be assigned to the tunnel interface. This string should be in the format "xx:xx:xx:xx:xx:xx", where each xx is a hexidecimal number between 0 and ff.
        ///
        /// Parameter `mtu`: The MTU (Maxium Transmission Unit) in bytes to be assigned to the tunnel interface.
        #[unsafe(method(initWithTunnelRemoteAddress:ethernetAddress:mtu:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTunnelRemoteAddress_ethernetAddress_mtu(
            this: Allocated<Self>,
            address: &NSString,
            ethernet_address: &NSString,
            mtu: NSInteger,
        ) -> Retained<Self>;

        /// An NSString object containing the ethernet address of the tunnel interface.
        #[unsafe(method(ethernetAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn ethernetAddress(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NETunnelNetworkSettings`.
impl NEEthernetTunnelNetworkSettings {
    extern_methods!(
        /// This function initializes a newly-allocated NETunnelNetworkSettings object with a given tunnel remote address.
        ///
        /// Parameter `address`: The address of the remote endpoint that is providing the tunnel service.
        #[unsafe(method(initWithTunnelRemoteAddress:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTunnelRemoteAddress(
            this: Allocated<Self>,
            address: &NSString,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEEthernetTunnelNetworkSettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The principal class for a packet tunnel provider app extension.
    ///
    /// ## Overview
    ///
    /// The [`NEPacketTunnelProvider`](https://developer.apple.com/documentation/networkextension/nepackettunnelprovider) class gives its subclasses access to a virtual network interface via the [`packetFlow`](https://developer.apple.com/documentation/networkextension/nepackettunnelprovider/packetflow) property. Use the [`setTunnelNetworkSettings:completionHandler:`](https://developer.apple.com/documentation/networkextension/netunnelprovider/settunnelnetworksettings(_:completionhandler:)) method in the Packet Tunnel Provider to specify that the following network settings be associated with the virtual interface:
    ///
    /// - Virtual IP address
    ///
    /// - DNS resolver configuration
    ///
    /// - HTTP proxy configuration
    ///
    /// - IP destination networks to be routed through the tunnel
    ///
    /// - IP destination networks to be routed outside the tunnel
    ///
    /// - Interface MTU
    ///
    /// By specifying IP destination networks, the Packet Tunnel Provider can dictate what IP destinations will be routed to the virtual interface. IP packets with matching destination addresses will then be diverted to Packet Tunnel Provider and can be read using the [`packetFlow`](https://developer.apple.com/documentation/networkextension/nepackettunnelprovider/packetflow) property. The Packet Tunnel Provider can then encapsulate the IP packets per a custom tunneling protocol and send them to a tunnel server. When the Packet Tunnel Provider decapsulates IP packets received from the tunnel server, it can use the [`packetFlow`](https://developer.apple.com/documentation/networkextension/nepackettunnelprovider/packetflow) property to inject the packets into the networking stack.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The `com.apple.developer.networking.networkextension` entitlement is required in order to use the [`NEPacketTunnelProvider`](https://developer.apple.com/documentation/networkextension/nepackettunnelprovider) class. Enable this entitlement when creating an App ID in your developer account.
    ///
    ///
    ///
    /// </div>
    /// ### Creating a Packet Tunnel Provider Extension
    ///
    /// Packet Tunnel Providers run as App Extensions for the `com.apple.networkextension.packet-tunnel` extension point.
    ///
    /// To create a Packet Tunnel Provider extension, first create a new App Extension target in your project.
    ///
    /// For an example of an Xcode build target for this app extension, see the [SimpleTunnel: Customized Networking Using the NetworkExtension Framework](https://developer.apple.com/library/archive/samplecode/SimpleTunnel/Introduction/Intro.html#//apple_ref/doc/uid/TP40016140) sample code project.
    ///
    /// Once you have a Packet Tunnel Provider extension target, create a subclass of NEPacketTunnelProvider. Then, set the `NSExtensionPrincipalClass` key in the the extension’s `Info.plist` to the name of your subclass.
    ///
    /// If it is not already, set the `NSExtensionPointIdentifier` key in the extension’s `Info.plist` to `com.apple.networkextension.packet-tunnel`.
    ///
    /// Here is an example of the NSExtension dictionary in a Packet Tunnel Provider extension’s `Info.plist`:
    ///
    /// ```xml
    /// <key>NSExtension</key>
    /// <dict>
    ///     <key>NSExtensionPointIdentifier</key>
    ///     <string>com.apple.networkextension.packet-tunnel</string>
    ///     <key>NSExtensionPrincipalClass</key>
    ///     <string>MyCustomPacketTunnelProvider</string>
    /// </dict>
    /// ```
    ///
    /// Finally, add the Packet Tunnel Provider extension target to your app’s Embed App Extensions build phase.
    ///
    /// ### Subclassing Notes
    ///
    /// In order to create a Packet Tunnel Provider extension, you must create a subclass of `NEPacketTunnelProvider` and override the methods listed below.
    ///
    /// #### Methods to Override
    ///
    /// - [`startTunnelWithOptions:completionHandler:`](https://developer.apple.com/documentation/networkextension/nepackettunnelprovider/starttunnel(options:completionhandler:))
    ///
    /// - [`stopTunnelWithReason:completionHandler:`](https://developer.apple.com/documentation/networkextension/nepackettunnelprovider/stoptunnel(with:completionhandler:))
    ///
    ///
    /// The NEPacketTunnelProvider class declares the programmatic interface of an object that implements the client side of a custom IP packet tunneling protocol.
    ///
    /// NEPacketTunnelProvider is part of NetworkExtension.framework.
    #[unsafe(super(NETunnelProvider, NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEPacketTunnelProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEPacketTunnelProvider {}
);

impl NEPacketTunnelProvider {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function is called by the framework when a new tunnel is being created. Subclasses must override this method to perform whatever steps are necessary to establish the tunnel.
        ///
        /// Parameter `options`: A dictionary containing keys and values passed by the provider's containing app. If the containing app did not start the tunnel then this parameter will be nil.
        ///
        /// Parameter `completionHandler`: A block that must be called when the process of starting the tunnel is complete. If the tunnel cannot be established then the subclass' implementation of this method must pass a non-nil NSError object to this block. A value of nil passed to the completion handler indicates that the tunnel was successfully established.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(startTunnelWithOptions:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startTunnelWithOptions_completionHandler(
            &self,
            options: Option<&NSDictionary<NSString, NSObject>>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function is called by the framework when the tunnel is being destroyed. Subclasses must override this method to perform whatever steps are necessary to tear down the tunnel.
        ///
        /// Parameter `reason`: An NEProviderStopReason indicating why the tunnel is being stopped.
        ///
        /// Parameter `completionHandler`: A block that must be called when the tunnel is completely torn down.
        #[unsafe(method(stopTunnelWithReason:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopTunnelWithReason_completionHandler(
            &self,
            reason: NEProviderStopReason,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        /// This function is called by tunnel provider implementations to initiate tunnel destruction when a network error is encountered that renders the tunnel no longer viable. Subclasses should not override this method.
        ///
        /// Parameter `error`: An NSError object containing details about the error that the tunnel provider implementation encountered.
        #[unsafe(method(cancelTunnelWithError:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelTunnelWithError(&self, error: Option<&NSError>);

        /// An NEPacketFlow object that the tunnel provider implementation should use to receive packets from the network stack and inject packets into the network stack. Every time the tunnel is started the packet flow object is in an initialized state and must be explicitly opened before any packets can be received or injected.
        #[unsafe(method(packetFlow))]
        #[unsafe(method_family = none)]
        pub unsafe fn packetFlow(&self) -> Retained<NEPacketTunnelFlow>;

        /// This function can be called by subclass implementations to create a TCP connection to a given network endpoint, through the tunnel established by the provider. This function should not be overridden by subclasses.
        ///
        /// Parameter `remoteEndpoint`: An NWEndpoint object that specifies the remote network endpoint to connect to.
        ///
        /// Parameter `enableTLS`: A flag indicating if a TLS session should be negotiated on the connection.
        ///
        /// Parameter `TLSParameters`: A set of optional TLS parameters. Only valid if enableTLS is YES. If TLSParameters is nil, the default system parameters will be used for TLS negotiation.
        ///
        /// Parameter `delegate`: An object to use as the connection delegate. This object should conform to the NWTCPConnectionAuthenticationDelegate protocol.
        ///
        /// Returns: An NWTCPConnection object.
        ///
        /// # Safety
        ///
        /// `delegate` should be of the correct type.
        #[deprecated = "Use the `virtualInterface` property with `nw_parameters_require_interface`"]
        #[unsafe(method(createTCPConnectionThroughTunnelToEndpoint:enableTLS:TLSParameters:delegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createTCPConnectionThroughTunnelToEndpoint_enableTLS_TLSParameters_delegate(
            &self,
            remote_endpoint: &NWEndpoint,
            enable_tls: bool,
            tls_parameters: Option<&NWTLSParameters>,
            delegate: Option<&AnyObject>,
        ) -> Retained<NWTCPConnection>;

        /// This function can be called by subclass implementations to create a UDP session between a local network endpoint and a remote network endpoint, through the tunnel established by the provider. This function should not be overridden by subclasses.
        ///
        /// Parameter `remoteEndpoint`: An NWEndpoint object that specifies the remote endpoint to which UDP datagrams will be sent by the UDP session.
        ///
        /// Parameter `localEndpoint`: An NWHostEndpoint object that specifies the local IP address endpoint to use as the source endpoint of the UDP session.
        ///
        /// Returns: An NWUDPSession object.
        #[deprecated = "Use the `virtualInterface` property with `nw_parameters_require_interface`"]
        #[unsafe(method(createUDPSessionThroughTunnelToEndpoint:fromEndpoint:))]
        #[unsafe(method_family = none)]
        pub unsafe fn createUDPSessionThroughTunnelToEndpoint_fromEndpoint(
            &self,
            remote_endpoint: &NWEndpoint,
            local_endpoint: Option<&NWHostEndpoint>,
        ) -> Retained<NWUDPSession>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEPacketTunnelProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A type that implements the client side of a custom link-layer packet tunneling protocol.
    /// The NEEthernetTunnelProvider class declares the programmatic interface of an object that implements the client side of a custom link-layer packet tunneling protocol.
    ///
    /// NEEthernetTunnelProvider is part of NetworkExtension.framework.
    #[unsafe(super(NEPacketTunnelProvider, NETunnelProvider, NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEEthernetTunnelProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEEthernetTunnelProvider {}
);

impl NEEthernetTunnelProvider {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NEEthernetTunnelProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// On Demand rule actions
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEOnDemandRuleAction(pub NSInteger);
impl NEOnDemandRuleAction {
    /// Start the VPN connection for every connection attempt.
    #[doc(alias = "NEOnDemandRuleActionConnect")]
    pub const Connect: Self = Self(1);
    /// Do not start the VPN connection, and disconnect the VPN connection if it is not currently disconnected.
    #[doc(alias = "NEOnDemandRuleActionDisconnect")]
    pub const Disconnect: Self = Self(2);
    /// Start the VPN after evaluating the destination host being accessed against the rule’s parameters.
    #[doc(alias = "NEOnDemandRuleActionEvaluateConnection")]
    pub const EvaluateConnection: Self = Self(3);
    /// Do not start the VPN connection, but do not disconnect it if it is currently connected.
    #[doc(alias = "NEOnDemandRuleActionIgnore")]
    pub const Ignore: Self = Self(4);
}

unsafe impl Encode for NEOnDemandRuleAction {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEOnDemandRuleAction {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// On Demand rule network interface types
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEOnDemandRuleInterfaceType(pub NSInteger);
impl NEOnDemandRuleInterfaceType {
    /// Match any interface type
    #[doc(alias = "NEOnDemandRuleInterfaceTypeAny")]
    pub const Any: Self = Self(0);
    /// Match wired ethernet interfaces
    #[doc(alias = "NEOnDemandRuleInterfaceTypeEthernet")]
    pub const Ethernet: Self = Self(1);
    /// Match Wi-Fi interfaces
    #[doc(alias = "NEOnDemandRuleInterfaceTypeWiFi")]
    pub const WiFi: Self = Self(2);
    /// Match cellular data interfaces
    #[doc(alias = "NEOnDemandRuleInterfaceTypeCellular")]
    pub const Cellular: Self = Self(3);
}

unsafe impl Encode for NEOnDemandRuleInterfaceType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEOnDemandRuleInterfaceType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A base class shared by all VPN On Demand rules.
    ///
    /// ## Overview
    ///
    /// Each rule is defined by a single action and a set of optional matching conditions. The action defines how the system should trigger the VPN when the conditions are met, such as connecting automatically for all connections, connecting conditionally, or disconnecting. The optional conditions describe parameters of a network. Some common rules include disconnecting the VPN on a trusted, internal network, and triggering on all other networks. When rules are defined in an array, they are evaluated in order and the action of the first rule to match all conditions is chosen.
    ///
    /// Instances of the `NEOnDemandRule` class should be created through one of its subclasses: [`NEOnDemandRuleConnect`](https://developer.apple.com/documentation/networkextension/neondemandruleconnect), [`NEOnDemandRuleDisconnect`](https://developer.apple.com/documentation/networkextension/neondemandruledisconnect), [`NEOnDemandRuleEvaluateConnection`](https://developer.apple.com/documentation/networkextension/neondemandruleevaluateconnection), or [`NEOnDemandRuleIgnore`](https://developer.apple.com/documentation/networkextension/neondemandruleignore).
    ///
    ///
    /// The NEOnDemandRule class declares the programmatic interface for an object that defines an On Demand rule.
    ///
    /// NEOnDemandRule is an abstract base class from which other action-specific rule classes are derived.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRule;
);

extern_conformance!(
    unsafe impl NSCoding for NEOnDemandRule {}
);

extern_conformance!(
    unsafe impl NSCopying for NEOnDemandRule {}
);

unsafe impl CopyingHelper for NEOnDemandRule {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEOnDemandRule {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEOnDemandRule {}
);

impl NEOnDemandRule {
    extern_methods!(
        /// The rule's action
        #[unsafe(method(action))]
        #[unsafe(method_family = none)]
        pub unsafe fn action(&self) -> NEOnDemandRuleAction;

        /// An array of NSString objects. If the current default search domain is equal to one of the strings in this array and all of the other conditions in the rule match, then the rule matches. If this property is nil (the default), then the current default search domain does not factor into the rule match.
        #[unsafe(method(DNSSearchDomainMatch))]
        #[unsafe(method_family = none)]
        pub unsafe fn DNSSearchDomainMatch(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`DNSSearchDomainMatch`][Self::DNSSearchDomainMatch].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDNSSearchDomainMatch:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDNSSearchDomainMatch(
            &self,
            dns_search_domain_match: Option<&NSArray<NSString>>,
        );

        /// An array of DNS server IP addresses represented as NSString objects. If each of the current default DNS servers is equal to one of the strings in this array and all of the other conditions in the rule match, then the rule matches. If this property is nil (the default), then the default DNS servers do not factor into the rule match.
        #[unsafe(method(DNSServerAddressMatch))]
        #[unsafe(method_family = none)]
        pub unsafe fn DNSServerAddressMatch(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`DNSServerAddressMatch`][Self::DNSServerAddressMatch].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDNSServerAddressMatch:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDNSServerAddressMatch(
            &self,
            dns_server_address_match: Option<&NSArray<NSString>>,
        );

        /// The type of interface that this rule matches. If the current primary network interface is of this type and all of the other conditions in the rule match, then the rule matches. If this property is 0 (the default), then the current primary interface type does not factor into the rule match.
        #[unsafe(method(interfaceTypeMatch))]
        #[unsafe(method_family = none)]
        pub unsafe fn interfaceTypeMatch(&self) -> NEOnDemandRuleInterfaceType;

        /// Setter for [`interfaceTypeMatch`][Self::interfaceTypeMatch].
        #[unsafe(method(setInterfaceTypeMatch:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInterfaceTypeMatch(
            &self,
            interface_type_match: NEOnDemandRuleInterfaceType,
        );

        /// An array of NSString objects. If the Service Set Identifier (SSID) of the current primary connected network matches one of the strings in this array and all of the other conditions in the rule match, then the rule matches. If this property is nil (the default), then the current primary connected network SSID does not factor into the rule match.
        #[unsafe(method(SSIDMatch))]
        #[unsafe(method_family = none)]
        pub unsafe fn SSIDMatch(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`SSIDMatch`][Self::SSIDMatch].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSSIDMatch:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSSIDMatch(&self, ssid_match: Option<&NSArray<NSString>>);

        /// An HTTP or HTTPS URL. If a request sent to this URL results in a HTTP 200 OK response and all of the other conditions in the rule match, then then rule matches. If this property is nil (the default), then an HTTP request does not factor into the rule match.
        #[unsafe(method(probeURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn probeURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`probeURL`][Self::probeURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProbeURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProbeURL(&self, probe_url: Option<&NSURL>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEOnDemandRule {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A VPN On Demand rule that connects the VPN.
    ///
    /// ## Overview
    ///
    /// When rules of this class match, the system starts the VPN connection whenever an application running on the system opens a network connection.
    ///
    ///
    /// The NEOnDemandRuleConnect class declares the programmatic interface for an object that defines an On Demand rule with the "Connect" action.
    ///
    /// When rules of this class match, the VPN connection is started whenever an application running on the system opens a network connection.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEOnDemandRule, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRuleConnect;
);

extern_conformance!(
    unsafe impl NSCoding for NEOnDemandRuleConnect {}
);

extern_conformance!(
    unsafe impl NSCopying for NEOnDemandRuleConnect {}
);

unsafe impl CopyingHelper for NEOnDemandRuleConnect {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEOnDemandRuleConnect {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEOnDemandRuleConnect {}
);

impl NEOnDemandRuleConnect {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NEOnDemandRuleConnect {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A VPN On Demand rule that disconnects the VPN.
    ///
    /// ## Overview
    ///
    /// When rules of this class match, the VPN connection is not started, and the VPN connection is disconnected if it is not already disconnected.
    ///
    ///
    /// The NEOnDemandRuleDisconnect class declares the programmatic interface for an object that defines an On Demand rule with the "Disconnect" action.
    ///
    /// When rules of this class match, the VPN connection is not started, and the VPN connection is disconnected if it is not currently disconnected.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEOnDemandRule, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRuleDisconnect;
);

extern_conformance!(
    unsafe impl NSCoding for NEOnDemandRuleDisconnect {}
);

extern_conformance!(
    unsafe impl NSCopying for NEOnDemandRuleDisconnect {}
);

unsafe impl CopyingHelper for NEOnDemandRuleDisconnect {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEOnDemandRuleDisconnect {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEOnDemandRuleDisconnect {}
);

impl NEOnDemandRuleDisconnect {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NEOnDemandRuleDisconnect {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A VPN On Demand rule that doesn’t change the status of the VPN.
    ///
    /// ## Overview
    ///
    /// When rules of this class match, the VPN connection is not started, and the current status of the VPN connection is left unchanged.
    ///
    ///
    /// The NEOnDemandRuleIgnore class declares the programmatic interface for an object that defines an On Demand rule with the "Ignore" action.
    ///
    /// When rules of this class match, the VPN connection is not started, and the current status of the VPN connection is left unchanged.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEOnDemandRule, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRuleIgnore;
);

extern_conformance!(
    unsafe impl NSCoding for NEOnDemandRuleIgnore {}
);

extern_conformance!(
    unsafe impl NSCopying for NEOnDemandRuleIgnore {}
);

unsafe impl CopyingHelper for NEOnDemandRuleIgnore {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEOnDemandRuleIgnore {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEOnDemandRuleIgnore {}
);

impl NEOnDemandRuleIgnore {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NEOnDemandRuleIgnore {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A VPN On Demand rule that evaluate the app’s connection to determine whether to run its action.
    ///
    /// ## Overview
    ///
    /// When rules of this class match, the properties of the network connection being established are matched against a set of connection rules. The action of the matched rule (if any) is used to determine whether or not the VPN will be started.
    ///
    ///
    /// The NEOnDemandRuleEvaluateConnection class declares the programmatic interface for an object that defines an On Demand rule with the "Evaluate Connection" action.
    ///
    /// When rules of this class match, the properties of the network connection being established are matched against a set of connection rules. The action of the matched rule (if any) is used to determine whether or not the VPN will be started.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEOnDemandRule, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEOnDemandRuleEvaluateConnection;
);

extern_conformance!(
    unsafe impl NSCoding for NEOnDemandRuleEvaluateConnection {}
);

extern_conformance!(
    unsafe impl NSCopying for NEOnDemandRuleEvaluateConnection {}
);

unsafe impl CopyingHelper for NEOnDemandRuleEvaluateConnection {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEOnDemandRuleEvaluateConnection {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEOnDemandRuleEvaluateConnection {}
);

impl NEOnDemandRuleEvaluateConnection {
    extern_methods!(
        /// An array of NEEvaluateConnectionRule objects. Each NEEvaluateConnectionRule object is evaluated in order against the properties of the network connection being established.
        #[unsafe(method(connectionRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectionRules(&self)
            -> Option<Retained<NSArray<NEEvaluateConnectionRule>>>;

        /// Setter for [`connectionRules`][Self::connectionRules].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setConnectionRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConnectionRules(
            &self,
            connection_rules: Option<&NSArray<NEEvaluateConnectionRule>>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NEOnDemandRuleEvaluateConnection {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Evaluate Connection rule actions
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEEvaluateConnectionRuleAction(pub NSInteger);
impl NEEvaluateConnectionRuleAction {
    /// Start the VPN if connections to the matching hostname cannot be resolved.
    #[doc(alias = "NEEvaluateConnectionRuleActionConnectIfNeeded")]
    pub const ConnectIfNeeded: Self = Self(1);
    /// Do not start the VPN.
    #[doc(alias = "NEEvaluateConnectionRuleActionNeverConnect")]
    pub const NeverConnect: Self = Self(2);
}

unsafe impl Encode for NEEvaluateConnectionRuleAction {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEEvaluateConnectionRuleAction {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// `NEEvaluateConnectionRule` associates properties of network connections with an action.
    /// The NEEvaluateConnectionRule class declares the programmatic interface for an object that associates properties of network connections with an action.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEEvaluateConnectionRule;
);

extern_conformance!(
    unsafe impl NSCoding for NEEvaluateConnectionRule {}
);

extern_conformance!(
    unsafe impl NSCopying for NEEvaluateConnectionRule {}
);

unsafe impl CopyingHelper for NEEvaluateConnectionRule {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEEvaluateConnectionRule {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEEvaluateConnectionRule {}
);

impl NEEvaluateConnectionRule {
    extern_methods!(
        /// Initialize an NEEvaluateConnectionRule instance with a list of destination host domains and an action
        #[unsafe(method(initWithMatchDomains:andAction:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMatchDomains_andAction(
            this: Allocated<Self>,
            domains: &NSArray<NSString>,
            action: NEEvaluateConnectionRuleAction,
        ) -> Retained<Self>;

        /// The action to take if the properties of the network connection being established match the rule.
        #[unsafe(method(action))]
        #[unsafe(method_family = none)]
        pub unsafe fn action(&self) -> NEEvaluateConnectionRuleAction;

        /// An array of NSString objects. If the host name of the destination of the network connection being established shares a suffix with one of the strings in this array, then the rule matches.
        #[unsafe(method(matchDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchDomains(&self) -> Retained<NSArray<NSString>>;

        /// An array of NSString objects. If the rule matches the connection being established and the action is NEEvaluateConnectionRuleActionConnectIfNeeded, the DNS servers specified in this array are used to resolve the host name of the destination while evaluating connectivity to the destination. If the resolution fails for any reason, the VPN is started.
        #[unsafe(method(useDNSServers))]
        #[unsafe(method_family = none)]
        pub unsafe fn useDNSServers(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`useDNSServers`][Self::useDNSServers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setUseDNSServers:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUseDNSServers(&self, use_dns_servers: Option<&NSArray<NSString>>);

        /// An HTTP or HTTPS URL. If the rule matches the connection being established and the action is NEEvaluateConnectionRuleActionConnectIfNeeded and a request sent to this URL results in a response with an HTTP response code other than 200, then the VPN is started.
        #[unsafe(method(probeURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn probeURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`probeURL`][Self::probeURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProbeURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProbeURL(&self, probe_url: Option<&NSURL>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEEvaluateConnectionRule {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A network packet and its associated properties.
    /// An NEPacket object represents the data, protocol family, and metadata associated with an IP packet.
    /// These packets are used to read and write on an NEPacketTunnelFlow.
    ///
    /// NEPacket is part of NetworkExtension.framework
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEPacket;
);

extern_conformance!(
    unsafe impl NSCoding for NEPacket {}
);

extern_conformance!(
    unsafe impl NSCopying for NEPacket {}
);

unsafe impl CopyingHelper for NEPacket {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEPacket {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEPacket {}
);

impl NEPacket {
    extern_methods!(
        #[cfg(feature = "libc")]
        /// Initializes a new NEPacket object with data and protocol family.
        ///
        /// Parameter `data`: The content of the packet.
        ///
        /// Parameter `protocolFamily`: The protocol family of the packet (such as AF_INET or AF_INET6).
        #[unsafe(method(initWithData:protocolFamily:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData_protocolFamily(
            this: Allocated<Self>,
            data: &NSData,
            protocol_family: libc::sa_family_t,
        ) -> Retained<Self>;

        /// The data content of the packet.
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Retained<NSData>;

        #[cfg(feature = "libc")]
        /// The protocol family of the packet (such as AF_INET or AF_INET6).
        #[unsafe(method(protocolFamily))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocolFamily(&self) -> libc::sa_family_t;

        /// The direction of the packet.
        #[unsafe(method(direction))]
        #[unsafe(method_family = none)]
        pub unsafe fn direction(&self) -> NETrafficDirection;

        /// Metadata about the source application and flow for this packet.
        /// This property will only be non-nil when the routing method for the NEPacketTunnelProvider
        /// is NETunnelProviderRoutingMethodSourceApplication.
        #[unsafe(method(metadata))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadata(&self) -> Option<Retained<NEFlowMetaData>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEPacket {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object you use to read and write packets to and from the tunnel’s virtual interface.
    ///
    /// ## Overview
    ///
    /// Use the `NEPacketTunnelFlow` class to implement a custom-IP tunneling protocol for your packet tunnel. For example, use the APIs in this class to read packets from the virtual interface, so you can then encapsulate these packets and send them to a packet-tunnel server. Likewise, read packets from your packet-tunnel server and use these APIs to write the packets back to the tunnel’s virtual interface.
    ///
    ///
    /// The NEPacketTunnelFlow class declares the programmatic interface of an object that is used by NEPacketTunnelProvider implementations to tunnel IP packets.
    ///
    /// NEPacketTunnelFlow is part of NetworkExtension.framework
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEPacketTunnelFlow;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEPacketTunnelFlow {}
);

impl NEPacketTunnelFlow {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// Read available IP packets from the flow.
        ///
        /// Parameter `completionHandler`: A block that will be executed to handle the packets. This block takes an array of NSData objects and an array of NSNumber objects. The NSData and NSNumber in corresponding indicies in the array represent one packet. If after handling the packets the caller wants to read more packets then the caller must call this method again.
        #[unsafe(method(readPacketsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readPacketsWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(NonNull<NSArray<NSData>>, NonNull<NSArray<NSNumber>>),
            >,
        );

        /// Write multiple IP packets to the flow.
        ///
        /// Parameter `packets`: An array of NSData objects, each containing packet data to be written.
        ///
        /// Parameter `protocols`: An array of NSNumber objects. Each number contains the protocol of the packet in the corresponding index in the packets array.
        #[unsafe(method(writePackets:withProtocols:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writePackets_withProtocols(
            &self,
            packets: &NSArray<NSData>,
            protocols: &NSArray<NSNumber>,
        ) -> bool;

        #[cfg(feature = "block2")]
        /// Read available IP packets from the flow.
        ///
        /// Parameter `completionHandler`: A block that will be executed to handle the packets. This block takes an array of NEPacket objects. If after handling the packets the caller wants to read more packets then the caller must call this method again.
        #[unsafe(method(readPacketObjectsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readPacketObjectsWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NEPacket>>)>,
        );

        /// Write multiple IP packets to the flow.
        ///
        /// Parameter `packets`: An array of NEPacket objects, each containing packet data and protocol family to be written.
        #[unsafe(method(writePacketObjects:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writePacketObjects(&self, packets: &NSArray<NEPacket>) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEPacketTunnelFlow {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A single relay server configuration that you can chain together with other relays.
    ///
    /// ## Overview
    ///
    /// Relay servers are secure HTTP proxies that allow proxying TCP traffic using the `CONNECT` method and UDP traffic using the `connect-udp` protocol defined in [RFC 9298](https://www.rfc-editor.org/rfc/rfc9298.html).
    ///
    ///
    /// The NERelay class declares the programmatic interface of an object that
    /// manages the details of a relay's configuration, such as authentication and URL details.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NERelay;
);

extern_conformance!(
    unsafe impl NSCoding for NERelay {}
);

extern_conformance!(
    unsafe impl NSCopying for NERelay {}
);

unsafe impl CopyingHelper for NERelay {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NERelay {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NERelay {}
);

impl NERelay {
    extern_methods!(
        /// The URL of the relay accessible over HTTP/3.
        #[unsafe(method(HTTP3RelayURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn HTTP3RelayURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`HTTP3RelayURL`][Self::HTTP3RelayURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setHTTP3RelayURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHTTP3RelayURL(&self, http3_relay_url: Option<&NSURL>);

        /// The URL of the relay accessible over HTTP/2.
        #[unsafe(method(HTTP2RelayURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn HTTP2RelayURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`HTTP2RelayURL`][Self::HTTP2RelayURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setHTTP2RelayURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHTTP2RelayURL(&self, http2_relay_url: Option<&NSURL>);

        /// The URL of a DNS-over-HTTPS (DoH) resolver accessible via the relay.
        #[unsafe(method(dnsOverHTTPSURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn dnsOverHTTPSURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`dnsOverHTTPSURL`][Self::dnsOverHTTPSURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDnsOverHTTPSURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDnsOverHTTPSURL(&self, dns_over_httpsurl: Option<&NSURL>);

        /// An IPv4 address prefix (such as "192.0.2.0/24") that will be used to synthesize
        /// DNS answers for apps that use `getaddrinfo()` to resolve domains included in `matchDomains`
        #[unsafe(method(syntheticDNSAnswerIPv4Prefix))]
        #[unsafe(method_family = none)]
        pub unsafe fn syntheticDNSAnswerIPv4Prefix(&self) -> Option<Retained<NSString>>;

        /// Setter for [`syntheticDNSAnswerIPv4Prefix`][Self::syntheticDNSAnswerIPv4Prefix].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSyntheticDNSAnswerIPv4Prefix:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSyntheticDNSAnswerIPv4Prefix(
            &self,
            synthetic_dns_answer_i_pv4_prefix: Option<&NSString>,
        );

        /// An IPv6 address prefix (such as "2001:DB8::/32") that will be used to synthesize
        /// DNS answers for apps that use `getaddrinfo()` to resolve domains included in `matchDomains`
        #[unsafe(method(syntheticDNSAnswerIPv6Prefix))]
        #[unsafe(method_family = none)]
        pub unsafe fn syntheticDNSAnswerIPv6Prefix(&self) -> Option<Retained<NSString>>;

        /// Setter for [`syntheticDNSAnswerIPv6Prefix`][Self::syntheticDNSAnswerIPv6Prefix].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSyntheticDNSAnswerIPv6Prefix:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSyntheticDNSAnswerIPv6Prefix(
            &self,
            synthetic_dns_answer_i_pv6_prefix: Option<&NSString>,
        );

        /// Additional HTTP header field names and values to be added to all relay requests.
        #[unsafe(method(additionalHTTPHeaderFields))]
        #[unsafe(method_family = none)]
        pub unsafe fn additionalHTTPHeaderFields(
            &self,
        ) -> Retained<NSDictionary<NSString, NSString>>;

        /// Setter for [`additionalHTTPHeaderFields`][Self::additionalHTTPHeaderFields].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAdditionalHTTPHeaderFields:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAdditionalHTTPHeaderFields(
            &self,
            additional_http_header_fields: &NSDictionary<NSString, NSString>,
        );

        /// TLS 1.3 raw public keys to use to authenticate the relay servers.
        #[unsafe(method(rawPublicKeys))]
        #[unsafe(method_family = none)]
        pub unsafe fn rawPublicKeys(&self) -> Option<Retained<NSArray<NSData>>>;

        /// Setter for [`rawPublicKeys`][Self::rawPublicKeys].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRawPublicKeys:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRawPublicKeys(&self, raw_public_keys: Option<&NSArray<NSData>>);

        /// The PKCS12 data for the relay client authentication. The value is a NSData in PKCS12 format.
        #[unsafe(method(identityData))]
        #[unsafe(method_family = none)]
        pub unsafe fn identityData(&self) -> Option<Retained<NSData>>;

        /// Setter for [`identityData`][Self::identityData].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentityData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentityData(&self, identity_data: Option<&NSData>);

        /// The password to be used to decrypt the PKCS12 identity data.
        #[unsafe(method(identityDataPassword))]
        #[unsafe(method_family = none)]
        pub unsafe fn identityDataPassword(&self) -> Option<Retained<NSString>>;

        /// Setter for [`identityDataPassword`][Self::identityDataPassword].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentityDataPassword:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentityDataPassword(&self, identity_data_password: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NERelay {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Error codes specific to relay managers.
/// NERelay Manager error codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NERelayManagerError(pub NSInteger);
impl NERelayManagerError {
    /// An error code that indicates the relay manager is invalid.
    #[doc(alias = "NERelayManagerErrorConfigurationInvalid")]
    pub const ConfigurationInvalid: Self = Self(1);
    /// An error code that indicates the relay manager isn’t enabled.
    #[doc(alias = "NERelayManagerErrorConfigurationDisabled")]
    pub const ConfigurationDisabled: Self = Self(2);
    /// An error code that indicates the relay manager isn’t loaded.
    #[doc(alias = "NERelayManagerErrorConfigurationStale")]
    pub const ConfigurationStale: Self = Self(3);
    /// An error code that indicates removing the relay manager failed.
    #[doc(alias = "NERelayManagerErrorConfigurationCannotBeRemoved")]
    pub const ConfigurationCannotBeRemoved: Self = Self(4);
}

unsafe impl Encode for NERelayManagerError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NERelayManagerError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The domain for errors resulting from calls to the relay manager.
    ///
    /// ## Discussion
    ///
    /// Match this constant to the [`domain`](https://developer.apple.com/documentation/foundation/nserror/domain) of an [`NSError`](https://developer.apple.com/documentation/foundation/nserror) encountered when calling methods on [`NERelayManager`](https://developer.apple.com/documentation/networkextension/nerelaymanager). The [`NERelayManagerError`](https://developer.apple.com/documentation/networkextension/nerelaymanagererror) enumeration defines possible [`code`](https://developer.apple.com/documentation/foundation/nserror/code) values for these errors.
    ///
    ///
    pub static NERelayErrorDomain: &'static NSString;
}

/// NERelay Manager error codes detected by the client while trying to use this relay
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NERelayManagerClientError(pub NSInteger);
impl NERelayManagerClientError {
    #[doc(alias = "NERelayManagerClientErrorNone")]
    pub const None: Self = Self(1);
    #[doc(alias = "NERelayManagerClientErrorDNSFailed")]
    pub const DNSFailed: Self = Self(2);
    #[doc(alias = "NERelayManagerClientErrorServerUnreachable")]
    pub const ServerUnreachable: Self = Self(3);
    #[doc(alias = "NERelayManagerClientErrorServerDisconnected")]
    pub const ServerDisconnected: Self = Self(4);
    #[doc(alias = "NERelayManagerClientErrorCertificateMissing")]
    pub const CertificateMissing: Self = Self(5);
    #[doc(alias = "NERelayManagerClientErrorCertificateInvalid")]
    pub const CertificateInvalid: Self = Self(6);
    #[doc(alias = "NERelayManagerClientErrorCertificateExpired")]
    pub const CertificateExpired: Self = Self(7);
    #[doc(alias = "NERelayManagerClientErrorServerCertificateInvalid")]
    pub const ServerCertificateInvalid: Self = Self(8);
    #[doc(alias = "NERelayManagerClientErrorServerCertificateExpired")]
    pub const ServerCertificateExpired: Self = Self(9);
    #[doc(alias = "NERelayManagerClientErrorOther")]
    pub const Other: Self = Self(10);
}

unsafe impl Encode for NERelayManagerClientError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NERelayManagerClientError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    pub static NERelayClientErrorDomain: &'static NSString;
}

extern "C" {
    pub static NERelayConfigurationDidChangeNotification: &'static NSString;
}

extern_class!(
    /// An object you use to create and manage a network relay configuration.
    ///
    /// ## Overview
    ///
    /// When your app starts up, access the shared instance of the relay manager, and load existing settings from the preferences using [`loadFromPreferencesWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nerelaymanager/loadfrompreferences(completionhandler:)). You can define your relay server configuration, and persist it by calling [`saveToPreferencesWithCompletionHandler:`](https://developer.apple.com/documentation/networkextension/nerelaymanager/savetopreferences(completionhandler:)).
    ///
    ///
    /// The NERelayManager class declares the programmatic interface for an object that manages relay configurations.
    ///
    /// NERelayManager declares methods and properties for configuring and controlling relay settings on the system.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NERelayManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NERelayManager {}
);

impl NERelayManager {
    extern_methods!(
        /// Returns: The singleton NERelayManager object for the calling process.
        #[unsafe(method(sharedManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedManager() -> Retained<NERelayManager>;

        #[cfg(feature = "block2")]
        /// This function loads the current relay configuration from the caller's relay preferences.
        ///
        /// Parameter `completionHandler`: A block that will be called when the load operation is completed. The NSError passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function removes the relay configuration from the caller's relay preferences. If the relay is enabled, the relay becomes disabled.
        ///
        /// Parameter `completionHandler`: A block that will be called when the remove operation is completed. The NSError passed to this block will be nil if the remove operation succeeded, non-nil otherwise.
        #[unsafe(method(removeFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function saves the relay configuration in the caller's relay preferences. If the relay are enabled, they will become active.
        ///
        /// Parameter `completionHandler`: A block that will be called when the save operation is completed. The NSError passed to this block will be nil if the save operation succeeded, non-nil otherwise.
        #[unsafe(method(saveToPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveToPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This function will get errors that the client detected while using this relay configuration within the specified time period.  Errors will be from the NERelayClientErrorDomain and the NERelayManagerClientErrorNone value will be set for successful connections.
        ///
        /// Parameter `seconds`: A NSTimeInterval that specifies how many seconds to report errors for.  The maximum supported value is 24 hours and any larger values will be automatically reduced to 24 hours.
        ///
        /// Parameter `completionHandler`: A block that will be called when once the errors have been collected. The NSArray will contain a list of NERelayManagerClientError values detected within the last number of seconds as specified by the "seconds" parameter.  The values will be ordered from the error most recently detected to the oldest.  The error value of NERelayManagerClientErrorNone indicates the last successful use of the relay without error.  The NSArray will be empty if there are no values detected within the specified time period or nil if there was a problem in retrieving the errors.
        #[unsafe(method(getLastClientErrors:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLastClientErrors_completionHandler(
            &self,
            seconds: NSTimeInterval,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSArray<NSError>)>,
        );

        /// A string containing a description of the relay.
        #[unsafe(method(localizedDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedDescription(&self) -> Option<Retained<NSString>>;

        /// Setter for [`localizedDescription`][Self::localizedDescription].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedDescription(&self, localized_description: Option<&NSString>);

        /// Toggles the enabled status of the relay.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);

        /// Determines if the user will have the ability to enable and disable the relay
        #[unsafe(method(isUIToggleEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isUIToggleEnabled(&self) -> bool;

        /// Setter for [`isUIToggleEnabled`][Self::isUIToggleEnabled].
        #[unsafe(method(setUIToggleEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUIToggleEnabled(&self, ui_toggle_enabled: bool);

        /// Determines if DNS queries that fail over relay can fallback to default DNS
        #[unsafe(method(isDNSFailoverAllowed))]
        #[unsafe(method_family = none)]
        pub unsafe fn isDNSFailoverAllowed(&self) -> bool;

        /// Setter for [`isDNSFailoverAllowed`][Self::isDNSFailoverAllowed].
        #[unsafe(method(setAllowDNSFailover:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowDNSFailover(&self, allow_dns_failover: bool);

        /// An array of relay configurations describing one or more relay hops.
        #[unsafe(method(relays))]
        #[unsafe(method_family = none)]
        pub unsafe fn relays(&self) -> Option<Retained<NSArray<NERelay>>>;

        /// Setter for [`relays`][Self::relays].
        #[unsafe(method(setRelays:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRelays(&self, relays: Option<&NSArray<NERelay>>);

        /// An array of strings containing domain names. If this property is non-nil, the relay will be used to access hosts within the specified domains. If this and the match FQDNs property is nil, the relay will be used for all domains.
        #[unsafe(method(matchDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchDomains(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`matchDomains`][Self::matchDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMatchDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchDomains(&self, match_domains: Option<&NSArray<NSString>>);

        /// An array of strings containing Fully Qualified Domain Names (FQDNs). If this property is non-nil, the relay will be used to access the specified hosts.  If this and the matchDomains property is nil, the relay will be used for all domains.
        #[unsafe(method(matchFQDNs))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchFQDNs(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`matchFQDNs`][Self::matchFQDNs].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMatchFQDNs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchFQDNs(&self, match_fqd_ns: Option<&NSArray<NSString>>);

        /// An array of strings containing domain names. If the destination host name of a connection shares a suffix with one of these strings then the relay will not be used.
        #[unsafe(method(excludedDomains))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludedDomains(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`excludedDomains`][Self::excludedDomains].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExcludedDomains:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludedDomains(&self, excluded_domains: Option<&NSArray<NSString>>);

        /// An array of strings containing Fully Qualified Domain Names (FQDNs). If the destination host matches one of these strings then the relay will not be used.  An excluded FQDN takes priority over the matchDomain property.  This means the relay will not be used if the hostname matches an FQDN in this array even if the matchDomains contains a domain that would have been considered a match.
        #[unsafe(method(excludedFQDNs))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludedFQDNs(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`excludedFQDNs`][Self::excludedFQDNs].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExcludedFQDNs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludedFQDNs(&self, excluded_fqd_ns: Option<&NSArray<NSString>>);

        /// An array of NEOnDemandRule objects. If nil, the associated relay will always apply. If non-nil, the array describes the networks on which the relay should be used or not.
        #[unsafe(method(onDemandRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn onDemandRules(&self) -> Option<Retained<NSArray<NEOnDemandRule>>>;

        /// Setter for [`onDemandRules`][Self::onDemandRules].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setOnDemandRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOnDemandRules(&self, on_demand_rules: Option<&NSArray<NEOnDemandRule>>);

        #[cfg(feature = "block2")]
        /// This function asynchronously reads all of the NERelay configurations created by the calling app that have previously been saved to disk and returns them as NERelayManager objects.
        ///
        /// Parameter `completionHandler`: A block that takes an array NERelayManager objects. The array passed to the block may be empty if no NERelay configurations were successfully read from the disk.  The NSError passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadAllManagersFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadAllManagersFromPreferencesWithCompletionHandler(
            completion_handler: &block2::DynBlock<
                dyn Fn(NonNull<NSArray<NERelayManager>>, *mut NSError),
            >,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NERelayManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object that configures and controls transparent proxies.
    /// The NETransparentProxyManager class declares the programmatic interface for an object that is used to configure and control transparent proxies provided by NEAppProxyProviders.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEVPNManager, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NETransparentProxyManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NETransparentProxyManager {}
);

impl NETransparentProxyManager {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This function asynchronously reads all of the transparent proxy configurations associated with the calling app that have previously been saved to disk and returns them as NETransparentProxyManager objects.
        ///
        /// Parameter `completionHandler`: A block that takes an array NETransparentProxyManager objects. The array passed to the block may be empty if no transparent proxy configurations were successfully read from the disk.  The NSError passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadAllFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadAllFromPreferencesWithCompletionHandler(
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<NETransparentProxyManager>, *mut NSError),
            >,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NETransparentProxyManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A specification of what traffic to route through a transparent proxy.
    ///
    /// ## Overview
    ///
    /// A proxy network settings object contains two properties: an array of rules to include traffic ([`includedNetworkRules`](https://developer.apple.com/documentation/networkextension/netransparentproxynetworksettings/includednetworkrules)) and an array of rules to exclude traffic ([`excludedNetworkRules`](https://developer.apple.com/documentation/networkextension/netransparentproxynetworksettings/excludednetworkrules)). The exclusion rules take prirority. Therefore, if a given flow matches any of the [`excludedNetworkRules`](https://developer.apple.com/documentation/networkextension/netransparentproxynetworksettings/excludednetworkrules), evaluation ends and the flow doesn’t route to the proxy. If there’s no match, then evaluation continues and attempts to match the flow against the [`includedNetworkRules`](https://developer.apple.com/documentation/networkextension/netransparentproxynetworksettings/includednetworkrules).
    ///
    ///
    /// The NETransparentProxyNetworkSettings class declares the programmatic interface for an object that contains network settings.
    ///
    /// NETransparentProxyNetworkSettings is used by NEAppProxyProviders to communicate the desired network settings for the proxy to the framework. The framework takes care of applying the contained settings to the system.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NETunnelNetworkSettings, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NETransparentProxyNetworkSettings;
);

extern_conformance!(
    unsafe impl NSCoding for NETransparentProxyNetworkSettings {}
);

extern_conformance!(
    unsafe impl NSCopying for NETransparentProxyNetworkSettings {}
);

unsafe impl CopyingHelper for NETransparentProxyNetworkSettings {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NETransparentProxyNetworkSettings {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NETransparentProxyNetworkSettings {}
);

impl NETransparentProxyNetworkSettings {
    extern_methods!(
        /// An array of NENetworkRule objects that collectively specify the traffic that will be routed through the transparent proxy. The following restrictions
        /// apply to each NENetworkRule in this list:
        /// Restrictions for rules with an address endpoint:
        /// If the port string of the endpoint is "0" or is the empty string, then the address of the endpoint must be a non-wildcard address (i.e. "0.0.0.0" or "::").
        /// If the address is a wildcard address (i.e. "0.0.0.0" or "::"), then the port string of the endpoint must be non-empty and must not be "0".
        /// A port string of "53" is not allowed. Destination Domain-based rules must be used to match DNS traffic.
        /// The matchLocalNetwork property must be nil.
        /// The matchDirection property must be NETrafficDirectionOutbound.
        #[unsafe(method(includedNetworkRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn includedNetworkRules(&self) -> Option<Retained<NSArray<NENetworkRule>>>;

        /// Setter for [`includedNetworkRules`][Self::includedNetworkRules].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIncludedNetworkRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIncludedNetworkRules(
            &self,
            included_network_rules: Option<&NSArray<NENetworkRule>>,
        );

        /// An array of NENetworkRule objects that collectively specify the traffic that will not be routed through the transparent proxy. The following restrictions
        /// apply to each NENetworkRule in this list:
        /// Restrictions for rules with an address endpoint:
        /// If the port string of the endpoint is "0" or is the empty string, then the address of the endpoint must be a non-wildcard address (i.e. "0.0.0.0" or "::").
        /// If the address is a wildcard address (i.e. "0.0.0.0" or "::"), then the port string of the endpoint must be non-empty and must not be "0".
        /// A port string of "53" is not allowed. Destination Domain-based rules must be used to match DNS traffic.
        /// The matchLocalNetwork property must be nil.
        /// The matchDirection property must be NETrafficDirectionOutbound.
        #[unsafe(method(excludedNetworkRules))]
        #[unsafe(method_family = none)]
        pub unsafe fn excludedNetworkRules(&self) -> Option<Retained<NSArray<NENetworkRule>>>;

        /// Setter for [`excludedNetworkRules`][Self::excludedNetworkRules].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setExcludedNetworkRules:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExcludedNetworkRules(
            &self,
            excluded_network_rules: Option<&NSArray<NENetworkRule>>,
        );
    );
}

/// Methods declared on superclass `NETunnelNetworkSettings`.
impl NETransparentProxyNetworkSettings {
    extern_methods!(
        /// This function initializes a newly-allocated NETunnelNetworkSettings object with a given tunnel remote address.
        ///
        /// Parameter `address`: The address of the remote endpoint that is providing the tunnel service.
        #[unsafe(method(initWithTunnelRemoteAddress:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTunnelRemoteAddress(
            this: Allocated<Self>,
            address: &NSString,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NETransparentProxyNetworkSettings {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object that implements the client side of a custom transparent network proxy solution.
    ///
    /// ## Overview
    ///
    /// The [`NETransparentProxyProvider`](https://developer.apple.com/documentation/networkextension/netransparentproxyprovider) class has the following behavior differences from its superclass [`NEAppProxyProvider`](https://developer.apple.com/documentation/networkextension/neappproxyprovider):
    ///
    /// - Returning `NO` from [`handleNewFlow:`](https://developer.apple.com/documentation/networkextension/neappproxyprovider/handlenewflow(_:)) and [`handleNewUDPFlow:initialRemoteEndpoint:`](https://developer.apple.com/documentation/networkextension/neappproxyprovider/handlenewudpflow(_:initialremoteendpoint:)) causes the flow to proceed to communicate directly with the flow’s ultimate destination, instead of closing the flow with a “Connection Refused” error.
    ///
    /// - This provider ignores [`NEDNSSettings`](https://developer.apple.com/documentation/networkextension/nednssettings) and [`NEProxySettings`](https://developer.apple.com/documentation/networkextension/neproxysettings) specified within [`NETransparentProxyNetworkSettings`](https://developer.apple.com/documentation/networkextension/netransparentproxynetworksettings). Flows that match the [`includedNetworkRules`](https://developer.apple.com/documentation/networkextension/netransparentproxynetworksettings/includednetworkrules) within [`NETransparentProxyNetworkSettings`](https://developer.apple.com/documentation/networkextension/netransparentproxynetworksettings) use the same DNS and proxy settings that other flows on the system currently use.
    ///
    /// - Flows that are created using a “connect by name” API (such as [`Network`](https://developer.apple.com/documentation/network) framework or [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession)) that match the [`includedNetworkRules`](https://developer.apple.com/documentation/networkextension/netransparentproxynetworksettings/includednetworkrules) don’t bypass DNS resolution.
    ///
    ///
    /// The NETransparentProxyProvider class declares the programmatic interface for an object that implements the client side of a custom transparent network proxy solution.
    /// The NETransparentProxyProvider class has the following behavior differences from its super class NEAppProxyProvider:
    /// - Returning NO from handleNewFlow: and handleNewUDPFlow:initialRemoteEndpoint: causes the flow to proceed to communicate directly with the flow's ultimate destination, instead of closing the flow with a "Connection Refused" error.
    /// - NEDNSSettings and NEProxySettings specified within NETransparentProxyNetworkSettings are ignored. Flows that match the includedNetworkRules within NETransparentProxyNetworkSettings will use the same DNS and proxy settings that other flows on the system are currently using.
    /// - Flows that are created using a "connect by name" API (such as Network.framework or NSURLSession) that match the includedNetworkRules will not bypass DNS resolution.
    ///
    /// NETransparentProxyProvider is part of NetworkExtension.framework
    #[unsafe(super(NEAppProxyProvider, NETunnelProvider, NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NETransparentProxyProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NETransparentProxyProvider {}
);

impl NETransparentProxyProvider {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NETransparentProxyProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The possible states of a VPN connection.
///
/// ## Overview
///
/// After the VPN transitions from the [`NEVPNStatusDisconnected`](https://developer.apple.com/documentation/networkextension/nevpnstatus/disconnected) to the [`NEVPNStatusDisconnecting`](https://developer.apple.com/documentation/networkextension/nevpnstatus/disconnecting) state, the system doesn’t close TCP connections, but ignores packets to and from established network connections. When the VPN transitions to another state — for example, from a Wi-Fi to a cellular network — the system ignores network traffic and the VPN client typically reconnects to the VPN server.
///
///
/// VPN status codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEVPNStatus(pub NSInteger);
impl NEVPNStatus {
    /// The associated VPN configuration doesn’t exist in the Network Extension preferences or isn’t enabled.
    #[doc(alias = "NEVPNStatusInvalid")]
    pub const Invalid: Self = Self(0);
    /// The VPN is disconnected.
    #[doc(alias = "NEVPNStatusDisconnected")]
    pub const Disconnected: Self = Self(1);
    /// The VPN is in the process of connecting.
    #[doc(alias = "NEVPNStatusConnecting")]
    pub const Connecting: Self = Self(2);
    /// The VPN is connected.
    #[doc(alias = "NEVPNStatusConnected")]
    pub const Connected: Self = Self(3);
    /// The VPN is in the process of reconnecting.
    #[doc(alias = "NEVPNStatusReasserting")]
    pub const Reasserting: Self = Self(4);
    /// The VPN is in the process of disconnecting.
    #[doc(alias = "NEVPNStatusDisconnecting")]
    pub const Disconnecting: Self = Self(5);
}

unsafe impl Encode for NEVPNStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// Posted when the status of the VPN connection changes.
    pub static NEVPNStatusDidChangeNotification: &'static NSString;
}

extern "C" {
    pub static NEVPNConnectionStartOptionUsername: &'static NSString;
}

extern "C" {
    pub static NEVPNConnectionStartOptionPassword: &'static NSString;
}

/// Error codes specific to VPN connections.
/// VPN error codes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEVPNConnectionError(pub NSInteger);
impl NEVPNConnectionError {
    /// An error code that indicates the system slept for an extended period of time, causing the VPN connection to terminate.
    #[doc(alias = "NEVPNConnectionErrorOverslept")]
    pub const Overslept: Self = Self(1);
    /// An error code that indicates the VPN connection failed because the system isn’t connected to a network.
    #[doc(alias = "NEVPNConnectionErrorNoNetworkAvailable")]
    pub const NoNetworkAvailable: Self = Self(2);
    /// An error code that indicates network conditions changed such that the VPN connection needed to terminate.
    /// way that the VPN connection could not be maintained.
    #[doc(alias = "NEVPNConnectionErrorUnrecoverableNetworkChange")]
    pub const UnrecoverableNetworkChange: Self = Self(3);
    /// An error code that indicates the VPN connection failed because the configuration is invalid.
    #[doc(alias = "NEVPNConnectionErrorConfigurationFailed")]
    pub const ConfigurationFailed: Self = Self(4);
    /// An error code that indicates the VPN connection failed because the system couldn’t determine the VPN server address.
    #[doc(alias = "NEVPNConnectionErrorServerAddressResolutionFailed")]
    pub const ServerAddressResolutionFailed: Self = Self(5);
    /// An error code that indicates the VPN connection failed because the VPN server isn’t responding.
    #[doc(alias = "NEVPNConnectionErrorServerNotResponding")]
    pub const ServerNotResponding: Self = Self(6);
    /// An error code that indicates the VPN connection failed because the VPN server has stopped responding.
    #[doc(alias = "NEVPNConnectionErrorServerDead")]
    pub const ServerDead: Self = Self(7);
    /// An error code that indicates the VPN connection failed because the VPN server rejected the user credentials.
    #[doc(alias = "NEVPNConnectionErrorAuthenticationFailed")]
    pub const AuthenticationFailed: Self = Self(8);
    /// An error code that indicates the client certfiicate is invalid.
    #[doc(alias = "NEVPNConnectionErrorClientCertificateInvalid")]
    pub const ClientCertificateInvalid: Self = Self(9);
    /// An error code that indicates the client certfiicate won’t be valid until some time in the future.
    #[doc(alias = "NEVPNConnectionErrorClientCertificateNotYetValid")]
    pub const ClientCertificateNotYetValid: Self = Self(10);
    /// An error code that indicates the client certfiicate’s validity period has passed.
    #[doc(alias = "NEVPNConnectionErrorClientCertificateExpired")]
    pub const ClientCertificateExpired: Self = Self(11);
    /// An error code that indicates the VPN plugin failed unexpectedly.
    #[doc(alias = "NEVPNConnectionErrorPluginFailed")]
    pub const PluginFailed: Self = Self(12);
    /// An error code that indicates the VPN connection failed because the system couldn’t find a configuration.
    #[doc(alias = "NEVPNConnectionErrorConfigurationNotFound")]
    pub const ConfigurationNotFound: Self = Self(13);
    /// An error code that indicates the VPN plugin isn’t available or needs an update.
    #[doc(alias = "NEVPNConnectionErrorPluginDisabled")]
    pub const PluginDisabled: Self = Self(14);
    /// An error code that indicates the VPN connection failed because the negotiation failed.
    #[doc(alias = "NEVPNConnectionErrorNegotiationFailed")]
    pub const NegotiationFailed: Self = Self(15);
    /// An error code that indicates the VPN connection failed because the VPN server terminated the connection.
    #[doc(alias = "NEVPNConnectionErrorServerDisconnected")]
    pub const ServerDisconnected: Self = Self(16);
    /// An error code that indicates the server certfiicate is invalid.
    #[doc(alias = "NEVPNConnectionErrorServerCertificateInvalid")]
    pub const ServerCertificateInvalid: Self = Self(17);
    /// An error code that indicates the server certfiicate won’t be valid until some time in the future.
    #[doc(alias = "NEVPNConnectionErrorServerCertificateNotYetValid")]
    pub const ServerCertificateNotYetValid: Self = Self(18);
    /// An error code that indicates the server certfiicate’s validity period has passed.
    #[doc(alias = "NEVPNConnectionErrorServerCertificateExpired")]
    pub const ServerCertificateExpired: Self = Self(19);
}

unsafe impl Encode for NEVPNConnectionError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNConnectionError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The domain for errors resulting from VPN connection calls.
    ///
    /// ## Discussion
    ///
    /// Match this constant to the [`domain`](https://developer.apple.com/documentation/foundation/nserror/domain) of an [`NSError`](https://developer.apple.com/documentation/foundation/nserror) encountered when calling methods on [`NEVPNConnection`](https://developer.apple.com/documentation/networkextension/nevpnconnection). The [`NEDNSSettingsManagerError`](https://developer.apple.com/documentation/networkextension/nednssettingsmanagererror) enumeration defines possible [`code`](https://developer.apple.com/documentation/foundation/nserror/code) values for these errors.
    ///
    ///
    pub static NEVPNConnectionErrorDomain: &'static NSString;
}

extern_class!(
    /// An object to start and stop a Personal VPN connection and get its status.
    ///
    /// ## Overview
    ///
    /// [`NEVPNConnection`](https://developer.apple.com/documentation/networkextension/nevpnconnection) objects are not instantiated directly. Instead, each `NEVPNManager` object has an associated [`NEVPNConnection`](https://developer.apple.com/documentation/networkextension/nevpnconnection) object as a read-only property.
    ///
    /// The [`NEVPNConnection`](https://developer.apple.com/documentation/networkextension/nevpnconnection) class provides methods for starting and stopping the VPN programmatically. The other way that the VPN can be started and stopped is through VPN On Demand. See the `onDemandRules` property in [`NEVPNManager`](https://developer.apple.com/documentation/networkextension/nevpnmanager) and [`NEOnDemandRule`](https://developer.apple.com/documentation/networkextension/neondemandrule).
    ///
    /// Instances of this class are thread safe.
    ///
    ///
    /// The NEVPNConnection class declares the programmatic interface for an object that manages VPN connections.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEVPNConnection;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEVPNConnection {}
);

impl NEVPNConnection {
    extern_methods!(
        /// This function is used to start the VPN tunnel using the current VPN configuration. The VPN tunnel connection process is started and this function returns immediately.
        ///
        /// Parameter `error`: If the VPN tunnel was started successfully, this parameter is set to nil. Otherwise this parameter is set to the error that occurred. Possible errors include:
        /// 1. NEVPNErrorConfigurationInvalid
        /// 2. NEVPNErrorConfigurationDisabled
        ///
        /// Returns: YES if the VPN tunnel was started successfully, NO if an error occurred.
        #[unsafe(method(startVPNTunnelAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn startVPNTunnelAndReturnError(&self) -> Result<(), Retained<NSError>>;

        /// This function is used to start the VPN tunnel using the current VPN configuration. The VPN tunnel connection process is started and this function returns immediately.
        ///
        /// Parameter `options`: A dictionary that will be passed to the tunnel provider during the process of starting the tunnel.
        /// If not nil, 'options' is an NSDictionary may contain the following keys
        /// NEVPNConnectionStartOptionUsername
        /// NEVPNConnectionStartOptionPassword
        ///
        /// Parameter `error`: If the VPN tunnel was started successfully, this parameter is set to nil. Otherwise this parameter is set to the error that occurred. Possible errors include:
        /// 1. NEVPNErrorConfigurationInvalid
        /// 2. NEVPNErrorConfigurationDisabled
        ///
        /// Returns: YES if the VPN tunnel was started successfully, NO if an error occurred.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(startVPNTunnelWithOptions:andReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn startVPNTunnelWithOptions_andReturnError(
            &self,
            options: Option<&NSDictionary<NSString, NSObject>>,
        ) -> Result<(), Retained<NSError>>;

        /// This function is used to stop the VPN tunnel. The VPN tunnel disconnect process is started and this function returns immediately.
        #[unsafe(method(stopVPNTunnel))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopVPNTunnel(&self);

        #[cfg(feature = "block2")]
        /// Retrive the most recent error that caused the VPN to disconnect. If the error was generated by the VPN system (including the IPsec client) then the error will be in the NEVPNConnectionErrorDomain error domain. If the error was generated by a tunnel provider app extension then the error will be the NSError that the provider passed when disconnecting the tunnel.
        ///
        /// Parameter `handler`: A block which takes an optional NSError that will be called when the error is obtained.
        #[unsafe(method(fetchLastDisconnectErrorWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchLastDisconnectErrorWithCompletionHandler(
            &self,
            handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// The current status of the VPN.
        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        pub unsafe fn status(&self) -> NEVPNStatus;

        /// The date and time when the connection status changed to NEVPNStatusConnected. This property is nil if the connection is not fully established.
        #[unsafe(method(connectedDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectedDate(&self) -> Option<Retained<NSDate>>;

        /// The NEVPNManager associated with this NEVPNConnection.
        #[unsafe(method(manager))]
        #[unsafe(method_family = none)]
        pub unsafe fn manager(&self) -> Retained<NEVPNManager>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEVPNConnection {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object to start and stop a tunnel connection and get its status.
    ///
    /// ## Overview
    ///
    /// `NETunnelProviderSession` objects control network tunnel connections provided by Tunnel Provider extensions.
    ///
    /// `NETunnelProviderSession` objects are not instantiated directly. Instead, each [`NETunnelProviderManager`](https://developer.apple.com/documentation/networkextension/netunnelprovidermanager) object has an associated `NETunnelProviderSession` as a read-only property.
    ///
    ///
    /// This file declares the NETunnelProviderSession API. The NETunnelProviderSession API is used to control network tunnel services provided by NETunnelProvider implementations.
    ///
    /// This API is part of NetworkExtension.framework.
    #[unsafe(super(NEVPNConnection, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NETunnelProviderSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NETunnelProviderSession {}
);

impl NETunnelProviderSession {
    extern_methods!(
        /// This function is used to start the tunnel using the configuration associated with this connection object. The tunnel connection process is started and this function returns immediately.
        ///
        /// Parameter `options`: A dictionary that will be passed as-is to the tunnel provider during the process of starting the tunnel.
        ///
        /// Parameter `error`: If the tunnel was started successfully, this parameter is set to nil. Otherwise this parameter is set to the error that occurred. Possible errors include:
        /// 1. NEVPNErrorConfigurationInvalid
        /// 2. NEVPNErrorConfigurationDisabled
        ///
        /// Returns: YES if the tunnel was started successfully, NO if an error occurred.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(startTunnelWithOptions:andReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn startTunnelWithOptions_andReturnError(
            &self,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Result<(), Retained<NSError>>;

        /// This function is used to stop the tunnel. The tunnel disconnect process is started and this function returns immediately.
        #[unsafe(method(stopTunnel))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopTunnel(&self);

        #[cfg(feature = "block2")]
        /// This function sends a message to the NETunnelProvider and provides a way to receive a response.
        ///
        /// Parameter `messageData`: An NSData object containing the message to be sent.
        ///
        /// Parameter `error`: If the message was sent successfully, this parameter is set to nil. Otherwise this parameter is set to the error that occurred. Possible errors include:
        /// 1. NEVPNErrorConfigurationInvalid
        /// 2. NEVPNErrorConfigurationDisabled
        ///
        /// Parameter `responseHandler`: A block that handles the response. Can be set to nil if no response is expected.
        ///
        /// Returns: YES if the message was sent successfully, NO if an error occurred.
        #[unsafe(method(sendProviderMessage:returnError:responseHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendProviderMessage_returnError_responseHandler(
            &self,
            message_data: &NSData,
            error: Option<&mut Option<Retained<NSError>>>,
            response_handler: Option<&block2::DynBlock<dyn Fn(*mut NSData)>>,
        ) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NETunnelProviderSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Configuration parameters for a VPN tunnel.
    ///
    /// ## Overview
    ///
    /// `NETunnelProviderProtocol` objects are used to specify configuration parameters for Tunnel Provider extensions.
    ///
    ///
    /// The NETunnelProviderProtocol class declares the programmatic interface for an object that contains NETunnelProvider-specific configuration settings.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NEVPNProtocol, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NETunnelProviderProtocol;
);

extern_conformance!(
    unsafe impl NSCoding for NETunnelProviderProtocol {}
);

extern_conformance!(
    unsafe impl NSCopying for NETunnelProviderProtocol {}
);

unsafe impl CopyingHelper for NETunnelProviderProtocol {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NETunnelProviderProtocol {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NETunnelProviderProtocol {}
);

impl NETunnelProviderProtocol {
    extern_methods!(
        /// A dictionary containing NETunnelProvider vendor-specific configuration parameters. This dictionary is passed as-is to NETunnelProviders when a tunnel is started.
        #[unsafe(method(providerConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn providerConfiguration(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        /// Setter for [`providerConfiguration`][Self::providerConfiguration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `provider_configuration` generic should be of the correct type.
        #[unsafe(method(setProviderConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProviderConfiguration(
            &self,
            provider_configuration: Option<&NSDictionary<NSString, AnyObject>>,
        );

        /// A string containing the bundle identifier of the NETunnelProvider to be used by this configuration.
        #[unsafe(method(providerBundleIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn providerBundleIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`providerBundleIdentifier`][Self::providerBundleIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProviderBundleIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProviderBundleIdentifier(
            &self,
            provider_bundle_identifier: Option<&NSString>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NETunnelProviderProtocol {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Internet Key Exchange (IKE) authentication methods used to authenticate with the IPSec server.
/// Internet Key Exchange (IKE) authentication methods used to authenticate with the IPSec server.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEVPNIKEAuthenticationMethod(pub NSInteger);
impl NEVPNIKEAuthenticationMethod {
    /// Do not authenticate with the IPSec server. Note that extended authentication may still be performed if the [`useExtendedAuthentication`](https://developer.apple.com/documentation/networkextension/nevpnprotocolipsec/useextendedauthentication) property is set. This value is only valid for IKE version 2 (IKEv2)
    #[doc(alias = "NEVPNIKEAuthenticationMethodNone")]
    pub const None: Self = Self(0);
    /// Use a certificate and private key as the authentication credential. The certificate and private key set in the [`identityReference`](https://developer.apple.com/documentation/networkextension/nevpnprotocol/identityreference) or [`identityData`](https://developer.apple.com/documentation/networkextension/nevpnprotocol/identitydata) property will be used.
    #[doc(alias = "NEVPNIKEAuthenticationMethodCertificate")]
    pub const Certificate: Self = Self(1);
    /// Use a shared secret as the authentication credential. The shared secret set in the [`sharedSecretReference`](https://developer.apple.com/documentation/networkextension/nevpnprotocolipsec/sharedsecretreference) property will be used.
    #[doc(alias = "NEVPNIKEAuthenticationMethodSharedSecret")]
    pub const SharedSecret: Self = Self(2);
}

unsafe impl Encode for NEVPNIKEAuthenticationMethod {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNIKEAuthenticationMethod {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Settings for an IPsec VPN configuration.
    ///
    /// ## Overview
    ///
    /// To configure IKE version 2 (IKEv2), use the [`NEVPNProtocolIKEv2`](https://developer.apple.com/documentation/networkextension/nevpnprotocolikev2) subclass. Instantiating [`NEVPNProtocolIPSec`](https://developer.apple.com/documentation/networkextension/nevpnprotocolipsec) directly implies IKE version 1.
    ///
    ///
    /// The NEVPNProtocolIPSec class declares the programmatic interface of an object that manages the IPSec-specific portion of a VPN configuration.
    ///
    /// Instances of this class use IKE version 1 for key negotiation.
    #[unsafe(super(NEVPNProtocol, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEVPNProtocolIPSec;
);

extern_conformance!(
    unsafe impl NSCoding for NEVPNProtocolIPSec {}
);

extern_conformance!(
    unsafe impl NSCopying for NEVPNProtocolIPSec {}
);

unsafe impl CopyingHelper for NEVPNProtocolIPSec {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEVPNProtocolIPSec {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEVPNProtocolIPSec {}
);

impl NEVPNProtocolIPSec {
    extern_methods!(
        /// The method used to authenticate with the IPSec server. Note that if this property is set to NEVPNIKEAuthenticationMethodNone, extended authentication will still be negotiated if useExtendedAuthentication is set to YES.
        #[unsafe(method(authenticationMethod))]
        #[unsafe(method_family = none)]
        pub unsafe fn authenticationMethod(&self) -> NEVPNIKEAuthenticationMethod;

        /// Setter for [`authenticationMethod`][Self::authenticationMethod].
        #[unsafe(method(setAuthenticationMethod:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAuthenticationMethod(
            &self,
            authentication_method: NEVPNIKEAuthenticationMethod,
        );

        /// A flag indicating if extended authentication will be negotiated. This authentication is in addition to the IKE authentication used to authenticate the endpoints of the IKE session.
        /// For IKE version 1, when this flag is set X-Auth authentication will be negotiated as part of the IKE session, using the username and password properties as the credential.
        /// For IKE version 2, when this flag is set EAP authentication will be negotiated as part of the IKE session, using the username, password, and/or identity properties as the credential depending on which EAP method the server requires.
        #[unsafe(method(useExtendedAuthentication))]
        #[unsafe(method_family = none)]
        pub unsafe fn useExtendedAuthentication(&self) -> bool;

        /// Setter for [`useExtendedAuthentication`][Self::useExtendedAuthentication].
        #[unsafe(method(setUseExtendedAuthentication:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUseExtendedAuthentication(&self, use_extended_authentication: bool);

        /// A persistent reference to a keychain item of class kSecClassGenericPassword containing the IKE shared secret.
        #[unsafe(method(sharedSecretReference))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedSecretReference(&self) -> Option<Retained<NSData>>;

        /// Setter for [`sharedSecretReference`][Self::sharedSecretReference].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSharedSecretReference:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSharedSecretReference(&self, shared_secret_reference: Option<&NSData>);

        /// A string identifying the local IPSec endpoint for authentication purposes.
        #[unsafe(method(localIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn localIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`localIdentifier`][Self::localIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalIdentifier(&self, local_identifier: Option<&NSString>);

        /// A string identifying the remote IPSec endpoint for authentication purposes.
        #[unsafe(method(remoteIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`remoteIdentifier`][Self::remoteIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRemoteIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRemoteIdentifier(&self, remote_identifier: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEVPNProtocolIPSec {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// An enumeration of encryption algorithm values.
/// IKEv2 Encryption Algorithms
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEVPNIKEv2EncryptionAlgorithm(pub NSInteger);
impl NEVPNIKEv2EncryptionAlgorithm {
    /// Data Encryption Standard (DES)
    #[doc(alias = "NEVPNIKEv2EncryptionAlgorithmDES")]
    #[deprecated = "DES is not supported"]
    pub const AlgorithmDES: Self = Self(1);
    /// Triple Data Encryption Algorithm (aka 3DES)
    #[doc(alias = "NEVPNIKEv2EncryptionAlgorithm3DES")]
    #[deprecated = "3DES is not supported"]
    pub const Algorithm3DES: Self = Self(2);
    /// Advanced Encryption Standard 256-bit (AES256).
    #[doc(alias = "NEVPNIKEv2EncryptionAlgorithmAES128")]
    #[deprecated = "Use an encryption algorithm with 256-bit keys instead"]
    pub const AlgorithmAES128: Self = Self(3);
    /// Advanced Encryption Standard 256 bit (AES256).
    #[doc(alias = "NEVPNIKEv2EncryptionAlgorithmAES256")]
    pub const AlgorithmAES256: Self = Self(4);
    /// Advanced Encryption Standard 128-bit Galois/Counter Mode (AES128GCM).
    #[doc(alias = "NEVPNIKEv2EncryptionAlgorithmAES128GCM")]
    #[deprecated = "Use an encryption algorithm with 256-bit keys instead"]
    pub const AlgorithmAES128GCM: Self = Self(5);
    /// Advanced Encryption Standard 256-bit Galois/Counter Mode (AES256GCM).
    #[doc(alias = "NEVPNIKEv2EncryptionAlgorithmAES256GCM")]
    pub const AlgorithmAES256GCM: Self = Self(6);
    /// ChaCha20 and Poly1305 (ChaCha20Poly1305).
    #[doc(alias = "NEVPNIKEv2EncryptionAlgorithmChaCha20Poly1305")]
    pub const AlgorithmChaCha20Poly1305: Self = Self(7);
}

unsafe impl Encode for NEVPNIKEv2EncryptionAlgorithm {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNIKEv2EncryptionAlgorithm {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// IKEv2 Integrity Algorithms
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEVPNIKEv2IntegrityAlgorithm(pub NSInteger);
impl NEVPNIKEv2IntegrityAlgorithm {
    /// SHA-1 96-bit.
    #[doc(alias = "NEVPNIKEv2IntegrityAlgorithmSHA96")]
    #[deprecated = "SHA-1 is not supported"]
    pub const SHA96: Self = Self(1);
    /// SHA-1 160-bit.
    #[doc(alias = "NEVPNIKEv2IntegrityAlgorithmSHA160")]
    #[deprecated = "SHA-1 is not supported"]
    pub const SHA160: Self = Self(2);
    /// SHA-2 256-bit.
    #[doc(alias = "NEVPNIKEv2IntegrityAlgorithmSHA256")]
    pub const SHA256: Self = Self(3);
    /// SHA-2 384-bit.
    #[doc(alias = "NEVPNIKEv2IntegrityAlgorithmSHA384")]
    pub const SHA384: Self = Self(4);
    /// SHA-2 512-bit.
    #[doc(alias = "NEVPNIKEv2IntegrityAlgorithmSHA512")]
    pub const SHA512: Self = Self(5);
}

unsafe impl Encode for NEVPNIKEv2IntegrityAlgorithm {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNIKEv2IntegrityAlgorithm {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An enumeration of values for the frequency at which the IKEv2 client runs the dead peer detection algorithm.
/// IKEv2 Dead Peer Detection Rates
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEVPNIKEv2DeadPeerDetectionRate(pub NSInteger);
impl NEVPNIKEv2DeadPeerDetectionRate {
    /// Do not perform dead peer detection.
    #[doc(alias = "NEVPNIKEv2DeadPeerDetectionRateNone")]
    pub const None: Self = Self(0);
    /// Run dead peer detection once every 30 minutes. If the peer does not respond, retry 5 times at 1 second intervals before declaring the peer dead and terminating the session.
    #[doc(alias = "NEVPNIKEv2DeadPeerDetectionRateLow")]
    pub const Low: Self = Self(1);
    /// Run dead peer detection once every 10 minutes. If the peer does not respond, retry 5 times at 1 second intervals before declaring the peer dead and terminating the session.
    #[doc(alias = "NEVPNIKEv2DeadPeerDetectionRateMedium")]
    pub const Medium: Self = Self(2);
    /// Run dead peer detection once every 1 minute. If the peer does not respond, retry 5 times at 1 second intervals before declaring the peer dead and terminating the session.
    #[doc(alias = "NEVPNIKEv2DeadPeerDetectionRateHigh")]
    pub const High: Self = Self(3);
}

unsafe impl Encode for NEVPNIKEv2DeadPeerDetectionRate {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNIKEv2DeadPeerDetectionRate {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An enumeration of Diffie-Hellman group values.
/// IKEv2 Diffie Hellman groups
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEVPNIKEv2DiffieHellmanGroup(pub NSInteger);
impl NEVPNIKEv2DiffieHellmanGroup {
    /// A value indicating the group is not a valid Diffie-Hellman group.
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroupInvalid")]
    pub const GroupInvalid: Self = Self(0);
    /// Diffie Hellman group 1 (768-bit modular exponential [MODP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup1")]
    #[deprecated = "Diffie Hellman groups less than 14 are not supported"]
    pub const Group1: Self = Self(1);
    /// Diffie Hellman group 2 (1024-bit modular exponential [MODP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup2")]
    #[deprecated = "Diffie Hellman groups less than 14 are not supported"]
    pub const Group2: Self = Self(2);
    /// Diffie Hellman group 5 (1536-bit modular exponential [MODP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup5")]
    #[deprecated = "Diffie Hellman groups less than 14 are not supported"]
    pub const Group5: Self = Self(5);
    /// Diffie Hellman group 14 (2048-bit modular exponential [MODP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup14")]
    pub const Group14: Self = Self(14);
    /// Diffie Hellman group 15 (3072-bit modular exponential [MODP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup15")]
    pub const Group15: Self = Self(15);
    /// Diffie Hellman group 16 (4096-bit modular exponential [MODP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup16")]
    pub const Group16: Self = Self(16);
    /// Diffie Hellman group 17 (6144-bit modular exponential [MODP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup17")]
    pub const Group17: Self = Self(17);
    /// Diffie Hellman group 18 (8192-bit modular exponential [MODP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup18")]
    pub const Group18: Self = Self(18);
    /// Diffie Hellman group 19 (256-bit random elliptic curve group over GF[P] [ECP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup19")]
    pub const Group19: Self = Self(19);
    /// Diffie Hellman group 20 (384-bit random elliptic curve group over GF[P] [ECP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup20")]
    pub const Group20: Self = Self(20);
    /// Diffie Hellman group 21 (521-bit random elliptic curve group over GF[P] [ECP]).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup21")]
    pub const Group21: Self = Self(21);
    /// Diffie Hellman group 31 (Curve 25519).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup31")]
    pub const Group31: Self = Self(31);
    /// Diffie Hellman group 32 (Curve 448).
    #[doc(alias = "NEVPNIKEv2DiffieHellmanGroup32")]
    pub const Group32: Self = Self(32);
}

unsafe impl Encode for NEVPNIKEv2DiffieHellmanGroup {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNIKEv2DiffieHellmanGroup {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Quantum-secure key exchange methods you use with IKEv2 servers.
/// IKEv2 post-quantum key exchange methods
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEVPNIKEv2PostQuantumKeyExchangeMethod(pub NSInteger);
impl NEVPNIKEv2PostQuantumKeyExchangeMethod {
    /// Instructs the server not to use a quantum-secure key exchange method.
    #[doc(alias = "NEVPNIKEv2PostQuantumKeyExchangeMethodNone")]
    pub const MethodNone: Self = Self(0);
    /// Instructs the server to use the ML-KEM-768 key exchange method.
    #[doc(alias = "NEVPNIKEv2PostQuantumKeyExchangeMethod36")]
    pub const Method36: Self = Self(36);
    /// Instructs the server to use the ML-KEM-1024 key exchange method.
    #[doc(alias = "NEVPNIKEv2PostQuantumKeyExchangeMethod37")]
    pub const Method37: Self = Self(37);
}

unsafe impl Encode for NEVPNIKEv2PostQuantumKeyExchangeMethod {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNIKEv2PostQuantumKeyExchangeMethod {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An enumeration of certificate type values.
/// IKEv2 Certificate types
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEVPNIKEv2CertificateType(pub NSInteger);
impl NEVPNIKEv2CertificateType {
    /// The RSA certificate type.
    #[doc(alias = "NEVPNIKEv2CertificateTypeRSA")]
    pub const RSA: Self = Self(1);
    /// The ECDSA with p-256 curve certificate type.
    #[doc(alias = "NEVPNIKEv2CertificateTypeECDSA256")]
    pub const ECDSA256: Self = Self(2);
    /// The ECDSA with p-384 curve certificate type.
    #[doc(alias = "NEVPNIKEv2CertificateTypeECDSA384")]
    pub const ECDSA384: Self = Self(3);
    /// The ECDSA with p-521 curve certificate type.
    #[doc(alias = "NEVPNIKEv2CertificateTypeECDSA521")]
    pub const ECDSA521: Self = Self(4);
    /// The Edwards 25519 curve certificate type.
    #[doc(alias = "NEVPNIKEv2CertificateTypeEd25519")]
    pub const Ed25519: Self = Self(5);
    /// The RSA-PSS certificate type.
    #[doc(alias = "NEVPNIKEv2CertificateTypeRSAPSS")]
    pub const RSAPSS: Self = Self(6);
}

unsafe impl Encode for NEVPNIKEv2CertificateType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNIKEv2CertificateType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An enumeration of TLS Versions for use in EAP-TLS.
/// TLS Versions for use in EAP-TLS
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NEVPNIKEv2TLSVersion(pub NSInteger);
impl NEVPNIKEv2TLSVersion {
    /// A value to use the default TLS configuration.
    #[doc(alias = "NEVPNIKEv2TLSVersionDefault")]
    pub const VersionDefault: Self = Self(0);
    /// A value to use TLS version 1.0.
    #[doc(alias = "NEVPNIKEv2TLSVersion1_0")]
    pub const Version1_0: Self = Self(1);
    /// A value to use TLS version 1.1.
    #[doc(alias = "NEVPNIKEv2TLSVersion1_1")]
    pub const Version1_1: Self = Self(2);
    /// A value to use TLS version 1.2.
    #[doc(alias = "NEVPNIKEv2TLSVersion1_2")]
    pub const Version1_2: Self = Self(3);
}

unsafe impl Encode for NEVPNIKEv2TLSVersion {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEVPNIKEv2TLSVersion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Parameters for an IKEv2 Security Association.
    /// The NEVPNIKEv2SecurityAssociationParameters class declares the programmatic interface of an object that manages parameters for an IPSec Security Association
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEVPNIKEv2SecurityAssociationParameters;
);

extern_conformance!(
    unsafe impl NSCoding for NEVPNIKEv2SecurityAssociationParameters {}
);

extern_conformance!(
    unsafe impl NSCopying for NEVPNIKEv2SecurityAssociationParameters {}
);

unsafe impl CopyingHelper for NEVPNIKEv2SecurityAssociationParameters {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEVPNIKEv2SecurityAssociationParameters {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEVPNIKEv2SecurityAssociationParameters {}
);

impl NEVPNIKEv2SecurityAssociationParameters {
    extern_methods!(
        /// The algorithm used by the Security Association to encrypt and decrypt data. On macOS and iOS, the default is NEVPNIKEv2EncryptionAlgorithmAES256 starting in macOS 11 and iOS 14.
        /// Prior to that the default was NEVPNIKEv2EncryptionAlgorithm3DES. On tvOS, the default is NEVPNIKEv2EncryptionAlgorithmAES256GCM.
        #[unsafe(method(encryptionAlgorithm))]
        #[unsafe(method_family = none)]
        pub unsafe fn encryptionAlgorithm(&self) -> NEVPNIKEv2EncryptionAlgorithm;

        /// Setter for [`encryptionAlgorithm`][Self::encryptionAlgorithm].
        #[unsafe(method(setEncryptionAlgorithm:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEncryptionAlgorithm(
            &self,
            encryption_algorithm: NEVPNIKEv2EncryptionAlgorithm,
        );

        /// The algorithm used by the Security Association to verify the integrity of data.  The IKE psedo-random function algorithm will be inferred based on the integrity algorithm.
        /// Default is NEVPNIKEv2IntegrityAlgorithmSHA256 starting in macOS 11, iOS 14, and tvOS 17.  Prior to that the default was NEVPNIKEv2IntegrityAlgorithmSHA96.
        #[unsafe(method(integrityAlgorithm))]
        #[unsafe(method_family = none)]
        pub unsafe fn integrityAlgorithm(&self) -> NEVPNIKEv2IntegrityAlgorithm;

        /// Setter for [`integrityAlgorithm`][Self::integrityAlgorithm].
        #[unsafe(method(setIntegrityAlgorithm:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIntegrityAlgorithm(
            &self,
            integrity_algorithm: NEVPNIKEv2IntegrityAlgorithm,
        );

        /// The Diffie Hellman group used by the Security Association. Default is NEVPNIKEv2DiffieHellmanGroup14 starting in macOS 11, iOS 14, and tvOS 17. Prior to that the default was NEVPNIKEv2DiffieHellmanGroup2.
        #[unsafe(method(diffieHellmanGroup))]
        #[unsafe(method_family = none)]
        pub unsafe fn diffieHellmanGroup(&self) -> NEVPNIKEv2DiffieHellmanGroup;

        /// Setter for [`diffieHellmanGroup`][Self::diffieHellmanGroup].
        #[unsafe(method(setDiffieHellmanGroup:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDiffieHellmanGroup(
            &self,
            diffie_hellman_group: NEVPNIKEv2DiffieHellmanGroup,
        );

        /// The post-quantum key exchange method(s) used by the Security Association, if any. Values are taken from NEVPNIKEv2PostQuantumKeyExchangeMethod. Up to 7 methods may be specified, mapping to ADDKE1 - ADDKE7 from RFC 9370.
        #[unsafe(method(postQuantumKeyExchangeMethods))]
        #[unsafe(method_family = none)]
        pub unsafe fn postQuantumKeyExchangeMethods(&self) -> Retained<NSArray<NSNumber>>;

        /// Setter for [`postQuantumKeyExchangeMethods`][Self::postQuantumKeyExchangeMethods].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPostQuantumKeyExchangeMethods:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPostQuantumKeyExchangeMethods(
            &self,
            post_quantum_key_exchange_methods: &NSArray<NSNumber>,
        );

        /// The life time of the Security Association, in minutes. Default is 60 for IKE Security Associations, and 30 for Child Security Associations. Before the lifetime is reached, IKEv2 will attempt to rekey the Security Association to maintain the connection.
        #[unsafe(method(lifetimeMinutes))]
        #[unsafe(method_family = none)]
        pub unsafe fn lifetimeMinutes(&self) -> i32;

        /// Setter for [`lifetimeMinutes`][Self::lifetimeMinutes].
        #[unsafe(method(setLifetimeMinutes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLifetimeMinutes(&self, lifetime_minutes: i32);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEVPNIKEv2SecurityAssociationParameters {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A class that manages parameters of a post-quantum pre-shared key (PPK).
    ///
    /// ## Discussion
    ///
    /// Instances of this class are thread safe. The class conforms to RFC 8784.
    ///
    ///
    /// The NEVPNIKEv2PPKConfiguration class declares the programmatic interface of an object that manages parameters for a Post-quantum Pre-shared Key (PPK)
    ///
    /// Instances of this class conform to RFC 8784.
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEVPNIKEv2PPKConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for NEVPNIKEv2PPKConfiguration {}
);

unsafe impl CopyingHelper for NEVPNIKEv2PPKConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEVPNIKEv2PPKConfiguration {}
);

impl NEVPNIKEv2PPKConfiguration {
    extern_methods!(
        /// Initialize a newly-allocated NEVPNIKEv2PPKConfiguration object.
        ///
        /// Parameter `identifier`: The identifier for the PPK.
        ///
        /// Parameter `keychainReference`: A persistent reference to a keychain item of class kSecClassGenericPassword containing the PPK.
        #[unsafe(method(initWithIdentifier:keychainReference:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier_keychainReference(
            this: Allocated<Self>,
            identifier: &NSString,
            keychain_reference: &NSData,
        ) -> Retained<Self>;

        /// The identifer for the PPK.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSString>;

        /// A persistent reference to a keychain item of class kSecClassGenericPassword containing the PPK.
        #[unsafe(method(keychainReference))]
        #[unsafe(method_family = none)]
        pub unsafe fn keychainReference(&self) -> Retained<NSData>;

        /// Boolean indicating whether use of the PPK is mandatory or not. Default is YES.
        #[unsafe(method(isMandatory))]
        #[unsafe(method_family = none)]
        pub unsafe fn isMandatory(&self) -> bool;

        /// Setter for [`isMandatory`][Self::isMandatory].
        #[unsafe(method(setIsMandatory:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIsMandatory(&self, is_mandatory: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEVPNIKEv2PPKConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Settings for an IKEv2 VPN configuration.
    ///
    /// ## Overview
    ///
    /// Instances of this class are thread safe.
    ///
    ///
    /// The NEVPNProtocolIKEv2 class declares the programmatic interface of an object that manages the IKEv2-specific portion of a VPN configuration.
    ///
    /// Instances of this class use IKE version 2 for key negotiation.
    /// Instances of this class are thread safe.
    #[unsafe(super(NEVPNProtocolIPSec, NEVPNProtocol, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEVPNProtocolIKEv2;
);

extern_conformance!(
    unsafe impl NSCoding for NEVPNProtocolIKEv2 {}
);

extern_conformance!(
    unsafe impl NSCopying for NEVPNProtocolIKEv2 {}
);

unsafe impl CopyingHelper for NEVPNProtocolIKEv2 {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEVPNProtocolIKEv2 {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEVPNProtocolIKEv2 {}
);

impl NEVPNProtocolIKEv2 {
    extern_methods!(
        /// How frequently the IKEv2 client will run the dead peer detection algorithm.  Default is NEVPNIKEv2DeadPeerDetectionRateMedium.
        #[unsafe(method(deadPeerDetectionRate))]
        #[unsafe(method_family = none)]
        pub unsafe fn deadPeerDetectionRate(&self) -> NEVPNIKEv2DeadPeerDetectionRate;

        /// Setter for [`deadPeerDetectionRate`][Self::deadPeerDetectionRate].
        #[unsafe(method(setDeadPeerDetectionRate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDeadPeerDetectionRate(
            &self,
            dead_peer_detection_rate: NEVPNIKEv2DeadPeerDetectionRate,
        );

        /// A string containing the Subject Common Name field of the Certificate Authority certificate that issued the IKEv2 server's certificate.
        #[unsafe(method(serverCertificateIssuerCommonName))]
        #[unsafe(method_family = none)]
        pub unsafe fn serverCertificateIssuerCommonName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`serverCertificateIssuerCommonName`][Self::serverCertificateIssuerCommonName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setServerCertificateIssuerCommonName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServerCertificateIssuerCommonName(
            &self,
            server_certificate_issuer_common_name: Option<&NSString>,
        );

        /// A string containing the value to verify in the IKEv2 server certificate's Subject Common Name field.
        #[unsafe(method(serverCertificateCommonName))]
        #[unsafe(method_family = none)]
        pub unsafe fn serverCertificateCommonName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`serverCertificateCommonName`][Self::serverCertificateCommonName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setServerCertificateCommonName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServerCertificateCommonName(
            &self,
            server_certificate_common_name: Option<&NSString>,
        );

        /// contains the type of certificate if an certificate is configured.  Default is RSA.
        #[unsafe(method(certificateType))]
        #[unsafe(method_family = none)]
        pub unsafe fn certificateType(&self) -> NEVPNIKEv2CertificateType;

        /// Setter for [`certificateType`][Self::certificateType].
        #[unsafe(method(setCertificateType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCertificateType(&self, certificate_type: NEVPNIKEv2CertificateType);

        /// Boolean indicating if client should use INTERNAL_IP4_SUBNET / INTERNAL_IP6_SUBNET attributes.  Default is False.
        #[unsafe(method(useConfigurationAttributeInternalIPSubnet))]
        #[unsafe(method_family = none)]
        pub unsafe fn useConfigurationAttributeInternalIPSubnet(&self) -> bool;

        /// Setter for [`useConfigurationAttributeInternalIPSubnet`][Self::useConfigurationAttributeInternalIPSubnet].
        #[unsafe(method(setUseConfigurationAttributeInternalIPSubnet:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUseConfigurationAttributeInternalIPSubnet(
            &self,
            use_configuration_attribute_internal_ip_subnet: bool,
        );

        /// Parameters for the IKE SA
        #[unsafe(method(IKESecurityAssociationParameters))]
        #[unsafe(method_family = none)]
        pub unsafe fn IKESecurityAssociationParameters(
            &self,
        ) -> Retained<NEVPNIKEv2SecurityAssociationParameters>;

        /// Parameters for the child SA
        #[unsafe(method(childSecurityAssociationParameters))]
        #[unsafe(method_family = none)]
        pub unsafe fn childSecurityAssociationParameters(
            &self,
        ) -> Retained<NEVPNIKEv2SecurityAssociationParameters>;

        /// Disable MOBIKE negotiation. Default is NO.
        #[unsafe(method(disableMOBIKE))]
        #[unsafe(method_family = none)]
        pub unsafe fn disableMOBIKE(&self) -> bool;

        /// Setter for [`disableMOBIKE`][Self::disableMOBIKE].
        #[unsafe(method(setDisableMOBIKE:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisableMOBIKE(&self, disable_mobike: bool);

        /// Disable Server Redirect. Default is NO.
        #[unsafe(method(disableRedirect))]
        #[unsafe(method_family = none)]
        pub unsafe fn disableRedirect(&self) -> bool;

        /// Setter for [`disableRedirect`][Self::disableRedirect].
        #[unsafe(method(setDisableRedirect:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisableRedirect(&self, disable_redirect: bool);

        /// Enable Perfect Forward Secrecy. Default is NO.
        #[unsafe(method(enablePFS))]
        #[unsafe(method_family = none)]
        pub unsafe fn enablePFS(&self) -> bool;

        /// Setter for [`enablePFS`][Self::enablePFS].
        #[unsafe(method(setEnablePFS:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnablePFS(&self, enable_pfs: bool);

        /// Allow servers that do not support post-quantum key exchanges to skip them. This property has no effect if no post-quantum key exchange methods
        /// are configured for the IKE SA or Child SA (see NEVPNIKEv2SecurityAssociationParameters.postQuantumKeyExchangeMethods). Default is NO.
        #[unsafe(method(allowPostQuantumKeyExchangeFallback))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowPostQuantumKeyExchangeFallback(&self) -> bool;

        /// Setter for [`allowPostQuantumKeyExchangeFallback`][Self::allowPostQuantumKeyExchangeFallback].
        #[unsafe(method(setAllowPostQuantumKeyExchangeFallback:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAllowPostQuantumKeyExchangeFallback(
            &self,
            allow_post_quantum_key_exchange_fallback: bool,
        );

        /// Enable certificate revocation check. Default is NO.
        #[unsafe(method(enableRevocationCheck))]
        #[unsafe(method_family = none)]
        pub unsafe fn enableRevocationCheck(&self) -> bool;

        /// Setter for [`enableRevocationCheck`][Self::enableRevocationCheck].
        #[unsafe(method(setEnableRevocationCheck:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnableRevocationCheck(&self, enable_revocation_check: bool);

        /// Require positive certificate revocation check response for peer certificate validation to pass. Default is NO.
        #[unsafe(method(strictRevocationCheck))]
        #[unsafe(method_family = none)]
        pub unsafe fn strictRevocationCheck(&self) -> bool;

        /// Setter for [`strictRevocationCheck`][Self::strictRevocationCheck].
        #[unsafe(method(setStrictRevocationCheck:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStrictRevocationCheck(&self, strict_revocation_check: bool);

        /// Sets a minimum TLS version to allow for EAP-TLS authentication. Default is NEVPNIKEv2TLSVersionDefault.
        #[unsafe(method(minimumTLSVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumTLSVersion(&self) -> NEVPNIKEv2TLSVersion;

        /// Setter for [`minimumTLSVersion`][Self::minimumTLSVersion].
        #[unsafe(method(setMinimumTLSVersion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinimumTLSVersion(&self, minimum_tls_version: NEVPNIKEv2TLSVersion);

        /// Sets a maximum TLS version to allow for EAP-TLS authentication. Default is NEVPNIKEv2TLSVersionDefault.
        #[unsafe(method(maximumTLSVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumTLSVersion(&self) -> NEVPNIKEv2TLSVersion;

        /// Setter for [`maximumTLSVersion`][Self::maximumTLSVersion].
        #[unsafe(method(setMaximumTLSVersion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumTLSVersion(&self, maximum_tls_version: NEVPNIKEv2TLSVersion);

        /// Enable Fallback is used to support Wi-Fi Assist. Wi-Fi Assist allows connections for foreground apps to switch over
        /// to Cellular Data when WiFi connectivity is poor. By setting the EnableFallback key, the device will bring up a tunnel over
        /// Cellular Data to carry traffic that is eligible for Wi-Fi Assist and also requires VPN. Enabling fallback requires that the
        /// server support multiple tunnels for a single user. Default is NO.
        #[unsafe(method(enableFallback))]
        #[unsafe(method_family = none)]
        pub unsafe fn enableFallback(&self) -> bool;

        /// Setter for [`enableFallback`][Self::enableFallback].
        #[unsafe(method(setEnableFallback:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnableFallback(&self, enable_fallback: bool);

        /// Maximum Transmission Unit (MTU) size in bytes to assign to the tunnel interface.
        #[unsafe(method(mtu))]
        #[unsafe(method_family = none)]
        pub unsafe fn mtu(&self) -> NSUInteger;

        /// Setter for [`mtu`][Self::mtu].
        #[unsafe(method(setMtu:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMtu(&self, mtu: NSUInteger);

        /// Configuration for the use of a Post-quantum Pre-shared Key (PPK).
        #[unsafe(method(ppkConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn ppkConfiguration(&self) -> Option<Retained<NEVPNIKEv2PPKConfiguration>>;

        /// Setter for [`ppkConfiguration`][Self::ppkConfiguration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPpkConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPpkConfiguration(
            &self,
            ppk_configuration: Option<&NEVPNIKEv2PPKConfiguration>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NEVPNProtocolIKEv2 {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern "C" {
    /// The error domain string for local push errors.
    pub static NEAppPushErrorDomain: &'static NSErrorDomain;
}

/// Error codes that the local push API declares.
/// App Push Manager error codes
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEAppPushManagerError(pub NSInteger);
impl NEAppPushManagerError {
    /// An error code that indicates the app push configuration is invalid.
    #[doc(alias = "NEAppPushManagerErrorConfigurationInvalid")]
    pub const ConfigurationInvalid: Self = Self(1);
    /// An error code that indicates the manager hasn’t loaded the app push configuration.
    #[doc(alias = "NEAppPushManagerErrorConfigurationNotLoaded")]
    pub const ConfigurationNotLoaded: Self = Self(2);
    /// An error code that indicates an internal error in the local push connectivity framework.
    #[doc(alias = "NEAppPushManagerErrorInternalError")]
    pub const InternalError: Self = Self(3);
    /// An error code that indicates an invalid attempt to perform an operation on an inactive session.
    #[doc(alias = "NEAppPushManagerErrorInactiveSession")]
    pub const InactiveSession: Self = Self(4);
}

unsafe impl Encode for NEAppPushManagerError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEAppPushManagerError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The parameters of a private LTE network.
    ///
    /// ## Overview
    ///
    /// Populate your manager’s [`matchPrivateLTENetworks`](https://developer.apple.com/documentation/networkextension/neapppushmanager/matchprivateltenetworks) with an array of objects of this type. The system starts the provider when the device’s current private LTE provider matches the properties of any member of the array.
    ///
    ///
    /// The NEPrivateLTENetwork class declares an object that contains the parameters of a private LTE network.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEPrivateLTENetwork;
);

extern_conformance!(
    unsafe impl NSCoding for NEPrivateLTENetwork {}
);

extern_conformance!(
    unsafe impl NSCopying for NEPrivateLTENetwork {}
);

unsafe impl CopyingHelper for NEPrivateLTENetwork {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NEPrivateLTENetwork {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NEPrivateLTENetwork {}
);

impl NEPrivateLTENetwork {
    extern_methods!(
        /// Mobile Country Code of the private LTE network.
        #[unsafe(method(mobileCountryCode))]
        #[unsafe(method_family = none)]
        pub unsafe fn mobileCountryCode(&self) -> Retained<NSString>;

        /// Setter for [`mobileCountryCode`][Self::mobileCountryCode].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMobileCountryCode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMobileCountryCode(&self, mobile_country_code: &NSString);

        /// Mobile Network Code of the private LTE network.
        #[unsafe(method(mobileNetworkCode))]
        #[unsafe(method_family = none)]
        pub unsafe fn mobileNetworkCode(&self) -> Retained<NSString>;

        /// Setter for [`mobileNetworkCode`][Self::mobileNetworkCode].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMobileNetworkCode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMobileNetworkCode(&self, mobile_network_code: &NSString);

        /// Tracking Area Code of the private LTE network. This property is only applicable for band 48 private LTE networks.
        #[unsafe(method(trackingAreaCode))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackingAreaCode(&self) -> Option<Retained<NSString>>;

        /// Setter for [`trackingAreaCode`][Self::trackingAreaCode].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTrackingAreaCode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTrackingAreaCode(&self, tracking_area_code: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEPrivateLTENetwork {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object that configures a push provider and manages its life cycle.
    ///
    /// ## Overview
    ///
    /// Your app can create as many [`NEAppPushManager`](https://developer.apple.com/documentation/networkextension/neapppushmanager) instances as you need. Load your managers from the persistent store and set up their delegates immediately after the app launches, so they’re ready to handle incoming calls.
    ///
    ///
    /// The NEAppPushManager class declares a programmatic interface to configure NEAppPushProvider.
    ///
    /// NEAppPushManager declares methods and properties for configuring and managing life cycle of app push provider.
    ///
    /// Instances of this class are thread safe.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEAppPushManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEAppPushManager {}
);

impl NEAppPushManager {
    extern_methods!(
        /// An array of Wi-Fi SSID strings. If the SSID string of current Wi-Fi network matches with one of these strings and the Wi-Fi network is the primary route
        /// on the device then the NEAppPushProvider is started. The upper limit of number of SSIDs is 10.
        #[unsafe(method(matchSSIDs))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchSSIDs(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`matchSSIDs`][Self::matchSSIDs].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMatchSSIDs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchSSIDs(&self, match_ssi_ds: &NSArray<NSString>);

        /// An array of NEPrivateLTENetwork objects. If the properties of current private LTE network match with properties of one of these NEPrivateLTENetwork
        /// objects and the private LTE network is the primary route on the device then the NEAppPushProvider is started. The upper limit of number of private LTE networks is 10.
        /// For private LTE networks that are not band 48, the device must be supervised in order to perform the match
        #[unsafe(method(matchPrivateLTENetworks))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchPrivateLTENetworks(&self) -> Retained<NSArray<NEPrivateLTENetwork>>;

        /// Setter for [`matchPrivateLTENetworks`][Self::matchPrivateLTENetworks].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMatchPrivateLTENetworks:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchPrivateLTENetworks(
            &self,
            match_private_lte_networks: &NSArray<NEPrivateLTENetwork>,
        );

        /// If set to YES NEAppPushProvider is started when iOS device is connected to an Ethernet network and the ethernet network is the primary route
        /// on the device. NEAppPushProvider must determine viability of its functionality on the network. If the network does not support its operation it must call
        /// [NEAppPushProvider unmatchEthernet:] method to stop itself.
        #[unsafe(method(matchEthernet))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchEthernet(&self) -> bool;

        /// Setter for [`matchEthernet`][Self::matchEthernet].
        #[unsafe(method(setMatchEthernet:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMatchEthernet(&self, match_ethernet: bool);

        /// A dictionary containing vendor-specific key-value pairs, where the data type of values must be one of the data types supported by property list. Values of user defined data
        /// type are not supported. This dictionary is passed as-is to NEAppPushProvider when is it is started or notified for other specified reasons.
        #[unsafe(method(providerConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn providerConfiguration(&self) -> Retained<NSDictionary<NSString, AnyObject>>;

        /// Setter for [`providerConfiguration`][Self::providerConfiguration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `provider_configuration` generic should be of the correct type.
        #[unsafe(method(setProviderConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProviderConfiguration(
            &self,
            provider_configuration: &NSDictionary<NSString, AnyObject>,
        );

        /// A string containing the bundle identifier of the NEAppPushProvider.
        #[unsafe(method(providerBundleIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn providerBundleIdentifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`providerBundleIdentifier`][Self::providerBundleIdentifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProviderBundleIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProviderBundleIdentifier(
            &self,
            provider_bundle_identifier: Option<&NSString>,
        );

        /// An instance of type NEAppPushDelegate that is required to receive incoming call informarion from the provider.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NEAppPushDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NEAppPushDelegate>>);

        #[cfg(feature = "block2")]
        /// This class method asynchronously reads all of the saved configurations and returns them as an array of NEAppPushManager objects.
        ///
        /// Parameter `completionHandler`: A block that takes an array of NEAppPushManager objects. The array passed to the block may be empty if no configurations
        /// were successfully read from the disk. The NSError object passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadAllFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadAllFromPreferencesWithCompletionHandler(
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<NEAppPushManager>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// This method loads the saved configuration from the persistent store.
        ///
        /// Parameter `completionHandler`: A block that will be called when the load operation is completed. The NSError object passed to this block will be nil if the load operation succeeded, non-nil otherwise.
        #[unsafe(method(loadFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn loadFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This method removes the configuration from the persistent store.
        ///
        /// Parameter `completionHandler`: A block that will be called when the remove operation is completed. The NSError object passed to this block will be nil if the remove operation succeeded, non-nil otherwise.
        #[unsafe(method(removeFromPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// This method saves the configuration in the persistent store.
        ///
        /// Parameter `completionHandler`: A block that will be called when the save operation is completed. The NSError object passed to this block will be nil if the save operation succeeded, non-nil otherwise.
        #[unsafe(method(saveToPreferencesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveToPreferencesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// A string containing a description of the app push manager.
        #[unsafe(method(localizedDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn localizedDescription(&self) -> Option<Retained<NSString>>;

        /// Setter for [`localizedDescription`][Self::localizedDescription].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLocalizedDescription:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocalizedDescription(&self, localized_description: Option<&NSString>);

        /// Toggles the enabled status of the configuration. This property will be set to NO when the same app saves another configuration that overlaps with this configuration.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);

        /// If set to YES, it indicates the associated configuration is in use. Use KVO to watch for changes.
        #[unsafe(method(isActive))]
        #[unsafe(method_family = none)]
        pub unsafe fn isActive(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEAppPushManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A protocol that defines how an app push manager instance interacts with the framework.
    /// Delegate for NEAppPushManager.
    pub unsafe trait NEAppPushDelegate: NSObjectProtocol {
        /// This delegate method is called when the provider reports incoming call using reportIncomingCommunicationWithUserInfo method.
        ///
        /// Parameter `userInfo`: A dictionary of custom information that the provider passes to reportIncomingCommunicationWithUserInfo method.
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[unsafe(method(appPushManager:didReceiveIncomingCallWithUserInfo:))]
        #[unsafe(method_family = none)]
        unsafe fn appPushManager_didReceiveIncomingCallWithUserInfo(
            &self,
            manager: &NEAppPushManager,
            user_info: &NSDictionary,
        );
    }
);

extern_class!(
    /// An object that creates and maintains a persistent network connection to a local push server.
    ///
    /// ## Overview
    ///
    /// Subclass [`NEAppPushProvider`](https://developer.apple.com/documentation/networkextension/neapppushprovider) to provide the connection to your local push server. A [`NEAppPushManager`](https://developer.apple.com/documentation/networkextension/neapppushmanager) creates instances of your provider class based on the [`providerBundleIdentifier`](https://developer.apple.com/documentation/networkextension/neapppushmanager/providerbundleidentifier) in the manager’s configuration. The manager then calls methods on your provider to start and stop communication with the server, and periodically check the provider’s status. When your provider receives an incoming call from your server, call the provider’s [`reportIncomingCallWithUserInfo:`](https://developer.apple.com/documentation/networkextension/neapppushprovider/reportincomingcall(userinfo:)) method to alert the manager’s [`delegate`](https://developer.apple.com/documentation/networkextension/neapppushmanager/delegate).
    ///
    /// ### Creating a Local Push Provider Extension
    ///
    /// Local Push Providers run as App Extensions for the `app-push-provider` extension point, which is a possible value the [`Network Extensions Entitlement`](https://developer.apple.com/documentation/bundleresources/entitlements/com.apple.developer.networking.networkextension).
    ///
    /// To create a Local Push Provider extension, first create a new App Extension target in your project.
    ///
    /// For an example of an Xcode build target for this app extension, see the [Receiving Voice and Text Communications on a Local Network](https://developer.apple.com/documentation/networkextension/receiving-voice-and-text-communications-on-a-local-network) sample code project.
    ///
    /// Once you have an extension target, create a subclass of [`NEAppPushProvider`](https://developer.apple.com/documentation/networkextension/neapppushprovider). Then set the `NSExtensionPrincipalClass` key in the extension’s `Info.plist` to the name of your subclass. Set the `NSExtensionPointIdentifier` key in the extension’s `Info.plist` to `com.apple.networkextension.app-push`, if it’s not set already.
    ///
    /// Here’s an example of the `NSExtension` dictionary in a Local Push Provider extension’s `Info.plist`:
    ///
    /// ```xml
    /// <key>NSExtension</key>
    /// <dict>
    ///     <key>NSExtensionPointIdentifier</key>
    ///     <string>com.apple.networkextension.app-push</string>
    ///     <key>NSExtensionPrincipalClass</key>
    ///     <string>$(PRODUCT_MODULE_NAME).MyPushProvider</string>
    /// </dict>
    ///
    /// ```
    ///
    /// Finally, add your Local Push Provider extension target to your app’s Embed App Extensions build phase.
    ///
    ///
    /// The NEAppPushProvider class declares a programmatic interface to manage a life cycle of app push provider. It also allows the provider to handle outgoing
    /// communication message from the containing app, and pass incoming call message to the containing app.
    /// NEAppPushProvider is part of NetworkExtension.framework
    #[unsafe(super(NEProvider, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEAppPushProvider;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEAppPushProvider {}
);

impl NEAppPushProvider {
    extern_methods!(
        /// A dictionary containing current vendor-specific configuration parameters. This dictionary is provided by NEAppPushManager. Use KVO to watch for changes.
        #[unsafe(method(providerConfiguration))]
        #[unsafe(method_family = none)]
        pub unsafe fn providerConfiguration(
            &self,
        ) -> Option<Retained<NSDictionary<NSString, AnyObject>>>;

        #[cfg(feature = "block2")]
        /// This method is called by the framework when the provider is started. Subclasses must override this method to create a connection with its server.
        ///
        /// Parameter `completionHandler`: A block that must be called when the provider establishes a connection with the server. If the providers fails to create a connection,
        /// the subclass' implementation of this method must pass a non-nil NSError object to this block. A value of nil passed to the completion handler indicates that the connection
        /// was successfully created.
        #[deprecated]
        #[unsafe(method(startWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// This method is called by the framework when the provider is started. Subclasses must override this method to create a connection with its server.
        #[unsafe(method(start))]
        #[unsafe(method_family = none)]
        pub unsafe fn start(&self);

        #[cfg(feature = "block2")]
        /// This method is called by the framework when the app push provider needs to be stopped. Subclasses must override this method to perform necessary tasks.
        ///
        /// Parameter `reason`: An NEProviderStopReason indicating why the provider was stopped.
        ///
        /// Parameter `completionHandler`: A block that must be called when the provider is completely stopped.
        #[unsafe(method(stopWithReason:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopWithReason_completionHandler(
            &self,
            reason: NEProviderStopReason,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        /// This function is called by the provider when it determines incoming call on the conection.
        ///
        /// Parameter `userInfo`: A dictionary of custom information associated with the incoming call. This dictionary is passed to containg app as-is.
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[unsafe(method(reportIncomingCallWithUserInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn reportIncomingCallWithUserInfo(&self, user_info: &NSDictionary);

        /// This function is called by the provider when it receives a Push to Talk message on the connection.
        ///
        /// Parameter `userInfo`: A dictionary of custom information associated with the Push to Talk message, such as the active remote participant. This dictionary is passed to the PTChannelManagerDelegate of the containing app if the user is joined to a Push to Talk channel.
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[unsafe(method(reportPushToTalkMessageWithUserInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn reportPushToTalkMessageWithUserInfo(&self, user_info: &NSDictionary);

        /// This method is called by the framework periodically after every 60 seconds. Subclasses must override this method to perform necessary tasks.
        #[unsafe(method(handleTimerEvent))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleTimerEvent(&self);

        /// This method is called by the provider when it does not require runtime while the device is connected to the current Ethernet network.
        /// This method is applicable only when NEAppPushManager has set matchEthernet property to YES and the provider is running because the device is connected to an
        /// Ethernet network.
        #[unsafe(method(unmatchEthernet))]
        #[unsafe(method_family = none)]
        pub unsafe fn unmatchEthernet(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl NEAppPushProvider {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An abstract base class, shared by [`NWHostEndpoint`](https://developer.apple.com/documentation/networkextension/nwhostendpoint) or [`NWBonjourServiceEndpoint`](https://developer.apple.com/documentation/networkextension/nwbonjourserviceendpoint), that represents the source or destination of a network connection.
    ///
    /// ## Overview
    ///
    /// All endpoint objects are static collections of parameters that describe a network resource. They do not directly provide any resolution services, but instead must be used with other classes to be resolved and create connections.
    ///
    ///
    /// NWEndpoint is a generic class to represent network endpoints, such as a port on a remote server.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use nw_endpoint_t in Network framework instead, see deprecation notice in <NetworkExtension/NWEndpoint.h>"]
    pub struct NWEndpoint;
);

extern_conformance!(
    unsafe impl NSCoding for NWEndpoint {}
);

extern_conformance!(
    unsafe impl NSCopying for NWEndpoint {}
);

unsafe impl CopyingHelper for NWEndpoint {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NWEndpoint {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NWEndpoint {}
);

impl NWEndpoint {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NWEndpoint {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A network endpoint specified by DNS name (or IP address) and port.
    /// NWHostEndpoint is a subclass of NWEndpoint. It represents an endpoint backed by a
    /// hostname and port. Note that a hostname string may be an IP or IPv6 address.
    #[unsafe(super(NWEndpoint, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use `nw_endpoint_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWHostEndpoint.h>"]
    pub struct NWHostEndpoint;
);

extern_conformance!(
    unsafe impl NSCoding for NWHostEndpoint {}
);

extern_conformance!(
    unsafe impl NSCopying for NWHostEndpoint {}
);

unsafe impl CopyingHelper for NWHostEndpoint {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NWHostEndpoint {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NWHostEndpoint {}
);

impl NWHostEndpoint {
    extern_methods!(
        /// Parameter `hostname`: A string representation of the hostname or address, such as www.apple.com or 10.0.0.1.
        ///
        /// Parameter `port`: A string containing the port on the host, such as 80.
        ///
        /// Returns: An initialized NWHostEndpoint object.
        #[deprecated = "Use `nw_endpoint_create_host` in Network framework instead, see deprecation notice in <NetworkExtension/NWHostEndpoint.h>"]
        #[unsafe(method(endpointWithHostname:port:))]
        #[unsafe(method_family = none)]
        pub unsafe fn endpointWithHostname_port(
            hostname: &NSString,
            port: &NSString,
        ) -> Retained<Self>;

        /// The endpoint's hostname.
        #[deprecated = "Use `nw_endpoint_get_hostname` in Network framework instead, see deprecation notice in <NetworkExtension/NWHostEndpoint.h>"]
        #[unsafe(method(hostname))]
        #[unsafe(method_family = none)]
        pub unsafe fn hostname(&self) -> Retained<NSString>;

        /// The endpoint's port.
        #[deprecated = "Use `nw_endpoint_get_port` in Network framework instead, see deprecation notice in <NetworkExtension/NWHostEndpoint.h>"]
        #[unsafe(method(port))]
        #[unsafe(method_family = none)]
        pub unsafe fn port(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NWHostEndpoint {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A network endpoint specified as a Bonjour service name, type, and domain.
    ///
    /// ## Overview
    ///
    /// For example, the Bonjour service `MyMusicStudio._music._tcp.local.` has the name `"MyMusicStudio"`, the type `"_music._tcp"`, and the domain `"local"`.
    ///
    ///
    /// NWBonjourServiceEndpoint is a subclass of NWEndpoint. It represents an endpoint
    /// backed by a Bonjour service, specified with a name, type, and domain. For example, the
    /// Bonjour service MyMusicStudio._music._tcp.local. has the name "MyMusicStudio",
    /// the type "_music._tcp", and the domain "local".
    #[unsafe(super(NWEndpoint, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use `nw_endpoint_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWBonjourServiceEndpoint.h>"]
    pub struct NWBonjourServiceEndpoint;
);

extern_conformance!(
    unsafe impl NSCoding for NWBonjourServiceEndpoint {}
);

extern_conformance!(
    unsafe impl NSCopying for NWBonjourServiceEndpoint {}
);

unsafe impl CopyingHelper for NWBonjourServiceEndpoint {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NWBonjourServiceEndpoint {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NWBonjourServiceEndpoint {}
);

impl NWBonjourServiceEndpoint {
    extern_methods!(
        /// Parameter `name`: The Bonjour service name.
        ///
        /// Parameter `type`: The Bonjour service type.
        ///
        /// Parameter `domain`: The Bonjour service domain.
        ///
        /// Returns: An initialized NWBonjourServiceEndpoint object.
        #[deprecated = "Use `nw_endpoint_create_bonjour_service` in Network framework instead, see deprecation notice in <NetworkExtension/NWBonjourServiceEndpoint.h>"]
        #[unsafe(method(endpointWithName:type:domain:))]
        #[unsafe(method_family = none)]
        pub unsafe fn endpointWithName_type_domain(
            name: &NSString,
            r#type: &NSString,
            domain: &NSString,
        ) -> Retained<Self>;

        /// The endpoint's Bonjour service name.
        #[deprecated = "Use `nw_endpoint_get_bonjour_service_name` in Network framework instead, see deprecation notice in <NetworkExtension/NWBonjourServiceEndpoint.h>"]
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Retained<NSString>;

        /// The endpoint's Bonjour service type.
        #[deprecated = "Use `nw_endpoint_get_bonjour_service_type` in Network framework instead, see deprecation notice in <NetworkExtension/NWBonjourServiceEndpoint.h>"]
        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        pub unsafe fn r#type(&self) -> Retained<NSString>;

        /// The endpoint's Bonjour service domain.
        #[deprecated = "Use `nw_endpoint_get_bonjour_service_domain` in Network framework instead, see deprecation notice in <NetworkExtension/NWBonjourServiceEndpoint.h>"]
        #[unsafe(method(domain))]
        #[unsafe(method_family = none)]
        pub unsafe fn domain(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NWBonjourServiceEndpoint {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Path status values
// NS_ENUM
#[deprecated = "Use `nw_path_status_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NWPathStatus(pub NSInteger);
impl NWPathStatus {
    /// The path cannot be evaluated.
    #[doc(alias = "NWPathStatusInvalid")]
    #[deprecated = "Use `nw_path_status_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
    pub const Invalid: Self = Self(0);
    /// The path is ready to be used for network connections.
    #[doc(alias = "NWPathStatusSatisfied")]
    #[deprecated = "Use `nw_path_status_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
    pub const Satisfied: Self = Self(1);
    /// The path for network connections is not available, either due to lack of network connectivity or being prohibited by system policy.
    #[doc(alias = "NWPathStatusUnsatisfied")]
    #[deprecated = "Use `nw_path_status_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
    pub const Unsatisfied: Self = Self(2);
    /// The path is not currently satisfied, but may become satisfied upon a connection attempt. This can be due to a service, such as a VPN or a cellular data connection not being activated.
    /// a connection attempt.
    #[doc(alias = "NWPathStatusSatisfiable")]
    #[deprecated = "Use `nw_path_status_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
    pub const Satisfiable: Self = Self(3);
}

unsafe impl Encode for NWPathStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NWPathStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The path made by a network connection, including information about its viability.
    ///
    /// ## Overview
    ///
    /// For example, if the path status is [`NWPathStatusSatisfied`](https://developer.apple.com/documentation/networkextension/nwpathstatus/satisfied), then a connection attempt will be made.
    ///
    /// When attached to a specific connection, a path takes all of the connection parameters into account. For example, if the route for a connection changes or is removed, the path will reflect that change. Note that every path is evaluated within the context of the process it is running in, and may be different across processes.
    ///
    /// [`NWPath`](https://developer.apple.com/documentation/networkextension/nwpath) is a static object, and properties of the path will never change. To monitor changing network status, use Key-Value Observing (KVO) to watch a path property on another object. For information about KVO, see [Key-Value Observing Programming Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/KeyValueObserving/KeyValueObserving.html#//apple_ref/doc/uid/10000177i).
    ///
    ///
    /// A network path, represented with NWPath, expresses the viability status and
    /// properties of the path that a networking connection will take on the device. For example,
    /// if the path status is NWPathStatusSatisfied, then a connection could use that path.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use `nw_path_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
    pub struct NWPath;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NWPath {}
);

impl NWPath {
    extern_methods!(
        /// The evaluated NWPathStatus of the NWPath.
        #[deprecated = "Use `nw_path_get_status` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        pub unsafe fn status(&self) -> NWPathStatus;

        /// Returns YES if the path is considered expensive, as when using a cellular data plan.
        #[deprecated = "Use `nw_path_is_expensive` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
        #[unsafe(method(isExpensive))]
        #[unsafe(method_family = none)]
        pub unsafe fn isExpensive(&self) -> bool;

        /// Returns YES if the path is considered constrained, as when it is in save data mode.
        #[deprecated = "Use `nw_path_is_constrained` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
        #[unsafe(method(isConstrained))]
        #[unsafe(method_family = none)]
        pub unsafe fn isConstrained(&self) -> bool;

        /// Parameter `path`: An NWPath object to compare.
        ///
        /// Returns: YES if the two path objects have the same content, NO otherwise.
        #[deprecated = "Use `nw_path_is_equal` in Network framework instead, see deprecation notice in <NetworkExtension/NWPath.h>"]
        #[unsafe(method(isEqualToPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEqualToPath(&self, path: &NWPath) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl NWPath {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Defined connection states. New types may be defined in the future.
/// Defined connection states. New types may be defined in the future.
// NS_ENUM
#[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NWTCPConnectionState(pub NSInteger);
impl NWTCPConnectionState {
    /// The connection is in an invalid or uninitialized state.
    #[doc(alias = "NWTCPConnectionStateInvalid")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
    pub const Invalid: Self = Self(0);
    /// The connection is attempting to connect. This includes endpoint resolution when applicable.
    #[doc(alias = "NWTCPConnectionStateConnecting")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
    pub const Connecting: Self = Self(1);
    /// The connection has attempted to connect but failed. It is now waiting for better conditions before trying again.
    /// waiting for better condition(s) before trying again.
    #[doc(alias = "NWTCPConnectionStateWaiting")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
    pub const Waiting: Self = Self(2);
    /// The connection is established. It is now possible to transfer data. If TLS is in use, the TLS handshake has finished.
    /// to transfer data. If TLS is in use, the TLS handshake would have finished when the connection
    /// is in this state.
    #[doc(alias = "NWTCPConnectionStateConnected")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
    pub const Connected: Self = Self(3);
    /// The connection is disconnected. It is no longer possible to transfer data. The application should call `cancel` to clean up resources.
    /// possible to transfer data. The application should call cancellation method to clean up resources
    /// when the connection is in this state.
    #[doc(alias = "NWTCPConnectionStateDisconnected")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
    pub const Disconnected: Self = Self(4);
    /// The connection has been cancelled by the client calling `cancel`.
    /// the cancellation method.
    #[doc(alias = "NWTCPConnectionStateCancelled")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
    pub const Cancelled: Self = Self(5);
}

unsafe impl Encode for NWTCPConnectionState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NWTCPConnectionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object to manage a TCP connection, with or without TLS.
    /// Establish TCP connections to an endpoint, and send and receive data on the TCP connection.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use `nw_connection_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
    pub struct NWTCPConnection;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NWTCPConnection {}
);

impl NWTCPConnection {
    extern_methods!(
        /// This convenience initializer can be used to create a new connection that would only
        /// be connected if there exists a better path (as determined by the system) to the destination
        /// endpoint of the original connection. It will be initialized using the same destination endpoint
        /// and set of parameters from the original connection.
        ///
        /// If the original connection becomes disconnected or cancelled, the new "upgrade" connection
        /// would automatically be considered better.
        ///
        /// The caller should create an NWTCPConnection and watch for the hasBetterPath property.
        /// When this property is YES, the caller should attempt to create a new upgrade
        /// connection, with the goal to start transferring data on the new better path as soon as
        /// possible to reduce power and potentially monetary cost. When the new upgrade connection
        /// becomes connected and when the caller wraps up the previous caller session on
        /// the original connection, the caller can start using the new upgrade connection and
        /// tear down the original one.
        ///
        ///
        /// Parameter `connection`: The original connection from which the caller will upgrade
        ///
        /// Returns: An initialized NWTCPConnection
        #[deprecated = "Use `nw_connection_create` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(initWithUpgradeForConnection:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUpgradeForConnection(
            this: Allocated<Self>,
            connection: &NWTCPConnection,
        ) -> Retained<Self>;

        /// The status of the connection. Use KVO to watch this property to get updates.
        #[deprecated = "Use `nw_connection_set_state_changed_handler` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> NWTCPConnectionState;

        /// YES if the connection can read and write data, NO otherwise. Use KVO to watch this property.
        #[deprecated = "Use `nw_connection_set_viability_changed_handler` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(isViable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isViable(&self) -> bool;

        /// YES if the system determines there is a better path the destination can be reached if
        /// the caller creates a new connection using the same endpoint and parameters. This can
        /// be done using the convenience upgrade initializer method.
        /// Use KVO to watch this property to get updates.
        #[deprecated = "Use `nw_connection_set_better_path_available_handler` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(hasBetterPath))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasBetterPath(&self) -> bool;

        /// The destination endpoint with which this connection was created.
        #[deprecated = "Use `nw_connection_copy_endpoint` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(endpoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn endpoint(&self) -> Retained<NWEndpoint>;

        /// The network path over which the connection was established. The caller can query
        /// additional properties from the NWPath object for more information.
        ///
        /// Note that this contains a snapshot of information at the time of connection establishment
        /// for this connection only. As a result, some underlying properties might change in time and
        /// might not reflect the path for other connections that might be established at different times.
        #[deprecated = "Use `nw_connection_copy_current_path` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(connectedPath))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectedPath(&self) -> Option<Retained<NWPath>>;

        /// The IP address endpoint from which the connection was connected.
        #[deprecated = "Use `nw_path_copy_effective_local_endpoint` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(localAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn localAddress(&self) -> Option<Retained<NWEndpoint>>;

        /// The IP address endpoint to which the connection was connected.
        #[deprecated = "Use `nw_path_copy_effective_remote_endpoint` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(remoteAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteAddress(&self) -> Option<Retained<NWEndpoint>>;

        /// When the connection is connected to a Bonjour service endpoint, the TXT record associated
        /// with the Bonjour service is available via this property. Beware that the value comes from
        /// the network. Care must be taken when parsing this potentially malicious value.
        #[deprecated = "Use `nw_endpoint_copy_txt_record` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(txtRecord))]
        #[unsafe(method_family = none)]
        pub unsafe fn txtRecord(&self) -> Option<Retained<NSData>>;

        /// The connection-wide error property indicates any fatal error that occurred while
        /// processing the connection or performing data reading or writing.
        #[deprecated = "Use `nw_connection_set_state_changed_handler` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(error))]
        #[unsafe(method_family = none)]
        pub unsafe fn error(&self) -> Option<Retained<NSError>>;

        /// Cancel the connection. This will clean up the resources associated with this object
        /// and transition this object to NWTCPConnectionStateCancelled state.
        #[deprecated = "Use `nw_connection_cancel` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(cancel))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancel(&self);

        #[cfg(feature = "block2")]
        /// Read "length" number of bytes. See readMinimumLength:maximumLength:completionHandler:
        /// for a complete discussion of the callback behavior.
        ///
        /// Parameter `length`: The exact number of bytes the application wants to read
        ///
        /// Parameter `completion`: The completion handler to be invoked when there is data to read or an error occurred
        #[deprecated = "Use `nw_connection_receive` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(readLength:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readLength_completionHandler(
            &self,
            length: NSUInteger,
            completion: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Read the requested range of bytes. The completion handler will be invoked when:
        /// - Exactly "length" number of bytes have been read. 'data' will be non-nil.
        ///
        /// - Fewer than "length" number of bytes, including 0 bytes, have been read, and the connection's
        /// read side has been closed. 'data' might be nil, depending on whether there was any data to be
        /// read when the connection's read side was closed.
        ///
        /// - Some fatal error has occurred, and 'data' will be nil.
        ///
        /// To know when to schedule a read again, check for the condition whether an error has occurred.
        ///
        /// For better performance, the caller should pick the effective minimum and maximum lengths.
        /// For example, if the caller absolutely needs a specific number of bytes before it can
        /// make any progress, use that value as the minimum. The maximum bytes can be the upperbound
        /// that the caller wants to read. Typically, the minimum length can be the caller
        /// protocol fixed-size header and the maximum length can be the maximum size of the payload or
        /// the size of the current read buffer.
        ///
        ///
        /// Parameter `minimum`: The minimum number of bytes the caller wants to read
        ///
        /// Parameter `maximum`: The maximum number of bytes the caller wants to read
        ///
        /// Parameter `completion`: The completion handler to be invoked when there is data to read or an error occurred
        #[deprecated = "Use `nw_connection_receive` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(readMinimumLength:maximumLength:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readMinimumLength_maximumLength_completionHandler(
            &self,
            minimum: NSUInteger,
            maximum: NSUInteger,
            completion: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Write the given data object content. Callers should wait until the completionHandler is executed
        /// before issuing another write.
        ///
        /// Parameter `data`: The data object whose content will be written
        ///
        /// Parameter `completion`: The completion handler to be invoked when the data content has been written or an error has occurred.
        /// If the error is nil, the write succeeded and the caller can write more data.
        #[deprecated = "Use `nw_connection_send` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(write:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn write_completionHandler(
            &self,
            data: &NSData,
            completion: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// Close this connection's write side such that further write requests won't succeed.
        /// Note that this has the effect of closing the read side of the peer connection.
        /// When the connection's read side and write side are closed, the connection is considered
        /// disconnected and will transition to the appropriate state.
        #[deprecated = "Use `nw_connection_send` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[unsafe(method(writeClose))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeClose(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl NWTCPConnection {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A delegate protocol to customize the TLS authentication done by a connection.
    ///
    /// ## Overview
    ///
    /// A delegate is not required for an [`NWTCPConnection`](https://developer.apple.com/documentation/networkextension/nwtcpconnection) object.
    ///
    ///
    /// Allows the caller to take custom actions on some connection events.
    #[deprecated = "Use `sec_protocol_options_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
    pub unsafe trait NWTCPConnectionAuthenticationDelegate: NSObjectProtocol {
        /// The caller can implement this optional protocol method to decide whether it
        /// wants to provide the identity for this connection for authentication. If this delegate
        /// method is not implemented, the return value will default to YES if
        /// provideIdentityForConnection:completionHandler: is implemented.
        ///
        /// Parameter `connection`: The connection sending this message
        ///
        /// Returns: YES to provide the identity for this connection, in which case, the delegate method
        /// provideIdentityForConnection:completionHandler: will be called.
        #[deprecated = "Use `sec_protocol_options_set_challenge_block` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[optional]
        #[unsafe(method(shouldProvideIdentityForConnection:))]
        #[unsafe(method_family = none)]
        unsafe fn shouldProvideIdentityForConnection(&self, connection: &NWTCPConnection) -> bool;

        #[cfg(all(feature = "block2", feature = "objc2-security"))]
        /// The caller can implement this optional protocol method to provide the identity
        /// and an optional certificate chain to be used for authentication.
        ///
        /// Parameter `connection`: The connection sending this message
        ///
        /// Parameter `completion`: The completion handler for passing identity and certificate chain to the connection.
        /// The "identity" argument is required and must not be nil. The "certificateChain" argument is optional,
        /// and is an array of one or more SecCertificateRef objects. The certificate chain must contain objects
        /// of type SecCertificateRef only. If the certificate chain is set, it will be used. Otherwise, the leaf
        /// certificate will be extracted from the SecIdentityRef object and will be used for authentication.
        ///
        /// The caller is responsible for keeping the argument object(s) alive for the duration of the
        /// completion handler invocation.
        #[deprecated = "Use `sec_protocol_options_set_challenge_block` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[optional]
        #[unsafe(method(provideIdentityForConnection:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn provideIdentityForConnection_completionHandler(
            &self,
            connection: &NWTCPConnection,
            completion: &block2::DynBlock<
                dyn Fn(NonNull<SecIdentity>, NonNull<NSArray<AnyObject>>),
            >,
        );

        /// The caller can implement this optional protocol method to decide whether it
        /// wants to take over the default trust evaluation for this connection. If this delegate method
        /// is not implemented, the return value will default to YES if
        /// provideIdentityForConnection:completionHandler: is implemented.
        ///
        /// Parameter `connection`: The connection sending this message
        ///
        /// Returns: YES to take over the default trust evaluation, in which case, the delegate method
        /// evaluateTrustForConnection:peerCertificateChain:completionHandler: will be called.
        #[deprecated = "Use `sec_protocol_options_set_verify_block` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[optional]
        #[unsafe(method(shouldEvaluateTrustForConnection:))]
        #[unsafe(method_family = none)]
        unsafe fn shouldEvaluateTrustForConnection(&self, connection: &NWTCPConnection) -> bool;

        #[cfg(all(feature = "block2", feature = "objc2-security"))]
        /// The caller can implement this optional protocol method to set up custom policies
        /// for peer certificate trust evaluation. If the delegate method is implemented, the caller
        /// is responsible for creating and setting up the SecTrustRef object and passing it to the
        /// completion handler. Otherwise, the default trust evaluation policy is used for the connection.
        ///
        /// Parameter `connection`: The connection sending this message
        ///
        /// Parameter `peerCertificateChain`: The peer certificate chain
        ///
        /// Parameter `completion`: The completion handler for passing the SecTrustRef object to the connection.
        /// The SecTrustRef object "trust" is required and must not be nil. It will be evaluated using
        /// SecTrustEvaluate() if necessary. The caller is responsible for keeping the argument object
        /// alive for the duration of the completion handler invocation.
        ///
        /// # Safety
        ///
        /// `peer_certificate_chain` generic should be of the correct type.
        #[deprecated = "Use `sec_protocol_options_set_verify_block` in Network framework instead, see deprecation notice in <NetworkExtension/NWTCPConnection.h>"]
        #[optional]
        #[unsafe(method(evaluateTrustForConnection:peerCertificateChain:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn evaluateTrustForConnection_peerCertificateChain_completionHandler(
            &self,
            connection: &NWTCPConnection,
            peer_certificate_chain: &NSArray<AnyObject>,
            completion: &block2::DynBlock<dyn Fn(NonNull<SecTrust>)>,
        );
    }
);

/// UDP session state values
// NS_ENUM
#[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NWUDPSessionState(pub NSInteger);
impl NWUDPSessionState {
    /// The session is in an invalid or uninitialized state.
    #[doc(alias = "NWUDPSessionStateInvalid")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
    pub const Invalid: Self = Self(0);
    /// The session is waiting for better conditions before attempting to make the session ready.
    /// attempting to make the session ready.
    #[doc(alias = "NWUDPSessionStateWaiting")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
    pub const Waiting: Self = Self(1);
    /// The remote endpoint is being resolved.
    #[doc(alias = "NWUDPSessionStatePreparing")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
    pub const Preparing: Self = Self(2);
    /// The session is ready for reading and writing data.
    #[doc(alias = "NWUDPSessionStateReady")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
    pub const Ready: Self = Self(3);
    /// None of the currently resolved endpoints can be used at this time, either due to problems with the path or the client rejecting the endpoints.
    /// at this time, either due to problems with the path or the client rejecting the
    /// endpoints.
    #[doc(alias = "NWUDPSessionStateFailed")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
    pub const Failed: Self = Self(4);
    /// The session has been cancelled by the client calling `cancel`.
    #[doc(alias = "NWUDPSessionStateCancelled")]
    #[deprecated = "Use `nw_connection_state_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
    pub const Cancelled: Self = Self(5);
}

unsafe impl Encode for NWUDPSessionState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NWUDPSessionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object to manage a UDP session to a network endpoint.
    ///
    /// ## Overview
    ///
    /// Since UDP does not include a handshake with the remote endpoint as part of its protocol, it is up to the client of the UDP session to provide feedback on the viability of the current endpoint. If a session is opened to a hostname, the system will resolve that hostname into potentially several IP addresses. Once the session state is `NWUDPSessionStateReady`, the client should try to write and read datagrams. If there is no response from the remote endpoint, the client can try the next address that was resolved using `tryNextResolvedEndpoint`.
    ///
    ///
    /// Open UDP datagram sessions to an endpoint, and send and receive datagrams.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use `nw_connection_t` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
    pub struct NWUDPSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NWUDPSession {}
);

impl NWUDPSession {
    extern_methods!(
        /// This convenience initializer can be used to create a new session based on the
        /// original session's endpoint and parameters.
        ///
        /// The application should create an NWUDPSession and watch the "hasBetterPath" property.
        /// When this property is YES, it should call initWithUpgradeForSession: to create a new
        /// session, with the goal to start transferring data on the new better path as soon as
        /// possible to reduce power and potentially monetary cost. When the new "upgrade" session
        /// becomes ready and when the application wraps up the previous application session on
        /// the original session, the application can start using the new "upgrade" session and
        /// tear down the original one.
        ///
        ///
        /// Parameter `session`: The original session from which the application will upgrade
        ///
        /// Returns: An initialized NWUDPSession object.
        #[deprecated = "Use `nw_connection_create` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(initWithUpgradeForSession:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUpgradeForSession(
            this: Allocated<Self>,
            session: &NWUDPSession,
        ) -> Retained<Self>;

        /// The current state of the UDP session. If the state is NWUDPSessionStateReady,
        /// then the connection is eligible for reading and writing. The state will be
        /// NWUDPSessionStateFailed if the endpoint could not be resolved, or all endpoints have been
        /// rejected. Use KVO to watch for changes.
        #[deprecated = "Use `nw_connection_set_state_changed_handler` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> NWUDPSessionState;

        /// The provided endpoint.
        #[deprecated = "Use `nw_connection_copy_endpoint` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(endpoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn endpoint(&self) -> Retained<NWEndpoint>;

        /// The currently targeted remote endpoint. Use KVO to watch for changes.
        #[deprecated = "Use `nw_connection_copy_current_path` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(resolvedEndpoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn resolvedEndpoint(&self) -> Option<Retained<NWEndpoint>>;

        /// YES if the connection can read and write data, NO otherwise.
        /// Use KVO to watch this property.
        #[deprecated = "Use `nw_connection_set_viability_changed_handler` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(isViable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isViable(&self) -> bool;

        /// YES if there is another path available that is preferred over the currentPath.
        /// To take advantage of this path, create a new UDPSession. Use KVO to watch for changes.
        #[deprecated = "Use `nw_connection_set_better_path_available_handler` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(hasBetterPath))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasBetterPath(&self) -> bool;

        /// The current evaluated path for the resolvedEndpoint. Use KVO to watch for changes.
        #[deprecated = "Use `nw_connection_copy_current_path` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(currentPath))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentPath(&self) -> Option<Retained<NWPath>>;

        /// Mark the current value of resolvedEndpoint as unusable, and try to switch to the
        /// next available endpoint. This should be used when the caller has attempted to communicate
        /// with the current resolvedEndpoint, and the caller has determined that it is unusable. If
        /// there are no other resolved endpoints, the session will move to the failed state.
        #[deprecated = "Use `nw_connection_cancel_current_endpoint` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(tryNextResolvedEndpoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn tryNextResolvedEndpoint(&self);

        /// The maximum size of a datagram to be written currently. If a datagram is written
        /// with a longer length, the datagram may be fragmented or encounter an error. Note that this
        /// value is not guaranteed to be the maximum datagram length for end-to-end communication
        /// across the network. Use KVO to watch for changes.
        #[deprecated = "Use `nw_connection_get_maximum_datagram_size` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(maximumDatagramLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumDatagramLength(&self) -> NSUInteger;

        #[cfg(feature = "block2")]
        /// Set a read handler for datagrams. Reads will be scheduled by the system, so this
        /// method only needs to be called once for a session.
        ///
        /// Parameter `handler`: A handler called when datagrams have been read, or when an error has occurred.
        ///
        /// Parameter `maxDatagrams`: The maximum number of datagrams to send to the handler.
        #[deprecated = "Use `nw_connection_receive` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(setReadHandler:maxDatagrams:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setReadHandler_maxDatagrams(
            &self,
            handler: &block2::DynBlock<dyn Fn(*mut NSArray<NSData>, *mut NSError)>,
            max_datagrams: NSUInteger,
        );

        #[cfg(feature = "block2")]
        /// Write multiple datagrams. Callers should wait until the completionHandler is executed
        /// before issuing another write.
        ///
        /// Parameter `datagramArray`: An NSArray of NSData objects, containing the ordered list datagrams to write.
        ///
        /// Parameter `completionHandler`: A handler called when the write request has either succeeded or failed.
        #[deprecated = "Use `nw_connection_send` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(writeMultipleDatagrams:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeMultipleDatagrams_completionHandler(
            &self,
            datagram_array: &NSArray<NSData>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Write a single datagram. Callers should wait until the completionHandler is executed
        /// before issuing another write.
        ///
        /// Parameter `datagram`: An NSData containing the datagram to write.
        ///
        /// Parameter `completionHandler`: A handler called when the write request has either succeeded or failed.
        #[deprecated = "Use `nw_connection_send` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(writeDatagram:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeDatagram_completionHandler(
            &self,
            datagram: &NSData,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// Move into the NWUDPSessionStateCancelled state. The connection will be terminated,
        /// and all handlers will be cancelled.
        #[deprecated = "Use `nw_connection_cancel` in Network framework instead, see deprecation notice in <NetworkExtension/NWUDPSession.h>"]
        #[unsafe(method(cancel))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancel(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl NWUDPSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// TLS properties for creating a connection.
    /// DEPRECATION NOTICE
    ///
    /// NW object wrappers are hidden in Swift 6. To continue accessing them, you
    /// can prepend double underscores to the symbol name.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated = "Use `sec_protocol_options_t` in Security framework instead, see deprecation notice in <NetworkExtension/NWTLSParameters.h>"]
    pub struct NWTLSParameters;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NWTLSParameters {}
);

impl NWTLSParameters {
    extern_methods!(
        /// The session ID for the associated connection, used for TLS session resumption.
        /// This property is optional when using TLS.
        #[deprecated = "Use `sec_protocol_options_set_tls_resumption_enabled` in Security framework instead, see deprecation notice in <NetworkExtension/NWTLSParameters.h>"]
        #[unsafe(method(TLSSessionID))]
        #[unsafe(method_family = none)]
        pub unsafe fn TLSSessionID(&self) -> Option<Retained<NSData>>;

        /// Setter for [`TLSSessionID`][Self::TLSSessionID].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[deprecated = "Use `sec_protocol_options_set_tls_resumption_enabled` in Security framework instead, see deprecation notice in <NetworkExtension/NWTLSParameters.h>"]
        #[unsafe(method(setTLSSessionID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTLSSessionID(&self, tls_session_id: Option<&NSData>);

        /// The set of allowed cipher suites, as defined in
        /// <Security
        /// /CipherSuite.h>.
        /// If set to nil, the default cipher suites will be used.
        #[deprecated = "Use `sec_protocol_options_append_tls_ciphersuite` in Security framework instead, see deprecation notice in <NetworkExtension/NWTLSParameters.h>"]
        #[unsafe(method(SSLCipherSuites))]
        #[unsafe(method_family = none)]
        pub unsafe fn SSLCipherSuites(&self) -> Option<Retained<NSSet<NSNumber>>>;

        /// Setter for [`SSLCipherSuites`][Self::SSLCipherSuites].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[deprecated = "Use `sec_protocol_options_append_tls_ciphersuite` in Security framework instead, see deprecation notice in <NetworkExtension/NWTLSParameters.h>"]
        #[unsafe(method(setSSLCipherSuites:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSSLCipherSuites(&self, ssl_cipher_suites: Option<&NSSet<NSNumber>>);

        /// The minimum allowed SSLProtocol value. as defined in
        /// <Security
        /// /SecureTransport.h>.
        /// If set, the SSL handshake will not accept any protocol version older than the minimum.
        #[deprecated = "Use `sec_protocol_options_set_min_tls_protocol_version` in Security framework instead, see deprecation notice in <NetworkExtension/NWTLSParameters.h>"]
        #[unsafe(method(minimumSSLProtocolVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumSSLProtocolVersion(&self) -> NSUInteger;

        /// Setter for [`minimumSSLProtocolVersion`][Self::minimumSSLProtocolVersion].
        #[deprecated = "Use `sec_protocol_options_set_min_tls_protocol_version` in Security framework instead, see deprecation notice in <NetworkExtension/NWTLSParameters.h>"]
        #[unsafe(method(setMinimumSSLProtocolVersion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinimumSSLProtocolVersion(&self, minimum_ssl_protocol_version: NSUInteger);

        /// The maximum allowed SSLProtocol value. as defined in
        /// <Security
        /// /SecureTransport.h>.
        /// If set, the SSL handshake will not accept any protocol version newer than the maximum.
        /// This property should be used with caution, since it may limit the use of preferred
        /// SSL protocols.
        #[deprecated = "Use `sec_protocol_options_set_max_tls_protocol_version` in Security framework instead, see deprecation notice in <NetworkExtension/NWTLSParameters.h>"]
        #[unsafe(method(maximumSSLProtocolVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumSSLProtocolVersion(&self) -> NSUInteger;

        /// Setter for [`maximumSSLProtocolVersion`][Self::maximumSSLProtocolVersion].
        #[deprecated = "Use `sec_protocol_options_set_max_tls_protocol_version` in Security framework instead, see deprecation notice in <NetworkExtension/NWTLSParameters.h>"]
        #[unsafe(method(setMaximumSSLProtocolVersion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumSSLProtocolVersion(&self, maximum_ssl_protocol_version: NSUInteger);
    );
}

/// Methods declared on superclass `NSObject`.
impl NWTLSParameters {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// A verdict returned by a URL filter.
///
/// ## Overview
///
/// You receive this type as the result of calling [`verdict(for:)`](https://developer.apple.com/documentation/networkextension/neurlfilter/verdict(for:)) on a [`NEURLFilter`](https://developer.apple.com/documentation/networkextension/neurlfilter) instance.
///
///
/// URL Filter Verdicts
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NEURLFilterVerdict(pub NSInteger);
impl NEURLFilterVerdict {
    /// A verdict that indicates URL validation failed.
    #[doc(alias = "NEURLFilterVerdictUnknown")]
    pub const Unknown: Self = Self(1);
    /// A verdict that indicates that accessing the URL is allowed.
    #[doc(alias = "NEURLFilterVerdictAllow")]
    pub const Allow: Self = Self(2);
    /// A verdict that indicates that accessing the URL is denied.
    #[doc(alias = "NEURLFilterVerdictDeny")]
    pub const Deny: Self = Self(3);
}

unsafe impl Encode for NEURLFilterVerdict {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NEURLFilterVerdict {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A class used to voluntarily validate URLs for apps that don’t use WebKit or the URL session API.
    ///
    /// ## Overview
    ///
    /// When using networking frameworks other than WebKit or Foundation’s [`NSURLSession`](https://developer.apple.com/documentation/foundation/urlsession), use the `NEURLFilter` API to evaluate URLs before potentially connecting to a restricted or malicious site. Call the class method [`verdict(for:)`](https://developer.apple.com/documentation/networkextension/neurlfilter/verdict(for:)) to check a URL and honor the “allow” or “deny” verdict. Don’t connect to any URL that receives a “deny” verdict.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NEURLFilter;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NEURLFilter {}
);

impl NEURLFilter {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// This method determines if the specified URL should be allowed or denied.  The returned Allow or Deny verdict should be honored to prevent
        /// communication with restricted or malicious Internet sites.
        /// - Parameters:
        /// - url: url to be validated
        /// - completionHandler: A block that will be called when validation is completed. A NEURLFilterVerdict verdict will be returned to indicate
        /// whether the specified URL should be allowed or denied.  If verdict is Deny, caller should fail the URL request.
        #[unsafe(method(verdictForURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn verdictForURL_completionHandler(
            url: &NSURL,
            completion_handler: &block2::DynBlock<dyn Fn(NEURLFilterVerdict)>,
        );

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NEURLFilter {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
