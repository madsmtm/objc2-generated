//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;

use crate::ffi::*;

extern "C-unwind" {
    pub fn backtrace(param1: *mut *mut c_void, param1: c_int) -> c_int;
}

extern "C-unwind" {
    pub fn backtrace_from_fp(startfp: *mut c_void, array: *mut *mut c_void, size: c_int) -> c_int;
}

extern "C-unwind" {
    pub fn backtrace_symbols(param1: *const *const c_void, param1: c_int) -> *mut *mut c_char;
}

extern "C-unwind" {
    pub fn backtrace_symbols_fd(param1: *const *const c_void, param1: c_int, param1: c_int);
}

/// [Apple's documentation](https://developer.apple.com/documentation/darwin/image_offset?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct image_offset {
    pub uuid: uuid_t,
    pub offset: u32,
}

extern "C-unwind" {
    pub fn backtrace_image_offsets(
        array: *const *const c_void,
        image_offsets: *mut libc::image_offset,
        size: c_int,
    );
}

extern "C-unwind" {
    /// Extracts the function return addresses of the current call stack. While
    /// backtrace() will only follow the OS call stack, backtrace_async() will
    /// prefer the unwind the Swift concurrency continuation stack if invoked
    /// from within an async context. In a non-async context this function is
    /// strictly equivalent to backtrace().
    ///
    ///
    /// Parameter `array`: The array of pointers to fill with the return addresses.
    ///
    ///
    /// Parameter `length`: The maximum number of pointers to write.
    ///
    ///
    /// Parameter `task_id`: Can be NULL. If non-NULL, the uint32_t pointed to by `task_id` is set to
    /// a non-zero value that for the current process uniquely identifies the async
    /// task currently running. If called from a non-async context, the value is
    /// set to 0 and `array` contains the same values backtrace() would return.
    ///
    /// Note that the continuation addresses provided by backtrace_async()
    /// have an offset of 1 added to them.  Most symbolication engines will
    /// substract 1 from the call stack return addresses in order to symbolicate
    /// the call site rather than the return location.  With a Swift async
    /// continuation, substracting 1 from its address would result in an address
    /// in a different function.  This offset allows the returned addresses to be
    /// handled correctly by most existing symbolication engines.
    ///
    ///
    /// Returns: The number of pointers actually written.
    pub fn backtrace_async(array: *mut *mut c_void, length: usize, task_id: *mut u32) -> usize;
}
