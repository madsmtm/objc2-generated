//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;

use crate::ffi::*;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_event_ent {
    pub ae_number: au_event_t,
    pub ae_name: *mut c_char,
    pub ae_desc: *mut c_char,
    pub ae_class: au_class_t,
}

pub type au_event_ent_t = au_event_ent;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_class_ent {
    pub ac_name: *mut c_char,
    pub ac_class: au_class_t,
    pub ac_desc: *mut c_char,
}

pub type au_class_ent_t = au_class_ent;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_user_ent {
    pub au_name: *mut c_char,
    pub au_always: au_mask_t,
    pub au_never: au_mask_t,
}

pub type au_user_ent_t = au_user_ent;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_tid32 {
    pub port: u32,
    pub addr: u32,
}

pub type au_tid32_t = au_tid32;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_tid64 {
    pub port: u64,
    pub addr: u32,
}

pub type au_tid64_t = au_tid64;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_tidaddr32 {
    pub port: u32,
    pub r#type: u32,
    pub addr: [u32; 4],
}

pub type au_tidaddr32_t = au_tidaddr32;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_tidaddr64 {
    pub port: u64,
    pub r#type: u32,
    pub addr: [u32; 4],
}

pub type au_tidaddr64_t = au_tidaddr64;

/// argument #              1 byte
/// argument value          4 bytes/8 bytes (32-bit/64-bit value)
/// text length             2 bytes
/// text                    N bytes + 1 terminating NULL byte
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_arg32_t {
    pub no: c_uchar,
    pub val: u32,
    pub len: u16,
    pub text: *mut c_char,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_arg64_t {
    pub no: c_uchar,
    pub val: u64,
    pub len: u16,
    pub text: *mut c_char,
}

/// how to print            1 byte
/// basic unit              1 byte
/// unit count              1 byte
/// data items              (depends on basic unit)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_arb_t {
    pub howtopr: c_uchar,
    pub bu: c_uchar,
    pub uc: c_uchar,
    pub data: *mut c_uchar,
}

/// file access mode        4 bytes
/// owner user ID           4 bytes
/// owner group ID          4 bytes
/// file system ID          4 bytes
/// node ID                 8 bytes
/// device                  4 bytes/8 bytes (32-bit/64-bit)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_attr32_t {
    pub mode: u32,
    pub uid: u32,
    pub gid: u32,
    pub fsid: u32,
    pub nid: u64,
    pub dev: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_attr64_t {
    pub mode: u32,
    pub uid: u32,
    pub gid: u32,
    pub fsid: u32,
    pub nid: u64,
    pub dev: u64,
}

/// count                   4 bytes
/// text                    count null-terminated string(s)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_execarg_t {
    pub count: u32,
    pub text: [*mut c_char; 128],
}

/// count                   4 bytes
/// text                    count null-terminated string(s)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_execenv_t {
    pub count: u32,
    pub text: [*mut c_char; 128],
}

/// count                   4 bytes
/// text                    count null-terminated string(s)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_cert_hash_t {
    pub count: u32,
    pub text: [*mut c_char; 32],
}

/// count                   4 bytes
/// text                    count null-terminated string(s)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_krb5_principal_t {
    pub count: u32,
    pub text: [*mut c_char; 32],
}

/// status                  4 bytes
/// return value            4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_exit_t {
    pub status: u32,
    pub ret: u32,
}

/// seconds of time         4 bytes
/// milliseconds of time    4 bytes
/// file name length        2 bytes
/// file pathname           N bytes + 1 terminating NULL byte
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_file_t {
    pub s: u32,
    pub ms: u32,
    pub len: u16,
    pub name: *mut c_char,
}

/// number groups           2 bytes
/// group list              N * 4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_groups_t {
    pub no: u16,
    pub list: [u32; 16],
}

/// record byte count       4 bytes
/// version #               1 byte    [2]
/// event type              2 bytes
/// event modifier          2 bytes
/// seconds of time         4 bytes/8 bytes (32-bit/64-bit value)
/// milliseconds of time    4 bytes/8 bytes (32-bit/64-bit value)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_header32_t {
    pub size: u32,
    pub version: c_uchar,
    pub e_type: u16,
    pub e_mod: u16,
    pub s: u32,
    pub ms: u32,
}

/// record byte count       4 bytes
/// version #               1 byte     [2]
/// event type              2 bytes
/// event modifier          2 bytes
/// address type/length     1 byte (XXX: actually, 4 bytes)
/// machine address         4 bytes/16 bytes (IPv4/IPv6 address)
/// seconds of time         4 bytes/8 bytes  (32/64-bits)
/// nanoseconds of time     4 bytes/8 bytes  (32/64-bits)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_header32_ex_t {
    pub size: u32,
    pub version: c_uchar,
    pub e_type: u16,
    pub e_mod: u16,
    pub ad_type: u32,
    pub addr: [u32; 4],
    pub s: u32,
    pub ms: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_header64_t {
    pub size: u32,
    pub version: c_uchar,
    pub e_type: u16,
    pub e_mod: u16,
    pub s: u64,
    pub ms: u64,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_header64_ex_t {
    pub size: u32,
    pub version: c_uchar,
    pub e_type: u16,
    pub e_mod: u16,
    pub ad_type: u32,
    pub addr: [u32; 4],
    pub s: u64,
    pub ms: u64,
}

/// internet address        4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_inaddr_t {
    pub addr: u32,
}

/// type                 4 bytes
/// internet address     16 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_inaddr_ex_t {
    pub r#type: u32,
    pub addr: [u32; 4],
}

/// version and ihl         1 byte
/// type of service         1 byte
/// length                  2 bytes
/// id                      2 bytes
/// offset                  2 bytes
/// ttl                     1 byte
/// protocol                1 byte
/// checksum                2 bytes
/// source address          4 bytes
/// destination address     4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_ip_t {
    pub version: c_uchar,
    pub tos: c_uchar,
    pub len: u16,
    pub id: u16,
    pub offset: u16,
    pub ttl: c_uchar,
    pub prot: c_uchar,
    pub chksm: u16,
    pub src: u32,
    pub dest: u32,
}

/// object ID type          1 byte
/// object ID               4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_ipc_t {
    pub r#type: c_uchar,
    pub id: u32,
}

/// owner user ID           4 bytes
/// owner group ID          4 bytes
/// creator user ID         4 bytes
/// creator group ID        4 bytes
/// access mode             4 bytes
/// slot sequence #         4 bytes
/// key                     4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_ipcperm_t {
    pub uid: u32,
    pub gid: u32,
    pub puid: u32,
    pub pgid: u32,
    pub mode: u32,
    pub seq: u32,
    pub key: u32,
}

/// port IP address         2 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_iport_t {
    pub port: u16,
}

/// length        2 bytes
/// data            length bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_opaque_t {
    pub size: u16,
    pub data: *mut c_char,
}

/// path length             2 bytes
/// path                    N bytes + 1 terminating NULL byte
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_path_t {
    pub len: u16,
    pub path: *mut c_char,
}

/// audit ID                4 bytes
/// effective user ID       4 bytes
/// effective group ID      4 bytes
/// real user ID            4 bytes
/// real group ID           4 bytes
/// process ID              4 bytes
/// session ID              4 bytes
/// terminal ID
/// port ID               4 bytes/8 bytes (32-bit/64-bit value)
/// machine address       4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_proc32_t {
    pub auid: u32,
    pub euid: u32,
    pub egid: u32,
    pub ruid: u32,
    pub rgid: u32,
    pub pid: u32,
    pub sid: u32,
    pub tid: au_tid32_t,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_proc64_t {
    pub auid: u32,
    pub euid: u32,
    pub egid: u32,
    pub ruid: u32,
    pub rgid: u32,
    pub pid: u32,
    pub sid: u32,
    pub tid: au_tid64_t,
}

/// audit ID                4 bytes
/// effective user ID       4 bytes
/// effective group ID      4 bytes
/// real user ID            4 bytes
/// real group ID           4 bytes
/// process ID              4 bytes
/// session ID              4 bytes
/// terminal ID
/// port ID               4 bytes/8 bytes (32-bit/64-bit value)
/// type                  4 bytes
/// machine address       16 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_proc32ex_t {
    pub auid: u32,
    pub euid: u32,
    pub egid: u32,
    pub ruid: u32,
    pub rgid: u32,
    pub pid: u32,
    pub sid: u32,
    pub tid: au_tidaddr32_t,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_proc64ex_t {
    pub auid: u32,
    pub euid: u32,
    pub egid: u32,
    pub ruid: u32,
    pub rgid: u32,
    pub pid: u32,
    pub sid: u32,
    pub tid: au_tidaddr64_t,
}

/// error status            1 byte
/// return value            4 bytes/8 bytes (32-bit/64-bit value)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_ret32_t {
    pub status: c_uchar,
    pub ret: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_ret64_t {
    pub err: c_uchar,
    pub val: u64,
}

/// sequence number         4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_seq_t {
    pub seqno: u32,
}

/// socket type             2 bytes
/// local port              2 bytes
/// local Internet address  4 bytes
/// remote port             2 bytes
/// remote Internet address 4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_socket_t {
    pub r#type: u16,
    pub l_port: u16,
    pub l_addr: u32,
    pub r_port: u16,
    pub r_addr: u32,
}

/// socket type             2 bytes
/// local port              2 bytes
/// address type/length     4 bytes
/// local Internet address  4 bytes/16 bytes (IPv4/IPv6 address)
/// remote port             4 bytes
/// address type/length     4 bytes
/// remote Internet address 4 bytes/16 bytes (IPv4/IPv6 address)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_socket_ex32_t {
    pub domain: u16,
    pub r#type: u16,
    pub atype: u16,
    pub l_port: u16,
    pub l_addr: [u32; 4],
    pub r_port: u32,
    pub r_addr: [u32; 4],
}

/// socket family           2 bytes
/// local port              2 bytes
/// socket address          4 bytes/16 bytes (IPv4/IPv6 address)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_socketinet_ex32_t {
    pub family: u16,
    pub port: u16,
    pub addr: [u32; 4],
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_socketinet32_t {
    pub family: u16,
    pub port: u16,
    pub addr: u32,
}

/// socket family           2 bytes
/// path                    104 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_socketunix_t {
    pub family: u16,
    pub path: [c_char; 104],
}

/// audit ID                4 bytes
/// effective user ID       4 bytes
/// effective group ID      4 bytes
/// real user ID            4 bytes
/// real group ID           4 bytes
/// process ID              4 bytes
/// session ID              4 bytes
/// terminal ID
/// port ID               4 bytes/8 bytes (32-bit/64-bit value)
/// machine address       4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_subject32_t {
    pub auid: u32,
    pub euid: u32,
    pub egid: u32,
    pub ruid: u32,
    pub rgid: u32,
    pub pid: u32,
    pub sid: u32,
    pub tid: au_tid32_t,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_subject64_t {
    pub auid: u32,
    pub euid: u32,
    pub egid: u32,
    pub ruid: u32,
    pub rgid: u32,
    pub pid: u32,
    pub sid: u32,
    pub tid: au_tid64_t,
}

/// audit ID                4 bytes
/// effective user ID       4 bytes
/// effective group ID      4 bytes
/// real user ID            4 bytes
/// real group ID           4 bytes
/// process ID              4 bytes
/// session ID              4 bytes
/// terminal ID
/// port ID               4 bytes/8 bytes (32-bit/64-bit value)
/// type                  4 bytes
/// machine address       16 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_subject32ex_t {
    pub auid: u32,
    pub euid: u32,
    pub egid: u32,
    pub ruid: u32,
    pub rgid: u32,
    pub pid: u32,
    pub sid: u32,
    pub tid: au_tidaddr32_t,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_subject64ex_t {
    pub auid: u32,
    pub euid: u32,
    pub egid: u32,
    pub ruid: u32,
    pub rgid: u32,
    pub pid: u32,
    pub sid: u32,
    pub tid: au_tidaddr64_t,
}

/// text length             2 bytes
/// text                    N bytes + 1 terminating NULL byte
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_text_t {
    pub len: u16,
    pub text: *mut c_char,
}

/// zonename length    2 bytes
/// zonename text    N bytes + 1 NULL terminator
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_zonename_t {
    pub len: u16,
    pub zonename: *mut c_char,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_kevent_t {
    pub ident: u32,
    pub filter: u16,
    pub flags: u16,
    pub fflags: u32,
    pub data: u32,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_invalid_t {
    pub length: u16,
    pub data: *mut c_char,
}

/// signer type             4 bytes
/// signing id length       2 bytes
/// signing id              N bytes + 1 terminating NULL byte
/// signing id truncated    1 byte (true/false)
/// team id length          2 bytes
/// team id                 N bytes + 1 terminating NULL byte
/// team id truncated       1 byte (true/false)
/// cdhash length           2 bytes
/// cdhash                  N bytes
///
/// Note: This structure represents a contiguous (in-memory/on-disk) layout.
/// Due to multiple variable length buffers it cannot be simply assigned and
/// should only be populated via au_fetch_tok().
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_identity_t {
    pub signer_type: u32,
    pub signing_id_len: u16,
    pub signing_id: *mut c_char,
    pub signing_id_truncated: c_uchar,
    pub team_id_len: u16,
    pub team_id: *mut c_char,
    pub team_id_truncated: c_uchar,
    pub cdhash_len: u16,
    pub cdhash: *mut u8,
}

/// trailer magic number    2 bytes
/// record byte count       4 bytes
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct au_trailer_t {
    pub magic: u16,
    pub count: u32,
}

#[repr(C)]
#[derive(Clone, Copy)]
pub union tokenstr_tt {
    pub arg32: au_arg32_t,
    pub arg64: au_arg64_t,
    pub arb: au_arb_t,
    pub attr32: au_attr32_t,
    pub attr64: au_attr64_t,
    pub execarg: au_execarg_t,
    pub execenv: au_execenv_t,
    pub exit: au_exit_t,
    pub file: au_file_t,
    pub grps: au_groups_t,
    pub hdr32: au_header32_t,
    pub hdr32_ex: au_header32_ex_t,
    pub hdr64: au_header64_t,
    pub hdr64_ex: au_header64_ex_t,
    pub inaddr: au_inaddr_t,
    pub inaddr_ex: au_inaddr_ex_t,
    pub ip: au_ip_t,
    pub ipc: au_ipc_t,
    pub ipcperm: au_ipcperm_t,
    pub iport: au_iport_t,
    pub opaque: au_opaque_t,
    pub path: au_path_t,
    pub proc32: au_proc32_t,
    pub proc32_ex: au_proc32ex_t,
    pub proc64: au_proc64_t,
    pub proc64_ex: au_proc64ex_t,
    pub ret32: au_ret32_t,
    pub ret64: au_ret64_t,
    pub seq: au_seq_t,
    pub socket: au_socket_t,
    pub socket_ex32: au_socket_ex32_t,
    pub sockinet_ex32: au_socketinet_ex32_t,
    pub sockunix: au_socketunix_t,
    pub subj32: au_subject32_t,
    pub subj32_ex: au_subject32ex_t,
    pub subj64: au_subject64_t,
    pub subj64_ex: au_subject64ex_t,
    pub text: au_text_t,
    pub kevent: au_kevent_t,
    pub invalid: au_invalid_t,
    pub trail: au_trailer_t,
    pub zonename: au_zonename_t,
    pub cert_hash: au_cert_hash_t,
    pub krb5_principal: au_krb5_principal_t,
    pub identity: au_identity_t,
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct tokenstr {
    pub id: c_uchar,
    pub data: *mut c_uchar,
    pub len: usize,
    /// The token is one of the above types
    pub tt: tokenstr_tt,
}

pub type tokenstr_t = tokenstr;

extern "C-unwind" {
    /// Functions relating to querying audit class information.
    #[deprecated = "audit is deprecated"]
    pub fn setauclass();
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn endauclass();
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauclassent() -> *mut au_class_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauclassent_r(class_int: *mut au_class_ent_t) -> *mut au_class_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauclassnam(name: *const c_char) -> *mut au_class_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauclassnam_r(
        class_int: *mut au_class_ent_t,
        name: *const c_char,
    ) -> *mut au_class_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauclassnum(class_number: au_class_t) -> *mut au_class_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauclassnum_r(
        class_int: *mut au_class_ent_t,
        class_number: au_class_t,
    ) -> *mut au_class_ent;
}

extern "C-unwind" {
    /// Functions relating to querying audit control information.
    #[deprecated = "audit is deprecated"]
    pub fn setac();
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn endac();
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getacdir(name: *mut c_char, len: c_int) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getacmin(min_val: *mut c_int) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getacfilesz(size_val: *mut usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getacflg(auditstr: *mut c_char, len: c_int) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getacna(auditstr: *mut c_char, len: c_int) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getacpol(auditstr: *mut c_char, len: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "no longer implemented"]
    pub fn getacsflagsmask(which: *const c_char, auditstr: *mut c_char, len: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getachost(auditstr: *mut c_char, len: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getacexpire(andflg: *mut c_int, age: *mut time_t, size: *mut usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauditflagsbin(auditstr: *mut c_char, masks: *mut au_mask_t) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauditflagschar(auditstr: *mut c_char, masks: *mut au_mask_t, verbose: c_int)
        -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn au_preselect(
        event: au_event_t,
        mask_p: *mut au_mask_t,
        sorf: c_int,
        flag: c_int,
    ) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn au_poltostr(policy: c_int, maxsize: usize, buf: *mut c_char) -> isize;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn au_strtopol(polstr: *const c_char, policy: *mut c_int) -> c_int;
}

extern "C-unwind" {
    /// Functions relating to audit session flags.
    pub fn au_sflagstostr(flags: u64, maxsize: usize, buf: *mut c_char) -> isize;
}

extern "C-unwind" {
    pub fn au_strtosflags(sflagsstr: *const c_char, flags: *mut u64) -> c_int;
}

extern "C-unwind" {
    /// Functions relating to querying audit event information.
    #[deprecated = "audit is deprecated"]
    pub fn setauevent();
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn endauevent();
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauevent() -> *mut au_event_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauevent_r(e: *mut au_event_ent) -> *mut au_event_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauevnam(name: *const c_char) -> *mut au_event_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauevnam_r(e: *mut au_event_ent, name: *const c_char) -> *mut au_event_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauevnum(event_number: au_event_t) -> *mut au_event_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauevnum_r(e: *mut au_event_ent, event_number: au_event_t) -> *mut au_event_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauevnonam(event_name: *const c_char) -> *mut au_event_t;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauevnonam_r(ev: *mut au_event_t, event_name: *const c_char) -> *mut au_event_t;
}

extern "C-unwind" {
    /// Functions relating to querying audit user information.
    #[deprecated = "audit is deprecated"]
    pub fn setauuser();
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn endauuser();
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauuserent() -> *mut au_user_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauuserent_r(u: *mut au_user_ent) -> *mut au_user_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauusernam(name: *const c_char) -> *mut au_user_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getauusernam_r(u: *mut au_user_ent, name: *const c_char) -> *mut au_user_ent;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn au_user_mask(username: *mut c_char, mask_p: *mut au_mask_t) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn getfauditflags(
        usremask: *mut au_mask_t,
        usrdmask: *mut au_mask_t,
        lastmask: *mut au_mask_t,
    ) -> c_int;
}

extern "C-unwind" {
    /// Functions for reading and printing records and tokens from audit trails.
    #[deprecated = "audit is deprecated"]
    pub fn au_read_rec(fp: *mut FILE, buf: *mut *mut c_uchar) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn au_fetch_tok(tok: *mut tokenstr_t, buf: *mut c_uchar, len: c_int) -> c_int;
}

extern "C-unwind" {
    /// XXX The following interface has different prototype from BSM
    #[deprecated = "audit is deprecated"]
    pub fn au_print_tok(
        outfp: *mut FILE,
        tok: *mut tokenstr_t,
        del: *mut c_char,
        raw: c_char,
        sfrm: c_char,
    );
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn au_print_flags_tok(
        outfp: *mut FILE,
        tok: *mut tokenstr_t,
        del: *mut c_char,
        oflags: c_int,
    );
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn au_print_tok_xml(
        outfp: *mut FILE,
        tok: *mut tokenstr_t,
        del: *mut c_char,
        raw: c_char,
        sfrm: c_char,
    );
}

extern "C-unwind" {
    /// Functions relating to XML output.
    #[deprecated = "audit is deprecated"]
    pub fn au_print_xml_header(outfp: *mut FILE);
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn au_print_xml_footer(outfp: *mut FILE);
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn au_strerror(bsm_error: c_uchar) -> *const c_char;
}

pub const kAUNoErr: c_int = 0;
pub const kAUBadParamErr: c_int = -66049;
pub const kAUStatErr: c_int = -66048;
pub const kAUSysctlErr: c_int = -66047;
pub const kAUOpenErr: c_int = -66046;
pub const kAUMakeSubjectTokErr: c_int = -66045;
pub const kAUWriteSubjectTokErr: c_int = -66044;
pub const kAUWriteCallerTokErr: c_int = -66043;
pub const kAUMakeReturnTokErr: c_int = -66042;
pub const kAUWriteReturnTokErr: c_int = -66041;
pub const kAUCloseErr: c_int = -66040;
pub const kAUMakeTextTokErr: c_int = -66039;
pub const kAULastErr: c_int = -66038;

extern "C-unwind" {
    /// XXX  This prototype should be in audit_record.h
    ///
    /// au_free_token()
    ///
    /// - au_free_token() deallocates a token_t created by any of
    /// the au_to_*() BSM API functions.
    ///
    /// The BSM API generally manages deallocation of token_t objects.  However,
    /// if au_write() is passed a bad audit descriptor, the token_t * parameter
    /// will be left untouched.  In that case, the caller can deallocate the
    /// token_t using au_free_token() if desired.  This is, in fact, what
    /// audit_write() does, in keeping with the existing memory management model
    /// of the BSM API.
    ///
    ///
    /// Parameter `tok`: - A token_t * generated by one of the au_to_*() BSM API
    /// calls.  For convenience, tok may be NULL, in which case
    /// au_free_token() returns immediately.
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    #[deprecated = "audit is deprecated"]
    pub fn au_free_token(tok: Option<&token_t>);
}

extern "C-unwind" {
    /// Lightweight check to determine if auditing is enabled.  If a client
    /// wants to use this to govern whether an entire series of audit calls
    /// should be made--as in the common case of a caller building a set of
    /// tokens, then writing them--it should cache the audit status in a local
    /// variable.  This call always returns the current state of auditing.
    ///
    ///
    /// Returns: - AUC_AUDITING or AUC_NOAUDIT if no error occurred.
    /// Otherwise the function can return any of the errno values defined for
    /// setaudit(2), or AU_UNIMPL if audit does not appear to be supported by
    /// the system.
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    #[deprecated = "audit is deprecated"]
    pub fn au_get_state() -> c_int;
}

extern "C-unwind" {
    /// Initialize the audit notification.  If it has not already been initialized
    /// it will automatically on the first call of au_get_state().
    #[deprecated = "audit is deprecated"]
    pub fn au_notify_initialize() -> u32;
}

extern "C-unwind" {
    /// Cancel audit notification and free the resources associated with it.
    /// Responsible code that no longer needs to use au_get_state() should call
    /// this.
    #[deprecated = "audit is deprecated"]
    pub fn au_notify_terminate() -> c_int;
}

extern "C-unwind" {
    /// OpenSSH compatibility
    #[deprecated = "audit is deprecated"]
    pub fn cannot_audit(param1: c_int) -> c_int;
}

extern "C-unwind" {
    /// audit_set_terminal_id_ex()
    /// audit_set_terminal_id()
    ///
    /// - audit_set_terminal_id_ex() fills in an au_tid_addr_t struct,
    /// which is used in audit session initialization by processes like
    /// /usr/bin/login.  audit_set_terminal_id() does the same but for the
    /// au_tid_t structure.  Note that audit_set_terminal_id_ex() is preferred
    /// since it can store longer terminal addresses like those used in IP
    /// version 6.  Neither audit_set_terminal_id() nor audit_set_terminal_id_ex()
    /// should be used if the terminal connection is a remote one and the remote IP
    /// address and port is known, however.  These wrapper functions populate the
    /// au_tid_t or au_tid_addr_t stuctures with local terminal information only.
    ///
    ///
    /// Parameter `tid`: - A pointer to an au_tid_addr_t or au_tid_t struct.
    ///
    ///
    /// Returns: - kAUNoErr on success; kAUBadParamErr if tid is NULL, kAUStatErr
    /// or kAUSysctlErr if one of the underlying system calls fails (a message
    /// is sent to the system log in those cases).
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    pub fn audit_set_terminal_id_ex(tid: *mut au_tid_addr_t) -> c_int;
}

extern "C-unwind" {
    pub fn audit_set_terminal_id(tid: *mut au_tid_t) -> c_int;
}

extern "C-unwind" {
    /// audit_write()
    ///
    /// - audit_write() is the basis for the other audit_write_*()
    /// calls.  Performs a basic write of an audit record (subject, additional
    /// info, success/failure).  Note that this call only permits logging one
    /// caller-specified token; clients needing to log more flexibly must use
    /// the existing BSM API (au_open(), et al.) directly.
    ///
    /// Note on memory management: audit_write() guarantees that the token_t *s
    /// passed to it will be deallocated whether or not the underlying write to
    /// the audit log succeeded.  This addresses an inconsistency in the
    /// underlying BSM API in which token_t *s are usually but not always
    /// deallocated.
    ///
    ///
    /// Parameter `event_code`: - The code for the event being logged.  This should
    /// be one of the AUE_ values in /usr/include/bsm/audit_uevents.h.
    ///
    ///
    /// Parameter `subject`: - A token_t * generated by au_to_subject(),
    /// au_to_subject32(), au_to_subject64(), or au_to_me().  If no subject is
    /// required, subject should be NULL.
    ///
    ///
    /// Parameter `misctok`: - A token_t * generated by one of the au_to_*() BSM API
    /// calls.  This should correspond to the additional information required by
    /// CAPP for the event being audited.  If no additional information is
    /// required, misctok should be NULL.
    ///
    ///
    /// Parameter `retval`: - The return value to be logged for this event.  This
    /// should be 0 (zero) for success, otherwise the value is event-specific.
    ///
    ///
    /// Parameter `errcode`: - Any error code associated with the return value (e.g.,
    /// errno or h_errno).  If there was no error, errcode should be 0 (zero).
    ///
    ///
    /// Returns: - The status of the call: 0 (zero) on success, else one of the
    /// kAU*Err values defined above.
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    #[deprecated = "audit is deprecated"]
    pub fn audit_write(
        event_code: c_short,
        subject: Option<&token_t>,
        misctok: Option<&token_t>,
        retval: c_char,
        errcode: c_int,
    ) -> c_int;
}

extern "C-unwind" {
    /// audit_write_success_ex()
    /// audit_write_success()
    ///
    /// - audit_write_success_ex() and audit_write_success() record
    /// an auditable event that did not encounter an error.  The interface is
    /// designed to require as little direct use of the au_to_*() API as possible.
    /// It builds a subject token from the information passed in and uses that to
    /// invoke audit_write(). A subject, as defined by CAPP, is a process acting
    /// on the user's behalf. Preference should be given in using
    /// audit_write_success_ex() since it supports longer addreses such as those
    /// used for IP version 6.
    ///
    /// If the subject information is the same as the current process, use
    /// au_write_success_self().
    ///
    ///
    /// Parameter `event_code`: - The code for the event being logged.  This should
    /// be one of the AUE_ values in /usr/include/bsm/audit_uevents.h.
    ///
    ///
    /// Parameter `misctok`: - A token_t * generated by one of the au_to_*() BSM API
    /// calls.  This should correspond to the additional information required by
    /// CAPP for the event being audited.  If no additional information is
    /// required, misctok should be NULL.
    ///
    ///
    /// Parameter `auid`: - The subject's audit ID.
    ///
    ///
    /// Parameter `euid`: - The subject's effective user ID.
    ///
    ///
    /// Parameter `egid`: - The subject's effective group ID.
    ///
    ///
    /// Parameter `ruid`: - The subject's real user ID.
    ///
    ///
    /// Parameter `rgid`: - The subject's real group ID.
    ///
    ///
    /// Parameter `pid`: - The subject's process ID.
    ///
    ///
    /// Parameter `sid`: - The subject's session ID.
    ///
    ///
    /// Parameter `tid`: - The subject's terminal ID.
    ///
    ///
    /// Returns: - The status of the call: 0 (zero) on success, else one of the
    /// kAU*Err values defined above.
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    #[deprecated = "audit is deprecated"]
    pub fn audit_write_success_ex(
        event_code: c_short,
        misctok: Option<&token_t>,
        auid: au_id_t,
        euid: uid_t,
        egid: gid_t,
        ruid: uid_t,
        rgid: gid_t,
        pid: pid_t,
        sid: au_asid_t,
        tid: *mut au_tid_addr_t,
    ) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_write_success(
        event_code: c_short,
        misctok: Option<&token_t>,
        auid: au_id_t,
        euid: uid_t,
        egid: gid_t,
        ruid: uid_t,
        rgid: gid_t,
        pid: pid_t,
        sid: au_asid_t,
        tid: *mut au_tid_t,
    ) -> c_int;
}

extern "C-unwind" {
    /// audit_write_success_self()
    ///
    /// - Similar to audit_write_success_ex(), but used when the subject
    /// (process) is owned and operated by the auditable user him/herself.
    ///
    ///
    /// Parameter `event_code`: - The code for the event being logged.  This should
    /// be one of the AUE_ values in /usr/include/bsm/audit_uevents.h.
    ///
    ///
    /// Parameter `misctok`: - A token_t * generated by one of the au_to_*() BSM API
    /// calls.  This should correspond to the additional information required by
    /// CAPP for the event being audited.  If no additional information is
    /// required, misctok should be NULL.
    ///
    ///
    /// Returns: - The status of the call: 0 (zero) on success, else one of the
    /// kAU*Err values defined above.
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    #[deprecated = "audit is deprecated"]
    pub fn audit_write_success_self(event_code: c_short, misctok: Option<&token_t>) -> c_int;
}

extern "C-unwind" {
    /// audit_write_failure_ex()
    /// audit_write_failure()
    ///
    /// - audit_write_failure_ex() and audit_write_failure() records an
    /// auditable event that encountered an error.  The interface is designed to
    /// require as little direct use of the au_to_*() API as possible.  It builds
    /// a subject token from the information passed in and uses that to invoke audit
    /// write(). A subject, as defined by CAPP, is a process acting on the user's
    /// behalf. Preference should be given in using audit_write_success_ex() since
    /// it supports longer addreses such as those used for IP version 6.
    ///
    /// If the subject information is the same as the current process, use
    /// au_write_failure_self().
    ///
    ///
    /// Parameter `event_code`: - The code for the event being logged.  This should
    /// be one of the AUE_ values in /usr/include/bsm/audit_uevents.h.
    ///
    ///
    /// Parameter `errmsg`: - A text message providing additional information about
    /// the event being audited.
    ///
    ///
    /// Parameter `errret`: - A numerical value providing additional information about
    /// the error.  This is intended to store the value of errno or h_errno if
    /// it's relevant.  This can be 0 (zero) if no additional information is
    /// available.
    ///
    ///
    /// Parameter `auid`: - The subject's audit ID.
    ///
    ///
    /// Parameter `euid`: - The subject's effective user ID.
    ///
    ///
    /// Parameter `egid`: - The subject's effective group ID.
    ///
    ///
    /// Parameter `ruid`: - The subject's real user ID.
    ///
    ///
    /// Parameter `rgid`: - The subject's real group ID.
    ///
    ///
    /// Parameter `pid`: - The subject's process ID.
    ///
    ///
    /// Parameter `sid`: - The subject's session ID.
    ///
    ///
    /// Parameter `tid`: - The subject's terminal ID.
    ///
    ///
    /// Returns: - The status of the call: 0 (zero) on success, else one of the
    /// kAU*Err values defined above.
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    #[deprecated = "audit is deprecated"]
    pub fn audit_write_failure_ex(
        event_code: c_short,
        errmsg: *mut c_char,
        errret: c_int,
        auid: au_id_t,
        euid: uid_t,
        egid: gid_t,
        ruid: uid_t,
        rgid: gid_t,
        pid: pid_t,
        sid: au_asid_t,
        tid: *mut au_tid_addr_t,
    ) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_write_failure(
        event_code: c_short,
        errmsg: *mut c_char,
        errret: c_int,
        auid: au_id_t,
        euid: uid_t,
        egid: gid_t,
        ruid: uid_t,
        rgid: gid_t,
        pid: pid_t,
        sid: au_asid_t,
        tid: *mut au_tid_t,
    ) -> c_int;
}

extern "C-unwind" {
    /// audit_write_failure_self()
    ///
    /// - Similar to audit_write_failure(), but used when the subject
    /// (process) is owned and operated by the auditable user him/herself.
    ///
    ///
    /// Parameter `event_code`: - The code for the event being logged.  This should
    /// be one of the AUE_ values in /usr/include/bsm/audit_uevents.h.
    ///
    ///
    /// Parameter `errmsg`: - A text message providing additional information about
    /// the event being audited.
    ///
    ///
    /// Parameter `errret`: - A numerical value providing additional information about
    /// the error.  This is intended to store the value of errno or h_errno if
    /// it's relevant.  This can be 0 (zero) if no additional information is
    /// available.
    ///
    ///
    /// Returns: - The status of the call: 0 (zero) on success, else one of the
    /// kAU*Err values defined above.
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    #[deprecated = "audit is deprecated"]
    pub fn audit_write_failure_self(
        event_code: c_short,
        errmsg: *mut c_char,
        errret: c_int,
    ) -> c_int;
}

extern "C-unwind" {
    /// audit_write_failure_na_ex()
    /// audit_write_failure_na()
    ///
    /// - audit_write_failure_na_ex()  and audit_write_failure_na() record
    /// errors during login.  Such errors are implicitly non-attributable (i.e., not
    /// ascribable to any user).  Preference should be given in using
    /// audit_write_failure_na_ex() since it supports longer addreses such as those
    /// used for IP version 6.
    ///
    ///
    /// Parameter `event_code`: - The code for the event being logged.  This should
    /// be one of the AUE_ values in /usr/include/bsm/audit_uevents.h.
    ///
    ///
    /// Parameter `errmsg`: - A text message providing additional information about
    /// the event being audited.
    ///
    ///
    /// Parameter `errret`: - A numerical value providing additional information about
    /// the error.  This is intended to store the value of errno or h_errno if
    /// it's relevant.  This can be 0 (zero) if no additional information is
    /// available.
    ///
    ///
    /// Parameter `euid`: - The subject's effective user ID.
    ///
    ///
    /// Parameter `egid`: - The subject's effective group ID.
    ///
    ///
    /// Parameter `pid`: - The subject's process ID.
    ///
    ///
    /// Parameter `tid`: - The subject's terminal ID.
    ///
    ///
    /// Returns: - The status of the call: 0 (zero) on success, else one of the
    /// kAU*Err values defined above.
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    #[deprecated = "audit is deprecated"]
    pub fn audit_write_failure_na_ex(
        event_code: c_short,
        errmsg: *mut c_char,
        errret: c_int,
        euid: uid_t,
        egid: gid_t,
        pid: pid_t,
        tid: *mut au_tid_addr_t,
    ) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_write_failure_na(
        event_code: c_short,
        errmsg: *mut c_char,
        errret: c_int,
        euid: uid_t,
        egid: gid_t,
        pid: pid_t,
        tid: *mut au_tid_t,
    ) -> c_int;
}

extern "C-unwind" {
    /// audit_token_to_au32()  (NOW DEPRECATED)
    ///
    /// - Extract information from an audit_token_t, used to identify
    /// Mach tasks and senders of Mach messages as subjects to the audit system.
    /// audit_tokent_to_au32() is the only method that should be used to parse
    /// an audit_token_t, since its internal representation may change over
    /// time.  A pointer parameter may be NULL if that information is not
    /// needed.  audit_token_to_au32() has been deprecated because the terminal
    /// ID information is no longer saved in this token.  The last parameter
    /// is actually the process ID version.  The API calls audit_token_to_auid(),
    /// audit_token_to_euid(), audit_token_to_ruid(), audit_token_to_rgid(),
    /// audit_token_to_pid(), audit_token_to_asid(),  and/or
    /// audit_token_to_pidversion() should be used instead.
    ///
    ///
    /// Parameter `atoken`: - the audit token containing the desired information
    ///
    ///
    /// Parameter `auidp`: - Pointer to a uid_t; on return will be set to the task or
    /// sender's audit user ID
    ///
    ///
    /// Parameter `euidp`: - Pointer to a uid_t; on return will be set to the task or
    /// sender's effective user ID
    ///
    ///
    /// Parameter `egidp`: - Pointer to a gid_t; on return will be set to the task or
    /// sender's effective group ID
    ///
    ///
    /// Parameter `ruidp`: - Pointer to a uid_t; on return will be set to the task or
    /// sender's real user ID
    ///
    ///
    /// Parameter `rgidp`: - Pointer to a gid_t; on return will be set to the task or
    /// sender's real group ID
    ///
    ///
    /// Parameter `pidp`: - Pointer to a pid_t; on return will be set to the task or
    /// sender's process ID
    ///
    ///
    /// Parameter `asidp`: - Pointer to an au_asid_t; on return will be set to the
    /// task or sender's audit session ID
    ///
    ///
    /// Parameter `tidp`: - Pointer to an au_tid_t; on return will be set to the
    /// process ID version and NOT THE SENDER'S TERMINAL ID.
    ///
    /// XXXRW: In Apple's bsm-8, these are marked __APPLE_API_PRIVATE.
    pub fn audit_token_to_au32(
        atoken: audit_token_t,
        auidp: *mut uid_t,
        euidp: *mut uid_t,
        egidp: *mut gid_t,
        ruidp: *mut uid_t,
        rgidp: *mut gid_t,
        pidp: *mut pid_t,
        asidp: *mut au_asid_t,
        tidp: *mut au_tid_t,
    );
}

extern "C-unwind" {
    /// audit_token_to_auid()
    ///
    /// - Extract the audit user ID from an audit_token_t, used to
    /// identify Mach tasks and senders of Mach messages as subjects of the audit
    /// system.
    ///
    ///
    /// Parameter `atoken`: - The Mach audit token.
    ///
    ///
    /// Returns: - The audit user ID extracted from the Mach audit token.
    pub fn audit_token_to_auid(atoken: audit_token_t) -> uid_t;
}

extern "C-unwind" {
    /// audit_token_to_euid()
    ///
    /// - Extract the effective user ID from an audit_token_t, used to
    /// identify Mach tasks and senders of Mach messages as subjects of the audit
    /// system.
    ///
    ///
    /// Parameter `atoken`: - The Mach audit token.
    ///
    ///
    /// Returns: - The effective user ID extracted from the Mach audit token.
    pub fn audit_token_to_euid(atoken: audit_token_t) -> uid_t;
}

extern "C-unwind" {
    /// audit_token_to_egid()
    ///
    /// - Extract the effective group ID from an audit_token_t, used to
    /// identify Mach tasks and senders of Mach messages as subjects of the audit
    /// system.
    ///
    ///
    /// Parameter `atoken`: - The Mach audit token.
    ///
    ///
    /// Returns: - The effective group ID extracted from the Mach audit token.
    pub fn audit_token_to_egid(atoken: audit_token_t) -> gid_t;
}

extern "C-unwind" {
    /// audit_token_to_ruid()
    ///
    /// - Extract the real user ID from an audit_token_t, used to
    /// identify Mach tasks and senders of Mach messages as subjects of the audit
    /// system.
    ///
    ///
    /// Parameter `atoken`: - The Mach audit token.
    ///
    ///
    /// Returns: - The real user ID extracted from the Mach audit token.
    pub fn audit_token_to_ruid(atoken: audit_token_t) -> uid_t;
}

extern "C-unwind" {
    /// audit_token_to_rgid()
    ///
    /// - Extract the real group ID from an audit_token_t, used to
    /// identify Mach tasks and senders of Mach messages as subjects of the audit
    /// system.
    ///
    ///
    /// Parameter `atoken`: - The Mach audit token.
    ///
    ///
    /// Returns: - The real group ID extracted from the Mach audit token.
    pub fn audit_token_to_rgid(atoken: audit_token_t) -> gid_t;
}

extern "C-unwind" {
    /// audit_token_to_pid()
    ///
    /// - Extract the process ID from an audit_token_t, used to
    /// identify Mach tasks and senders of Mach messages as subjects of the audit
    /// system.
    ///
    ///
    /// Parameter `atoken`: - The Mach audit token.
    ///
    ///
    /// Returns: - The process ID extracted from the Mach audit token.
    pub fn audit_token_to_pid(atoken: audit_token_t) -> pid_t;
}

extern "C-unwind" {
    /// audit_token_to_asid()
    ///
    /// - Extract the audit session ID from an audit_token_t, used to
    /// identify Mach tasks and senders of Mach messages as subjects of the audit
    /// system.
    ///
    ///
    /// Parameter `atoken`: - The Mach audit token.
    ///
    ///
    /// Returns: - The audit session ID extracted from the Mach audit token.
    pub fn audit_token_to_asid(atoken: audit_token_t) -> au_asid_t;
}

extern "C-unwind" {
    /// audit_token_to_pidversion()
    ///
    /// - Extract the process ID version from an audit_token_t, used to
    /// identify Mach tasks and senders of Mach messages as subjects of the audit
    /// system.
    ///
    ///
    /// Parameter `atoken`: - The Mach audit token.
    ///
    ///
    /// Returns: - The process ID version extracted from the Mach audit token.
    pub fn audit_token_to_pidversion(atoken: audit_token_t) -> c_int;
}

extern "C-unwind" {
    /// Wrapper functions to auditon(2).
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_car(path: *mut c_char, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_class(evc_map: *mut au_evclass_map_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_set_class(evc_map: *mut au_evclass_map_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_cond(cond: *mut c_int) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_set_cond(cond: *mut c_int) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_cwd(path: *mut c_char, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_fsize(fstat: *mut au_fstat_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_set_fsize(fstat: *mut au_fstat_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_kmask(kmask: *mut au_mask_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_set_kmask(kmask: *mut au_mask_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_kaudit(aia: *mut auditinfo_addr_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_set_kaudit(aia: *mut auditinfo_addr_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_set_pmask(api: *mut auditpinfo_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "use audit_get_pinfo_addr"]
    pub fn audit_get_pinfo(api: *mut auditpinfo_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    pub fn audit_get_pinfo_addr(apia: *mut auditpinfo_addr_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_policy(policy: *mut c_int) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_set_policy(policy: *mut c_int) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_qctrl(qctrl: *mut au_qctrl_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_set_qctrl(qctrl: *mut au_qctrl_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    pub fn audit_get_sflags(flags: *mut u64) -> c_int;
}

extern "C-unwind" {
    pub fn audit_set_sflags(flags: u64) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "no longer implemented"]
    pub fn audit_get_sflags_mask(which: *const c_char, mask: *mut u64) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "no longer implemented"]
    pub fn audit_set_sflags_mask(which: *const c_char, mask: u64) -> c_int;
}

extern "C-unwind" {
    pub fn audit_get_sinfo_addr(aia: *mut auditinfo_addr_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_stat(stats: *mut au_stat_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_set_stat(stats: *mut au_stat_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_send_trigger(trigger: *mut c_int) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_ctlmode(mode: *mut au_ctlmode_t, sz: usize) -> c_int;
}

extern "C-unwind" {
    #[deprecated = "audit is deprecated"]
    pub fn audit_get_expire_after(expire: *mut au_expire_after_t, sz: usize) -> c_int;
}
