//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
#[cfg(feature = "_platform")]
#[path = "_platform.rs"]
mod ___platform;

#[cfg(feature = "__builtin__")]
use __builtin__::*;
use core::ffi::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::ffi::*;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct _malloc_zone_t {
    pub reserved1: *mut c_void,
    pub reserved2: *mut c_void,
    pub size: Option<unsafe extern "C-unwind" fn(*mut _malloc_zone_t, *const c_void) -> usize>,
    pub malloc: Option<unsafe extern "C-unwind" fn(*mut Self, usize) -> *mut c_void>,
    pub calloc: Option<unsafe extern "C-unwind" fn(*mut Self, usize, usize) -> *mut c_void>,
    pub valloc: Option<unsafe extern "C-unwind" fn(*mut Self, usize) -> *mut c_void>,
    pub free: Option<unsafe extern "C-unwind" fn(*mut Self, *mut c_void)>,
    pub realloc: Option<unsafe extern "C-unwind" fn(*mut Self, *mut c_void, usize) -> *mut c_void>,
    pub destroy: Option<unsafe extern "C-unwind" fn(*mut Self)>,
    pub zone_name: *const c_char,
    pub batch_malloc:
        Option<unsafe extern "C-unwind" fn(*mut Self, usize, *mut *mut c_void, c_uint) -> c_uint>,
    pub batch_free: Option<unsafe extern "C-unwind" fn(*mut Self, *mut *mut c_void, c_uint)>,
    pub introspect: *mut malloc_introspection_t,
    pub version: c_uint,
    pub memalign: Option<unsafe extern "C-unwind" fn(*mut Self, usize, usize) -> *mut c_void>,
    pub free_definite_size: Option<unsafe extern "C-unwind" fn(*mut Self, *mut c_void, usize)>,
    pub pressure_relief: Option<unsafe extern "C-unwind" fn(*mut Self, usize) -> usize>,
    pub claimed_address: Option<unsafe extern "C-unwind" fn(*mut Self, *mut c_void) -> boolean_t>,
    pub try_free_default: Option<unsafe extern "C-unwind" fn(*mut Self, *mut c_void)>,
    pub malloc_with_options:
        Option<unsafe extern "C-unwind" fn(*mut Self, usize, usize, u64) -> *mut c_void>,
    pub malloc_type_malloc:
        Option<unsafe extern "C-unwind" fn(*mut Self, usize, malloc_type_id_t) -> *mut c_void>,
    pub malloc_type_calloc: Option<
        unsafe extern "C-unwind" fn(*mut Self, usize, usize, malloc_type_id_t) -> *mut c_void,
    >,
    pub malloc_type_realloc: Option<
        unsafe extern "C-unwind" fn(*mut Self, *mut c_void, usize, malloc_type_id_t) -> *mut c_void,
    >,
    pub malloc_type_memalign: Option<
        unsafe extern "C-unwind" fn(*mut Self, usize, usize, malloc_type_id_t) -> *mut c_void,
    >,
    pub malloc_type_malloc_with_options: Option<
        unsafe extern "C-unwind" fn(*mut Self, usize, usize, u64, malloc_type_id_t) -> *mut c_void,
    >,
}

pub type malloc_zone_t = Self;

/// Information about where and how malloc was called
///
///
/// Set in malloc_type_summary_v0_t if the call to malloc was called with a fixed
/// size. Note that, at present, this bit is set in all callsites where the
/// compiler rewrites a call to malloc
///
///
/// Set in malloc_type_summary_v0_t if the type being allocated is an array, e.g.
/// allocated via new[] or calloc(count, size)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct malloc_type_callsite_flags_v0_t(pub c_uint);
impl malloc_type_callsite_flags_v0_t {
    pub const MALLOC_TYPE_CALLSITE_FLAGS_V0_NONE: Self = Self(0);
    pub const MALLOC_TYPE_CALLSITE_FLAGS_V0_FIXED_SIZE: Self = Self(1 << 0);
    pub const MALLOC_TYPE_CALLSITE_FLAGS_V0_ARRAY: Self = Self(1 << 1);
}

/// Default allocation type, used for most calls to malloc
///
///
/// Marks a type allocated by libobjc
///
///
/// Marks a type allocated by the Swift runtime
///
///
/// Marks a type allocated by the C++ runtime's operator new
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct malloc_type_kind_v0_t(pub c_uint);
impl malloc_type_kind_v0_t {
    pub const MALLOC_TYPE_KIND_V0_OTHER: Self = Self(0);
    pub const MALLOC_TYPE_KIND_V0_OBJC: Self = Self(1);
    pub const MALLOC_TYPE_KIND_V0_SWIFT: Self = Self(2);
    pub const MALLOC_TYPE_KIND_V0_CXX: Self = Self(3);
}

/// Field: contains_data_pointer
/// True if the allocated type or any of its fields is a pointer
/// to a data type (i.e. the pointee contains no pointers)
///
/// Field: contains_struct_pointer
/// True if the allocated type or any of its fields is a pointer
/// to a struct or union
///
/// Field: contains_immutable_pointer
/// True if the allocated type or any of its fields is a const pointer
///
/// Field: contains_anonymous_pointer
/// True if the allocated type or any of its fields is a pointer
/// to something other than a struct or data type
///
/// Field: is_reference_counted
/// True if the allocated type is reference counted
///
/// Field: contains_generic_data
/// True if the allocated type or any of its fields are not pointers
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct malloc_type_layout_semantics_v0_t {
    pub contains_data_pointer: bool,
    pub contains_struct_pointer: bool,
    pub contains_immutable_pointer: bool,
    pub contains_anonymous_pointer: bool,
    pub is_reference_counted: bool,
    pub reserved_0: u16,
    pub contains_generic_data: bool,
    pub reserved_1: u16,
}

/// Field: version
/// Versioning field of the type summary. Set to 0 for the current verison. New
/// fields can be added where the reserved fields currently are without
/// incrementing the version, as long as they are non-breaking.
///
/// Field: callsite_flags
/// Details from the callsite of malloc inferred by the compiler
///
/// Field: type_kind
/// Details about the runtime making the allocation
///
/// Field: layout_semantics
/// Details about what kinds of data are contained in the type being allocated
///
///
/// The reserved fields should not be read from or written to, and may be
/// used for additional fields and information in future versions
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct malloc_type_summary_v0_t {
    pub version: u32,
    pub reserved_0: u32,
    pub callsite_flags: malloc_type_callsite_flags_v0_t,
    pub type_kind: malloc_type_kind_v0_t,
    pub reserved_1: u32,
    pub layout_semantics: malloc_type_layout_semantics_v0_t,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct malloc_type_descriptor_v0_t_type_id {
    pub hash: u32,
    pub summary: malloc_type_summary_v0_t,
}

/// Field: hash
/// Hash of the type layout of the allocated type, or if type inference failed,
/// the hash of the callsite's file, line and column. The hash allows the
/// allocator to disambiguate between different types with the same summary, e.g.
/// types that have the same fields in different orders.
///
/// Field: summary
/// Details of the type being allocated
///
/// Field: type_id
/// opaque type used for punning
///
///
/// Use malloc_type_descriptor_v0_t to decode the opaque malloc_type_id_t with
/// version == 0 into a malloc_type_summary_v0_t:
///
/// <code>
/// malloc_type_descriptor_v0_t desc = (malloc_type_descriptor_v0_t){ .type_id = id };
/// </code>
///
/// See LLVM documentation for more details
#[repr(C)]
#[derive(Clone, Copy)]
pub union malloc_type_descriptor_v0_t {
    pub type_id: malloc_type_id_t,
}

/// *******    Creation and destruction    ***********
#[inline]
pub unsafe extern "C-unwind" fn malloc_default_zone() -> Option<Retained<malloc_zone_t>> {
    extern "C-unwind" {
        fn malloc_default_zone() -> *mut malloc_zone_t;
    }
    let ret = unsafe { malloc_default_zone() };
    unsafe { Retained::retain_autoreleased(ret) }
}

#[inline]
pub unsafe extern "C-unwind" fn malloc_create_zone(
    start_size: vm_size_t,
    flags: c_uint,
) -> Option<Retained<malloc_zone_t>> {
    extern "C-unwind" {
        fn malloc_create_zone(start_size: vm_size_t, flags: c_uint) -> *mut malloc_zone_t;
    }
    let ret = unsafe { malloc_create_zone(start_size, flags) };
    unsafe { Retained::from_raw(ret) }
}

extern "C-unwind" {
    pub fn malloc_destroy_zone(zone: Option<&malloc_zone_t>);
}

extern "C-unwind" {
    /// *******    Block creation and manipulation    ***********
    pub fn malloc_zone_malloc(zone: Option<&malloc_zone_t>, size: usize) -> *mut c_void;
}

extern "C-unwind" {
    pub fn malloc_zone_calloc(
        zone: Option<&malloc_zone_t>,
        num_items: usize,
        size: usize,
    ) -> *mut c_void;
}

extern "C-unwind" {
    pub fn malloc_zone_valloc(zone: Option<&malloc_zone_t>, size: usize) -> *mut c_void;
}

extern "C-unwind" {
    pub fn malloc_zone_free(zone: Option<&malloc_zone_t>, ptr: *mut c_void);
}

extern "C-unwind" {
    pub fn malloc_zone_realloc(
        zone: Option<&malloc_zone_t>,
        ptr: *mut c_void,
        size: usize,
    ) -> *mut c_void;
}

#[inline]
pub unsafe extern "C-unwind" fn malloc_zone_from_ptr(
    ptr: *const c_void,
) -> Option<Retained<malloc_zone_t>> {
    extern "C-unwind" {
        fn malloc_zone_from_ptr(ptr: *const c_void) -> *mut malloc_zone_t;
    }
    let ret = unsafe { malloc_zone_from_ptr(ptr) };
    unsafe { Retained::retain_autoreleased(ret) }
}

extern "C-unwind" {
    pub fn malloc_size(ptr: *const c_void) -> usize;
}

extern "C-unwind" {
    pub fn malloc_good_size(size: usize) -> usize;
}

extern "C-unwind" {
    pub fn malloc_zone_memalign(
        zone: Option<&malloc_zone_t>,
        alignment: usize,
        size: usize,
    ) -> *mut c_void;
}

extern "C-unwind" {
    pub fn malloc_zone_batch_malloc(
        zone: Option<&malloc_zone_t>,
        size: usize,
        results: *mut *mut c_void,
        num_requested: c_uint,
    ) -> c_uint;
}

extern "C-unwind" {
    pub fn malloc_zone_batch_free(
        zone: Option<&malloc_zone_t>,
        to_be_freed: *mut *mut c_void,
        num: c_uint,
    );
}

#[inline]
pub unsafe extern "C-unwind" fn malloc_default_purgeable_zone() -> Option<Retained<malloc_zone_t>> {
    extern "C-unwind" {
        fn malloc_default_purgeable_zone() -> *mut malloc_zone_t;
    }
    let ret = unsafe { malloc_default_purgeable_zone() };
    unsafe { Retained::retain_autoreleased(ret) }
}

extern "C-unwind" {
    pub fn malloc_make_purgeable(ptr: *mut c_void);
}

extern "C-unwind" {
    pub fn malloc_make_nonpurgeable(ptr: *mut c_void) -> c_int;
}

extern "C-unwind" {
    pub fn malloc_zone_register(zone: Option<&malloc_zone_t>);
}

extern "C-unwind" {
    pub fn malloc_zone_unregister(zone: Option<&malloc_zone_t>);
}

extern "C-unwind" {
    pub fn malloc_set_zone_name(zone: Option<&malloc_zone_t>, name: *const c_char);
}

extern "C-unwind" {
    pub fn malloc_get_zone_name(zone: Option<&malloc_zone_t>) -> *const c_char;
}

extern "C-unwind" {
    pub fn malloc_zone_pressure_relief(zone: Option<&malloc_zone_t>, goal: usize) -> usize;
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct vm_range_t {
    pub address: vm_address_t,
    pub size: vm_size_t,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct malloc_statistics_t {
    pub blocks_in_use: c_uint,
    pub size_in_use: usize,
    pub max_size_in_use: usize,
    pub size_allocated: usize,
}

pub type memory_reader_t = core::ffi::c_void;

pub type vm_range_recorder_t = core::ffi::c_void;

pub type print_task_printer_t = core::ffi::c_void;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct malloc_introspection_t {
    pub enumerator: Option<
        unsafe extern "C-unwind" fn(
            task_t,
            *mut c_void,
            c_uint,
            vm_address_t,
            memory_reader_t,
            vm_range_recorder_t,
        ) -> kern_return_t,
    >,
    pub good_size: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t, usize) -> usize>,
    pub check: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t) -> boolean_t>,
    pub print: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t, boolean_t)>,
    pub log: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t, *mut c_void)>,
    pub force_lock: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t)>,
    pub force_unlock: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t)>,
    pub statistics:
        Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t, *mut malloc_statistics_t)>,
    pub zone_locked: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t) -> boolean_t>,
    pub enable_discharge_checking:
        Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t) -> boolean_t>,
    pub disable_discharge_checking: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t)>,
    pub discharge: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t, *mut c_void)>,
    pub enumerate_discharged_pointers: Option<
        unsafe extern "C-unwind" fn(
            *mut malloc_zone_t,
            *mut block2::Block<dyn Fn(*mut c_void, *mut c_void)>,
        ),
    >,
    pub reinit_lock: Option<unsafe extern "C-unwind" fn(*mut malloc_zone_t)>,
    pub print_task: Option<
        unsafe extern "C-unwind" fn(
            task_t,
            c_uint,
            vm_address_t,
            memory_reader_t,
            print_task_printer_t,
        ),
    >,
    pub task_statistics: Option<
        unsafe extern "C-unwind" fn(
            task_t,
            vm_address_t,
            memory_reader_t,
            *mut malloc_statistics_t,
        ),
    >,
    pub zone_type: c_uint,
}

extern "C-unwind" {
    pub fn malloc_get_all_zones(
        task: task_t,
        reader: memory_reader_t,
        addresses: *mut *mut vm_address_t,
        count: *mut c_uint,
    ) -> kern_return_t;
}

extern "C-unwind" {
    /// *******    Debug helpers    ***********
    pub fn malloc_zone_print_ptr_info(ptr: *mut c_void);
}

#[inline]
pub unsafe extern "C-unwind" fn malloc_zone_check(zone: Option<&malloc_zone_t>) -> bool {
    extern "C-unwind" {
        fn malloc_zone_check(zone: Option<&malloc_zone_t>) -> boolean_t;
    }
    let ret = unsafe { malloc_zone_check(zone) };
    ret != 0
}

#[inline]
pub unsafe extern "C-unwind" fn malloc_zone_print(zone: Option<&malloc_zone_t>, verbose: bool) {
    extern "C-unwind" {
        fn malloc_zone_print(zone: Option<&malloc_zone_t>, verbose: boolean_t);
    }
    unsafe { malloc_zone_print(zone, verbose as _) }
}

extern "C-unwind" {
    pub fn malloc_zone_statistics(zone: Option<&malloc_zone_t>, stats: *mut malloc_statistics_t);
}

extern "C-unwind" {
    pub fn malloc_zone_log(zone: Option<&malloc_zone_t>, address: *mut c_void);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct mstats {
    pub bytes_total: usize,
    pub chunks_used: usize,
    pub bytes_used: usize,
    pub chunks_free: usize,
    pub bytes_free: usize,
}

extern "C-unwind" {
    pub fn mstats() -> mstats;
}

#[inline]
pub unsafe extern "C-unwind" fn malloc_zone_enable_discharge_checking(
    zone: Option<&malloc_zone_t>,
) -> bool {
    extern "C-unwind" {
        fn malloc_zone_enable_discharge_checking(zone: Option<&malloc_zone_t>) -> boolean_t;
    }
    let ret = unsafe { malloc_zone_enable_discharge_checking(zone) };
    ret != 0
}

extern "C-unwind" {
    pub fn malloc_zone_disable_discharge_checking(zone: Option<&malloc_zone_t>);
}

extern "C-unwind" {
    pub fn malloc_zone_discharge(zone: Option<&malloc_zone_t>, memory: *mut c_void);
}

extern "C-unwind" {
    pub fn malloc_zone_enumerate_discharged_pointers(
        zone: Option<&malloc_zone_t>,
        report_discharged: Option<&block2::Block<dyn Fn(*mut c_void, *mut c_void)>>,
    );
}
