//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;

use crate::ffi::*;

/// [Apple's documentation](https://developer.apple.com/documentation/darwin/os_function_t?language=objc)
pub type os_function_t = Option<unsafe extern "C-unwind" fn(*mut c_void)>;

/// Generic type for a block taking no arguments and returning no value.
///
///
/// When not building with Objective-C ARC, a block object allocated on or
/// copied to the heap must be released with a -[release] message or the
/// Block_release() function.
///
/// The declaration of a block literal allocates storage on the stack.
/// Therefore, this is an invalid construct:
/// <code>
/// os_block_t block;
/// if (x) {
/// block = ^{ printf("true\n"); };
/// } else {
/// block = ^{ printf("false\n"); };
/// }
/// block(); // unsafe!!!
/// </code>
///
/// What is happening behind the scenes:
/// <code>
/// if (x) {
/// struct Block __tmp_1 = ...; // setup details
/// block =
/// &
/// __tmp_1;
/// } else {
/// struct Block __tmp_2 = ...; // setup details
/// block =
/// &
/// __tmp_2;
/// }
/// </code>
///
/// As the example demonstrates, the address of a stack variable is escaping the
/// scope in which it is allocated. That is a classic C bug.
///
/// Instead, the block literal must be copied to the heap with the Block_copy()
/// function or by sending it a -[copy] message.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/darwin/os_block_t?language=objc)
pub type os_block_t = *mut block2::Block<dyn Fn()>;
