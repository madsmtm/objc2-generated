//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;

use crate::ffi::*;

/// [Apple's documentation](https://developer.apple.com/documentation/darwin/os_lock_api_version?language=objc)
pub const OS_LOCK_API_VERSION: c_uint = 20160309;
/// Low-level lock that allows waiters to block efficiently on contention.
///
/// os_unfair_lock is an appropriate lock for cases where simple and lightweight
/// mutual exclusion is needed.
/// It can be intrusively stored inline in a datastructure without needing a
/// separate allocation, reducing memory consumption and cost of indirection.
/// For situations where something more sophisticated like condition waits or
/// FIFO ordering is needed, use appropriate higher level APIs such as those from
/// the pthread or dispatch subsystems.
///
/// The values stored in the lock should be considered opaque and implementation
/// defined, they contain thread ownership information that the system may use
/// to attempt to resolve priority inversions.
///
/// This lock must be unlocked from the same thread that locked it, attempts to
/// unlock from a different thread will cause an assertion aborting the process.
///
/// This lock must not be accessed from multiple processes or threads via shared
/// or multiply-mapped memory, because the lock implementation relies on the
/// address of the lock value and identity of the owning process.
///
/// Must be initialized with OS_UNFAIR_LOCK_INIT.
///
///
/// The name 'unfair' indicates that there is no attempt at enforcing acquisition
/// fairness, e.g. an unlocker can potentially immediately reacquire the lock
/// before a woken up waiter gets an opportunity to attempt to acquire the lock.
/// This is often advantageous for performance reasons, but also makes starvation
/// of waiters a possibility.
///
/// This lock is suitable as a drop-in replacement for the deprecated OSSpinLock,
/// providing much better behavior under contention.
///
/// In Swift, note that use of the `
/// &
/// ` operator on an unfair lock can copy or move
/// the lock memory, leading to misbehavior. Use an OSAllocatedUnfairLock to safely wrap
/// access to the lock memory instead. If you use os_unfair_lock APIs directly,
/// always make sure to store and use the lock in memory with a stable address.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/darwin/os_unfair_lock_s?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct os_unfair_lock_s {
    pub(crate) _os_unfair_lock_opaque: u32,
}

/// Low-level lock that allows waiters to block efficiently on contention.
///
/// os_unfair_lock is an appropriate lock for cases where simple and lightweight
/// mutual exclusion is needed.
/// It can be intrusively stored inline in a datastructure without needing a
/// separate allocation, reducing memory consumption and cost of indirection.
/// For situations where something more sophisticated like condition waits or
/// FIFO ordering is needed, use appropriate higher level APIs such as those from
/// the pthread or dispatch subsystems.
///
/// The values stored in the lock should be considered opaque and implementation
/// defined, they contain thread ownership information that the system may use
/// to attempt to resolve priority inversions.
///
/// This lock must be unlocked from the same thread that locked it, attempts to
/// unlock from a different thread will cause an assertion aborting the process.
///
/// This lock must not be accessed from multiple processes or threads via shared
/// or multiply-mapped memory, because the lock implementation relies on the
/// address of the lock value and identity of the owning process.
///
/// Must be initialized with OS_UNFAIR_LOCK_INIT.
///
///
/// The name 'unfair' indicates that there is no attempt at enforcing acquisition
/// fairness, e.g. an unlocker can potentially immediately reacquire the lock
/// before a woken up waiter gets an opportunity to attempt to acquire the lock.
/// This is often advantageous for performance reasons, but also makes starvation
/// of waiters a possibility.
///
/// This lock is suitable as a drop-in replacement for the deprecated OSSpinLock,
/// providing much better behavior under contention.
///
/// In Swift, note that use of the `
/// &
/// ` operator on an unfair lock can copy or move
/// the lock memory, leading to misbehavior. Use an OSAllocatedUnfairLock to safely wrap
/// access to the lock memory instead. If you use os_unfair_lock APIs directly,
/// always make sure to store and use the lock in memory with a stable address.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/darwin/os_unfair_lock?language=objc)
pub type os_unfair_lock = libc::os_unfair_lock_s;

/// Low-level lock that allows waiters to block efficiently on contention.
///
/// os_unfair_lock is an appropriate lock for cases where simple and lightweight
/// mutual exclusion is needed.
/// It can be intrusively stored inline in a datastructure without needing a
/// separate allocation, reducing memory consumption and cost of indirection.
/// For situations where something more sophisticated like condition waits or
/// FIFO ordering is needed, use appropriate higher level APIs such as those from
/// the pthread or dispatch subsystems.
///
/// The values stored in the lock should be considered opaque and implementation
/// defined, they contain thread ownership information that the system may use
/// to attempt to resolve priority inversions.
///
/// This lock must be unlocked from the same thread that locked it, attempts to
/// unlock from a different thread will cause an assertion aborting the process.
///
/// This lock must not be accessed from multiple processes or threads via shared
/// or multiply-mapped memory, because the lock implementation relies on the
/// address of the lock value and identity of the owning process.
///
/// Must be initialized with OS_UNFAIR_LOCK_INIT.
///
///
/// The name 'unfair' indicates that there is no attempt at enforcing acquisition
/// fairness, e.g. an unlocker can potentially immediately reacquire the lock
/// before a woken up waiter gets an opportunity to attempt to acquire the lock.
/// This is often advantageous for performance reasons, but also makes starvation
/// of waiters a possibility.
///
/// This lock is suitable as a drop-in replacement for the deprecated OSSpinLock,
/// providing much better behavior under contention.
///
/// In Swift, note that use of the `
/// &
/// ` operator on an unfair lock can copy or move
/// the lock memory, leading to misbehavior. Use an OSAllocatedUnfairLock to safely wrap
/// access to the lock memory instead. If you use os_unfair_lock APIs directly,
/// always make sure to store and use the lock in memory with a stable address.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/darwin/os_unfair_lock_t?language=objc)
pub type os_unfair_lock_t = *mut libc::os_unfair_lock_s;

extern "C-unwind" {
    /// Locks an os_unfair_lock.
    ///
    ///
    /// Parameter `lock`: Pointer to an os_unfair_lock.
    pub fn os_unfair_lock_lock(lock: libc::os_unfair_lock_t);
}

extern "C-unwind" {
    /// Locks an os_unfair_lock if it is not already locked.
    ///
    ///
    /// It is invalid to surround this function with a retry loop, if this function
    /// returns false, the program must be able to proceed without having acquired
    /// the lock, or it must call os_unfair_lock_lock() directly (a retry loop around
    /// os_unfair_lock_trylock() amounts to an inefficient implementation of
    /// os_unfair_lock_lock() that hides the lock waiter from the system and prevents
    /// resolution of priority inversions).
    ///
    ///
    /// Parameter `lock`: Pointer to an os_unfair_lock.
    ///
    ///
    /// Returns: Returns true if the lock was succesfully locked and false if the lock was
    /// already locked.
    #[must_use]
    pub fn os_unfair_lock_trylock(lock: libc::os_unfair_lock_t) -> bool;
}

extern "C-unwind" {
    /// Unlocks an os_unfair_lock.
    ///
    ///
    /// Parameter `lock`: Pointer to an os_unfair_lock.
    pub fn os_unfair_lock_unlock(lock: libc::os_unfair_lock_t);
}

extern "C-unwind" {
    /// Asserts that the calling thread is the current owner of the specified
    /// unfair lock.
    ///
    ///
    /// If the lock is currently owned by the calling thread, this function returns.
    ///
    /// If the lock is unlocked or owned by a different thread, this function
    /// asserts and terminates the process.
    ///
    ///
    /// Parameter `lock`: Pointer to an os_unfair_lock.
    pub fn os_unfair_lock_assert_owner(lock: NonNull<libc::os_unfair_lock>);
}

extern "C-unwind" {
    /// Asserts that the calling thread is not the current owner of the specified
    /// unfair lock.
    ///
    ///
    /// If the lock is unlocked or owned by a different thread, this function
    /// returns.
    ///
    /// If the lock is currently owned by the current thread, this function asserts
    /// and terminates the process.
    ///
    ///
    /// Parameter `lock`: Pointer to an os_unfair_lock.
    pub fn os_unfair_lock_assert_not_owner(lock: NonNull<libc::os_unfair_lock>);
}

/// [Apple's documentation](https://developer.apple.com/documentation/darwin/os_unfair_lock_flags_t?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct os_unfair_lock_flags_t(pub u32);
bitflags::bitflags! {
    impl os_unfair_lock_flags_t: u32 {
        const OS_UNFAIR_LOCK_FLAG_NONE = 0x00000000;
        const OS_UNFAIR_LOCK_FLAG_ADAPTIVE_SPIN = 0x00040000;
    }
}

extern "C-unwind" {
    /// Locks an os_unfair_lock.
    ///
    ///
    /// Parameter `lock`: Pointer to an os_unfair_lock.
    ///
    ///
    /// Parameter `flags`: Flags to alter the behavior of the lock. See os_unfair_lock_flags_t.
    pub fn os_unfair_lock_lock_with_flags(
        lock: libc::os_unfair_lock_t,
        flags: libc::os_unfair_lock_flags_t,
    );
}
