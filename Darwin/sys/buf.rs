//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
#[cfg(feature = "__builtin__")]
use __builtin__::*;
use core::ffi::*;

use crate::ffi::*;

extern "C-unwind" {
    /// Mark a buffer as "aged," i.e. as a good candidate to be discarded and reused after buf_brelse().
    ///
    /// Parameter `bp`: Buffer to mark.
    pub fn buf_markaged(bp: buf_t);
}

extern "C-unwind" {
    /// Mark a buffer as not having valid data and being ready for immediate reuse after buf_brelse().
    ///
    /// Parameter `bp`: Buffer to mark.
    pub fn buf_markinvalid(bp: buf_t);
}

extern "C-unwind" {
    /// Mark a buffer as a delayed write: mark it dirty without actually scheduling I/O.
    ///
    /// Data will be flushed to disk at some later time, not with brelse(). A sync()/fsync()
    /// or pressure necessitating reuse of the buffer will cause it to be written back to disk.
    ///
    /// Parameter `bp`: Buffer to mark.
    pub fn buf_markdelayed(bp: buf_t);
}

extern "C-unwind" {
    pub fn buf_markclean(param1: buf_t);
}

extern "C-unwind" {
    /// Mark a buffer as having been interrupted during I/O.
    ///
    /// Waiters for I/O to complete (buf_biowait()) will return with EINTR when woken up.
    /// buf_markeintr does not itself do a wakeup.
    ///
    /// Parameter `bp`: Buffer to mark.
    pub fn buf_markeintr(bp: buf_t);
}

extern "C-unwind" {
    /// Mark a buffer for write through disk cache, if disk supports it.
    ///
    /// Parameter `bp`: Buffer to mark.
    pub fn buf_markfua(bp: buf_t);
}

extern "C-unwind" {
    /// Check if a buffer is marked for write through disk caches.
    ///
    /// Parameter `bp`: Buffer to test.
    ///
    /// Returns: Nonzero if buffer is marked for write-through, 0 if not.
    pub fn buf_fua(bp: buf_t) -> c_int;
}

extern "C-unwind" {
    /// Check if a buffer contains valid data.
    ///
    /// Parameter `bp`: Buffer to test.
    ///
    /// Returns: Nonzero if buffer has valid data, 0 if not.
    pub fn buf_valid(bp: buf_t) -> c_int;
}

extern "C-unwind" {
    /// Check if a buffer's data was found in core.
    ///
    /// Will return truth after a buf_getblk that finds a valid buffer in the cache or the relevant
    /// data in core (but not in a buffer).
    ///
    /// Parameter `bp`: Buffer to test.
    ///
    /// Returns: Nonzero if we got this buffer's data without doing I/O, 0 if not.
    pub fn buf_fromcache(bp: buf_t) -> c_int;
}

extern "C-unwind" {
    /// Get the upl (Universal Page List) associated with a buffer.
    ///
    /// Buffers allocated with buf_alloc() are not returned with a upl, and
    /// traditional buffers only have a upl while an I/O is in progress.
    ///
    /// Parameter `bp`: Buffer whose upl to grab.
    ///
    /// Returns: Buffer's upl if it has one, else NULL.
    pub fn buf_upl(bp: buf_t) -> *mut c_void;
}

extern "C-unwind" {
    /// Get the offset into a UPL at which this buffer begins.
    ///
    /// This function should only be called on iobufs, i.e. buffers allocated with buf_alloc().
    ///
    /// Parameter `bp`: Buffer whose uploffset to grab.
    ///
    /// Returns: Buffer's uploffset--does not check whether that value makes sense for this buffer.
    pub fn buf_uploffset(bp: buf_t) -> u32;
}

extern "C-unwind" {
    /// Get the credential associated with a buffer for reading.
    ///
    /// No reference is taken; if the credential is to be held on to persistently, an additional
    /// reference must be taken with kauth_cred_ref.
    ///
    /// Parameter `bp`: Buffer whose credential to grab.
    ///
    /// Returns: Credential if it exists, else NULL.
    pub fn buf_rcred(bp: buf_t) -> kauth_cred_t;
}

extern "C-unwind" {
    /// Get the credential associated with a buffer for writing.
    ///
    /// No reference is taken; if the credential is to be held on to persistently, an additional
    /// reference must be taken with kauth_cred_ref.
    ///
    /// Parameter `bp`: Buffer whose credential to grab.
    ///
    /// Returns: Credential if it exists, else NULL.
    pub fn buf_wcred(bp: buf_t) -> kauth_cred_t;
}

extern "C-unwind" {
    /// Get the process associated with this buffer.
    ///
    /// buf_proc() will generally return NULL; a process is currently only associated with
    /// a buffer in the event of a physio() call.
    ///
    /// Parameter `bp`: Buffer whose associated process to find.
    ///
    /// Returns: Associated process, possibly NULL.
    pub fn buf_proc(bp: buf_t) -> proc_t;
}

extern "C-unwind" {
    /// Get the starting offset of the dirty region associated with a buffer.
    ///
    /// The dirty offset is zero unless someone explicitly calls buf_setdirtyoff() (which the kernel does not).
    ///
    /// Parameter `bp`: Buffer whose dirty offset to get.
    ///
    /// Returns: Dirty offset (0 if not explicitly changed).
    pub fn buf_dirtyoff(bp: buf_t) -> u32;
}

extern "C-unwind" {
    /// Get the ending offset of the dirty region associated with a buffer.
    ///
    /// If the buffer's data was found incore and dirty, the dirty end is the size of the block; otherwise, unless
    /// someone outside of xnu explicitly changes it by calling buf_setdirtyend(), it will be zero.
    ///
    /// Parameter `bp`: Buffer whose dirty end to get.
    ///
    /// Returns: 0 if buffer is found clean; size of buffer if found dirty.  Can be set to any value by callers of buf_setdirtyend().
    pub fn buf_dirtyend(bp: buf_t) -> u32;
}

extern "C-unwind" {
    /// Set the starting offset of the dirty region associated with a buffer.
    ///
    /// This value is zero unless someone set it explicitly.
    ///
    /// Parameter `bp`: Buffer whose dirty end to set.
    pub fn buf_setdirtyoff(bp: buf_t, param1: u32);
}

extern "C-unwind" {
    /// Set the ending offset of the dirty region associated with a buffer.
    ///
    /// If the buffer's data was found incore and dirty, the dirty end is the size of the block; otherwise, unless
    /// someone outside of xnu explicitly changes it by calling buf_setdirtyend(), it will be zero.
    ///
    /// Parameter `bp`: Buffer whose dirty end to set.
    pub fn buf_setdirtyend(bp: buf_t, param1: u32);
}

extern "C-unwind" {
    /// Get the error value associated with a buffer.
    ///
    /// Errors are set with buf_seterror().
    ///
    /// Parameter `bp`: Buffer whose error value to retrieve.
    ///
    /// Returns: Error value, directly.
    pub fn buf_error(bp: buf_t) -> errno_t;
}

extern "C-unwind" {
    /// Set an error value on a buffer.
    ///
    /// Parameter `bp`: Buffer whose error value to set.
    pub fn buf_seterror(bp: buf_t, param1: errno_t);
}

extern "C-unwind" {
    /// Set flags on a buffer.
    ///
    /// buffer_flags |= flags
    ///
    /// Parameter `bp`: Buffer whose flags to set.
    ///
    /// Parameter `flags`: Flags to add to buffer's mask. B_LOCKED/B_NOCACHE/B_ASYNC/B_READ/B_WRITE/B_PAGEIO/B_FUA
    pub fn buf_setflags(bp: buf_t, flags: i32);
}

extern "C-unwind" {
    /// Clear flags on a buffer.
    ///
    /// buffer_flags
    /// &
    /// = ~flags
    ///
    /// Parameter `bp`: Buffer whose flags to clear.
    ///
    /// Parameter `flags`: Flags to remove from buffer's mask. B_LOCKED/B_NOCACHE/B_ASYNC/B_READ/B_WRITE/B_PAGEIO/B_FUA
    pub fn buf_clearflags(bp: buf_t, flags: i32);
}

extern "C-unwind" {
    /// Get flags set on a buffer.
    ///
    /// Valid flags are B_LOCKED/B_NOCACHE/B_ASYNC/B_READ/B_WRITE/B_PAGEIO/B_FUA.
    ///
    /// Parameter `bp`: Buffer whose flags to grab.
    ///
    /// Returns: flags.
    pub fn buf_flags(bp: buf_t) -> i32;
}

extern "C-unwind" {
    /// Reset I/O flag state on a buffer.
    ///
    /// Clears current flags on a buffer (internal and external) and allows some new flags to be set.
    /// Used perhaps to prepare an iobuf for reuse.
    ///
    /// Parameter `bp`: Buffer whose flags to grab.
    ///
    /// Parameter `flags`: Flags to set on buffer: B_READ, B_WRITE, B_ASYNC, B_NOCACHE.
    pub fn buf_reset(bp: buf_t, flags: i32);
}

extern "C-unwind" {
    /// Get virtual mappings for buffer data.
    ///
    /// For buffers created through buf_getblk() (i.e. traditional buffer cache usage),
    /// buf_map() just returns the address at which data was mapped by but_getblk().  For a B_CLUSTER buffer, i.e. an iobuf
    /// whose upl state is managed manually, there are two possibilities.  If the buffer was created
    /// with an underlying "real" buffer through cluster_bp(), the mapping of the "real" buffer is returned.
    /// Otherwise, the buffer was created with buf_alloc() and buf_setupl() was subsequently called; buf_map()
    /// will call ubc_upl_map() to get a mapping for the buffer's upl and return the start of that mapping
    /// plus the buffer's upl offset (set in buf_setupl()).  In the last case, buf_unmap() must later be called
    /// to tear down the mapping.  NOTE: buf_map() does not set the buffer data pointer; this must be done with buf_setdataptr().
    ///
    /// Parameter `bp`: Buffer whose mapping to find or create.
    ///
    /// Parameter `io_addr`: Destination for mapping address.
    ///
    /// Returns: 0 for success, ENOMEM if unable to map the buffer.
    pub fn buf_map(bp: buf_t, io_addr: *mut caddr_t) -> errno_t;
}

extern "C-unwind" {
    /// Get virtual mappings for buffer data.
    ///
    /// Similar to buf_map but the focus is on a range
    /// of the UPL. The b_uploffset and b_count control what part of the UPL will be mapped.
    /// This function is paired with buf_unmap_range which must be called from the same
    /// thread.
    ///
    /// Parameter `bp`: Buffer whose mapping to find or create.
    ///
    /// Parameter `io_addr`: Destination for mapping address.
    ///
    /// Returns: 0 for success, ENOMEM if unable to map the buffer.
    pub fn buf_map_range(bp: buf_t, io_addr: *mut caddr_t) -> errno_t;
}

extern "C-unwind" {
    /// Get virtual mappings for buffer data.
    ///
    /// Similar to buf_map_range but also takes protection so that part of the UPL
    /// will be mapped with the requested protection.
    /// This function is paired with buf_unmap_range which must be called from the same
    /// thread.
    ///
    /// Parameter `bp`: Buffer whose mapping to find or create.
    ///
    /// Parameter `io_addr`: Destination for mapping address.
    ///
    /// Returns: 0 for success, ENOMEM if unable to map the buffer.
    pub fn buf_map_range_with_prot(bp: buf_t, io_addr: *mut caddr_t, prot: vm_prot_t) -> errno_t;
}

extern "C-unwind" {
    /// Release mappings for buffer data.
    ///
    /// For buffers created through buf_getblk() (i.e. traditional buffer cache usage),
    /// buf_unmap() does nothing; buf_brelse() will take care of unmapping.  For a B_CLUSTER buffer, i.e. an iobuf
    /// whose upl state is managed manually, there are two possibilities.  If the buffer was created
    /// with an underlying "real" buffer through cluster_bp(), buf_unmap() does nothing; buf_brelse() on the
    /// underlying buffer will tear down the mapping. Otherwise, the buffer was created with buf_alloc() and
    /// buf_setupl() was subsequently called; buf_map() created the mapping.  In this case, buf_unmap() will
    /// unmap the buffer.
    ///
    /// Parameter `bp`: Buffer whose mapping to find or create.
    ///
    /// Returns: 0 for success, EINVAL if unable to unmap buffer.
    pub fn buf_unmap(bp: buf_t) -> errno_t;
}

extern "C-unwind" {
    /// Release mappings for buffer data.
    ///
    /// Similar to buf_unmap but the focus is on a range
    /// of the UPL. The b_uploffset and b_count control what part of the UPL will be unmapped.
    /// This function must be called from the same thread that called the corresponding
    /// buf_map_range/buf_map_range_with_prot.
    ///
    /// Parameter `bp`: Buffer whose mapping to find or create.
    ///
    /// Returns: 0 for success, EINVAL if unable to unmap buffer.
    pub fn buf_unmap_range(bp: buf_t) -> errno_t;
}

extern "C-unwind" {
    /// Set driver-specific data on a buffer.
    ///
    /// Parameter `bp`: Buffer whose driver-data to set.
    ///
    /// Parameter `drvdata`: Opaque driver data.
    pub fn buf_setdrvdata(bp: buf_t, drvdata: *mut c_void);
}

extern "C-unwind" {
    /// Get driver-specific data from a buffer.
    ///
    /// Parameter `bp`: Buffer whose driver data to get.
    ///
    /// Returns: Opaque driver data.
    pub fn buf_drvdata(bp: buf_t) -> *mut c_void;
}

extern "C-unwind" {
    /// Set filesystem-specific data on a buffer.
    ///
    /// Parameter `bp`: Buffer whose filesystem data to set.
    ///
    /// Parameter `fsprivate`: Opaque filesystem data.
    pub fn buf_setfsprivate(bp: buf_t, fsprivate: *mut c_void);
}

extern "C-unwind" {
    /// Get filesystem-specific data from a buffer.
    ///
    /// Parameter `bp`: Buffer whose filesystem data to get.
    ///
    /// Returns: Opaque filesystem data.
    pub fn buf_fsprivate(bp: buf_t) -> *mut c_void;
}

extern "C-unwind" {
    /// Get physical block number associated with a buffer, in the sense of VNOP_BLOCKMAP.
    ///
    /// When a buffer's physical block number is the same is its logical block number, then the physical
    /// block number is considered uninitialized.  A physical block number of -1 indicates that there is no valid
    /// physical mapping (e.g. the logical block is invalid or corresponds to a sparse region in a file).  Physical
    /// block number is normally set by the cluster layer or by buf_getblk().
    ///
    /// Parameter `bp`: Buffer whose physical block number to get.
    ///
    /// Returns: Block number.
    pub fn buf_blkno(bp: buf_t) -> daddr64_t;
}

extern "C-unwind" {
    /// Get logical block number associated with a buffer.
    ///
    /// Logical block number is set on traditionally-used buffers by an argument passed to buf_getblk(),
    /// for example by buf_bread().
    ///
    /// Parameter `bp`: Buffer whose logical block number to get.
    ///
    /// Returns: Block number.
    pub fn buf_lblkno(bp: buf_t) -> daddr64_t;
}

extern "C-unwind" {
    /// Get the block size used to calculate the logical block number associated with a buffer.
    ///
    /// Logical block number is set on traditionally-used buffers by an argument passed to buf_getblk(),
    /// for example by buf_bread(). Block size is the block size used to calculate the file offset.
    ///
    /// Parameter `bp`: Buffer whose logical block size to get.
    ///
    /// Returns: Block size.
    pub fn buf_lblksize(bp: buf_t) -> u32;
}

extern "C-unwind" {
    /// Set physical block number associated with a buffer.
    ///
    /// Physical block number is generally set by the cluster layer or by buf_getblk().
    ///
    /// Parameter `bp`: Buffer whose physical block number to set.
    ///
    /// Parameter `blkno`: Block number to set.
    pub fn buf_setblkno(bp: buf_t, blkno: daddr64_t);
}

extern "C-unwind" {
    /// Set logical block number associated with a buffer.
    ///
    /// Logical block number is set on traditionally-used buffers by an argument passed to buf_getblk(),
    /// for example by buf_bread().
    ///
    /// Parameter `bp`: Buffer whose logical block number to set.
    ///
    /// Parameter `lblkno`: Block number to set.
    pub fn buf_setlblkno(bp: buf_t, lblkno: daddr64_t);
}

extern "C-unwind" {
    /// Set block size used to set the logical block number associated with a buffer.
    ///
    /// Logical block number is set on traditionally-used buffers by an argument passed to buf_getblk(),
    /// for example by buf_bread().
    ///
    /// Parameter `bp`: Buffer whose logical block size to set.
    ///
    /// Parameter `lblksize`: Block size to set.
    pub fn buf_setlblksize(bp: buf_t, lblksize: u32);
}

extern "C-unwind" {
    /// Get count of valid bytes in a buffer.  This may be less than the space allocated to the buffer.
    ///
    /// Parameter `bp`: Buffer whose byte count to get.
    ///
    /// Returns: Byte count.
    pub fn buf_count(bp: buf_t) -> u32;
}

extern "C-unwind" {
    /// Get size of data region allocated to a buffer.
    ///
    /// May be larger than amount of valid data in buffer.
    ///
    /// Parameter `bp`: Buffer whose size to get.
    ///
    /// Returns: Size.
    pub fn buf_size(bp: buf_t) -> u32;
}

extern "C-unwind" {
    /// Get a count of bytes which were not consumed by an I/O on a buffer.
    ///
    /// Set when an I/O operations completes.
    ///
    /// Parameter `bp`: Buffer whose outstanding count to get.
    ///
    /// Returns: Count of unwritten/unread bytes.
    pub fn buf_resid(bp: buf_t) -> u32;
}

extern "C-unwind" {
    /// Set count of valid bytes in a buffer.  This may be less than the space allocated to the buffer.
    ///
    /// Parameter `bp`: Buffer whose byte count to set.
    ///
    /// Parameter `bcount`: Count to set.
    pub fn buf_setcount(bp: buf_t, bcount: u32);
}

extern "C-unwind" {
    /// Set size of data region allocated to a buffer.
    ///
    /// May be larger than amount of valid data in buffer.  Should be used by
    /// code which is manually providing storage for an iobuf, one allocated with buf_alloc().
    ///
    /// Parameter `bp`: Buffer whose size to set.
    pub fn buf_setsize(bp: buf_t, param1: u32);
}

extern "C-unwind" {
    /// Set a count of bytes outstanding for I/O in a buffer.
    ///
    /// Set when an I/O operations completes.  Examples: called by IOStorageFamily when I/O
    /// completes, often called on an "original" buffer when using a manipulated buffer to perform I/O
    /// on behalf of the first.
    ///
    /// Parameter `bp`: Buffer whose outstanding count to set.
    pub fn buf_setresid(bp: buf_t, resid: u32);
}

extern "C-unwind" {
    /// Set the address at which a buffer's data will be stored.
    ///
    /// In traditional buffer use, the data pointer will be set automatically. This routine is
    /// useful with iobufs (allocated with buf_alloc()).
    ///
    /// Parameter `bp`: Buffer whose data pointer to set.
    ///
    /// Parameter `data`: Pointer to data region.
    pub fn buf_setdataptr(bp: buf_t, data: usize);
}

extern "C-unwind" {
    /// Get the address at which a buffer's data is stored; for iobufs, this must
    /// be set with buf_setdataptr().  See buf_map().
    ///
    /// Parameter `bp`: Buffer whose data pointer to retrieve.
    ///
    /// Returns: Data pointer; NULL if unset.
    pub fn buf_dataptr(bp: buf_t) -> usize;
}

extern "C-unwind" {
    /// Get the vnode associated with a buffer.
    ///
    /// Every buffer is associated with a file.  Because there is an I/O in flight,
    /// there is an iocount on this vnode; it is returned WITHOUT an extra iocount, and vnode_put()
    /// need NOT be called.
    ///
    /// Parameter `bp`: Buffer whose vnode to retrieve.
    ///
    /// Returns: Buffer's vnode.
    pub fn buf_vnode(bp: buf_t) -> vnode_t;
}

extern "C-unwind" {
    /// Set the vnode associated with a buffer.
    ///
    /// This call need not be used on traditional buffers; it is for use with iobufs.
    ///
    /// Parameter `bp`: Buffer whose vnode to set.
    ///
    /// Parameter `vp`: The vnode to attach to the buffer.
    pub fn buf_setvnode(bp: buf_t, vp: vnode_t);
}

extern "C-unwind" {
    /// Get the device ID associated with a buffer.
    ///
    /// In traditional buffer use, this value is NODEV until buf_strategy() is called unless
    /// buf_getblk() was passed a device vnode.  It is set on an iobuf if buf_alloc() is passed a device
    /// vnode or if buf_setdevice() is called.
    ///
    /// Parameter `bp`: Buffer whose device ID to retrieve.
    ///
    /// Returns: Device id.
    pub fn buf_device(bp: buf_t) -> dev_t;
}

extern "C-unwind" {
    /// Set the device associated with a buffer.
    ///
    /// A buffer's device is set in buf_strategy() (or in buf_getblk() if the file is a device).
    /// It is also set on an iobuf if buf_alloc() is passed a device vnode.
    ///
    /// Parameter `bp`: Buffer whose device ID to set.
    ///
    /// Parameter `vp`: Device to set on the buffer.
    ///
    /// Returns: 0 for success, EINVAL if vp is not a device file.
    pub fn buf_setdevice(bp: buf_t, vp: vnode_t) -> errno_t;
}

extern "C-unwind" {
    /// Pass an I/O request for a buffer down to the device layer.
    ///
    /// This is one of the most important routines in the buffer cache layer.  For buffers obtained
    /// through buf_getblk, it handles finding physical block numbers for the I/O (with VNOP_BLKTOOFF and
    /// VNOP_BLOCKMAP), packaging the I/O into page-sized chunks, and initiating I/O on the disk by calling
    /// the device's strategy routine. If a buffer's UPL has been set manually with buf_setupl(), it assumes
    /// that the request is already correctly configured with a block number and a size divisible by page size
    /// and will just call directly to the device.
    ///
    /// Parameter `devvp`: Device on which to perform I/O
    ///
    /// Parameter `ap`: vnop_strategy_args structure (most importantly, a buffer).
    ///
    /// Returns: 0 for success, or errors from filesystem or device layers.
    pub fn buf_strategy(devvp: vnode_t, ap: *mut c_void) -> errno_t;
}

extern "C-unwind" {
    /// Invalidate a filesystem logical block in a file.
    ///
    /// buf_invalblkno() tries to make the data for a given block in a file
    /// invalid; if the buffer for that block is found in core and is not busy, we mark it
    /// invalid and call buf_brelse() (see "flags" param for what happens if the buffer is busy).
    /// buf_brelse(), noticing that it is invalid, will
    /// will return the buffer to the empty-buffer list and tell the VM subsystem to abandon
    /// the relevant pages.  Data will not be written to backing store--it will be cast aside.
    /// Note that this function will only work if the block in question has been
    /// obtained with a buf_getblk().  If data has been read into core without using
    /// traditional buffer cache routines, buf_invalblkno() will not be able to invalidate it--this
    /// includes the use of iobufs.
    ///
    /// Parameter `vp`: vnode whose block to invalidate.
    ///
    /// Parameter `lblkno`: Logical block number.
    ///
    /// Parameter `flags`: BUF_WAIT: wait for busy buffers to become unbusy and invalidate them then.  Otherwise,
    /// just return EBUSY for busy blocks.
    ///
    /// Returns: 0 for success, EINVAL if vp is not a device file.
    pub fn buf_invalblkno(vp: vnode_t, lblkno: daddr64_t, flags: c_int) -> errno_t;
}

extern "C-unwind" {
    /// Get the function set to be called when I/O on a buffer completes.
    ///
    /// A function returned by buf_callback was originally set with buf_setcallback().
    ///
    /// Parameter `bp`: Buffer whose callback to get.
    ///
    /// Returns: 0 for success, or errors from filesystem or device layers.
    pub fn buf_callback(bp: buf_t) -> *mut c_void;
}

extern "C-unwind" {
    /// Set a function to be called once when I/O on a buffer completes.
    ///
    /// A one-shot callout set with buf_setcallback() will be called from buf_biodone()
    /// when I/O completes. It will be passed the "transaction" argument as well as the buffer.
    /// buf_setcallback() also marks the buffer as B_ASYNC.
    ///
    /// Parameter `bp`: Buffer whose callback to set.
    ///
    /// Parameter `callback`: function to use as callback.
    ///
    /// Parameter `transaction`: Additional argument to callback function.
    ///
    /// Returns: 0; always succeeds.
    pub fn buf_setcallback(
        bp: buf_t,
        callback: Option<unsafe extern "C-unwind" fn(buf_t, *mut c_void)>,
        transaction: *mut c_void,
    ) -> errno_t;
}

extern "C-unwind" {
    /// Set the UPL (Universal Page List), and offset therein, on a buffer.
    ///
    /// buf_setupl() should only be called on buffers allocated with buf_alloc().
    /// A subsequent call to buf_map() will map the UPL and give back the address at which data
    /// begins. After buf_setupl() is called, a buffer is marked B_CLUSTER; when this is the case,
    /// buf_strategy() assumes that a buffer is correctly configured to be passed to the device
    /// layer without modification. Passing a NULL upl will clear the upl and the B_CLUSTER flag on the
    /// buffer.
    ///
    /// Parameter `bp`: Buffer whose upl to set.
    ///
    /// Parameter `upl`: UPL to set in the buffer.
    ///
    /// Parameter `offset`: Offset within upl at which relevant data begin.
    ///
    /// Returns: 0 for success, EINVAL if the buffer was not allocated with buf_alloc().
    pub fn buf_setupl(bp: buf_t, upl: upl_t, offset: u32) -> errno_t;
}

extern "C-unwind" {
    /// Clone a buffer with a restricted range and an optional callback.
    ///
    /// Generates a buffer which is identical to its "bp" argument except that
    /// it spans a subset of the data of the original.  The buffer to be cloned should
    /// have been allocated with buf_alloc().  Checks its arguments to make sure
    /// that the data subset is coherent. Optionally, adds a callback function and argument to it
    /// to be called when I/O completes (as with buf_setcallback(), but B_ASYNC is not set).  If the original buffer had
    /// a upl set through buf_setupl(), this upl is copied to the new buffer; otherwise, the original's
    /// data pointer is used raw. The buffer must be released with buf_free().
    ///
    /// Parameter `bp`: Buffer to clone.
    ///
    /// Parameter `io_offset`: Offset, relative to start of data in original buffer, at which new buffer's data will begin.
    ///
    /// Parameter `io_size`: Size of buffer region in new buffer, in the sense of buf_count().
    ///
    /// Parameter `iodone`: Callback to be called from buf_biodone() when I/O completes, in the sense of buf_setcallback().
    ///
    /// Parameter `arg`: Argument to pass to iodone() callback.
    ///
    /// Returns: NULL if io_offset/io_size combination is invalid for the buffer to be cloned; otherwise, the new buffer.
    pub fn buf_clone(
        bp: buf_t,
        io_offset: c_int,
        io_size: c_int,
        iodone: Option<unsafe extern "C-unwind" fn(buf_t, *mut c_void)>,
        arg: *mut c_void,
    ) -> buf_t;
}

/// Create a shadow buffer with optional private storage and an optional callback.
///
/// Parameter `bp`: Buffer to shadow.
///
/// Parameter `force_copy`: If TRUE, do not link the shadaow to 'bp' and if 'external_storage' == NULL,
/// force a copy of the data associated with 'bp'.
///
/// Parameter `external_storage`: If non-NULL, associate it with the new buffer as its storage instead of the
/// storage currently associated with 'bp'.
///
/// Parameter `iodone`: Callback to be called from buf_biodone() when I/O completes, in the sense of buf_setcallback().
///
/// Parameter `arg`: Argument to pass to iodone() callback.
///
/// Returns: NULL if the buffer to be shadowed is not B_META or a primary buffer (i.e. not a shadow buffer); otherwise, the new buffer.
#[inline]
pub unsafe extern "C-unwind" fn buf_create_shadow(
    bp: buf_t,
    force_copy: bool,
    external_storage: usize,
    iodone: Option<unsafe extern "C-unwind" fn(buf_t, *mut c_void)>,
    arg: *mut c_void,
) -> buf_t {
    extern "C-unwind" {
        fn buf_create_shadow(
            bp: buf_t,
            force_copy: boolean_t,
            external_storage: usize,
            iodone: Option<unsafe extern "C-unwind" fn(buf_t, *mut c_void)>,
            arg: *mut c_void,
        ) -> buf_t;
    }
    unsafe { buf_create_shadow(bp, force_copy as _, external_storage, iodone, arg) }
}

extern "C-unwind" {
    /// returns true if 'bp' is a shadow of another buffer.
    ///
    /// Parameter `bp`: Buffer to query.
    ///
    /// Returns: 1 if 'bp' is a shadow, 0 otherwise.
    pub fn buf_shadow(bp: buf_t) -> c_int;
}

extern "C-unwind" {
    /// Allocate an uninitialized buffer.
    ///
    /// A buffer returned by buf_alloc() is marked as busy and as an iobuf; it has no storage set up and must be
    /// set up using buf_setdataptr() or buf_setupl()/buf_map().
    ///
    /// Parameter `vp`: vnode to associate with the buffer: optionally NULL.  If vp is a device file, then
    /// the buffer's associated device will be set. If vp is NULL, it can be set later with buf_setvnode().
    ///
    /// Returns: New buffer.
    pub fn buf_alloc(vp: vnode_t) -> buf_t;
}

extern "C-unwind" {
    /// Free a buffer that was allocated with buf_alloc().
    ///
    /// The storage (UPL, data pointer) associated with an iobuf must be freed manually.
    ///
    /// Parameter `bp`: The buffer to free.
    pub fn buf_free(bp: buf_t);
}

extern "C-unwind" {
    /// Invalidate all the blocks associated with a vnode.
    ///
    /// This function does for all blocks associated with a vnode what buf_invalblkno does for one block.
    /// Again, it will only be able to invalidate data which were populated with traditional buffer cache routines,
    /// i.e. by buf_getblk() and callers thereof. Unlike buf_invalblkno(), it can be made to write dirty data to disk
    /// rather than casting it aside.
    ///
    /// Parameter `vp`: The vnode whose data to invalidate.
    ///
    /// Parameter `flags`: BUF_WRITE_DATA: write dirty data to disk with VNOP_BWRITE() before kicking buffer cache entries out.
    /// BUF_SKIP_META: do not invalidate metadata blocks.
    ///
    /// Parameter `slpflag`: Flags to pass to "msleep" while waiting to acquire busy buffers.
    ///
    /// Parameter `slptimeo`: Timeout in "hz" (1/100 second) to wait for a buffer to become unbusy before waking from sleep
    /// and re-starting the scan.
    ///
    /// Returns: 0 for success, error values from msleep().
    pub fn buf_invalidateblks(vp: vnode_t, flags: c_int, slpflag: c_int, slptimeo: c_int) -> c_int;
}

extern "C-unwind" {
    /// Write dirty file blocks to disk.
    ///
    /// Parameter `vp`: The vnode whose blocks to flush.
    ///
    /// Parameter `wait`: Wait for writes to complete before returning.
    ///
    /// Parameter `flags`: Can pass zero, meaning "flush all dirty buffers."
    /// BUF_SKIP_NONLOCKED: Skip buffers which are not busy when we encounter them.
    /// BUF_SKIP_LOCKED: Skip buffers which are busy when we encounter them.
    ///
    /// Parameter `msg`: String to pass to msleep().
    pub fn buf_flushdirtyblks(vp: vnode_t, wait: c_int, flags: c_int, msg: *const c_char);
}

extern "C-unwind" {
    /// Perform some operation on all buffers associated with a vnode.
    ///
    /// Parameter `vp`: The vnode whose buffers to scan.
    ///
    /// Parameter `callout`: Function to call on each buffer.  Should return one of:
    /// BUF_RETURNED: buf_iterate() should call buf_brelse() on the buffer.
    /// BUF_RETURNED_DONE: buf_iterate() should call buf_brelse() on the buffer and then stop iterating.
    /// BUF_CLAIMED: buf_iterate() should continue iterating (and not call buf_brelse()).
    /// BUF_CLAIMED_DONE: buf_iterate() should stop iterating (and not call buf_brelse()).
    ///
    /// Parameter `flags`: BUF_SKIP_NONLOCKED: Skip buffers which are not busy when we encounter them. BUF_SKIP_LOCKED: Skip buffers which are busy when we encounter them.
    /// BUF_SCAN_CLEAN: Call out on clean buffers.
    /// BUF_SCAN_DIRTY: Call out on dirty buffers.
    /// BUF_NOTIFY_BUSY: If a buffer cannot be acquired, pass a NULL buffer to callout; otherwise,
    /// that buffer will be silently skipped.
    ///
    /// Parameter `arg`: Argument to pass to callout in addition to buffer.
    pub fn buf_iterate(
        vp: vnode_t,
        callout: Option<unsafe extern "C-unwind" fn(buf_t, *mut c_void) -> c_int>,
        flags: c_int,
        arg: *mut c_void,
    );
}

extern "C-unwind" {
    /// Zero out the storage associated with a buffer.
    ///
    /// Calls buf_map() to get the buffer's data address; for a B_CLUSTER
    /// buffer (one which has had buf_setupl() called on it), it tries to map the buffer's
    /// UPL into memory; should only be called once during the life cycle of an iobuf (one allocated
    /// with buf_alloc()).
    ///
    /// Parameter `bp`: The buffer to zero out.
    pub fn buf_clear(bp: buf_t);
}

extern "C-unwind" {
    /// Start an asychronous write on a buffer.
    ///
    /// Calls VNOP_BWRITE to start the process of propagating an asynchronous write down to the device layer.
    /// Callers can wait for writes to complete at their discretion using buf_biowait().  When this function is called,
    /// data should already have been written to the buffer's data region.
    ///
    /// Parameter `bp`: The buffer on which to initiate I/O.
    ///
    /// Returns: EWOULDBLOCK if write count is high and "throttle" is zero; otherwise, errors from VNOP_BWRITE.
    pub fn buf_bawrite(bp: buf_t) -> errno_t;
}

extern "C-unwind" {
    /// Mark a buffer for delayed write.
    ///
    /// Marks a buffer as waiting for delayed write and the current I/O as complete; data will be written to backing store
    /// before the buffer is reused, but it will not be queued for I/O immediately.  Note that for buffers allocated
    /// with buf_alloc(), there are no such guarantees; you must take care of your own flushing to disk.  If
    /// the number of delayed writes pending on the system is greater than an internal limit and the caller has not
    /// requested otherwise [see return_error] , buf_bdwrite() will unilaterally launch an asynchronous I/O with buf_bawrite() to keep the pile of
    /// delayed writes from getting too large.
    ///
    /// Parameter `bp`: The buffer to mark for delayed write.
    ///
    /// Returns: EAGAIN for return_error != 0 case, 0 for succeess, errors from buf_bawrite.
    pub fn buf_bdwrite(bp: buf_t) -> errno_t;
}

extern "C-unwind" {
    /// Write a buffer's data to backing store.
    ///
    /// Once the data in a buffer has been modified, buf_bwrite() starts sending it to disk by calling
    /// VNOP_STRATEGY.  Unless B_ASYNC has been set on the buffer (by buf_setflags() or otherwise), data will have
    /// been written to disk when buf_bwrite() returns.  See Bach (p 56).
    ///
    /// Parameter `bp`: The buffer to write to disk.
    ///
    /// Returns: 0 for success; errors from buf_biowait().
    pub fn buf_bwrite(bp: buf_t) -> errno_t;
}

extern "C-unwind" {
    /// Mark an I/O as completed.
    ///
    /// buf_biodone() should be called by whosoever decides that an I/O on a buffer is complete; for example,
    /// IOStorageFamily.  It clears the dirty flag on a buffer and signals on the vnode that a write has completed
    /// with vnode_writedone(). If a callout or filter has been set on the buffer, that function is called.  In the case
    /// of a callout, that function is expected to take care of cleaning up and freeing the buffer.
    /// Otherwise, if the buffer is marked B_ASYNC (e.g. it was passed to buf_bawrite()), then buf_biodone()
    /// considers itself justified in calling buf_brelse() to return it to free lists--no one is waiting for it.  Finally,
    /// waiters on the bp (e.g. in buf_biowait()) are woken up.
    ///
    /// Parameter `bp`: The buffer to mark as done with I/O.
    pub fn buf_biodone(bp: buf_t);
}

extern "C-unwind" {
    /// Wait for I/O on a buffer to complete.
    ///
    /// Waits for I/O on a buffer to finish, as marked by a buf_biodone() call.
    ///
    /// Parameter `bp`: The buffer to wait on.
    ///
    /// Returns: 0 for a successful wait; nonzero the buffer has been marked as EINTR or had an error set on it.
    pub fn buf_biowait(bp: buf_t) -> errno_t;
}

extern "C-unwind" {
    /// Release any claim to a buffer, sending it back to free lists.
    ///
    /// buf_brelse() cleans up buffer state and releases a buffer to the free lists.  If the buffer
    /// is not marked invalid and its pages are dirty (e.g. a delayed write was made), its data will be commited
    /// to backing store. If it is marked invalid, its data will be discarded completely.
    /// A valid, cacheable buffer will be put on a list and kept in the buffer hash so it
    /// can be found again; otherwise, it will be dissociated from its vnode and treated as empty.  Which list a valid
    /// buffer is placed on depends on the use of buf_markaged(), whether it is metadata, and the B_LOCKED flag.  A
    /// B_LOCKED buffer will not be available for reuse by other files, though its data may be paged out.
    /// Note that buf_brelse() is intended for use with traditionally allocated buffers.
    ///
    /// Parameter `bp`: The buffer to release.
    pub fn buf_brelse(bp: buf_t);
}

extern "C-unwind" {
    /// Synchronously read a block of a file.
    ///
    /// buf_bread() is the traditional way to read a single logical block of a file through the buffer cache.
    /// It tries to find the buffer and corresponding page(s) in core, calls VNOP_STRATEGY if necessary to bring the data
    /// into memory, and waits for I/O to complete.  It should not be used to read blocks of greater than 4K (one VM page)
    /// in size; use cluster routines for large reads.  Indeed, the cluster layer is a more efficient choice for reading DATA
    /// unless you need some finely-tuned semantics that it cannot provide.
    ///
    /// Parameter `vp`: The file from which to read.
    ///
    /// Parameter `blkno`: The logical (filesystem) block number to read.
    ///
    /// Parameter `size`: Size of block; do not use for sizes > 4K.
    ///
    /// Parameter `cred`: Credential to store and use for reading from disk if data are not already in core.
    ///
    /// Parameter `bpp`: Destination pointer for buffer.
    ///
    /// Returns: 0 for success, or an error from buf_biowait().
    pub fn buf_bread(
        vp: vnode_t,
        blkno: daddr64_t,
        size: c_int,
        cred: kauth_cred_t,
        bpp: *mut buf_t,
    ) -> errno_t;
}

extern "C-unwind" {
    /// Read a block from a file with read-ahead.
    ///
    /// buf_breadn() reads one block synchronously in the style of buf_bread() and fires
    /// off a specified set of asynchronous reads to improve the likelihood of future cache hits.
    /// It should not be used to read blocks of greater than 4K (one VM page) in size; use cluster
    /// routines for large reads.  Indeed, the cluster layer is a more efficient choice for reading DATA
    /// unless you need some finely-tuned semantics that it cannot provide.
    ///
    /// Parameter `vp`: The file from which to read.
    ///
    /// Parameter `blkno`: The logical (filesystem) block number to read synchronously.
    ///
    /// Parameter `size`: Size of block; do not use for sizes > 4K.
    ///
    /// Parameter `rablks`: Array of logical block numbers for asynchronous read-aheads.
    ///
    /// Parameter `rasizes`: Array of block sizes for asynchronous read-aheads, each index corresponding to same index in "rablks."
    ///
    /// Parameter `nrablks`: Number of entries in read-ahead arrays.
    ///
    /// Parameter `cred`: Credential to store and use for reading from disk if data are not already in core.
    ///
    /// Parameter `bpp`: Destination pointer for buffer.
    ///
    /// Returns: 0 for success, or an error from buf_biowait().
    pub fn buf_breadn(
        vp: vnode_t,
        blkno: daddr64_t,
        size: c_int,
        rablks: *mut daddr64_t,
        rasizes: *mut c_int,
        nrablks: c_int,
        cred: kauth_cred_t,
        bpp: *mut buf_t,
    ) -> errno_t;
}

extern "C-unwind" {
    /// Synchronously read a metadata block of a file.
    ///
    /// buf_meta_bread() is the traditional way to read a single logical block of a file through the buffer cache.
    /// It tries to find the buffer and corresponding page(s) in core, calls VNOP_STRATEGY if necessary to bring the data
    /// into memory, and waits for I/O to complete.  It should not be used to read blocks of greater than 4K (one VM page)
    /// in size; use cluster routines for large reads.  Reading meta-data through the traditional buffer cache, unlike
    /// reading data, is efficient and encouraged, especially if the blocks being read are significantly smaller than page size.
    ///
    /// Parameter `vp`: The file from which to read.
    ///
    /// Parameter `blkno`: The logical (filesystem) block number to read.
    ///
    /// Parameter `size`: Size of block; do not use for sizes > 4K.
    ///
    /// Parameter `cred`: Credential to store and use for reading from disk if data are not already in core.
    ///
    /// Parameter `bpp`: Destination pointer for buffer.
    ///
    /// Returns: 0 for success, or an error from buf_biowait().
    pub fn buf_meta_bread(
        vp: vnode_t,
        blkno: daddr64_t,
        size: c_int,
        cred: kauth_cred_t,
        bpp: *mut buf_t,
    ) -> errno_t;
}

extern "C-unwind" {
    /// Read a metadata block from a file with read-ahead.
    ///
    /// buf_meta_breadn() reads one block synchronously in the style of buf_meta_bread() and fires
    /// off a specified set of asynchronous reads to improve the likelihood of future cache hits.
    /// It should not be used to read blocks of greater than 4K (one VM page) in size; use cluster
    /// routines for large reads.
    ///
    /// Parameter `vp`: The file from which to read.
    ///
    /// Parameter `blkno`: The logical (filesystem) block number to read synchronously.
    ///
    /// Parameter `size`: Size of block; do not use for sizes > 4K.
    ///
    /// Parameter `rablks`: Array of logical block numbers for asynchronous read-aheads.
    ///
    /// Parameter `rasizes`: Array of block sizes for asynchronous read-aheads, each index corresponding to same index in "rablks."
    ///
    /// Parameter `nrablks`: Number of entries in read-ahead arrays.
    ///
    /// Parameter `cred`: Credential to store and use for reading from disk if data are not already in core.
    ///
    /// Parameter `bpp`: Destination pointer for buffer.
    ///
    /// Returns: 0 for success, or an error from buf_biowait().
    pub fn buf_meta_breadn(
        vp: vnode_t,
        blkno: daddr64_t,
        size: c_int,
        rablks: *mut daddr64_t,
        rasizes: *mut c_int,
        nrablks: c_int,
        cred: kauth_cred_t,
        bpp: *mut buf_t,
    ) -> errno_t;
}

extern "C-unwind" {
    /// Adjust a buffer's count to be no more than maximum physical I/O transfer size for the host architecture.
    ///
    /// physio() takes as a parameter a function to bound transfer sizes for each VNOP_STRATEGY() call.  minphys()
    /// is a default implementation.  It calls buf_setcount() to make the buffer's count the min() of its current count
    /// and the max I/O size for the host architecture.
    ///
    /// Parameter `bp`: The buffer whose byte count to modify.
    ///
    /// Returns: New byte count.
    pub fn minphys(bp: buf_t) -> c_uint;
}

extern "C-unwind" {
    /// Perform I/O on a device to/from target memory described by a uio.
    ///
    /// physio() allows I/O directly from a device to user-space memory.  It waits
    /// for all I/O to complete before returning.
    ///
    /// Parameter `f_strategy`: Strategy routine to call to initiate I/O.
    ///
    /// Parameter `bp`: Buffer to configure and pass to strategy routine; can be NULL.
    ///
    /// Parameter `dev`: Device on which to perform I/O.
    ///
    /// Parameter `flags`: B_READ or B_WRITE.
    ///
    /// Parameter `f_minphys`: Function which calls buf_setcount() to set a byte count which is suitably
    /// small for the device in question.  Returns byte count that has been set (or unchanged) on the buffer.
    ///
    /// Parameter `uio`: UIO describing the I/O operation.
    ///
    /// Parameter `blocksize`: Logical block size for this vnode.
    ///
    /// Returns: 0 for success; EFAULT for an invalid uio; errors from buf_biowait().
    pub fn physio(
        f_strategy: Option<unsafe extern "C-unwind" fn(buf_t)>,
        bp: buf_t,
        dev: dev_t,
        flags: c_int,
        f_minphys: Option<unsafe extern "C-unwind" fn(buf_t) -> c_uint>,
        uio: *mut uio,
        blocksize: c_int,
    ) -> c_int;
}

extern "C-unwind" {
    /// Traditional buffer cache routine to get a buffer corresponding to a logical block in a file.
    ///
    /// buf_getblk() gets a buffer, not necessarily containing valid data, representing a block in a file.
    /// A metadata buffer will be returned with its own zone-allocated storage, managed by the traditional buffer-cache
    /// layer, whereas data buffers will be returned hooked into backing by the UBC (which in fact controls the caching of data).
    /// buf_getblk() first looks for the buffer header in cache; if the buffer is in-core but busy, buf_getblk() will wait for it to become
    /// unbusy, depending on the slpflag and slptimeo parameters. If the buffer is found unbusy and is a metadata buffer,
    /// it must already contain valid data and will be returned directly; data buffers will have a UPL configured to
    /// prepare for interaction with the underlying UBC.  If the buffer is found in core, it will be marked as such
    /// and buf_fromcache() will return truth. A buffer is allocated and initialized (but not filled with data)
    /// if none is found in core. buf_bread(), buf_breadn(), buf_meta_bread(), and buf_meta_breadn() all
    /// return buffers obtained with buf_getblk().
    ///
    /// Parameter `vp`: File for which to get block.
    ///
    /// Parameter `blkno`: Logical block number.
    ///
    /// Parameter `size`: Size of block.
    ///
    /// Parameter `slpflag`: Flag to pass to msleep() while waiting for buffer to become unbusy.
    ///
    /// Parameter `slptimeo`: Time, in milliseconds, to wait for buffer to become unbusy.  0 means to wait indefinitely.
    ///
    /// Parameter `operation`: BLK_READ: want a read buffer.  BLK_WRITE: want a write buffer.  BLK_META: want a metadata buffer.  BLK_ONLYVALID:
    /// only return buffers which are found in core (do not allocate anew), and do not change buffer size.  The last remark means
    /// that if a given logical block is found in core with a different size than what is requested, the buffer size will not be modified.
    ///
    /// Returns: Buffer found in core or newly allocated, either containing valid data or ready for I/O.
    pub fn buf_getblk(
        vp: vnode_t,
        blkno: daddr64_t,
        size: c_int,
        slpflag: c_int,
        slptimeo: c_int,
        operation: c_int,
    ) -> buf_t;
}

extern "C-unwind" {
    /// Get a metadata buffer which is marked invalid and not associated with any vnode.
    ///
    /// A buffer is returned with zone-allocated storage of the specified size, marked B_META and invalid.
    /// It has no vnode and is not visible in the buffer hash.
    ///
    /// Parameter `size`: Size of buffer.
    ///
    /// Returns: Always returns a new buffer.
    pub fn buf_geteblk(size: c_int) -> buf_t;
}

extern "C-unwind" {
    /// Clear flags on a buffer.
    ///
    /// buffer_redundancy_flags
    /// &
    /// = ~flags
    ///
    /// Parameter `bp`: Buffer whose flags to clear.
    ///
    /// Parameter `flags`: Flags to remove from buffer's mask
    pub fn buf_clear_redundancy_flags(bp: buf_t, flags: u32);
}

extern "C-unwind" {
    /// Get redundancy flags set on a buffer.
    ///
    /// Parameter `bp`: Buffer whose redundancy flags to grab.
    ///
    /// Returns: flags.
    pub fn buf_redundancy_flags(bp: buf_t) -> u32;
}

extern "C-unwind" {
    /// Set redundancy flags on a buffer.
    ///
    /// buffer_redundancy_flags |= flags
    ///
    /// Parameter `bp`: Buffer whose flags to set.
    ///
    /// Parameter `flags`: Flags to add to buffer's redundancy flags
    pub fn buf_set_redundancy_flags(bp: buf_t, flags: u32);
}

extern "C-unwind" {
    /// Gets the attributes for this buf.
    ///
    /// Parameter `bp`: Buffer whose attributes to get.
    ///
    /// Returns: bufattr_t.
    pub fn buf_attr(bp: buf_t) -> bufattr_t;
}

extern "C-unwind" {
    /// Mark a buffer as being likely to contain static data.
    ///
    /// Parameter `bp`: Buffer to mark.
    pub fn buf_markstatic(bp: buf_t);
}

extern "C-unwind" {
    /// Check if a buffer contains static data.
    ///
    /// Parameter `bp`: Buffer to test.
    ///
    /// Returns: Nonzero if buffer has static data, 0 otherwise.
    pub fn buf_static(bp: buf_t) -> c_int;
}

extern "C-unwind" {
    /// Mark a buffer as belonging to an io scheduled mount point
    ///
    /// Parameter `bap`: Buffer attributes to mark.
    ///
    /// Marks the buffer so that spec_strategy() will know that it belongs to an io scheduled mount point
    pub fn bufattr_markioscheduled(bap: bufattr_t);
}

extern "C-unwind" {
    /// Check if a buffer is marked as io scheduled
    ///
    /// Parameter `bap`: Buffer attributes to test.
    ///
    /// Returns: Nonzero if the buffer is marked io scheduled, 0 otherwise.
    pub fn bufattr_ioscheduled(bap: bufattr_t) -> c_int;
}

extern "C-unwind" {
    /// Mark a metadata I/O buffer as expedited (i.e. requires a high I/O tier).
    ///
    /// Parameter `bap`: Buffer attributes to mark.
    ///
    /// Marks the buffer so that spec_strategy() will know that it should be expedited
    pub fn bufattr_markexpeditedmeta(bap: bufattr_t);
}

extern "C-unwind" {
    /// Check if a buffer is marked as expedited metadata I/O.
    ///
    /// Parameter `bap`: Buffer attributes to test.
    ///
    /// Returns: Nonzero if the buffer is marked expedited metadata I/O, 0 otherwise.
    pub fn bufattr_expeditedmeta(bap: bufattr_t) -> c_int;
}
