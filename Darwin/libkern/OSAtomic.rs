//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;

use crate::ffi::*;

/// [Apple's documentation](https://developer.apple.com/documentation/darwin/osatomic_int64_aligned64_t?language=objc)
pub type OSAtomic_int64_aligned64_t = i64;

extern "C-unwind" {
    /// Atomically adds two 32-bit values.
    ///
    /// This function adds the value given by
    /// <code>
    /// __theAmount
    /// </code>
    /// to the
    /// value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// Returns: Returns the new value.
    #[deprecated = "Use atomic_fetch_add_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicAdd32(the_amount: i32, the_value: *mut i32) -> i32;
}

extern "C-unwind" {
    /// Atomically adds two 32-bit values.
    ///
    /// This function adds the value given by
    /// <code>
    /// __theAmount
    /// </code>
    /// to the
    /// value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicAdd32}
    ///     except that it also introduces a barrier.
    ///     @result Returns the new value.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_add() from <stdatomic.h> instead"]
    pub fn OSAtomicAdd32Barrier(the_amount: i32, the_value: *mut i32) -> i32;
}

extern "C-unwind" {
    /// Atomically increments a 32-bit value.
    ///
    /// Returns: Returns the new value.
    #[deprecated = "Use atomic_fetch_add_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicIncrement32(the_value: *mut i32) -> i32;
}

extern "C-unwind" {
    /// Atomically increments a 32-bit value with a barrier.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicIncrement32}
    ///     except that it also introduces a barrier.
    ///     @result Returns the new value.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_add() from <stdatomic.h> instead"]
    pub fn OSAtomicIncrement32Barrier(the_value: *mut i32) -> i32;
}

extern "C-unwind" {
    /// Atomically decrements a 32-bit value.
    ///
    /// Returns: Returns the new value.
    #[deprecated = "Use atomic_fetch_sub_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicDecrement32(the_value: *mut i32) -> i32;
}

extern "C-unwind" {
    /// Atomically decrements a 32-bit value with a barrier.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicDecrement32}
    ///     except that it also introduces a barrier.
    ///     @result Returns the new value.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_sub() from <stdatomic.h> instead"]
    pub fn OSAtomicDecrement32Barrier(the_value: *mut i32) -> i32;
}

extern "C-unwind" {
    /// Atomically adds two 64-bit values.
    ///
    /// This function adds the value given by
    /// <code>
    /// __theAmount
    /// </code>
    /// to the
    /// value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// Returns: Returns the new value.
    #[deprecated = "Use atomic_fetch_add_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicAdd64(the_amount: i64, the_value: *mut libc::OSAtomic_int64_aligned64_t) -> i64;
}

extern "C-unwind" {
    /// Atomically adds two 64-bit values with a barrier.
    ///
    /// This function adds the value given by
    /// <code>
    /// __theAmount
    /// </code>
    /// to the
    /// value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicAdd64}
    ///     except that it also introduces a barrier.
    ///     @result Returns the new value.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_add() from <stdatomic.h> instead"]
    pub fn OSAtomicAdd64Barrier(
        the_amount: i64,
        the_value: *mut libc::OSAtomic_int64_aligned64_t,
    ) -> i64;
}

extern "C-unwind" {
    /// Atomically increments a 64-bit value.
    ///
    /// Returns: Returns the new value.
    #[deprecated = "Use atomic_fetch_add_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicIncrement64(the_value: *mut libc::OSAtomic_int64_aligned64_t) -> i64;
}

extern "C-unwind" {
    /// Atomically increments a 64-bit value with a barrier.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicIncrement64}
    ///     except that it also introduces a barrier.
    ///     @result Returns the new value.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_add() from <stdatomic.h> instead"]
    pub fn OSAtomicIncrement64Barrier(the_value: *mut libc::OSAtomic_int64_aligned64_t) -> i64;
}

extern "C-unwind" {
    /// Atomically decrements a 64-bit value.
    ///
    /// Returns: Returns the new value.
    #[deprecated = "Use atomic_fetch_sub_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicDecrement64(the_value: *mut libc::OSAtomic_int64_aligned64_t) -> i64;
}

extern "C-unwind" {
    /// Atomically decrements a 64-bit value with a barrier.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicDecrement64}
    ///     except that it also introduces a barrier.
    ///     @result Returns the new value.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_sub() from <stdatomic.h> instead"]
    pub fn OSAtomicDecrement64Barrier(the_value: *mut libc::OSAtomic_int64_aligned64_t) -> i64;
}

extern "C-unwind" {
    /// Atomic bitwise OR of two 32-bit values.
    ///
    /// This function performs the bitwise OR of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// Returns: Returns the new value.
    #[deprecated = "Use atomic_fetch_or_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicOr32(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise OR of two 32-bit values with barrier.
    ///
    /// This function performs the bitwise OR of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicOr32}
    ///     except that it also introduces a barrier.
    ///     @result Returns the new value.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_or() from <stdatomic.h> instead"]
    pub fn OSAtomicOr32Barrier(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise OR of two 32-bit values returning original.
    ///
    /// This function performs the bitwise OR of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// Returns: Returns the original value referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .
    #[deprecated = "Use atomic_fetch_or_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicOr32Orig(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise OR of two 32-bit values returning original with barrier.
    ///
    /// This function performs the bitwise OR of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicOr32Orig}
    ///     except that it also introduces a barrier.
    ///     @result Returns the original value referenced by <code>__theValue</code>.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_or() from <stdatomic.h> instead"]
    pub fn OSAtomicOr32OrigBarrier(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise AND of two 32-bit values.
    ///
    /// This function performs the bitwise AND of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// Returns: Returns the new value.
    #[deprecated = "Use atomic_fetch_and_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicAnd32(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise AND of two 32-bit values with barrier.
    ///
    /// This function performs the bitwise AND of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicAnd32}
    ///     except that it also introduces a barrier.
    ///     @result Returns the new value.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_and() from <stdatomic.h> instead"]
    pub fn OSAtomicAnd32Barrier(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise AND of two 32-bit values returning original.
    ///
    /// This function performs the bitwise AND of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// Returns: Returns the original value referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .
    #[deprecated = "Use atomic_fetch_and_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicAnd32Orig(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise AND of two 32-bit values returning original with barrier.
    ///
    /// This function performs the bitwise AND of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicAnd32Orig}
    ///     except that it also introduces a barrier.
    ///     @result Returns the original value referenced by <code>__theValue</code>.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_and() from <stdatomic.h> instead"]
    pub fn OSAtomicAnd32OrigBarrier(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise XOR of two 32-bit values.
    ///
    /// This function performs the bitwise XOR of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// Returns: Returns the new value.
    #[deprecated = "Use atomic_fetch_xor_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicXor32(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise XOR of two 32-bit values with barrier.
    ///
    /// This function performs the bitwise XOR of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicXor32}
    ///     except that it also introduces a barrier.
    ///     @result Returns the new value.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_xor() from <stdatomic.h> instead"]
    pub fn OSAtomicXor32Barrier(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise XOR of two 32-bit values returning original.
    ///
    /// This function performs the bitwise XOR of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// Returns: Returns the original value referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .
    #[deprecated = "Use atomic_fetch_xor_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicXor32Orig(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Atomic bitwise XOR of two 32-bit values returning original with barrier.
    ///
    /// This function performs the bitwise XOR of the value given by
    /// <code>
    /// __theMask
    /// </code>
    /// with the value in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// ,
    /// storing the result back to that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicXor32Orig}
    ///     except that it also introduces a barrier.
    ///     @result Returns the original value referenced by <code>__theValue</code>.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_xor() from <stdatomic.h> instead"]
    pub fn OSAtomicXor32OrigBarrier(the_mask: u32, the_value: *mut u32) -> i32;
}

extern "C-unwind" {
    /// Compare and swap for 32-bit values.
    ///
    /// This function compares the value in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the value
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the values
    /// match, this function stores the value from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// Returns: Returns TRUE on a match, FALSE otherwise.
    #[deprecated = "Use atomic_compare_exchange_strong_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwap32(old_value: i32, new_value: i32, the_value: *mut i32) -> bool;
}

extern "C-unwind" {
    /// Compare and swap for 32-bit values with barrier.
    ///
    /// This function compares the value in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the value
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the values
    /// match, this function stores the value from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicCompareAndSwap32}
    ///     except that it also introduces a barrier.
    ///     @result Returns TRUE on a match, FALSE otherwise.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_compare_exchange_strong() from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwap32Barrier(
        old_value: i32,
        new_value: i32,
        the_value: *mut i32,
    ) -> bool;
}

extern "C-unwind" {
    /// Compare and swap pointers.
    ///
    /// This function compares the pointer stored in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the pointer
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the pointers
    /// match, this function stores the pointer from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// Returns: Returns TRUE on a match, FALSE otherwise.
    #[deprecated = "Use atomic_compare_exchange_strong_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwapPtr(
        old_value: *mut c_void,
        new_value: *mut c_void,
        the_value: *mut *mut c_void,
    ) -> bool;
}

extern "C-unwind" {
    /// Compare and swap pointers with barrier.
    ///
    /// This function compares the pointer stored in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the pointer
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the pointers
    /// match, this function stores the pointer from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicCompareAndSwapPtr}
    ///     except that it also introduces a barrier.
    ///     @result Returns TRUE on a match, FALSE otherwise.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_compare_exchange_strong() from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwapPtrBarrier(
        old_value: *mut c_void,
        new_value: *mut c_void,
        the_value: *mut *mut c_void,
    ) -> bool;
}

extern "C-unwind" {
    /// Compare and swap for
    /// <code>
    /// int
    /// </code>
    /// values.
    ///
    /// This function compares the value in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the value
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the values
    /// match, this function stores the value from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicCompareAndSwap32}.
    ///     @result Returns TRUE on a match, FALSE otherwise.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_compare_exchange_strong_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwapInt(
        old_value: c_int,
        new_value: c_int,
        the_value: *mut c_int,
    ) -> bool;
}

extern "C-unwind" {
    /// Compare and swap for
    /// <code>
    /// int
    /// </code>
    /// values.
    ///
    /// This function compares the value in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the value
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the values
    /// match, this function stores the value from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicCompareAndSwapInt}
    ///     except that it also introduces a barrier.
    ///
    ///     This function is equivalent to {@link OSAtomicCompareAndSwap32Barrier}.
    ///     @result Returns TRUE on a match, FALSE otherwise.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_compare_exchange_strong() from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwapIntBarrier(
        old_value: c_int,
        new_value: c_int,
        the_value: *mut c_int,
    ) -> bool;
}

extern "C-unwind" {
    /// Compare and swap for
    /// <code>
    /// long
    /// </code>
    /// values.
    ///
    /// This function compares the value in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the value
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the values
    /// match, this function stores the value from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicCompareAndSwap32} on 32-bit architectures,
    ///     or {@link OSAtomicCompareAndSwap64} on 64-bit architectures.
    ///     @result Returns TRUE on a match, FALSE otherwise.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_compare_exchange_strong_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwapLong(
        old_value: c_long,
        new_value: c_long,
        the_value: *mut c_long,
    ) -> bool;
}

extern "C-unwind" {
    /// Compare and swap for
    /// <code>
    /// long
    /// </code>
    /// values.
    ///
    /// This function compares the value in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the value
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the values
    /// match, this function stores the value from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicCompareAndSwapLong}
    ///     except that it also introduces a barrier.
    ///
    ///     This function is equivalent to {@link OSAtomicCompareAndSwap32} on 32-bit architectures,
    ///     or {@link OSAtomicCompareAndSwap64} on 64-bit architectures.
    ///     @result Returns TRUE on a match, FALSE otherwise.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_compare_exchange_strong() from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwapLongBarrier(
        old_value: c_long,
        new_value: c_long,
        the_value: *mut c_long,
    ) -> bool;
}

extern "C-unwind" {
    /// Compare and swap for
    /// <code>
    /// uint64_t
    /// </code>
    /// values.
    ///
    /// This function compares the value in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the value
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the values
    /// match, this function stores the value from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// Returns: Returns TRUE on a match, FALSE otherwise.
    #[deprecated = "Use atomic_compare_exchange_strong_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwap64(
        old_value: i64,
        new_value: i64,
        the_value: *mut libc::OSAtomic_int64_aligned64_t,
    ) -> bool;
}

extern "C-unwind" {
    /// Compare and swap for
    /// <code>
    /// uint64_t
    /// </code>
    /// values.
    ///
    /// This function compares the value in
    /// <code>
    /// __oldValue
    /// </code>
    /// to the value
    /// in the memory location referenced by
    /// <code>
    /// __theValue
    /// </code>
    /// .  If the values
    /// match, this function stores the value from
    /// <code>
    /// __newValue
    /// </code>
    /// into
    /// that memory location atomically.
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicCompareAndSwap64}
    ///     except that it also introduces a barrier.
    ///     @result Returns TRUE on a match, FALSE otherwise.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_compare_exchange_strong() from <stdatomic.h> instead"]
    pub fn OSAtomicCompareAndSwap64Barrier(
        old_value: i64,
        new_value: i64,
        the_value: *mut libc::OSAtomic_int64_aligned64_t,
    ) -> bool;
}

extern "C-unwind" {
    /// Atomic test and set
    ///
    /// This function tests a bit in the value referenced by
    /// <code>
    /// __theAddress
    /// </code>
    /// and if it is not set, sets it.
    ///
    /// The bit is chosen by the value of
    /// <code>
    /// __n
    /// </code>
    /// such that the
    /// operation will be performed on bit
    /// <code>
    /// (0x80 >> (__n
    /// &
    /// 7))
    /// </code>
    /// of byte
    /// <code>
    /// ((char *)__theAddress + (n >> 3))
    /// </code>
    /// .
    ///
    /// For example, if
    /// <code>
    /// __theAddress
    /// </code>
    /// points to a 64-bit value,
    /// to compare the value of the most significant bit, you would specify
    /// <code>
    /// 56
    /// </code>
    /// for
    /// <code>
    /// __n
    /// </code>
    /// .
    ///
    /// Returns: Returns the original value of the bit being tested.
    #[deprecated = "Use atomic_fetch_or_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicTestAndSet(n: u32, the_address: *mut c_void) -> bool;
}

extern "C-unwind" {
    /// Atomic test and set with barrier
    ///
    /// This function tests a bit in the value referenced by
    /// <code>
    /// __theAddress
    /// </code>
    /// and if it is not set, sets it.
    ///
    /// The bit is chosen by the value of
    /// <code>
    /// __n
    /// </code>
    /// such that the
    /// operation will be performed on bit
    /// <code>
    /// (0x80 >> (__n
    /// &
    /// 7))
    /// </code>
    /// of byte
    /// <code>
    /// ((char *)__theAddress + (n >> 3))
    /// </code>
    /// .
    ///
    /// For example, if
    /// <code>
    /// __theAddress
    /// </code>
    /// points to a 64-bit value,
    /// to compare the value of the most significant bit, you would specify
    /// <code>
    /// 56
    /// </code>
    /// for
    /// <code>
    /// __n
    /// </code>
    /// .
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicTestAndSet}
    ///     except that it also introduces a barrier.
    ///     @result
    ///     Returns the original value of the bit being tested.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_or() from <stdatomic.h> instead"]
    pub fn OSAtomicTestAndSetBarrier(n: u32, the_address: *mut c_void) -> bool;
}

extern "C-unwind" {
    /// Atomic test and clear
    ///
    /// This function tests a bit in the value referenced by
    /// <code>
    /// __theAddress
    /// </code>
    /// and if it is not cleared, clears it.
    ///
    /// The bit is chosen by the value of
    /// <code>
    /// __n
    /// </code>
    /// such that the
    /// operation will be performed on bit
    /// <code>
    /// (0x80 >> (__n
    /// &
    /// 7))
    /// </code>
    /// of byte
    /// <code>
    /// ((char *)__theAddress + (n >> 3))
    /// </code>
    /// .
    ///
    /// For example, if
    /// <code>
    /// __theAddress
    /// </code>
    /// points to a 64-bit value,
    /// to compare the value of the most significant bit, you would specify
    /// <code>
    /// 56
    /// </code>
    /// for
    /// <code>
    /// __n
    /// </code>
    /// .
    ///
    ///
    /// Returns: Returns the original value of the bit being tested.
    #[deprecated = "Use atomic_fetch_and_explicit(memory_order_relaxed) from <stdatomic.h> instead"]
    pub fn OSAtomicTestAndClear(n: u32, the_address: *mut c_void) -> bool;
}

extern "C-unwind" {
    /// Atomic test and clear
    ///
    /// This function tests a bit in the value referenced by
    /// <code>
    /// __theAddress
    /// </code>
    /// and if it is not cleared, clears it.
    ///
    /// The bit is chosen by the value of
    /// <code>
    /// __n
    /// </code>
    /// such that the
    /// operation will be performed on bit
    /// <code>
    /// (0x80 >> (__n
    /// &
    /// 7))
    /// </code>
    /// of byte
    /// <code>
    /// ((char *)__theAddress + (n >> 3))
    /// </code>
    /// .
    ///
    /// For example, if
    /// <code>
    /// __theAddress
    /// </code>
    /// points to a 64-bit value,
    /// to compare the value of the most significant bit, you would specify
    /// <code>
    /// 56
    /// </code>
    /// for
    /// <code>
    /// __n
    /// </code>
    /// .
    ///
    /// This function is equivalent to {
    ///
    /// ```text
    ///  OSAtomicTestAndSet}
    ///     except that it also introduces a barrier.
    ///     @result
    ///     Returns the original value of the bit being tested.
    ///  
    ///
    /// ```
    #[deprecated = "Use atomic_fetch_and() from <stdatomic.h> instead"]
    pub fn OSAtomicTestAndClearBarrier(n: u32, the_address: *mut c_void) -> bool;
}

extern "C-unwind" {
    /// Memory barrier.
    ///
    /// This function serves as both a read and write barrier.
    #[deprecated = "Use atomic_thread_fence() from <stdatomic.h> instead"]
    pub fn OSMemoryBarrier();
}

/// [Apple's documentation](https://developer.apple.com/documentation/darwin/osfifoqueuehead?language=objc)
pub type OSFifoQueueHead = libc::UnknownStruct;

extern "C-unwind" {
    /// Enqueue an element onto a list.
    ///
    /// Memory barriers are incorporated as needed to permit thread-safe access
    /// to the queue element.
    ///
    /// Parameter `__list`: The list on which you want to enqueue the element.
    ///
    /// Parameter `__new`: The element to add.
    ///
    /// Parameter `__offset`: The "offset" parameter is the offset (in bytes) of the link field
    /// from the beginning of the data structure being queued (
    /// <code>
    /// __new
    /// </code>
    /// ).
    /// The link field should be a pointer type.
    /// The
    /// <code>
    /// __offset
    /// </code>
    /// value needs to be same for all enqueuing and
    /// dequeuing operations on the same list, even if different structure types
    /// are enqueued on that list.  The use of
    /// <code>
    /// offsetset()
    /// </code>
    /// , defined in
    /// <code>
    /// stddef.h
    /// </code>
    /// is the common way to specify the
    /// <code>
    /// __offset
    /// </code>
    /// value.
    ///
    ///
    /// Note: This API is deprecated and no longer recommended
    #[deprecated = "No longer supported"]
    pub fn OSAtomicFifoEnqueue(list: *mut libc::OSFifoQueueHead, new: *mut c_void, offset: usize);
}

extern "C-unwind" {
    /// Dequeue an element from a list.
    ///
    /// Memory barriers are incorporated as needed to permit thread-safe access
    /// to the queue element.
    ///
    /// Parameter `__list`: The list from which you want to dequeue an element.
    ///
    /// Parameter `__offset`: The "offset" parameter is the offset (in bytes) of the link field
    /// from the beginning of the data structure being dequeued (
    /// <code>
    /// __new
    /// </code>
    /// ).
    /// The link field should be a pointer type.
    /// The
    /// <code>
    /// __offset
    /// </code>
    /// value needs to be same for all enqueuing and
    /// dequeuing operations on the same list, even if different structure types
    /// are enqueued on that list.  The use of
    /// <code>
    /// offsetset()
    /// </code>
    /// , defined in
    /// <code>
    /// stddef.h
    /// </code>
    /// is the common way to specify the
    /// <code>
    /// __offset
    /// </code>
    /// value.
    ///
    /// Returns: Returns the oldest enqueued element, or
    /// <code>
    /// NULL
    /// </code>
    /// if the
    /// list is empty.
    ///
    ///
    /// Note: This API is deprecated and no longer recommended
    #[deprecated = "No longer supported"]
    pub fn OSAtomicFifoDequeue(list: *mut libc::OSFifoQueueHead, offset: usize) -> *mut c_void;
}

/// Data type for a spinlock.
///
/// You should always initialize a spinlock to {
///
/// ```text
///  OS_SPINLOCK_INIT} before
///     using it.
///  
///
/// ```
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/darwin/osspinlock?language=objc)
pub type OSSpinLock = i32;

extern "C-unwind" {
    /// Locks a spinlock if it would not block
    ///
    /// Returns: Returns
    /// <code>
    /// false
    /// </code>
    /// if the lock was already held by another thread,
    /// <code>
    /// true
    /// </code>
    /// if it took the lock successfully.
    #[deprecated = "Use os_unfair_lock_trylock() from <os/lock.h> instead"]
    pub fn OSSpinLockTry(lock: *mut libc::OSSpinLock) -> bool;
}

extern "C-unwind" {
    /// Locks a spinlock
    ///
    /// Although the lock operation spins, it employs various strategies to back
    /// off if the lock is held.
    #[deprecated = "Use os_unfair_lock_lock() from <os/lock.h> instead"]
    pub fn OSSpinLockLock(lock: *mut libc::OSSpinLock);
}

extern "C-unwind" {
    /// Unlocks a spinlock
    #[deprecated = "Use os_unfair_lock_unlock() from <os/lock.h> instead"]
    pub fn OSSpinLockUnlock(lock: *mut libc::OSSpinLock);
}

/// [Apple's documentation](https://developer.apple.com/documentation/darwin/osqueuehead?language=objc)
pub type OSQueueHead = libc::UnknownStruct;

extern "C-unwind" {
    /// Enqueue an element onto a list.
    ///
    /// Memory barriers are incorporated as needed to permit thread-safe access
    /// to the queue element.
    ///
    /// Parameter `__list`: The list on which you want to enqueue the element.
    ///
    /// Parameter `__new`: The element to add.
    ///
    /// Parameter `__offset`: The "offset" parameter is the offset (in bytes) of the link field
    /// from the beginning of the data structure being queued (
    /// <code>
    /// __new
    /// </code>
    /// ).
    /// The link field should be a pointer type.
    /// The
    /// <code>
    /// __offset
    /// </code>
    /// value needs to be same for all enqueuing and
    /// dequeuing operations on the same list, even if different structure types
    /// are enqueued on that list.  The use of
    /// <code>
    /// offsetset()
    /// </code>
    /// , defined in
    /// <code>
    /// stddef.h
    /// </code>
    /// is the common way to specify the
    /// <code>
    /// __offset
    /// </code>
    /// value.
    pub fn OSAtomicEnqueue(list: *mut libc::OSQueueHead, new: *mut c_void, offset: usize);
}

extern "C-unwind" {
    /// Dequeue an element from a list.
    ///
    /// Memory barriers are incorporated as needed to permit thread-safe access
    /// to the queue element.
    ///
    /// Parameter `__list`: The list from which you want to dequeue an element.
    ///
    /// Parameter `__offset`: The "offset" parameter is the offset (in bytes) of the link field
    /// from the beginning of the data structure being dequeued (
    /// <code>
    /// __new
    /// </code>
    /// ).
    /// The link field should be a pointer type.
    /// The
    /// <code>
    /// __offset
    /// </code>
    /// value needs to be same for all enqueuing and
    /// dequeuing operations on the same list, even if different structure types
    /// are enqueued on that list.  The use of
    /// <code>
    /// offsetset()
    /// </code>
    /// , defined in
    /// <code>
    /// stddef.h
    /// </code>
    /// is the common way to specify the
    /// <code>
    /// __offset
    /// </code>
    /// value.
    /// IMPORTANT: the memory backing the link field of a queue element must not be
    /// unmapped after OSAtomicDequeue() returns until all concurrent calls to
    /// OSAtomicDequeue() for the same list on other threads have also returned,
    /// as they may still be accessing that memory location.
    ///
    /// Returns: Returns the most recently enqueued element, or
    /// <code>
    /// NULL
    /// </code>
    /// if the
    /// list is empty.
    pub fn OSAtomicDequeue(list: *mut libc::OSQueueHead, offset: usize) -> *mut c_void;
}
