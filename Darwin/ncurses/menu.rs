//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::ffi::*;

pub type Menu_Options = c_int;

pub type Item_Options = c_int;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct TEXT {
    pub str: *const c_char,
    pub length: c_ushort,
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct tagITEM {
    /// name of menu item
    pub name: TEXT,
    /// description of item, optional in display
    pub description: TEXT,
    /// Pointer to parent menu
    pub imenu: *mut tagMENU,
    /// Pointer to user defined per item data
    pub userptr: *mut c_void,
    /// Item options
    pub opt: Item_Options,
    /// Item number if connected to a menu
    pub index: c_short,
    /// y and x location of item in menu
    pub y: c_short,
    pub x: c_short,
    /// Selection value
    pub value: bool,
    /// neighbor items
    pub left: *mut Self,
    pub right: *mut Self,
    pub up: *mut Self,
    pub down: *mut Self,
}

pub type ITEM = Self;

pub type Menu_Hook = Option<unsafe extern "C-unwind" fn(*mut Self)>;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct tagMENU {
    /// Nr. of chars high
    pub height: c_short,
    /// Nr. of chars wide
    pub width: c_short,
    /// Nr. of items high
    pub rows: c_short,
    /// Nr. of items wide
    pub cols: c_short,
    /// Nr. of formatted items high
    pub frows: c_short,
    /// Nr. of formatted items wide
    pub fcols: c_short,
    /// Nr. of items high (actual)
    pub arows: c_short,
    /// Max. name length
    pub namelen: c_short,
    /// Max. description length
    pub desclen: c_short,
    /// Length of mark, if any
    pub marklen: c_short,
    /// Length of one item
    pub itemlen: c_short,
    /// Spacing for descriptor
    pub spc_desc: c_short,
    /// Spacing for columns
    pub spc_cols: c_short,
    /// Spacing for rows
    pub spc_rows: c_short,
    /// Buffer to store match chars
    pub pattern: *mut c_char,
    /// Index into pattern buffer
    pub pindex: c_short,
    /// Window containing menu
    pub win: *mut WINDOW,
    /// Subwindow for menu display
    pub sub: *mut WINDOW,
    /// User's window
    pub userwin: *mut WINDOW,
    /// User's subwindow
    pub usersub: *mut WINDOW,
    /// array of items
    pub items: *mut *mut ITEM,
    /// Nr. of items in menu
    pub nitems: c_short,
    /// Current item
    pub curitem: *mut ITEM,
    /// Top row of menu
    pub toprow: c_short,
    /// Selection attribute
    pub fore: chtype,
    /// Nonselection attribute
    pub back: chtype,
    /// Inactive attribute
    pub grey: chtype,
    /// Pad character
    pub pad: c_uchar,
    /// User hooks
    pub menuinit: Menu_Hook,
    pub menuterm: Menu_Hook,
    pub iteminit: Menu_Hook,
    pub itemterm: Menu_Hook,
    /// Pointer to menus user data
    pub userptr: *mut c_void,
    /// Pointer to marker string
    pub mark: *mut c_char,
    /// Menu options
    pub opt: Menu_Options,
    /// Internal state of menu
    pub status: c_ushort,
}

pub type MENU = Self;

extern "C-unwind" {
    /// --------- prototypes for libmenu functions -----------------------------
    pub fn menu_items(param1: Option<&MENU>) -> *mut *mut ITEM;
}

#[inline]
pub unsafe extern "C-unwind" fn current_item(param1: Option<&MENU>) -> Option<Retained<ITEM>> {
    extern "C-unwind" {
        fn current_item(param1: Option<&MENU>) -> *mut ITEM;
    }
    let ret = unsafe { current_item(param1) };
    unsafe { Retained::retain_autoreleased(ret) }
}

#[inline]
pub unsafe extern "C-unwind" fn new_item(
    param1: *const c_char,
    param1: *const c_char,
) -> Option<Retained<ITEM>> {
    extern "C-unwind" {
        fn new_item(param1: *const c_char, param1: *const c_char) -> *mut ITEM;
    }
    let ret = unsafe { new_item(param1, param1) };
    unsafe { Retained::retain_autoreleased(ret) }
}

#[inline]
pub unsafe extern "C-unwind" fn new_menu(param1: *mut *mut ITEM) -> Option<Retained<MENU>> {
    extern "C-unwind" {
        fn new_menu(param1: *mut *mut ITEM) -> *mut MENU;
    }
    let ret = unsafe { new_menu(param1) };
    unsafe { Retained::retain_autoreleased(ret) }
}

extern "C-unwind" {
    pub fn item_opts(param1: Option<&ITEM>) -> Item_Options;
}

extern "C-unwind" {
    pub fn menu_opts(param1: Option<&MENU>) -> Menu_Options;
}

extern "C-unwind" {
    pub fn item_init(param1: Option<&MENU>) -> Menu_Hook;
}

extern "C-unwind" {
    pub fn item_term(param1: Option<&MENU>) -> Menu_Hook;
}

extern "C-unwind" {
    pub fn menu_init(param1: Option<&MENU>) -> Menu_Hook;
}

extern "C-unwind" {
    pub fn menu_term(param1: Option<&MENU>) -> Menu_Hook;
}

extern "C-unwind" {
    pub fn menu_sub(param1: Option<&MENU>) -> *mut WINDOW;
}

extern "C-unwind" {
    pub fn menu_win(param1: Option<&MENU>) -> *mut WINDOW;
}

extern "C-unwind" {
    pub fn item_description(param1: Option<&ITEM>) -> *const c_char;
}

extern "C-unwind" {
    pub fn item_name(param1: Option<&ITEM>) -> *const c_char;
}

extern "C-unwind" {
    pub fn menu_mark(param1: Option<&MENU>) -> *const c_char;
}

extern "C-unwind" {
    pub fn menu_request_name(param1: c_int) -> *const c_char;
}

extern "C-unwind" {
    pub fn menu_pattern(param1: Option<&MENU>) -> *mut c_char;
}

extern "C-unwind" {
    pub fn menu_userptr(param1: Option<&MENU>) -> *mut c_void;
}

extern "C-unwind" {
    pub fn item_userptr(param1: Option<&ITEM>) -> *mut c_void;
}

extern "C-unwind" {
    pub fn menu_back(param1: Option<&MENU>) -> chtype;
}

extern "C-unwind" {
    pub fn menu_fore(param1: Option<&MENU>) -> chtype;
}

extern "C-unwind" {
    pub fn menu_grey(param1: Option<&MENU>) -> chtype;
}

extern "C-unwind" {
    pub fn free_item(param1: Option<&ITEM>) -> c_int;
}

extern "C-unwind" {
    pub fn free_menu(param1: Option<&MENU>) -> c_int;
}

extern "C-unwind" {
    pub fn item_count(param1: Option<&MENU>) -> c_int;
}

extern "C-unwind" {
    pub fn item_index(param1: Option<&ITEM>) -> c_int;
}

extern "C-unwind" {
    pub fn item_opts_off(param1: Option<&ITEM>, param1: Item_Options) -> c_int;
}

extern "C-unwind" {
    pub fn item_opts_on(param1: Option<&ITEM>, param1: Item_Options) -> c_int;
}

extern "C-unwind" {
    pub fn menu_driver(param1: Option<&MENU>, param1: c_int) -> c_int;
}

extern "C-unwind" {
    pub fn menu_opts_off(param1: Option<&MENU>, param1: Menu_Options) -> c_int;
}

extern "C-unwind" {
    pub fn menu_opts_on(param1: Option<&MENU>, param1: Menu_Options) -> c_int;
}

extern "C-unwind" {
    pub fn menu_pad(param1: Option<&MENU>) -> c_int;
}

extern "C-unwind" {
    pub fn pos_menu_cursor(param1: Option<&MENU>) -> c_int;
}

extern "C-unwind" {
    pub fn post_menu(param1: Option<&MENU>) -> c_int;
}

extern "C-unwind" {
    pub fn scale_menu(param1: Option<&MENU>, param1: *mut c_int, param1: *mut c_int) -> c_int;
}

extern "C-unwind" {
    pub fn set_current_item(menu: Option<&MENU>, item: Option<&ITEM>) -> c_int;
}

extern "C-unwind" {
    pub fn set_item_init(param1: Option<&MENU>, param1: Menu_Hook) -> c_int;
}

extern "C-unwind" {
    pub fn set_item_opts(param1: Option<&ITEM>, param1: Item_Options) -> c_int;
}

extern "C-unwind" {
    pub fn set_item_term(param1: Option<&MENU>, param1: Menu_Hook) -> c_int;
}

extern "C-unwind" {
    pub fn set_item_userptr(param1: Option<&ITEM>, param1: *mut c_void) -> c_int;
}

extern "C-unwind" {
    pub fn set_item_value(param1: Option<&ITEM>, param1: bool) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_back(param1: Option<&MENU>, param1: chtype) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_fore(param1: Option<&MENU>, param1: chtype) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_format(param1: Option<&MENU>, param1: c_int, param1: c_int) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_grey(param1: Option<&MENU>, param1: chtype) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_init(param1: Option<&MENU>, param1: Menu_Hook) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_items(param1: Option<&MENU>, param1: *mut *mut ITEM) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_mark(param1: Option<&MENU>, param1: *const c_char) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_opts(param1: Option<&MENU>, param1: Menu_Options) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_pad(param1: Option<&MENU>, param1: c_int) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_pattern(param1: Option<&MENU>, param1: *const c_char) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_sub(param1: Option<&MENU>, param1: *mut WINDOW) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_term(param1: Option<&MENU>, param1: Menu_Hook) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_userptr(param1: Option<&MENU>, param1: *mut c_void) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_win(param1: Option<&MENU>, param1: *mut WINDOW) -> c_int;
}

extern "C-unwind" {
    pub fn set_top_row(param1: Option<&MENU>, param1: c_int) -> c_int;
}

extern "C-unwind" {
    pub fn top_row(param1: Option<&MENU>) -> c_int;
}

extern "C-unwind" {
    pub fn unpost_menu(param1: Option<&MENU>) -> c_int;
}

extern "C-unwind" {
    pub fn menu_request_by_name(param1: *const c_char) -> c_int;
}

extern "C-unwind" {
    pub fn set_menu_spacing(
        param1: Option<&MENU>,
        param1: c_int,
        param1: c_int,
        param1: c_int,
    ) -> c_int;
}

extern "C-unwind" {
    pub fn menu_spacing(
        param1: Option<&MENU>,
        param1: *mut c_int,
        param1: *mut c_int,
        param1: *mut c_int,
    ) -> c_int;
}

extern "C-unwind" {
    pub fn item_value(param1: Option<&ITEM>) -> bool;
}

extern "C-unwind" {
    pub fn item_visible(param1: Option<&ITEM>) -> bool;
}

extern "C-unwind" {
    pub fn menu_format(param1: Option<&MENU>, param1: *mut c_int, param1: *mut c_int);
}
