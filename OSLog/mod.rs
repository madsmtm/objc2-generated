// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "OSLog", kind = "framework")]
extern "C" {}

use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// A classification of how the entry was to be stored and rotated at the point when it was created.
///
/// ## Overview
///
/// The unified logging system keeps entries in one of two locations: a ring buffer in memory, or a persisted data store. Entries rotate out to free up resources; they are rotated out in bulk according to heuristics based on space, time, and entry classification.
///
///
/// A classification of how the entry was to be stored and
/// rotated at the point when it was created.
///
///
/// The unified logging system keeps entries in one of two
/// places: a ring buffer in memory and a persisted data store.
/// Entries are rotated out of both places to free up resources.
/// This rotation is not strictly aligned with entries'
/// timestamps --- in particular, they can be rotated in bulk,
/// and they are rotated according to a series of heuristics that
/// take into account space, time, and how the entries were
/// classified.
///
///
/// This entry was generated as information about the other
/// entries or about the sequence of entries as a whole.
///
///
/// This entry was not intended to be long-lived and was captured
/// in the ring buffer.
///
///
/// The entry was intended to be persisted in a filesystem-backed
/// data store and kept mainly based on the amount of space
/// available.
///
///
///
///
///
///
/// The entry was tagged with a hint indicating that the system
/// should try to preserve it for a certain amount of time. It
/// was persisted in the filesystem-backed data store, and
/// rotation of these entries was based on both time and space
/// considerations.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OSLogEntryStoreCategory(pub NSInteger);
impl OSLogEntryStoreCategory {
    /// This entry’s purpose is unknown.
    #[doc(alias = "OSLogEntryStoreCategoryUndefined")]
    pub const Undefined: Self = Self(0);
    /// This entry was generated as information about the other entries or about the sequence of entries as a whole.
    #[doc(alias = "OSLogEntryStoreCategoryMetadata")]
    pub const Metadata: Self = Self(1);
    /// This entry was not intended to be long-lived, and was captured in the ring buffer.
    #[doc(alias = "OSLogEntryStoreCategoryShortTerm")]
    pub const ShortTerm: Self = Self(2);
    /// The entry was tagged with a hint indicating the system should try to preserve it based on the amount of space available.
    ///
    /// ## Discussion
    ///
    /// Instead of tagging a hint with a number of days that the entry should be preserved, the `longTermAuto` case is preserved based on the amount of space available. Therefore, it will automatically make determinations on how long to preserve the entry. Entries using this case should be persisted in a filesystem-backed data store.
    ///
    ///
    #[doc(alias = "OSLogEntryStoreCategoryLongTermAuto")]
    pub const LongTermAuto: Self = Self(3);
    /// The entry was tagged with a hint indicating the system should try to preserve it for approximately 1 day.
    ///
    /// ## Discussion
    ///
    /// It was persisted in the filesystem-backed date store, and rotation of these entries was based on both time and space considerations.
    ///
    ///
    #[doc(alias = "OSLogEntryStoreCategoryLongTerm1")]
    pub const LongTerm1: Self = Self(4);
    /// The entry was tagged with a hint indicating the system should try to preserve it for approximately 3 days.
    ///
    /// ## Discussion
    ///
    /// It was persisted in the filesystem-backed date store, and rotation of these entries was based on both time and space considerations.
    ///
    ///
    #[doc(alias = "OSLogEntryStoreCategoryLongTerm3")]
    pub const LongTerm3: Self = Self(5);
    /// The entry was tagged with a hint indicating the system should try to preserve it for approximately 7 days.
    ///
    /// ## Discussion
    ///
    /// It was persisted in the filesystem-backed date store, and rotation of these entries was based on both time and space considerations.
    ///
    ///
    #[doc(alias = "OSLogEntryStoreCategoryLongTerm7")]
    pub const LongTerm7: Self = Self(6);
    /// The entry was tagged with a hint indicating the system should try to preserve it for approximately 14 days.
    ///
    /// ## Discussion
    ///
    /// It was persisted in the filesystem-backed date store, and rotation of these entries was based on both time and space considerations.
    ///
    ///
    #[doc(alias = "OSLogEntryStoreCategoryLongTerm14")]
    pub const LongTerm14: Self = Self(7);
    /// The entry was tagged with a hint indicating the system should try to preserve it for approximately 30 days.
    ///
    /// ## Discussion
    ///
    /// It was persisted in the filesystem-backed date store, and rotation of these entries was based on both time and space considerations.
    ///
    ///
    #[doc(alias = "OSLogEntryStoreCategoryLongTerm30")]
    pub const LongTerm30: Self = Self(8);
}

unsafe impl Encode for OSLogEntryStoreCategory {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for OSLogEntryStoreCategory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A single entry from the unified logging system.
    /// A single entry from the unified logging system.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSLogEntry;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSLogEntry {}
);

impl OSLogEntry {
    extern_methods!(
        /// The fully formatted message for the entry.
        #[unsafe(method(composedMessage))]
        #[unsafe(method_family = none)]
        pub unsafe fn composedMessage(&self) -> Retained<NSString>;

        /// The timestamp of the entry.
        #[unsafe(method(date))]
        #[unsafe(method_family = none)]
        pub unsafe fn date(&self) -> Retained<NSDate>;

        /// This entry's storage tag. See OSLogEntryStoreCategory.
        #[unsafe(method(storeCategory))]
        #[unsafe(method_family = none)]
        pub unsafe fn storeCategory(&self) -> OSLogEntryStoreCategory;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSLogEntry {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A protocol that defines subclasses containing metadata about a process.
    /// Entry subclasses conforming to this protocol represent data
    /// that are generated from a process; they have metadata about
    /// the originator.
    pub unsafe trait OSLogEntryFromProcess {
        /// The activity ID associated with the entry.
        #[unsafe(method(activityIdentifier))]
        #[unsafe(method_family = none)]
        unsafe fn activityIdentifier(&self) -> os_activity_id_t;

        /// The name of the process that made the entry.
        #[unsafe(method(process))]
        #[unsafe(method_family = none)]
        unsafe fn process(&self) -> Retained<NSString>;

        #[cfg(feature = "libc")]
        /// The pid of the process that made the entry.
        #[unsafe(method(processIdentifier))]
        #[unsafe(method_family = none)]
        unsafe fn processIdentifier(&self) -> libc::pid_t;

        /// The name of the binary image that made the entry.
        #[unsafe(method(sender))]
        #[unsafe(method_family = none)]
        unsafe fn sender(&self) -> Retained<NSString>;

        /// The tid of the thread that made the entry.
        #[unsafe(method(threadIdentifier))]
        #[unsafe(method_family = none)]
        unsafe fn threadIdentifier(&self) -> u64;
    }
);

extern_protocol!(
    /// A protocol defining subclasses that represent entries made using a handle and a format string.
    /// Entry subclasses conforming to this protocol represent
    /// entries that were made using a handle and a format string.
    pub unsafe trait OSLogEntryWithPayload {
        /// The category from the os_log_t handle used.
        #[unsafe(method(category))]
        #[unsafe(method_family = none)]
        unsafe fn category(&self) -> Retained<NSString>;

        /// An array of the various parts of the composed message.
        #[unsafe(method(components))]
        #[unsafe(method_family = none)]
        unsafe fn components(&self) -> Retained<NSArray<OSLogMessageComponent>>;

        /// The format string used.
        #[unsafe(method(formatString))]
        #[unsafe(method_family = none)]
        unsafe fn formatString(&self) -> Retained<NSString>;

        /// The subsystem of the os_log_t handle used.
        #[unsafe(method(subsystem))]
        #[unsafe(method_family = none)]
        unsafe fn subsystem(&self) -> Retained<NSString>;
    }
);

impl OSLogEntry {
    extern_methods!();
}

extern_conformance!(
    unsafe impl NSSecureCoding for OSLogEntry {}
);

extern_class!(
    /// An entry generated by an activity event.
    /// An entry generated by an activity event.
    #[unsafe(super(OSLogEntry, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSLogEntryActivity;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSLogEntryActivity {}
);

extern_conformance!(
    unsafe impl OSLogEntryFromProcess for OSLogEntryActivity {}
);

impl OSLogEntryActivity {
    extern_methods!(
        /// This parent activity's activity ID.
        #[unsafe(method(parentActivityIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn parentActivityIdentifier(&self) -> os_activity_id_t;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSLogEntryActivity {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// The metadata that partitions sequences of other entries.
    /// This entry represents metadata that partitions sequences of
    /// other entries.
    ///
    ///
    /// For example, this kind of entry is used for boot boundaries.
    /// The data here are currently informational and carried in the
    /// composedMessage property.
    #[unsafe(super(OSLogEntry, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSLogEntryBoundary;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSLogEntryBoundary {}
);

impl OSLogEntryBoundary {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl OSLogEntryBoundary {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The log level at which the entry was generated.
/// The level that this entry was generated at.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OSLogEntryLogLevel(pub NSInteger);
impl OSLogEntryLogLevel {
    /// The log level was never specified.
    ///
    /// ## Discussion
    ///
    /// You should never encounter an undefined log level.
    ///
    ///
    #[doc(alias = "OSLogEntryLogLevelUndefined")]
    pub const Undefined: Self = Self(0);
    /// A log level that captures diagnostic information.
    ///
    /// ## Discussion
    ///
    /// This level captures information that may be useful during development or while troubleshooting a specific problem.
    ///
    ///
    #[doc(alias = "OSLogEntryLogLevelDebug")]
    pub const Debug: Self = Self(1);
    /// The log level that captures additional information.
    ///
    /// ## Discussion
    ///
    /// This log level captures information that may be helpful but isn’t essential for troubleshooting errors.
    ///
    ///
    #[doc(alias = "OSLogEntryLogLevelInfo")]
    pub const Info: Self = Self(2);
    /// The log level that captures notifications.
    ///
    /// ## Discussion
    ///
    /// This log level captures normal `os_log` entries used to generate notifications on system errors.
    ///
    ///
    #[doc(alias = "OSLogEntryLogLevelNotice")]
    pub const Notice: Self = Self(3);
    /// The log level that captures errors.
    ///
    /// ## Discussion
    ///
    /// This log level captures process-level information to report errors in the process.
    ///
    ///
    #[doc(alias = "OSLogEntryLogLevelError")]
    pub const Error: Self = Self(4);
    /// The log level that captures fault information.
    ///
    /// ## Discussion
    ///
    /// This log level represents system errors.
    ///
    ///
    #[doc(alias = "OSLogEntryLogLevelFault")]
    pub const Fault: Self = Self(5);
}

unsafe impl Encode for OSLogEntryLogLevel {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for OSLogEntryLogLevel {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A log entry.
    ///
    /// ## Overview
    ///
    /// These log entries are generated by the os_log API. To learn more about how to generate a log entry, see [`os_log(_:dso:log:_:_:)`](https://developer.apple.comhttps://developer.apple.com/documentation/os/3019240-os_log) and [`os_log(_:dso:log:type:_:)`](https://developer.apple.comhttps://developer.apple.com/documentation/os/2320718-os_log).
    ///
    ///
    /// Entries made by the os_log API.
    #[unsafe(super(OSLogEntry, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSLogEntryLog;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSLogEntryLog {}
);

extern_conformance!(
    unsafe impl OSLogEntryFromProcess for OSLogEntryLog {}
);

extern_conformance!(
    unsafe impl OSLogEntryWithPayload for OSLogEntryLog {}
);

impl OSLogEntryLog {
    extern_methods!(
        /// The level of the entry, e.g., info, debug.
        #[unsafe(method(level))]
        #[unsafe(method_family = none)]
        pub unsafe fn level(&self) -> OSLogEntryLogLevel;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSLogEntryLog {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The available signpost types.
/// The kind of of signpost emitted.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OSLogEntrySignpostType(pub NSInteger);
impl OSLogEntrySignpostType {
    /// The signpost does not have a type.
    ///
    /// ## Discussion
    ///
    /// You should never encounter an undefined signpost type.
    ///
    ///
    #[doc(alias = "OSLogEntrySignpostTypeUndefined")]
    pub const Undefined: Self = Self(0);
    /// The signpost marks the start of a time interval.
    #[doc(alias = "OSLogEntrySignpostTypeIntervalBegin")]
    pub const IntervalBegin: Self = Self(1);
    /// The signpost marks the end of a time interval.
    #[doc(alias = "OSLogEntrySignpostTypeIntervalEnd")]
    pub const IntervalEnd: Self = Self(2);
    /// The signpost marks an event.
    #[doc(alias = "OSLogEntrySignpostTypeEvent")]
    pub const Event: Self = Self(3);
}

unsafe impl Encode for OSLogEntrySignpostType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for OSLogEntrySignpostType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An entry containing a signpost.
    ///
    /// ## Overview
    ///
    /// These entries are created by the os_signpost API. To learn more about signposts and how to create a signpost entry, see [`os_signpost(_:dso:log:name:signpostID:)`](https://developer.apple.com/documentation/os/os_signpost(_:dso:log:name:signpostid:)-2oz8u) and [`os_signpost(_:dso:log:name:signpostID:_:_:)`](https://developer.apple.com/documentation/os/os_signpost(_:dso:log:name:signpostid:_:_:)-2om9b).
    ///
    ///
    /// Entries made by the os_signpost API.
    #[unsafe(super(OSLogEntry, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSLogEntrySignpost;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSLogEntrySignpost {}
);

extern_conformance!(
    unsafe impl OSLogEntryFromProcess for OSLogEntrySignpost {}
);

extern_conformance!(
    unsafe impl OSLogEntryWithPayload for OSLogEntrySignpost {}
);

impl OSLogEntrySignpost {
    extern_methods!(
        /// The signpost ID associated with this entry.
        #[unsafe(method(signpostIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn signpostIdentifier(&self) -> os_signpost_id_t;

        /// The signpost name associated with this entry.
        #[unsafe(method(signpostName))]
        #[unsafe(method_family = none)]
        pub unsafe fn signpostName(&self) -> Retained<NSString>;

        /// The signpost type associated with this entry.
        #[unsafe(method(signpostType))]
        #[unsafe(method_family = none)]
        pub unsafe fn signpostType(&self) -> OSLogEntrySignpostType;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSLogEntrySignpost {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Option to control the direction of the iteration.
/// Control the direction of the iteration.
///
///
/// Iterate backward in time. If no starting position is specified,
/// start at the latest entry.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OSLogEnumeratorOptions(pub NSUInteger);
bitflags::bitflags! {
    impl OSLogEnumeratorOptions: NSUInteger {
/// Tells the framework to iterate backwards.
///
/// ## Discussion
///
/// If there is no starting position specified, start at the latest entry.
///
///
        #[doc(alias = "OSLogEnumeratorReverse")]
        const Reverse = 0x01;
    }
}

unsafe impl Encode for OSLogEnumeratorOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for OSLogEnumeratorOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An enumerator that can access and list log entries.
    /// An enumerator that views entries in the unified logging system.
    #[unsafe(super(NSEnumerator, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSLogEnumerator;
);

extern_conformance!(
    unsafe impl NSFastEnumeration for OSLogEnumerator {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSLogEnumerator {}
);

impl OSLogEnumerator {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl OSLogEnumerator {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// The data type corresponding to the argument provided in a message payload.
///
/// ## Overview
///
/// For example, `OSLogMessageComponent` can represent the number associated with a `%d` placeholder. This value can be undefined if the argument data cann’t be decoded, for example if it were redacted.
///
///
/// The kind of data corresponding to an argument in a message
/// payload, like the number associated with a "%d" placeholder.
/// This value can be undefined if the argument data cannot be
/// decoded; for example, it may be redacted.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OSLogMessageComponentArgumentCategory(pub NSInteger);
impl OSLogMessageComponentArgumentCategory {
    /// The argument’s type is not defined.
    #[doc(alias = "OSLogMessageComponentArgumentCategoryUndefined")]
    pub const Undefined: Self = Self(0);
    /// The argument is an [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) object.
    #[doc(alias = "OSLogMessageComponentArgumentCategoryData")]
    pub const Data: Self = Self(1);
    /// The argument is a double.
    #[doc(alias = "OSLogMessageComponentArgumentCategoryDouble")]
    pub const Double: Self = Self(2);
    /// The argument is a 64-bit signed integer.
    #[doc(alias = "OSLogMessageComponentArgumentCategoryInt64")]
    pub const Int64: Self = Self(3);
    /// The argument is a string.
    #[doc(alias = "OSLogMessageComponentArgumentCategoryString")]
    pub const String: Self = Self(4);
    /// The argument is a 64-bit unsigned integer.
    #[doc(alias = "OSLogMessageComponentArgumentCategoryUInt64")]
    pub const UInt64: Self = Self(5);
}

unsafe impl Encode for OSLogMessageComponentArgumentCategory {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for OSLogMessageComponentArgumentCategory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The message arguments for a particular entry.
    ///
    /// ## Overview
    ///
    /// There is one component for each placeholder in the formatString plus one component for any text after the last placeholder.
    ///
    ///
    /// The message arguments for a particular entry. There is one
    /// component for each placeholder in the formatString plus one
    /// component for any text after the last placeholder.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSLogMessageComponent;
);

extern_conformance!(
    unsafe impl NSCoding for OSLogMessageComponent {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSLogMessageComponent {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for OSLogMessageComponent {}
);

impl OSLogMessageComponent {
    extern_methods!(
        /// The text immediately preceding a placeholder. This can be an
        /// empty string if there is nothing between two placeholders, or
        /// between the placeholder and the bounds of the string.
        #[unsafe(method(formatSubstring))]
        #[unsafe(method_family = none)]
        pub unsafe fn formatSubstring(&self) -> Retained<NSString>;

        /// The placeholder text. Is empty for is the last component.
        #[unsafe(method(placeholder))]
        #[unsafe(method_family = none)]
        pub unsafe fn placeholder(&self) -> Retained<NSString>;

        /// The type of argument corresponding to the placeholder; see
        /// OSLogMessageComponentArgumentCategory.
        #[unsafe(method(argumentCategory))]
        #[unsafe(method_family = none)]
        pub unsafe fn argumentCategory(&self) -> OSLogMessageComponentArgumentCategory;

        /// The argument as a sequence of bytes. Can be nil if the
        /// argument cannot be decoded (for example, it could be
        /// redacted), or if this is the last component.
        #[unsafe(method(argumentDataValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn argumentDataValue(&self) -> Option<Retained<NSData>>;

        /// The argument as a double-precision floating point number; the
        /// value is undefined if the argument cannot be decoded or if this
        /// is the last component.
        #[unsafe(method(argumentDoubleValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn argumentDoubleValue(&self) -> c_double;

        /// The argument as a 64-bit signed integer; the value is undefined
        /// if it cannot be decoded or if this is the last component.
        #[unsafe(method(argumentInt64Value))]
        #[unsafe(method_family = none)]
        pub unsafe fn argumentInt64Value(&self) -> i64;

        /// The argument as a number. Can be nil if the argument cannot
        /// be decoded (for example, it could be redacted), or if this is
        /// the last component.
        #[unsafe(method(argumentNumberValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn argumentNumberValue(&self) -> Option<Retained<NSNumber>>;

        /// The argument as a string. Can be nil if the argument cannot
        /// be decoded (for example, it could be redacted), or if this is
        /// the last component.
        #[unsafe(method(argumentStringValue))]
        #[unsafe(method_family = none)]
        pub unsafe fn argumentStringValue(&self) -> Option<Retained<NSString>>;

        /// The argument as a 64-bit unsigned integer; the value is
        /// undefined if the argument cannot be decoded or if this is the
        /// last component.
        #[unsafe(method(argumentUInt64Value))]
        #[unsafe(method_family = none)]
        pub unsafe fn argumentUInt64Value(&self) -> u64;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSLogMessageComponent {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A representation of a point in a sequence of entries in the unified logging system.
    ///
    /// ## Overview
    ///
    /// Generate positions with [`OSLogStore`](https://developer.apple.com/documentation/oslog/oslogstore) instance methods and use them to view entries from a particular starting point.
    ///
    ///
    /// An opaque abstraction representing a point in a sequence of
    /// entries in the unified logging system.
    ///
    ///
    /// Generate positions with OSLogStore instance methods and use them
    /// to start viewing entries from a particular starting point.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSLogPosition;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSLogPosition {}
);

impl OSLogPosition {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSLogPosition {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Create a store to a subset of the libtrace entries.
///
///
///
/// "System" scope indicates the entire system; i.e., all logs. Entries can be
/// retrieved for the current calling process, i.e., matching pid.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OSLogStoreScope(pub NSInteger);
impl OSLogStoreScope {
    #[doc(alias = "OSLogStoreSystem")]
    pub const System: Self = Self(0);
    #[doc(alias = "OSLogStoreCurrentProcessIdentifier")]
    pub const CurrentProcessIdentifier: Self = Self(1);
}

unsafe impl Encode for OSLogStoreScope {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for OSLogStoreScope {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A set of entries from the unified logging system.
    ///
    /// ## Overview
    ///
    /// Instances of this class represent a fixed range of entries and may be backed by a `logarchive` or your Mac’s local store.
    ///
    /// In Swift, Use the [`getEntries(with:at:matching:)`](https://developer.apple.com/documentation/oslog/oslogstore/getentries(with:at:matching:)) function to retrieve a filtered array of log entries.
    ///
    /// In Objective-C, use instances of this class to create [`OSLogEnumerator`](https://developer.apple.com/documentation/oslog/oslogenumerator) objects. One store can support multiple `OSLogEnumerator` instances concurrently.
    ///
    ///
    /// A set of entries from the unified logging system. Instances
    /// represent a fixed range of entries and may be backed by a
    /// logarchive or the Mac's local store.
    ///
    ///
    /// Entries in OSLogStore objects are used by OSLogEnumerator
    /// instances; one store can support multiple OSLogEnumerator
    /// instances concurrently.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSLogStore;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSLogStore {}
);

impl OSLogStore {
    extern_methods!(
        /// Create an OSLogStore representing the Mac's local store.
        ///
        ///
        /// Parameter `error`: If initialization is unsuccessful --- for example, this process
        /// does not have access to local logs --- return nil and set this
        /// parameter to a pointer to an error object describing the reason.
        ///
        ///
        /// This enables processing of a sequence of logs as of the particular
        /// point in time when this object is created.
        ///
        /// Gaining access to the local unified logging system requires
        /// permission from the system. The caller must be run by an admin
        /// account.
        #[unsafe(method(localStoreAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn localStoreAndReturnError() -> Result<Retained<Self>, Retained<NSError>>;

        /// Create an OSLogStore for a subset of entries in the local store.
        ///
        ///
        /// Parameter `scope`: The kind of subset the OSLogStore is for.
        ///
        ///
        /// Parameter `error`: If initialization is unsuccessful, return nil and set this parameter to a
        /// pointer to an error object that describes the reason.
        #[unsafe(method(storeWithScope:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn storeWithScope_error(
            scope: OSLogStoreScope,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        /// Create an OSLogStore based on a logarchive.
        ///
        ///
        /// Parameter `url`: The path identifying a logarchive to be read.
        ///
        ///
        /// Parameter `error`: If initialization is unsuccessful --- for example, the path is not
        /// to a valid logarchive or the logarchive is not compatible because
        /// it is from a newer version --- return nil and set this parameter
        /// to a pointer to an error object that describes the reason.
        #[unsafe(method(storeWithURL:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn storeWithURL_error(url: &NSURL) -> Result<Retained<Self>, Retained<NSError>>;

        #[deprecated = "Use one of the factory methods"]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Return an OSLogEnumerator object based on an underlying store.
        /// This object represents the sequence of entries for the store.
        /// OSLogStore. Additional parameters control which entries are
        /// yielded and their order.
        ///
        ///
        /// Parameter `options`: Control the direction of iteration.
        ///
        ///
        /// Parameter `position`: Where to start iteration. If nil, depend on the direction of
        /// the iteration: if forwards, start with the earliest entry; if
        /// reverse, start with the latest entry.
        ///
        ///
        /// Parameter `predicate`: A predicate that filters which entries are in the sequence. If
        /// this is nil, yield all entries.
        ///
        ///
        /// Parameter `error`: If the enumerator cannot be set up --- for example, the
        /// predicate has an unrecognized key --- return nil and set this
        /// to a pointer to an error object that describes the reason.
        #[unsafe(method(entriesEnumeratorWithOptions:position:predicate:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn entriesEnumeratorWithOptions_position_predicate_error(
            &self,
            options: OSLogEnumeratorOptions,
            position: Option<&OSLogPosition>,
            predicate: Option<&NSPredicate>,
        ) -> Result<Retained<OSLogEnumerator>, Retained<NSError>>;

        /// Return an OSLogEnumerator object with default options for
        /// viewing the entries; all are viewed, from earliest to latest.
        ///
        ///
        /// Parameter `error`: If the enumerator cannot be set up, return nil and set this
        /// to a pointer to an error object that describes the reason.
        #[unsafe(method(entriesEnumeratorAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn entriesEnumeratorAndReturnError(
            &self,
        ) -> Result<Retained<OSLogEnumerator>, Retained<NSError>>;

        /// Return a position representing the time specified.
        ///
        ///
        /// Parameter `date`: The date to look for.
        ///
        ///
        /// If there are multiple occurences of the same time --- if, for
        /// example, there was a time change during the range of entries
        /// --- the earliest occurrence is used.
        #[unsafe(method(positionWithDate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn positionWithDate(&self, date: &NSDate) -> Retained<OSLogPosition>;

        /// Return a position representing an offset since the end of the time
        /// range that the entries span.
        ///
        ///
        /// Parameter `seconds`: The seconds to add to the last time point in the range of entries.
        #[unsafe(method(positionWithTimeIntervalSinceEnd:))]
        #[unsafe(method_family = none)]
        pub unsafe fn positionWithTimeIntervalSinceEnd(
            &self,
            seconds: NSTimeInterval,
        ) -> Retained<OSLogPosition>;

        /// Return a position representing time since the last boot in the
        /// series of entries.
        ///
        ///
        /// Parameter `seconds`: The seconds to add to the boot time point in the log time range.
        ///
        ///
        /// Negative seconds would create an ambiguous or imprecise position;
        /// this function asserts that the interval is positive.
        #[unsafe(method(positionWithTimeIntervalSinceLatestBoot:))]
        #[unsafe(method_family = none)]
        pub unsafe fn positionWithTimeIntervalSinceLatestBoot(
            &self,
            seconds: NSTimeInterval,
        ) -> Retained<OSLogPosition>;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSLogStore {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
