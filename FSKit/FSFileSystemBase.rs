//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// A protocol containing functionality supplied by FSKit to file system implementations.
    ///
    /// Both ``FSFileSystem`` and ``FSUnaryFileSystem`` conform to this protocol.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsfilesystembase?language=objc)
    pub unsafe trait FSFileSystemBase: NSObjectProtocol {
        #[cfg(feature = "FSContainer")]
        /// The status of the file system container, indicating its readiness and activity.
        ///
        /// A file system container starts in the ``FSContainerState/notReady`` state, and then transitions to the other values of the ``FSContainerState`` enumeration.
        /// The following diagram illustrates the possible state transitions.
        ///
        /// ![A flow diagram of four possible container states. The initial state, notReady, can transition to ready or blocked. The ready state can transition back to not ready, or to blocked or active. The blocked state can transition to ready or not ready. The active state can transition back to ready or to not ready.](fs-file-system-base)
        ///
        /// Your file system implementation updates this property as it changes state.
        /// Many events and operations may trigger a state transition, and some transitions depend on a specific file system's design.
        ///
        /// When using ``FSBlockDeviceResource``, implement the following common state transitions:
        ///
        /// * Calling `loadResource` transitions the state out of ``FSContainerState/notReady``. For all block device file systems, this operation changes the state to either ``FSContainerState/ready`` or ``FSContainerState/blocked``.
        /// * Calling `unloadResource` transitions to the ``FSContainerState/notReady`` state, as does device termination.
        /// * Transitioning from ``FSContainerState/blocked`` to ``FSContainerState/ready`` occurs as a result of resolving the underlying block favorably.
        /// * Transitioning from ``FSContainerState/ready`` to ``FSContainerState/blocked`` is unusal, but valid.
        /// * Transitioning between ``FSContainerState/ready`` and ``FSContainerState/active`` can result from maintenance operations such as ``FSManageableResourceMaintenanceOperations/startCheckWithTask:options:error:``. For a ``FSUnaryFileSystem``, this transition can also occur when activating or deactivating the container's single volume.
        #[unsafe(method(containerStatus))]
        #[unsafe(method_family = none)]
        unsafe fn containerStatus(&self) -> Retained<FSContainerStatus>;

        #[cfg(feature = "FSContainer")]
        /// Setter for [`containerStatus`][Self::containerStatus].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setContainerStatus:))]
        #[unsafe(method_family = none)]
        unsafe fn setContainerStatus(&self, container_status: &FSContainerStatus);

        #[cfg(all(feature = "FSResource", feature = "block2"))]
        /// Wipes existing file systems on the specified resource.
        ///
        /// This method wraps the `wipefs` functionality from `libutil`.
        /// For more information, see the `man` page for `wipefs`.
        ///
        /// - Parameters:
        /// - resource: The ``FSBlockDeviceResource`` to wipe.
        /// - completion: A block or closure that executes after the wipe operation completes. The completion handler receives a single parameter indicating any error that occurs during the operation. If the value is `nil`, the wipe operation succeeded.
        #[unsafe(method(wipeResource:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn wipeResource_completionHandler(
            &self,
            resource: &FSBlockDeviceResource,
            completion: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );
    }
);
