//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The name of a file, expressed as a data buffer.
    ///
    /// ## Overview
    ///
    /// `FSFileName` is the class that carries filenames from the kernel to `FSModule` instances, and carries names back to the kernel as part of directory enumeration.
    ///
    /// A filename is usually a valid UTF-8 sequence, but can be an arbitrary byte sequence that doesn’t conform to that format. As a result, the [`data`](https://developer.apple.com/documentation/fskit/fsfilename/data) property always contains a value, but the [`string`](https://developer.apple.com/documentation/fskit/fsfilename/string) property may be empty. An `FSModule` can receive an `FSFileName` that isn’t valid UTF-8 in two cases:
    ///
    /// 1. A program passes erroneous data to a system call. The `FSModule` treats this situation as an error.
    ///
    /// 2. An `FSModule` lacks the character encoding used for a file name. This situation occurs because some file system formats consider a filename to be an arbitrary “bag of bytes,” and leave character encoding up to the operating system. Without encoding information, the `FSModule` can only pass back the names it finds on disk. In this case, the behavior of upper layers such as [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager) is unspecified. However, the `FSModule` must support looking up such names and using them as the source name of rename operations. The `FSModule` must also be able to support filenames that are derivatives of filenames returned from directory enumeration. Derivative filenames include Apple Double filenames (`"._Name"`), and editor backup filenames.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    /// Don’t subclass this class.
    ///
    ///
    ///
    /// </div>
    ///
    /// The name of a file, expressed as a data buffer.
    ///
    /// `FSFileName` is the class that carries filenames from the kernel to `FSModule` instances, and carries names back to the kernel as part of directory enumeration.
    ///
    /// A filename is usually a valid UTF-8 sequence, but can be an arbitrary byte sequence that doesn't conform to that format.
    /// As a result, the ``data`` property always contains a value, but the ``string`` property may be empty.
    /// An `FSModule` can receive an `FSFileName` that isn't valid UTF-8 in two cases:
    /// 1. A program passes erroneous data to a system call. The `FSModule` treats this situation as an error.
    /// 2. An `FSModule` lacks the character encoding used for a file name.
    /// This situation occurs because some file system formats consider a filename to be an arbitrary "bag of bytes," and leave character encoding up to the operating system.
    /// Without encoding information, the `FSModule` can only pass back the names it finds on disk.
    /// In this case, the behavior of upper layers such as
    /// <doc
    /// ://com.apple.documentation/documentation/Foundation/NSFileManager> is unspecified.
    /// However, the `FSModule` must support looking up such names and using them as the source name of rename operations.
    /// The `FSModule` must also be able to support filenames that are derivatives of filenames returned from directory enumeration.
    /// Derivative filenames include Apple Double filenames (`"._Name"`), and editor backup filenames.
    ///
    /// > Important: Don't subclass this class.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSFileName;
);

extern_conformance!(
    unsafe impl NSCoding for FSFileName {}
);

extern_conformance!(
    unsafe impl NSCopying for FSFileName {}
);

unsafe impl CopyingHelper for FSFileName {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for FSFileName {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for FSFileName {}
);

impl FSFileName {
    extern_methods!(
        /// The byte sequence of the filename, as a data object.
        ///
        /// This property always provides a value.
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Retained<NSData>;

        /// The filename, represented as a Unicode string.
        ///
        /// If the value of the filename's ``FSFileName/data`` is not a valid UTF-8 byte sequence, this property is empty.
        #[unsafe(method(string))]
        #[unsafe(method_family = none)]
        pub unsafe fn string(&self) -> Option<Retained<NSString>>;

        /// The filename, represented as a potentially lossy conversion to a string.
        ///
        /// The exact details of the string conversion may change in the future.
        #[unsafe(method(debugDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn debugDescription(&self) -> Retained<NSString>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Initializes a filename from a null-terminated character sequence.
        ///
        /// > Note: This initializer is unavailable in Swift. Use ``initWithData:`` or ``initWithString:`` instead.
        ///
        /// - Parameter name: A pointer to a C string.
        ///
        /// # Safety
        ///
        /// `name` must be a valid pointer.
        #[unsafe(method(initWithCString:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCString(
            this: Allocated<Self>,
            name: NonNull<c_char>,
        ) -> Retained<Self>;

        /// Initializes a file name by copying a character sequence from a byte array.
        ///
        /// > Note: This initializer is unavailable in Swift. Use ``initWithData:`` or ``initWithString:`` instead.
        ///
        /// - Parameters:
        /// - bytes: A pointer to the character data to copy, up to a maximum of `length`. The sequence terminates if a `NUL` character exists prior to `length`.
        /// - length: The size of the `bytes` array.
        ///
        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(initWithBytes:length:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithBytes_length(
            this: Allocated<Self>,
            bytes: NonNull<c_char>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// Creates a filename by copying a character sequence data object.
        ///
        /// This initializer copies up to `name.length` characters of the sequence pointed to by `bytes`.
        ///
        /// - Parameter name: The data object containing the character sequence to use for the filename. The sequence terminates if a `NUL` character exists prior to `name.length`.
        #[unsafe(method(initWithData:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData(this: Allocated<Self>, name: &NSData) -> Retained<Self>;

        /// Creates a filename by copying a character sequence from a string instance.
        ///
        /// This initializer copies the UTF-8 representation of the characters in `string`.
        /// If `string` contains a `NUL` character, the sequence terminates.
        ///
        /// - Parameter name: The string containing the character sequence to use for the filename.
        #[unsafe(method(initWithString:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithString(this: Allocated<Self>, name: &NSString) -> Retained<Self>;

        /// Creates a filename from a null-terminated character sequence.
        ///
        /// - Parameter name: A pointer to a C string.
        ///
        /// # Safety
        ///
        /// `name` must be a valid pointer.
        #[unsafe(method(nameWithCString:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nameWithCString(name: NonNull<c_char>) -> Retained<Self>;

        /// Creates a filename by copying a character sequence from a byte array.
        ///
        /// - Parameters:
        /// - bytes: A pointer to the character data to copy, up to a maximum of `length`. The sequence terminates if a `NUL` character exists prior to `length`.
        /// - length: The size of the `bytes` array.
        ///
        /// # Safety
        ///
        /// `bytes` must be a valid pointer.
        #[unsafe(method(nameWithBytes:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nameWithBytes_length(
            bytes: NonNull<c_char>,
            length: NSUInteger,
        ) -> Retained<Self>;

        /// Creates a filename by copying a character sequence data object.
        ///
        /// This initializer copies up to `name.length` characters of the sequence pointed to by `bytes`.
        ///
        /// - Parameter name: The data object containing the character sequence to use for the filename. The sequence terminates if a `NUL` character exists prior to `name.length`.
        #[unsafe(method(nameWithData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nameWithData(name: &NSData) -> Retained<Self>;

        /// Creates a filename by copying a character sequence from a string instance.
        ///
        /// This initializer copies the UTF-8 representation of the characters in `string`.
        /// If `string` contains a `NUL` character, the sequence terminates.
        ///
        /// - Parameter name: The string containing the character sequence to use for the filename.
        #[unsafe(method(nameWithString:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nameWithString(name: &NSString) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSFileName {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
