//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An abstract base class for implementing a minimal file system.
    ///
    /// `FSUnaryFileSystem` is a simplified file system, which works with one ``FSResource`` and presents it as one ``FSVolume``.
    ///
    /// The one volume and its container have a shared state and lifetime, a more constrained life cycle than the ``FSFileSystem`` design flow.
    ///
    /// Implement your app extension by providing a subclass of `FSUnaryFileSystem` as a delegate object.
    /// Your delegate also needs to implement the ``FSUnaryFileSystemOperations`` protocol so that it can load resources.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsunaryfilesystem?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSUnaryFileSystem;
);

#[cfg(feature = "FSFileSystemBase")]
extern_conformance!(
    unsafe impl FSFileSystemBase for FSUnaryFileSystem {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSUnaryFileSystem {}
);

impl FSUnaryFileSystem {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl FSUnaryFileSystem {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Operations performed by a unary file system.
    ///
    /// Make sure your subclass of ``FSUnaryFileSystem`` conforms to this protocol.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsunaryfilesystemoperations?language=objc)
    pub unsafe trait FSUnaryFileSystemOperations: NSObjectProtocol {
        #[cfg(all(feature = "FSResource", feature = "block2"))]
        /// Requests that the file system probe the specified resource.
        ///
        /// Implement this method to indicate whether the resource is recognizable and usable.
        /// - Parameters:
        /// - resource: The ``FSResource`` to probe.
        /// - reply: A block or closure that your implementation invokes when it finishes the probe or encounters an error. Pass an instance of ``FSProbeResult`` with probe results as the first parameter if your probe operation succeeds. If probing fails, pass an error as the second parameter.
        #[unsafe(method(probeResource:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn probeResource_replyHandler(
            &self,
            resource: &FSResource,
            reply: &block2::DynBlock<dyn Fn(*mut FSProbeResult, *mut NSError)>,
        );

        #[cfg(all(
            feature = "FSResource",
            feature = "FSTaskOptions",
            feature = "FSVolume",
            feature = "block2"
        ))]
        /// Requests that the file system load a resource and present it as a volume.
        ///
        /// Implement this method by inspecting the provided resource and verifying it uses a supported format.
        /// If the resource does use a supported format, create a subclass of `FSVolume`, clear the container error state, and invoke the `reply` callback, passing your volume as a parameter.
        /// If loading can't proceed, invoke `reply` and send an appropriate error as the second parameter.
        ///
        /// - Parameters:
        /// - resource: An ``FSResource`` to load.
        /// - options: An ``FSTaskOptions`` object specifying options to apply when loading the resource. An ``FSUnaryFileSystem`` supports two options: `-f` for "force" and `--rdonly` for read-only. The file system must remember if the read-only option is present.
        /// - reply: A block or closure that your implementation invokes when it finishes setting up or encounters an error. Pass a subclass of `FSVolume` as the first parameter if loading succeeds. If loading fails, pass an error as the second parameter.
        #[unsafe(method(loadResource:options:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadResource_options_replyHandler(
            &self,
            resource: &FSResource,
            options: &FSTaskOptions,
            reply: &block2::DynBlock<dyn Fn(*mut FSVolume, *mut NSError)>,
        );

        #[cfg(all(feature = "FSResource", feature = "FSTaskOptions", feature = "block2"))]
        /// Requests that the file system unload the specified resource.
        ///
        /// - Parameters:
        /// - resource: An ``FSResource`` to unload.
        /// - options: An ``FSTaskOptions`` object specifying options to apply when unloading the resource.
        /// - reply: A block or closure that your implementation invokes when it finishes unloading or encounters an error. If unloading fails, pass an error as the parameter to describe the problem. Otherwise, pass `nil`.
        #[unsafe(method(unloadResource:options:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn unloadResource_options_replyHandler(
            &self,
            resource: &FSResource,
            options: &FSTaskOptions,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        /// Notifies you that the system finished loading your file system extension.
        ///
        /// The system performs this callback after the main run loop starts and before receiving the first message from the FSKit daemon.
        ///
        /// Implement this method if you want to perform any setup prior to receiving FSKit callbacks.
        #[optional]
        #[unsafe(method(didFinishLoading))]
        #[unsafe(method_family = none)]
        unsafe fn didFinishLoading(&self);
    }
);
