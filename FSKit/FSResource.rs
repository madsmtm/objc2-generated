//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// A type that represents the recognition and usability of a probed resource.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsmatchresult?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSMatchResult(pub NSInteger);
impl FSMatchResult {
    /// The probe doesn't recognize the resource.
    ///
    /// This match result is appropriate when the file system module determines that the resource uses a completely different format.
    #[doc(alias = "FSMatchResultNotRecognized")]
    pub const NotRecognized: Self = Self(0);
    /// The probe recognizes the resource but can't use it.
    ///
    /// This match result is appropriate when the file system module identifies the resource's format but can't use it. For example, if the resource uses a newer version than the module supports, the module can name the resource but can't safely do anything with it.
    #[doc(alias = "FSMatchResultRecognized")]
    pub const Recognized: Self = Self(1);
    /// The probe recognizes the resource and is ready to use it, but only in a limited capacity.
    ///
    /// This match result is appropriate when the file system module identifies the resource's format but also identifies incompatibilities. For example, if the module determines the resource uses new features that the module doesn't support, the module may only offer read-only access.
    #[doc(alias = "FSMatchResultUsableButLimited")]
    pub const UsableButLimited: Self = Self(2);
    /// The probe recognizes the resource and is ready to use it.
    #[doc(alias = "FSMatchResultUsable")]
    pub const Usable: Self = Self(3);
}

unsafe impl Encode for FSMatchResult {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for FSMatchResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An abstract resource a file system uses to provide data for a volume.
    ///
    /// `FSResource` is a base class to represent the various possible sources of data for a file system.
    /// These range from dedicated storage devices like hard drives and flash storage to network connections, and beyond.
    /// Subclasses define behavior specific to a given kind of resource, such as ``FSBlockDeviceResource-c.class`` for disk partition (IOMedia) file systems.
    /// These file systems are typical disk file systems such as HFS, APFS, ExFAT, ext2fs, or NTFS.
    ///
    /// A resource's type also determines its life cycle.
    /// Resources based on block storage devices come into being when the system probes the media underlying the volumes and container.
    /// Other kinds of resources, like those based on URLs, might have different life cycles.
    /// For example, a resource based on a `file://` URL might iniitalize when a person uses the "Connect to server" command in the macOS Finder.
    ///
    /// ### Proxying resources
    ///
    /// Some resources, like ``FSBlockDeviceResource``, come in proxy and non-proxy variants.
    /// This addresses the issue that opening an external device like `/dev/disk2s1` requires an entitlement.
    /// Proxy resources allow unentitled clients of FSKit to describe which disk an ``FSBlockDeviceResource`` should represent.
    /// This allows, for example, the `mount(8)` tool to mount FSKit file systems on block devices when run as root.
    /// The tool uses a proxy when executing a command like `mount -t ffs /dev/disk2s1 /some/path`, which prevents leaking privileged resource access.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsresource?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSResource;
);

extern_conformance!(
    unsafe impl NSCoding for FSResource {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSResource {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for FSResource {}
);

impl FSResource {
    extern_methods!(
        /// A Boolean value that indicates whether the resource is revoked.
        ///
        /// If this is a proxy resource, the value of this property is always `true` (Swift) or `YES` (Objective-C).
        #[unsafe(method(isRevoked))]
        #[unsafe(method_family = none)]
        pub unsafe fn isRevoked(&self) -> bool;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates a proxy object of this resource.
        ///
        /// If you create a proxy from a proxy resource, this method returns a copy of the proxy.
        #[unsafe(method(makeProxy))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeProxy(&self) -> Retained<Self>;

        /// Revokes the resource.
        ///
        /// This method works by stripping away any underlying privileges associated with the resource.
        /// This effectively disconnects this object from its underlying resource.
        #[unsafe(method(revoke))]
        #[unsafe(method_family = none)]
        pub unsafe fn revoke(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl FSResource {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A range that describes contiguous metadata segments on disk.
    ///
    /// This type represents a range that begins at `startOffset` and ends at `startOffset + segmentLength * segmentCount`.
    /// Each segment in the range represents a single block in the resource's buffer cache.
    ///
    /// For example, given an `FSMetadataRange` with the following properties:
    ///
    /// * `startOffset = 0`
    /// * `segmentLength = 512`
    /// * `segmentCount = 8`
    ///
    /// The range represents eight segments: from 0 to 511, then from 512 to 1023, and so on until a final segment of 3584 to 4095.
    ///
    /// Ensure that each metadata segment represents a range that's already present in the resource's buffer cache.
    /// Similarly, ensure that each segment's offset and length matches the offset and length of the corresponding block in the buffer cache.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsmetadatarange?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSMetadataRange;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSMetadataRange {}
);

impl FSMetadataRange {
    extern_methods!(
        #[cfg(feature = "libc")]
        /// The start offset of the range in bytes.
        ///
        /// Ensure this value is a multiple of the corresponding resource's ``FSBlockDeviceResource-c.class/blockSize``.
        #[unsafe(method(startOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn startOffset(&self) -> libc::off_t;

        /// The segment length in bytes.
        ///
        /// Ensure this value is a multiple of the corresponding resource's ``FSBlockDeviceResource-c.class/blockSize``.
        #[unsafe(method(segmentLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn segmentLength(&self) -> u64;

        /// The number of segments in the range.
        #[unsafe(method(segmentCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn segmentCount(&self) -> u64;

        #[cfg(feature = "libc")]
        /// Initializes a metadata range with the given properties.
        ///
        /// - Parameters:
        /// - startOffset: The start offset of the range in bytes. Ensure this value is a multiple of the corresponding resource's ``FSBlockDeviceResource-c.class/blockSize``.
        /// - segmentLength: The segment length in bytes. Ensure this value is a multiple of the corresponding resource's ``FSBlockDeviceResource-c.class/blockSize``.
        /// - segmentCount: The number of segments in the range.
        #[unsafe(method(initWithOffset:segmentLength:segmentCount:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithOffset_segmentLength_segmentCount(
            this: Allocated<Self>,
            start_offset: libc::off_t,
            segment_length: u64,
            segment_count: u64,
        ) -> Retained<Self>;

        #[cfg(feature = "libc")]
        /// Creates a metadata range with the given properties.
        /// - Parameters:
        /// - startOffset: The start offset of the range in bytes. Ensure this value is a multiple of the corresponding resource's ``FSBlockDeviceResource-c.class/blockSize``.
        /// - segmentLength: The segment length in bytes. Ensure this value is a multiple of the corresponding resource's ``FSBlockDeviceResource-c.class/blockSize``.
        /// - segmentCount: The number of segments in the range.
        #[unsafe(method(rangeWithOffset:segmentLength:segmentCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rangeWithOffset_segmentLength_segmentCount(
            start_offset: libc::off_t,
            segment_length: u64,
            segment_count: u64,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSMetadataRange {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A resource that represents a block storage disk partition.
    ///
    /// A `FSBlockDeviceResource` can exist in either a proxied or nonproxied version.
    /// Only the `fskitd` daemon creates "real" (nonproxied) instances of this class.
    /// Client applications and daemons create proxy objects for requests, and `fskitd` opens the underlying device during the processing of the request.
    ///
    /// This class wraps a file descriptor for a disk device or partition.
    /// Its fundamental identifier is the BSD disk name (``bsdName``) for the underlying IOMedia object.
    /// However, ``FSBlockDeviceResource-c.class`` doesn't expose the underlying file descriptor.
    /// Instead, it provides accessor methods that can read from and write to the partition, either directly or using the kernel buffer cache.
    ///
    /// When you use a `FSBlockDeviceResource`, your file system implementation also conforms to a maintenance operation protocol.
    /// These protocols add support for checking, repairing, and optionally formatting file systems.
    /// The system doesn't mount block device file systems until they pass a file system check.
    /// For an ``FSUnaryFileSystem`` that uses `FSBlockDeviceResource`, conform to `FSManageableResourceMaintenanceOperations`.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsblockdeviceresource?language=objc)
    #[unsafe(super(FSResource, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSBlockDeviceResource;
);

extern_conformance!(
    unsafe impl NSCoding for FSBlockDeviceResource {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSBlockDeviceResource {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for FSBlockDeviceResource {}
);

impl FSBlockDeviceResource {
    extern_methods!(
        /// The device name of the resource.
        #[unsafe(method(BSDName))]
        #[unsafe(method_family = none)]
        pub unsafe fn BSDName(&self) -> Retained<NSString>;

        /// A Boolean property that indicates whether the resource can write data to the device.
        #[unsafe(method(isWritable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isWritable(&self) -> bool;

        /// The logical block size, the size of data blocks used by the file system.
        ///
        /// This is equivalent to the `DKIOCGETBLOCKSIZE` device parameter.
        #[unsafe(method(blockSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn blockSize(&self) -> u64;

        /// The block count on this resource.
        #[unsafe(method(blockCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn blockCount(&self) -> u64;

        /// The sector size of the device.
        ///
        /// This is equivalent to the `DKIOCGETPHYSICALBLOCKSIZE` device parameter.
        #[unsafe(method(physicalBlockSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn physicalBlockSize(&self) -> u64;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "block2", feature = "libc"))]
        /// Reads data from the resource into a buffer and executes a block afterwards.
        ///
        /// For the read to succeed, requests must conform to any transfer requirements of the underlying resource.
        /// Disk drives typically require sector (`physicalBlockSize`) addressed operations of one or more sector-aligned offsets.
        ///
        /// - Parameters:
        /// - buffer: A buffer to receive the data.
        /// - offset: The offset into the resource from which to start reading.
        /// - length: A maximum number of bytes to read. The completion handler receives a parameter with the actual number of bytes read.
        /// - completionHandler: A block that executes after the read operation completes. If successful, the first parameter contains the number of bytes actually read. In the case of an error, the second parameter contains a non-`nil` error. This value is `EFAULT` if `buffer` is `NULL`, or `errno` if reading from the resource failed.
        #[unsafe(method(readInto:startingAt:length:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readInto_startingAt_length_completionHandler(
            &self,
            buffer: NonNull<c_void>,
            offset: libc::off_t,
            length: usize,
            completion_handler: &block2::DynBlock<dyn Fn(usize, *mut NSError)>,
        );

        #[cfg(all(feature = "block2", feature = "libc"))]
        /// Writes data from from a buffer to the resource and executes a block afterwards.
        ///
        /// For the write to succeed, requests must conform to any transfer requirements of the underlying resource.
        /// Disk drives typically require sector (`physicalBlockSize`) addressed operations of one or more sector-aligned offsets.
        ///
        /// - Parameters:
        /// - buffer: A buffer to provide the data.
        /// - offset: The offset into the resource from which to start writing.
        /// - length: A maximum number of bytes to write. The completion handler receives a parameter with the actual number of bytes write.
        /// - completionHandler: A block that executes after the write operation completes. If successful, the first parameter contains the number of bytes actually written. In the case of an error, the second parameter contains a non-`nil` error. This value is `EFAULT` if `buffer` is `NULL`, or `errno` if writing to the resource failed.
        #[unsafe(method(writeFrom:startingAt:length:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeFrom_startingAt_length_completionHandler(
            &self,
            buffer: NonNull<c_void>,
            offset: libc::off_t,
            length: usize,
            completion_handler: &block2::DynBlock<dyn Fn(usize, *mut NSError)>,
        );

        #[cfg(feature = "libc")]
        /// Synchronously reads file system metadata from the resource into a buffer.
        ///
        /// This method provides access to the Kernel Buffer Cache, which is the primary system cache for file system metadata.
        /// Unlike equivalent kernel APIs, this method doesn't hold any kernel-level claim to the underlying buffers.
        ///
        /// For the read to succeed, requests must conform to any transfer requirements of the underlying resource.
        /// Disk drives typically require sector (`physicalBlockSize`) addressed operations of one or more sector-aligned offsets.
        ///
        /// This method doesn't support partial reading of metadata.
        ///
        /// - Parameters:
        /// - buffer: A buffer to receive the data.
        /// - offset: The offset into the resource from which to start reading.
        /// - length: The number of bytes to read.
        /// - error: On return, any error encountered while reading data, or `nil` if no error occurred.
        ///
        /// - Returns: A Boolean value indicating whether the metadata read succeeded.
        #[unsafe(method(metadataReadInto:startingAt:length:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataReadInto_startingAt_length_error(
            &self,
            buffer: NonNull<c_void>,
            offset: libc::off_t,
            length: usize,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "libc")]
        /// Synchronously writes file system metadata from a buffer to the resource.
        ///
        /// This method provides access to the Kernel Buffer Cache, which is the primary system cache for file system metadata.
        /// Unlike equivalent kernel APIs, this method doesn't hold any kernel-level claim to the underlying buffers.
        ///
        /// For the write to succeed, requests must conform to any transfer requirements of the underlying resource.
        /// Disk drives typically require sector (`physicalBlockSize`) addressed operations of one or more sector-aligned offsets.
        ///
        /// This method doesn't support partial writing of metadata.
        ///
        /// - Parameters:
        /// - buffer: A buffer to provide the data.
        /// - offset: The offset into the resource from which to start writing.
        /// - length: The number of bytes to writing.
        /// - error: On return, any error encountered while writing data, or `nil` if no error occurred.
        ///
        /// - Returns: A Boolean value indicating whether the metadata write succeeded.
        #[unsafe(method(metadataWriteFrom:startingAt:length:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataWriteFrom_startingAt_length_error(
            &self,
            buffer: NonNull<c_void>,
            offset: libc::off_t,
            length: usize,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "libc")]
        /// Writes file system metadata from a buffer to a cache, prior to flushing it to the resource.
        ///
        /// This method provides access to the Kernel Buffer Cache, which is the primary system cache for file system metadata.
        /// Unlike equivalent kernel APIs, this method doesn't hold any kernel-level claim to the underlying buffers.
        ///
        /// This method is equivalent to ``metadataWriteFrom:startingAt:length:error:``, except that it writes data to the resource's buffer cache instead of writing to disk immediately.
        /// To ensure writing data to disk, the client must flush the metadata by calling ``metadataFlushWithError:`` or ``asynchronousMetadataFlushWithError:``.
        ///
        /// Delayed writes offer two significant advantages:
        /// - Delayed writes are more performant, since the file system can avoid waiting for the actual write, reducing I/O latency.
        /// - When writing to a specific range repeatedly, delayed writes allow the file system to flush data to the disk only when necessary. This reduces disk usage by eliminating unnecessary writes.
        ///
        /// For the write to succeed, requests must conform to any transfer requirements of the underlying resource.
        /// Disk drives typically require sector (`physicalBlockSize`) addressed operations of one or more sector-aligned offsets.
        ///
        /// This method doesn't support partial writing of metadata.
        ///
        /// - Parameters:
        /// - buffer: A buffer to provide the data.
        /// - offset: The offset into the resource from which to start writing.
        /// - length: The number of bytes to writing.
        /// - error: On return, any error encountered while writing data, or `nil` if no error occurred.
        ///
        /// - Returns: A Boolean value indicating whether the metadata write succeeded.
        #[unsafe(method(delayedMetadataWriteFrom:startingAt:length:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn delayedMetadataWriteFrom_startingAt_length_error(
            &self,
            buffer: NonNull<c_void>,
            offset: libc::off_t,
            length: usize,
        ) -> Result<(), Retained<NSError>>;

        /// Synchronously flushes the resource's buffer cache.
        ///
        /// This method flushes data previously written with ``delayedMetadataWriteFrom:startingAt:length:error:`` to the resource.
        ///
        /// - Parameter error: On return, any error encountered while writing data, or `nil` if no error occurred.
        ///
        /// - Returns: A Boolean value indicating whether the metadata flush succeeded.
        #[unsafe(method(metadataFlushWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataFlushWithError(&self) -> Result<(), Retained<NSError>>;

        /// Asynchronously flushes the resource's buffer cache.
        ///
        /// This method schedules a flush of data previously written with ``delayedMetadataWriteFrom:startingAt:length:error:`` to the resource and returns immediately without blocking.
        /// This method doesn't wait to check the flush's status.
        /// If an error prevents the flush from being scheduled, the error is indicated by the in-out `error` parameter.
        ///
        /// - Parameter error: On return, any error encountered while writing data, or `nil` if no error occurred.
        ///
        /// - Returns: A Boolean value indicating whether scheduling the metadata flush succeeded.
        #[unsafe(method(asynchronousMetadataFlushWithError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn asynchronousMetadataFlushWithError(&self) -> Result<(), Retained<NSError>>;

        /// Clears the given ranges within the buffer cache.
        ///
        /// This method clears the specified ranges in the resourceâ€™s buffer cache by writing zeroes into them.
        ///
        /// - Parameters:
        /// - rangesToClear: The metadata ranges to clear.
        /// - withDelayedWrites: A Boolean value that determines whether to perform the clear operation with delayed writes. The delay works in the same manner as ``delayedMetadataWriteFrom:startingAt:length:error:``. When using delayed writes, the client can flush the metadata with ``metadataFlushWithError:`` or ``asynchronousMetadataFlushWithError:``. The system also flushes stale data in the buffer cache periodically.
        /// - error: On return, any error encountered while writing data, or `nil` if no error occurred. This value is `EINVAL` if `rangesToClear` is invalid.
        ///
        /// - Returns: A Boolean value indicating whether clearing the metadata succeeded.
        #[unsafe(method(metadataClear:withDelayedWrites:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataClear_withDelayedWrites_error(
            &self,
            ranges_to_clear: &NSArray<FSMetadataRange>,
            with_delayed_writes: bool,
        ) -> Result<(), Retained<NSError>>;

        /// Synchronously purges the given ranges from the buffer cache.
        ///
        /// This method removes the given ranges from the resource's buffer cache.
        /// This process drops any dirty data in the cache, preventing the data from reaching the device.
        ///
        /// - Parameters:
        /// - rangesToPurge: The metadata ranges to purge.
        /// - error: On return, any error encountered while writing data, or `nil` if no error occurred. This value is `EINVAL` if `rangesToPurge` is invalid.
        ///
        /// - Returns: A Boolean value indicating whether purging the metadata succeeded.
        #[unsafe(method(metadataPurge:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn metadataPurge_error(
            &self,
            ranges_to_purge: &NSArray<FSMetadataRange>,
        ) -> Result<(), Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSBlockDeviceResource {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A resource representing an abstract URL
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsgenericurlresource?language=objc)
    #[unsafe(super(FSResource, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSGenericURLResource;
);

extern_conformance!(
    unsafe impl NSCoding for FSGenericURLResource {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSGenericURLResource {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for FSGenericURLResource {}
);

impl FSGenericURLResource {
    extern_methods!(
        #[unsafe(method(url))]
        #[unsafe(method_family = none)]
        pub unsafe fn url(&self) -> Retained<NSURL>;

        #[unsafe(method(initWithURL:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL(this: Allocated<Self>, url: &NSURL) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSGenericURLResource {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A resource representing a path
    ///
    /// Represents a file path (possibly security scoped URL).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fspathurlresource?language=objc)
    #[unsafe(super(FSResource, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSPathURLResource;
);

extern_conformance!(
    unsafe impl NSCoding for FSPathURLResource {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSPathURLResource {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for FSPathURLResource {}
);

impl FSPathURLResource {
    extern_methods!(
        #[unsafe(method(url))]
        #[unsafe(method_family = none)]
        pub unsafe fn url(&self) -> Retained<NSURL>;

        #[unsafe(method(initWithURL:writable:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithURL_writable(
            this: Allocated<Self>,
            url: &NSURL,
            writable: bool,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(isWritable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isWritable(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSPathURLResource {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Maintenance operations for a file system's resources.
    ///
    /// This protocol includes operations to check and format a resource for an ``FSUnaryFileSystem``.
    /// Conform to this protocol if you implement a ``FSUnaryFileSystem`` that uses an ``FSBlockDeviceResource-c.class``.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsmanageableresourcemaintenanceoperations?language=objc)
    pub unsafe trait FSManageableResourceMaintenanceOperations: NSObjectProtocol {
        #[cfg(all(feature = "FSTask", feature = "FSTaskOptions"))]
        /// Starts checking the file system with the given options.
        ///
        /// - Parameters:
        /// - task: A task object you use to communicate back to the client.
        /// - options: Options for performing the check.
        /// - error: In Objective-C, a pointer to an
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSError>. Populate this with any error that occurs when starting the check. In Swift, throw an
        /// <doc
        /// ://com.apple.documentation/documentation/Swift/Error> instead.
        /// - Returns: An
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSProgress> object that you use to update progress as the check operation progresses. Return `nil` if starting the file system check encountered an error.
        #[unsafe(method(startCheckWithTask:options:error:_))]
        #[unsafe(method_family = none)]
        unsafe fn startCheckWithTask_options_error(
            &self,
            task: &FSTask,
            options: &FSTaskOptions,
        ) -> Result<Retained<NSProgress>, Retained<NSError>>;

        #[cfg(all(feature = "FSTask", feature = "FSTaskOptions"))]
        /// Starts formatting the file system with the given options.
        ///
        /// - Parameters:
        /// - task: A task object you use to communicate back to the client.
        /// - options: Options for performing the format.
        /// - error: In Objective-C, a pointer to an
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSError>. Populate this with any error that occurs when starting the format. In Swift, throw an
        /// <doc
        /// ://com.apple.documentation/documentation/Swift/Error> instead.
        /// - Returns: An
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSProgress> object that you use to update progress as the format operation progresses. Return `nil` if starting to format the file system encountered an error.
        #[unsafe(method(startFormatWithTask:options:error:_))]
        #[unsafe(method_family = none)]
        unsafe fn startFormatWithTask_options_error(
            &self,
            task: &FSTask,
            options: &FSTaskOptions,
        ) -> Result<Retained<NSProgress>, Retained<NSError>>;
    }
);

extern_class!(
    /// An object that represents the results of a specific probe.
    ///
    /// For any ``result`` value other than ``FSMatchResult/notRecognized``, ensure the ``name`` and ``containerID`` values are non-`nil`.
    /// When a container or volume format doesn't use a name, return an empty string.
    /// Also use an empty string in the case in which the format supports a name, but the value isn't set yet.
    ///
    /// Some container or volume formats may lack a durable UUID on which to base a container identifier.
    /// This situation is only valid for unary file systems.
    /// In such a case, return a random UUID.
    ///
    /// With a block device resource, a probe operation may successfully get a result but encounter an error reading the name or UUID.
    /// If this happens, use whatever information is available, and provide an empty string or random UUID for the name or container ID, respectively.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsproberesult?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSProbeResult;
);

extern_conformance!(
    unsafe impl NSCoding for FSProbeResult {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSProbeResult {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for FSProbeResult {}
);

impl FSProbeResult {
    extern_methods!(
        /// The match result, representing the recognition and usability of a probed resource.
        #[unsafe(method(result))]
        #[unsafe(method_family = none)]
        pub unsafe fn result(&self) -> FSMatchResult;

        /// The resource name, as found during the probe operation.
        ///
        /// This value is non-`nil` unless the ``FSProbeResult/result`` is ``FSMatchResult/notRecognized`.
        /// For formats that lack a name, this value may be an empty string.
        /// This value can also be an empty string if the format supports a name, but the value isn't set yet.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Option<Retained<NSString>>;

        #[cfg(all(feature = "FSContainer", feature = "FSEntityIdentifier"))]
        /// The container identifier, as found during the probe operation.
        ///
        /// This value is non-`nil` unless the ``FSProbeResult/result`` is ``FSMatchResult/notRecognized`.
        /// For formats that lack a durable UUID on which to base a container identifier --- which is only legal for a ``FSUnaryFileSystem`` --- this value may be a random UUID.
        #[unsafe(method(containerID))]
        #[unsafe(method_family = none)]
        pub unsafe fn containerID(&self) -> Option<Retained<FSContainerIdentifier>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// A probe result for an unrecognized file system.
        ///
        /// An unrecognized probe result contains `nil` for its ``FSProbeResult/name`` and ``FSProbeResult/containerID`` properties.
        #[unsafe(method(notRecognizedProbeResult))]
        #[unsafe(method_family = none)]
        pub unsafe fn notRecognizedProbeResult() -> Retained<FSProbeResult>;

        #[cfg(all(feature = "FSContainer", feature = "FSEntityIdentifier"))]
        /// Creates a probe result for a recognized file system.
        ///
        /// - Parameters:
        /// - name: The resource name, as found during the probe operation. If the file system doesn't support names, or is awaiting naming, use an empty string.
        /// - containerID: The container identifier, as found during the probe operation. If the file system doesn't support durable identifiers, use a random UUID.
        #[unsafe(method(recognizedProbeResultWithName:containerID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn recognizedProbeResultWithName_containerID(
            name: &NSString,
            container_id: &FSContainerIdentifier,
        ) -> Retained<Self>;

        /// A probe result for a recognized file system that is usable, but with limited capabilities.
        ///
        /// This kind of probe result lacks the ``FSProbeResult/name``, ``FSProbeResult/containerID``, or both.
        /// Don't return this result from probing a resource that isn't limited.
        #[unsafe(method(usableButLimitedProbeResult))]
        #[unsafe(method_family = none)]
        pub unsafe fn usableButLimitedProbeResult() -> Retained<FSProbeResult>;

        #[cfg(all(feature = "FSContainer", feature = "FSEntityIdentifier"))]
        /// Creates a probe result for a recognized file system that is usable, but with limited capabilities.
        ///
        /// - Parameters:
        /// - name: The resource name, as found during the probe operation. If the file system doesn't support names, or is awaiting naming, use an empty string.
        /// - containerID: The container identifier, as found during the probe operation. If the file system doesn't support durable identifiers, use a random UUID.
        #[unsafe(method(usableButLimitedProbeResultWithName:containerID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn usableButLimitedProbeResultWithName_containerID(
            name: &NSString,
            container_id: &FSContainerIdentifier,
        ) -> Retained<Self>;

        #[cfg(all(feature = "FSContainer", feature = "FSEntityIdentifier"))]
        /// Creates a probe result for a recognized and usable file system.
        ///
        /// - Parameters:
        /// - name: The resource name, as found during the probe operation. If the file system doesn't support names, or is awaiting naming, use an empty string.
        /// - containerID: The container identifier, as found during the probe operation. If the file system doesn't support durable identifiers, use a random UUID.
        #[unsafe(method(usableProbeResultWithName:containerID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn usableProbeResultWithName_containerID(
            name: &NSString,
            container_id: &FSContainerIdentifier,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSProbeResult {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
