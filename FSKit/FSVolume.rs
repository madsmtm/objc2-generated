//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// A value that indicates a location in a directory from which to enumerate.
///
/// Your implementation of ``FSVolume/Operations/enumerateDirectory(_:startingAt:verifier:attributes:packer:replyHandler:)`` defines the semantics of this value; it's opaque to FSKit.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsdirectorycookie?language=objc)
// NS_TYPED_EXTENSIBLE_ENUM
pub type FSDirectoryCookie = u64;

extern "C" {
    /// The constant initial value for the directory-enumeration cookie.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsdirectorycookieinitial?language=objc)
    pub static FSDirectoryCookieInitial: FSDirectoryCookie;
}

/// A tool to detect whether the directory contents changed since the last call to enumerate a directory.
///
/// Your implementation of ``FSVolume/Operations/enumerateDirectory(_:startingAt:verifier:attributes:packer:replyHandler:)`` defines the semantics of this value; it's opaque to FSKit.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsdirectoryverifier?language=objc)
// NS_TYPED_EXTENSIBLE_ENUM
pub type FSDirectoryVerifier = u64;

extern "C" {
    /// The constant initial value for the directory-enumeration verifier.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsdirectoryverifierinitial?language=objc)
    pub static FSDirectoryVerifierInitial: FSDirectoryVerifier;
}

/// Options that affect the behavior of deactivate methods.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsdeactivateoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSDeactivateOptions(pub NSInteger);
bitflags::bitflags! {
    impl FSDeactivateOptions: NSInteger {
/// An option to force deactivation.
        #[doc(alias = "FSDeactivateOptionsForce")]
        const Force = 1<<0;
    }
}

unsafe impl Encode for FSDeactivateOptions {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for FSDeactivateOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Behavior flags for use with synchronization calls.
///
/// These values are based on flags defined in `mount.h`. Since there are system-defined flags that are valid in the kernel but not in FSKit, this type defines its members as options rather than use an enumeration.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fssyncflags?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSSyncFlags(pub NSInteger);
impl FSSyncFlags {
    /// A flag for synchronized I/O with file-integrity completion.
    #[doc(alias = "FSSyncFlagsWait")]
    pub const Wait: Self = Self(1);
    /// A flag for synchronized I/O that starts I/O but doesn't wait for it.
    #[doc(alias = "FSSyncFlagsNoWait")]
    pub const NoWait: Self = Self(2);
    /// A flag for synchronized I/O with data-integrity completion.
    #[doc(alias = "FSSyncFlagsDWait")]
    pub const DWait: Self = Self(4);
}

unsafe impl Encode for FSSyncFlags {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for FSSyncFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A type that identifies a volume.
    ///
    /// For most volumes, the volume identifier is the UUID identifying the volume.
    ///
    /// Network file systems may access the same underlying volume using different authentication credentials.
    /// To handle this situation, add qualifying data to identify the specific container, as discussed in the superclass, ``FSEntityIdentifier``.
    ///
    /// > Important: Don't subclass this class.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumeidentifier?language=objc)
    #[unsafe(super(FSEntityIdentifier, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "FSEntityIdentifier")]
    pub struct FSVolumeIdentifier;
);

#[cfg(feature = "FSEntityIdentifier")]
extern_conformance!(
    unsafe impl NSCoding for FSVolumeIdentifier {}
);

#[cfg(feature = "FSEntityIdentifier")]
extern_conformance!(
    unsafe impl NSCopying for FSVolumeIdentifier {}
);

#[cfg(feature = "FSEntityIdentifier")]
unsafe impl CopyingHelper for FSVolumeIdentifier {
    type Result = Self;
}

#[cfg(feature = "FSEntityIdentifier")]
extern_conformance!(
    unsafe impl NSObjectProtocol for FSVolumeIdentifier {}
);

#[cfg(feature = "FSEntityIdentifier")]
extern_conformance!(
    unsafe impl NSSecureCoding for FSVolumeIdentifier {}
);

#[cfg(feature = "FSEntityIdentifier")]
impl FSVolumeIdentifier {
    extern_methods!();
}

/// Methods declared on superclass `FSEntityIdentifier`.
#[cfg(feature = "FSEntityIdentifier")]
impl FSVolumeIdentifier {
    extern_methods!(
        /// Creates an entity identifier with a random UUID.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Creates an entity identifier with the given UUID.
        ///
        /// - Parameter uuid: The UUID to use for this identifier.
        #[unsafe(method(initWithUUID:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUUID(this: Allocated<Self>, uuid: &NSUUID) -> Retained<Self>;

        /// Creates an entity identifier with the given UUID and qualifier data as a 64-bit unsigned integer.
        /// - Parameters:
        /// - uuid: The UUID to use for this identifier.
        /// - qualifier: The data to distinguish entities that otherwise share the same UUID.
        #[unsafe(method(initWithUUID:qualifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUUID_qualifier(
            this: Allocated<Self>,
            uuid: &NSUUID,
            qualifier: u64,
        ) -> Retained<Self>;

        /// Creates an entity identifier with the given UUID and qualifier data.
        ///
        /// - Parameters:
        /// - uuid: The UUID to use for this identifier.
        /// - qualifierData: The data to distinguish entities that otherwise share the same UUID.
        #[unsafe(method(initWithUUID:data:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUUID_data(
            this: Allocated<Self>,
            uuid: &NSUUID,
            qualifier_data: &NSData,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "FSEntityIdentifier")]
impl FSVolumeIdentifier {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object used to provide items during a directory enumeration.
    ///
    /// You use this type in your implementation of ``FSVolume/Operations/enumerateDirectory(_:startingAt:verifier:attributes:packer:replyHandler:)``.
    ///
    /// Packing allows your implementation to provide information FSKit needs, including each item's name, type, and identifier (such as an inode number).
    /// Some directory enumerations require other attributes, as indicated by the ``FSItemGetAttributesRequest`` sent to the enumerate method.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsdirectoryentrypacker?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSDirectoryEntryPacker;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSDirectoryEntryPacker {}
);

impl FSDirectoryEntryPacker {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "FSFileName", feature = "FSItem"))]
        /// Provides a directory entry during enumeration.
        ///
        /// You call this method in your implementation of ``FSVolume/Operations/enumerateDirectory(_:startingAt:verifier:attributes:packer:replyHandler:)``, for each directory entry you want to provide to the enumeration.
        ///
        /// - Parameters:
        /// - name: The item's name.
        /// - itemType: The type of the item.
        /// - itemID: The item's identifier.
        /// - nextCookie: A value to indicate the next entry in the directory to enumerate. FSKit passes this value as the `cookie` parameter on the next call to ``FSVolume/Operations/enumerateDirectory(_:startingAt:verifier:attributes:packer:replyHandler:)``. Use whatever value is appropriate for your implementation; the value is opaque to FSKit.
        /// - attributes: The item's attributes. Pass `nil` if the enumeration call didn't request attributes.
        /// - Returns: `true` (Swift) or `YES` (Objective-C) if packing was successful and enumeration can continue with the next directory entry. If the value is `false` (Swift) or `NO` (Objective-C), stop enumerating. This result can happen when the entry is too big for the remaining space in the buffer.
        #[unsafe(method(packEntryWithName:itemType:itemID:nextCookie:attributes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn packEntryWithName_itemType_itemID_nextCookie_attributes(
            &self,
            name: &FSFileName,
            item_type: FSItemType,
            item_id: FSItemID,
            next_cookie: FSDirectoryCookie,
            attributes: Option<&FSItemAttributes>,
        ) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSDirectoryEntryPacker {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// An enumeration of case-sensitivity support types.
///
/// A case-sensitive volume is a volume that treats upper and lower case characters in file and directory names as being distinct from each other. For example, `FILE.TXT` and `file.TXT` are different names in a case-sensitive volume, and the same name in a case-insensitive volume.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumecaseformat?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSVolumeCaseFormat(pub NSInteger);
impl FSVolumeCaseFormat {
    /// The volume is case sensitive.
    #[doc(alias = "FSVolumeCaseFormatSensitive")]
    pub const Sensitive: Self = Self(0);
    /// The volume isn't case sensitive.
    #[doc(alias = "FSVolumeCaseFormatInsensitive")]
    pub const Insensitive: Self = Self(1);
    /// The volume isn't case sensitive, but supports preserving the case of file and directory names.
    #[doc(alias = "FSVolumeCaseFormatInsensitiveCasePreserving")]
    pub const InsensitiveCasePreserving: Self = Self(2);
}

unsafe impl Encode for FSVolumeCaseFormat {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for FSVolumeCaseFormat {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A type that represents capabillities supported by a volume, such as hard and symbolic links, journaling, and large file sizes.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumesupportedcapabilities?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSVolumeSupportedCapabilities;
);

extern_conformance!(
    unsafe impl NSCoding for FSVolumeSupportedCapabilities {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSVolumeSupportedCapabilities {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for FSVolumeSupportedCapabilities {}
);

impl FSVolumeSupportedCapabilities {
    extern_methods!(
        /// A Boolean property that indicates whether the volume supports persistent object identifiers and can look up file system objects by their IDs.
        #[unsafe(method(supportsPersistentObjectIDs))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsPersistentObjectIDs(&self) -> bool;

        /// Setter for [`supportsPersistentObjectIDs`][Self::supportsPersistentObjectIDs].
        #[unsafe(method(setSupportsPersistentObjectIDs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsPersistentObjectIDs(&self, supports_persistent_object_i_ds: bool);

        /// A Boolean property that indicates whether the volume supports symbolic links.
        #[unsafe(method(supportsSymbolicLinks))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsSymbolicLinks(&self) -> bool;

        /// Setter for [`supportsSymbolicLinks`][Self::supportsSymbolicLinks].
        #[unsafe(method(setSupportsSymbolicLinks:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsSymbolicLinks(&self, supports_symbolic_links: bool);

        /// A Boolean property that indicates whether the volume supports hard links.
        #[unsafe(method(supportsHardLinks))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsHardLinks(&self) -> bool;

        /// Setter for [`supportsHardLinks`][Self::supportsHardLinks].
        #[unsafe(method(setSupportsHardLinks:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsHardLinks(&self, supports_hard_links: bool);

        /// A Boolean property that indicates whether the volume supports a journal used to speed recovery in case of unplanned restart, such as a power outage or crash.
        ///
        /// This property doesn't necessarily mean the volume is actively using a journal.
        #[unsafe(method(supportsJournal))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsJournal(&self) -> bool;

        /// Setter for [`supportsJournal`][Self::supportsJournal].
        #[unsafe(method(setSupportsJournal:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsJournal(&self, supports_journal: bool);

        /// A Boolean property that indicates whether the volume currently uses a journal for speeding recovery after an unplanned shutdown.
        #[unsafe(method(supportsActiveJournal))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsActiveJournal(&self) -> bool;

        /// Setter for [`supportsActiveJournal`][Self::supportsActiveJournal].
        #[unsafe(method(setSupportsActiveJournal:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsActiveJournal(&self, supports_active_journal: bool);

        /// A Boolan property that indicates the volume doesn't store reliable times for the root directory.
        ///
        /// If this value is `true` (Swift) or `YES` (Objective-C), the volume doesn't store reliable times for the root directory.
        #[unsafe(method(doesNotSupportRootTimes))]
        #[unsafe(method_family = none)]
        pub unsafe fn doesNotSupportRootTimes(&self) -> bool;

        /// Setter for [`doesNotSupportRootTimes`][Self::doesNotSupportRootTimes].
        #[unsafe(method(setDoesNotSupportRootTimes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDoesNotSupportRootTimes(&self, does_not_support_root_times: bool);

        /// A Boolean property that indicates whether the volume supports sparse files.
        ///
        /// A sparse file is a file that can have "holes" that the file system has never written to, and as a result don't consume space on disk.
        #[unsafe(method(supportsSparseFiles))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsSparseFiles(&self) -> bool;

        /// Setter for [`supportsSparseFiles`][Self::supportsSparseFiles].
        #[unsafe(method(setSupportsSparseFiles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsSparseFiles(&self, supports_sparse_files: bool);

        /// A Boolean property that indicates whether the volume supports zero runs
        ///
        /// If this value is true, the volume keeps track of allocated but unwritten runs of a file so that it can substitute zeroes without actually writing zeroes to the media.
        #[unsafe(method(supportsZeroRuns))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsZeroRuns(&self) -> bool;

        /// Setter for [`supportsZeroRuns`][Self::supportsZeroRuns].
        #[unsafe(method(setSupportsZeroRuns:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsZeroRuns(&self, supports_zero_runs: bool);

        /// A Boolean property that indicates whether the volume supports fast results when fetching file system statistics.
        ///
        /// A true value means this volume hints to upper layers to indicate that `statfs(2)` is fast enough that its results need not be cached by the caller.
        #[unsafe(method(supportsFastStatFS))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsFastStatFS(&self) -> bool;

        /// Setter for [`supportsFastStatFS`][Self::supportsFastStatFS].
        #[unsafe(method(setSupportsFastStatFS:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsFastStatFS(&self, supports_fast_stat_fs: bool);

        /// A Boolean property that indicates whether the volume supports file sizes larger than 4GB, and potentially up to 2TB.
        #[unsafe(method(supports2TBFiles))]
        #[unsafe(method_family = none)]
        pub unsafe fn supports2TBFiles(&self) -> bool;

        /// Setter for [`supports2TBFiles`][Self::supports2TBFiles].
        #[unsafe(method(setSupports2TBFiles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupports2TBFiles(&self, supports2_tb_files: bool);

        /// A Boolean property that indicates whether the volume supports open deny modes.
        ///
        /// These are modes such as "open for read write, deny write".
        #[unsafe(method(supportsOpenDenyModes))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsOpenDenyModes(&self) -> bool;

        /// Setter for [`supportsOpenDenyModes`][Self::supportsOpenDenyModes].
        #[unsafe(method(setSupportsOpenDenyModes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsOpenDenyModes(&self, supports_open_deny_modes: bool);

        /// A Boolean property that indicates whether the volume supports hidden files.
        ///
        /// A `true` value means the volume supports the `UF_HIDDEN` file flag.
        #[unsafe(method(supportsHiddenFiles))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsHiddenFiles(&self) -> bool;

        /// Setter for [`supportsHiddenFiles`][Self::supportsHiddenFiles].
        #[unsafe(method(setSupportsHiddenFiles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsHiddenFiles(&self, supports_hidden_files: bool);

        /// A Boolean property that indicates the volume doesn't support certain volume size reports.
        ///
        /// A true value means the volume doesn't support determining values for total data blocks, available blocks, or free blocks, as in `f_blocks`, `f_bavail`, and `f_bfree` in the struct `statFS` returned by `statfs(2)`.
        #[unsafe(method(doesNotSupportVolumeSizes))]
        #[unsafe(method_family = none)]
        pub unsafe fn doesNotSupportVolumeSizes(&self) -> bool;

        /// Setter for [`doesNotSupportVolumeSizes`][Self::doesNotSupportVolumeSizes].
        #[unsafe(method(setDoesNotSupportVolumeSizes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDoesNotSupportVolumeSizes(&self, does_not_support_volume_sizes: bool);

        /// A Boolean property that indicates whether the volume supports 64-bit object IDs.
        #[unsafe(method(supports64BitObjectIDs))]
        #[unsafe(method_family = none)]
        pub unsafe fn supports64BitObjectIDs(&self) -> bool;

        /// Setter for [`supports64BitObjectIDs`][Self::supports64BitObjectIDs].
        #[unsafe(method(setSupports64BitObjectIDs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupports64BitObjectIDs(&self, supports64_bit_object_i_ds: bool);

        /// A Boolean property that indicates whether the volume supports document IDs for document revisions.
        ///
        /// A document ID is an identifier that persists across object ID changes.
        #[unsafe(method(supportsDocumentID))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsDocumentID(&self) -> bool;

        /// Setter for [`supportsDocumentID`][Self::supportsDocumentID].
        #[unsafe(method(setSupportsDocumentID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsDocumentID(&self, supports_document_id: bool);

        /// A Boolean property that indicates the volume doesn't support immutable files.
        ///
        /// A `true` value means this volume doesn't support setting the `UF_IMMUTABLE` flag.
        #[unsafe(method(doesNotSupportImmutableFiles))]
        #[unsafe(method_family = none)]
        pub unsafe fn doesNotSupportImmutableFiles(&self) -> bool;

        /// Setter for [`doesNotSupportImmutableFiles`][Self::doesNotSupportImmutableFiles].
        #[unsafe(method(setDoesNotSupportImmutableFiles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDoesNotSupportImmutableFiles(
            &self,
            does_not_support_immutable_files: bool,
        );

        /// A Boolean property that indicates the volume doesn't set file permissions.
        ///
        /// If this value is `true` (Swift) or `YES` (Objective-C), the volume doesn't support setting file permissions.
        #[unsafe(method(doesNotSupportSettingFilePermissions))]
        #[unsafe(method_family = none)]
        pub unsafe fn doesNotSupportSettingFilePermissions(&self) -> bool;

        /// Setter for [`doesNotSupportSettingFilePermissions`][Self::doesNotSupportSettingFilePermissions].
        #[unsafe(method(setDoesNotSupportSettingFilePermissions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDoesNotSupportSettingFilePermissions(
            &self,
            does_not_support_setting_file_permissions: bool,
        );

        /// A Boolean property that indicates whether the volume supports multiple logical file systems that share space in a single "partition."
        #[unsafe(method(supportsSharedSpace))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsSharedSpace(&self) -> bool;

        /// Setter for [`supportsSharedSpace`][Self::supportsSharedSpace].
        #[unsafe(method(setSupportsSharedSpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsSharedSpace(&self, supports_shared_space: bool);

        /// A Boolean property that indicates whether the volume supports volume groups.
        ///
        /// Volume groups involve multiple logical file systems that the system can mount and unmount together, and for which the system can present common file system identifier information.
        #[unsafe(method(supportsVolumeGroups))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsVolumeGroups(&self) -> bool;

        /// Setter for [`supportsVolumeGroups`][Self::supportsVolumeGroups].
        #[unsafe(method(setSupportsVolumeGroups:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsVolumeGroups(&self, supports_volume_groups: bool);

        /// A value that indicates the volume's support for case sensitivity.
        #[unsafe(method(caseFormat))]
        #[unsafe(method_family = none)]
        pub unsafe fn caseFormat(&self) -> FSVolumeCaseFormat;

        /// Setter for [`caseFormat`][Self::caseFormat].
        #[unsafe(method(setCaseFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCaseFormat(&self, case_format: FSVolumeCaseFormat);
    );
}

/// Methods declared on superclass `NSObject`.
impl FSVolumeSupportedCapabilities {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A directory structure for files and folders.
    ///
    /// A file system, depending on its type, provides one or more volumes to clients.
    /// The ``FSUnaryFileSystem`` by definition provides only one volume, while an ``FSFileSystem`` supports multiple volumes.
    ///
    /// You implement a volume for your file system type by subclassing this class, and also conforming to the ``FSVolume/Operations`` and ``FSVolume/PathConfOperations`` protocols.
    /// This protocol defines the minimum set of operations supported by a volume, such as mounting, activating, creating and removing items, and more.
    ///
    /// Your volume can provide additional functionality by conforming to other volume operations protocols.
    /// These protocols add support for operations like open and close, read and write, extended attribute (Xattr) manipulation, and more.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolume?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSVolume;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSVolume {}
);

impl FSVolume {
    extern_methods!(
        #[cfg(feature = "FSEntityIdentifier")]
        /// An identifier that uniquely identifies the volume.
        #[unsafe(method(volumeID))]
        #[unsafe(method_family = none)]
        pub unsafe fn volumeID(&self) -> Retained<FSVolumeIdentifier>;

        #[cfg(feature = "FSFileName")]
        /// The name of the volume.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Retained<FSFileName>;

        #[cfg(feature = "FSFileName")]
        /// Setter for [`name`][Self::name].
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setName(&self, name: &FSFileName);

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "FSEntityIdentifier", feature = "FSFileName"))]
        /// Creates a volume with the given identifier and name.
        /// - Parameters:
        /// - volumeID: An ``FSVolumeIdentifier`` to uniquely identify the volume. For a network file system that supports multiple authenticated users, disambiguate the users by using qualifying data in the identifier.
        /// - volumeName: A name for the volume.
        #[unsafe(method(initWithVolumeID:volumeName:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithVolumeID_volumeName(
            this: Allocated<Self>,
            volume_id: &FSVolumeIdentifier,
            volume_name: &FSFileName,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSVolume {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Properties implemented by volumes that support providing the values of system limits or options.
    ///
    /// This protocol gathers properties related to the `pathconf` and `fpathconf` system calls.
    ///
    /// For a file, the value of a property applies to just that file; for a directory, the value applies to all items in the directory.
    ///
    /// Properties that represent limits and have a numeric type use `-1` to represent no limit.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumepathconfoperations?language=objc)
    pub unsafe trait FSVolumePathConfOperations: NSObjectProtocol {
        /// A property that represents the maximum number of hard links to the object.
        #[unsafe(method(maximumLinkCount))]
        #[unsafe(method_family = none)]
        unsafe fn maximumLinkCount(&self) -> NSInteger;

        /// A property that represents the maximum length of a component of a filename.
        #[unsafe(method(maximumNameLength))]
        #[unsafe(method_family = none)]
        unsafe fn maximumNameLength(&self) -> NSInteger;

        /// A Boolean property that indicates whether the volume restricts ownership changes based on authorization.
        ///
        /// If this value is true, the volume rejects a `chown(2)` from anyone other than the superuser.
        #[unsafe(method(restrictsOwnershipChanges))]
        #[unsafe(method_family = none)]
        unsafe fn restrictsOwnershipChanges(&self) -> bool;

        /// A property that indicates whether the volume truncates files longer than its maximum supported length.
        ///
        /// If this value is `true`, the volume truncates the filename to ``maximumNameLength`` if the filename is longer than that.
        /// If this value is false, the file system responds with the error code `ENAMETOOLONG` if the filename is longer than ``maximumNameLength``.
        #[unsafe(method(truncatesLongNames))]
        #[unsafe(method_family = none)]
        unsafe fn truncatesLongNames(&self) -> bool;

        /// The maximum extended attribute size in bytes.
        ///
        /// Implement at least one of `maximumXattrSize` or ``maximumXattrSizeInBits``.
        /// FSKit automatically converts from one to another if needed.
        /// If you implement both, FSKit uses only the `maximumXattrSizeInBits` implementation.
        #[optional]
        #[unsafe(method(maximumXattrSize))]
        #[unsafe(method_family = none)]
        unsafe fn maximumXattrSize(&self) -> NSInteger;

        /// The maximum extended attribute size in bits.
        ///
        /// Implement at least one of ``maximumXattrSize`` or `maximumXattrSizeInBits`.
        /// FSKit automatically converts from one to another if needed.
        /// If you implement both, FSKit uses only the `maximumXattrSizeInBits` implementation.
        #[optional]
        #[unsafe(method(maximumXattrSizeInBits))]
        #[unsafe(method_family = none)]
        unsafe fn maximumXattrSizeInBits(&self) -> NSInteger;

        /// The maximum size of a regular file allowed in the volume.
        ///
        /// Implement at least one of `maximumFileSize` or ``maximumFileSizeInBits``.
        /// FSKit automatically converts from one to another if needed.
        /// If you implement both, FSKit uses only the `maximumFileSizeInBits` implementation.
        #[optional]
        #[unsafe(method(maximumFileSize))]
        #[unsafe(method_family = none)]
        unsafe fn maximumFileSize(&self) -> u64;

        /// The minimum number of bits needed to represent, as a signed integer value, the maximum size of a regular file allowed in the volume.
        ///
        /// The maximum file size is `2^(maximumFileSizeInBits - 1)`.
        ///
        /// | Maximum file size (bytes)  | Maximum (in hex)     | Unsigned bits | Signed bits |
        /// | -------------------------: | -------------------: | ------------: | ----------: |
        /// |                     65,535 |             `0xFFFF` |            16 |          17 |
        /// |              2,147,483,647 |         `0x7FFFFFFF` |            31 |          32 |
        /// |              4,294,967,295 |         `0xFFFFFFFF` |            32 |          33 |
        /// | 18,446,744,073,709,551,615 | `0xFFFFFFFFFFFFFFFF` |            64 |          65 |
        ///
        /// Implement at least one of ``maximumFileSize`` or `maximumFileSizeInBits`.
        /// FSKit automatically converts from one to another if needed.
        /// If you implement both, FSKit uses only the `maximumFileSizeInBits` implementation.
        #[optional]
        #[unsafe(method(maximumFileSizeInBits))]
        #[unsafe(method_family = none)]
        unsafe fn maximumFileSizeInBits(&self) -> NSInteger;
    }
);

extern_class!(
    /// A type used to report a volume's statistics.
    ///
    /// The names of this type's properties match those in the `statfs` structure in `statfs(2)`, which reports these values for an FSKit file system.
    /// All numeric properties default to `0`.
    /// Override these values, unless a given property has no meaningful value to provide.
    ///
    /// > Note: Available space, free space, total space, and used space have properties to express their values either as a number of blocks or a number of bytes.
    /// Your module may supply both of these values by setting both the relevant block or byte property.
    /// Alternatively, a module may set only one of the two properties.
    /// When you do this, FSKit calculates the matching value based on ``blockSize``.
    ///
    /// For the read-only ``fileSystemTypeName``, set this value with the designated initializer.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsstatfsresult?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct FSStatFSResult;
);

extern_conformance!(
    unsafe impl NSCoding for FSStatFSResult {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for FSStatFSResult {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for FSStatFSResult {}
);

impl FSStatFSResult {
    extern_methods!(
        /// A property for the volume's block size, in bytes.
        ///
        /// This value defaults to `4096`. Zero isn't a valid block size.
        #[unsafe(method(blockSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn blockSize(&self) -> NSInteger;

        /// Setter for [`blockSize`][Self::blockSize].
        #[unsafe(method(setBlockSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBlockSize(&self, block_size: NSInteger);

        /// A property for the optimal block size with which to perform I/O.
        ///
        /// For best performance, specify an `ioSize` that's an even multiple of ``blockSize``.
        #[unsafe(method(ioSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn ioSize(&self) -> NSInteger;

        /// Setter for [`ioSize`][Self::ioSize].
        #[unsafe(method(setIoSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIoSize(&self, io_size: NSInteger);

        /// A property for the volume's total data block count.
        #[unsafe(method(totalBlocks))]
        #[unsafe(method_family = none)]
        pub unsafe fn totalBlocks(&self) -> u64;

        /// Setter for [`totalBlocks`][Self::totalBlocks].
        #[unsafe(method(setTotalBlocks:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTotalBlocks(&self, total_blocks: u64);

        /// A property for the number of free blocks available to a non-superuser on the volume.
        #[unsafe(method(availableBlocks))]
        #[unsafe(method_family = none)]
        pub unsafe fn availableBlocks(&self) -> u64;

        /// Setter for [`availableBlocks`][Self::availableBlocks].
        #[unsafe(method(setAvailableBlocks:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAvailableBlocks(&self, available_blocks: u64);

        /// A property for the number of free blocks in the volume.
        #[unsafe(method(freeBlocks))]
        #[unsafe(method_family = none)]
        pub unsafe fn freeBlocks(&self) -> u64;

        /// Setter for [`freeBlocks`][Self::freeBlocks].
        #[unsafe(method(setFreeBlocks:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFreeBlocks(&self, free_blocks: u64);

        /// A property for the number of used blocks in the volume.
        #[unsafe(method(usedBlocks))]
        #[unsafe(method_family = none)]
        pub unsafe fn usedBlocks(&self) -> u64;

        /// Setter for [`usedBlocks`][Self::usedBlocks].
        #[unsafe(method(setUsedBlocks:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUsedBlocks(&self, used_blocks: u64);

        /// A property for the total size, in bytes, of the volume.
        #[unsafe(method(totalBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn totalBytes(&self) -> u64;

        /// Setter for [`totalBytes`][Self::totalBytes].
        #[unsafe(method(setTotalBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTotalBytes(&self, total_bytes: u64);

        /// A property for the amount of space available to users, in bytes, in the volume.
        #[unsafe(method(availableBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn availableBytes(&self) -> u64;

        /// Setter for [`availableBytes`][Self::availableBytes].
        #[unsafe(method(setAvailableBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAvailableBytes(&self, available_bytes: u64);

        /// A property for the amount of free space, in bytes, in the volume.
        #[unsafe(method(freeBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn freeBytes(&self) -> u64;

        /// Setter for [`freeBytes`][Self::freeBytes].
        #[unsafe(method(setFreeBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFreeBytes(&self, free_bytes: u64);

        /// A property for the amount of used space, in bytes, in the volume.
        #[unsafe(method(usedBytes))]
        #[unsafe(method_family = none)]
        pub unsafe fn usedBytes(&self) -> u64;

        /// Setter for [`usedBytes`][Self::usedBytes].
        #[unsafe(method(setUsedBytes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUsedBytes(&self, used_bytes: u64);

        /// A property for the total number of file slots in the volume,
        #[unsafe(method(totalFiles))]
        #[unsafe(method_family = none)]
        pub unsafe fn totalFiles(&self) -> u64;

        /// Setter for [`totalFiles`][Self::totalFiles].
        #[unsafe(method(setTotalFiles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTotalFiles(&self, total_files: u64);

        /// A property for the total number of free file slots in the volume.
        #[unsafe(method(freeFiles))]
        #[unsafe(method_family = none)]
        pub unsafe fn freeFiles(&self) -> u64;

        /// Setter for [`freeFiles`][Self::freeFiles].
        #[unsafe(method(setFreeFiles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFreeFiles(&self, free_files: u64);

        /// A property for the file system's subtype or flavor.
        ///
        /// Match this value to the `FSPersonalities`'s `FSSubType` attribute, if it exists within the `EXAppExtensionAttributes` dictionary of the module's `Info.plist`.
        #[unsafe(method(fileSystemSubType))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileSystemSubType(&self) -> NSInteger;

        /// Setter for [`fileSystemSubType`][Self::fileSystemSubType].
        #[unsafe(method(setFileSystemSubType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFileSystemSubType(&self, file_system_sub_type: NSInteger);

        /// A property for the file system type name.
        ///
        /// Match this value to the `FSShortName` attribute within the `EXAppExtensionAttributes` dictionary of the module's `Info.plist`.
        /// The maximum allowed length is `MFSTYPENAMELEN`, including the terminating `NUL` character.
        #[unsafe(method(fileSystemTypeName))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileSystemTypeName(&self) -> Retained<NSString>;

        /// Creates an statistics result instance, using the given file system type name.
        ///
        /// - Parameters fileSystemTypeName: A type name for the file system. The maximum allowed length is `MFSTYPENAMELEN`, including the terminating `NUL` character.
        #[unsafe(method(initWithFileSystemTypeName:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithFileSystemTypeName(
            this: Allocated<Self>,
            file_system_type_name: &NSString,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl FSStatFSResult {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Methods that all volumes implement to provide required capabilities.
    ///
    /// Conform to this protocol in your subclass of ``FSVolume``.
    /// To provide additional capabilities, conform to the other `FSVolume` operations protocols, like ``FSVolumeOpenCloseOperations`` and ``FSVolumeReadWriteOperations``.
    ///
    /// > Note: This protocol extends ``FSVolumePathConfOperations``, so your volume implementation must also conform to that protocol.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumeoperations?language=objc)
    pub unsafe trait FSVolumeOperations:
        NSObjectProtocol + FSVolumePathConfOperations
    {
        /// A property that provides the supported capabilities of the volume.
        #[unsafe(method(supportedVolumeCapabilities))]
        #[unsafe(method_family = none)]
        unsafe fn supportedVolumeCapabilities(&self) -> Retained<FSVolumeSupportedCapabilities>;

        /// A property that provides up-to-date statistics of the volume.
        #[unsafe(method(volumeStatistics))]
        #[unsafe(method_family = none)]
        unsafe fn volumeStatistics(&self) -> Retained<FSStatFSResult>;

        /// A property that allows the file system to use open-unlink emulation.
        ///
        /// _Open-unlink_ functionality refers to a file system's ability to support an open file being fully unlinked from the file system namespace.
        /// If a file system doesn't support this functionality, FSKit can emulate it instead; this is called "open-unlink emulation".
        ///
        /// Implement this property to return `true` (Swift) or `YES` (Objective-C) to allow FSKit to perform open-unlink emulation.
        /// If you don't implement this property at all, FSKit doesn't perform open-unlink emulation for this volume.
        ///
        /// FSKit reads this value after the file system replies to the `loadResource` message.
        /// Changing the returned value during the runtime of the volume has no effect.
        #[optional]
        #[unsafe(method(enableOpenUnlinkEmulation))]
        #[unsafe(method_family = none)]
        unsafe fn enableOpenUnlinkEmulation(&self) -> bool;

        /// Setter for [`enableOpenUnlinkEmulation`][Self::enableOpenUnlinkEmulation].
        #[optional]
        #[unsafe(method(setEnableOpenUnlinkEmulation:))]
        #[unsafe(method_family = none)]
        unsafe fn setEnableOpenUnlinkEmulation(&self, enable_open_unlink_emulation: bool);

        #[cfg(all(feature = "FSTaskOptions", feature = "block2"))]
        /// Mounts this volume, using the specified options.
        ///
        /// FSKit calls this method as a signal that some process is trying to mount this volume.
        /// Your file system receives a call to ``activate(options:replyHandler:)`` prior to receiving any mount calls.
        ///
        /// - Parameters:
        /// - options: Options to apply to the mount. These can include security-scoped file paths. There are no defined options currently.
        /// - reply: A block or closure to indicate success or failure. If mounting fails, pass an error as the one parameter to the reply handler. If mounting succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply return normally.
        #[unsafe(method(mountWithOptions:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn mountWithOptions_replyHandler(
            &self,
            options: &FSTaskOptions,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Unmounts this volume.
        ///
        /// Clear and flush all cached state in your implementation of this method.
        ///
        /// - Parameters:
        /// - reply: A block or closure to indicate success or failure. If unmounting fails, pass an error as the one parameter to the reply handler. If unmounting succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply return normally.
        #[unsafe(method(unmountWithReplyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn unmountWithReplyHandler(&self, reply: &block2::DynBlock<dyn Fn()>);

        #[cfg(feature = "block2")]
        /// Synchronizes the volume with its underlying resource.
        ///
        /// After calling this method, FSKit assumes that the volume has sent all pending I/O or metadata to its resource.
        ///
        /// - Parameters:
        /// - flags: Timing flags, as defined in `mount.h.` These flags let the file system know whether to run the operation in a blocking or nonblocking fashion.
        /// - reply: A block or closure to indicate success or failure. If synchronization fails, pass an error as the one parameter to the reply handler. If synchronization succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply throw an error or return normally.
        #[unsafe(method(synchronizeWithFlags:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn synchronizeWithFlags_replyHandler(
            &self,
            flags: FSSyncFlags,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(feature = "FSItem", feature = "block2"))]
        /// Fetches attributes for the given item.
        ///
        /// For file systems that don't support hard links, set ``FSItemAttributes/linkCount`` to `1` for regular files and symbolic links.
        ///
        /// If the item's `bsdFlags` contain the `UF_COMPRESSED` flag, your file system returns the uncompressed size of the file.
        ///
        /// - Parameters:
        /// - desiredAttributes: A requested set of attributes to get. The implementation inspects the request's ``FSItemGetAttributesRequest/wantedAttributes`` to determine which attributes to populate.
        /// - item: The item to get attributes for.
        /// - reply: A block or closure to indicate success or failure. If getting attributes succeeds, pass an ``FSItemAttributes`` with the requested attributes populated and a `nil` error. If getting attributes fails, pass the relevant error as the second parameter; FSKit ignores any ``FSItemAttributes`` in this case. For an `async` Swift implementation, there's no reply handler; simply return the ``FSItemAttributes`` or throw an error.
        #[unsafe(method(getAttributes:ofItem:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn getAttributes_ofItem_replyHandler(
            &self,
            desired_attributes: &FSItemGetAttributesRequest,
            item: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut FSItemAttributes, *mut NSError)>,
        );

        #[cfg(all(feature = "FSItem", feature = "block2"))]
        /// Sets the given attributes on an item.
        ///
        /// Several attributes are considered "read-only", and an attempt to set these attributes results in an error with the code `EINVAL`.
        ///
        /// A request may set ``FSItem/Attributes/size`` beyond the end of the file.
        /// If the underlying file system doesn't support sparse files, allocate space to fill the new file size.
        /// Either fill this space with zeroes, or configure it to read as zeroes.
        ///
        /// If a request sets the file size below the current end-of-file, truncate the file and return any unused space to the file system as free space.
        ///
        /// Ignore attempts to set the size of directories or symbolic links; don't produce an error.
        ///
        /// If the caller attepts to sest an attribute not supported by the on-disk file system format, don't produce an error.
        /// The upper layers of the framework will detect this situation.
        ///
        /// - Parameters:
        /// - newAttributes: A request containing the attributes to set.
        /// - item: The item on which to set the attributes.
        /// - reply: A block or closure to indicate success or failure. If setting attributes succeeds, pass an ``FSItemAttributes`` with the item's updated attributes and a `nil` error. If setting attributes fails, pass the relevant error as the second parameter; FSKit ignores any ``FSItemAttributes`` in this case. For an `async` Swift implementation, there's no reply handler; simply return the ``FSItemAttributes`` or throw an error.
        #[unsafe(method(setAttributes:onItem:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn setAttributes_onItem_replyHandler(
            &self,
            new_attributes: &FSItemSetAttributesRequest,
            item: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut FSItemAttributes, *mut NSError)>,
        );

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Looks up an item within a directory.
        ///
        /// If no item matching `name` exists in the directory indicated by `directory`, complete the request with an error with a domain of
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSPOSIXErrorDomain> and a code of `ENOENT`.
        ///
        /// > Tip: The ``FSFileName`` sent back to the caller may differ from the `name` parameter. This flexibility allows your implementation to handle case-insensitive and case-sensitive file systems. It might also be the case that `name` uses a composed Unicode string, but the name maintained by the file system and provided to the caller is uncomposed Unicode.
        ///
        /// - Parameters:
        /// - name: The name of the item to look up.
        /// - directory: The directory in which to look up the item.
        /// - reply: A block or closure to indicate success or failure. If lookup succeeds, pass the found ``FSItem`` and its ``FSFileName`` (as saved within the file system), along with a `nil` error. If lookup fails, pass the relevant error as the third parameter; any ``FSItem`` or ``FSFileName`` are ignored in this case. For an `async` Swift implementation, there's no reply handler; simply return the ``FSItem`` and ``FSFileName`` as a tuple or throw an error.
        #[unsafe(method(lookupItemNamed:inDirectory:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn lookupItemNamed_inDirectory_replyHandler(
            &self,
            name: &FSFileName,
            directory: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut FSItem, *mut FSFileName, *mut NSError)>,
        );

        #[cfg(all(feature = "FSItem", feature = "block2"))]
        /// Reclaims an item, releasing any resources allocated for the item.
        ///
        /// FSKit guarantees that for every ``FSItem`` returned by the volume, a corresponding reclaim operation occurs after the upper layers no longer reference that item.
        ///
        /// > Note: Block device file systems may assess whether an underyling resource terminates before processing reclaim operations. On unary file systems, for example, the associated volumes unmount when such resources disconnect from the system. The unmount triggers a reclaiming of all items. Some implementations benefit greatly from short-circuiting in such cases. With a terminated resource, all I/O results in an error, making short-circuiting the most efficient response.
        ///
        /// - Parameters:
        /// - item: The item to reclaim.
        /// - reply: A block or closure to indicate success or failure. If removal fails, pass an error as the one parameter to the reply handler. If removal succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply throw an error or return normally.
        #[unsafe(method(reclaimItem:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn reclaimItem_replyHandler(
            &self,
            item: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Reads a symbolic link.
        ///
        /// - Parameters:
        /// - item: The symbolic link to read from. FSKit guarantees this item is of type ``FSItem/ItemType/symlink``.
        /// - reply: A block or closure to indicate success or failure. If reading succeeds, pass the link's contents as an ``FSFileName`` and a `nil` error. If reading fails, pass the relevant error as the second parameter; FSKit ignores any ``FSFileName`` in this case. For an `async` Swift implementation, there's no reply handler; simply return the ``FSFileName`` or throw an error.
        #[unsafe(method(readSymbolicLink:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn readSymbolicLink_replyHandler(
            &self,
            item: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut FSFileName, *mut NSError)>,
        );

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Creates a new file or directory item.
        ///
        /// If an item named `name` already exists in the directory indicated by `directory`, complete the request with an error with a domain of
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSPOSIXErrorDomain> and a code of `EEXIST`.
        ///
        /// - Parameters:
        /// - name: The new item's name.
        /// - type: The new item's type.  Valid values are ``FSItem/ItemType/file`` or ``FSItem/ItemType/directory``.
        /// - directory: The directory in which to create the item.
        /// - newAttributes: Attributes to apply to the new item.
        /// - reply: A block or closure to indicate success or failure. If creation succeeds, pass the newly-created ``FSItem`` and its ``FSFileName``, along with a `nil` error. If creation fails, pass the relevant error as the third parameter; FSKit ignores any ``FSItem`` or ``FSFileName`` in this case. For an `async` Swift implementation, there's no reply handler; simply return a tuple of the ``FSItem`` and its ``FSFileName`` or throw an error.
        #[unsafe(method(createItemNamed:type:inDirectory:attributes:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn createItemNamed_type_inDirectory_attributes_replyHandler(
            &self,
            name: &FSFileName,
            r#type: FSItemType,
            directory: &FSItem,
            new_attributes: &FSItemSetAttributesRequest,
            reply: &block2::DynBlock<dyn Fn(*mut FSItem, *mut FSFileName, *mut NSError)>,
        );

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Creates a new symbolic link.
        ///
        /// If an item named `name` already exists in the directory indicated by `directory`, complete the request with an error with a domain of
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSPOSIXErrorDomain> and a code of `EEXIST`.
        ///
        /// - Parameters:
        /// - name: The new item's name.
        /// - directory: The directory in which to create the item.
        /// - newAttributes: Attributes to apply to the new item.
        /// - contents: The contents of the new symbolic link.
        /// - reply: A block or closure to indicate success or failure. If creation succeeds, pass the newly-created ``FSItem`` and a `nil` error. If creation fails, pass the relevant error as the second parameter; FSKit ignores any ``FSItem`` in this case. For an `async` Swift implementation, there's no reply handler; simply return the ``FSItem`` or throw an error.
        #[unsafe(method(createSymbolicLinkNamed:inDirectory:attributes:linkContents:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn createSymbolicLinkNamed_inDirectory_attributes_linkContents_replyHandler(
            &self,
            name: &FSFileName,
            directory: &FSItem,
            new_attributes: &FSItemSetAttributesRequest,
            contents: &FSFileName,
            reply: &block2::DynBlock<dyn Fn(*mut FSItem, *mut FSFileName, *mut NSError)>,
        );

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Creates a new hard link.
        ///
        /// If creating the link fails, complete the request with an error with a domain of
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSPOSIXErrorDomain> and the following error codes:
        ///
        /// * `EEXIST` if there's already an item named `name` in the directory.
        /// * `EMLINK` if creating the link would exceed the maximum number of hard links supported on `item`.
        /// * `ENOTSUP` if the file system doesn't support creating hard links to the type of file system object that `item` represents.
        ///
        /// - Parameters:
        /// - item: The existing item to which to link.
        /// - name: The name for the new link.
        /// - directory: The directory in which to create the link.
        /// - reply: A block or closure to indicate success or failure. If creation succeeds, pass an ``FSFileName`` of the newly-created link and a `nil` error. If creation fails, pass the relevant error as the second parameter; FSKit ignores any ``FSFileName`` in this case. For an `async` Swift implementation, there's no reply handler; simply return the ``FSFileName`` or throw an error.
        #[unsafe(method(createLinkToItem:named:inDirectory:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn createLinkToItem_named_inDirectory_replyHandler(
            &self,
            item: &FSItem,
            name: &FSFileName,
            directory: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut FSFileName, *mut NSError)>,
        );

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Removes an existing item from a given directory.
        ///
        /// Don't actually remove the item object itself in your implementation; instead, only remove the given item name from the given directory.
        /// Remove and deallocate the item in ``reclaimItem(_:replyHandler:)``.
        ///
        /// - Parameters:
        /// - item: The item to remove.
        /// - name: The name of the item to remove.
        /// - directory: The directory from which to remove the item.
        /// - reply: A block or closure to indicate success or failure. If removal fails, pass an error as the one parameter to the reply handler. If removal succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply throw an error or return normally.
        #[unsafe(method(removeItem:named:fromDirectory:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn removeItem_named_fromDirectory_replyHandler(
            &self,
            item: &FSItem,
            name: &FSFileName,
            directory: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Renames an item from one path in the file system to another.
        ///
        /// Implement renaming along the lines of this algorithm:
        ///
        /// - If `item` is a file:
        /// - If the destination file exists:
        /// - Remove the destination file.
        /// - If the source and destination directories are the same:
        /// - Rewrite the name in the existing directory.
        /// - Else:
        /// - Write the new entry in the destination directory.
        /// - Clear the old directory entry.
        /// - If `item` is a directory:
        /// - If the destination directory exists:
        /// - If the destination directory isn't empty:
        /// - Fail the operation with an error of
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSPOSIXErrorDomain> and a code of `ENOTEMPTY`.
        /// - Else:
        /// - Remove the destination directory.
        /// - If the source and destination directories are the same:
        /// - Rewrite the name in the existing directory.
        /// - Else:
        /// - If the destination is a child of the source directory:
        /// - Fail the operation with an error.
        /// - Else:
        /// - Write the new entry in the destination directory.
        /// - Update `"."` and `".."` in the moved directory.
        /// - Clear the old directory entry.
        ///
        /// - Parameters:
        /// - item: The file system object being renamed.
        /// - sourceDirectory: The directory that currently contains the item to rename.
        /// - sourceName: The name of the item within the source directory.
        /// - destinationName: The new name of the item as it appears in `destinationDirectory`.
        /// - destinationDirectory: The directory to contain the renamed object, which may be the same as `sourceDirectory`.
        /// - overItem: The file system object if the destination exists, as discovered in a prior lookup. If this parameter is non-`nil`, mark `overItem` as deleted, so the file system can free its allocated space on the next call to ``reclaimItem(_:replyHandler:)``. After doing so, ensure the operation finishes without errors.
        /// - reply: A block or closure to indicate success or failure. If renaming succeeds, pass the ``FSFileName`` as it exists within `destinationDirectory` and a `nil` error. If renaming fails, pass the relevant error as the second parameter; FSKit ignores any ``FSFileName`` in this case. For an `async` Swift implementation, there's no reply handler; simply return the ``FSFileName`` or throw an error.
        #[unsafe(method(renameItem:inDirectory:named:toNewName:inDirectory:overItem:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn renameItem_inDirectory_named_toNewName_inDirectory_overItem_replyHandler(
            &self,
            item: &FSItem,
            source_directory: &FSItem,
            source_name: &FSFileName,
            destination_name: &FSFileName,
            destination_directory: &FSItem,
            over_item: Option<&FSItem>,
            reply: &block2::DynBlock<dyn Fn(*mut FSFileName, *mut NSError)>,
        );

        #[cfg(all(feature = "FSItem", feature = "block2"))]
        /// Enumerates the contents of the given directory.
        ///
        /// This method uses the ``FSDirectoryEntryPacker/packEntry(name:itemType:itemID:nextCookie:attributes:)`` method of the `packer` parameter to deliver the enumerated items to the caller.
        /// The general flow of an enumeration implementation follows these steps:
        ///
        /// 1. Enumeration starts with a call to `enumerateDirectory` using the initial next-cookie and verifier values ``FSDirectoryCookieInitial`` and ``FSDirectoryVerifierInitial``, respectively.
        /// 2. The implementation uses `packer` to pack the initial set of directory entries. Packing also sets a `nextCookie` to use on the next call.
        /// 3. The implementation replies with a new verifier value, a nonzero value that reflects the directory's current version.
        /// 4. On the next call the implementation packs the next set of entries, starting with the item indicated by `cookie`. If `cookie` doesn't resolve to a valid directory entry, complete the request with an error of domain
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSPOSIXErrorDomain> and code ``FSError/Code/invalidDirectoryCookie``.
        ///
        /// When packing, make sure to use acceptable directory entry names and unambiguous input to all file operations that take names without additional normalization, such as`lookupName`.
        ///
        /// > Tip: If the `attributes` parameter is `nil`, include at least two entries in a directory: `"."` and `".."`, which represent the current and parent directories, respectively. Both of these items have type ``FSItem/ItemType/directory``. For the root directory, `"."` and `".."` have identical contents. Don't pack  `"."` and `".."` if `attributes` isn't `nil`.
        ///
        /// - Parameters:
        /// - directory: The item to enumerate. FSKit guarantees this item is of type ``FSItem/ItemType/directory``.
        /// - cookie: A value that indicates the location within the directory from which to enumerate. Your implementation defines the semantics of the cookie values; they're opaque to FSKit. The first call to the enumerate method passes ``FSDirectoryCookieInitial`` for this parameter. Subsequent calls pass whatever cookie value you previously passed to the packer's `nextCookie` parmeter.
        /// - verifier: A tool to detect whether the directory contents changed since the last call to `enumerateDirectory`. Your implementation defines the semantics of the verifier values; they're opaque to FSKit. The first call to the enumerate method passes ``FSDirectoryVerifierInitial`` for this parameter. Subsequent calls pass whatever cookie value you previously passed to the packer's `currentVerifier` parmeter.
        /// - attributes: The desired attributes to provide, or `nil` if the caller doesn't require attributes.
        /// - packer: An object that your implementation uses to enumerate directory items, packing one item per callback to `enumerateDirectory`.
        /// - reply: A block or closure to indicate success or failure. If enumeration succeeds, pass the current verifier and a `nil` error. If enumeration fails, pass the relevant error as the second parameter; FSKit ignores any verifier in this case. For an `async` Swift implementation, there's no reply handler; simply return the current verifier or throw an error.
        #[unsafe(method(enumerateDirectory:startingAtCookie:verifier:providingAttributes:usingPacker:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn enumerateDirectory_startingAtCookie_verifier_providingAttributes_usingPacker_replyHandler(
            &self,
            directory: &FSItem,
            cookie: FSDirectoryCookie,
            verifier: FSDirectoryVerifier,
            attributes: Option<&FSItemGetAttributesRequest>,
            packer: &FSDirectoryEntryPacker,
            reply: &block2::DynBlock<dyn Fn(FSDirectoryVerifier, *mut NSError)>,
        );

        #[cfg(all(feature = "FSItem", feature = "FSTaskOptions", feature = "block2"))]
        /// Activates the volume using the specified options.
        ///
        /// When FSKit calls this method, allocate any in-memory state required to represent the file system.
        /// Also allocate an ``FSItem`` for the root directory of the file system, and pass it to the reply block.
        /// FSKit caches this root item for the lifetime of the volume, and uses it as a starting point for all file look-ups.
        ///
        /// Volume activation occurs prior to any call to mount the volume.
        ///
        /// - Parameters:
        /// - options: Options to apply to the activation. These can include security-scoped file paths. There are no defined options currently.
        /// - reply: A block or closure to indicate success or failure. If activation succeeds, pass the root ``FSItem`` and a `nil` error. If activation fails, pass the relevant error as the second parameter; FSKit ignores any ``FSItem`` in this case. In Swift, `reply` takes only the ``FSItem`` as the parameter; you signal any error with a `throw`. For an `async` Swift implementation, there's no reply handler; simply return the ``FSItem`` or throw an error.
        #[unsafe(method(activateWithOptions:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn activateWithOptions_replyHandler(
            &self,
            options: &FSTaskOptions,
            reply: &block2::DynBlock<dyn Fn(*mut FSItem, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Tears down a previously initialized volume instance.
        ///
        /// Set up your implementation to release any resources allocated for the volume instance.
        /// By the time you receive this callback, FSKit has already performed a reclaim call to release all other file nodes associated with this file system instance.
        ///
        /// Avoid performing any I/O in this method.
        /// Prior to calling this method, FSKit has already issued a sync call to perform any
        /// cleanup-related I/O.
        ///
        /// FSKit unmounts any mounted volume with a call to ``unmount(replyHandler:)`` prior to the deactivate callback.
        ///
        /// - Parameters:
        /// - options: Options to apply to the deactivation.
        /// - reply: A block or closure to indicate success or failure. If activation fails, pass an error as the one parameter to the reply handler. If activation succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply throw an error or return normally.
        #[unsafe(method(deactivateWithOptions:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn deactivateWithOptions_replyHandler(
            &self,
            options: FSDeactivateOptions,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );
    }
);

/// Flags to specify the policy when setting extended file attributes.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fssetxattrpolicy?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSSetXattrPolicy(pub NSUInteger);
impl FSSetXattrPolicy {
    /// Set the value, regardless of previous state.
    #[doc(alias = "FSSetXattrPolicyAlwaysSet")]
    pub const AlwaysSet: Self = Self(0);
    /// Set the value, but fail if the extended attribute already exists.
    #[doc(alias = "FSSetXattrPolicyMustCreate")]
    pub const MustCreate: Self = Self(1);
    /// Set the value, but fail if the extended attribute doesn't already exist.
    #[doc(alias = "FSSetXattrPolicyMustReplace")]
    pub const MustReplace: Self = Self(2);
    /// Delete the value, failing if the extended attribute doesn't exist.
    #[doc(alias = "FSSetXattrPolicyDelete")]
    pub const Delete: Self = Self(3);
}

unsafe impl Encode for FSSetXattrPolicy {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for FSSetXattrPolicy {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// Methods and properties implemented by volumes that natively or partially support extended attributes.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumexattroperations?language=objc)
    pub unsafe trait FSVolumeXattrOperations: NSObjectProtocol {
        /// A Boolean value that instructs FSKit not to call this protocol's methods, even if the volume conforms to it.
        ///
        /// FSKit reads this value after the file system replies to the `loadResource` message.
        /// Changing the returned value during the runtime of the volume has no effect.
        #[optional]
        #[unsafe(method(xattrOperationsInhibited))]
        #[unsafe(method_family = none)]
        unsafe fn xattrOperationsInhibited(&self) -> bool;

        /// Setter for [`xattrOperationsInhibited`][Self::xattrOperationsInhibited].
        #[optional]
        #[unsafe(method(setXattrOperationsInhibited:))]
        #[unsafe(method_family = none)]
        unsafe fn setXattrOperationsInhibited(&self, xattr_operations_inhibited: bool);

        #[cfg(all(feature = "FSFileName", feature = "FSItem"))]
        /// Returns an array that specifies the extended attribute names the given item supports.
        ///
        /// If `item` supports no extended attributes, this method returns `nil`.
        ///
        /// Only implement this method if your volume works with "limited" extended attributes.
        /// For purposes of this protocol, "limited" support means the volume doesn't support extended attributes generally, but uses these APIs to expose specific file system data.
        ///
        /// > Note: If a file system implements this method, FSKit assumes limited support for extended attributes exists. In this mode, FSkit only calls this protocol's methods for the extended attribute names this method returns.
        ///
        /// - Parameter item: The item for which to get information.
        #[optional]
        #[unsafe(method(supportedXattrNamesForItem:))]
        #[unsafe(method_family = none)]
        unsafe fn supportedXattrNamesForItem(&self, item: &FSItem)
            -> Retained<NSArray<FSFileName>>;

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Gets the specified extended attribute of the given item.
        ///
        /// - Parameters:
        /// - name: The extended attribute name.
        /// - item: The item for which to get the extended attribute.
        /// - reply: A block or closure to indicate success or failure. If getting the attribute succeeds, pass an data instance containing the extended attribute data and a `nil` error. If getting the attribute fails, pass the relevant error as the second parameter; FSKit ignores any data in this case. For an `async` Swift implementation, there's no reply handler; simply return the data or throw an error.
        #[unsafe(method(getXattrNamed:ofItem:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn getXattrNamed_ofItem_replyHandler(
            &self,
            name: &FSFileName,
            item: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Sets the specified extended attribute data on the given item.
        ///
        /// - Parameters:
        /// - name: The extended attribute name.
        /// - value: The extended attribute value to set. This can't be `nil`, unless the policy is ``FSVolume/SetXattrPolicy/delete``.
        /// - item: The item on which to set the extended attribute.
        /// - policy: The policy to apply when setting the attribute. See ``FSSetXattrPolicy`` for possible values.
        /// - reply: A block or closure to indicate success or failure. If setting the attribute fails, pass an error as the one parameter to the reply handler. If setting the attribute succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply throw an error or return normally.
        #[unsafe(method(setXattrNamed:toData:onItem:policy:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn setXattrNamed_toData_onItem_policy_replyHandler(
            &self,
            name: &FSFileName,
            value: Option<&NSData>,
            item: &FSItem,
            policy: FSSetXattrPolicy,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(feature = "FSFileName", feature = "FSItem", feature = "block2"))]
        /// Gets the list of extended attributes currently set on the given item.
        ///
        /// - Parameters:
        /// - item: The item from which to get extended attributes.
        /// - reply: A block or closure to indicate success or failure. If getting the list of extended attributes succeeds, pass the xattrs as an array of ``FSFileName`` instances and a `nil` error. If getting the attriubtes fails, pass `nil` along with the relevant error. For an `async` Swift implementation, there's no reply handler; simply return the byte count or throw an error.
        #[unsafe(method(listXattrsOfItem:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn listXattrsOfItem_replyHandler(
            &self,
            item: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut NSArray<FSFileName>, *mut NSError)>,
        );
    }
);

/// Defined modes for opening a file.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumeopenmodes?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSVolumeOpenModes(pub NSUInteger);
bitflags::bitflags! {
    impl FSVolumeOpenModes: NSUInteger {
/// The read mode.
///
/// This mode is equivalent to POSIX `FREAD`.
        #[doc(alias = "FSVolumeOpenModesRead")]
        const Read = 1;
/// The write mode.
///
/// This mode is equivalent to POSIX `FRWITE`.
        #[doc(alias = "FSVolumeOpenModesWrite")]
        const Write = 2;
    }
}

unsafe impl Encode for FSVolumeOpenModes {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for FSVolumeOpenModes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// Methods and properties implemented by volumes that want to receive open and close calls for each item.
    ///
    /// When a file system volume conforms to this protocol, the kernel layer issues an open call to indicate desired access, and a close call to indicate what access to retain.
    /// A file is fully closed when the kernel layer issues a close call with no retained open nodes.
    /// When a file system receives the close call, it removes all access to the item.
    /// When all memory mappings to the item release, the kernel layer issues a final close.
    ///
    /// If a file system volume doesn't conform to this protocol, the kernel layer can skip making such calls to the volume.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumeopencloseoperations?language=objc)
    pub unsafe trait FSVolumeOpenCloseOperations: NSObjectProtocol {
        /// A Boolean value that instructs FSKit not to call this protocol's methods, even if the volume conforms to it.
        ///
        /// FSKit reads this value after the file system replies to the `loadResource` message.
        /// Changing the returned value during the runtime of the volume has no effect.
        #[optional]
        #[unsafe(method(isOpenCloseInhibited))]
        #[unsafe(method_family = none)]
        unsafe fn isOpenCloseInhibited(&self) -> bool;

        /// Setter for [`isOpenCloseInhibited`][Self::isOpenCloseInhibited].
        #[optional]
        #[unsafe(method(setOpenCloseInhibited:))]
        #[unsafe(method_family = none)]
        unsafe fn setOpenCloseInhibited(&self, open_close_inhibited: bool);

        #[cfg(all(feature = "FSItem", feature = "block2"))]
        /// Opens a file for access.
        ///
        /// - Parameters:
        /// - item: The item to open.
        /// - modes: The set of mode flags to open the item with.
        /// - reply: A block or closure to indicate success or failure. If opening fails, pass an error as the one parameter to the reply handler. If opening succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply throw an error or return normally.
        #[unsafe(method(openItem:withModes:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn openItem_withModes_replyHandler(
            &self,
            item: &FSItem,
            modes: FSVolumeOpenModes,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(all(feature = "FSItem", feature = "block2"))]
        /// Closes a file from further access.
        ///
        /// - Parameters:
        /// - item: The item to close.
        /// - modes: The set of mode flags to keep after this close.
        /// - reply: A block or closure to indicate success or failure. If closing fails, pass an error as the one parameter to the reply handler. If closing succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply throw an error or return normally.
        #[unsafe(method(closeItem:keepingModes:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn closeItem_keepingModes_replyHandler(
            &self,
            item: &FSItem,
            modes: FSVolumeOpenModes,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );
    }
);

extern_protocol!(
    /// Methods implemented for read and write operations that deliver data to and from the extension.
    ///
    /// Most volumes conform to either this protocol or ``FSVolumeKernelOffloadedIOOperations``.
    /// You can conform to both if you need to provide kernel-offloaded I/O only for certain files.
    /// In that case, files with the ``FSItem/Attribute/inhibitKernelOffloadedIO`` attribute set use this protocol, and those without it use ``FSVolumeKernelOffloadedIOOperations``.
    /// A volume that doesn't conform to either protocol can't support any I/O operation.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumereadwriteoperations?language=objc)
    pub unsafe trait FSVolumeReadWriteOperations: NSObjectProtocol {
        #[cfg(all(
            feature = "FSItem",
            feature = "FSMutableFileDataBuffer",
            feature = "block2",
            feature = "libc"
        ))]
        /// Reads the contents of the given file item.
        ///
        /// If the number of bytes requested exceeds the number of bytes available before the end of the file, then the call copies only those bytes to `buffer`.
        /// If `offset` points past the last valid byte of the file, don't reply with an error but set `actuallyRead` to `0`.
        ///
        /// - Parameters:
        /// - item: The item from which to read. FSKit guarantees this item will be of type ``FSItem/ItemType/file``.
        /// - offset: The offset in the file from which to start reading.
        /// - length: The number of bytes to read.
        /// - buffer: A buffer to receive the bytes read from the file.
        /// - reply: A block or closure to indicate success or failure. If reading succeeds, pass the number of bytes read and a `nil` error. If reading fails, pass the number of bytes read prior to the error along with the relevant error. For an `async` Swift implementation, there's no reply handler; simply return the byte count or throw an error.
        #[unsafe(method(readFromFile:offset:length:intoBuffer:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn readFromFile_offset_length_intoBuffer_replyHandler(
            &self,
            item: &FSItem,
            offset: libc::off_t,
            length: usize,
            buffer: &FSMutableFileDataBuffer,
            reply: &block2::DynBlock<dyn Fn(usize, *mut NSError)>,
        );

        #[cfg(all(feature = "FSItem", feature = "block2", feature = "libc"))]
        /// Writes contents to the given file item.
        ///
        /// FSKit expects this routine to allocate space in the file system to extend the file as necessary.
        ///
        /// If the volume experiences an out-of-space condition, reply with an error of domain
        /// <doc
        /// ://com.apple.documentation/documentation/Foundation/NSPOSIXErrorDomain> and code `ENOSPC`.
        ///
        /// - Parameters:
        /// - contents: A buffer containing the data to write to the file.
        /// - item: The item to which to write. FSKit guarantees this item will be of type ``FSItem/ItemType/file``.
        /// - offset: The offset in the file from which to start writing.
        /// - reply: A block or closure to indicate success or failure. If writing succeeds, pass the number of bytes written and a `nil` error. If writing fails, pass the number of bytes written prior to the error along with the relevant error. For an `async` Swift implementation, there's no reply handler; simply return the byte count or throw an error.
        #[unsafe(method(writeContents:toFile:atOffset:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn writeContents_toFile_atOffset_replyHandler(
            &self,
            contents: &NSData,
            item: &FSItem,
            offset: libc::off_t,
            reply: &block2::DynBlock<dyn Fn(usize, *mut NSError)>,
        );
    }
);

/// A bitmask of access rights.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsaccessmask?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSAccessMask(pub NSUInteger);
bitflags::bitflags! {
    impl FSAccessMask: NSUInteger {
/// The file system allows reading data.
        #[doc(alias = "FSAccessReadData")]
        const ReadData = 1<<1;
/// The file system allows listing directory contents.
        #[doc(alias = "FSAccessListDirectory")]
        const ListDirectory = FSAccessMask::ReadData.0;
/// The file system allows writing data.
        #[doc(alias = "FSAccessWriteData")]
        const WriteData = 1<<2;
/// The file system allows adding files.
        #[doc(alias = "FSAccessAddFile")]
        const AddFile = FSAccessMask::WriteData.0;
/// The file system allows file executuion.
        #[doc(alias = "FSAccessExecute")]
        const Execute = 1<<3;
/// The file system allows searching files.
        #[doc(alias = "FSAccessSearch")]
        const Search = FSAccessMask::Execute.0;
/// The file system allows deleting a file.
        #[doc(alias = "FSAccessDelete")]
        const Delete = 1<<4;
/// The file system allows appending data to a file.
        #[doc(alias = "FSAccessAppendData")]
        const AppendData = 1<<5;
/// The file system allows adding subdirectories.
        #[doc(alias = "FSAccessAddSubdirectory")]
        const AddSubdirectory = FSAccessMask::AppendData.0;
/// The file system allows deleting subdirectories.
        #[doc(alias = "FSAccessDeleteChild")]
        const DeleteChild = 1<<6;
/// The file system allows reading file attributes.
        #[doc(alias = "FSAccessReadAttributes")]
        const ReadAttributes = 1<<7;
/// The file system allows writing file attributes.
        #[doc(alias = "FSAccessWriteAttributes")]
        const WriteAttributes = 1<<8;
/// The file system allows reading extended file attributes.
        #[doc(alias = "FSAccessReadXattr")]
        const ReadXattr = 1<<9;
/// The file system allows writing extended file attributes.
        #[doc(alias = "FSAccessWriteXattr")]
        const WriteXattr = 1<<10;
/// The file system allows reading a file's security descriptors.
        #[doc(alias = "FSAccessReadSecurity")]
        const ReadSecurity = 1<<11;
/// The file system allows writing a file's security descriptors.
        #[doc(alias = "FSAccessWriteSecurity")]
        const WriteSecurity = 1<<12;
/// The file system allows taking ownership of a file.
        #[doc(alias = "FSAccessTakeOwnership")]
        const TakeOwnership = 1<<13;
    }
}

unsafe impl Encode for FSAccessMask {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for FSAccessMask {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// Methods and properties implemented by volumes that want to enforce access check operations.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumeaccesscheckoperations?language=objc)
    pub unsafe trait FSVolumeAccessCheckOperations: NSObjectProtocol {
        /// A Boolean value that instructs FSKit not to call this protocol's methods, even if the volume conforms to it.
        ///
        /// FSKit reads this value after the file system replies to the `loadResource` message.
        /// Changing the returned value during the runtime of the volume has no effect.
        #[optional]
        #[unsafe(method(isAccessCheckInhibited))]
        #[unsafe(method_family = none)]
        unsafe fn isAccessCheckInhibited(&self) -> bool;

        /// Setter for [`isAccessCheckInhibited`][Self::isAccessCheckInhibited].
        #[optional]
        #[unsafe(method(setAccessCheckInhibited:))]
        #[unsafe(method_family = none)]
        unsafe fn setAccessCheckInhibited(&self, access_check_inhibited: bool);

        #[cfg(all(feature = "FSItem", feature = "block2"))]
        /// Checks whether the file system allows access to the given item.
        ///
        /// - Parameters:
        /// - theItem: The item for which to check access.
        /// - access: A mask indicating a set of access types for which to check.
        /// - reply: A block or closure to indicate success or failure. If the access check succeeds, pass a Boolean value to indicate whether the file system grants access, followed by a `nil` error. If the access check fails, pass the relevant error as the second parameter; FSKit ignores the Boolean parameter in this case. For an `async` Swift implementation, there's no reply handler; simply return the `Bool` or throw an error.
        #[unsafe(method(checkAccessToItem:requestedAccess:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn checkAccessToItem_requestedAccess_replyHandler(
            &self,
            the_item: &FSItem,
            access: FSAccessMask,
            reply: &block2::DynBlock<dyn Fn(Bool, *mut NSError)>,
        );
    }
);

extern_protocol!(
    /// Methods and properties implemented by volumes that support renaming the volume.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumerenameoperations?language=objc)
    pub unsafe trait FSVolumeRenameOperations: NSObjectProtocol {
        /// A Boolean value that instructs FSKit not to call this protocol's methods, even if the volume conforms to it.
        ///
        /// FSKit reads this value after the file system replies to the `loadResource` message.
        /// Changing the returned value during the runtime of the volume has no effect.
        #[optional]
        #[unsafe(method(isVolumeRenameInhibited))]
        #[unsafe(method_family = none)]
        unsafe fn isVolumeRenameInhibited(&self) -> bool;

        /// Setter for [`isVolumeRenameInhibited`][Self::isVolumeRenameInhibited].
        #[optional]
        #[unsafe(method(setVolumeRenameInhibited:))]
        #[unsafe(method_family = none)]
        unsafe fn setVolumeRenameInhibited(&self, volume_rename_inhibited: bool);

        #[cfg(all(feature = "FSFileName", feature = "block2"))]
        /// Sets a new name for the volume.
        ///
        /// - Parameters:
        /// - name: The new volume name.
        /// - reply: A block or closure to indicate success or failure. If renaming succeeds, pass an ``FSFileName`` of the new volume name and a `nil` error. If renaming fails, pass the relevant error as the second parameter; FSKit ignores any ``FSFileName`` in this case. For an `async` Swift implementation, there's no reply handler; simply return the ``FSFileName`` or throw an error.
        #[unsafe(method(setVolumeName:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn setVolumeName_replyHandler(
            &self,
            name: &FSFileName,
            reply: &block2::DynBlock<dyn Fn(*mut FSFileName, *mut NSError)>,
        );
    }
);

/// Behavior flags for preallocation operations.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fspreallocateflags?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSPreallocateFlags(pub NSUInteger);
bitflags::bitflags! {
    impl FSPreallocateFlags: NSUInteger {
/// Allocates contiguous space.
        #[doc(alias = "FSPreallocateFlagsContiguous")]
        const Contiguous = 0x00000002;
/// Allocates all requested space or no space at all.
        #[doc(alias = "FSPreallocateFlagsAll")]
        const All = 0x00000004;
/// Allocates space that isn't freed when deleting the descriptor.
///
/// This space remains allocated even after calling `close(2)`.
        #[doc(alias = "FSPreallocateFlagsPersist")]
        const Persist = 0x00000008;
/// Allocates space from the physical end of file.
///
/// When implementing this behavior, ignore any offset in the preallocate call.
/// This flag is currently set for all ``FSVolume/PreallocateOperations/preallocateSpace(for:at:length:flags:replyHandler:)`` calls.
        #[doc(alias = "FSPreallocateFlagsFromEOF")]
        const FromEOF = 0x00000010;
    }
}

unsafe impl Encode for FSPreallocateFlags {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for FSPreallocateFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// Methods and properties implemented by volumes that want to offer preallocation functions.
    ///
    /// A preallocation operation allocates space for a file without writing to it yet.
    /// A file system may use reallocation to avoid performing space allocation while in the midst of I/O; this strategy improves performance.
    /// Also, if the expected I/O pattern is many small writes, preallocating contiguous chunks may prevent fragmenting the file system.
    /// This process can improve performance later.
    ///
    /// In a kernel-based file system, you typically preallocate space with the `VNOP_ALLOCATE` operation, called from `fcntl(F_PREALLOCATE)`.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumepreallocateoperations?language=objc)
    pub unsafe trait FSVolumePreallocateOperations: NSObjectProtocol {
        /// A Boolean value that instructs FSKit not to call this protocol's methods, even if the volume conforms to it.
        ///
        /// FSKit reads this value after the file system replies to the `loadResource` message.
        /// Changing the returned value during the runtime of the volume has no effect.
        #[optional]
        #[unsafe(method(isPreallocateInhibited))]
        #[unsafe(method_family = none)]
        unsafe fn isPreallocateInhibited(&self) -> bool;

        /// Setter for [`isPreallocateInhibited`][Self::isPreallocateInhibited].
        #[optional]
        #[unsafe(method(setPreallocateInhibited:))]
        #[unsafe(method_family = none)]
        unsafe fn setPreallocateInhibited(&self, preallocate_inhibited: bool);

        #[cfg(all(feature = "FSItem", feature = "block2", feature = "libc"))]
        /// Prealocates disk space for the given item.
        ///
        /// - Parameters:
        /// - item: The item for which to preallocate space.
        /// - offset: The offset from which to allocate.
        /// - length: The length of the space in bytes.
        /// - flags: Flags that affect the preallocation behavior.
        /// - reply: A block or closure to indicate success or failure. If preallocation succeeds, pass the amount of bytes allocated and a `nil` error. If preallocation fails, pass the relevant error as the second parameter; FSKit ignores any byte count in this case. For an `async` Swift implementation, there's no reply handler; simply return the allocated byte count or throw an error.
        #[unsafe(method(preallocateSpaceForItem:atOffset:length:flags:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn preallocateSpaceForItem_atOffset_length_flags_replyHandler(
            &self,
            item: &FSItem,
            offset: libc::off_t,
            length: usize,
            flags: FSPreallocateFlags,
            reply: &block2::DynBlock<dyn Fn(usize, *mut NSError)>,
        );
    }
);

/// Options to specify the item deactivation policy.
///
/// Callers may want to set a deactivation policy because ``FSVolume/ItemDeactivation/deactivateItem(_:replyHandler:)`` processing blocks the kernel.
/// Setting a deactivation policy allows the file system to take action at a definitive point in the item's life cycle.
/// These options allow the file system to instruct the FSKit kernel of which circumstances require the expense of a round-trip call to the module.
///
/// > Note: To avoid performing deactivation calls, Objective-C developers use the value `FSItemDeactivationNever`. In Swift, use an empty option set (`[]`).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsitemdeactivationoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct FSItemDeactivationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl FSItemDeactivationOptions: NSUInteger {
/// An option to never perform deactivation.
///
/// With this deactivation option, FSKit never issues `deactivateItem` calls, even though the volume conforms to ``FSVolume/ItemDeactivation``.
        #[doc(alias = "FSItemDeactivationNever")]
        const Never = 0;
/// An option to always perform deactivation calls.
///
/// Use this option if the file system needs `deactivateItem` calls in circumstances beyond those covered by ``forRemovedItems`` and ``forPreallocatedItems``.
        #[doc(alias = "FSItemDeactivationAlways")]
        const Always = NSUIntegerMax as _;
/// An option to process deactivation for open-unlinked items at the moment of last close.
        #[doc(alias = "FSItemDeactivationForRemovedItems")]
        const ForRemovedItems = 1<<0;
/// An option to process deactivation for for files with preallocated space.
///
/// This option facilitates a sort of trim-on-close behavior.
/// It is only meaningful for volumes that conform to ``FSVolume/PreallocateOperations``.
        #[doc(alias = "FSItemDeactivationForPreallocatedItems")]
        const ForPreallocatedItems = 1<<1;
    }
}

unsafe impl Encode for FSItemDeactivationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for FSItemDeactivationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// Methods and properties implemented by volumes that support deactivating items.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/fskit/fsvolumeitemdeactivation?language=objc)
    pub unsafe trait FSVolumeItemDeactivation: NSObjectProtocol {
        /// A property that tells FSKit to which types of items the deactivation applies, if any.
        ///
        /// FSKit reads this value after the file system replies to the `loadResource` message.
        /// Changing the returned value during the runtime of the volume has no effect.
        #[unsafe(method(itemDeactivationPolicy))]
        #[unsafe(method_family = none)]
        unsafe fn itemDeactivationPolicy(&self) -> FSItemDeactivationOptions;

        #[cfg(all(feature = "FSItem", feature = "block2"))]
        /// Notifies the file system that the kernel is no longer making immediate use of the given item.
        ///
        /// This method gives a file system a chance to release resources associated wtih an item.
        /// However, this method prescribes no specific action; it's acceptable to defer all reclamation until ``FSVolume/Operations/reclaimItem(_:replyHandler:)``.
        /// This method is the equivalent of VFS's `VNOP_INACTIVE`.
        ///
        /// FSKit restricts calls to this method based on the current value of ``FSVolume/ItemDeactivation/itemDeactivationPolicy``.
        ///
        /// - Parameters:
        /// - item: The item to deactivate.
        /// - reply: A block or closure to indicate success or failure. If deactivation fails, pass an error as the one parameter to the reply handler. If deactivation succeeds, pass `nil`. For an `async` Swift implementation, there's no reply handler; simply throw an error or return normally.
        #[unsafe(method(deactivateItem:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn deactivateItem_replyHandler(
            &self,
            item: &FSItem,
            reply: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );
    }
);
