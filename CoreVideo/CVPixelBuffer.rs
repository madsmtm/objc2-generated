//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_1monochrome?language=objc)
pub const kCVPixelFormatType_1Monochrome: OSType = 0x00000001;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_2indexed?language=objc)
pub const kCVPixelFormatType_2Indexed: OSType = 0x00000002;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_4indexed?language=objc)
pub const kCVPixelFormatType_4Indexed: OSType = 0x00000004;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_8indexed?language=objc)
pub const kCVPixelFormatType_8Indexed: OSType = 0x00000008;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_1indexedgray_whiteiszero?language=objc)
pub const kCVPixelFormatType_1IndexedGray_WhiteIsZero: OSType = 0x00000021;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_2indexedgray_whiteiszero?language=objc)
pub const kCVPixelFormatType_2IndexedGray_WhiteIsZero: OSType = 0x00000022;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_4indexedgray_whiteiszero?language=objc)
pub const kCVPixelFormatType_4IndexedGray_WhiteIsZero: OSType = 0x00000024;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_8indexedgray_whiteiszero?language=objc)
pub const kCVPixelFormatType_8IndexedGray_WhiteIsZero: OSType = 0x00000028;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_16be555?language=objc)
pub const kCVPixelFormatType_16BE555: OSType = 0x00000010;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_16le555?language=objc)
pub const kCVPixelFormatType_16LE555: OSType = 0x4c353535;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_16le5551?language=objc)
pub const kCVPixelFormatType_16LE5551: OSType = 0x35353531;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_16be565?language=objc)
pub const kCVPixelFormatType_16BE565: OSType = 0x42353635;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_16le565?language=objc)
pub const kCVPixelFormatType_16LE565: OSType = 0x4c353635;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_24rgb?language=objc)
pub const kCVPixelFormatType_24RGB: OSType = 0x00000018;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_24bgr?language=objc)
pub const kCVPixelFormatType_24BGR: OSType = 0x32344247;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_32argb?language=objc)
pub const kCVPixelFormatType_32ARGB: OSType = 0x00000020;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_32bgra?language=objc)
pub const kCVPixelFormatType_32BGRA: OSType = 0x42475241;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_32abgr?language=objc)
pub const kCVPixelFormatType_32ABGR: OSType = 0x41424752;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_32rgba?language=objc)
pub const kCVPixelFormatType_32RGBA: OSType = 0x52474241;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_64argb?language=objc)
pub const kCVPixelFormatType_64ARGB: OSType = 0x62363461;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_64rgbale?language=objc)
pub const kCVPixelFormatType_64RGBALE: OSType = 0x6c363472;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_48rgb?language=objc)
pub const kCVPixelFormatType_48RGB: OSType = 0x62343872;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_32alphagray?language=objc)
pub const kCVPixelFormatType_32AlphaGray: OSType = 0x62333261;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_16gray?language=objc)
pub const kCVPixelFormatType_16Gray: OSType = 0x62313667;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_30rgb?language=objc)
pub const kCVPixelFormatType_30RGB: OSType = 0x5231306b;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_30rgb_r210?language=objc)
pub const kCVPixelFormatType_30RGB_r210: OSType = 0x72323130;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr8?language=objc)
pub const kCVPixelFormatType_422YpCbCr8: OSType = 0x32767579;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_4444ypcbcra8?language=objc)
pub const kCVPixelFormatType_4444YpCbCrA8: OSType = 0x76343038;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_4444ypcbcra8r?language=objc)
pub const kCVPixelFormatType_4444YpCbCrA8R: OSType = 0x72343038;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_4444aypcbcr8?language=objc)
pub const kCVPixelFormatType_4444AYpCbCr8: OSType = 0x79343038;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_4444aypcbcr16?language=objc)
pub const kCVPixelFormatType_4444AYpCbCr16: OSType = 0x79343136;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_4444aypcbcrfloat?language=objc)
pub const kCVPixelFormatType_4444AYpCbCrFloat: OSType = 0x7234666c;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_444ypcbcr8?language=objc)
pub const kCVPixelFormatType_444YpCbCr8: OSType = 0x76333038;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr16?language=objc)
pub const kCVPixelFormatType_422YpCbCr16: OSType = 0x76323136;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr10?language=objc)
pub const kCVPixelFormatType_422YpCbCr10: OSType = 0x76323130;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_444ypcbcr10?language=objc)
pub const kCVPixelFormatType_444YpCbCr10: OSType = 0x76343130;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_420ypcbcr8planar?language=objc)
pub const kCVPixelFormatType_420YpCbCr8Planar: OSType = 0x79343230;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_420ypcbcr8planarfullrange?language=objc)
pub const kCVPixelFormatType_420YpCbCr8PlanarFullRange: OSType = 0x66343230;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr_4a_8biplanar?language=objc)
pub const kCVPixelFormatType_422YpCbCr_4A_8BiPlanar: OSType = 0x61327679;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_420ypcbcr8biplanarvideorange?language=objc)
pub const kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange: OSType = 0x34323076;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_420ypcbcr8biplanarfullrange?language=objc)
pub const kCVPixelFormatType_420YpCbCr8BiPlanarFullRange: OSType = 0x34323066;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr8biplanarvideorange?language=objc)
pub const kCVPixelFormatType_422YpCbCr8BiPlanarVideoRange: OSType = 0x34323276;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr8biplanarfullrange?language=objc)
pub const kCVPixelFormatType_422YpCbCr8BiPlanarFullRange: OSType = 0x34323266;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_444ypcbcr8biplanarvideorange?language=objc)
pub const kCVPixelFormatType_444YpCbCr8BiPlanarVideoRange: OSType = 0x34343476;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_444ypcbcr8biplanarfullrange?language=objc)
pub const kCVPixelFormatType_444YpCbCr8BiPlanarFullRange: OSType = 0x34343466;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr8_yuvs?language=objc)
pub const kCVPixelFormatType_422YpCbCr8_yuvs: OSType = 0x79757673;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr8fullrange?language=objc)
pub const kCVPixelFormatType_422YpCbCr8FullRange: OSType = 0x79757666;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_onecomponent8?language=objc)
pub const kCVPixelFormatType_OneComponent8: OSType = 0x4c303038;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_twocomponent8?language=objc)
pub const kCVPixelFormatType_TwoComponent8: OSType = 0x32433038;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_30rgblepackedwidegamut?language=objc)
pub const kCVPixelFormatType_30RGBLEPackedWideGamut: OSType = 0x77333072;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_argb2101010lepacked?language=objc)
pub const kCVPixelFormatType_ARGB2101010LEPacked: OSType = 0x6c313072;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_40argblewidegamut?language=objc)
pub const kCVPixelFormatType_40ARGBLEWideGamut: OSType = 0x77343061;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_40argblewidegamutpremultiplied?language=objc)
pub const kCVPixelFormatType_40ARGBLEWideGamutPremultiplied: OSType = 0x7734306d;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_onecomponent10?language=objc)
pub const kCVPixelFormatType_OneComponent10: OSType = 0x4c303130;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_onecomponent12?language=objc)
pub const kCVPixelFormatType_OneComponent12: OSType = 0x4c303132;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_onecomponent16?language=objc)
pub const kCVPixelFormatType_OneComponent16: OSType = 0x4c303136;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_twocomponent16?language=objc)
pub const kCVPixelFormatType_TwoComponent16: OSType = 0x32433136;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_onecomponent16half?language=objc)
pub const kCVPixelFormatType_OneComponent16Half: OSType = 0x4c303068;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_onecomponent32float?language=objc)
pub const kCVPixelFormatType_OneComponent32Float: OSType = 0x4c303066;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_twocomponent16half?language=objc)
pub const kCVPixelFormatType_TwoComponent16Half: OSType = 0x32433068;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_twocomponent32float?language=objc)
pub const kCVPixelFormatType_TwoComponent32Float: OSType = 0x32433066;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_64rgbahalf?language=objc)
pub const kCVPixelFormatType_64RGBAHalf: OSType = 0x52476841;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_128rgbafloat?language=objc)
pub const kCVPixelFormatType_128RGBAFloat: OSType = 0x52476641;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_14bayer_grbg?language=objc)
pub const kCVPixelFormatType_14Bayer_GRBG: OSType = 0x67726234;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_14bayer_rggb?language=objc)
pub const kCVPixelFormatType_14Bayer_RGGB: OSType = 0x72676734;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_14bayer_bggr?language=objc)
pub const kCVPixelFormatType_14Bayer_BGGR: OSType = 0x62676734;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_14bayer_gbrg?language=objc)
pub const kCVPixelFormatType_14Bayer_GBRG: OSType = 0x67627234;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_disparityfloat16?language=objc)
pub const kCVPixelFormatType_DisparityFloat16: OSType = 0x68646973;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_disparityfloat32?language=objc)
pub const kCVPixelFormatType_DisparityFloat32: OSType = 0x66646973;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_depthfloat16?language=objc)
pub const kCVPixelFormatType_DepthFloat16: OSType = 0x68646570;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_depthfloat32?language=objc)
pub const kCVPixelFormatType_DepthFloat32: OSType = 0x66646570;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_420ypcbcr10biplanarvideorange?language=objc)
pub const kCVPixelFormatType_420YpCbCr10BiPlanarVideoRange: OSType = 0x78343230;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr10biplanarvideorange?language=objc)
pub const kCVPixelFormatType_422YpCbCr10BiPlanarVideoRange: OSType = 0x78343232;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_444ypcbcr10biplanarvideorange?language=objc)
pub const kCVPixelFormatType_444YpCbCr10BiPlanarVideoRange: OSType = 0x78343434;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_420ypcbcr10biplanarfullrange?language=objc)
pub const kCVPixelFormatType_420YpCbCr10BiPlanarFullRange: OSType = 0x78663230;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr10biplanarfullrange?language=objc)
pub const kCVPixelFormatType_422YpCbCr10BiPlanarFullRange: OSType = 0x78663232;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_444ypcbcr10biplanarfullrange?language=objc)
pub const kCVPixelFormatType_444YpCbCr10BiPlanarFullRange: OSType = 0x78663434;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_420ypcbcr8videorange_8a_triplanar?language=objc)
pub const kCVPixelFormatType_420YpCbCr8VideoRange_8A_TriPlanar: OSType = 0x76306138;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_16versatilebayer?language=objc)
pub const kCVPixelFormatType_16VersatileBayer: OSType = 0x62703136;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_96versatilebayerpacked12?language=objc)
pub const kCVPixelFormatType_96VersatileBayerPacked12: OSType = 0x62747032;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_64rgba_downscaledproresraw?language=objc)
pub const kCVPixelFormatType_64RGBA_DownscaledProResRAW: OSType = 0x62703634;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_422ypcbcr16biplanarvideorange?language=objc)
pub const kCVPixelFormatType_422YpCbCr16BiPlanarVideoRange: OSType = 0x73763232;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_444ypcbcr16biplanarvideorange?language=objc)
pub const kCVPixelFormatType_444YpCbCr16BiPlanarVideoRange: OSType = 0x73763434;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_444ypcbcr16videorange_16a_triplanar?language=objc)
pub const kCVPixelFormatType_444YpCbCr16VideoRange_16A_TriPlanar: OSType = 0x73346173;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_30rgble_8a_biplanar?language=objc)
pub const kCVPixelFormatType_30RGBLE_8A_BiPlanar: OSType = 0x62336138;

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossless_32bgra?language=objc)
pub const kCVPixelFormatType_Lossless_32BGRA: OSType = 0x26424741;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossless_64rgbahalf?language=objc)
pub const kCVPixelFormatType_Lossless_64RGBAHalf: OSType = 0x26526841;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossless_420ypcbcr8biplanarvideorange?language=objc)
pub const kCVPixelFormatType_Lossless_420YpCbCr8BiPlanarVideoRange: OSType = 0x26387630;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossless_420ypcbcr8biplanarfullrange?language=objc)
pub const kCVPixelFormatType_Lossless_420YpCbCr8BiPlanarFullRange: OSType = 0x26386630;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossless_420ypcbcr10packedbiplanarvideorange?language=objc)
pub const kCVPixelFormatType_Lossless_420YpCbCr10PackedBiPlanarVideoRange: OSType = 0x26787630;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossless_422ypcbcr10packedbiplanarvideorange?language=objc)
pub const kCVPixelFormatType_Lossless_422YpCbCr10PackedBiPlanarVideoRange: OSType = 0x26787632;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossless_420ypcbcr10packedbiplanarfullrange?language=objc)
pub const kCVPixelFormatType_Lossless_420YpCbCr10PackedBiPlanarFullRange: OSType = 0x26786630;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossless_30rgble_8a_biplanar?language=objc)
pub const kCVPixelFormatType_Lossless_30RGBLE_8A_BiPlanar: OSType = 0x26623338;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossless_30rgblepackedwidegamut?language=objc)
pub const kCVPixelFormatType_Lossless_30RGBLEPackedWideGamut: OSType = 0x26773372;

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossy_32bgra?language=objc)
pub const kCVPixelFormatType_Lossy_32BGRA: OSType = 0x2d424741;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossy_420ypcbcr8biplanarvideorange?language=objc)
pub const kCVPixelFormatType_Lossy_420YpCbCr8BiPlanarVideoRange: OSType = 0x2d387630;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossy_420ypcbcr8biplanarfullrange?language=objc)
pub const kCVPixelFormatType_Lossy_420YpCbCr8BiPlanarFullRange: OSType = 0x2d386630;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossy_420ypcbcr10packedbiplanarvideorange?language=objc)
pub const kCVPixelFormatType_Lossy_420YpCbCr10PackedBiPlanarVideoRange: OSType = 0x2d787630;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelformattype_lossy_422ypcbcr10packedbiplanarvideorange?language=objc)
pub const kCVPixelFormatType_Lossy_422YpCbCr10PackedBiPlanarVideoRange: OSType = 0x2d787632;

/// Flags to pass to CVPixelBufferLockBaseAddress() / CVPixelBufferUnlockBaseAddress()
///
/// If you are not going to modify the data while you hold the lock, you should set this flag
/// to avoid potentially invalidating any existing caches of the buffer contents.  This flag
/// should be passed both to the lock and unlock functions.  Non-symmetrical usage of this
/// flag will result in undefined behavior.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/cvpixelbufferlockflags?language=objc)
// NS_OPTIONS
#[cfg(feature = "CVBase")]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CVPixelBufferLockFlags(pub CVOptionFlags);
#[cfg(feature = "CVBase")]
bitflags::bitflags! {
    impl CVPixelBufferLockFlags: CVOptionFlags {
        #[doc(alias = "kCVPixelBufferLock_ReadOnly")]
        const ReadOnly = 0x00000001;
    }
}

#[cfg(all(feature = "CVBase", feature = "objc2"))]
unsafe impl Encode for CVPixelBufferLockFlags {
    const ENCODING: Encoding = CVOptionFlags::ENCODING;
}

#[cfg(all(feature = "CVBase", feature = "objc2"))]
unsafe impl RefEncode for CVPixelBufferLockFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/cvplanarcomponentinfo?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CVPlanarComponentInfo {
    pub offset: i32,
    pub rowBytes: u32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CVPlanarComponentInfo {
    const ENCODING: Encoding =
        Encoding::Struct("CVPlanarComponentInfo", &[<i32>::ENCODING, <u32>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CVPlanarComponentInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/cvplanarpixelbufferinfo?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CVPlanarPixelBufferInfo {
    pub componentInfo: [CVPlanarComponentInfo; 1],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CVPlanarPixelBufferInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "CVPlanarPixelBufferInfo",
        &[<[CVPlanarComponentInfo; 1]>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CVPlanarPixelBufferInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/cvplanarpixelbufferinfo_ycbcrplanar?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CVPlanarPixelBufferInfo_YCbCrPlanar {
    pub componentInfoY: CVPlanarComponentInfo,
    pub componentInfoCb: CVPlanarComponentInfo,
    pub componentInfoCr: CVPlanarComponentInfo,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CVPlanarPixelBufferInfo_YCbCrPlanar {
    const ENCODING: Encoding = Encoding::Struct(
        "CVPlanarPixelBufferInfo_YCbCrPlanar",
        &[
            <CVPlanarComponentInfo>::ENCODING,
            <CVPlanarComponentInfo>::ENCODING,
            <CVPlanarComponentInfo>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CVPlanarPixelBufferInfo_YCbCrPlanar {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/cvplanarpixelbufferinfo_ycbcrbiplanar?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CVPlanarPixelBufferInfo_YCbCrBiPlanar {
    pub componentInfoY: CVPlanarComponentInfo,
    pub componentInfoCbCr: CVPlanarComponentInfo,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CVPlanarPixelBufferInfo_YCbCrBiPlanar {
    const ENCODING: Encoding = Encoding::Struct(
        "CVPlanarPixelBufferInfo_YCbCrBiPlanar",
        &[
            <CVPlanarComponentInfo>::ENCODING,
            <CVPlanarComponentInfo>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CVPlanarPixelBufferInfo_YCbCrBiPlanar {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferpixelformattypekey?language=objc)
    pub static kCVPixelBufferPixelFormatTypeKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbuffermemoryallocatorkey?language=objc)
    pub static kCVPixelBufferMemoryAllocatorKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferwidthkey?language=objc)
    pub static kCVPixelBufferWidthKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferheightkey?language=objc)
    pub static kCVPixelBufferHeightKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferextendedpixelsleftkey?language=objc)
    pub static kCVPixelBufferExtendedPixelsLeftKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferextendedpixelstopkey?language=objc)
    pub static kCVPixelBufferExtendedPixelsTopKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferextendedpixelsrightkey?language=objc)
    pub static kCVPixelBufferExtendedPixelsRightKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferextendedpixelsbottomkey?language=objc)
    pub static kCVPixelBufferExtendedPixelsBottomKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferbytesperrowalignmentkey?language=objc)
    pub static kCVPixelBufferBytesPerRowAlignmentKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbuffercgbitmapcontextcompatibilitykey?language=objc)
    pub static kCVPixelBufferCGBitmapContextCompatibilityKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbuffercgimagecompatibilitykey?language=objc)
    pub static kCVPixelBufferCGImageCompatibilityKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferopenglcompatibilitykey?language=objc)
    pub static kCVPixelBufferOpenGLCompatibilityKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferplanealignmentkey?language=objc)
    pub static kCVPixelBufferPlaneAlignmentKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferiosurfacepropertieskey?language=objc)
    pub static kCVPixelBufferIOSurfacePropertiesKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferopenglescompatibilitykey?language=objc)
    pub static kCVPixelBufferOpenGLESCompatibilityKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbuffermetalcompatibilitykey?language=objc)
    pub static kCVPixelBufferMetalCompatibilityKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferopengltexturecachecompatibilitykey?language=objc)
    pub static kCVPixelBufferOpenGLTextureCacheCompatibilityKey: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferopenglestexturecachecompatibilitykey?language=objc)
    pub static kCVPixelBufferOpenGLESTextureCacheCompatibilityKey: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for code indicating Bayer pattern (sensel arrangement).
    ///
    /// Associated attachment is a CFNumber of type kCFNumberSInt32Type.  The value follows the semantics of the ProRes RAW bayer_pattern bitstream syntax element, namely 0, 1, 2, or 3, where 0 means the top-left sensel of the frame is red-filtered ("RGGB"); 1 means the top-left sensel of the frame is green-filtered, with the top row alternating between green- and red-filtered sensels ("GRBG"); 2 means the top-left sensel of the frame is green- filtered, with the top row alternating between green- and blue-filtered sensels ("GBRG"); and 3 means the top-left sensel of the frame is blue-filtered ("BGGR").  This attachment applies only to buffers with VersatileBayer formats.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferversatilebayerkey_bayerpattern?language=objc)
    pub static kCVPixelBufferVersatileBayerKey_BayerPattern: &'static CFString;
}

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvversatilebayer_bayerpattern_rggb?language=objc)
pub const kCVVersatileBayer_BayerPattern_RGGB: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvversatilebayer_bayerpattern_grbg?language=objc)
pub const kCVVersatileBayer_BayerPattern_GRBG: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvversatilebayer_bayerpattern_gbrg?language=objc)
pub const kCVVersatileBayer_BayerPattern_GBRG: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvversatilebayer_bayerpattern_bggr?language=objc)
pub const kCVVersatileBayer_BayerPattern_BGGR: c_uint = 3;

extern "C" {
    /// Buffer attachment key for siting offsets, relative to pixel center, of individual sensels/components constituting each pixel.
    ///
    /// Associated attachment is CFData containing an array of 8 32-bit floats.  The eight CFData array elements specify, in order, the following sensel/component offsets from pixel center: red horizontal offset, red vertical offset, green horizontal offset, green vertical offset, blue horizontal offset, blue vertical offset, alpha horizontal offset, and alpha vertical offset.  A positive offset value indicates that the sensel/component lies to the right of or below the center of its pixel, while a negative value indicates that the sensel/component lies to the left of or above the center of its pixel.  Horizontal and vertical offset magnitudes are respectively in terms of the spacing between horizontally- and vertically-adjacent pixel centers.  This attachment applies only to buffers with the bp64 format, and is optional for those buffers; if not present, all offsets are considered to be 0.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_senselsitingoffsets?language=objc)
    pub static kCVPixelBufferProResRAWKey_SenselSitingOffsets: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for sensel black level.
    ///
    /// Associated attachment is a CFNumber of type kCFNumberSInt32Type.  The value is the sensel level corresponding to no light exposure.  This attachment is required for buffers with either the bp16 or bp64 format.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_blacklevel?language=objc)
    pub static kCVPixelBufferProResRAWKey_BlackLevel: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for sensel white level.
    ///
    /// Associated attachment is a CFNumber of type kCFNumberSInt32Type.  The value is the sensel level corresponding to sensor (or camera A-to-D converter) saturation.  This attachment is required for buffers with either the bp16 or bp64 format.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_whitelevel?language=objc)
    pub static kCVPixelBufferProResRAWKey_WhiteLevel: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for illuminant correlated color temperature.
    ///
    /// Associated attachment is a CFNumber of type kCFNumberSInt32Type.  The value is the illuminant correlated color temperature (CCT), in kelvins, selected at the time of capture.  May be 0, indicating that the CCT is unknown or unspecified.  This attachment is optional for buffers with either the bp16 or bp64 format; if not present, the CCT is considered unknown or unspecified.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_whitebalancecct?language=objc)
    pub static kCVPixelBufferProResRAWKey_WhiteBalanceCCT: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for white balance red factor.
    ///
    /// Associated attachment is a CFNumber of type kCFNumberFloat32Type.  The value is the white balance multiplication factor for red-filtered sensels.  This attachment is required for buffers with either the bp16 or bp64 format.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_whitebalanceredfactor?language=objc)
    pub static kCVPixelBufferProResRAWKey_WhiteBalanceRedFactor: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for white balance blue factor.
    ///
    /// Associated attachment is a CFNumber of type kCFNumberFloat32Type.  The value is the white balance multiplication factor for blue-filtered sensels.  This attachment is required for buffers with either the bp16 or bp64 format.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_whitebalancebluefactor?language=objc)
    pub static kCVPixelBufferProResRAWKey_WhiteBalanceBlueFactor: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for color translation matrix.
    ///
    /// Associated attachment is CFData containing an array of 9 32-bit floats.  The value is a 3x3 matrix which transforms linear RGB pixel values in the camera native color space to CIE 1931 XYZ values relative to the D65 illuminant, where the matrix entries are stored in the CFData in row-major order.  This attachment is required for buffers with either the bp16 or bp64 format.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_colormatrix?language=objc)
    pub static kCVPixelBufferProResRAWKey_ColorMatrix: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for gain factor.
    ///
    /// Associated attachment is a CFNumber of type kCFNumberFloat32Type.  The value is the overall gain factor for raw conversion.  This attachment is required for buffers with either the bp16 or bp64 format.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_gainfactor?language=objc)
    pub static kCVPixelBufferProResRAWKey_GainFactor: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for recommended number of pixels/rows to discard from the sides of the image after raw conversion.
    ///
    /// Associated attachment is CFData containing an array of 4 32-bit floats.  The four CFData array elements specify, in order, the recommended number of: pixels to discard from the start (left) of each row of the image; pixels to discard from the end (right) of each row of the image; rows of pixels to discard from the top of the image; and rows of pixels to discard from the bottom of the image.  (Pixels/rows are discarded after raw conversion.)  This attachment is optional for buffers with either the bp16 or bp64 format; if not present, the recommended crop values are considered to be 0.  For buffers with the bp64 format, the values may be nonintegral due to downscaling, in which case the handling of fractional parts is implementation-dependent.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_recommendedcrop?language=objc)
    pub static kCVPixelBufferProResRAWKey_RecommendedCrop: &'static CFString;
}

extern "C" {
    /// Buffer attachment key for metadata extension.
    ///
    /// Associated attachment is CFData containing ProRes RAW metadata extension. This attachment is optional for buffers with either bp16 or bp64.  The CFData contains a big-endian uint32 representing the size of the item in bytes followed by a 4-character code ('psim') followed by a variable-length pascal string identifying the metadata (like a key string) followed by the metadata payload.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferproresrawkey_metadataextension?language=objc)
    pub static kCVPixelBufferProResRAWKey_MetadataExtension: &'static CFString;
}

extern "C" {
    /// Key sets the IOSurface backed memory allocation for CVPixelBuffer as purgable and volatile.
    ///
    /// A purgeable IOSurface is capable of being switched between non-volatile, volatile and empty states using IOSurfaceSetPurgeable.  When in the volatile state, the OS is permitted to instantly change its state to empty and remove all its memory pages.  Clients should set the IOSurfaces to the non-volatile state while they are in use and the volatile state when their need and contents is optional/speculative and OK to discard in response to system memory demand.  See IOSurfaceSetPurgeable for more details.  This key is only effective for CVPixelBuffers that are backed by IOSurface.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/kcvpixelbufferiosurfacepurgeablekey?language=objc)
    pub static kCVPixelBufferIOSurfacePurgeableKey: &'static CFString;
}

/// Based on the image buffer type. The pixel buffer implements the memory storage for an image buffer.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corevideo/cvpixelbuffer?language=objc)
#[doc(alias = "CVPixelBufferRef")]
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
pub type CVPixelBuffer = CVImageBuffer;

#[inline]
pub extern "C-unwind" fn CVPixelBufferGetTypeID() -> CFTypeID {
    extern "C-unwind" {
        fn CVPixelBufferGetTypeID() -> CFTypeID;
    }
    unsafe { CVPixelBufferGetTypeID() }
}

extern "C-unwind" {
    /// Takes a CFArray of CFDictionary objects describing various pixel buffer attributes and tries to resolve them into a
    /// single dictionary.
    ///
    /// This is useful when you need to resolve multiple requirements between different potential clients of a buffer.
    ///
    /// Parameter `attributes`: CFArray of CFDictionaries containing kCVPixelBuffer key/value pairs.
    ///
    /// Parameter `resolvedDictionaryOut`: The resulting dictionary will be placed here.
    ///
    /// Returns: Return value that may be useful in discovering why resolution failed.
    ///
    /// # Safety
    ///
    /// - `attributes` generic must be of the correct type.
    /// - `resolved_dictionary_out` must be a valid pointer.
    #[cfg(feature = "CVReturn")]
    pub fn CVPixelBufferCreateResolvedAttributesDictionary(
        allocator: Option<&CFAllocator>,
        attributes: Option<&CFArray>,
        resolved_dictionary_out: NonNull<*const CFDictionary>,
    ) -> CVReturn;
}

extern "C-unwind" {
    /// Call to create a single PixelBuffer for a given size and pixelFormatType.
    ///
    /// Creates a single PixelBuffer for a given size and pixelFormatType. It allocates the necessary memory based on the pixel dimensions, pixelFormatType and extended pixels described in the pixelBufferAttributes. Not all parameters of the pixelBufferAttributes will be used here.
    ///
    /// Parameter `width`: Width of the PixelBuffer in pixels.
    ///
    /// Parameter `height`: Height of the PixelBuffer in pixels.
    ///
    /// Parameter `pixelFormatType`: Pixel format indentified by its respective OSType.
    ///
    /// Parameter `pixelBufferAttributes`: A dictionary with additional attributes for a pixel buffer. This parameter is optional. See BufferAttributeKeys for more details.
    ///
    /// Parameter `pixelBufferOut`: The new pixel buffer will be returned here
    ///
    /// Returns: returns kCVReturnSuccess on success.
    ///
    /// # Safety
    ///
    /// - `pixel_buffer_attributes` generics must be of the correct type.
    /// - `pixel_buffer_out` must be a valid pointer.
    #[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer", feature = "CVReturn"))]
    pub fn CVPixelBufferCreate(
        allocator: Option<&CFAllocator>,
        width: usize,
        height: usize,
        pixel_format_type: OSType,
        pixel_buffer_attributes: Option<&CFDictionary>,
        pixel_buffer_out: NonNull<*mut CVPixelBuffer>,
    ) -> CVReturn;
}

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/cvpixelbufferreleasebytescallback?language=objc)
pub type CVPixelBufferReleaseBytesCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *const c_void)>;

extern "C-unwind" {
    /// Call to create a single PixelBuffer for a given size and pixelFormatType based on a passed in piece of memory.
    ///
    /// Creates a single PixelBuffer for a given size and pixelFormatType. Not all parameters of the pixelBufferAttributes will be used here. It requires a release callback function that will be called, when the PixelBuffer gets destroyed so that the owner of the pixels can free the memory.
    ///
    /// Parameter `width`: Width of the PixelBuffer in pixels
    ///
    /// Parameter `height`: Height of the PixelBuffer in pixels
    ///
    /// Parameter `pixelFormatType`: Pixel format indentified by its respective OSType.
    ///
    /// Parameter `baseAddress`: Address of the memory storing the pixels.
    ///
    /// Parameter `bytesPerRow`: Row bytes of the pixel storage memory.
    ///
    /// Parameter `releaseCallback`: CVPixelBufferReleaseBytePointerCallback function that gets called when the PixelBuffer gets destroyed.
    ///
    /// Parameter `releaseRefCon`: User data identifying the PixelBuffer for the release callback.
    ///
    /// Parameter `pixelBufferAttributes`: A dictionary with additional attributes for a a pixel buffer. This parameter is optional. See PixelBufferAttributes for more details.
    ///
    /// Parameter `pixelBufferOut`: The new pixel buffer will be returned here
    ///
    /// Returns: returns kCVReturnSuccess on success.
    ///
    /// # Safety
    ///
    /// - `base_address` must be a valid pointer.
    /// - `release_callback` must be implemented correctly.
    /// - `release_ref_con` must be a valid pointer or null.
    /// - `pixel_buffer_attributes` generics must be of the correct type.
    /// - `pixel_buffer_out` must be a valid pointer.
    #[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer", feature = "CVReturn"))]
    pub fn CVPixelBufferCreateWithBytes(
        allocator: Option<&CFAllocator>,
        width: usize,
        height: usize,
        pixel_format_type: OSType,
        base_address: NonNull<c_void>,
        bytes_per_row: usize,
        release_callback: CVPixelBufferReleaseBytesCallback,
        release_ref_con: *mut c_void,
        pixel_buffer_attributes: Option<&CFDictionary>,
        pixel_buffer_out: NonNull<*mut CVPixelBuffer>,
    ) -> CVReturn;
}

/// [Apple's documentation](https://developer.apple.com/documentation/corevideo/cvpixelbufferreleaseplanarbytescallback?language=objc)
pub type CVPixelBufferReleasePlanarBytesCallback = Option<
    unsafe extern "C-unwind" fn(*mut c_void, *const c_void, usize, usize, *mut *const c_void),
>;

extern "C-unwind" {
    /// Call to create a single PixelBuffer in planar format for a given size and pixelFormatType based on a passed in piece of memory.
    ///
    /// Creates a single PixelBuffer for a given size and pixelFormatType. Not all parameters of the pixelBufferAttributes will be used here. It requires a release callback function that will be called, when the PixelBuffer gets destroyed so that the owner of the pixels can free the memory.
    ///
    /// Parameter `width`: Width of the PixelBuffer in pixels
    ///
    /// Parameter `height`: Height of the PixelBuffer in pixels
    ///
    /// Parameter `pixelFormatType`: Pixel format indentified by its respective OSType.
    ///
    /// Parameter `dataPtr`: Pass a pointer to a plane descriptor block, or NULL.
    ///
    /// Parameter `dataSize`: pass size if planes are contiguous, NULL if not.
    ///
    /// Parameter `numberOfPlanes`: Number of planes.
    ///
    /// Parameter `planeBaseAddress`: Array of base addresses for the planes.
    ///
    /// Parameter `planeWidth`: Array of plane widths.
    ///
    /// Parameter `planeHeight`: Array of plane heights.
    ///
    /// Parameter `planeBytesPerRow`: Array of plane bytesPerRow values.
    ///
    /// Parameter `releaseCallback`: CVPixelBufferReleaseBytePointerCallback function that gets called when the PixelBuffer gets destroyed.
    ///
    /// Parameter `releaseRefCon`: User data identifying the PixelBuffer for the release callback.
    ///
    /// Parameter `pixelBufferAttributes`: A dictionary with additional attributes for a a pixel buffer. This parameter is optional. See PixelBufferAttributes for more details.
    ///
    /// Parameter `pixelBufferOut`: The new pixel buffer will be returned here
    ///
    /// Returns: returns kCVReturnSuccess on success.
    ///
    /// # Safety
    ///
    /// - `data_ptr` must be a valid pointer or null.
    /// - `plane_base_address` must be a valid pointer.
    /// - `plane_width` must be a valid pointer.
    /// - `plane_height` must be a valid pointer.
    /// - `plane_bytes_per_row` must be a valid pointer.
    /// - `release_callback` must be implemented correctly.
    /// - `release_ref_con` must be a valid pointer or null.
    /// - `pixel_buffer_attributes` generics must be of the correct type.
    /// - `pixel_buffer_out` must be a valid pointer.
    #[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer", feature = "CVReturn"))]
    pub fn CVPixelBufferCreateWithPlanarBytes(
        allocator: Option<&CFAllocator>,
        width: usize,
        height: usize,
        pixel_format_type: OSType,
        data_ptr: *mut c_void,
        data_size: usize,
        number_of_planes: usize,
        plane_base_address: NonNull<*mut c_void>,
        plane_width: NonNull<usize>,
        plane_height: NonNull<usize>,
        plane_bytes_per_row: NonNull<usize>,
        release_callback: CVPixelBufferReleasePlanarBytesCallback,
        release_ref_con: *mut c_void,
        pixel_buffer_attributes: Option<&CFDictionary>,
        pixel_buffer_out: NonNull<*mut CVPixelBuffer>,
    ) -> CVReturn;
}

extern "C-unwind" {
    /// Description Locks the BaseAddress of the PixelBuffer to ensure that the memory is accessible.
    ///
    /// This API ensures that the CVPixelBuffer is accessible in system memory. This should only be called if the base address is going to be used and the pixel data will be accessed by the CPU.
    ///
    /// Parameter `pixelBuffer`: Target PixelBuffer.
    ///
    /// Parameter `lockFlags`: See CVPixelBufferLockFlags.
    ///
    /// Returns: kCVReturnSuccess if the lock succeeded, or error code on failure
    #[cfg(all(
        feature = "CVBase",
        feature = "CVBuffer",
        feature = "CVImageBuffer",
        feature = "CVReturn"
    ))]
    pub fn CVPixelBufferLockBaseAddress(
        pixel_buffer: &CVPixelBuffer,
        lock_flags: CVPixelBufferLockFlags,
    ) -> CVReturn;
}

extern "C-unwind" {
    /// Description Unlocks the BaseAddress of the PixelBuffer.
    ///
    /// Parameter `pixelBuffer`: Target PixelBuffer.
    ///
    /// Parameter `unlockFlags`: See CVPixelBufferLockFlags.
    ///
    /// Returns: kCVReturnSuccess if the unlock succeeded, or error code on failure
    #[cfg(all(
        feature = "CVBase",
        feature = "CVBuffer",
        feature = "CVImageBuffer",
        feature = "CVReturn"
    ))]
    pub fn CVPixelBufferUnlockBaseAddress(
        pixel_buffer: &CVPixelBuffer,
        unlock_flags: CVPixelBufferLockFlags,
    ) -> CVReturn;
}

/// Returns the width of the PixelBuffer.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Returns: Width in pixels.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetWidth(pixel_buffer: &CVPixelBuffer) -> usize {
    extern "C-unwind" {
        fn CVPixelBufferGetWidth(pixel_buffer: &CVPixelBuffer) -> usize;
    }
    unsafe { CVPixelBufferGetWidth(pixel_buffer) }
}

/// Returns the height of the PixelBuffer.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Returns: Height in pixels.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetHeight(pixel_buffer: &CVPixelBuffer) -> usize {
    extern "C-unwind" {
        fn CVPixelBufferGetHeight(pixel_buffer: &CVPixelBuffer) -> usize;
    }
    unsafe { CVPixelBufferGetHeight(pixel_buffer) }
}

/// Returns the PixelFormatType of the PixelBuffer.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Returns: OSType identifying the pixel format by its type.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetPixelFormatType(pixel_buffer: &CVPixelBuffer) -> OSType {
    extern "C-unwind" {
        fn CVPixelBufferGetPixelFormatType(pixel_buffer: &CVPixelBuffer) -> OSType;
    }
    unsafe { CVPixelBufferGetPixelFormatType(pixel_buffer) }
}

/// Returns the base address of the PixelBuffer.
///
/// Retrieving the base address for a PixelBuffer requires that the buffer base address be locked
/// via a successful call to CVPixelBufferLockBaseAddress.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Returns: Base address of the pixels.
/// For chunky buffers, this will return a pointer to the pixel at 0,0 in the buffer
/// For planar buffers this will return a pointer to a PlanarComponentInfo struct (defined in QuickTime).
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetBaseAddress(pixel_buffer: &CVPixelBuffer) -> *mut c_void {
    extern "C-unwind" {
        fn CVPixelBufferGetBaseAddress(pixel_buffer: &CVPixelBuffer) -> *mut c_void;
    }
    unsafe { CVPixelBufferGetBaseAddress(pixel_buffer) }
}

/// Returns the rowBytes of the PixelBuffer.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Returns: Bytes per row of the image data.   For planar buffers this will return a rowBytes value such that bytesPerRow * height
/// will cover the entire image including all planes.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetBytesPerRow(pixel_buffer: &CVPixelBuffer) -> usize {
    extern "C-unwind" {
        fn CVPixelBufferGetBytesPerRow(pixel_buffer: &CVPixelBuffer) -> usize;
    }
    unsafe { CVPixelBufferGetBytesPerRow(pixel_buffer) }
}

/// Returns the data size for contigous planes of the PixelBuffer.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Returns: Data size used in CVPixelBufferCreateWithPlanarBytes.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetDataSize(pixel_buffer: &CVPixelBuffer) -> usize {
    extern "C-unwind" {
        fn CVPixelBufferGetDataSize(pixel_buffer: &CVPixelBuffer) -> usize;
    }
    unsafe { CVPixelBufferGetDataSize(pixel_buffer) }
}

/// Returns if the PixelBuffer is planar.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Returns: True if the PixelBuffer was created using CVPixelBufferCreateWithPlanarBytes.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferIsPlanar(pixel_buffer: &CVPixelBuffer) -> bool {
    extern "C-unwind" {
        fn CVPixelBufferIsPlanar(pixel_buffer: &CVPixelBuffer) -> Boolean;
    }
    let ret = unsafe { CVPixelBufferIsPlanar(pixel_buffer) };
    ret != 0
}

/// Returns number of planes of the PixelBuffer.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Returns: Number of planes.  Returns 0 for non-planar CVPixelBufferRefs.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetPlaneCount(pixel_buffer: &CVPixelBuffer) -> usize {
    extern "C-unwind" {
        fn CVPixelBufferGetPlaneCount(pixel_buffer: &CVPixelBuffer) -> usize;
    }
    unsafe { CVPixelBufferGetPlaneCount(pixel_buffer) }
}

/// Returns the width of the plane at planeIndex in the PixelBuffer.
///
/// On OSX 10.10 and earlier, or iOS 8 and earlier, calling this
/// function with a non-planar buffer will have undefined behavior.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Parameter `planeIndex`: Identifying the plane.
///
/// Returns: Width in pixels, or 0 for non-planar CVPixelBufferRefs.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetWidthOfPlane(
    pixel_buffer: &CVPixelBuffer,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn CVPixelBufferGetWidthOfPlane(pixel_buffer: &CVPixelBuffer, plane_index: usize) -> usize;
    }
    unsafe { CVPixelBufferGetWidthOfPlane(pixel_buffer, plane_index) }
}

/// Returns the height of the plane at planeIndex in the PixelBuffer.
///
/// On OSX 10.10 and earlier, or iOS 8 and earlier, calling this
/// function with a non-planar buffer will have undefined behavior.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Parameter `planeIndex`: Identifying the plane.
///
/// Returns: Height in pixels, or 0 for non-planar CVPixelBufferRefs.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetHeightOfPlane(
    pixel_buffer: &CVPixelBuffer,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn CVPixelBufferGetHeightOfPlane(pixel_buffer: &CVPixelBuffer, plane_index: usize)
            -> usize;
    }
    unsafe { CVPixelBufferGetHeightOfPlane(pixel_buffer, plane_index) }
}

/// Returns the base address of the plane at planeIndex in the PixelBuffer.
///
/// Retrieving the base address for a PixelBuffer requires that the buffer base address be locked
/// via a successful call to CVPixelBufferLockBaseAddress. On OSX 10.10 and earlier, or iOS 8 and
/// earlier, calling this function with a non-planar buffer will have undefined behavior.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Parameter `planeIndex`: Identifying the plane.
///
/// Returns: Base address of the plane, or NULL for non-planar CVPixelBufferRefs.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetBaseAddressOfPlane(
    pixel_buffer: &CVPixelBuffer,
    plane_index: usize,
) -> *mut c_void {
    extern "C-unwind" {
        fn CVPixelBufferGetBaseAddressOfPlane(
            pixel_buffer: &CVPixelBuffer,
            plane_index: usize,
        ) -> *mut c_void;
    }
    unsafe { CVPixelBufferGetBaseAddressOfPlane(pixel_buffer, plane_index) }
}

/// Returns the row bytes of the plane at planeIndex in the PixelBuffer.
///
/// On OSX 10.10 and earlier, or iOS 8 and earlier, calling this
/// function with a non-planar buffer will have undefined behavior.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
///
/// Parameter `planeIndex`: Identifying the plane.
///
/// Returns: Row bytes of the plane, or NULL for non-planar CVPixelBufferRefs.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferGetBytesPerRowOfPlane(
    pixel_buffer: &CVPixelBuffer,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn CVPixelBufferGetBytesPerRowOfPlane(
            pixel_buffer: &CVPixelBuffer,
            plane_index: usize,
        ) -> usize;
    }
    unsafe { CVPixelBufferGetBytesPerRowOfPlane(pixel_buffer, plane_index) }
}

extern "C-unwind" {
    /// Returns the size of extended pixels of the PixelBuffer.
    ///
    /// On OSX 10.10 and earlier, or iOS 8 and earlier, calling this
    /// function with a non-planar buffer will have undefined behavior.
    ///
    /// Parameter `pixelBuffer`: Target PixelBuffer.
    ///
    /// Parameter `extraColumnsOnLeft`: Returns the pixel row padding to the left.  May be NULL.
    ///
    /// Parameter `extraRowsOnTop`: Returns the pixel row padding to the top.  May be NULL.
    ///
    /// Parameter `extraColumnsOnRight`: Returns the pixel row padding to the right. May be NULL.
    ///
    /// Parameter `extraRowsOnBottom`: Returns the pixel row padding to the bottom. May be NULL.
    ///
    /// # Safety
    ///
    /// - `extra_columns_on_left` must be a valid pointer or null.
    /// - `extra_columns_on_right` must be a valid pointer or null.
    /// - `extra_rows_on_top` must be a valid pointer or null.
    /// - `extra_rows_on_bottom` must be a valid pointer or null.
    #[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
    pub fn CVPixelBufferGetExtendedPixels(
        pixel_buffer: &CVPixelBuffer,
        extra_columns_on_left: *mut usize,
        extra_columns_on_right: *mut usize,
        extra_rows_on_top: *mut usize,
        extra_rows_on_bottom: *mut usize,
    );
}

/// Fills the extended pixels of the PixelBuffer.   This function replicates edge pixels to fill the entire extended region of the image.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer", feature = "CVReturn"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferFillExtendedPixels(pixel_buffer: &CVPixelBuffer) -> CVReturn {
    extern "C-unwind" {
        fn CVPixelBufferFillExtendedPixels(pixel_buffer: &CVPixelBuffer) -> CVReturn;
    }
    unsafe { CVPixelBufferFillExtendedPixels(pixel_buffer) }
}

/// Returns a copy of pixelBufferAttributes dictionary used to create the PixelBuffer.
///
/// Can be used to create similar pixelbuffers.
///
/// Parameter `pixelBuffer`: Target PixelBuffer.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub extern "C-unwind" fn CVPixelBufferCopyCreationAttributes(
    pixel_buffer: &CVPixelBuffer,
) -> CFRetained<CFDictionary> {
    extern "C-unwind" {
        fn CVPixelBufferCopyCreationAttributes(
            pixel_buffer: &CVPixelBuffer,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CVPixelBufferCopyCreationAttributes(pixel_buffer) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

/// Returns true if given pixel buffer is compatible with pixelBufferAttributes dictionary.
///
/// Parameter `pixelBuffer`: PixelBuffer to check for compatibility.
///
/// Parameter `attributes`: Creation attributes which pixel buffer should have.
///
/// # Safety
///
/// `attributes` generics must be of the correct type.
#[cfg(all(feature = "CVBuffer", feature = "CVImageBuffer"))]
#[inline]
pub unsafe extern "C-unwind" fn CVPixelBufferIsCompatibleWithAttributes(
    pixel_buffer: &CVPixelBuffer,
    attributes: Option<&CFDictionary>,
) -> bool {
    extern "C-unwind" {
        fn CVPixelBufferIsCompatibleWithAttributes(
            pixel_buffer: &CVPixelBuffer,
            attributes: Option<&CFDictionary>,
        ) -> Boolean;
    }
    let ret = unsafe { CVPixelBufferIsCompatibleWithAttributes(pixel_buffer, attributes) };
    ret != 0
}
