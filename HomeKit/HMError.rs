//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// A string that identifies the HomeKit error domain.
    pub static HMErrorDomain: &'static NSString;
}

/// Possible error values that can be returned from HomeKit APIs.
/// This enumeration describes the possible error constants that can be
/// returned from the the HomeKit APIs.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct HMErrorCode(pub NSInteger);
impl HMErrorCode {
    /// An unexpected error.
    #[doc(alias = "HMErrorCodeUnexpectedError")]
    pub const UnexpectedError: Self = Self(-1);
    /// An error indicating the container already contains the object you are trying to add.
    #[doc(alias = "HMErrorCodeAlreadyExists")]
    pub const AlreadyExists: Self = Self(1);
    /// An error indicating the object was not found in the container.
    #[doc(alias = "HMErrorCodeNotFound")]
    pub const NotFound: Self = Self(2);
    /// An error indicating the object is invalid for the given operation.
    ///
    /// ## Discussion
    ///
    /// For example, the home object issues an error when attempting to add a room that exists in another home.
    ///
    ///
    #[doc(alias = "HMErrorCodeInvalidParameter")]
    pub const InvalidParameter: Self = Self(3);
    /// An error indicating the accessory is not reachable over the network.
    #[doc(alias = "HMErrorCodeAccessoryNotReachable")]
    pub const AccessoryNotReachable: Self = Self(4);
    /// An attempt to modify a read-only value.
    #[doc(alias = "HMErrorCodeReadOnlyCharacteristic")]
    pub const ReadOnlyCharacteristic: Self = Self(5);
    /// An attempt to read from a write-only characteristic.
    #[doc(alias = "HMErrorCodeWriteOnlyCharacteristic")]
    pub const WriteOnlyCharacteristic: Self = Self(6);
    /// An attempt to register for notifications from an accessory that does not support notifications.
    #[doc(alias = "HMErrorCodeNotificationNotSupported")]
    pub const NotificationNotSupported: Self = Self(7);
    /// An error indicating the operation timed out.
    #[doc(alias = "HMErrorCodeOperationTimedOut")]
    pub const OperationTimedOut: Self = Self(8);
    /// An error indicating the accessory is off.
    #[doc(alias = "HMErrorCodeAccessoryPoweredOff")]
    pub const AccessoryPoweredOff: Self = Self(9);
    /// An error indicating the current user doesn’t have privileges to perform the operation.
    #[doc(alias = "HMErrorCodeAccessDenied")]
    pub const AccessDenied: Self = Self(10);
    /// An attempt to associate an object with a home when it’s already associated with another home.
    #[doc(alias = "HMErrorCodeObjectAssociatedToAnotherHome")]
    pub const ObjectAssociatedToAnotherHome: Self = Self(11);
    /// An attempt to perform an operation on an object that is not associated to any home.
    #[doc(alias = "HMErrorCodeObjectNotAssociatedToAnyHome")]
    pub const ObjectNotAssociatedToAnyHome: Self = Self(12);
    /// An attempt to associate an object with a home when it’s already associated with that home.
    #[doc(alias = "HMErrorCodeObjectAlreadyAssociatedToHome")]
    pub const ObjectAlreadyAssociatedToHome: Self = Self(13);
    /// An error indicating the accessory is busy.
    #[doc(alias = "HMErrorCodeAccessoryIsBusy")]
    pub const AccessoryIsBusy: Self = Self(14);
    /// An error indicating the operation is already in progress.
    #[doc(alias = "HMErrorCodeOperationInProgress")]
    pub const OperationInProgress: Self = Self(15);
    /// An error indicating the accessory is out of resources.
    #[doc(alias = "HMErrorCodeAccessoryOutOfResources")]
    pub const AccessoryOutOfResources: Self = Self(16);
    /// An error indicating insufficient privileges for the operation.
    #[doc(alias = "HMErrorCodeInsufficientPrivileges")]
    pub const InsufficientPrivileges: Self = Self(17);
    /// An attempt to pair with the accessory has failed.
    #[doc(alias = "HMErrorCodeAccessoryPairingFailed")]
    pub const AccessoryPairingFailed: Self = Self(18);
    /// An error indicating an invalid data format was specified.
    #[doc(alias = "HMErrorCodeInvalidDataFormatSpecified")]
    pub const InvalidDataFormatSpecified: Self = Self(19);
    /// An error indicating that `nil` was passed for an operation that does not accept `nil`.
    #[doc(alias = "HMErrorCodeNilParameter")]
    pub const NilParameter: Self = Self(20);
    /// An error indicating an unconfigured parameter.
    #[doc(alias = "HMErrorCodeUnconfiguredParameter")]
    pub const UnconfiguredParameter: Self = Self(21);
    /// An attempt to use an abstract base class in an operation instead of a concrete subclass.
    #[doc(alias = "HMErrorCodeInvalidClass")]
    pub const InvalidClass: Self = Self(22);
    /// An error indicating the user canceled the operation.
    #[doc(alias = "HMErrorCodeOperationCancelled")]
    pub const OperationCancelled: Self = Self(23);
    /// An attempt to add the room that represents the entire home to a zone.
    #[doc(alias = "HMErrorCodeRoomForHomeCannotBeInZone")]
    pub const RoomForHomeCannotBeInZone: Self = Self(24);
    /// An attempt to execute an action set with no actions.
    #[doc(alias = "HMErrorCodeNoActionsInActionSet")]
    pub const NoActionsInActionSet: Self = Self(25);
    /// An attempt to activate a trigger with no action sets.
    #[doc(alias = "HMErrorCodeNoRegisteredActionSets")]
    pub const NoRegisteredActionSets: Self = Self(26);
    /// An error indicating a missing parameter.
    #[doc(alias = "HMErrorCodeMissingParameter")]
    pub const MissingParameter: Self = Self(27);
    /// An attempt to activate a timer trigger with a date in the past.
    #[doc(alias = "HMErrorCodeFireDateInPast")]
    pub const FireDateInPast: Self = Self(28);
    /// An attempt to change the room that represents the entire home.
    #[doc(alias = "HMErrorCodeRoomForHomeCannotBeUpdated")]
    pub const RoomForHomeCannotBeUpdated: Self = Self(29);
    /// An attempt to add an action that exists in one action set to another action set.
    #[doc(alias = "HMErrorCodeActionInAnotherActionSet")]
    pub const ActionInAnotherActionSet: Self = Self(30);
    /// An attempt to give the name of one object to another object in the home.
    #[doc(alias = "HMErrorCodeObjectWithSimilarNameExistsInHome")]
    pub const ObjectWithSimilarNameExistsInHome: Self = Self(31);
    /// An attempt to assign a home the same name as an existing home.
    #[doc(alias = "HMErrorCodeHomeWithSimilarNameExists")]
    pub const HomeWithSimilarNameExists: Self = Self(32);
    /// An attempt to rename an object with its current name.
    #[doc(alias = "HMErrorCodeRenameWithSimilarName")]
    pub const RenameWithSimilarName: Self = Self(33);
    /// An attempt to remove a bridged accessory.
    ///
    /// ## Discussion
    ///
    /// You can only remove standalone or bridge accessories.
    ///
    ///
    #[doc(alias = "HMErrorCodeCannotRemoveNonBridgeAccessory")]
    pub const CannotRemoveNonBridgeAccessory: Self = Self(34);
    /// An attempt to name an object with prohibited characters.
    ///
    /// ## Discussion
    ///
    /// Only letters, symbols, numbers, spaces, and apostrophes are permitted in names.
    ///
    ///
    #[doc(alias = "HMErrorCodeNameContainsProhibitedCharacters")]
    pub const NameContainsProhibitedCharacters: Self = Self(35);
    /// An attempt to start the name of an object with invalid characters.
    ///
    /// ## Discussion
    ///
    /// Names must start with a letter, symbol, or number.
    ///
    ///
    #[doc(alias = "HMErrorCodeNameDoesNotStartWithValidCharacters")]
    pub const NameDoesNotStartWithValidCharacters: Self = Self(36);
    /// An error indicating the user’s ID is not a valid email address.
    #[doc(alias = "HMErrorCodeUserIDNotEmailAddress")]
    pub const UserIDNotEmailAddress: Self = Self(37);
    /// An error indicating the user canceled the add user operation.
    #[doc(alias = "HMErrorCodeUserDeclinedAddingUser")]
    pub const UserDeclinedAddingUser: Self = Self(38);
    /// An error indicating the user canceled the remove user operation.
    #[doc(alias = "HMErrorCodeUserDeclinedRemovingUser")]
    pub const UserDeclinedRemovingUser: Self = Self(39);
    /// An error indicating the user declined the invitation.
    #[doc(alias = "HMErrorCodeUserDeclinedInvite")]
    pub const UserDeclinedInvite: Self = Self(40);
    /// A user management error not covered by the other errors.
    #[doc(alias = "HMErrorCodeUserManagementFailed")]
    pub const UserManagementFailed: Self = Self(41);
    /// An error indicating the recurrence interval is too short.
    #[doc(alias = "HMErrorCodeRecurrenceTooSmall")]
    pub const RecurrenceTooSmall: Self = Self(42);
    /// An attempt to use an invalid value type.
    #[doc(alias = "HMErrorCodeInvalidValueType")]
    pub const InvalidValueType: Self = Self(43);
    /// An attempt to use a numeric value lower than the specified minimum value.
    #[doc(alias = "HMErrorCodeValueLowerThanMinimum")]
    pub const ValueLowerThanMinimum: Self = Self(44);
    /// An attempt to use a numeric value higher than the specified maximum value.
    #[doc(alias = "HMErrorCodeValueHigherThanMaximum")]
    pub const ValueHigherThanMaximum: Self = Self(45);
    /// An attempt to use a string longer than the maximum allowed.
    #[doc(alias = "HMErrorCodeStringLongerThanMaximum")]
    pub const StringLongerThanMaximum: Self = Self(46);
    /// An error indicating access to the home was not authorized.
    #[doc(alias = "HMErrorCodeHomeAccessNotAuthorized")]
    pub const HomeAccessNotAuthorized: Self = Self(47);
    /// An attempt to use an unsupported operation.
    #[doc(alias = "HMErrorCodeOperationNotSupported")]
    pub const OperationNotSupported: Self = Self(48);
    /// An error indicating the maximum object count has been reached.
    #[doc(alias = "HMErrorCodeMaximumObjectLimitReached")]
    pub const MaximumObjectLimitReached: Self = Self(49);
    /// An error indicating the accessory sent an invalid response.
    #[doc(alias = "HMErrorCodeAccessorySentInvalidResponse")]
    pub const AccessorySentInvalidResponse: Self = Self(50);
    /// An attempt to use a string shorter than the required minimum.
    #[doc(alias = "HMErrorCodeStringShorterThanMinimum")]
    pub const StringShorterThanMinimum: Self = Self(51);
    /// An error that does not have a more specific error code.
    #[doc(alias = "HMErrorCodeGenericError")]
    pub const GenericError: Self = Self(52);
    /// A security failure.
    #[doc(alias = "HMErrorCodeSecurityFailure")]
    pub const SecurityFailure: Self = Self(53);
    /// A communication failure.
    #[doc(alias = "HMErrorCodeCommunicationFailure")]
    pub const CommunicationFailure: Self = Self(54);
    /// A message authentication failure.
    #[doc(alias = "HMErrorCodeMessageAuthenticationFailed")]
    pub const MessageAuthenticationFailed: Self = Self(55);
    /// An error indicating an invalid message size.
    #[doc(alias = "HMErrorCodeInvalidMessageSize")]
    pub const InvalidMessageSize: Self = Self(56);
    /// An error indicating accessory discovery failed.
    #[doc(alias = "HMErrorCodeAccessoryDiscoveryFailed")]
    pub const AccessoryDiscoveryFailed: Self = Self(57);
    /// An error with the client request.
    #[doc(alias = "HMErrorCodeClientRequestError")]
    pub const ClientRequestError: Self = Self(58);
    /// An error with the accessory’s response.
    #[doc(alias = "HMErrorCodeAccessoryResponseError")]
    pub const AccessoryResponseError: Self = Self(59);
    /// An error indicating the provided name has invalid characters at the end.
    #[doc(alias = "HMErrorCodeNameDoesNotEndWithValidCharacters")]
    pub const NameDoesNotEndWithValidCharacters: Self = Self(60);
    /// An error indicating a blocked accessory.
    #[doc(alias = "HMErrorCodeAccessoryIsBlocked")]
    pub const AccessoryIsBlocked: Self = Self(61);
    /// An error indicating an invalid service type.
    #[doc(alias = "HMErrorCodeInvalidAssociatedServiceType")]
    pub const InvalidAssociatedServiceType: Self = Self(62);
    /// An attempt to execute the action set failed.
    #[doc(alias = "HMErrorCodeActionSetExecutionFailed")]
    pub const ActionSetExecutionFailed: Self = Self(63);
    /// An attempt to execute the action set was only partially successful.
    #[doc(alias = "HMErrorCodeActionSetExecutionPartialSuccess")]
    pub const ActionSetExecutionPartialSuccess: Self = Self(64);
    /// An error indicating the execution of the action set is in progress.
    #[doc(alias = "HMErrorCodeActionSetExecutionInProgress")]
    pub const ActionSetExecutionInProgress: Self = Self(65);
    /// An error indicating the accessory is out of compliance.
    #[doc(alias = "HMErrorCodeAccessoryOutOfCompliance")]
    pub const AccessoryOutOfCompliance: Self = Self(66);
    /// An attempt to reset the data failed.
    #[doc(alias = "HMErrorCodeDataResetFailure")]
    pub const DataResetFailure: Self = Self(67);
    /// An error indicating the notification is already enabled.
    #[doc(alias = "HMErrorCodeNotificationAlreadyEnabled")]
    pub const NotificationAlreadyEnabled: Self = Self(68);
    /// An error indicating the recurrence rule is not on the specified boundaries.
    #[doc(alias = "HMErrorCodeRecurrenceMustBeOnSpecifiedBoundaries")]
    pub const RecurrenceMustBeOnSpecifiedBoundaries: Self = Self(69);
    /// An error indicating the date is not on the specified boundaries.
    #[doc(alias = "HMErrorCodeDateMustBeOnSpecifiedBoundaries")]
    pub const DateMustBeOnSpecifiedBoundaries: Self = Self(70);
    /// An error indicating the trigger cannot be activated because it is set too far in the future.
    #[doc(alias = "HMErrorCodeCannotActivateTriggerTooFarInFuture")]
    pub const CannotActivateTriggerTooFarInFuture: Self = Self(71);
    /// An attempt to use a recurrence period that is too large.
    #[doc(alias = "HMErrorCodeRecurrenceTooLarge")]
    pub const RecurrenceTooLarge: Self = Self(72);
    /// An error indicating a partially successful read/write operation.
    #[doc(alias = "HMErrorCodeReadWritePartialSuccess")]
    pub const ReadWritePartialSuccess: Self = Self(73);
    /// An error indicating a failed read/write operation.
    #[doc(alias = "HMErrorCodeReadWriteFailure")]
    pub const ReadWriteFailure: Self = Self(74);
    /// An error indicating the user is not signed into iCloud.
    #[doc(alias = "HMErrorCodeNotSignedIntoiCloud")]
    pub const NotSignedIntoiCloud: Self = Self(75);
    /// An error indicating Keychain syncing is not enabled for the user.
    #[doc(alias = "HMErrorCodeKeychainSyncNotEnabled")]
    pub const KeychainSyncNotEnabled: Self = Self(76);
    /// An error indicating a data synchronization operation is in progress.
    #[doc(alias = "HMErrorCodeCloudDataSyncInProgress")]
    pub const CloudDataSyncInProgress: Self = Self(77);
    /// An error indicating the network is unavailable.
    #[doc(alias = "HMErrorCodeNetworkUnavailable")]
    pub const NetworkUnavailable: Self = Self(78);
    /// A failed attempt to add an accessory.
    #[doc(alias = "HMErrorCodeAddAccessoryFailed")]
    pub const AddAccessoryFailed: Self = Self(79);
    /// An error indicating a required entitlement is not available.
    #[doc(alias = "HMErrorCodeMissingEntitlement")]
    pub const MissingEntitlement: Self = Self(80);
    /// An error indicating a non-bridge accessory cannot be unblocked.
    #[doc(alias = "HMErrorCodeCannotUnblockNonBridgeAccessory")]
    pub const CannotUnblockNonBridgeAccessory: Self = Self(81);
    /// An error indicating the device is locked.
    #[doc(alias = "HMErrorCodeDeviceLocked")]
    pub const DeviceLocked: Self = Self(82);
    /// An error indicating the built-in action set cannot be removed.
    #[doc(alias = "HMErrorCodeCannotRemoveBuiltinActionSet")]
    pub const CannotRemoveBuiltinActionSet: Self = Self(83);
    /// An error indicating the home’s location is disabled.
    #[doc(alias = "HMErrorCodeLocationForHomeDisabled")]
    pub const LocationForHomeDisabled: Self = Self(84);
    /// An error indicating location services are not authorized.
    #[doc(alias = "HMErrorCodeNotAuthorizedForLocationServices")]
    pub const NotAuthorizedForLocationServices: Self = Self(85);
    /// An error described in the device’s user manual.
    #[doc(alias = "HMErrorCodeReferToUserManual")]
    pub const ReferToUserManual: Self = Self(86);
    /// An error indicating the authorization data is invalid or missing.
    #[doc(alias = "HMErrorCodeInvalidOrMissingAuthorizationData")]
    pub const InvalidOrMissingAuthorizationData: Self = Self(87);
    /// An error indicating the bridged accessory cannot be reached.
    #[doc(alias = "HMErrorCodeBridgedAccessoryNotReachable")]
    pub const BridgedAccessoryNotReachable: Self = Self(88);
    /// An error indicating microphone access is not authorized.
    #[doc(alias = "HMErrorCodeNotAuthorizedForMicrophoneAccess")]
    pub const NotAuthorizedForMicrophoneAccess: Self = Self(89);
    /// An error indicating an incompatible network.
    #[doc(alias = "HMErrorCodeIncompatibleNetwork")]
    pub const IncompatibleNetwork: Self = Self(90);
    /// An error indicating no home hub found.
    #[doc(alias = "HMErrorCodeNoHomeHub")]
    pub const NoHomeHub: Self = Self(91);
    /// An error indicating no compatible home hub found.
    #[doc(alias = "HMErrorCodeNoCompatibleHomeHub")]
    pub const NoCompatibleHomeHub: Self = Self(92);
    /// The accessory is incompatible.
    #[doc(alias = "HMErrorCodeIncompatibleAccessory")]
    pub const IncompatibleAccessory: Self = Self(93);
    /// An error indicating an incompatible home hub.
    #[doc(alias = "HMErrorCodeIncompatibleHomeHub")]
    #[deprecated]
    pub const IncompatibleHomeHub: Self = Self(HMErrorCode::NoCompatibleHomeHub.0);
    /// An object with a similar name already exists.
    #[doc(alias = "HMErrorCodeObjectWithSimilarNameExists")]
    pub const ObjectWithSimilarNameExists: Self = Self(95);
    /// The ownership code did not match.
    #[doc(alias = "HMErrorCodeOwnershipFailure")]
    pub const OwnershipFailure: Self = Self(96);
    /// The home already has the maximum number of accessories of the given type.
    #[doc(alias = "HMErrorCodeMaximumAccessoriesOfTypeInHome")]
    pub const MaximumAccessoriesOfTypeInHome: Self = Self(97);
    /// WiFi credential generation failed.
    #[doc(alias = "HMErrorCodeWiFiCredentialGenerationFailed")]
    pub const WiFiCredentialGenerationFailed: Self = Self(98);
    /// An enterprise network doesn’t support this accessory.
    #[doc(alias = "HMErrorCodeEnterpriseNetworkNotSupported")]
    pub const EnterpriseNetworkNotSupported: Self = Self(99);
    /// An accessory did not respond timely.
    #[doc(alias = "HMErrorCodeTimedOutWaitingForAccessory")]
    pub const TimedOutWaitingForAccessory: Self = Self(100);
    /// The accessory failed to communicate.
    #[doc(alias = "HMErrorCodeAccessoryCommunicationFailure")]
    pub const AccessoryCommunicationFailure: Self = Self(101);
    /// The accessory failed to join the network.
    #[doc(alias = "HMErrorCodeFailedToJoinNetwork")]
    pub const FailedToJoinNetwork: Self = Self(102);
    /// The accessory is suspended.
    #[doc(alias = "HMErrorCodeAccessoryIsSuspended")]
    pub const AccessoryIsSuspended: Self = Self(103);
    #[doc(alias = "HMErrorCodePartialCommunicationFailure")]
    pub const PartialCommunicationFailure: Self = Self(104);
    #[doc(alias = "HMErrorCodeHomeUpgradeRequired")]
    pub const HomeUpgradeRequired: Self = Self(105);
    #[doc(alias = "HMErrorCodeQuotaExceeded")]
    pub const QuotaExceeded: Self = Self(106);
}

unsafe impl Encode for HMErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for HMErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}
