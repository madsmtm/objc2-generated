//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// Constants for specifying how a cell represents its data (as text or as an image).
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSCellType(pub NSUInteger);
impl NSCellType {
    /// Cell displays nothing.
    #[doc(alias = "NSNullCellType")]
    pub const NullCellType: Self = Self(0);
    /// Cell displays text.
    #[doc(alias = "NSTextCellType")]
    pub const TextCellType: Self = Self(1);
    /// Cell displays images.
    #[doc(alias = "NSImageCellType")]
    pub const ImageCellType: Self = Self(2);
}

unsafe impl Encode for NSCellType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSCellType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants for specifying how a button behaves when pressed and how it displays its state.
///
/// ## Overview
///
/// These constants are used by the [`NSButton`](https://developer.apple.com/documentation/appkit/nsbutton) and [`NSButtonCell`](https://developer.apple.com/documentation/appkit/nsbuttoncell) classes.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSCellAttribute(pub NSUInteger);
impl NSCellAttribute {
    /// Does not let the user manipulate the cell.
    #[doc(alias = "NSCellDisabled")]
    pub const CellDisabled: Self = Self(0);
    /// The cell’s state.
    ///
    /// ## Discussion
    ///
    /// The cell’s state can be [`NSMixedState`](https://developer.apple.com/documentation/appkit/nsmixedstate), [`NSOffState`](https://developer.apple.com/documentation/appkit/nsoffstate), or [`NSOnState`](https://developer.apple.com/documentation/appkit/nsonstate).
    ///
    ///
    #[doc(alias = "NSCellState")]
    pub const CellState: Self = Self(1);
    /// Determines whether the cell’s image and text appear to be shifted down and to the right.
    #[doc(alias = "NSPushInCell")]
    pub const PushInCell: Self = Self(2);
    /// Lets the user edit the cell’s contents.
    #[doc(alias = "NSCellEditable")]
    pub const CellEditable: Self = Self(3);
    /// If the cell’s state is `NSMixedState` or `NSOnState`, displays the cell’s image as darkened.
    #[doc(alias = "NSChangeGrayCell")]
    pub const ChangeGrayCell: Self = Self(4);
    /// Draws the cell with a highlighted appearance.
    #[doc(alias = "NSCellHighlighted")]
    pub const CellHighlighted: Self = Self(5);
    /// If the cell is pushed in, displays the cell’s alternate image.
    #[doc(alias = "NSCellLightsByContents")]
    pub const CellLightsByContents: Self = Self(6);
    /// If the cell is pushed in, displays the cell’s image as darkened.
    #[doc(alias = "NSCellLightsByGray")]
    pub const CellLightsByGray: Self = Self(7);
    /// If the cell’s state is `NSMixedState` or `NSOnState`, changes the cell’s background color from gray to white.
    #[doc(alias = "NSChangeBackgroundCell")]
    pub const ChangeBackgroundCell: Self = Self(8);
    /// If the cell is pushed in, changes the cell’s background color from gray to white.
    #[doc(alias = "NSCellLightsByBackground")]
    pub const CellLightsByBackground: Self = Self(9);
    /// Draws a border around the cell.
    #[doc(alias = "NSCellIsBordered")]
    pub const CellIsBordered: Self = Self(10);
    /// Controls the position of the cell’s image: places the image over any text in the cell.
    ///
    /// ## Discussion
    ///
    /// See [`NSCellHasImageHorizontal`](https://developer.apple.com/documentation/appkit/nscell/attribute/cellhasimagehorizontal) for more details.
    ///
    ///
    #[doc(alias = "NSCellHasOverlappingImage")]
    pub const CellHasOverlappingImage: Self = Self(11);
    /// Controls the position of the cell’s image: places the image on the right of any text in the cell.
    ///
    /// ## Discussion
    ///
    /// Together, `NSCellHasImageOnLeftOrBottom`, `NSCellHasImageHorizontal`, and `NSCellHasOverlappingImage` control the position of the cell’s image and text. To place the image above, set none of them. To place the image below, set `NSCellHasImageOnLeftOrBottom`. To place the image to the right, set `NSCellHasImageHorizontal`. To place the image to the left, set `NSCellHasImageHorizontal` and `NSCellHasImageOnLeftOrBottom`. To place the image directly over, set `NSCellHasOverlappingImage`.
    ///
    ///
    #[doc(alias = "NSCellHasImageHorizontal")]
    pub const CellHasImageHorizontal: Self = Self(12);
    /// Controls the position of the cell’s image: places the image on the left of or below any text in the cell.
    ///
    /// ## Discussion
    ///
    /// See [`NSCellHasImageHorizontal`](https://developer.apple.com/documentation/appkit/nscell/attribute/cellhasimagehorizontal) for more details.
    ///
    ///
    #[doc(alias = "NSCellHasImageOnLeftOrBottom")]
    pub const CellHasImageOnLeftOrBottom: Self = Self(13);
    /// If the cell’s state is `NSMixedState` or `NSOnState`, displays the cell’s alternate image.
    #[doc(alias = "NSCellChangesContents")]
    pub const CellChangesContents: Self = Self(14);
    /// Insets the cell’s contents from the border.
    ///
    /// ## Discussion
    ///
    /// By default, the cell’s contents are inset by 2 points. This constant is ignored if the cell has no border.
    ///
    ///
    #[doc(alias = "NSCellIsInsetButton")]
    pub const CellIsInsetButton: Self = Self(15);
    /// Lets the cell’s state be `NSMixedState`, as well as `NSOffState` and `NSOnState`.
    #[doc(alias = "NSCellAllowsMixedState")]
    pub const CellAllowsMixedState: Self = Self(16);
}

unsafe impl Encode for NSCellAttribute {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSCellAttribute {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A constant for specifying the position of a button’s image relative to its title.
///
/// ## Overview
///
/// Use these constants with the [`imagePosition`](https://developer.apple.com/documentation/appkit/nsbutton/imageposition) property of [`NSButton`](https://developer.apple.com/documentation/appkit/nsbutton) and [`NSButtonCell`](https://developer.apple.com/documentation/appkit/nsbuttoncell).
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSCellImagePosition(pub NSUInteger);
impl NSCellImagePosition {
    /// The cell doesn’t display an image.
    #[doc(alias = "NSNoImage")]
    pub const NoImage: Self = Self(0);
    /// The cell displays an image but not a title.
    #[doc(alias = "NSImageOnly")]
    pub const ImageOnly: Self = Self(1);
    /// The image is to the left of the title.
    #[doc(alias = "NSImageLeft")]
    pub const ImageLeft: Self = Self(2);
    /// The image is to the right of the title.
    #[doc(alias = "NSImageRight")]
    pub const ImageRight: Self = Self(3);
    /// The image is below the title.
    #[doc(alias = "NSImageBelow")]
    pub const ImageBelow: Self = Self(4);
    /// The image is above the title.
    #[doc(alias = "NSImageAbove")]
    pub const ImageAbove: Self = Self(5);
    /// The image overlaps the title.
    #[doc(alias = "NSImageOverlaps")]
    pub const ImageOverlaps: Self = Self(6);
    /// The image is on the title’s leading edge.
    #[doc(alias = "NSImageLeading")]
    pub const ImageLeading: Self = Self(7);
    /// The image is on the title’s trailing edge.
    #[doc(alias = "NSImageTrailing")]
    pub const ImageTrailing: Self = Self(8);
}

unsafe impl Encode for NSCellImagePosition {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSCellImagePosition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that specify a cell’s image scaling behavior.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSImageScaling(pub NSUInteger);
impl NSImageScaling {
    /// If it is too large for the destination, scale the image down while preserving the aspect ratio.
    #[doc(alias = "NSImageScaleProportionallyDown")]
    pub const ScaleProportionallyDown: Self = Self(0);
    /// Scale each dimension to exactly fit destination.
    ///
    /// ## Discussion
    ///
    /// This setting does not preserve the aspect ratio of the image.
    ///
    ///
    #[doc(alias = "NSImageScaleAxesIndependently")]
    pub const ScaleAxesIndependently: Self = Self(1);
    /// Do not scale the image.
    #[doc(alias = "NSImageScaleNone")]
    pub const ScaleNone: Self = Self(2);
    /// Scale the image to its maximum possible dimensions while both staying within the destination area and preserving its aspect ratio.
    #[doc(alias = "NSImageScaleProportionallyUpOrDown")]
    pub const ScaleProportionallyUpOrDown: Self = Self(3);
    ///
    /// ## Discussion
    ///
    /// Use [`NSImageScaleProportionallyDown`](https://developer.apple.com/documentation/appkit/nsimagescaling/scaleproportionallydown).
    ///
    ///
    #[deprecated = "Use NSImageScaleProportionallyDown instead"]
    pub const NSScaleProportionally: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// Use [`NSImageScaleAxesIndependently`](https://developer.apple.com/documentation/appkit/nsimagescaling/scaleaxesindependently).
    ///
    ///
    #[deprecated = "Use NSImageScaleAxesIndependently instead"]
    pub const NSScaleToFit: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// Use [`NSImageScaleNone`](https://developer.apple.com/documentation/appkit/nsimagescaling/scalenone).
    ///
    ///
    #[deprecated = "Use NSImageScaleNone instead"]
    pub const NSScaleNone: Self = Self(2);
}

unsafe impl Encode for NSImageScaling {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSImageScaling {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A constant that indicates whether a control is on, off, or in a mixed state.
// NS_TYPED_EXTENSIBLE_ENUM
pub type NSControlStateValue = NSInteger;

/// A constant value that indicates a control is in a mixed state, neither on nor off.
///
/// ## Discussion
///
/// For example, if a checkbox displays the state of more than one selected row in a table and the items have different states, then the checkbox’s state is mixed.
///
///
pub static NSControlStateValueMixed: NSControlStateValue = -1;

/// A constant value that indicates a control is off or unselected.
pub static NSControlStateValueOff: NSControlStateValue = 0;

/// A constant value that indicates a control is on or selected.
pub static NSControlStateValueOn: NSControlStateValue = 1;

/// Constants for specifying what happens when a button is pressed or is displaying its alternate state.
///
/// ## Overview
///
/// These contents are used by the [`highlightsBy`](https://developer.apple.com/documentation/appkit/nsbuttoncell/highlightsby) and [`showsStateBy`](https://developer.apple.com/documentation/appkit/nsbuttoncell/showsstateby) methods of [`NSButtonCell`](https://developer.apple.com/documentation/appkit/nsbuttoncell).
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSCellStyleMask(pub NSUInteger);
bitflags::bitflags! {
    impl NSCellStyleMask: NSUInteger {
/// The button cell doesn’t change.
        #[doc(alias = "NSNoCellMask")]
        const NoCellMask = 0;
/// The button cell displays its alternate icon and/or title.
        #[doc(alias = "NSContentsCellMask")]
        const ContentsCellMask = 1;
/// The button cell “pushes in” if it has a border.
        #[doc(alias = "NSPushInCellMask")]
        const PushInCellMask = 2;
/// The button cell swaps the “control color” (the [`controlColor`](https://developer.apple.com/documentation/appkit/nscolor/controlcolor) method of `NSColor`) and white pixels on its background and icon.
        #[doc(alias = "NSChangeGrayCellMask")]
        const ChangeGrayCellMask = 4;
/// Same as `NSChangeGrayCellMask`, but only background pixels are changed.
        #[doc(alias = "NSChangeBackgroundCellMask")]
        const ChangeBackgroundCellMask = 8;
    }
}

unsafe impl Encode for NSCellStyleMask {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSCellStyleMask {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants for specifying a cell’s tint color.
///
/// ## Overview
///
/// These constants are used by the [`controlTint`](https://developer.apple.com/documentation/appkit/nscell/controltint) property.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSControlTint(pub NSUInteger);
impl NSControlTint {
    /// The current default tint setting.
    #[doc(alias = "NSDefaultControlTint")]
    pub const DefaultControlTint: Self = Self(0);
    /// Aqua control tint.
    #[doc(alias = "NSBlueControlTint")]
    pub const BlueControlTint: Self = Self(1);
    /// Graphite control tint.
    #[doc(alias = "NSGraphiteControlTint")]
    pub const GraphiteControlTint: Self = Self(6);
    /// Clear control tint.
    #[doc(alias = "NSClearControlTint")]
    pub const ClearControlTint: Self = Self(7);
}

unsafe impl Encode for NSControlTint {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSControlTint {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A constant for specifying a cell’s size.
///
/// ## Overview
///
/// These constants are used by the [`controlSize`](https://developer.apple.com/documentation/appkit/nscell/controlsize) property.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSControlSize(pub NSUInteger);
impl NSControlSize {
    /// The default control size.
    #[doc(alias = "NSControlSizeRegular")]
    pub const Regular: Self = Self(0);
    /// A size smaller than the default control size.
    ///
    /// ## Discussion
    ///
    /// This constant is for controls that can’t be resized in one direction, such as push buttons, radio buttons, checkboxes, sliders, scroll bars, pop-up buttons, tabs, and progress indicators. Use a small system font with a small control.
    ///
    ///
    #[doc(alias = "NSControlSizeSmall")]
    pub const Small: Self = Self(1);
    /// The smallest control size.
    #[doc(alias = "NSControlSizeMini")]
    pub const Mini: Self = Self(2);
    /// A size larger than the default control size.
    #[doc(alias = "NSControlSizeLarge")]
    pub const Large: Self = Self(3);
    #[doc(alias = "NSControlSizeExtraLarge")]
    pub const ExtraLarge: Self = Self(4);
}

unsafe impl Encode for NSControlSize {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSControlSize {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A mechanism for displaying text or images in a view object without the overhead of a full [`NSView`](https://developer.apple.com/documentation/appkit/nsview) subclass.
    ///
    /// ## Overview
    ///
    /// Cells are used by most of the [`NSControl`](https://developer.apple.com/documentation/appkit/nscontrol) classes to implement their internal workings.
    ///
    /// ### Designated Initializers
    ///
    /// When subclassing `NSCell` you must implement all of the designated initializers. Those methods include [`init`](https://developer.apple.com/documentation/appkit/nscell/init()), [`initWithCoder:`](https://developer.apple.com/documentation/appkit/nscell/init(coder:)), [`initTextCell:`](https://developer.apple.com/documentation/appkit/nscell/init(textcell:)), and [`initImageCell:`](https://developer.apple.com/documentation/appkit/nscell/init(imagecell:)).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCell;
);

#[cfg(feature = "NSAccessibilityProtocols")]
extern_conformance!(
    unsafe impl NSAccessibility for NSCell {}
);

#[cfg(feature = "NSAccessibilityProtocols")]
extern_conformance!(
    unsafe impl NSAccessibilityElementProtocol for NSCell {}
);

extern_conformance!(
    unsafe impl NSCoding for NSCell {}
);

extern_conformance!(
    unsafe impl NSCopying for NSCell {}
);

unsafe impl CopyingHelper for NSCell {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCell {}
);

#[cfg(feature = "NSUserInterfaceItemIdentification")]
extern_conformance!(
    unsafe impl NSUserInterfaceItemIdentification for NSCell {}
);

impl NSCell {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initTextCell:))]
        #[unsafe(method_family = init)]
        pub fn initTextCell(this: Allocated<Self>, string: &NSString) -> Retained<Self>;

        #[cfg(feature = "NSImage")]
        #[unsafe(method(initImageCell:))]
        #[unsafe(method_family = init)]
        pub fn initImageCell(this: Allocated<Self>, image: Option<&NSImage>) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(this: Allocated<Self>, coder: &NSCoder) -> Retained<Self>;

        #[unsafe(method(prefersTrackingUntilMouseUp))]
        #[unsafe(method_family = none)]
        pub fn prefersTrackingUntilMouseUp(mtm: MainThreadMarker) -> bool;

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(controlView))]
        #[unsafe(method_family = none)]
        pub unsafe fn controlView(&self) -> Option<Retained<NSView>>;

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        /// Setter for [`controlView`][Self::controlView].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setControlView:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setControlView(&self, control_view: Option<&NSView>);

        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        pub fn r#type(&self) -> NSCellType;

        /// Setter for [`type`][Self::type].
        #[unsafe(method(setType:))]
        #[unsafe(method_family = none)]
        pub fn setType(&self, r#type: NSCellType);

        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub fn state(&self) -> NSControlStateValue;

        /// Setter for [`state`][Self::state].
        #[unsafe(method(setState:))]
        #[unsafe(method_family = none)]
        pub fn setState(&self, state: NSControlStateValue);

        #[unsafe(method(target))]
        #[unsafe(method_family = none)]
        pub fn target(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`target`][Self::target].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        ///
        /// # Safety
        ///
        /// `target` should be of the correct type.
        #[unsafe(method(setTarget:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTarget(&self, target: Option<&AnyObject>);

        #[unsafe(method(action))]
        #[unsafe(method_family = none)]
        pub fn action(&self) -> Option<Sel>;

        /// Setter for [`action`][Self::action].
        ///
        /// # Safety
        ///
        /// `action` must be a valid selector.
        #[unsafe(method(setAction:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAction(&self, action: Option<Sel>);

        #[unsafe(method(tag))]
        #[unsafe(method_family = none)]
        pub fn tag(&self) -> NSInteger;

        /// Setter for [`tag`][Self::tag].
        #[unsafe(method(setTag:))]
        #[unsafe(method_family = none)]
        pub fn setTag(&self, tag: NSInteger);

        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub fn title(&self) -> Retained<NSString>;

        /// Setter for [`title`][Self::title].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTitle:))]
        #[unsafe(method_family = none)]
        pub fn setTitle(&self, title: &NSString);

        #[unsafe(method(isOpaque))]
        #[unsafe(method_family = none)]
        pub fn isOpaque(&self) -> bool;

        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setEnabled(&self, enabled: bool);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(sendActionOn:))]
        #[unsafe(method_family = none)]
        pub fn sendActionOn(&self, mask: NSEventMask) -> NSInteger;

        #[unsafe(method(isContinuous))]
        #[unsafe(method_family = none)]
        pub fn isContinuous(&self) -> bool;

        /// Setter for [`isContinuous`][Self::isContinuous].
        #[unsafe(method(setContinuous:))]
        #[unsafe(method_family = none)]
        pub fn setContinuous(&self, continuous: bool);

        #[unsafe(method(isEditable))]
        #[unsafe(method_family = none)]
        pub fn isEditable(&self) -> bool;

        /// Setter for [`isEditable`][Self::isEditable].
        #[unsafe(method(setEditable:))]
        #[unsafe(method_family = none)]
        pub fn setEditable(&self, editable: bool);

        #[unsafe(method(isSelectable))]
        #[unsafe(method_family = none)]
        pub fn isSelectable(&self) -> bool;

        /// Setter for [`isSelectable`][Self::isSelectable].
        #[unsafe(method(setSelectable:))]
        #[unsafe(method_family = none)]
        pub fn setSelectable(&self, selectable: bool);

        #[unsafe(method(isBordered))]
        #[unsafe(method_family = none)]
        pub fn isBordered(&self) -> bool;

        /// Setter for [`isBordered`][Self::isBordered].
        #[unsafe(method(setBordered:))]
        #[unsafe(method_family = none)]
        pub fn setBordered(&self, bordered: bool);

        #[unsafe(method(isBezeled))]
        #[unsafe(method_family = none)]
        pub fn isBezeled(&self) -> bool;

        /// Setter for [`isBezeled`][Self::isBezeled].
        #[unsafe(method(setBezeled:))]
        #[unsafe(method_family = none)]
        pub fn setBezeled(&self, bezeled: bool);

        #[unsafe(method(isScrollable))]
        #[unsafe(method_family = none)]
        pub fn isScrollable(&self) -> bool;

        /// Setter for [`isScrollable`][Self::isScrollable].
        #[unsafe(method(setScrollable:))]
        #[unsafe(method_family = none)]
        pub fn setScrollable(&self, scrollable: bool);

        #[unsafe(method(isHighlighted))]
        #[unsafe(method_family = none)]
        pub fn isHighlighted(&self) -> bool;

        /// Setter for [`isHighlighted`][Self::isHighlighted].
        #[unsafe(method(setHighlighted:))]
        #[unsafe(method_family = none)]
        pub fn setHighlighted(&self, highlighted: bool);

        #[cfg(feature = "NSText")]
        #[unsafe(method(alignment))]
        #[unsafe(method_family = none)]
        pub fn alignment(&self) -> NSTextAlignment;

        #[cfg(feature = "NSText")]
        /// Setter for [`alignment`][Self::alignment].
        #[unsafe(method(setAlignment:))]
        #[unsafe(method_family = none)]
        pub fn setAlignment(&self, alignment: NSTextAlignment);

        #[unsafe(method(wraps))]
        #[unsafe(method_family = none)]
        pub fn wraps(&self) -> bool;

        /// Setter for [`wraps`][Self::wraps].
        #[unsafe(method(setWraps:))]
        #[unsafe(method_family = none)]
        pub fn setWraps(&self, wraps: bool);

        #[cfg(feature = "NSFont")]
        #[unsafe(method(font))]
        #[unsafe(method_family = none)]
        pub fn font(&self) -> Option<Retained<NSFont>>;

        #[cfg(feature = "NSFont")]
        /// Setter for [`font`][Self::font].
        #[unsafe(method(setFont:))]
        #[unsafe(method_family = none)]
        pub fn setFont(&self, font: Option<&NSFont>);

        #[unsafe(method(keyEquivalent))]
        #[unsafe(method_family = none)]
        pub fn keyEquivalent(&self) -> Retained<NSString>;

        #[unsafe(method(formatter))]
        #[unsafe(method_family = none)]
        pub fn formatter(&self) -> Option<Retained<NSFormatter>>;

        /// Setter for [`formatter`][Self::formatter].
        #[unsafe(method(setFormatter:))]
        #[unsafe(method_family = none)]
        pub fn setFormatter(&self, formatter: Option<&NSFormatter>);

        #[unsafe(method(objectValue))]
        #[unsafe(method_family = none)]
        pub fn objectValue(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`objectValue`][Self::objectValue].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `object_value` should be of the correct type.
        #[unsafe(method(setObjectValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setObjectValue(&self, object_value: Option<&AnyObject>);

        #[unsafe(method(hasValidObjectValue))]
        #[unsafe(method_family = none)]
        pub fn hasValidObjectValue(&self) -> bool;

        #[unsafe(method(stringValue))]
        #[unsafe(method_family = none)]
        pub fn stringValue(&self) -> Retained<NSString>;

        /// Setter for [`stringValue`][Self::stringValue].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setStringValue:))]
        #[unsafe(method_family = none)]
        pub fn setStringValue(&self, string_value: &NSString);

        /// # Safety
        ///
        /// `other_cell` should be of the correct type.
        #[unsafe(method(compare:))]
        #[unsafe(method_family = none)]
        pub unsafe fn compare(&self, other_cell: &AnyObject) -> NSComparisonResult;

        #[unsafe(method(intValue))]
        #[unsafe(method_family = none)]
        pub fn intValue(&self) -> c_int;

        /// Setter for [`intValue`][Self::intValue].
        #[unsafe(method(setIntValue:))]
        #[unsafe(method_family = none)]
        pub fn setIntValue(&self, int_value: c_int);

        #[unsafe(method(floatValue))]
        #[unsafe(method_family = none)]
        pub fn floatValue(&self) -> c_float;

        /// Setter for [`floatValue`][Self::floatValue].
        #[unsafe(method(setFloatValue:))]
        #[unsafe(method_family = none)]
        pub fn setFloatValue(&self, float_value: c_float);

        #[unsafe(method(doubleValue))]
        #[unsafe(method_family = none)]
        pub fn doubleValue(&self) -> c_double;

        /// Setter for [`doubleValue`][Self::doubleValue].
        #[unsafe(method(setDoubleValue:))]
        #[unsafe(method_family = none)]
        pub fn setDoubleValue(&self, double_value: c_double);

        #[unsafe(method(integerValue))]
        #[unsafe(method_family = none)]
        pub fn integerValue(&self) -> NSInteger;

        /// Setter for [`integerValue`][Self::integerValue].
        #[unsafe(method(setIntegerValue:))]
        #[unsafe(method_family = none)]
        pub fn setIntegerValue(&self, integer_value: NSInteger);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(takeIntValueFrom:))]
        #[unsafe(method_family = none)]
        pub unsafe fn takeIntValueFrom(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(takeFloatValueFrom:))]
        #[unsafe(method_family = none)]
        pub unsafe fn takeFloatValueFrom(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(takeDoubleValueFrom:))]
        #[unsafe(method_family = none)]
        pub unsafe fn takeDoubleValueFrom(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(takeStringValueFrom:))]
        #[unsafe(method_family = none)]
        pub unsafe fn takeStringValueFrom(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(takeObjectValueFrom:))]
        #[unsafe(method_family = none)]
        pub unsafe fn takeObjectValueFrom(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(takeIntegerValueFrom:))]
        #[unsafe(method_family = none)]
        pub unsafe fn takeIntegerValueFrom(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "NSImage")]
        #[unsafe(method(image))]
        #[unsafe(method_family = none)]
        pub fn image(&self) -> Option<Retained<NSImage>>;

        #[cfg(feature = "NSImage")]
        /// Setter for [`image`][Self::image].
        #[unsafe(method(setImage:))]
        #[unsafe(method_family = none)]
        pub fn setImage(&self, image: Option<&NSImage>);

        #[unsafe(method(controlSize))]
        #[unsafe(method_family = none)]
        pub fn controlSize(&self) -> NSControlSize;

        /// Setter for [`controlSize`][Self::controlSize].
        #[unsafe(method(setControlSize:))]
        #[unsafe(method_family = none)]
        pub fn setControlSize(&self, control_size: NSControlSize);

        #[unsafe(method(representedObject))]
        #[unsafe(method_family = none)]
        pub fn representedObject(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`representedObject`][Self::representedObject].
        ///
        /// # Safety
        ///
        /// `represented_object` should be of the correct type.
        #[unsafe(method(setRepresentedObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRepresentedObject(&self, represented_object: Option<&AnyObject>);

        #[unsafe(method(cellAttribute:))]
        #[unsafe(method_family = none)]
        pub fn cellAttribute(&self, parameter: NSCellAttribute) -> NSInteger;

        #[unsafe(method(setCellAttribute:to:))]
        #[unsafe(method_family = none)]
        pub fn setCellAttribute_to(&self, parameter: NSCellAttribute, value: NSInteger);

        #[unsafe(method(imageRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn imageRectForBounds(&self, rect: NSRect) -> NSRect;

        #[unsafe(method(titleRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn titleRectForBounds(&self, rect: NSRect) -> NSRect;

        #[unsafe(method(drawingRectForBounds:))]
        #[unsafe(method_family = none)]
        pub fn drawingRectForBounds(&self, rect: NSRect) -> NSRect;

        #[unsafe(method(_bulletStringForString:bulletCharacter:))]
        #[unsafe(method_family = none)]
        pub fn _bulletStringForString_bulletCharacter(
            string: &NSString,
            bullet_char: unichar,
            mtm: MainThreadMarker,
        ) -> Retained<NSString>;

        #[unsafe(method(cellSize))]
        #[unsafe(method_family = none)]
        pub fn cellSize(&self) -> NSSize;

        #[unsafe(method(cellSizeForBounds:))]
        #[unsafe(method_family = none)]
        pub fn cellSizeForBounds(&self, rect: NSRect) -> NSSize;

        #[cfg(all(feature = "NSColor", feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(highlightColorWithFrame:inView:))]
        #[unsafe(method_family = none)]
        pub fn highlightColorWithFrame_inView(
            &self,
            cell_frame: NSRect,
            control_view: &NSView,
        ) -> Option<Retained<NSColor>>;

        #[unsafe(method(calcDrawInfo:))]
        #[unsafe(method_family = none)]
        pub fn calcDrawInfo(&self, rect: NSRect);

        #[cfg(all(feature = "NSResponder", feature = "NSText", feature = "NSView"))]
        #[unsafe(method(setUpFieldEditorAttributes:))]
        #[unsafe(method_family = none)]
        pub fn setUpFieldEditorAttributes(&self, text_obj: &NSText) -> Retained<NSText>;

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(drawInteriorWithFrame:inView:))]
        #[unsafe(method_family = none)]
        pub fn drawInteriorWithFrame_inView(&self, cell_frame: NSRect, control_view: &NSView);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(drawWithFrame:inView:))]
        #[unsafe(method_family = none)]
        pub fn drawWithFrame_inView(&self, cell_frame: NSRect, control_view: &NSView);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(highlight:withFrame:inView:))]
        #[unsafe(method_family = none)]
        pub fn highlight_withFrame_inView(
            &self,
            flag: bool,
            cell_frame: NSRect,
            control_view: &NSView,
        );

        #[unsafe(method(mouseDownFlags))]
        #[unsafe(method_family = none)]
        pub fn mouseDownFlags(&self) -> NSInteger;

        /// # Safety
        ///
        /// - `delay` must be a valid pointer.
        /// - `interval` must be a valid pointer.
        #[unsafe(method(getPeriodicDelay:interval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getPeriodicDelay_interval(
            &self,
            delay: NonNull<c_float>,
            interval: NonNull<c_float>,
        );

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(startTrackingAt:inView:))]
        #[unsafe(method_family = none)]
        pub fn startTrackingAt_inView(&self, start_point: NSPoint, control_view: &NSView) -> bool;

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(continueTracking:at:inView:))]
        #[unsafe(method_family = none)]
        pub fn continueTracking_at_inView(
            &self,
            last_point: NSPoint,
            current_point: NSPoint,
            control_view: &NSView,
        ) -> bool;

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(stopTracking:at:inView:mouseIsUp:))]
        #[unsafe(method_family = none)]
        pub fn stopTracking_at_inView_mouseIsUp(
            &self,
            last_point: NSPoint,
            stop_point: NSPoint,
            control_view: &NSView,
            flag: bool,
        );

        #[cfg(all(feature = "NSEvent", feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(trackMouse:inRect:ofView:untilMouseUp:))]
        #[unsafe(method_family = none)]
        pub fn trackMouse_inRect_ofView_untilMouseUp(
            &self,
            event: &NSEvent,
            cell_frame: NSRect,
            control_view: &NSView,
            flag: bool,
        ) -> bool;

        #[cfg(all(
            feature = "NSEvent",
            feature = "NSResponder",
            feature = "NSText",
            feature = "NSView"
        ))]
        /// # Safety
        ///
        /// `delegate` should be of the correct type.
        #[unsafe(method(editWithFrame:inView:editor:delegate:event:))]
        #[unsafe(method_family = none)]
        pub unsafe fn editWithFrame_inView_editor_delegate_event(
            &self,
            rect: NSRect,
            control_view: &NSView,
            text_obj: &NSText,
            delegate: Option<&AnyObject>,
            event: Option<&NSEvent>,
        );

        #[cfg(all(feature = "NSResponder", feature = "NSText", feature = "NSView"))]
        /// # Safety
        ///
        /// `delegate` should be of the correct type.
        #[unsafe(method(selectWithFrame:inView:editor:delegate:start:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn selectWithFrame_inView_editor_delegate_start_length(
            &self,
            rect: NSRect,
            control_view: &NSView,
            text_obj: &NSText,
            delegate: Option<&AnyObject>,
            sel_start: NSInteger,
            sel_length: NSInteger,
        );

        #[cfg(all(feature = "NSResponder", feature = "NSText", feature = "NSView"))]
        #[unsafe(method(endEditing:))]
        #[unsafe(method_family = none)]
        pub fn endEditing(&self, text_obj: &NSText);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(resetCursorRect:inView:))]
        #[unsafe(method_family = none)]
        pub fn resetCursorRect_inView(&self, cell_frame: NSRect, control_view: &NSView);

        #[cfg(feature = "NSMenu")]
        #[unsafe(method(menu))]
        #[unsafe(method_family = none)]
        pub fn menu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        /// Setter for [`menu`][Self::menu].
        #[unsafe(method(setMenu:))]
        #[unsafe(method_family = none)]
        pub fn setMenu(&self, menu: Option<&NSMenu>);

        #[cfg(all(
            feature = "NSEvent",
            feature = "NSMenu",
            feature = "NSResponder",
            feature = "NSView"
        ))]
        #[unsafe(method(menuForEvent:inRect:ofView:))]
        #[unsafe(method_family = none)]
        pub fn menuForEvent_inRect_ofView(
            &self,
            event: &NSEvent,
            cell_frame: NSRect,
            view: &NSView,
        ) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        #[unsafe(method(defaultMenu))]
        #[unsafe(method_family = none)]
        pub fn defaultMenu(mtm: MainThreadMarker) -> Option<Retained<NSMenu>>;

        #[unsafe(method(sendsActionOnEndEditing))]
        #[unsafe(method_family = none)]
        pub fn sendsActionOnEndEditing(&self) -> bool;

        /// Setter for [`sendsActionOnEndEditing`][Self::sendsActionOnEndEditing].
        #[unsafe(method(setSendsActionOnEndEditing:))]
        #[unsafe(method_family = none)]
        pub fn setSendsActionOnEndEditing(&self, sends_action_on_end_editing: bool);

        #[cfg(feature = "NSText")]
        #[unsafe(method(baseWritingDirection))]
        #[unsafe(method_family = none)]
        pub fn baseWritingDirection(&self) -> NSWritingDirection;

        #[cfg(feature = "NSText")]
        /// Setter for [`baseWritingDirection`][Self::baseWritingDirection].
        #[unsafe(method(setBaseWritingDirection:))]
        #[unsafe(method_family = none)]
        pub fn setBaseWritingDirection(&self, base_writing_direction: NSWritingDirection);

        #[cfg(feature = "NSParagraphStyle")]
        #[unsafe(method(lineBreakMode))]
        #[unsafe(method_family = none)]
        pub fn lineBreakMode(&self) -> NSLineBreakMode;

        #[cfg(feature = "NSParagraphStyle")]
        /// Setter for [`lineBreakMode`][Self::lineBreakMode].
        #[unsafe(method(setLineBreakMode:))]
        #[unsafe(method_family = none)]
        pub fn setLineBreakMode(&self, line_break_mode: NSLineBreakMode);

        #[unsafe(method(allowsUndo))]
        #[unsafe(method_family = none)]
        pub fn allowsUndo(&self) -> bool;

        /// Setter for [`allowsUndo`][Self::allowsUndo].
        #[unsafe(method(setAllowsUndo:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsUndo(&self, allows_undo: bool);

        #[unsafe(method(truncatesLastVisibleLine))]
        #[unsafe(method_family = none)]
        pub fn truncatesLastVisibleLine(&self) -> bool;

        /// Setter for [`truncatesLastVisibleLine`][Self::truncatesLastVisibleLine].
        #[unsafe(method(setTruncatesLastVisibleLine:))]
        #[unsafe(method_family = none)]
        pub fn setTruncatesLastVisibleLine(&self, truncates_last_visible_line: bool);

        #[cfg(feature = "NSUserInterfaceLayout")]
        #[unsafe(method(userInterfaceLayoutDirection))]
        #[unsafe(method_family = none)]
        pub fn userInterfaceLayoutDirection(&self) -> NSUserInterfaceLayoutDirection;

        #[cfg(feature = "NSUserInterfaceLayout")]
        /// Setter for [`userInterfaceLayoutDirection`][Self::userInterfaceLayoutDirection].
        #[unsafe(method(setUserInterfaceLayoutDirection:))]
        #[unsafe(method_family = none)]
        pub fn setUserInterfaceLayoutDirection(
            &self,
            user_interface_layout_direction: NSUserInterfaceLayoutDirection,
        );

        #[cfg(all(
            feature = "NSResponder",
            feature = "NSText",
            feature = "NSTextView",
            feature = "NSView"
        ))]
        #[unsafe(method(fieldEditorForView:))]
        #[unsafe(method_family = none)]
        pub fn fieldEditorForView(&self, control_view: &NSView) -> Option<Retained<NSTextView>>;

        #[unsafe(method(usesSingleLineMode))]
        #[unsafe(method_family = none)]
        pub fn usesSingleLineMode(&self) -> bool;

        /// Setter for [`usesSingleLineMode`][Self::usesSingleLineMode].
        #[unsafe(method(setUsesSingleLineMode:))]
        #[unsafe(method_family = none)]
        pub fn setUsesSingleLineMode(&self, uses_single_line_mode: bool);

        #[cfg(all(
            feature = "NSDraggingItem",
            feature = "NSResponder",
            feature = "NSView"
        ))]
        #[unsafe(method(draggingImageComponentsWithFrame:inView:))]
        #[unsafe(method_family = none)]
        pub fn draggingImageComponentsWithFrame_inView(
            &self,
            frame: NSRect,
            view: &NSView,
        ) -> Retained<NSArray<NSDraggingImageComponent>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSCell {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// NSKeyboardUI.
impl NSCell {
    extern_methods!(
        #[unsafe(method(refusesFirstResponder))]
        #[unsafe(method_family = none)]
        pub fn refusesFirstResponder(&self) -> bool;

        /// Setter for [`refusesFirstResponder`][Self::refusesFirstResponder].
        #[unsafe(method(setRefusesFirstResponder:))]
        #[unsafe(method_family = none)]
        pub fn setRefusesFirstResponder(&self, refuses_first_responder: bool);

        #[unsafe(method(acceptsFirstResponder))]
        #[unsafe(method_family = none)]
        pub fn acceptsFirstResponder(&self) -> bool;

        #[unsafe(method(showsFirstResponder))]
        #[unsafe(method_family = none)]
        pub fn showsFirstResponder(&self) -> bool;

        /// Setter for [`showsFirstResponder`][Self::showsFirstResponder].
        #[unsafe(method(setShowsFirstResponder:))]
        #[unsafe(method_family = none)]
        pub fn setShowsFirstResponder(&self, shows_first_responder: bool);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(performClick:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performClick(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "NSGraphics")]
        #[unsafe(method(focusRingType))]
        #[unsafe(method_family = none)]
        pub fn focusRingType(&self) -> NSFocusRingType;

        #[cfg(feature = "NSGraphics")]
        /// Setter for [`focusRingType`][Self::focusRingType].
        #[unsafe(method(setFocusRingType:))]
        #[unsafe(method_family = none)]
        pub fn setFocusRingType(&self, focus_ring_type: NSFocusRingType);

        #[cfg(feature = "NSGraphics")]
        #[unsafe(method(defaultFocusRingType))]
        #[unsafe(method_family = none)]
        pub fn defaultFocusRingType(mtm: MainThreadMarker) -> NSFocusRingType;

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(drawFocusRingMaskWithFrame:inView:))]
        #[unsafe(method_family = none)]
        pub fn drawFocusRingMaskWithFrame_inView(&self, cell_frame: NSRect, control_view: &NSView);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(focusRingMaskBoundsForFrame:inView:))]
        #[unsafe(method_family = none)]
        pub fn focusRingMaskBoundsForFrame_inView(
            &self,
            cell_frame: NSRect,
            control_view: &NSView,
        ) -> NSRect;

        #[unsafe(method(wantsNotificationForMarkedText))]
        #[unsafe(method_family = none)]
        pub fn wantsNotificationForMarkedText(&self) -> bool;
    );
}

/// NSCellAttributedStringMethods.
impl NSCell {
    extern_methods!(
        #[unsafe(method(attributedStringValue))]
        #[unsafe(method_family = none)]
        pub fn attributedStringValue(&self) -> Retained<NSAttributedString>;

        /// Setter for [`attributedStringValue`][Self::attributedStringValue].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAttributedStringValue:))]
        #[unsafe(method_family = none)]
        pub fn setAttributedStringValue(&self, attributed_string_value: &NSAttributedString);

        #[unsafe(method(allowsEditingTextAttributes))]
        #[unsafe(method_family = none)]
        pub fn allowsEditingTextAttributes(&self) -> bool;

        /// Setter for [`allowsEditingTextAttributes`][Self::allowsEditingTextAttributes].
        #[unsafe(method(setAllowsEditingTextAttributes:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsEditingTextAttributes(&self, allows_editing_text_attributes: bool);

        #[unsafe(method(importsGraphics))]
        #[unsafe(method_family = none)]
        pub fn importsGraphics(&self) -> bool;

        /// Setter for [`importsGraphics`][Self::importsGraphics].
        #[unsafe(method(setImportsGraphics:))]
        #[unsafe(method_family = none)]
        pub fn setImportsGraphics(&self, imports_graphics: bool);
    );
}

/// NSCellMixedState.
impl NSCell {
    extern_methods!(
        #[unsafe(method(allowsMixedState))]
        #[unsafe(method_family = none)]
        pub fn allowsMixedState(&self) -> bool;

        /// Setter for [`allowsMixedState`][Self::allowsMixedState].
        #[unsafe(method(setAllowsMixedState:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsMixedState(&self, allows_mixed_state: bool);

        #[unsafe(method(nextState))]
        #[unsafe(method_family = none)]
        pub fn nextState(&self) -> NSInteger;

        #[unsafe(method(setNextState))]
        #[unsafe(method_family = none)]
        pub fn setNextState(&self);
    );
}

/// Constants used by the [`hitTestForEvent:inRect:ofView:`](https://developer.apple.com/documentation/appkit/nscell/hittest(for:in:of:)) method to determine the effect of an event.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSCellHitResult(pub NSUInteger);
bitflags::bitflags! {
    impl NSCellHitResult: NSUInteger {
/// An empty area, or did not hit in the cell.
        #[doc(alias = "NSCellHitNone")]
        const None = 0;
/// A content area in the cell.
        #[doc(alias = "NSCellHitContentArea")]
        const ContentArea = 1<<0;
/// An editable text area of the cell.
        #[doc(alias = "NSCellHitEditableTextArea")]
        const EditableTextArea = 1<<1;
/// A trackable area in the cell.
        #[doc(alias = "NSCellHitTrackableArea")]
        const TrackableArea = 1<<2;
    }
}

unsafe impl Encode for NSCellHitResult {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSCellHitResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// NSCellHitTest.
impl NSCell {
    extern_methods!(
        #[cfg(all(feature = "NSEvent", feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(hitTestForEvent:inRect:ofView:))]
        #[unsafe(method_family = none)]
        pub fn hitTestForEvent_inRect_ofView(
            &self,
            event: &NSEvent,
            cell_frame: NSRect,
            control_view: &NSView,
        ) -> NSCellHitResult;
    );
}

/// NSCellExpansion.
impl NSCell {
    extern_methods!(
        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(expansionFrameWithFrame:inView:))]
        #[unsafe(method_family = none)]
        pub fn expansionFrameWithFrame_inView(&self, cell_frame: NSRect, view: &NSView) -> NSRect;

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(drawWithExpansionFrame:inView:))]
        #[unsafe(method_family = none)]
        pub fn drawWithExpansionFrame_inView(&self, cell_frame: NSRect, view: &NSView);
    );
}

/// Background styles to apply to a view’s cell.
///
/// ## Overview
///
/// Apply these styles to the [`backgroundStyle`](https://developer.apple.com/documentation/appkit/nscell/backgroundstyle) or [`interiorBackgroundStyle`](https://developer.apple.com/documentation/appkit/nscell/interiorbackgroundstyle) properties of an [`NSCell`](https://developer.apple.com/documentation/appkit/nscell) object.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSBackgroundStyle(pub NSInteger);
impl NSBackgroundStyle {
    /// A style that reflects the predominant color scheme of the view’s appearance.
    #[doc(alias = "NSBackgroundStyleNormal")]
    pub const Normal: Self = Self(0);
    /// A style that adds emphasis to the background using an alternate color or visual effect.
    ///
    /// ## Discussion
    ///
    /// You might use this style to show selection. You might need to alter the appearance of the cell’s content to achieve the needed emphasis.
    ///
    ///
    #[doc(alias = "NSBackgroundStyleEmphasized")]
    pub const Emphasized: Self = Self(1);
    /// A style that makes the background appear higher than the content drawn on it.
    ///
    /// ## Discussion
    ///
    /// You might need to inset the cell’s content to achieve this effect.
    ///
    ///
    #[doc(alias = "NSBackgroundStyleRaised")]
    pub const Raised: Self = Self(2);
    /// A style that makes the background appear lower than the content drawn on it.
    ///
    /// ## Discussion
    ///
    /// You might need to emboss the cell’s content to achieve this effect.
    ///
    ///
    #[doc(alias = "NSBackgroundStyleLowered")]
    pub const Lowered: Self = Self(3);
}

unsafe impl Encode for NSBackgroundStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSBackgroundStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// NSCellBackgroundStyle.
impl NSCell {
    extern_methods!(
        #[unsafe(method(backgroundStyle))]
        #[unsafe(method_family = none)]
        pub fn backgroundStyle(&self) -> NSBackgroundStyle;

        /// Setter for [`backgroundStyle`][Self::backgroundStyle].
        #[unsafe(method(setBackgroundStyle:))]
        #[unsafe(method_family = none)]
        pub fn setBackgroundStyle(&self, background_style: NSBackgroundStyle);

        #[unsafe(method(interiorBackgroundStyle))]
        #[unsafe(method_family = none)]
        pub fn interiorBackgroundStyle(&self) -> NSBackgroundStyle;
    );
}

/// Draws a three-part tiled image.
///
/// Parameters:
/// - frame: The rectangle (specified in the current coordinate system) in which to draw the images.
///
/// - startCap: For a horizontal three-part image, this is the image located at the left edge of the frame rectangle. For a vertical three-part image, this image appears at the top of the screen in an unflipped coordinate system and at the bottom of the screen in a flipped coordinate system.
///
/// - centerFill: The image used to tile the space between the `startCap` and `endCap` images.
///
/// - endCap: For a horizontal three-part image, this is the image located at the right edge of the frame rectangle. For a vertical three-part image, this image appears at the bottom of the screen in an unflipped coordinate system and at the top of the screen in a flipped coordinate system.
///
/// - vertical: Specify [`true`](https://developer.apple.com/documentation/swift/true) if the images should be stacked on top of one another to create a vertically oriented element. Specify [`false`](https://developer.apple.com/documentation/swift/false) if the images should be laid out side-by-side to create a horizontally oriented element.
///
/// - op: The compositing operation to use when rendering the images.
///
/// - alphaFraction: The alpha value to apply to the rendered image. This value can range between 0.0 and 1.0, with 0.0 being fully transparent and 1.0 being fully opaque.
///
/// - flipped: Specify [`true`](https://developer.apple.com/documentation/swift/true) if you are drawing the images in a flipped coordinate system; otherwise, specify [`false`](https://developer.apple.com/documentation/swift/false).
///
///
/// ## Discussion
///
/// This function is typically used to draw custom cells (such as the backgrounds for push button and slider controls) that are capable of being resized along a single axis only. Cells of this type are comprised of fixed-size end cap images and a center area that is filled by tiling the specified center image as many times as needed to fill the gap. These cells allow you to create sophisticated looking controls that can grow and shrink without distorting the control’s overall appearance.
///
/// You should prefer the use of this function over your own custom code for handling multi-part images whose size can change. This function correctly manages the subtle behaviors needed to handle resolution independence issues and to avoid visual artifacts caused by tiling the various images.
///
/// When drawing a horizontally oriented control, the images in the `startCap`, `centerFill`, and `endCap` parameters should all have the same height, and that height should match the height of the frame rectangle. If an image’s height does not match the height of the frame rectangle, it is scaled until it does match, which might yield less desirable results. For vertically oriented controls, the image widths are scaled instead of the heights.
///
/// The `flipped` parameter lets you reorient the contents of each image when drawing in a flipped coordinate system. By default, images use an internal coordinate system that is not flipped. Rendering such an image in a flipped coordinate system would therefore cause the image to appear upside down. Passing [`true`](https://developer.apple.com/documentation/swift/true) for the `flipped` parameter adjusts the image’s internal coordinate system to draw it correctly in a flipped environment.
///
///
#[cfg(all(
    feature = "NSGraphics",
    feature = "NSImage",
    feature = "objc2-core-foundation"
))]
#[inline]
pub extern "C-unwind" fn NSDrawThreePartImage(
    frame: NSRect,
    start_cap: Option<&NSImage>,
    center_fill: Option<&NSImage>,
    end_cap: Option<&NSImage>,
    vertical: bool,
    op: NSCompositingOperation,
    alpha_fraction: CGFloat,
    flipped: bool,
) {
    extern "C-unwind" {
        fn NSDrawThreePartImage(
            frame: NSRect,
            start_cap: Option<&NSImage>,
            center_fill: Option<&NSImage>,
            end_cap: Option<&NSImage>,
            vertical: Bool,
            op: NSCompositingOperation,
            alpha_fraction: CGFloat,
            flipped: Bool,
        );
    }
    unsafe {
        NSDrawThreePartImage(
            frame,
            start_cap,
            center_fill,
            end_cap,
            Bool::new(vertical),
            op,
            alpha_fraction,
            Bool::new(flipped),
        )
    }
}

/// Draws a nine-part tiled image.
///
/// Parameters:
/// - frame: The rectangle (specified in the current coordinate system) in which to draw the images.
///
/// - topLeftCorner: The image to display in the top-left corner.
///
/// - topEdgeFill: The image used to tile the space between the `topLeftCorner` and `topRightCorner` images.
///
/// - topRightCorner: The image to display in the top-right corner.
///
/// - leftEdgeFill: The image used to tile the space between the `topLeftCorner` and `bottomLeftCorner` images.
///
/// - centerFill: The image used to tile the center area between the other eight images.
///
/// - rightEdgeFill: The image used to tile the space between the `topRightCorner` and `bottomRightCorner` images.
///
/// - bottomLeftCorner: The image to display in the bottom-left corner.
///
/// - bottomEdgeFill: The image used to tile the space between the `bottomLeftCorner` and `bottomRightCorner` images.
///
/// - bottomRightCorner: The image to display in the bottom-right corner.
///
/// - op: The compositing operation to use when rendering the images.
///
/// - alphaFraction: The alpha value to apply to the rendered image. This value can range between 0.0 and 1.0, with 0.0 being fully transparent and 1.0 being fully opaque.
///
/// - flipped: Specify [`true`](https://developer.apple.com/documentation/swift/true) if you are drawing the images in a flipped coordinate system; otherwise, specify [`false`](https://developer.apple.com/documentation/swift/false).
///
///
/// ## Discussion
///
/// This function is typically used to draw custom cells that are capable of being resized both vertically and horizontally. Cells of this type are comprised of four fixed-size corner images along and a set of edge and center images that are used to fill the gaps between the corners. These cells allow you to create sophisticated looking controls that can grow and shrink in any direction without distorting the control’s overall appearance.
///
/// You should prefer the use of this function over your own custom code for handling multi-part images whose size can change. This function correctly manages the subtle behaviors needed to handle resolution independence issues and to avoid visual artifacts caused by tiling the various images.
///
/// This function uses the top-left and bottom-right corner images to determine the widths and heights of the edge areas that need to be filled. If the width or height of the bottom-left and top-right images are not sized appropriately, they may be scaled to fill their corner area. Edge areas between the corners are tiled using the corresponding image. Similarly, the center area is tiled using the specified center image.
///
/// The `flipped` parameter lets you reorient the contents of each image when drawing in a flipped coordinate system. By default, images use an internal coordinate system that is not flipped. Rendering such an image in a flipped coordinate system would therefore cause the image to appear upside down. Passing [`true`](https://developer.apple.com/documentation/swift/true) for the `flipped` parameter adjusts the image’s internal coordinate system to draw it correctly in a flipped environment.
///
///
#[cfg(all(
    feature = "NSGraphics",
    feature = "NSImage",
    feature = "objc2-core-foundation"
))]
#[inline]
pub extern "C-unwind" fn NSDrawNinePartImage(
    frame: NSRect,
    top_left_corner: Option<&NSImage>,
    top_edge_fill: Option<&NSImage>,
    top_right_corner: Option<&NSImage>,
    left_edge_fill: Option<&NSImage>,
    center_fill: Option<&NSImage>,
    right_edge_fill: Option<&NSImage>,
    bottom_left_corner: Option<&NSImage>,
    bottom_edge_fill: Option<&NSImage>,
    bottom_right_corner: Option<&NSImage>,
    op: NSCompositingOperation,
    alpha_fraction: CGFloat,
    flipped: bool,
) {
    extern "C-unwind" {
        fn NSDrawNinePartImage(
            frame: NSRect,
            top_left_corner: Option<&NSImage>,
            top_edge_fill: Option<&NSImage>,
            top_right_corner: Option<&NSImage>,
            left_edge_fill: Option<&NSImage>,
            center_fill: Option<&NSImage>,
            right_edge_fill: Option<&NSImage>,
            bottom_left_corner: Option<&NSImage>,
            bottom_edge_fill: Option<&NSImage>,
            bottom_right_corner: Option<&NSImage>,
            op: NSCompositingOperation,
            alpha_fraction: CGFloat,
            flipped: Bool,
        );
    }
    unsafe {
        NSDrawNinePartImage(
            frame,
            top_left_corner,
            top_edge_fill,
            top_right_corner,
            left_edge_fill,
            center_fill,
            right_edge_fill,
            bottom_left_corner,
            bottom_edge_fill,
            bottom_right_corner,
            op,
            alpha_fraction,
            Bool::new(flipped),
        )
    }
}

/// NSDeprecated.
impl NSCell {
    extern_methods!(
        #[deprecated = "The controlTint property is not respected on 10.14 and later. For custom cells, use +[NSColor controlAccentColor] to respect the user's preferred accent color when drawing."]
        #[unsafe(method(controlTint))]
        #[unsafe(method_family = none)]
        pub fn controlTint(&self) -> NSControlTint;

        /// Setter for [`controlTint`][Self::controlTint].
        #[deprecated = "The controlTint property is not respected on 10.14 and later. For custom cells, use +[NSColor controlAccentColor] to respect the user's preferred accent color when drawing."]
        #[unsafe(method(setControlTint:))]
        #[unsafe(method_family = none)]
        pub fn setControlTint(&self, control_tint: NSControlTint);

        #[deprecated]
        #[unsafe(method(entryType))]
        #[unsafe(method_family = none)]
        pub fn entryType(&self) -> NSInteger;

        #[deprecated]
        #[unsafe(method(setEntryType:))]
        #[unsafe(method_family = none)]
        pub fn setEntryType(&self, r#type: NSInteger);

        #[deprecated]
        #[unsafe(method(isEntryAcceptable:))]
        #[unsafe(method_family = none)]
        pub fn isEntryAcceptable(&self, string: &NSString) -> bool;

        #[deprecated]
        #[unsafe(method(setFloatingPointFormat:left:right:))]
        #[unsafe(method_family = none)]
        pub fn setFloatingPointFormat_left_right(
            &self,
            auto_range: bool,
            left_digits: NSUInteger,
            right_digits: NSUInteger,
        );

        #[deprecated]
        #[unsafe(method(setMnemonicLocation:))]
        #[unsafe(method_family = none)]
        pub fn setMnemonicLocation(&self, location: NSUInteger);

        #[deprecated]
        #[unsafe(method(mnemonicLocation))]
        #[unsafe(method_family = none)]
        pub fn mnemonicLocation(&self) -> NSUInteger;

        #[deprecated]
        #[unsafe(method(mnemonic))]
        #[unsafe(method_family = none)]
        pub fn mnemonic(&self) -> Retained<NSString>;

        #[deprecated]
        #[unsafe(method(setTitleWithMnemonic:))]
        #[unsafe(method_family = none)]
        pub fn setTitleWithMnemonic(&self, string_with_ampersand: &NSString);
    );
}

/// The background is a light color.
///
/// ## Discussion
///
/// Dark content contrasts well with this background.
///
///
#[deprecated]
pub static NSBackgroundStyleLight: NSBackgroundStyle =
    NSBackgroundStyle(NSBackgroundStyle::Normal.0);

/// The background is a dark color.
///
/// ## Discussion
///
/// Light content contrasts well with this background.
///
///
#[deprecated]
pub static NSBackgroundStyleDark: NSBackgroundStyle =
    NSBackgroundStyle(NSBackgroundStyle::Emphasized.0);

/// Constants for specifying a cell’s state and are used mostly for buttons.
///
/// ## Discussion
///
/// These constants are described in [Cell States](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ControlCell/Concepts/CellStates.html#//apple_ref/doc/uid/20000069).
///
///
#[deprecated]
pub type NSCellStateValue = NSControlStateValue;

/// The corresponding feature is in effect somewhere.
#[deprecated]
pub static NSMixedState: NSControlStateValue = NSControlStateValueMixed;

/// The corresponding feature is in effect nowhere.
#[deprecated]
pub static NSOffState: NSControlStateValue = NSControlStateValueOff;

/// The corresponding feature is in effect everywhere.
#[deprecated]
pub static NSOnState: NSControlStateValue = NSControlStateValueOn;

/// The default control size.
#[deprecated]
pub static NSRegularControlSize: NSControlSize = NSControlSize(NSControlSize::Regular.0);

/// A size that is smaller than the default control size.
#[deprecated]
pub static NSSmallControlSize: NSControlSize = NSControlSize(NSControlSize::Small.0);

/// The control has a smaller size than `NSSmallControlSize`.
#[deprecated]
pub static NSMiniControlSize: NSControlSize = NSControlSize(NSControlSize::Mini.0);

extern "C" {
    /// Sent after the user changes control tint preference.
    ///
    /// ## Discussion
    ///
    /// The notification object is `NSApp`. This notification does not contain a `userInfo` dictionary.
    ///
    ///
    #[deprecated = "Changes to the accent color can be manually observed by implementing -viewDidChangeEffectiveAppearance in a NSView subclass, or by Key-Value Observing the -effectiveAppearance property on NSApplication. Views are automatically redisplayed when the accent color changes."]
    pub static NSControlTintDidChangeNotification: &'static NSNotificationName;
}

/// Any value is allowed.
#[deprecated = "Use formatters instead"]
pub const NSAnyType: c_uint = 0;
/// Must be between `INT_MIN` and `INT_MAX`.
#[deprecated = "Use formatters instead"]
pub const NSIntType: c_uint = 1;
/// Must be between 1 and `INT_MAX`.
#[deprecated = "Use formatters instead"]
pub const NSPositiveIntType: c_uint = 2;
/// Must be between `–FLT_MAX` and `FLT_MAX`.
#[deprecated = "Use formatters instead"]
pub const NSFloatType: c_uint = 3;
/// Must be between `FLT_MIN` and `FLT_MAX`.
#[deprecated = "Use formatters instead"]
pub const NSPositiveFloatType: c_uint = 4;
/// Must be between `–FLT_MAX` and `FLT_MAX`.
#[deprecated = "Use formatters instead"]
pub const NSDoubleType: c_uint = 6;
/// Must be between `FLT_MIN` and `FLT_MAX`.
#[deprecated = "Use formatters instead"]
pub const NSPositiveDoubleType: c_uint = 7;
