//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// A set of methods that restoration classes must implement to handle the recreation of windows.
    ///
    /// ## Overview
    ///
    /// At launch time, the application object retrieves the restoration class and uses its [`restoreWindowWithIdentifier:state:completionHandler:`](https://developer.apple.com/documentation/appkit/nswindowrestoration/restorewindow(withidentifier:state:completionhandler:)) method to obtain a new window whose type matches the type that was preserved previously. Classes that adopt this protocol can use the provided information to create (or obtain a reference to) the window in the new application. As part of creating the window, the class should also create any related objects, such as window controllers, normally used to manage the window.
    ///
    ///
    pub unsafe trait NSWindowRestoration: NSObjectProtocol + MainThreadOnly {
        #[cfg(all(
            feature = "NSResponder",
            feature = "NSUserInterfaceItemIdentification",
            feature = "NSWindow",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `state` possibly has further requirements.
        #[unsafe(method(restoreWindowWithIdentifier:state:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn restoreWindowWithIdentifier_state_completionHandler(
            identifier: &NSUserInterfaceItemIdentifier,
            state: &NSCoder,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSWindow, *mut NSError)>,
            mtm: MainThreadMarker,
        );
    }
);

/// NSWindowRestoration.
#[cfg(feature = "NSDocumentController")]
impl NSDocumentController {
    extern_methods!();
}

#[cfg(feature = "NSDocumentController")]
extern_conformance!(
    unsafe impl NSWindowRestoration for NSDocumentController {}
);

/// NSWindowRestoration.
#[cfg(all(feature = "NSApplication", feature = "NSResponder"))]
impl NSApplication {
    extern_methods!(
        #[cfg(all(
            feature = "NSUserInterfaceItemIdentification",
            feature = "NSWindow",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `state` possibly has further requirements.
        #[unsafe(method(restoreWindowWithIdentifier:state:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn restoreWindowWithIdentifier_state_completionHandler(
            &self,
            identifier: &NSUserInterfaceItemIdentifier,
            state: &NSCoder,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSWindow, *mut NSError)>,
        ) -> bool;
    );
}

extern "C" {
    /// Posted when the app has finished restoring windows.
    ///
    /// ## Discussion
    ///
    /// The notification is posted on the main actor when the app is finished restoring windows, that is, when all the completion handlers from [`restoreWindowWithIdentifier:state:completionHandler:`](https://developer.apple.com/documentation/appkit/nswindowrestoration/restorewindow(withidentifier:state:completionhandler:)) have been called. This is always posted after [`NSApplicationWillFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/willfinishlaunchingnotification), but may be posted before or after [`NSApplicationDidFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/didfinishlaunchingnotification), depending on whether clients copy the completion handlers and invoke them later. If there were no windows to restore, then this notification is still posted at the corresponding point in app launch (between [`NSApplicationWillFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/willfinishlaunchingnotification) and [`NSApplicationDidFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/didfinishlaunchingnotification)).
    ///
    /// The notification object is [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared). This notification doesnâ€™t contain a `userInfo` dictionary.
    ///
    ///
    pub static NSApplicationDidFinishRestoringWindowsNotification: &'static NSNotificationName;
}

/// NSUserInterfaceRestoration.
#[cfg(all(feature = "NSResponder", feature = "NSWindow"))]
impl NSWindow {
    extern_methods!(
        #[unsafe(method(isRestorable))]
        #[unsafe(method_family = none)]
        pub fn isRestorable(&self) -> bool;

        /// Setter for [`isRestorable`][Self::isRestorable].
        #[unsafe(method(setRestorable:))]
        #[unsafe(method_family = none)]
        pub fn setRestorable(&self, restorable: bool);

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(restorationClass))]
        #[unsafe(method_family = none)]
        pub unsafe fn restorationClass(&self) -> Option<&'static AnyClass>;

        /// Setter for [`restorationClass`][Self::restorationClass].
        ///
        /// # Safety
        ///
        /// - `restoration_class` must implement NSWindowRestoration.
        /// - This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setRestorationClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRestorationClass(&self, restoration_class: Option<&AnyClass>);

        #[unsafe(method(disableSnapshotRestoration))]
        #[unsafe(method_family = none)]
        pub fn disableSnapshotRestoration(&self);

        #[unsafe(method(enableSnapshotRestoration))]
        #[unsafe(method_family = none)]
        pub fn enableSnapshotRestoration(&self);
    );
}

/// NSRestorableState.
#[cfg(feature = "NSResponder")]
impl NSResponder {
    extern_methods!(
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(encodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder(&self, coder: &NSCoder);

        /// # Safety
        ///
        /// - `coder` possibly has further requirements.
        /// - `queue` possibly has additional threading requirements.
        #[unsafe(method(encodeRestorableStateWithCoder:backgroundQueue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder_backgroundQueue(
            &self,
            coder: &NSCoder,
            queue: &NSOperationQueue,
        );

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(restoreStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn restoreStateWithCoder(&self, coder: &NSCoder);

        #[unsafe(method(invalidateRestorableState))]
        #[unsafe(method_family = none)]
        pub fn invalidateRestorableState(&self);

        #[unsafe(method(restorableStateKeyPaths))]
        #[unsafe(method_family = none)]
        pub fn restorableStateKeyPaths(mtm: MainThreadMarker) -> Retained<NSArray<NSString>>;

        /// When secure state restoration is used, values at restorableStateKeyPaths must support NSSecureCoding and this method will be consulted when restoring state. Any values not of an allowed class will not be set.
        #[unsafe(method(allowedClassesForRestorableStateKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn allowedClassesForRestorableStateKeyPath(
            key_path: &NSString,
            mtm: MainThreadMarker,
        ) -> Retained<NSArray<AnyClass>>;
    );
}

/// NSRestorableStateExtension.
#[cfg(all(feature = "NSApplication", feature = "NSResponder"))]
impl NSApplication {
    extern_methods!(
        #[unsafe(method(extendStateRestoration))]
        #[unsafe(method_family = none)]
        pub fn extendStateRestoration(&self);

        #[unsafe(method(completeStateRestoration))]
        #[unsafe(method_family = none)]
        pub fn completeStateRestoration(&self);
    );
}

/// NSRestorableState.
#[cfg(feature = "NSDocument")]
impl NSDocument {
    extern_methods!(
        #[cfg(all(
            feature = "NSResponder",
            feature = "NSUserInterfaceItemIdentification",
            feature = "NSWindow",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// `state` possibly has further requirements.
        #[unsafe(method(restoreDocumentWindowWithIdentifier:state:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn restoreDocumentWindowWithIdentifier_state_completionHandler(
            &self,
            identifier: &NSUserInterfaceItemIdentifier,
            state: &NSCoder,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSWindow, *mut NSError)>,
        );

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(encodeRestorableStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder(&self, coder: &NSCoder);

        /// # Safety
        ///
        /// - `coder` possibly has further requirements.
        /// - `queue` possibly has additional threading requirements.
        #[unsafe(method(encodeRestorableStateWithCoder:backgroundQueue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn encodeRestorableStateWithCoder_backgroundQueue(
            &self,
            coder: &NSCoder,
            queue: &NSOperationQueue,
        );

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(restoreStateWithCoder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn restoreStateWithCoder(&self, coder: &NSCoder);

        #[unsafe(method(invalidateRestorableState))]
        #[unsafe(method_family = none)]
        pub fn invalidateRestorableState(&self);

        #[unsafe(method(restorableStateKeyPaths))]
        #[unsafe(method_family = none)]
        pub fn restorableStateKeyPaths(mtm: MainThreadMarker) -> Retained<NSArray<NSString>>;

        #[unsafe(method(allowedClassesForRestorableStateKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn allowedClassesForRestorableStateKeyPath(
            key_path: &NSString,
            mtm: MainThreadMarker,
        ) -> Retained<NSArray<AnyClass>>;
    );
}
