//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// These constants describe the curve of an animation—that is, the relative speed of an animation from start to finish.
///
/// ## Overview
///
/// You initialize an `NSAnimation` object using one of these constants with [`initWithDuration:animationCurve:`](https://developer.apple.com/documentation/appkit/nsanimation/init(duration:animationcurve:)) and you can set it thereafter with the [`animationCurve`](https://developer.apple.com/documentation/appkit/nsanimation/animationcurve) property.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSAnimationCurve(pub NSUInteger);
impl NSAnimationCurve {
    /// Describes an S-curve in which the animation slowly speeds up and then slows down near the end of the animation. This constant is the default.
    #[doc(alias = "NSAnimationEaseInOut")]
    pub const EaseInOut: Self = Self(0);
    /// Describes an animation that slows down as it reaches the end.
    #[doc(alias = "NSAnimationEaseIn")]
    pub const EaseIn: Self = Self(1);
    /// Describes an animation that slowly speeds up from the start.
    #[doc(alias = "NSAnimationEaseOut")]
    pub const EaseOut: Self = Self(2);
    /// Describes an animation in which there is no change in frame rate.
    #[doc(alias = "NSAnimationLinear")]
    pub const Linear: Self = Self(3);
}

unsafe impl Encode for NSAnimationCurve {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSAnimationCurve {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// These constants indicate the blocking mode of an `NSAnimation` object when it is running.
///
/// ## Overview
///
/// You specify one of these constants in the [`animationBlockingMode`](https://developer.apple.com/documentation/appkit/nsanimation/animationblockingmode) property.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSAnimationBlockingMode(pub NSUInteger);
impl NSAnimationBlockingMode {
    /// Requests the animation to run in the main thread in a custom run-loop mode that blocks user input.
    ///
    /// ## Discussion
    ///
    /// This is the default.
    ///
    ///
    #[doc(alias = "NSAnimationBlocking")]
    pub const Blocking: Self = Self(0);
    /// Requests the animation to run in a standard or specified run-loop mode that allows user input.
    #[doc(alias = "NSAnimationNonblocking")]
    pub const Nonblocking: Self = Self(1);
    /// Requests the animation to run in a separate thread that is spawned by the `NSAnimation` object.
    ///
    /// ## Discussion
    ///
    /// The secondary thread has its own run loop.
    ///
    ///
    #[doc(alias = "NSAnimationNonblockingThreaded")]
    pub const NonblockingThreaded: Self = Self(2);
}

unsafe impl Encode for NSAnimationBlockingMode {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSAnimationBlockingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The animation progress, as a floating-point number between `0.0` and `1.0`.
///
/// ## Discussion
///
/// An animation progress value is returned in the `userInfo` dictionary of an [`NSAnimationProgressMarkNotification`](https://developer.apple.com/documentation/appkit/nsanimation/progressmarknotification) notification.
///
///
pub type NSAnimationProgress = c_float;

extern "C" {
    /// Posted when the current progress of a running animation reaches one of its progress marks.
    ///
    /// ## Discussion
    ///
    /// The notification object is a running `NSAnimation` object. The `userInfo` dictionary contains the current progress mark, accessed via the key `NSAnimationProgressMark`.
    ///
    ///
    pub static NSAnimationProgressMarkNotification: &'static NSNotificationName;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Contains the value of an [`NSAnimationProgress`](https://developer.apple.com/documentation/appkit/nsanimation/progress) as an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) instance that indicates the current animation progress. The value will be between `0.0` and `1.0`.
    ///
    ///
    pub static NSAnimationProgressMark: &'static NSString;
}

extern_class!(
    /// An object that manages the timing and progress of animations in the user interface.
    ///
    /// ## Overview
    ///
    /// [`NSAnimation`](https://developer.apple.com/documentation/appkit/nsanimation) also lets you link together multiple animations so that when one animation ends another one starts. It does not provide any drawing support for animation and does not directly deal with views, targets, or actions.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  For simple tasks requiring a timing mechanism, consider using [`NSTimer`](https://developer.apple.com/documentation/foundation/timer).
    ///
    ///
    ///
    /// </div>
    /// [`NSAnimation`](https://developer.apple.com/documentation/appkit/nsanimation) objects have several characteristics, including duration, frame rate, and animation curve, which describes the relative speed of the animation over its course. You can set progress marks in an animation, each of which specifies a percentage of the animation completed; when an animation reaches a progress mark, it notifies its delegate and posts a notification to any observers. Animations execute in one of three blocking modes: blocking, non-blocking on the main thread, and non-blocking on a separate thread. The non-blocking modes permit the handling of user events while the animation is running.
    ///
    /// ### Subclassing Notes
    ///
    /// The usual usage pattern for `NSAnimation` is to make a subclass that overrides (at least) the [`currentProgress`](https://developer.apple.com/documentation/appkit/nsanimation/currentprogress) property to invoke the superclass implementation and then perform whatever animation action is needed. The method implementation might use the [`currentValue`](https://developer.apple.com/documentation/appkit/nsanimation/currentvalue) property and then use that value to update some drawing; as a consequence of getting the current value, the method [`animation:valueForProgress:`](https://developer.apple.com/documentation/appkit/nsanimationdelegate/animation(_:valueforprogress:)) is sent to the delegate (if there is a delegate that implements the method). For more information on subclassing `NSAnimation`, see [Animation Programming Guide for Cocoa](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/AnimationGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003592).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSAnimation;
);

extern_conformance!(
    unsafe impl NSCoding for NSAnimation {}
);

extern_conformance!(
    unsafe impl NSCopying for NSAnimation {}
);

unsafe impl CopyingHelper for NSAnimation {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSAnimation {}
);

impl NSAnimation {
    extern_methods!(
        #[unsafe(method(initWithDuration:animationCurve:))]
        #[unsafe(method_family = init)]
        pub fn initWithDuration_animationCurve(
            this: Allocated<Self>,
            duration: NSTimeInterval,
            animation_curve: NSAnimationCurve,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(startAnimation))]
        #[unsafe(method_family = none)]
        pub fn startAnimation(&self);

        #[unsafe(method(stopAnimation))]
        #[unsafe(method_family = none)]
        pub fn stopAnimation(&self);

        #[unsafe(method(isAnimating))]
        #[unsafe(method_family = none)]
        pub fn isAnimating(&self) -> bool;

        #[unsafe(method(currentProgress))]
        #[unsafe(method_family = none)]
        pub fn currentProgress(&self) -> NSAnimationProgress;

        /// Setter for [`currentProgress`][Self::currentProgress].
        #[unsafe(method(setCurrentProgress:))]
        #[unsafe(method_family = none)]
        pub fn setCurrentProgress(&self, current_progress: NSAnimationProgress);

        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub fn duration(&self) -> NSTimeInterval;

        /// Setter for [`duration`][Self::duration].
        #[unsafe(method(setDuration:))]
        #[unsafe(method_family = none)]
        pub fn setDuration(&self, duration: NSTimeInterval);

        #[unsafe(method(animationBlockingMode))]
        #[unsafe(method_family = none)]
        pub fn animationBlockingMode(&self) -> NSAnimationBlockingMode;

        /// Setter for [`animationBlockingMode`][Self::animationBlockingMode].
        #[unsafe(method(setAnimationBlockingMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAnimationBlockingMode(
            &self,
            animation_blocking_mode: NSAnimationBlockingMode,
        );

        #[unsafe(method(frameRate))]
        #[unsafe(method_family = none)]
        pub fn frameRate(&self) -> c_float;

        /// Setter for [`frameRate`][Self::frameRate].
        #[unsafe(method(setFrameRate:))]
        #[unsafe(method_family = none)]
        pub fn setFrameRate(&self, frame_rate: c_float);

        #[unsafe(method(animationCurve))]
        #[unsafe(method_family = none)]
        pub fn animationCurve(&self) -> NSAnimationCurve;

        /// Setter for [`animationCurve`][Self::animationCurve].
        #[unsafe(method(setAnimationCurve:))]
        #[unsafe(method_family = none)]
        pub fn setAnimationCurve(&self, animation_curve: NSAnimationCurve);

        #[unsafe(method(currentValue))]
        #[unsafe(method_family = none)]
        pub fn currentValue(&self) -> c_float;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSAnimationDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSAnimationDelegate>>);

        #[unsafe(method(progressMarks))]
        #[unsafe(method_family = none)]
        pub fn progressMarks(&self) -> Retained<NSArray<NSNumber>>;

        /// Setter for [`progressMarks`][Self::progressMarks].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setProgressMarks:))]
        #[unsafe(method_family = none)]
        pub fn setProgressMarks(&self, progress_marks: &NSArray<NSNumber>);

        #[unsafe(method(addProgressMark:))]
        #[unsafe(method_family = none)]
        pub fn addProgressMark(&self, progress_mark: NSAnimationProgress);

        #[unsafe(method(removeProgressMark:))]
        #[unsafe(method_family = none)]
        pub fn removeProgressMark(&self, progress_mark: NSAnimationProgress);

        #[unsafe(method(startWhenAnimation:reachesProgress:))]
        #[unsafe(method_family = none)]
        pub fn startWhenAnimation_reachesProgress(
            &self,
            animation: &NSAnimation,
            start_progress: NSAnimationProgress,
        );

        #[unsafe(method(stopWhenAnimation:reachesProgress:))]
        #[unsafe(method_family = none)]
        pub fn stopWhenAnimation_reachesProgress(
            &self,
            animation: &NSAnimation,
            stop_progress: NSAnimationProgress,
        );

        #[unsafe(method(clearStartAnimation))]
        #[unsafe(method_family = none)]
        pub fn clearStartAnimation(&self);

        #[unsafe(method(clearStopAnimation))]
        #[unsafe(method_family = none)]
        pub fn clearStopAnimation(&self);

        #[unsafe(method(runLoopModesForAnimating))]
        #[unsafe(method_family = none)]
        pub fn runLoopModesForAnimating(&self) -> Option<Retained<NSArray<NSRunLoopMode>>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSAnimation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSAnimation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_protocol!(
    /// A set of optional methods implemented by delegates of [`NSAnimation`](https://developer.apple.com/documentation/appkit/nsanimation) objects.
    pub unsafe trait NSAnimationDelegate: NSObjectProtocol {
        #[optional]
        #[unsafe(method(animationShouldStart:))]
        #[unsafe(method_family = none)]
        fn animationShouldStart(&self, animation: &NSAnimation) -> bool;

        #[optional]
        #[unsafe(method(animationDidStop:))]
        #[unsafe(method_family = none)]
        fn animationDidStop(&self, animation: &NSAnimation);

        #[optional]
        #[unsafe(method(animationDidEnd:))]
        #[unsafe(method_family = none)]
        fn animationDidEnd(&self, animation: &NSAnimation);

        #[optional]
        #[unsafe(method(animation:valueForProgress:))]
        #[unsafe(method_family = none)]
        fn animation_valueForProgress(
            &self,
            animation: &NSAnimation,
            progress: NSAnimationProgress,
        ) -> c_float;

        #[optional]
        #[unsafe(method(animation:didReachProgressMark:))]
        #[unsafe(method_family = none)]
        fn animation_didReachProgressMark(
            &self,
            animation: &NSAnimation,
            progress: NSAnimationProgress,
        );
    }
);

/// The following string constants are keys for the dictionaries in the array passed into [`initWithViewAnimations:`](https://developer.apple.com/documentation/appkit/nsviewanimation/init(viewanimations:)) and [`viewAnimations`](https://developer.apple.com/documentation/appkit/nsviewanimation/viewanimations).
// NS_TYPED_ENUM
pub type NSViewAnimationKey = NSString;

extern "C" {
    /// The target of the animation.
    ///
    /// ## Discussion
    ///
    /// The target can be either an [`NSView`](https://developer.apple.com/documentation/appkit/nsview) object or an [`NSWindow`](https://developer.apple.com/documentation/appkit/nswindow) object. This property is required.
    ///
    ///
    pub static NSViewAnimationTargetKey: &'static NSViewAnimationKey;
}

extern "C" {
    /// The size and location of the window or view at the start of the animation.
    ///
    /// ## Discussion
    ///
    /// The size and location are specified by an [`NSRect`](https://developer.apple.com/documentation/foundation/nsrect) structure encoded in an [`NSValue`](https://developer.apple.com/documentation/foundation/nsvalue) object. This property is optional. If it is not specified, `NSViewAnimation` uses the frame of the window or view at the start of the animation.
    ///
    ///
    pub static NSViewAnimationStartFrameKey: &'static NSViewAnimationKey;
}

extern "C" {
    /// The size and location of the window or view at the end of the animation.
    ///
    /// ## Discussion
    ///
    /// The size and location are specified by an [`NSRect`](https://developer.apple.com/documentation/foundation/nsrect) structure encoded in an [`NSValue`](https://developer.apple.com/documentation/foundation/nsvalue) object. This property is optional. If it is not specified, `NSViewAnimation` uses the frame of the window or view at the start of the animation. If the target is a view and the end frame is empty, the view is hidden at the end.
    ///
    ///
    pub static NSViewAnimationEndFrameKey: &'static NSViewAnimationKey;
}

extern "C" {
    /// An effect to apply to the animation.
    ///
    /// ## Discussion
    ///
    /// Takes a string constant specifying fade-in or fade-out effects for the target: `NSViewAnimationFadeInEffect` and `NSViewAnimationFadeOutEffect`. If the target is a view and the effect is to fade out, the view is hidden at the end. If the effect is to fade in an initially hidden view and the end frame is non-empty, the view is unhidden at the end. If the target is a window, the window is ordered in or out as appropriate to the effect. This property is optional.
    ///
    ///
    pub static NSViewAnimationEffectKey: &'static NSViewAnimationKey;
}

/// The following constants specify the animation effect to apply and are used as values for the animation effect property of the animation view. See the description of [`NSViewAnimationEffectKey`](https://developer.apple.com/documentation/appkit/nsviewanimation/key/effect) for usage details.
// NS_TYPED_ENUM
pub type NSViewAnimationEffectName = NSString;

extern "C" {
    /// Specifies a fade-in type of effect.
    pub static NSViewAnimationFadeInEffect: &'static NSViewAnimationEffectName;
}

extern "C" {
    /// Specifies a fade-out type of effect.
    pub static NSViewAnimationFadeOutEffect: &'static NSViewAnimationEffectName;
}

extern_class!(
    /// An animation of an app’s views, limited to changes in frame location and size, and to fade-in and fade-out effects.
    ///
    /// ## Overview
    ///
    /// An [`NSViewAnimation`](https://developer.apple.com/documentation/appkit/nsviewanimation) object takes an array of dictionaries from which it determines the objects to animate and the effects to apply to them. Each dictionary must have a target object and, optionally, properties that specify beginning and ending frame and whether to fade in or fade out. (See [`NSViewAnimationKey`](https://developer.apple.com/documentation/appkit/nsviewanimation/key) for further information.) Animations with [`NSViewAnimation`](https://developer.apple.com/documentation/appkit/nsviewanimation) are, by default, in non-blocking mode over a duration of 0.5 seconds using the ease in-out animation curve. But you can configure the animation to have any duration, curve, frame rate, and blocking mode. You may also set progress marks, assign a delegate, and implement delegation methods in order to animate view and windows concurrent with the ones specified as targets in the view-animation dictionary.
    ///
    /// Invoking the [`NSAnimation`](https://developer.apple.com/documentation/appkit/nsanimation) [`stopAnimation`](https://developer.apple.com/documentation/appkit/nsanimation/stop()) method on a running [`NSViewAnimation`](https://developer.apple.com/documentation/appkit/nsviewanimation) object moves the animation to the end frame.
    ///
    ///
    #[unsafe(super(NSAnimation, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSViewAnimation;
);

extern_conformance!(
    unsafe impl NSCoding for NSViewAnimation {}
);

extern_conformance!(
    unsafe impl NSCopying for NSViewAnimation {}
);

unsafe impl CopyingHelper for NSViewAnimation {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSViewAnimation {}
);

impl NSViewAnimation {
    extern_methods!(
        /// # Safety
        ///
        /// `view_animations` generic generic should be of the correct type.
        #[unsafe(method(initWithViewAnimations:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithViewAnimations(
            this: Allocated<Self>,
            view_animations: &NSArray<NSDictionary<NSViewAnimationKey, AnyObject>>,
        ) -> Retained<Self>;

        #[unsafe(method(viewAnimations))]
        #[unsafe(method_family = none)]
        pub fn viewAnimations(
            &self,
        ) -> Retained<NSArray<NSDictionary<NSViewAnimationKey, AnyObject>>>;

        /// Setter for [`viewAnimations`][Self::viewAnimations].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `view_animations` generic generic should be of the correct type.
        #[unsafe(method(setViewAnimations:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setViewAnimations(
            &self,
            view_animations: &NSArray<NSDictionary<NSViewAnimationKey, AnyObject>>,
        );
    );
}

/// Methods declared on superclass `NSAnimation`.
impl NSViewAnimation {
    extern_methods!(
        #[unsafe(method(initWithDuration:animationCurve:))]
        #[unsafe(method_family = init)]
        pub fn initWithDuration_animationCurve(
            this: Allocated<Self>,
            duration: NSTimeInterval,
            animation_curve: NSAnimationCurve,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSViewAnimation {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSViewAnimation {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

pub type NSAnimatablePropertyKey = NSString;

extern_protocol!(
    /// A set of methods that defines a way to add animation to an existing class with a minimum of API impact.
    ///
    /// ## Overview
    ///
    /// The [`NSAnimatablePropertyContainer`](https://developer.apple.com/documentation/appkit/nsanimatablepropertycontainer) protocol returns a proxy object for the receiver that can be used to initiate implied animation of property changes. An object’s animator proxy should be treated as if it was the object itself, and may be passed to any code that accepts the object as a parameter. Sending of key-value-coding compliant “set” messages to the proxy will trigger animation for automatically animated properties of its target object.
    ///
    /// An object’s automatically animated properties are those for which [`NSAnimatablePropertyContainer`](https://developer.apple.com/documentation/appkit/nsanimatablepropertycontainer) finds and returns a [`CAAnimation`](https://developer.apple.com/documentation/quartzcore/caanimation) object instead of `nil`, often because [`animator`](https://developer.apple.com/documentation/appkit/nsanimatablepropertycontainer/animator()) specifies a default animation for the key.
    ///
    /// It’s perfectly valid to set a new value for a property for which an animation that is currently in progress; this simply sets a new target value for that property, with animation to the new target proceeding from whatever current value the property has reached. An in-flight property animation can be stopped by setting a new value for the property bracketed by an [`NSAnimationContext`](https://developer.apple.com/documentation/appkit/nsanimationcontext) with 0.0 as the duration.
    ///
    ///
    pub unsafe trait NSAnimatablePropertyContainer {
        #[unsafe(method(animator))]
        #[unsafe(method_family = none)]
        fn animator(&self) -> Retained<Self>;

        #[unsafe(method(animations))]
        #[unsafe(method_family = none)]
        fn animations(&self) -> Retained<NSDictionary<NSAnimatablePropertyKey, AnyObject>>;

        /// Setter for [`animations`][Self::animations].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `animations` generic should be of the correct type.
        #[unsafe(method(setAnimations:))]
        #[unsafe(method_family = none)]
        unsafe fn setAnimations(
            &self,
            animations: &NSDictionary<NSAnimatablePropertyKey, AnyObject>,
        );

        #[unsafe(method(animationForKey:))]
        #[unsafe(method_family = none)]
        fn animationForKey(&self, key: &NSAnimatablePropertyKey) -> Option<Retained<AnyObject>>;

        #[unsafe(method(defaultAnimationForKey:))]
        #[unsafe(method_family = none)]
        fn defaultAnimationForKey(key: &NSAnimatablePropertyKey) -> Option<Retained<AnyObject>>;
    }
);

extern "C" {
    ///
    /// ## Discussion
    ///
    /// The key that references the transition animation used when a view becomes visible, either as a result of being inserted into the visible view hierarchy or as a result of the view no longer being set as hidden .
    ///
    ///
    pub static NSAnimationTriggerOrderIn: &'static NSAnimatablePropertyKey;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// The key that references the transition animation used when a view is no longer visible, either as a result of being removed from the visible view hierarchy or as a result of the view set as hidden.
    ///
    ///
    pub static NSAnimationTriggerOrderOut: &'static NSAnimatablePropertyKey;
}
