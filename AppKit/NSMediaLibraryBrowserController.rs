//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// These constants are masks used to configure a Media Library Browser to display specific types of media. Combined masks are not yet supported.  In other words, only one nonzero mask value is supported at a time.  If masks are combined, the lowest mask value is used.
/// This type is used to configure a media browser for individual media types.
///
/// Warning: Though this type is declared as a set of mixable options -- and was originally intended to become that eventually -- you should treat it as an enum.
///
/// Warning: In other words, this type should be declared with NS_ENUM rather than NS_OPTIONS, but the latter has historical inertia not worth struggling against.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSMediaLibrary(pub NSUInteger);
bitflags::bitflags! {
    impl NSMediaLibrary: NSUInteger {
/// Display audio media.
        #[doc(alias = "NSMediaLibraryAudio")]
        const Audio = 1<<0;
/// Display image media.
        #[doc(alias = "NSMediaLibraryImage")]
        const Image = 1<<1;
/// Display movie media.
        #[doc(alias = "NSMediaLibraryMovie")]
        const Movie = 1<<2;
    }
}

unsafe impl Encode for NSMediaLibrary {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSMediaLibrary {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that configures and displays a Media Library Browser panel.
    ///
    /// ## Overview
    ///
    /// From this panel a user can drag media  into views in their app. The class provides a standard interface to the MediaLibrary framework content.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The Media Library Browser panel is not an `NSPanel` instance.  It has panel like methods to remotely control the Media Library Browser.  Clients have no direct programmatic access to the panel displaying the Media Library Browser.
    ///
    ///
    ///
    /// </div>
    /// For more information see [`MLMediaLibrary`](https://developer.apple.com/documentation/medialibrary/mlmedialibrary), [`MLMediaSource`](https://developer.apple.com/documentation/medialibrary/mlmediasource), [`MLMediaGroup`](https://developer.apple.com/documentation/medialibrary/mlmediagroup), and [`MLMediaObject`](https://developer.apple.com/documentation/medialibrary/mlmediaobject) in [`Media Library`](https://developer.apple.com/documentation/medialibrary).
    ///
    /// ### Pasteboard Types
    ///
    /// The Media Library Browser defines two pasteboard types for decoding the dragged content and retrieving the media content that is appropriate, one for mediagroup content and one for individual media items
    ///
    /// - The `com.apple.MediaLibrary.PboardType.MediaGroupIdentifiersPlist` pasteboard type describes media group content and is published when the user drags items from the upper media-group-organized pane of the Media Library Browser.
    ///
    /// - The `com.apple.MediaLibrary.PboardType.MediaObjectIdentifiersPlist` pasteboard type describes individual media items and is published when the user drags media items such as images, movies, or sounds from the media item pane of the Media Library Browser.
    ///
    /// There is a third, less specialized, type of media library pasteboard. When the user initiates a drag the pasteboard will contain an array with one more more  [`NSFilenamesPboardType`](https://developer.apple.com/documentation/appkit/nsfilenamespboardtype) pasteboard items, one for each of the files within the group dragged from the media-group-organized pane, and one or more items when a media item or items are dragged from the media item pane.
    ///
    /// If you do not need access to the associated Media Library metadata, using the `NSFilenamesPboardType` pasteboard data is the simplest means of retrieving the dragged content, although accessing the media in this manner when your app is sandboxed requires that you use the `NSURL` [`startAccessingSecurityScopedResource`](https://developer.apple.com/documentation/foundation/nsurl/startaccessingsecurityscopedresource()) and [`stopAccessingSecurityScopedResource`](https://developer.apple.com/documentation/foundation/nsurl/stopaccessingsecurityscopedresource()) methods.
    ///
    /// #### The Media Group Pasteboard Type
    ///
    /// The `"com.apple.MediaLibrary.PboardType.MediaGroupIdentifiersPlist"` pasteboard type is published when the user drags items from the upper media-group-organized pane of the Media Library Browser.
    ///
    /// It consists of an `NSDictionary` plist that contains`keys` with the media source identifiers and corresponding `value` that are arrays of media group identifiers.
    ///
    /// To decode the pasteboard data and get `MLMediaGroup` instances, assuming you have an `MLMediaLibrary` instance, use the techniques illustrated in the code listing below.
    ///
    /// Listing 1. Retrieving MLMediaGroup instances from the pasteboard
    ///
    /// ```objc
    /// NSDictionary *mediaGroupsDict = [dragPasteboard propertyListForType:@"com.apple.MediaLibrary.PBoardType.MediaGroupIdentifiersPlist"];
    ///     if ( mediaGroupsDict )
    ///     {
    ///         [s appendFormat:@"Media Groups Dictionary: %@\n", mediaGroupsDict];
    ///         [s appendString:@"Media Groups:\n"];
    ///         for ( NSString *sourceIdentifier in [mediaGroupsDict allKeys] )
    ///         {
    ///             MLTAppDelegate *appDelegate = (MLTAppDelegate *)[[NSApplication sharedApplication] delegate];
    ///             MLMediaLibrary *mediaLibrary = appDelegate.mediaLibrary;
    ///             MLMediaSource *mediaSource = [mediaLibrary.mediaSources objectForKey:sourceIdentifier];
    ///             if ( mediaSource )
    ///             {
    ///                 NSArray *groupIdentifiers = [mediaGroupsDict objectForKey:sourceIdentifier];
    ///                 for ( NSString *groupIdentifier in groupIdentifiers )
    ///                 {
    ///                     MLMediaGroup *mediaGroup = [mediaSource mediaGroupForIdentifier:groupIdentifier];
    ///                     [s appendFormat:@"%@\n", mediaGroup];
    ///                 }
    ///             }
    ///         }
    ///     }
    /// ```
    ///
    /// #### The Media Object Pasteboard Type
    ///
    /// The `"com.apple.MediaLibrary.PboardType.MediaObjectIdentifiersPlist"` pasteboard type is published when the user drags an item from the media item pane of the Media Library Browser.
    ///
    /// It consists of an `NSDictionary` plist that contains`keys` with the media source identifiers and corresponding `value` that are arrays of media object identifiers.
    ///
    /// To decode the pasteboard data and get `MLMediaObject` instances, assuming that you have an MLMediaLibrary instance, use the techniques illustrated in the code listing below.
    ///
    /// Listing 2. Retrieving MLMediaObject instances from the pasteboard
    ///
    /// ```objc
    ///  NSDictionary *mediaObjectsDict = [dragPasteboard propertyListForType:@"com.apple.MediaLibrary.PBoardType.MediaObjectIdentifiersPlist"];
    ///     if ( mediaObjectsDict )
    ///     {
    ///         [s appendFormat:@"Media Objects Dictionary: %@\n", mediaObjectsDict];
    ///         [s appendString:@"Media Objects:\n"];
    ///         for ( NSString *sourceIdentifier in [mediaObjectsDict allKeys] )
    ///         {
    ///             MLTAppDelegate *appDelegate = (MLTAppDelegate *)[[NSApplication sharedApplication] delegate];
    ///             MLMediaLibrary *mediaLibrary = appDelegate.mediaLibrary;
    ///             MLMediaSource *mediaSource = [mediaLibrary.mediaSources objectForKey:sourceIdentifier];
    ///             if ( mediaSource )
    ///             {
    ///                 NSArray *objectIdentifiers = [mediaObjectsDict objectForKey:sourceIdentifier];
    ///                 for ( NSString *objectIdentifier in objectIdentifiers )
    ///                 {
    ///                     MLMediaObject *mediaObject = [mediaSource mediaObjectForIdentifier:objectIdentifier];
    ///                     [s appendFormat:@"%@\n", mediaObject];
    ///                 }
    ///             }
    ///         }
    ///     }
    /// ```
    ///
    ///
    /// This class configures and displays a media browser panel.
    ///
    /// This class provides no direct access to the panel, and its meaningful contents aren't in the calling process.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMediaLibraryBrowserController;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSMediaLibraryBrowserController {}
);

impl NSMediaLibraryBrowserController {
    extern_methods!(
        #[unsafe(method(sharedMediaLibraryBrowserController))]
        #[unsafe(method_family = none)]
        pub fn sharedMediaLibraryBrowserController() -> Retained<NSMediaLibraryBrowserController>;

        #[unsafe(method(isVisible))]
        #[unsafe(method_family = none)]
        pub fn isVisible(&self) -> bool;

        /// Setter for [`isVisible`][Self::isVisible].
        #[unsafe(method(setVisible:))]
        #[unsafe(method_family = none)]
        pub fn setVisible(&self, visible: bool);

        #[unsafe(method(frame))]
        #[unsafe(method_family = none)]
        pub fn frame(&self) -> NSRect;

        /// Setter for [`frame`][Self::frame].
        #[unsafe(method(setFrame:))]
        #[unsafe(method_family = none)]
        pub fn setFrame(&self, frame: NSRect);

        #[unsafe(method(mediaLibraries))]
        #[unsafe(method_family = none)]
        pub fn mediaLibraries(&self) -> NSMediaLibrary;

        /// Setter for [`mediaLibraries`][Self::mediaLibraries].
        #[unsafe(method(setMediaLibraries:))]
        #[unsafe(method_family = none)]
        pub fn setMediaLibraries(&self, media_libraries: NSMediaLibrary);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(togglePanel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn togglePanel(&self, sender: Option<&AnyObject>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSMediaLibraryBrowserController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSMediaLibraryBrowserController {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}
