//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A bindings-compatible controller that manages a tree of objects.
    ///
    /// ## Overview
    ///
    /// The [`NSTreeController`](https://developer.apple.com/documentation/appkit/nstreecontroller) class provides selection and sort management. Its primary purpose is to act as the controller when binding [`NSOutlineView`](https://developer.apple.com/documentation/appkit/nsoutlineview) and [`NSBrowser`](https://developer.apple.com/documentation/appkit/nsbrowser) instances to a hierarchical collection of objects. The root content object of the tree can be a single object, or an array of objects.
    ///
    /// An [`NSTreeController`](https://developer.apple.com/documentation/appkit/nstreecontroller) object requires that you describe how the tree of objects is traversed by specifying the key-path for child objects specified by [`childrenKeyPath`](https://developer.apple.com/documentation/appkit/nstreecontroller/childrenkeypath). All child objects for the tree must be key-value coding compliant for the same child key path. If necessary, you should add properties to your model classes that map the child key name to the appropriate class-specific property name.
    ///
    /// Child objects can implement a count method (specified to the tree controller using [`countKeyPath`](https://developer.apple.com/documentation/appkit/nstreecontroller/countkeypath)) that, if provided, returns the number of child objects available. Your model objects are expected to update the value of the count key path in a key-value observing compliant method. Optionally, you can also provide a leaf key path using [`leafKeyPath`](https://developer.apple.com/documentation/appkit/nstreecontroller/leafkeypath) that specifies a key in your model object that returns [`true`](https://developer.apple.com/documentation/swift/true) if the object is a leaf node, and [`false`](https://developer.apple.com/documentation/swift/false) if it is not. Changes to the leaf node value of the child object should be made in a key-value observing compliant manner. Providing the leaf node key path can improve performance, because it prevents the [`NSTreeController`](https://developer.apple.com/documentation/appkit/nstreecontroller) from having to examine the child object to determine if it is a leaf node.
    ///
    /// For more information about using NSTreeController in your app, see [Navigating Hierarchical Data Using Outline and Split Views](https://developer.apple.com/documentation/appkit/navigating-hierarchical-data-using-outline-and-split-views).
    ///
    ///
    #[unsafe(super(NSObjectController, NSController, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "NSController", feature = "NSObjectController"))]
    pub struct NSTreeController;
);

#[cfg(all(feature = "NSController", feature = "NSObjectController"))]
extern_conformance!(
    unsafe impl NSCoding for NSTreeController {}
);

#[cfg(all(
    feature = "NSController",
    feature = "NSKeyValueBinding",
    feature = "NSObjectController"
))]
extern_conformance!(
    unsafe impl NSEditor for NSTreeController {}
);

#[cfg(all(
    feature = "NSController",
    feature = "NSKeyValueBinding",
    feature = "NSObjectController"
))]
extern_conformance!(
    unsafe impl NSEditorRegistration for NSTreeController {}
);

#[cfg(all(feature = "NSController", feature = "NSObjectController"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSTreeController {}
);

#[cfg(all(feature = "NSController", feature = "NSObjectController"))]
impl NSTreeController {
    extern_methods!(
        #[unsafe(method(rearrangeObjects))]
        #[unsafe(method_family = none)]
        pub fn rearrangeObjects(&self);

        #[cfg(feature = "NSTreeNode")]
        #[unsafe(method(arrangedObjects))]
        #[unsafe(method_family = none)]
        pub fn arrangedObjects(&self) -> Retained<NSTreeNode>;

        #[unsafe(method(childrenKeyPath))]
        #[unsafe(method_family = none)]
        pub fn childrenKeyPath(&self) -> Option<Retained<NSString>>;

        /// Setter for [`childrenKeyPath`][Self::childrenKeyPath].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setChildrenKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn setChildrenKeyPath(&self, children_key_path: Option<&NSString>);

        #[unsafe(method(countKeyPath))]
        #[unsafe(method_family = none)]
        pub fn countKeyPath(&self) -> Option<Retained<NSString>>;

        /// Setter for [`countKeyPath`][Self::countKeyPath].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setCountKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn setCountKeyPath(&self, count_key_path: Option<&NSString>);

        #[unsafe(method(leafKeyPath))]
        #[unsafe(method_family = none)]
        pub fn leafKeyPath(&self) -> Option<Retained<NSString>>;

        /// Setter for [`leafKeyPath`][Self::leafKeyPath].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLeafKeyPath:))]
        #[unsafe(method_family = none)]
        pub fn setLeafKeyPath(&self, leaf_key_path: Option<&NSString>);

        #[unsafe(method(sortDescriptors))]
        #[unsafe(method_family = none)]
        pub fn sortDescriptors(&self) -> Retained<NSArray<NSSortDescriptor>>;

        /// Setter for [`sortDescriptors`][Self::sortDescriptors].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSortDescriptors:))]
        #[unsafe(method_family = none)]
        pub fn setSortDescriptors(&self, sort_descriptors: &NSArray<NSSortDescriptor>);

        #[unsafe(method(content))]
        #[unsafe(method_family = none)]
        pub fn content(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`content`][Self::content].
        ///
        /// # Safety
        ///
        /// `content` should be of the correct type.
        #[unsafe(method(setContent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContent(&self, content: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(add:))]
        #[unsafe(method_family = none)]
        pub unsafe fn add(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(remove:))]
        #[unsafe(method_family = none)]
        pub unsafe fn remove(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(addChild:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addChild(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(insert:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insert(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(insertChild:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertChild(&self, sender: Option<&AnyObject>);

        #[unsafe(method(canInsert))]
        #[unsafe(method_family = none)]
        pub fn canInsert(&self) -> bool;

        #[unsafe(method(canInsertChild))]
        #[unsafe(method_family = none)]
        pub fn canInsertChild(&self) -> bool;

        #[unsafe(method(canAddChild))]
        #[unsafe(method_family = none)]
        pub fn canAddChild(&self) -> bool;

        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[unsafe(method(insertObject:atArrangedObjectIndexPath:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertObject_atArrangedObjectIndexPath(
            &self,
            object: Option<&AnyObject>,
            index_path: &NSIndexPath,
        );

        /// # Safety
        ///
        /// `objects` generic should be of the correct type.
        #[unsafe(method(insertObjects:atArrangedObjectIndexPaths:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertObjects_atArrangedObjectIndexPaths(
            &self,
            objects: &NSArray,
            index_paths: &NSArray<NSIndexPath>,
        );

        #[unsafe(method(removeObjectAtArrangedObjectIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn removeObjectAtArrangedObjectIndexPath(&self, index_path: &NSIndexPath);

        #[unsafe(method(removeObjectsAtArrangedObjectIndexPaths:))]
        #[unsafe(method_family = none)]
        pub fn removeObjectsAtArrangedObjectIndexPaths(&self, index_paths: &NSArray<NSIndexPath>);

        #[unsafe(method(avoidsEmptySelection))]
        #[unsafe(method_family = none)]
        pub fn avoidsEmptySelection(&self) -> bool;

        /// Setter for [`avoidsEmptySelection`][Self::avoidsEmptySelection].
        #[unsafe(method(setAvoidsEmptySelection:))]
        #[unsafe(method_family = none)]
        pub fn setAvoidsEmptySelection(&self, avoids_empty_selection: bool);

        #[unsafe(method(preservesSelection))]
        #[unsafe(method_family = none)]
        pub fn preservesSelection(&self) -> bool;

        /// Setter for [`preservesSelection`][Self::preservesSelection].
        #[unsafe(method(setPreservesSelection:))]
        #[unsafe(method_family = none)]
        pub fn setPreservesSelection(&self, preserves_selection: bool);

        #[unsafe(method(selectsInsertedObjects))]
        #[unsafe(method_family = none)]
        pub fn selectsInsertedObjects(&self) -> bool;

        /// Setter for [`selectsInsertedObjects`][Self::selectsInsertedObjects].
        #[unsafe(method(setSelectsInsertedObjects:))]
        #[unsafe(method_family = none)]
        pub fn setSelectsInsertedObjects(&self, selects_inserted_objects: bool);

        #[unsafe(method(alwaysUsesMultipleValuesMarker))]
        #[unsafe(method_family = none)]
        pub fn alwaysUsesMultipleValuesMarker(&self) -> bool;

        /// Setter for [`alwaysUsesMultipleValuesMarker`][Self::alwaysUsesMultipleValuesMarker].
        #[unsafe(method(setAlwaysUsesMultipleValuesMarker:))]
        #[unsafe(method_family = none)]
        pub fn setAlwaysUsesMultipleValuesMarker(&self, always_uses_multiple_values_marker: bool);

        #[unsafe(method(selectedObjects))]
        #[unsafe(method_family = none)]
        pub fn selectedObjects(&self) -> Retained<NSArray>;

        #[unsafe(method(setSelectionIndexPaths:))]
        #[unsafe(method_family = none)]
        pub fn setSelectionIndexPaths(&self, index_paths: &NSArray<NSIndexPath>) -> bool;

        #[unsafe(method(selectionIndexPaths))]
        #[unsafe(method_family = none)]
        pub fn selectionIndexPaths(&self) -> Retained<NSArray<NSIndexPath>>;

        #[unsafe(method(setSelectionIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn setSelectionIndexPath(&self, index_path: Option<&NSIndexPath>) -> bool;

        #[unsafe(method(selectionIndexPath))]
        #[unsafe(method_family = none)]
        pub fn selectionIndexPath(&self) -> Option<Retained<NSIndexPath>>;

        #[unsafe(method(addSelectionIndexPaths:))]
        #[unsafe(method_family = none)]
        pub fn addSelectionIndexPaths(&self, index_paths: &NSArray<NSIndexPath>) -> bool;

        #[unsafe(method(removeSelectionIndexPaths:))]
        #[unsafe(method_family = none)]
        pub fn removeSelectionIndexPaths(&self, index_paths: &NSArray<NSIndexPath>) -> bool;

        #[cfg(feature = "NSTreeNode")]
        #[unsafe(method(selectedNodes))]
        #[unsafe(method_family = none)]
        pub fn selectedNodes(&self) -> Retained<NSArray<NSTreeNode>>;

        #[cfg(feature = "NSTreeNode")]
        #[unsafe(method(moveNode:toIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn moveNode_toIndexPath(&self, node: &NSTreeNode, index_path: &NSIndexPath);

        #[cfg(feature = "NSTreeNode")]
        #[unsafe(method(moveNodes:toIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn moveNodes_toIndexPath(
            &self,
            nodes: &NSArray<NSTreeNode>,
            starting_index_path: &NSIndexPath,
        );

        #[cfg(feature = "NSTreeNode")]
        #[unsafe(method(childrenKeyPathForNode:))]
        #[unsafe(method_family = none)]
        pub fn childrenKeyPathForNode(&self, node: &NSTreeNode) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSTreeNode")]
        #[unsafe(method(countKeyPathForNode:))]
        #[unsafe(method_family = none)]
        pub fn countKeyPathForNode(&self, node: &NSTreeNode) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSTreeNode")]
        #[unsafe(method(leafKeyPathForNode:))]
        #[unsafe(method_family = none)]
        pub fn leafKeyPathForNode(&self, node: &NSTreeNode) -> Option<Retained<NSString>>;
    );
}

/// Methods declared on superclass `NSObjectController`.
#[cfg(all(feature = "NSController", feature = "NSObjectController"))]
impl NSTreeController {
    extern_methods!(
        /// # Safety
        ///
        /// `content` should be of the correct type.
        #[unsafe(method(initWithContent:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContent(
            this: Allocated<Self>,
            content: Option<&AnyObject>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSController`.
#[cfg(all(feature = "NSController", feature = "NSObjectController"))]
impl NSTreeController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "NSController", feature = "NSObjectController"))]
impl NSTreeController {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
