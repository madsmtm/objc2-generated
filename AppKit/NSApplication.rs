//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-cloud-kit")]
#[cfg(target_vendor = "apple")]
use objc2_cloud_kit::*;
use objc2_foundation::*;

use crate::*;

/// Constants for determining which version of AppKit is available.
// NS_TYPED_EXTENSIBLE_ENUM
pub type NSAppKitVersion = c_double;

extern "C" {
    /// The most recent version of AppKit.
    pub static NSAppKitVersionNumber: NSAppKitVersion;
}

/// The AppKit framework included in OS X v10.0.
pub static NSAppKitVersionNumber10_0: NSAppKitVersion = 577 as _;

/// The AppKit framework included in OS X v10.1.
pub static NSAppKitVersionNumber10_1: NSAppKitVersion = 620 as _;

/// The AppKit framework included in OS X v10.2.
pub static NSAppKitVersionNumber10_2: NSAppKitVersion = 663 as _;

/// The AppKit framework included in OS X v10.2.3.
pub static NSAppKitVersionNumber10_2_3: NSAppKitVersion = 663.6 as _;

/// The AppKit framework included in OS X v10.3.
pub static NSAppKitVersionNumber10_3: NSAppKitVersion = 743 as _;

/// The AppKit framework included in OS X v10.3.2.
pub static NSAppKitVersionNumber10_3_2: NSAppKitVersion = 743.14 as _;

/// The AppKit framework included in OS X v10.3.3.
pub static NSAppKitVersionNumber10_3_3: NSAppKitVersion = 743.2 as _;

/// The AppKit framework included in OS X v10.3.5.
pub static NSAppKitVersionNumber10_3_5: NSAppKitVersion = 743.24 as _;

/// The AppKit framework included in OS X v10.3.7.
pub static NSAppKitVersionNumber10_3_7: NSAppKitVersion = 743.33 as _;

/// The AppKit framework included in OS X v10.3.9.
pub static NSAppKitVersionNumber10_3_9: NSAppKitVersion = 743.36 as _;

/// The AppKit framework included in OS X v10.4.
pub static NSAppKitVersionNumber10_4: NSAppKitVersion = 824 as _;

/// The AppKit framework included in OS X v10.4.1.
pub static NSAppKitVersionNumber10_4_1: NSAppKitVersion = 824.1 as _;

/// The AppKit framework included in OS X v10.4.3.
pub static NSAppKitVersionNumber10_4_3: NSAppKitVersion = 824.23 as _;

/// The AppKit framework included in OS X v10.4.4.
pub static NSAppKitVersionNumber10_4_4: NSAppKitVersion = 824.33 as _;

/// The AppKit framework included in OS X v10.4.7.
pub static NSAppKitVersionNumber10_4_7: NSAppKitVersion = 824.41 as _;

/// The AppKit framework included in OS X v10.5.
pub static NSAppKitVersionNumber10_5: NSAppKitVersion = 949 as _;

/// The AppKit framework included in OS X v10.5.2.
pub static NSAppKitVersionNumber10_5_2: NSAppKitVersion = 949.27 as _;

/// The AppKit framework included in OS X v10.5.3.
pub static NSAppKitVersionNumber10_5_3: NSAppKitVersion = 949.33 as _;

/// The AppKit framework included in OS X v10.6.
pub static NSAppKitVersionNumber10_6: NSAppKitVersion = 1038 as _;

/// The AppKit framework included in OS X v10.7.
pub static NSAppKitVersionNumber10_7: NSAppKitVersion = 1138 as _;

/// The AppKit framework included in OS X v10.7.2.
pub static NSAppKitVersionNumber10_7_2: NSAppKitVersion = 1138.23 as _;

/// The AppKit framework included in OS X v10.7.3.
pub static NSAppKitVersionNumber10_7_3: NSAppKitVersion = 1138.32 as _;

/// The AppKit framework included in OS X v10.7.4.
pub static NSAppKitVersionNumber10_7_4: NSAppKitVersion = 1138.47 as _;

/// The AppKit framework included in OS X v10.8.
pub static NSAppKitVersionNumber10_8: NSAppKitVersion = 1187 as _;

pub static NSAppKitVersionNumber10_9: NSAppKitVersion = 1265 as _;

pub static NSAppKitVersionNumber10_10: NSAppKitVersion = 1343 as _;

pub static NSAppKitVersionNumber10_10_2: NSAppKitVersion = 1344 as _;

pub static NSAppKitVersionNumber10_10_3: NSAppKitVersion = 1347 as _;

pub static NSAppKitVersionNumber10_10_4: NSAppKitVersion = 1348 as _;

pub static NSAppKitVersionNumber10_10_5: NSAppKitVersion = 1348 as _;

pub static NSAppKitVersionNumber10_10_Max: NSAppKitVersion = 1349 as _;

pub static NSAppKitVersionNumber10_11: NSAppKitVersion = 1404 as _;

pub static NSAppKitVersionNumber10_11_1: NSAppKitVersion = 1404.13 as _;

pub static NSAppKitVersionNumber10_11_2: NSAppKitVersion = 1404.34 as _;

pub static NSAppKitVersionNumber10_11_3: NSAppKitVersion = 1404.34 as _;

pub static NSAppKitVersionNumber10_12: NSAppKitVersion = 1504 as _;

pub static NSAppKitVersionNumber10_12_1: NSAppKitVersion = 1504.6 as _;

pub static NSAppKitVersionNumber10_12_2: NSAppKitVersion = 1504.76 as _;

pub static NSAppKitVersionNumber10_13: NSAppKitVersion = 1561 as _;

pub static NSAppKitVersionNumber10_13_1: NSAppKitVersion = 1561.1 as _;

pub static NSAppKitVersionNumber10_13_2: NSAppKitVersion = 1561.2 as _;

pub static NSAppKitVersionNumber10_13_4: NSAppKitVersion = 1561.4 as _;

pub static NSAppKitVersionNumber10_14: NSAppKitVersion = 1671 as _;

pub static NSAppKitVersionNumber10_14_1: NSAppKitVersion = 1671.1 as _;

pub static NSAppKitVersionNumber10_14_2: NSAppKitVersion = 1671.2 as _;

pub static NSAppKitVersionNumber10_14_3: NSAppKitVersion = 1671.3 as _;

pub static NSAppKitVersionNumber10_14_4: NSAppKitVersion = 1671.4 as _;

pub static NSAppKitVersionNumber10_14_5: NSAppKitVersion = 1671.5 as _;

pub static NSAppKitVersionNumber10_15: NSAppKitVersion = 1894 as _;

pub static NSAppKitVersionNumber10_15_1: NSAppKitVersion = 1894.1 as _;

pub static NSAppKitVersionNumber10_15_2: NSAppKitVersion = 1894.2 as _;

pub static NSAppKitVersionNumber10_15_3: NSAppKitVersion = 1894.3 as _;

pub static NSAppKitVersionNumber10_15_4: NSAppKitVersion = 1894.4 as _;

pub static NSAppKitVersionNumber10_15_5: NSAppKitVersion = 1894.5 as _;

pub static NSAppKitVersionNumber10_15_6: NSAppKitVersion = 1894.6 as _;

pub static NSAppKitVersionNumber11_0: NSAppKitVersion = 2022 as _;

pub static NSAppKitVersionNumber11_1: NSAppKitVersion = 2022.2 as _;

pub static NSAppKitVersionNumber11_2: NSAppKitVersion = 2022.3 as _;

pub static NSAppKitVersionNumber11_3: NSAppKitVersion = 2022.4 as _;

pub static NSAppKitVersionNumber11_4: NSAppKitVersion = 2022.5 as _;

pub static NSAppKitVersionNumber11_5: NSAppKitVersion = 2022.6 as _;

pub static NSAppKitVersionNumber12_0: NSAppKitVersion = 2113 as _;

pub static NSAppKitVersionNumber12_1: NSAppKitVersion = 2113.2 as _;

pub static NSAppKitVersionNumber12_2: NSAppKitVersion = 2113.3 as _;

pub static NSAppKitVersionNumber12_3: NSAppKitVersion = 2113.4 as _;

pub static NSAppKitVersionNumber12_4: NSAppKitVersion = 2113.5 as _;

pub static NSAppKitVersionNumber12_5: NSAppKitVersion = 2113.6 as _;

pub static NSAppKitVersionNumber13_0: NSAppKitVersion = 2299 as _;

pub static NSAppKitVersionNumber13_1: NSAppKitVersion = 2299.3 as _;

pub static NSAppKitVersionNumber13_2: NSAppKitVersion = 2299.3 as _;

pub static NSAppKitVersionNumber13_3: NSAppKitVersion = 2299.4 as _;

pub static NSAppKitVersionNumber13_4: NSAppKitVersion = 2299.5 as _;

pub static NSAppKitVersionNumber13_5: NSAppKitVersion = 2299.6 as _;

pub static NSAppKitVersionNumber13_6: NSAppKitVersion = 2299.7 as _;

pub static NSAppKitVersionNumber14_0: NSAppKitVersion = 2487 as _;

pub static NSAppKitVersionNumber14_1: NSAppKitVersion = 2487.2 as _;

extern "C" {
    /// The mode set when waiting for input from a modal panel, such as a save or open panel.
    pub static NSModalPanelRunLoopMode: &'static NSRunLoopMode;
}

extern "C" {
    /// The mode set when tracking events modally, such as a mouse-dragging loop.
    pub static NSEventTrackingRunLoopMode: &'static NSRunLoopMode;
}

/// A set of button return values for modal dialogs.
///
/// ## Discussion
///
/// The response value that a button returns can depend on which method is used to present the dialog. See [`alertWithMessageText:defaultButton:alternateButton:otherButton:informativeTextWithFormat:`](https://developer.apple.com/documentation/appkit/nsalert/alertwithmessagetext:defaultbutton:alternatebutton:otherbutton:informativetextwithformat:), [`runModal`](https://developer.apple.com/documentation/appkit/nsalert/runmodal()), and [`addButtonWithTitle:`](https://developer.apple.com/documentation/appkit/nsalert/addbutton(withtitle:)) for examples.
///
///
// NS_TYPED_EXTENSIBLE_ENUM
pub type NSModalResponse = NSInteger;

/// Modal session was broken with [`stopModal`](https://developer.apple.com/documentation/appkit/nsapplication/stopmodal()).
///
/// ## Discussion
///
/// This constant is also used as the default response for sheet.
///
///
/// Also used as the default response for sheets
pub static NSModalResponseStop: NSModalResponse = -1000;

/// Modal session was broken with [`abortModal`](https://developer.apple.com/documentation/appkit/nsapplication/abortmodal()).
pub static NSModalResponseAbort: NSModalResponse = -1001;

/// Modal session is continuing (returned by [`runModalSession:`](https://developer.apple.com/documentation/appkit/nsapplication/runmodalsession(_:)) only).
pub static NSModalResponseContinue: NSModalResponse = -1002;

/// Run-loop message priority for handling window updates.
///
/// ## Discussion
///
/// This constant is used by the [`NSRunLoop`](https://developer.apple.com/documentation/foundation/runloop) method [`performSelector:target:argument:order:modes:`](https://developer.apple.com/documentation/foundation/runloop/perform(_:target:argument:order:modes:)).
///
///
pub const NSUpdateWindowsRunLoopOrdering: c_uint = 500000;

/// Constants that control the presentation of the app, typically for fullscreen apps such as games or kiosks.
///
/// ## Overview
///
/// There are restrictions on the combination of presentation options that can be set simultaneously:
///
/// - [`NSApplicationPresentationAutoHideDock`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/autohidedock) and [`NSApplicationPresentationHideDock`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/hidedock) are mutually exclusive: You may specify one or the other, but not both.
///
/// - [`NSApplicationPresentationAutoHideMenuBar`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/autohidemenubar) and [`NSApplicationPresentationHideMenuBar`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/hidemenubar) are mutually exclusive: You may specify one or the other, but not both.
///
/// - If you specify [`NSApplicationPresentationHideMenuBar`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/hidemenubar), it must be accompanied by [`NSApplicationPresentationHideDock`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/hidedock).
///
/// - If you specify [`NSApplicationPresentationAutoHideMenuBar`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/autohidemenubar), it must be accompanied by either [`NSApplicationPresentationHideDock`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/hidedock) or [`NSApplicationPresentationAutoHideDock`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/autohidedock).
///
/// - If you specify any of [`NSApplicationPresentationDisableProcessSwitching`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/disableprocessswitching), [`NSApplicationPresentationDisableForceQuit`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/disableforcequit), [`NSApplicationPresentationDisableSessionTermination`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/disablesessiontermination), or [`NSApplicationPresentationDisableMenuBarTransparency`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/disablemenubartransparency), it must be accompanied by either [`NSApplicationPresentationHideDock`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/hidedock) or [`NSApplicationPresentationAutoHideDock`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/autohidedock).
///
/// - [`NSApplicationPresentationAutoHideToolbar`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/autohidetoolbar) may be used only when both [`NSApplicationPresentationFullScreen`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/fullscreen) and [`NSApplicationPresentationAutoHideMenuBar`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct/autohidemenubar) are also set.
///
/// When [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) receives a parameter value that does not conform to these requirements, it raises an [`NSInvalidArgumentException`](https://developer.apple.com/documentation/foundation/nsexceptionname/invalidargumentexception).
///
///
/// Flags that comprise an application's
/// `presentationOptions.`
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSApplicationPresentationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSApplicationPresentationOptions: NSUInteger {
/// This is the default presentation mode.
///
/// ## Discussion
///
/// In the default presentation mode, the dock icon and menu bar are displayed, process switching, force quit, session termination, and the “Hide” menu option are all enabled, and the menu bar transparency is normal.
///
///
        #[doc(alias = "NSApplicationPresentationDefault")]
        const Default = 0;
/// The dock is normally hidden, but automatically appears when moused near.
/// Dock appears when moused to.
        #[doc(alias = "NSApplicationPresentationAutoHideDock")]
        const AutoHideDock = 1<<0;
/// The dock is entirely hidden and disabled.
/// Dock is entirely unavailable.
        #[doc(alias = "NSApplicationPresentationHideDock")]
        const HideDock = 1<<1;
/// The menu bar is normally hidden, but automatically appears when moused near.
/// Menu Bar appears when moused to.
        #[doc(alias = "NSApplicationPresentationAutoHideMenuBar")]
        const AutoHideMenuBar = 1<<2;
/// The menu bar is entirely hidden and disabled.
/// Menu Bar is entirely unavailable.
        #[doc(alias = "NSApplicationPresentationHideMenuBar")]
        const HideMenuBar = 1<<3;
/// All Apple Menu items are disabled.
/// All Apple menu items are disabled.
        #[doc(alias = "NSApplicationPresentationDisableAppleMenu")]
        const DisableAppleMenu = 1<<4;
/// The process switching user interface (Command + Tab to cycle through apps) is disabled.
/// Cmd+Tab UI is disabled.
        #[doc(alias = "NSApplicationPresentationDisableProcessSwitching")]
        const DisableProcessSwitching = 1<<5;
/// The force quit panel (displayed by pressing Command + Option + Esc) is disabled
/// Cmd+Opt+Esc panel is disabled.
        #[doc(alias = "NSApplicationPresentationDisableForceQuit")]
        const DisableForceQuit = 1<<6;
/// The panel that shows the Restart, Shut Down, and Log Out options that are displayed as a result of pushing the power key is disabled.
/// PowerKey panel and Restart/Shut Down/Log Out disabled.
        #[doc(alias = "NSApplicationPresentationDisableSessionTermination")]
        const DisableSessionTermination = 1<<7;
/// The app’s “Hide” menu item is disabled.
/// Application "Hide" menu item is disabled.
        #[doc(alias = "NSApplicationPresentationDisableHideApplication")]
        const DisableHideApplication = 1<<8;
/// The menu bar transparency appearance is disabled.
/// Menu Bar's transparent appearance is disabled.
        #[doc(alias = "NSApplicationPresentationDisableMenuBarTransparency")]
        const DisableMenuBarTransparency = 1<<9;
/// The app is in fullscreen mode.
/// Application is in fullscreen mode.
        #[doc(alias = "NSApplicationPresentationFullScreen")]
        const FullScreen = 1<<10;
/// When in fullscreen mode the window toolbar is detached from window and hides and shows with autoHidden menuBar.
/// Fullscreen window toolbar is detached from window and hides/shows on rollover.
/// May be used only when both
/// `NSApplicationPresentationFullScreen`is also set.
        #[doc(alias = "NSApplicationPresentationAutoHideToolbar")]
        const AutoHideToolbar = 1<<11;
/// The behavior that allows the user to shake the mouse to locate the cursor is disabled.
/// "Shake mouse pointer to locate" is disabled for this application.
        #[doc(alias = "NSApplicationPresentationDisableCursorLocationAssistance")]
        const DisableCursorLocationAssistance = 1<<12;
    }
}

unsafe impl Encode for NSApplicationPresentationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationPresentationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This constant indicates whether at least part of any window owned by this app is visible.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSApplicationOcclusionState(pub NSUInteger);
bitflags::bitflags! {
    impl NSApplicationOcclusionState: NSUInteger {
/// If set, at least part of any window owned by this app is visible.
///
/// ## Discussion
///
/// If not set, all parts of all windows owned by this app are completely occluded. The menu bar does not count as a window owned by this app, so if only the menu bar is showing then the app is considered not visible. Status items, however, have windows owned by your app. If the status item is present in the menu bar, your app will be considered visible as long as the menu bar is visible.
///
///
/// If set, at least part of any window owned by this application is visible. If not set, all parts of all windows owned by this application are completely occluded. The menu bar does not count as a window owned by this application, so if only the menu bar is showing then the application is considered not visible. Status items, however, have windows owned by your application. If the status item is present in the menu bar, your application will be considered visible as long as the menu bar is visible.
        #[doc(alias = "NSApplicationOcclusionStateVisible")]
        const Visible = 1<<1;
    }
}

unsafe impl Encode for NSApplicationOcclusionState {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationOcclusionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This constant indicates a window ordering.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSWindowListOptions(pub NSInteger);
bitflags::bitflags! {
    impl NSWindowListOptions: NSInteger {
/// The app’s onscreen windows in front-to-back order. By default, [`windows`](https://developer.apple.com/documentation/appkit/nsapplication/windows) is used.
/// Onscreen application windows in front to back order. By default, -[NSApp windows] is used.
        #[doc(alias = "NSWindowListOrderedFrontToBack")]
        const OrderedFrontToBack = 1<<0;
    }
}

unsafe impl Encode for NSWindowListOptions {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSWindowListOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Debug)]
pub struct _NSModalSession {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for _NSModalSession {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("_NSModalSession", &[]));
}

/// Variables of type `NSModalSession` point to information used by the system between `NSApplication`’s [`beginModalSessionForWindow:`](https://developer.apple.com/documentation/appkit/nsapplication/beginmodalsession(for:)) and [`endModalSession:`](https://developer.apple.com/documentation/appkit/nsapplication/endmodalsession(_:)) messages.
/// Information used by the system during modal sessions.
pub type NSModalSession = *mut _NSModalSession;

/// These constants specify the level of severity of a user attention request and are used by [`cancelUserAttentionRequest:`](https://developer.apple.com/documentation/appkit/nsapplication/canceluserattentionrequest(_:)) and [`requestUserAttention:`](https://developer.apple.com/documentation/appkit/nsapplication/requestuserattention(_:)).
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSRequestUserAttentionType(pub NSUInteger);
impl NSRequestUserAttentionType {
    /// The user attention request is a critical request.
    ///
    /// ## Discussion
    ///
    /// The dock icon will bounce until either the app becomes active or the request is canceled.
    ///
    ///
    #[doc(alias = "NSCriticalRequest")]
    pub const CriticalRequest: Self = Self(0);
    /// The user attention request is an informational request.
    ///
    /// ## Discussion
    ///
    /// The dock icon will bounce for one second. The request, though, remains active until either the app becomes active or the request is canceled.
    ///
    ///
    #[doc(alias = "NSInformationalRequest")]
    pub const InformationalRequest: Self = Self(10);
}

unsafe impl Encode for NSRequestUserAttentionType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSRequestUserAttentionType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that indicate whether a copy or print operation was successful, was canceled, or failed.
///
/// ## Overview
///
/// These constants are used by the [`replyToOpenOrPrint:`](https://developer.apple.com/documentation/appkit/nsapplication/reply(toopenorprint:)) method.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSApplicationDelegateReply(pub NSUInteger);
impl NSApplicationDelegateReply {
    /// Indicates the operation succeeded.
    #[doc(alias = "NSApplicationDelegateReplySuccess")]
    pub const Success: Self = Self(0);
    /// Indicates the user cancelled the operation.
    #[doc(alias = "NSApplicationDelegateReplyCancel")]
    pub const Cancel: Self = Self(1);
    /// Indicates an error occurred processing the operation.
    #[doc(alias = "NSApplicationDelegateReplyFailure")]
    pub const Failure: Self = Self(2);
}

unsafe impl Encode for NSApplicationDelegateReply {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationDelegateReply {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that manages an app’s main event loop and resources used by all of that app’s objects.
    ///
    /// ## Overview
    ///
    /// Every app uses a single instance of [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) to control the main event loop, keep track of the app’s windows and menus, distribute events to the appropriate objects (that’s, itself or one of its windows), set up autorelease pools, and receive notification of app-level events. An [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) object has a delegate (an object that you assign) that’s notified when the app starts or terminates, is hidden or activated, should open a file selected by the user, and so forth. By setting the delegate and implementing the delegate methods, you customize the behavior of your app without having to subclass [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication). In your app’s `main()` function, create the [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) instance by calling the [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared) class method. After creating the application object, the `main()` function should load your app’s main nib file and then start the event loop by sending the application object a [`run`](https://developer.apple.com/documentation/appkit/nsapplication/run()) message. If you create an Application project in Xcode, this `main()` function is created for you. The `main()` function Xcode creates begins by calling a function named `NSApplicationMain()`, which is functionally similar to the following:
    ///
    /// ```objc
    /// void NSApplicationMain(int argc, char *argv[]) {
    ///     [NSApplication sharedApplication];
    ///     [NSBundle loadNibNamed:@"myMain" owner:NSApp];
    ///     [NSApp run];
    /// }
    /// ```
    ///
    /// The [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared) class method initializes the display environment and connects your program to the window server and the display server. The [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) object maintains a list of all the [`NSWindow`](https://developer.apple.com/documentation/appkit/nswindow) objects the app uses, so it can retrieve any of the app’s [`NSView`](https://developer.apple.com/documentation/appkit/nsview) objects. The [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared) method also initializes the global variable `NSApp`, which you use to retrieve the [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) instance. [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared) only performs the initialization once. If you invoke it more than once, it returns the application object it created previously.
    ///
    /// The shared [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) object performs the important task of receiving events from the window server and distributing them to the proper [`NSResponder`](https://developer.apple.com/documentation/appkit/nsresponder) objects. `NSApp` translates an event into an [`NSEvent`](https://developer.apple.com/documentation/appkit/nsevent) object, then forwards the event object to the affected [`NSWindow`](https://developer.apple.com/documentation/appkit/nswindow) object. All keyboard and mouse events go directly to the [`NSWindow`](https://developer.apple.com/documentation/appkit/nswindow) object associated with the event. The only exception to this rule is if the Command key is pressed when a key-down event occurs; in this case, every [`NSWindow`](https://developer.apple.com/documentation/appkit/nswindow) object has an opportunity to respond to the event. When a window object receives an [`NSEvent`](https://developer.apple.com/documentation/appkit/nsevent) object from `NSApp`, it distributes it to the objects in its view hierarchy.
    ///
    /// [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) is also responsible for dispatching certain Apple events received by the app. For example, macOS sends Apple events to your app at various times, such as when the app is launched or reopened. [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) installs Apple event handlers to handle these events by sending a message to the appropriate object. You can also use the [`NSAppleEventManager`](https://developer.apple.com/documentation/foundation/nsappleeventmanager) class to register your own Apple event handlers. The [`applicationWillFinishLaunching:`](https://developer.apple.com/documentation/appkit/nsapplicationdelegate/applicationwillfinishlaunching(_:)) method is generally the best place to do so. For more information on how events are handled and how you can modify the default behavior, including information on working with Apple events in scriptable apps, see [How Cocoa Applications Handle Apple Events](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ScriptableCocoaApplications/SApps_handle_AEs/SAppsHandleAEs.html#//apple_ref/doc/uid/20001239) in [Cocoa Scripting Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ScriptableCocoaApplications/SApps_intro/SAppsIntro.html#//apple_ref/doc/uid/TP40002164).
    ///
    /// The [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) class sets up `@autorelease` block during initialization and inside the event loop—specifically, within its initialization (or [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared)) and [`run`](https://developer.apple.com/documentation/appkit/nsapplication/run()) methods. Similarly, the methods AppKit adds to [`NSBundle`](https://developer.apple.com/documentation/foundation/bundle) employ `@autorelease` blocks during the loading of nib files. These `@autorelease` blocks aren’t accessible outside the scope of the respective [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) and [`NSBundle`](https://developer.apple.com/documentation/foundation/bundle) methods. Typically, an app creates objects either while the event loop is running or by loading objects from nib files, so this lack of access usually isn’t a problem. However, if you do need to use Cocoa classes within the `main()` function itself (other than to load nib files or to instantiate [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication)), you should create an `@autorelease` block to contain the code using the classes.
    ///
    /// ### The delegate and notifications
    ///
    /// You can assign a delegate to your [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) object. The delegate responds to certain messages on behalf of the object. Some of these messages, such as [`application:openFile:`](https://developer.apple.com/documentation/appkit/nsapplicationdelegate/application(_:openfile:)), ask the delegate to perform an action. Another message, [`applicationShouldTerminate:`](https://developer.apple.com/documentation/appkit/nsapplicationdelegate/applicationshouldterminate(_:)), lets the delegate determine whether the app should be allowed to quit. The [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) class sends these messages directly to its delegate.
    ///
    /// [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) also posts notifications to the app’s default notification center. Any object may register to receive one or more of the notifications posted by [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) by sending the message [`addObserver:selector:name:object:`](https://developer.apple.com/documentation/foundation/notificationcenter/addobserver(_:selector:name:object:)) to the default notification center (an instance of the `NSNotificationCenter` class). The delegate of [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) is automatically registered to receive these notifications if it implements certain delegate methods. For example, [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) posts notifications when it’s about to be done launching the app and when it’s done launching the app ([`NSApplicationWillFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/willfinishlaunchingnotification) and [`NSApplicationDidFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/didfinishlaunchingnotification)). The delegate has an opportunity to respond to these notifications by implementing the methods [`applicationWillFinishLaunching:`](https://developer.apple.com/documentation/appkit/nsapplicationdelegate/applicationwillfinishlaunching(_:)) and [`applicationDidFinishLaunching:`](https://developer.apple.com/documentation/appkit/nsapplicationdelegate/applicationdidfinishlaunching(_:)). If the delegate wants to be informed of both events, it implements both methods. If it needs to know only when the app is finished launching, it implements only [`applicationDidFinishLaunching:`](https://developer.apple.com/documentation/appkit/nsapplicationdelegate/applicationdidfinishlaunching(_:)).
    ///
    /// ### System services
    ///
    /// `NSApplication` interacts with the system services architecture to provide services to your app through the Services menu.
    ///
    /// ### Subclassing notes
    ///
    /// You rarely should find a real need to create a custom `NSApplication` subclass. Unlike some object-oriented libraries, Cocoa doesn’t require you to subclass `NSApplication` to customize app behavior. Instead it gives you many other ways to customize an app. This section discusses both some of the possible reasons to subclass `NSApplication` and some of the reasons _not_ to subclass `NSApplication`.
    ///
    /// To use a custom subclass of `NSApplication`, send [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared) to your subclass rather than directly to `NSApplication`. If you create your app in Xcode, you can accomplish this by setting your custom app class to be the principal class. In Xcode, double-click the app target in the Groups and Files list to open the Info window for the target. Then display the Properties pane of the window and replace “NSApplication” in the Principal Class field with the name of your custom class. The `NSApplicationMain` function sends [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared) to the principal class to obtain the global app instance (`NSApp`)—which in this case will be an instance of your custom subclass of `NSApplication`.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Many AppKit classes rely on the `NSApplication` class and may not work properly until this class is fully initialized. As a result, you should not, for example, attempt to invoke methods of other AppKit classes from an initialization method of an `NSApplication` subclass.
    ///
    ///
    ///
    /// </div>
    /// #### Methods to override
    ///
    /// Generally, you subclass `NSApplication` to provide your own special responses to messages that are routinely sent to the global app object (`NSApp`). `NSApplication` doesn’t have primitive methods in the sense of methods that you must override in your subclass. Here are four methods that are possible candidates for overriding:
    ///
    /// - Override [`run`](https://developer.apple.com/documentation/appkit/nsapplication/run()) if you want the app to manage the main event loop differently than it does by default. (This a critical and complex task, however, that you should only attempt with good reason).
    ///
    /// - Override [`sendEvent:`](https://developer.apple.com/documentation/appkit/nsapplication/sendevent(_:)) if you want to change how events are dispatched or perform some special event processing.
    ///
    /// - Override [`requestUserAttention:`](https://developer.apple.com/documentation/appkit/nsapplication/requestuserattention(_:)) if you want to modify how your app attracts the attention of the user (for example, offering an alternative to the bouncing app icon in the Dock).
    ///
    /// - Override [`targetForAction:`](https://developer.apple.com/documentation/appkit/nsapplication/target(foraction:)) to substitute another object for the target of an action message.
    ///
    /// #### Special considerations
    ///
    /// The global app object uses `@autorelease` blocks in its [`run`](https://developer.apple.com/documentation/appkit/nsapplication/run()) method; if you override this method, you’ll need to create your own `@autorelease` blocks.
    ///
    /// Do not override [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared). The default implementation, which is essential to app behavior, is too complex to duplicate on your own.
    ///
    /// #### Alternatives to subclassing
    ///
    /// `NSApplication` defines numerous [Delegation](https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Delegation.html#//apple_ref/doc/uid/TP40008195-CH14) methods that offer opportunities for modifying specific aspects of app behavior. Instead of making a custom subclass of `NSApplication`, your app delegate may be able to implement one or more of these methods to accomplish your design goals. In general, a better design than subclassing `NSApplication` is to put the code that expresses your app’s special behavior into one or more custom objects called controllers. Methods defined in your controllers can be invoked from a small dispatcher object without being closely tied to the global app object.
    ///
    ///
    #[unsafe(super(NSResponder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSResponder")]
    pub struct NSApplication;
);

#[cfg(all(feature = "NSAccessibilityProtocols", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSAccessibility for NSApplication {}
);

#[cfg(all(feature = "NSAccessibilityProtocols", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSAccessibilityElementProtocol for NSApplication {}
);

#[cfg(feature = "NSResponder")]
extern_conformance!(
    unsafe impl NSCoding for NSApplication {}
);

#[cfg(all(feature = "NSMenu", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSMenuItemValidation for NSApplication {}
);

#[cfg(feature = "NSResponder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSApplication {}
);

#[cfg(all(feature = "NSResponder", feature = "NSUserInterfaceValidation"))]
extern_conformance!(
    unsafe impl NSUserInterfaceValidations for NSApplication {}
);

#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[unsafe(method(sharedApplication))]
        #[unsafe(method_family = none)]
        pub fn sharedApplication(mtm: MainThreadMarker) -> Retained<NSApplication>;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSApplicationDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSApplicationDelegate>>);

        #[unsafe(method(hide:))]
        #[unsafe(method_family = none)]
        pub fn hide(&self, sender: Option<&AnyObject>);

        #[unsafe(method(unhide:))]
        #[unsafe(method_family = none)]
        pub fn unhide(&self, sender: Option<&AnyObject>);

        #[unsafe(method(unhideWithoutActivation))]
        #[unsafe(method_family = none)]
        pub fn unhideWithoutActivation(&self);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(windowWithWindowNumber:))]
        #[unsafe(method_family = none)]
        pub fn windowWithWindowNumber(&self, window_num: NSInteger) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(mainWindow))]
        #[unsafe(method_family = none)]
        pub fn mainWindow(&self) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(keyWindow))]
        #[unsafe(method_family = none)]
        pub fn keyWindow(&self) -> Option<Retained<NSWindow>>;

        #[unsafe(method(isActive))]
        #[unsafe(method_family = none)]
        pub fn isActive(&self) -> bool;

        #[unsafe(method(isHidden))]
        #[unsafe(method_family = none)]
        pub fn isHidden(&self) -> bool;

        #[unsafe(method(isRunning))]
        #[unsafe(method_family = none)]
        pub fn isRunning(&self) -> bool;

        /// A boolean value indicating whether your application should suppress HDR content based on established policy.
        /// Built-in AppKit components such as NSImageView will automatically behave correctly with HDR content. You should use this value in conjunction with notifications (`NSApplicationShouldBeginSuppressingHighDynamicRangeContentNotification` and `NSApplicationShouldEndSuppressingHighDynamicRangeContentNotification`) to suppress HDR content in your application when signaled to do so.
        #[unsafe(method(applicationShouldSuppressHighDynamicRangeContent))]
        #[unsafe(method_family = none)]
        pub fn applicationShouldSuppressHighDynamicRangeContent(&self) -> bool;

        #[unsafe(method(deactivate))]
        #[unsafe(method_family = none)]
        pub fn deactivate(&self);

        /// Makes the receiver the active app.
        /// - Parameter ignoreOtherApps: If `NO`, the app is activated only if no other app is currently active. If `YES`, the app activates regardless.
        #[deprecated = "This method will be deprecated in a future release. Use NSApp.activate instead."]
        #[unsafe(method(activateIgnoringOtherApps:))]
        #[unsafe(method_family = none)]
        pub fn activateIgnoringOtherApps(&self, ignore_other_apps: bool);

        /// Makes the receiver the active app, if possible.
        ///
        /// You shouldn’t assume the app will be active immediately
        /// after sending this message. The framework also does not
        /// guarantee that the app will be activated at all.
        ///
        /// For cooperative activation, the other application should
        /// call `-yieldActivationToApplication:` or equivalent prior
        /// to the target application invoking `-activate`.
        ///
        /// Invoking `-activate` on an already-active application
        /// cancels any pending activation yields by the receiver.
        #[unsafe(method(activate))]
        #[unsafe(method_family = none)]
        pub fn activate(&self);

        #[cfg(feature = "NSRunningApplication")]
        /// Explicitly allows another application to make itself active.
        ///
        /// Calling this method will not deactivate the current app, nor
        /// will it activate the other app. For cooperative or coordinated
        /// activation, the other app should request to be activated at
        /// some point in the future by calling `activate` or equivalent.
        #[unsafe(method(yieldActivationToApplication:))]
        #[unsafe(method_family = none)]
        pub fn yieldActivationToApplication(&self, application: &NSRunningApplication);

        /// Same as `-yieldActivationToApplication:`, but the provided
        /// bundle identifier does not have to correspond to a currently
        /// running application.
        ///
        /// This method should be used to yield activation to apps that
        /// may not be running at the time of invoking it. If it is known
        /// that the target application is currently running, use
        /// `-yieldActivationToApplication:` instead.
        #[unsafe(method(yieldActivationToApplicationWithBundleIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn yieldActivationToApplicationWithBundleIdentifier(
            &self,
            bundle_identifier: &NSString,
        );

        #[unsafe(method(hideOtherApplications:))]
        #[unsafe(method_family = none)]
        pub fn hideOtherApplications(&self, sender: Option<&AnyObject>);

        #[unsafe(method(unhideAllApplications:))]
        #[unsafe(method_family = none)]
        pub fn unhideAllApplications(&self, sender: Option<&AnyObject>);

        #[unsafe(method(finishLaunching))]
        #[unsafe(method_family = none)]
        pub fn finishLaunching(&self);

        #[unsafe(method(run))]
        #[unsafe(method_family = none)]
        pub fn run(&self);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(runModalForWindow:))]
        #[unsafe(method_family = none)]
        pub fn runModalForWindow(&self, window: &NSWindow) -> NSModalResponse;

        #[unsafe(method(stop:))]
        #[unsafe(method_family = none)]
        pub fn stop(&self, sender: Option<&AnyObject>);

        #[unsafe(method(stopModal))]
        #[unsafe(method_family = none)]
        pub fn stopModal(&self);

        #[unsafe(method(stopModalWithCode:))]
        #[unsafe(method_family = none)]
        pub fn stopModalWithCode(&self, return_code: NSModalResponse);

        #[unsafe(method(abortModal))]
        #[unsafe(method_family = none)]
        pub fn abortModal(&self);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(modalWindow))]
        #[unsafe(method_family = none)]
        pub fn modalWindow(&self) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(beginModalSessionForWindow:))]
        #[unsafe(method_family = none)]
        pub fn beginModalSessionForWindow(&self, window: &NSWindow) -> NSModalSession;

        /// # Safety
        ///
        /// `session` must be a valid pointer.
        #[unsafe(method(runModalSession:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runModalSession(&self, session: NSModalSession) -> NSModalResponse;

        /// # Safety
        ///
        /// `session` must be a valid pointer.
        #[unsafe(method(endModalSession:))]
        #[unsafe(method_family = none)]
        pub unsafe fn endModalSession(&self, session: NSModalSession);

        #[unsafe(method(terminate:))]
        #[unsafe(method_family = none)]
        pub fn terminate(&self, sender: Option<&AnyObject>);

        /// Inform the user that this application needs attention - call this method only if your application is not already active.
        #[unsafe(method(requestUserAttention:))]
        #[unsafe(method_family = none)]
        pub fn requestUserAttention(&self, request_type: NSRequestUserAttentionType) -> NSInteger;

        #[unsafe(method(cancelUserAttentionRequest:))]
        #[unsafe(method_family = none)]
        pub fn cancelUserAttentionRequest(&self, request: NSInteger);

        #[cfg(all(feature = "NSWindow", feature = "block2"))]
        /// Execute a block for each of the app's windows. Set `*stop = YES` if desired, to halt the enumeration early.
        #[unsafe(method(enumerateWindowsWithOptions:usingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateWindowsWithOptions_usingBlock(
            &self,
            options: NSWindowListOptions,
            block: &block2::DynBlock<dyn Fn(NonNull<NSWindow>, NonNull<Bool>) + '_>,
        );

        #[unsafe(method(preventWindowOrdering))]
        #[unsafe(method_family = none)]
        pub fn preventWindowOrdering(&self);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(windows))]
        #[unsafe(method_family = none)]
        pub fn windows(&self) -> Retained<NSArray<NSWindow>>;

        #[unsafe(method(setWindowsNeedUpdate:))]
        #[unsafe(method_family = none)]
        pub fn setWindowsNeedUpdate(&self, need_update: bool);

        #[unsafe(method(updateWindows))]
        #[unsafe(method_family = none)]
        pub fn updateWindows(&self);

        #[cfg(feature = "NSMenu")]
        #[unsafe(method(mainMenu))]
        #[unsafe(method_family = none)]
        pub fn mainMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        /// Setter for [`mainMenu`][Self::mainMenu].
        #[unsafe(method(setMainMenu:))]
        #[unsafe(method_family = none)]
        pub fn setMainMenu(&self, main_menu: Option<&NSMenu>);

        #[cfg(feature = "NSMenu")]
        /// Set or get the Help menu for the app.  If a non-nil menu is set as the Help menu, Spotlight for Help will be installed in it; otherwise AppKit will install Spotlight for Help into a menu of its choosing (and that menu is not returned from `-helpMenu`).  If you wish to completely suppress Spotlight for Help, you can set a menu that does not appear in the menu bar.
        /// `NSApplication`retains its Help menu and releases it when a different menu is set.
        #[unsafe(method(helpMenu))]
        #[unsafe(method_family = none)]
        pub fn helpMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        /// Setter for [`helpMenu`][Self::helpMenu].
        #[unsafe(method(setHelpMenu:))]
        #[unsafe(method_family = none)]
        pub fn setHelpMenu(&self, help_menu: Option<&NSMenu>);

        #[cfg(feature = "NSImage")]
        #[unsafe(method(applicationIconImage))]
        #[unsafe(method_family = none)]
        pub fn applicationIconImage(&self) -> Option<Retained<NSImage>>;

        #[cfg(feature = "NSImage")]
        /// Setter for [`applicationIconImage`][Self::applicationIconImage].
        ///
        /// # Safety
        ///
        /// `application_icon_image` might not allow `None`.
        #[unsafe(method(setApplicationIconImage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setApplicationIconImage(&self, application_icon_image: Option<&NSImage>);

        #[cfg(feature = "NSRunningApplication")]
        /// Returns: The activation policy of the application.
        #[unsafe(method(activationPolicy))]
        #[unsafe(method_family = none)]
        pub fn activationPolicy(&self) -> NSApplicationActivationPolicy;

        #[cfg(feature = "NSRunningApplication")]
        /// Attempts to modify the application's activation policy.  In OS X 10.9, any policy may be set; prior to 10.9, the activation policy may be changed to
        /// `NSApplicationActivationPolicyProhibited`or
        /// `NSApplicationActivationPolicyRegular,`but may not be changed to
        /// `NSApplicationActivationPolicyAccessory.`This returns
        /// `YES`if setting the activation policy is successful, and
        /// `NO`if not.
        #[unsafe(method(setActivationPolicy:))]
        #[unsafe(method_family = none)]
        pub fn setActivationPolicy(&self, activation_policy: NSApplicationActivationPolicy)
            -> bool;

        #[cfg(feature = "NSDockTile")]
        #[unsafe(method(dockTile))]
        #[unsafe(method_family = none)]
        pub fn dockTile(&self) -> Retained<NSDockTile>;

        #[unsafe(method(reportException:))]
        #[unsafe(method_family = none)]
        pub fn reportException(&self, exception: &NSException);

        /// # Safety
        ///
        /// - `selector` must be a valid selector.
        /// - `target` should be of the correct type.
        /// - `argument` should be of the correct type.
        #[unsafe(method(detachDrawingThread:toTarget:withObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn detachDrawingThread_toTarget_withObject(
            selector: Sel,
            target: &AnyObject,
            argument: Option<&AnyObject>,
            mtm: MainThreadMarker,
        );

        /// If an application delegate returns NSTerminateLater from -applicationShouldTerminate:, -replyToApplicationShouldTerminate: must be called with YES or NO once the application decides if it can terminate.
        #[unsafe(method(replyToApplicationShouldTerminate:))]
        #[unsafe(method_family = none)]
        pub fn replyToApplicationShouldTerminate(&self, should_terminate: bool);

        /// If an application delegate encounters an error while handling `-application:openFiles:` or` -application:printFiles:`, `-replyToOpenOrPrint:` should be called with
        /// `NSApplicationDelegateReplyFailure.`If the user cancels the operation,
        /// `NSApplicationDelegateReplyCancel`should be used, and if the operation succeeds,
        /// `NSApplicationDelegateReplySuccess`should be used .
        #[unsafe(method(replyToOpenOrPrint:))]
        #[unsafe(method_family = none)]
        pub fn replyToOpenOrPrint(&self, reply: NSApplicationDelegateReply);

        /// Opens the character palette.
        #[unsafe(method(orderFrontCharacterPalette:))]
        #[unsafe(method_family = none)]
        pub fn orderFrontCharacterPalette(&self, sender: Option<&AnyObject>);

        /// Gets or sets the
        /// `presentationOptions`that should be in effect for the system when this application is the active application.  Only certain combinations of
        /// `NSApplicationPresentationOptions`flags are allowed, as detailed in the AppKit Release Notes and the reference documentation for `-setPresentationOptions:`.  When given an invalid combination of option flags, `-setPresentationOptions:` raises an exception.
        #[unsafe(method(presentationOptions))]
        #[unsafe(method_family = none)]
        pub fn presentationOptions(&self) -> NSApplicationPresentationOptions;

        /// Setter for [`presentationOptions`][Self::presentationOptions].
        #[unsafe(method(setPresentationOptions:))]
        #[unsafe(method_family = none)]
        pub fn setPresentationOptions(
            &self,
            presentation_options: NSApplicationPresentationOptions,
        );

        /// Returns: The set of application presentation options that are currently in effect for the system.
        /// These are the presentation options that have been put into effect by the currently active application.
        #[unsafe(method(currentSystemPresentationOptions))]
        #[unsafe(method_family = none)]
        pub fn currentSystemPresentationOptions(&self) -> NSApplicationPresentationOptions;

        #[unsafe(method(occlusionState))]
        #[unsafe(method_family = none)]
        pub fn occlusionState(&self) -> NSApplicationOcclusionState;

        #[unsafe(method(isProtectedDataAvailable))]
        #[unsafe(method_family = none)]
        pub fn isProtectedDataAvailable(&self) -> bool;
    );
}

/// Methods declared on superclass `NSResponder`.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// NSAppearanceCustomization.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[cfg(feature = "NSAppearance")]
        #[unsafe(method(appearance))]
        #[unsafe(method_family = none)]
        pub fn appearance(&self) -> Option<Retained<NSAppearance>>;

        #[cfg(feature = "NSAppearance")]
        /// Setter for [`appearance`][Self::appearance].
        #[unsafe(method(setAppearance:))]
        #[unsafe(method_family = none)]
        pub fn setAppearance(&self, appearance: Option<&NSAppearance>);

        #[cfg(feature = "NSAppearance")]
        #[unsafe(method(effectiveAppearance))]
        #[unsafe(method_family = none)]
        pub fn effectiveAppearance(&self) -> Retained<NSAppearance>;
    );
}

#[cfg(all(feature = "NSAppearance", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSAppearanceCustomization for NSApplication {}
);

/// NSEvent.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[cfg(feature = "NSEvent")]
        #[unsafe(method(sendEvent:))]
        #[unsafe(method_family = none)]
        pub fn sendEvent(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(postEvent:atStart:))]
        #[unsafe(method_family = none)]
        pub fn postEvent_atStart(&self, event: &NSEvent, at_start: bool);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(currentEvent))]
        #[unsafe(method_family = none)]
        pub fn currentEvent(&self) -> Option<Retained<NSEvent>>;

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(nextEventMatchingMask:untilDate:inMode:dequeue:))]
        #[unsafe(method_family = none)]
        pub fn nextEventMatchingMask_untilDate_inMode_dequeue(
            &self,
            mask: NSEventMask,
            expiration: Option<&NSDate>,
            mode: &NSRunLoopMode,
            deq_flag: bool,
        ) -> Option<Retained<NSEvent>>;

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(discardEventsMatchingMask:beforeEvent:))]
        #[unsafe(method_family = none)]
        pub fn discardEventsMatchingMask_beforeEvent(
            &self,
            mask: NSEventMask,
            last_event: Option<&NSEvent>,
        );
    );
}

/// NSResponder.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        /// # Safety
        ///
        /// - `action` must be a valid selector.
        /// - `target` should be of the correct type.
        /// - `sender` should be of the correct type.
        #[unsafe(method(sendAction:to:from:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendAction_to_from(
            &self,
            action: Sel,
            target: Option<&AnyObject>,
            sender: Option<&AnyObject>,
        ) -> bool;

        /// # Safety
        ///
        /// `action` must be a valid selector.
        #[unsafe(method(targetForAction:))]
        #[unsafe(method_family = none)]
        pub unsafe fn targetForAction(&self, action: Sel) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// - `action` must be a valid selector.
        /// - `target` should be of the correct type.
        /// - `sender` should be of the correct type.
        #[unsafe(method(targetForAction:to:from:))]
        #[unsafe(method_family = none)]
        pub unsafe fn targetForAction_to_from(
            &self,
            action: Sel,
            target: Option<&AnyObject>,
            sender: Option<&AnyObject>,
        ) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// - `action` must be a valid selector.
        /// - `object` should be of the correct type.
        #[unsafe(method(tryToPerform:with:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tryToPerform_with(&self, action: Sel, object: Option<&AnyObject>) -> bool;

        #[cfg(feature = "NSPasteboard")]
        #[unsafe(method(validRequestorForSendType:returnType:))]
        #[unsafe(method_family = none)]
        pub fn validRequestorForSendType_returnType(
            &self,
            send_type: Option<&NSPasteboardType>,
            return_type: Option<&NSPasteboardType>,
        ) -> Option<Retained<AnyObject>>;
    );
}

/// NSWindowsMenu.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[cfg(feature = "NSMenu")]
        #[unsafe(method(windowsMenu))]
        #[unsafe(method_family = none)]
        pub fn windowsMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        /// Setter for [`windowsMenu`][Self::windowsMenu].
        #[unsafe(method(setWindowsMenu:))]
        #[unsafe(method_family = none)]
        pub fn setWindowsMenu(&self, windows_menu: Option<&NSMenu>);

        #[unsafe(method(arrangeInFront:))]
        #[unsafe(method_family = none)]
        pub fn arrangeInFront(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(removeWindowsItem:))]
        #[unsafe(method_family = none)]
        pub fn removeWindowsItem(&self, win: &NSWindow);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(addWindowsItem:title:filename:))]
        #[unsafe(method_family = none)]
        pub fn addWindowsItem_title_filename(
            &self,
            win: &NSWindow,
            string: &NSString,
            is_filename: bool,
        );

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(changeWindowsItem:title:filename:))]
        #[unsafe(method_family = none)]
        pub fn changeWindowsItem_title_filename(
            &self,
            win: &NSWindow,
            string: &NSString,
            is_filename: bool,
        );

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(updateWindowsItem:))]
        #[unsafe(method_family = none)]
        pub fn updateWindowsItem(&self, win: &NSWindow);

        #[unsafe(method(miniaturizeAll:))]
        #[unsafe(method_family = none)]
        pub fn miniaturizeAll(&self, sender: Option<&AnyObject>);
    );
}

/// NSFullKeyboardAccess.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        /// A Boolean value indicating whether keyboard navigation is enabled in System Settings > Keyboard.
        /// - Note: The value of this property is `YES` if keyboard navigation is enabled or `NO` if it’s not. You might use this value to implement your own key loop or to implement in-control tabbing behavior similar to `NSTableView`. Because of the nature of the preference storage, you won’t be notified of changes to this property if you attempt to observe it through key-value observing; however, accessing this property is fairly inexpensive, so you can access it directly rather than caching it.
        /// - Note: This property’s value isn’t necessarily reflective of the separate accessibility setting named “Full Keyboard Access” in System Settings > Accessibility > Keyboard.
        #[unsafe(method(isFullKeyboardAccessEnabled))]
        #[unsafe(method_family = none)]
        pub fn isFullKeyboardAccessEnabled(&self) -> bool;
    );
}

/// Constants that determine whether an app should terminate.
/// Return values for `-applicationShouldTerminate:`.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSApplicationTerminateReply(pub NSUInteger);
impl NSApplicationTerminateReply {
    /// The app should not be terminated.
    #[doc(alias = "NSTerminateCancel")]
    pub const TerminateCancel: Self = Self(0);
    /// It is OK to proceed with termination.
    #[doc(alias = "NSTerminateNow")]
    pub const TerminateNow: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// It may be OK to proceed with termination later. Returning this value causes Cocoa to run the run loop in the [`NSModalPanelRunLoopMode`](https://developer.apple.com/documentation/appkit/nsmodalpanelrunloopmode) until your app subsequently calls [`replyToApplicationShouldTerminate:`](https://developer.apple.com/documentation/appkit/nsapplication/reply(toapplicationshouldterminate:)) with the value [`true`](https://developer.apple.com/documentation/swift/true) or [`false`](https://developer.apple.com/documentation/swift/false). This return value is for delegates that need to provide document modal alerts (sheets) in order to decide whether to quit.
    ///
    ///
    #[doc(alias = "NSTerminateLater")]
    pub const TerminateLater: Self = Self(2);
}

unsafe impl Encode for NSApplicationTerminateReply {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationTerminateReply {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that indicate the outcome of a print request.
/// Return values for `-application:printFiles:withSettings:showPrintPanels:`.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSApplicationPrintReply(pub NSUInteger);
impl NSApplicationPrintReply {
    /// Printing was cancelled.
    #[doc(alias = "NSPrintingCancelled")]
    pub const PrintingCancelled: Self = Self(0);
    /// Printing was successful.
    #[doc(alias = "NSPrintingSuccess")]
    pub const PrintingSuccess: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// The result of printing cannot be returned immediately, for example, if printing will cause the presentation of a sheet. If your method returns `NSPrintingReplyLater` it must always invoke [`replyToOpenOrPrint:`](https://developer.apple.com/documentation/appkit/nsapplication/reply(toopenorprint:)) when the entire print operation has been completed, successfully or not.
    ///
    ///
    #[doc(alias = "NSPrintingReplyLater")]
    pub const PrintingReplyLater: Self = Self(2);
    /// Printing failed.
    #[doc(alias = "NSPrintingFailure")]
    pub const PrintingFailure: Self = Self(3);
}

unsafe impl Encode for NSApplicationPrintReply {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSApplicationPrintReply {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A set of methods that manage your app’s life cycle and its interaction with common system services.
    pub unsafe trait NSApplicationDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "NSResponder")]
        /// Allowable return values are:
        /// `NSTerminateNow`- it is ok to proceed with termination
        /// `NSTerminateCancel`- the application should not be terminated
        /// `NSTerminateLater`- it may be ok to proceed with termination later.  The application must call `-replyToApplicationShouldTerminate:` with
        /// `YES`or
        /// `NO`once the answer is known
        ///
        /// Note: This return value is for delegates who need to provide document modal alerts (sheets) in order to decide whether to quit.
        #[optional]
        #[unsafe(method(applicationShouldTerminate:))]
        #[unsafe(method_family = none)]
        fn applicationShouldTerminate(&self, sender: &NSApplication)
            -> NSApplicationTerminateReply;

        #[cfg(feature = "NSResponder")]
        /// This will be called for any URLs your application is asked to open. This includes URL types (CFBundleURLTypes) defined in your Info.plist, and Document types (
        /// `CFBundleDocumentTypes)`that have no associated
        /// `NSDocument`class. Document URLs that have an associated
        /// `NSDocument`class will be opened through
        /// `NSDocumentController.`If this is implemented, `-application:openFiles:` and `-application:openFile:` will not be called.
        #[optional]
        #[unsafe(method(application:openURLs:))]
        #[unsafe(method_family = none)]
        fn application_openURLs(&self, application: &NSApplication, urls: &NSArray<NSURL>);

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(application:openFile:))]
        #[unsafe(method_family = none)]
        fn application_openFile(&self, sender: &NSApplication, filename: &NSString) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(application:openFiles:))]
        #[unsafe(method_family = none)]
        fn application_openFiles(&self, sender: &NSApplication, filenames: &NSArray<NSString>);

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(application:openTempFile:))]
        #[unsafe(method_family = none)]
        fn application_openTempFile(&self, sender: &NSApplication, filename: &NSString) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(applicationShouldOpenUntitledFile:))]
        #[unsafe(method_family = none)]
        fn applicationShouldOpenUntitledFile(&self, sender: &NSApplication) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(applicationOpenUntitledFile:))]
        #[unsafe(method_family = none)]
        fn applicationOpenUntitledFile(&self, sender: &NSApplication) -> bool;

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[optional]
        #[unsafe(method(application:openFileWithoutUI:))]
        #[unsafe(method_family = none)]
        unsafe fn application_openFileWithoutUI(
            &self,
            sender: &AnyObject,
            filename: &NSString,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(application:printFile:))]
        #[unsafe(method_family = none)]
        fn application_printFile(&self, sender: &NSApplication, filename: &NSString) -> bool;

        #[cfg(all(feature = "NSPrintInfo", feature = "NSResponder"))]
        /// # Safety
        ///
        /// `print_settings` generic should be of the correct type.
        #[optional]
        #[unsafe(method(application:printFiles:withSettings:showPrintPanels:))]
        #[unsafe(method_family = none)]
        unsafe fn application_printFiles_withSettings_showPrintPanels(
            &self,
            application: &NSApplication,
            file_names: &NSArray<NSString>,
            print_settings: &NSDictionary<NSPrintInfoAttributeKey, AnyObject>,
            show_print_panels: bool,
        ) -> NSApplicationPrintReply;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(applicationShouldTerminateAfterLastWindowClosed:))]
        #[unsafe(method_family = none)]
        fn applicationShouldTerminateAfterLastWindowClosed(&self, sender: &NSApplication) -> bool;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(applicationShouldHandleReopen:hasVisibleWindows:))]
        #[unsafe(method_family = none)]
        fn applicationShouldHandleReopen_hasVisibleWindows(
            &self,
            sender: &NSApplication,
            has_visible_windows: bool,
        ) -> bool;

        #[cfg(all(feature = "NSMenu", feature = "NSResponder"))]
        #[optional]
        #[unsafe(method(applicationDockMenu:))]
        #[unsafe(method_family = none)]
        fn applicationDockMenu(&self, sender: &NSApplication) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(application:willPresentError:))]
        #[unsafe(method_family = none)]
        fn application_willPresentError(
            &self,
            application: &NSApplication,
            error: &NSError,
        ) -> Retained<NSError>;

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(application:didRegisterForRemoteNotificationsWithDeviceToken:))]
        #[unsafe(method_family = none)]
        fn application_didRegisterForRemoteNotificationsWithDeviceToken(
            &self,
            application: &NSApplication,
            device_token: &NSData,
        );

        #[cfg(feature = "NSResponder")]
        #[optional]
        #[unsafe(method(application:didFailToRegisterForRemoteNotificationsWithError:))]
        #[unsafe(method_family = none)]
        fn application_didFailToRegisterForRemoteNotificationsWithError(
            &self,
            application: &NSApplication,
            error: &NSError,
        );

        #[cfg(feature = "NSResponder")]
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[optional]
        #[unsafe(method(application:didReceiveRemoteNotification:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didReceiveRemoteNotification(
            &self,
            application: &NSApplication,
            user_info: &NSDictionary<NSString, AnyObject>,
        );

        #[cfg(feature = "NSResponder")]
        /// Method to opt-in to secure restorable state.
        ///
        /// When this returns
        /// `YES:`NSCoders that are passed into the various
        /// `NSWindowRestoration`methods will
        /// `requiresSecureCoding`and have a
        /// `decodingFailurePolicy`of
        /// `NSDecodingFailurePolicySetErrorAndReturn.`Any
        /// `restorationClass`set on a window must explicitly conform to
        /// `NSWindowRestoration.`This method will be called prior to any state encoding or restoration.
        #[optional]
        #[unsafe(method(applicationSupportsSecureRestorableState:))]
        #[unsafe(method_family = none)]
        fn applicationSupportsSecureRestorableState(&self, app: &NSApplication) -> bool;

        #[cfg(feature = "NSResponder")]
        /// Method called by `-[NSApplication encodeRestorableStateWithCoder:]` to give the delegate a chance to encode any additional state into the
        /// `NSCoder.`If the restorable state managed by the delegate changes, you must call `-[NSApplication invalidateRestorableState]` so that it will be re-encoded. See the header `NSWindowRestoration.h` for more information.
        ///
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(application:willEncodeRestorableState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_willEncodeRestorableState(
            &self,
            app: &NSApplication,
            coder: &NSCoder,
        );

        #[cfg(feature = "NSResponder")]
        /// Method called by `-[NSApplication restoreStateWithCoder:]` to give the delegate a chance to restore its own state, which it may decode from the
        /// `NSCoder.`See the header `NSWindowRestoration.h` for more information.
        ///
        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[optional]
        #[unsafe(method(application:didDecodeRestorableState:))]
        #[unsafe(method_family = none)]
        unsafe fn application_didDecodeRestorableState(&self, app: &NSApplication, coder: &NSCoder);

        #[cfg(feature = "NSResponder")]
        /// This will be called on the main thread as soon as the user indicates they want to continue an activity in your application. The
        /// `NSUserActivity`object may not be available instantly, so use this as an opportunity to show the user that an activity will be continued shortly. Return
        /// `YES`to indicate that you are doing so. Return
        /// `NO`(or leave it unimplemented) and AppKit/UIKit will put up a default UI.
        ///
        /// For each `-application:willContinueUserActivityWithType:` invocation, you are guaranteed to get exactly one invocation of `-application:continueUserActivity:restorationHandler:` on success, or `-application:didFailToContinueUserActivityWithType:error:` if an error was encountered.
        #[optional]
        #[unsafe(method(application:willContinueUserActivityWithType:))]
        #[unsafe(method_family = none)]
        fn application_willContinueUserActivityWithType(
            &self,
            application: &NSApplication,
            user_activity_type: &NSString,
        ) -> bool;

        #[cfg(all(
            feature = "NSResponder",
            feature = "NSUserActivity",
            feature = "block2"
        ))]
        /// This will be called on the main thread after the
        /// `NSUserActivity`object is available. Use the data you stored in the NSUserActivity object to re-create what the user was doing.
        ///
        ///
        /// Returns: `YES`to indicate that the activity was handled. Return
        /// `NO`(or leave it unimplemented) and AppKit will attempt to continue the user activity.
        ///
        /// You should create/fetch any restorable objects associated with the user activity, and pass them to the restorationHandler. They will then get the above `-restoreUserActivityState:` method invoked with the user activity. Invoking the
        /// `restorationHandler`is optional. It may be copied and invoked later, but must be invoked on the main thread.
        ///
        /// If this user activity was created automatically by having
        /// `NSUbiquitousDocumentUserActivityType`in a
        /// `CFBundleDocumentTypes`entry, AppKit can automatically restore the NSUserActivity on OS X if NO is returned, or this method is unimplemented. It will do so by creating a document of the appropriate type using the URL stored in the userInfo under the
        /// `NSUserActivityDocumentURLKey.`The document will have `-restoreUserActivity:` called on it.
        #[optional]
        #[unsafe(method(application:continueUserActivity:restorationHandler:))]
        #[unsafe(method_family = none)]
        fn application_continueUserActivity_restorationHandler(
            &self,
            application: &NSApplication,
            user_activity: &NSUserActivity,
            restoration_handler: &block2::DynBlock<
                dyn Fn(NonNull<NSArray<ProtocolObject<dyn NSUserActivityRestoring>>>),
            >,
        ) -> bool;

        #[cfg(feature = "NSResponder")]
        /// There are instances where continuing a
        /// `NSUserActivity`may fail. This will get called on the main thread if it does so. If it is unimplemented, AppKit will present the error.
        #[optional]
        #[unsafe(method(application:didFailToContinueUserActivityWithType:error:))]
        #[unsafe(method_family = none)]
        fn application_didFailToContinueUserActivityWithType_error(
            &self,
            application: &NSApplication,
            user_activity_type: &NSString,
            error: &NSError,
        );

        #[cfg(feature = "NSResponder")]
        /// This will be called on the main thread when a user activity managed by AppKit/UIKit has been updated. You should use this as a last chance to add additional data to the
        /// `userActivity.`
        #[optional]
        #[unsafe(method(application:didUpdateUserActivity:))]
        #[unsafe(method_family = none)]
        fn application_didUpdateUserActivity(
            &self,
            application: &NSApplication,
            user_activity: &NSUserActivity,
        );

        #[cfg(all(feature = "NSResponder", feature = "objc2-cloud-kit"))]
        #[cfg(target_vendor = "apple")]
        /// This will be called on the main thread after the user indicates they want to accept a CloudKit sharing invitation in your application.
        ///
        /// You should use the
        /// `CKShareMetadata`object's
        /// `shareURL`and containerIdentifier to schedule a
        /// `CKAcceptSharesOperation,`then start using the resulting
        /// `CKShare`and its associated record(s), which will appear in the
        /// `CKContainer's`shared database in a zone matching that of the record's owner.
        #[optional]
        #[unsafe(method(application:userDidAcceptCloudKitShareWithMetadata:))]
        #[unsafe(method_family = none)]
        fn application_userDidAcceptCloudKitShareWithMetadata(
            &self,
            application: &NSApplication,
            metadata: &CKShareMetadata,
        );

        #[cfg(feature = "NSResponder")]
        /// Returns: `YES`if the receiving delegate object can respond to key value coding messages for a specific keyed attribute, to-one relationship, or to-many relationship.  Return
        /// `NO`otherwise.
        #[optional]
        #[unsafe(method(application:delegateHandlesKey:))]
        #[unsafe(method_family = none)]
        fn application_delegateHandlesKey(&self, sender: &NSApplication, key: &NSString) -> bool;

        #[cfg(feature = "NSResponder")]
        /// This method will be called once during application launch at `-[NSApplication finishLaunching]`.
        ///
        ///
        /// Returns: `NO`if the receiving delegate object wishes to opt-out of system-wide keyboard shortcut localization for all application-supplied menus. Return
        /// `YES`by default for apps linked against 12.0 and later SDK.
        #[optional]
        #[unsafe(method(applicationShouldAutomaticallyLocalizeKeyEquivalents:))]
        #[unsafe(method_family = none)]
        fn applicationShouldAutomaticallyLocalizeKeyEquivalents(
            &self,
            application: &NSApplication,
        ) -> bool;

        #[optional]
        #[unsafe(method(applicationWillFinishLaunching:))]
        #[unsafe(method_family = none)]
        fn applicationWillFinishLaunching(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationDidFinishLaunching:))]
        #[unsafe(method_family = none)]
        fn applicationDidFinishLaunching(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationWillHide:))]
        #[unsafe(method_family = none)]
        fn applicationWillHide(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationDidHide:))]
        #[unsafe(method_family = none)]
        fn applicationDidHide(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationWillUnhide:))]
        #[unsafe(method_family = none)]
        fn applicationWillUnhide(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationDidUnhide:))]
        #[unsafe(method_family = none)]
        fn applicationDidUnhide(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationWillBecomeActive:))]
        #[unsafe(method_family = none)]
        fn applicationWillBecomeActive(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationDidBecomeActive:))]
        #[unsafe(method_family = none)]
        fn applicationDidBecomeActive(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationWillResignActive:))]
        #[unsafe(method_family = none)]
        fn applicationWillResignActive(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationDidResignActive:))]
        #[unsafe(method_family = none)]
        fn applicationDidResignActive(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationWillUpdate:))]
        #[unsafe(method_family = none)]
        fn applicationWillUpdate(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationDidUpdate:))]
        #[unsafe(method_family = none)]
        fn applicationDidUpdate(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationWillTerminate:))]
        #[unsafe(method_family = none)]
        fn applicationWillTerminate(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationDidChangeScreenParameters:))]
        #[unsafe(method_family = none)]
        fn applicationDidChangeScreenParameters(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationDidChangeOcclusionState:))]
        #[unsafe(method_family = none)]
        fn applicationDidChangeOcclusionState(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationProtectedDataWillBecomeUnavailable:))]
        #[unsafe(method_family = none)]
        fn applicationProtectedDataWillBecomeUnavailable(&self, notification: &NSNotification);

        #[optional]
        #[unsafe(method(applicationProtectedDataDidBecomeAvailable:))]
        #[unsafe(method_family = none)]
        fn applicationProtectedDataDidBecomeAvailable(&self, notification: &NSNotification);
    }
);

/// NSServicesMenu.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[cfg(feature = "NSMenu")]
        #[unsafe(method(servicesMenu))]
        #[unsafe(method_family = none)]
        pub fn servicesMenu(&self) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        /// Setter for [`servicesMenu`][Self::servicesMenu].
        #[unsafe(method(setServicesMenu:))]
        #[unsafe(method_family = none)]
        pub fn setServicesMenu(&self, services_menu: Option<&NSMenu>);

        #[cfg(feature = "NSPasteboard")]
        #[unsafe(method(registerServicesMenuSendTypes:returnTypes:))]
        #[unsafe(method_family = none)]
        pub fn registerServicesMenuSendTypes_returnTypes(
            &self,
            send_types: &NSArray<NSPasteboardType>,
            return_types: &NSArray<NSPasteboardType>,
        );
    );
}

extern_protocol!(
    /// A set of methods that support interaction with items users can share through a sharing service.
    ///
    /// ## Overview
    ///
    /// This informal protocol consists of two methods, [`writeSelectionToPasteboard:types:`](https://developer.apple.com/documentation/appkit/nsservicesmenurequestor/writeselection(to:types:)) and [`readSelectionFromPasteboard:`](https://developer.apple.com/documentation/appkit/nsservicesmenurequestor/readselection(from:)). The first method provides data to a remote service, and the second receives any data the remote service might send back. Both respond to messages that are generated when the user chooses a command from the Services menu.
    ///
    ///
    pub unsafe trait NSServicesMenuRequestor: NSObjectProtocol {
        #[cfg(feature = "NSPasteboard")]
        #[optional]
        #[unsafe(method(writeSelectionToPasteboard:types:))]
        #[unsafe(method_family = none)]
        fn writeSelectionToPasteboard_types(
            &self,
            pboard: &NSPasteboard,
            types: &NSArray<NSPasteboardType>,
        ) -> bool;

        #[cfg(feature = "NSPasteboard")]
        #[optional]
        #[unsafe(method(readSelectionFromPasteboard:))]
        #[unsafe(method_family = none)]
        fn readSelectionFromPasteboard(&self, pboard: &NSPasteboard) -> bool;
    }
);

/// NSServicesHandling.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[unsafe(method(servicesProvider))]
        #[unsafe(method_family = none)]
        pub fn servicesProvider(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`servicesProvider`][Self::servicesProvider].
        ///
        /// # Safety
        ///
        /// `services_provider` should be of the correct type.
        #[unsafe(method(setServicesProvider:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setServicesProvider(&self, services_provider: Option<&AnyObject>);
    );
}

/// Keys to include in the options dictionary when displaying an About panel.
/// Optional keys in `-orderFrontStandardAboutPanelWithOptions:`
/// `optionsDictionary.`
// NS_TYPED_ENUM
pub type NSAboutPanelOptionKey = NSString;

extern "C" {
    /// The credits string to display in the About panel.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring) displayed in the info area of the panel. If not specified, AppKit then looks for a file named “Credits.html”, “Credits.rtf”, and “Credits.rtfd”, in that order, in the bundle returned by the [`NSBundle`](https://developer.apple.com/documentation/foundation/bundle) class method main. The first file found is used. If none is found, the info area is left blank.
    ///
    ///
    /// NSAttributedString displayed in the info area of the panel. If not specified, contents obtained from "Credits.rtf" (.rtfd, .html) in [NSBundle mainBundle]; if not available, blank. Note that  in applications built against the 10.14 SDK or earlier, the credits are shown in light appearance even when the application is running in dark appearance, except when the credits are specified as an attributed string, or come from a file are the text is just pure black. In applications built against the 10.15 SDK or newer, credits will be shown in dark appearance, using the "adaptive color mapping" setting in NSTextView.
    pub static NSAboutPanelOptionCredits: &'static NSAboutPanelOptionKey;
}

extern "C" {
    /// The name of the application to display in the About panel.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object containing the app’s name. If you do not specify this key, AppKit uses the value of the `CFBundleName` key from the app’s `Info.plist` file. If neither is found, AppKit uses the name of the app’s process.
    ///
    ///
    /// NSString displayed in place of the default app name. If not specified, uses the value of CFBundleName (localizable). Fallback is [[NSProcessInfo processInfo] processName].
    pub static NSAboutPanelOptionApplicationName: &'static NSAboutPanelOptionKey;
}

extern "C" {
    /// The icon to display for the app in the About panel.
    ///
    /// ## Discussion
    ///
    /// The value associated with this key is an [`NSImage`](https://developer.apple.com/documentation/appkit/nsimage) object. If you do not specify an image, AppKit looks for an image with the name `NSApplicationIcon`. If neither is available, this method uses the generic app icon.
    ///
    ///
    /// NSImage displayed in place of NSApplicationIcon. If not specified, use [NSImage imageNamed:
    /// "
    /// NSApplicationIcon"]; if not available, generic icon.
    pub static NSAboutPanelOptionApplicationIcon: &'static NSAboutPanelOptionKey;
}

extern "C" {
    /// The version number to display in the About panel.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object with the build version number of the app, such as `58.4`. AppKit displays this string as `(v58.4)`. If not specified, AppKit obtains the version number from the CFBundleVersion key of the app’s Info.plist file. If no version information is found, AppKit does not display version information.
    ///
    ///
    /// NSString containing the build version number of the application ("58.4", "1.2d3"); displayed as "Version 58.4" or "Version 1.0 (58.4) depending on the presence of ApplicationVersion. If not specified, obtain from the CFBundleVersion key in infoDictionary; if not specified or empty string, leave blank.
    pub static NSAboutPanelOptionVersion: &'static NSAboutPanelOptionKey;
}

extern "C" {
    /// The version information to display in the About panel.
    ///
    /// ## Discussion
    ///
    /// The value of this key is an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object with the app version (“Version 1.0”). If not specified, AppKit obtains the version string from the `CFBundleShortVersionString` key in the app’s `Info.plist` file. If neither is available, AppKit uses the build version, printed as `Version x.x`.
    ///
    ///
    /// NSString displayed as the marketing version  ("1.0", "Mac OS X", "3", "WebObjects 3.5", ...), before the build version. If not specified, obtain from CFBundleShortVersionString key in infoDictionary. Prefixed with word "Version" if it looks like a number.
    pub static NSAboutPanelOptionApplicationVersion: &'static NSAboutPanelOptionKey;
}

/// NSStandardAboutPanel.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[unsafe(method(orderFrontStandardAboutPanel:))]
        #[unsafe(method_family = none)]
        pub fn orderFrontStandardAboutPanel(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `options_dictionary` generic should be of the correct type.
        #[unsafe(method(orderFrontStandardAboutPanelWithOptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn orderFrontStandardAboutPanelWithOptions(
            &self,
            options_dictionary: &NSDictionary<NSAboutPanelOptionKey, AnyObject>,
        );
    );
}

/// NSApplicationLayoutDirection.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[cfg(feature = "NSUserInterfaceLayout")]
        #[unsafe(method(userInterfaceLayoutDirection))]
        #[unsafe(method_family = none)]
        pub fn userInterfaceLayoutDirection(&self) -> NSUserInterfaceLayoutDirection;
    );
}

/// NSRestorableUserInterface.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        /// Disable or reenable relaunching this app on login, if the app was running at the time the user logged out.  These methods increment and decrement a counter respectively; if the counter is 0 at the time the user logs out, then the app may be relaunched when the user logs back in.  The counter is initially zero, so by default apps are relaunched.
        ///
        /// If your app should not be relaunched because it launches via some other mechanism (e.g. launchd), then the recommended usage is to call `-[NSApp disableRelaunchOnLogin]` once, and never pair it with an -enable call.
        ///
        /// If your app should not be relaunched because it triggers a restart (e.g. an installer), then the recommended usage is to call `-[NSApp disableRelaunchOnLogin]` immediately before you attempt to trigger a restart, and `-[NSApp enableRelaunchOnLogin]` immediately after.  This is because the user may cancel restarting; if the user later restarts for another reason, then your app should be brought back.
        ///
        /// These methods are thread safe.
        #[unsafe(method(disableRelaunchOnLogin))]
        #[unsafe(method_family = none)]
        pub fn disableRelaunchOnLogin(&self);

        #[unsafe(method(enableRelaunchOnLogin))]
        #[unsafe(method_family = none)]
        pub fn enableRelaunchOnLogin(&self);
    );
}

/// These constants determine whether apps launched by remote notifications display a badge.
/// Soft deprecated.
/// Please use `NSApplication`'s `-registerForRemoteNotifications` along with `-requestAuthorizationWithOptions:` from the `UserNotifications.framework` to specify allowable notification types.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSRemoteNotificationType(pub NSUInteger);
bitflags::bitflags! {
    impl NSRemoteNotificationType: NSUInteger {
/// The app shouldn’t display a badge.
        #[doc(alias = "NSRemoteNotificationTypeNone")]
        const None = 0;
/// The app should display a badge.
        #[doc(alias = "NSRemoteNotificationTypeBadge")]
        const Badge = 1<<0;
/// The app should play a sound.
        #[doc(alias = "NSRemoteNotificationTypeSound")]
        const Sound = 1<<1;
/// The app should display an alert.
        #[doc(alias = "NSRemoteNotificationTypeAlert")]
        const Alert = 1<<2;
    }
}

unsafe impl Encode for NSRemoteNotificationType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSRemoteNotificationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// NSRemoteNotifications.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[unsafe(method(registerForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub fn registerForRemoteNotifications(&self);

        #[unsafe(method(unregisterForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub fn unregisterForRemoteNotifications(&self);

        /// Returns: `YES`if the application is currently registered for remote notifications, taking into account any systemwide settings; doesn't relate to connectivity.
        #[unsafe(method(isRegisteredForRemoteNotifications))]
        #[unsafe(method_family = none)]
        pub fn isRegisteredForRemoteNotifications(&self) -> bool;

        /// The following are soft deprecated.
        /// Please use the `-registerForRemoteNotifications` above and `-requestAuthorizationWithOptions:` from `UserNotifications.framework`.
        #[unsafe(method(registerForRemoteNotificationTypes:))]
        #[unsafe(method_family = none)]
        pub fn registerForRemoteNotificationTypes(&self, types: NSRemoteNotificationType);

        #[unsafe(method(enabledRemoteNotificationTypes))]
        #[unsafe(method_family = none)]
        pub fn enabledRemoteNotificationTypes(&self) -> NSRemoteNotificationType;
    );
}

#[cfg(feature = "NSResponder")]
impl NSApplication {
    /// Called by the main function to create and run the application.
    ///
    /// Parameters:
    /// - argc: The number of arguments in the `argv` parameter.
    ///
    /// - argv: An array of pointers containing the arguments passed to the application at startup.
    ///
    ///
    /// ## Return Value
    ///
    /// This method never returns a result code. Instead, it calls the `exit` function to exit the application and terminate the process. If you want to determine why the application exited, you should look at the result code from the `exit` function instead.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Creates the application, loads the main nib file from the application’s main bundle, and runs the application. You must call this function from the main thread of your application, and you typically call it only once from your application’s `main` function. Your `main` function is usually generated automatically by Xcode.
    ///
    /// ### Special Considerations
    ///
    /// `NSApplicationMain` itself ignores the `argc` and `argv` arguments. Instead, Cocoa gets its arguments indirectly through `_NSGetArgv`, `_NSGetArgc`, and `_NSGetEnviron` (see <crt_externs.h>).
    ///
    ///
    /// An Application's startup function.
    ///
    /// # Safety
    ///
    /// `argv` must be a valid pointer.
    #[doc(alias = "NSApplicationMain")]
    #[inline]
    pub(crate) unsafe fn __main(argc: c_int, argv: NonNull<NonNull<c_char>>) -> c_int {
        extern "C-unwind" {
            fn NSApplicationMain(argc: c_int, argv: NonNull<NonNull<c_char>>) -> c_int;
        }
        unsafe { NSApplicationMain(argc, argv) }
    }

    /// Startup function to call when running Cocoa code from a Carbon application.
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) object was successfully initialized and can now be used from your Carbon application or [`false`](https://developer.apple.com/documentation/swift/false) if there was an error during initialization.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You typically call this function before calling other Cocoa code in a plug-in loaded into a primarily Carbon application. If the shared [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) object isn’t already initialized, this function initializes it and sets up the necessary event handlers for Cocoa.
    ///
    ///
    /// `NSApplicationLoad`should be called when loading a Cocoa bundle in a Carbon app in order to initialize
    /// `NSApplication`and other Cocoa objects.  Redundant calls are ignored.
    #[doc(alias = "NSApplicationLoad")]
    #[inline]
    pub fn load() -> bool {
        extern "C-unwind" {
            fn NSApplicationLoad() -> Bool;
        }
        unsafe { NSApplicationLoad() }.as_bool()
    }
}

/// Specifies whether a Services menu item is currently enabled.
///
/// ## Discussion
///
/// Deprecated. This function simply returns [`true`](https://developer.apple.com/documentation/swift/true).
///
///
/// `NSShowsServicesMenuItem()`always returns
/// `YES.`
#[inline]
pub extern "C-unwind" fn NSShowsServicesMenuItem(item_name: &NSString) -> bool {
    extern "C-unwind" {
        fn NSShowsServicesMenuItem(item_name: &NSString) -> Bool;
    }
    unsafe { NSShowsServicesMenuItem(item_name) }.as_bool()
}

/// Specifies whether an item should be included in Services menus.
///
/// ## Discussion
///
/// Deprecated. This function simply returns 0.
///
///
/// `NSSetShowsServicesMenuItem()`has no effect, and always returns 0.
#[inline]
pub extern "C-unwind" fn NSSetShowsServicesMenuItem(
    item_name: &NSString,
    enabled: bool,
) -> NSInteger {
    extern "C-unwind" {
        fn NSSetShowsServicesMenuItem(item_name: &NSString, enabled: Bool) -> NSInteger;
    }
    unsafe { NSSetShowsServicesMenuItem(item_name, Bool::new(enabled)) }
}

/// Causes the services information for the system to be updated.
///
/// ## Discussion
///
/// Used by a service-providing application to reregister the services it is willing to provide. To do this, you create a bundle with the extension “`.service`” and place it in the application’s path or `~/Library/Services`. The content of the bundle is identical to a normal service bundle. You then call this function.
///
/// It is only necessary to call this function if your program adds dynamic services to the system.
///
///
/// `NSUpdateDynamicServices()`causes the services information for the system to be updated.
/// This will only be necessary if your program adds dynamic services to the system (i.e. services not found in mach-o segments of executables).
#[inline]
pub extern "C-unwind" fn NSUpdateDynamicServices() {
    extern "C-unwind" {
        fn NSUpdateDynamicServices();
    }
    unsafe { NSUpdateDynamicServices() }
}

/// Programmatically invokes a Services menu service.
///
/// Parameters:
/// - itemName: Specifies a Services menu item, in any language. If the requested service is from a submenu of the Services menu, the value must contain a slash (for example, “Mail/Selection”).
///
/// - pboard: The pasteboard containing the data required by the service. This data must be present for the service to succeed. On output, this pasteboard contains the data returned by the service provider.
///
///
/// ## Return Value
///
/// [`true`](https://developer.apple.com/documentation/swift/true) if the service was successfully performed or [`false`](https://developer.apple.com/documentation/swift/false) if it was not.
///
///
///
/// ## Discussion
///
/// Use this function to programmatically invoke a service found in the application’s Services menu.
///
///
#[cfg(feature = "NSPasteboard")]
#[inline]
pub extern "C-unwind" fn NSPerformService(
    item_name: &NSString,
    pboard: Option<&NSPasteboard>,
) -> bool {
    extern "C-unwind" {
        fn NSPerformService(item_name: &NSString, pboard: Option<&NSPasteboard>) -> Bool;
    }
    unsafe { NSPerformService(item_name, pboard) }.as_bool()
}

pub type NSServiceProviderName = NSString;

extern "C-unwind" {
    /// Registers a service provider.
    ///
    /// Parameters:
    /// - provider: The object providing the service you want to register.
    ///
    /// - name: The unique name to associate with the service. This string is used to advertise the service to interested clients.
    ///
    ///
    /// ## Discussion
    ///
    /// Use this function to register custom services not directly related to your application.
    ///
    /// You should not use this function to register the services provided by your application. For your application’s services, you should use the [`servicesProvider`](https://developer.apple.com/documentation/appkit/nsapplication/servicesprovider) method of [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication), passing a non-`nil` argument.
    ///
    ///
    /// Apps should use -setServicesProvider.
    ///
    /// # Safety
    ///
    /// `provider` should be of the correct type.
    pub fn NSRegisterServicesProvider(provider: Option<&AnyObject>, name: &NSServiceProviderName);
}

/// Unregisters a service provider.
///
/// Parameters:
/// - name: The name of the service you want to unregister.
///
///
/// ## Discussion
///
/// Use this function to unregister custom services not directly related to your application.
///
/// You should not use this function to unregister the services provided by your application. For your application’s services, you should use the [`servicesProvider`](https://developer.apple.com/documentation/appkit/nsapplication/servicesprovider) method of [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication), passing a `nil` argument.
///
///
#[inline]
pub extern "C-unwind" fn NSUnregisterServicesProvider(name: &NSServiceProviderName) {
    extern "C-unwind" {
        fn NSUnregisterServicesProvider(name: &NSServiceProviderName);
    }
    unsafe { NSUnregisterServicesProvider(name) }
}

extern "C" {
    /// Posted immediately after the app becomes active.
    ///
    /// ## Discussion
    ///
    /// The notification object is [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared). This notification doesn’t contain a `userInfo` dictionary.
    ///
    /// The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationDidBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted at the end of the [`hide:`](https://developer.apple.com/documentation/appkit/nsapplication/hide(_:)) method to indicate that the app is now hidden.
    ///
    /// ## Discussion
    ///
    /// The notification object is `NSApp`. This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationDidHideNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted at the end of the [`finishLaunching`](https://developer.apple.com/documentation/appkit/nsapplication/finishlaunching()) method to indicate that the app has completed launching and is ready to run.
    ///
    /// ## Discussion
    ///
    /// The notification object is [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared). See [NSApplicationDidFinishLaunching User Info Keys](https://developer.apple.com/documentation/appkit/nsapplicationdidfinishlaunching-user-info-keys) for the possible `userInfo` keys and values. The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationDidFinishLaunchingNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted immediately after the app gives up its active status to another app.
    ///
    /// ## Discussion
    ///
    /// The notification object is `NSApp`. This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationDidResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted at the end of the [`unhideWithoutActivation`](https://developer.apple.com/documentation/appkit/nsapplication/unhidewithoutactivation()) method to indicate that the app is now visible.
    ///
    /// ## Discussion
    ///
    /// The notification object is `NSApp`. This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationDidUnhideNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted at the end of the [`updateWindows`](https://developer.apple.com/documentation/appkit/nsapplication/updatewindows()) method to indicate that the app has finished updating its windows.
    ///
    /// ## Discussion
    ///
    /// The notification object is `NSApp`. This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationDidUpdateNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted immediately before the app becomes active.
    ///
    /// ## Discussion
    ///
    /// The notification object is `NSApp`. This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationWillBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted at the start of the [`hide:`](https://developer.apple.com/documentation/appkit/nsapplication/hide(_:)) method to indicate that the app is about to be hidden.
    ///
    /// ## Discussion
    ///
    /// The notification object is `NSApp`. This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationWillHideNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted at the start of the [`finishLaunching`](https://developer.apple.com/documentation/appkit/nsapplication/finishlaunching()) method to indicate that the app has completed its initialization process and is about to finish launching.
    ///
    /// ## Discussion
    ///
    /// The notification object is `NSApp`. This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationWillFinishLaunchingNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted immediately before the app gives up its active status to another app.
    ///
    /// ## Discussion
    ///
    /// The notification object is [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared). This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationWillResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted at the start of the [`unhideWithoutActivation`](https://developer.apple.com/documentation/appkit/nsapplication/unhidewithoutactivation()) method to indicate that the app is about to become visible.
    ///
    /// ## Discussion
    ///
    /// The notification object is [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared). This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationWillUnhideNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted at the start of the [`updateWindows`](https://developer.apple.com/documentation/appkit/nsapplication/updatewindows()) method to indicate that the app is about to update its windows.
    ///
    /// ## Discussion
    ///
    /// The notification object is [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared). This notification doesn’t contain a `userInfo` dictionary.  The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationWillUpdateNotification: &'static NSNotificationName;
}

extern "C" {
    /// Sends a notification to terminate the app.
    ///
    /// ## Discussion
    ///
    /// The system posts this notification on the main actor in response to the [`terminate:`](https://developer.apple.com/documentation/appkit/nsapplication/terminate(_:)) method, and only posted if the delegate method [`applicationShouldTerminate:`](https://developer.apple.com/documentation/appkit/nsapplicationdelegate/applicationshouldterminate(_:)) returns [`true`](https://developer.apple.com/documentation/swift/true). The notification object is [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared). This notification doesn’t contain a `userInfo` dictionary.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This notification isn’t sent during sudden termination of an app. For more information about sudden termination, see the section  [`NSProcessInfo`](https://developer.apple.com/documentation/foundation/processinfo) of [`NSProcessInfo`](https://developer.apple.com/documentation/foundation/processinfo).
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSApplicationWillTerminateNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted when the configuration of the displays attached to the computer is changed.
    ///
    /// ## Discussion
    ///
    /// The configuration change can be made either programmatically or when the user changes settings in the Displays control panel. The notification object is [`sharedApplication`](https://developer.apple.com/documentation/appkit/nsapplication/shared). This notification doesn’t contain a `userInfo` dictionary.
    ///
    /// The system posts this notification on the main actor.
    ///
    ///
    pub static NSApplicationDidChangeScreenParametersNotification: &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationProtectedDataWillBecomeUnavailableNotification:
        &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationProtectedDataDidBecomeAvailableNotification:
        &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationShouldBeginSuppressingHighDynamicRangeContentNotification:
        &'static NSNotificationName;
}

extern "C" {
    pub static NSApplicationShouldEndSuppressingHighDynamicRangeContentNotification:
        &'static NSNotificationName;
}

extern "C" {
    /// A Boolean value that indicates if the app launch is a default launch.
    ///
    /// ## Discussion
    ///
    /// The value for this key is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) containing a Boolean value. The value is [`false`](https://developer.apple.com/documentation/swift/false) if the app was launched to open or print a file, to perform a Service action, if the app had saved state that will be restored, or if the app launch was in some other sense not a default launch. Otherwise its value will be [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    ///
    /// The following key is present in the userInfo of NSApplicationDidFinishLaunchingNotification.  Its value is an NSNumber containing a bool.  It will be NO if the app was launched to open or print a file, to perform a Service, if the app had saved state that will be restored, or if the app launch was in some other sense not a "default" launch.  Otherwise its value will be YES.
    pub static NSApplicationLaunchIsDefaultLaunchKey: &'static NSString;
}

extern "C" {
    /// A key that indicates your app was launched because a user activated a notification in the Notification Center.
    ///
    /// ## Discussion
    ///
    /// The [`NSApplicationLaunchUserNotificationKey`](https://developer.apple.com/documentation/appkit/nsapplication/launchusernotificationuserinfokey) key is an [`NSUserNotification`](https://developer.apple.com/documentation/foundation/nsusernotification) object that is present in the [`userInfo`](https://developer.apple.com/documentation/foundation/nsnotification/userinfo) dictionary of the [`NSApplicationDidFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/didfinishlaunchingnotification) notification if your app was launched because a user activated a notification in the Notification Center. To access the notification payload in the [`userInfo`](https://developer.apple.com/documentation/foundation/nsnotification/userinfo) dictionary, you can use code like this:
    ///
    /// ```objc
    /// NSUserNotification *userNotification = [[myNotification userInfo]
    ///     objectForKey:NSApplicationLaunchUserNotificationKey];
    ///     if (userNotification) {
    ///         // The app was launched by a user selection from Notification Center.
    ///     }
    /// ```
    ///
    ///
    /// The following key is present in the userInfo of NSApplicationDidFinishLaunchingNotification. It will be present if your application was launched because a user activated a notification in the Notification Center. Its value is an NSUserNotification object.
    pub static NSApplicationLaunchUserNotificationKey: &'static NSString;
}

extern "C" {
    /// Use this key to access the JSON push-notification payload from the user info dictionary of the `didFinishLaunchingNotification` notification.
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Deprecated
    /// Use [`launchUserNotificationUserInfoKey`](https://developer.apple.com/documentation/appkit/nsapplication/launchusernotificationuserinfokey) instead.
    ///
    ///
    ///
    /// </div>
    /// The [`didFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/didfinishlaunchingnotification) notification is passed into the delegate method [`applicationDidFinishLaunching(_:)`](https://developer.apple.com/documentation/appkit/nsapplicationdelegate/applicationdidfinishlaunching(_:)) declared by the [`NSApplicationDelegate`](https://developer.apple.com/documentation/appkit/nsapplicationdelegate) protocol to handle this notification. For information about the payload dictionary, see [Local and Remote Notification Programming Guide](https://developer.apple.com/library/archive/documentation/NetworkingInternet/Conceptual/RemoteNotificationsPG/index.html#//apple_ref/doc/uid/TP40008194).
    ///
    ///
    /// NSApplicationLaunchRemoteNotificationKey is unimplemented.  Please use NSApplicationLaunchUserNotificationKey to get the NSUserNotification object.  The NSUserNotification object has an isRemote property to indicate whether this application was launched as a result of a remote notification
    #[deprecated]
    pub static NSApplicationLaunchRemoteNotificationKey: &'static NSString;
}

extern "C" {
    /// Posted when the app’s occlusion state changes.
    ///
    /// ## Discussion
    ///
    /// The system posts this notification on the main actor.  Upon receiving this notification, you can query the app for its occlusion state. Note that this only notifies about changes in the state of the occlusion, not when the occlusion region changes. You can use this notification to increase responsiveness and save power by halting any expensive calculations that the user can’t see.
    ///
    ///
    /// Upon receiving this notification, you can query the NSApplication for its occlusion state. Note that this only notifies about changes in the state of the occlusion, not when the occlusion region changes. You can use this notification to increase responsiveness and save power, by halting any expensive calculations that the user can not see.
    pub static NSApplicationDidChangeOcclusionStateNotification: &'static NSNotificationName;
}

/// Modal session was broken with [`stopModal`](https://developer.apple.com/documentation/appkit/nsapplication/stopmodal()).
#[deprecated = "Use NSModalResponseStop instead"]
pub const NSRunStoppedResponse: c_int = -1000;
/// Modal session was broken with [`abortModal`](https://developer.apple.com/documentation/appkit/nsapplication/abortmodal()).
#[deprecated = "Use NSModalResponseAbort instead"]
pub const NSRunAbortedResponse: c_int = -1001;
/// Modal session is continuing (returned by [`runModalSession:`](https://developer.apple.com/documentation/appkit/nsapplication/runmodalsession(_:)) only).
#[deprecated = "Use NSModalResponseContinue instead"]
pub const NSRunContinuesResponse: c_int = -1002;

/// NSDeprecated.
#[cfg(feature = "NSResponder")]
impl NSApplication {
    extern_methods!(
        #[cfg(feature = "NSWindow")]
        /// `-runModalForWindow:relativeToWindow:` was deprecated in Mac OS X 10.0. Please use `-[NSWindow beginSheet:completionHandler:]` instead.
        ///
        /// # Safety
        ///
        /// - `window` might not allow `None`.
        /// - `doc_window` might not allow `None`.
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[unsafe(method(runModalForWindow:relativeToWindow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runModalForWindow_relativeToWindow(
            &self,
            window: Option<&NSWindow>,
            doc_window: Option<&NSWindow>,
        ) -> NSInteger;

        #[cfg(feature = "NSWindow")]
        /// `-beginModalSessionForWindow:relativeToWindow:` was deprecated in Mac OS X 10.0. Please use `-[NSWindow beginSheet:completionHandler:]` instead.
        ///
        /// # Safety
        ///
        /// - `window` might not allow `None`.
        /// - `doc_window` might not allow `None`.
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[unsafe(method(beginModalSessionForWindow:relativeToWindow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginModalSessionForWindow_relativeToWindow(
            &self,
            window: Option<&NSWindow>,
            doc_window: Option<&NSWindow>,
        ) -> NSModalSession;

        /// `-application:printFiles:` was deprecated in Mac OS X 10.4.
        /// Implement `-application:printFiles:withSettings:showPrintPanels:` in your application delegate instead.
        ///
        /// # Safety
        ///
        /// - `sender` might not allow `None`.
        /// - `filenames` might not allow `None`.
        #[deprecated]
        #[unsafe(method(application:printFiles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn application_printFiles(
            &self,
            sender: Option<&NSApplication>,
            filenames: Option<&NSArray<NSString>>,
        );

        #[cfg(feature = "NSWindow")]
        /// `NSWindow`'s `-beginSheet:completionHandler:` and `-endSheet:returnCode:` should be used instead.  `NSApplication`'s `-beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:` will continue to work as it previously did, leaking contextInfo and failing when there is already an existing sheet.
        ///
        /// # Safety
        ///
        /// - `modal_delegate` should be of the correct type.
        /// - `did_end_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer.
        #[deprecated = "Use -[NSWindow beginSheet:completionHandler:] instead"]
        #[unsafe(method(beginSheet:modalForWindow:modalDelegate:didEndSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn beginSheet_modalForWindow_modalDelegate_didEndSelector_contextInfo(
            &self,
            sheet: &NSWindow,
            doc_window: &NSWindow,
            modal_delegate: Option<&AnyObject>,
            did_end_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -[NSWindow endSheet:] instead"]
        #[unsafe(method(endSheet:))]
        #[unsafe(method_family = none)]
        pub fn endSheet(&self, sheet: &NSWindow);

        #[cfg(feature = "NSWindow")]
        #[deprecated = "Use -[NSWindow endSheet:returnCode:] instead"]
        #[unsafe(method(endSheet:returnCode:))]
        #[unsafe(method_family = none)]
        pub fn endSheet_returnCode(&self, sheet: &NSWindow, return_code: NSInteger);

        #[cfg(feature = "NSWindow")]
        /// # Safety
        ///
        /// `selector` must be a valid selector.
        #[deprecated = "Use -enumerateWindowsWithOptions:usingBlock: instead"]
        #[unsafe(method(makeWindowsPerform:inOrder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeWindowsPerform_inOrder(
            &self,
            selector: Sel,
            in_order: bool,
        ) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSGraphicsContext")]
        /// This method is deprecated as of macOS 10.12. Beginning in OS X 10.11 it would always return nil. Prior to this it would return an undefined graphics context that was not generally suitable for drawing.
        #[deprecated = "This method always returns nil. If you need access to the current drawing context, use [NSGraphicsContext currentContext] inside of a draw operation."]
        #[unsafe(method(context))]
        #[unsafe(method_family = none)]
        pub fn context(&self) -> Option<Retained<NSGraphicsContext>>;
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `NSApplication::__main`"]
    pub fn NSApplicationMain(argc: c_int, argv: NonNull<NonNull<c_char>>) -> c_int;
}

#[deprecated = "renamed to `NSApplication::load`"]
#[inline]
pub extern "C-unwind" fn NSApplicationLoad() -> bool {
    extern "C-unwind" {
        fn NSApplicationLoad() -> Bool;
    }
    unsafe { NSApplicationLoad() }.as_bool()
}
