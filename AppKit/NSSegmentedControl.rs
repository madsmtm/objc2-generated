//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// The following constants specify the type of tracking behavior a segmented control exhibits. They are used by [`trackingMode`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/trackingmode).
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSSegmentSwitchTracking(pub NSUInteger);
impl NSSegmentSwitchTracking {
    /// Only one segment in the control can be selected at a time.
    ///
    /// ## Discussion
    ///
    /// This mode functions as a radio button and is illustrated by the view selection control in Finder, which allows you to toggle between icon view, list view, column view, and Cover Flow.
    ///
    ///
    #[doc(alias = "NSSegmentSwitchTrackingSelectOne")]
    pub const SelectOne: Self = Self(0);
    /// One or more segment cells in the control can be selected at a time.
    ///
    /// ## Discussion
    ///
    /// This mode functions as a set of checkboxes, where any combination of segments may be on or off, and is illustrated by the font format selection control in Pages, which allows you to apply bold, italics, and underline to the selected text.
    ///
    ///
    #[doc(alias = "NSSegmentSwitchTrackingSelectAny")]
    pub const SelectAny: Self = Self(1);
    /// A segment is selected only when the user is pressing the mouse down within the bounds of the segment. When the mouse is no longer down within the segment, the segment is automatically deselected. A momentary segmented control sends an action when the user clicks a segment, and another action when the user releases the segment. If configured as continuous (see [`continuous`](https://developer.apple.com/documentation/appkit/nscontrol/iscontinuous)), the control also sends actions at repeating intervals until the user releases the segment, at which point the control sends its final action.
    ///
    /// ## Discussion
    ///
    /// When the user clicks a segment, the [`selectedSegment`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/selectedsegment) value is the index of the active segment. When the user releases the segment, the [`selectedSegment`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/selectedsegment) value is `-1`.
    ///
    /// This type of control is illustrated by the navigation segmented control in the Safari toolbar. When you click the back segment, for example, the previous webpage is displayed. This particular control is not configured as continuous. If it were, clicking and holding on the back segment would continue cycling through previous webpages until the segment is released.
    ///
    ///
    #[doc(alias = "NSSegmentSwitchTrackingMomentary")]
    pub const Momentary: Self = Self(2);
    /// On pressure-sensitive systems, when the user force clicks a segment, a momentary accelerator segmented control sends repeating actions as pressure changes occur. The control stops sending actions when the user releases pressure. A document-based app, for example, might implement a momentary accelerator segmented control in order to allow a user to adjust the speed of paging by using variable pressure. In this example, actions are sent to the app to indicate when pressure on the control has changed. The app then determines the amount of pressure currently applied, and adjusts navigation speed accordingly.
    ///
    /// ## Discussion
    ///
    /// When the control is configured as continuous (see [`continuous`](https://developer.apple.com/documentation/appkit/nscontrol/iscontinuous)), the interval between repeating actions automatically adjusts to match the applied pressure. As the user presses harder, actions are sent more rapidly. As the user reduces pressure, actions slow down. As such, the user has direct control over how fast actions are sent. Continuous momentary accelerator segmented controls are intended for continuously advancing through a series of discrete objects, such as photos in an album or pages in a book.
    ///
    /// When configured as noncontinuous, actions are sent whenever a change in pressure occurs. Noncontinuous momentary accelerator segmented controls are intended for adjusting the speed of navigation, such as playback speed in a media player, based on pressure. Once the control is released, a final action is sent.
    ///
    /// When the user force clicks a segment in the control, [`selectedSegment`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/selectedsegment) value is the index of the active segment, and [`doubleValueForSelectedSegment`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/doublevalueforselectedsegment) is a measurement of pressure between `1.0` and approaching `2.0`. When the user releases pressure, the [`selectedSegment`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/selectedsegment) value is `-1` and [`doubleValueForSelectedSegment`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/doublevalueforselectedsegment) is `0.0`.
    ///
    /// On a system that doesn’t support pressure sensitivity, a momentary accelerator segmented control behaves like a control of type [`NSSegmentSwitchTrackingMomentary`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/switchtracking/momentary).
    ///
    ///
    #[doc(alias = "NSSegmentSwitchTrackingMomentaryAccelerator")]
    pub const MomentaryAccelerator: Self = Self(3);
}

unsafe impl Encode for NSSegmentSwitchTracking {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSSegmentSwitchTracking {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The following constants specify the visual style used to display the segmented control. They are used by [`segmentStyle`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/segmentstyle).
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSSegmentStyle(pub NSInteger);
impl NSSegmentStyle {
    /// The appearance of the segmented control is automatically determined based on the type of window in which the control is displayed and the position within the window.
    #[doc(alias = "NSSegmentStyleAutomatic")]
    pub const Automatic: Self = Self(0);
    /// The control is displayed using the rounded style.
    #[doc(alias = "NSSegmentStyleRounded")]
    pub const Rounded: Self = Self(1);
    /// The control is displayed using the round rect style.
    #[doc(alias = "NSSegmentStyleRoundRect")]
    pub const RoundRect: Self = Self(3);
    /// The control is displayed using the textured square style.
    #[doc(alias = "NSSegmentStyleTexturedSquare")]
    pub const TexturedSquare: Self = Self(4);
    /// The control is displayed using the small square style.
    #[doc(alias = "NSSegmentStyleSmallSquare")]
    pub const SmallSquare: Self = Self(6);
    /// The segments in the control are displayed very close to each other but not touching. For example, Safari in macOS 10.10 and later uses this style for the previous and next page segmented control.
    #[doc(alias = "NSSegmentStyleSeparated")]
    pub const Separated: Self = Self(8);
    /// The control is displayed using the textured rounded style. In macOS 10.7 and later, this style uses the artwork defined for [`NSSegmentStyleTexturedSquare`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/style/texturedsquare), so you should specify [`NSSegmentStyleTexturedSquare`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/style/texturedsquare) instead.
    #[doc(alias = "NSSegmentStyleTexturedRounded")]
    pub const TexturedRounded: Self = Self(2);
    /// The control is displayed using the capsule style. In macOS 10.7 and later, this style uses the artwork defined for [`NSSegmentStyleTexturedSquare`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/style/texturedsquare), so you should specify [`NSSegmentStyleTexturedSquare`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/style/texturedsquare) instead.
    #[doc(alias = "NSSegmentStyleCapsule")]
    pub const Capsule: Self = Self(5);
}

unsafe impl Encode for NSSegmentStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSSegmentStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSSegmentDistribution(pub NSInteger);
impl NSSegmentDistribution {
    /// Dynamically sized segments will be sized to fit their contents, any remaining space will be left blank. This style is equivalent to the way segments were distributed on older systems.
    #[doc(alias = "NSSegmentDistributionFit")]
    pub const Fit: Self = Self(0);
    /// Dynamically sized segments will be sized to fill the available space, with extra space being distributed equally among them. Default value.
    #[doc(alias = "NSSegmentDistributionFill")]
    pub const Fill: Self = Self(1);
    /// Dynamically sized segments will be sized to fill the available space, and kept the same size as each other.
    #[doc(alias = "NSSegmentDistributionFillEqually")]
    pub const FillEqually: Self = Self(2);
    /// Dynamically sized segments will be sized to fill the available space, and kept proportional to their fitting size.
    #[doc(alias = "NSSegmentDistributionFillProportionally")]
    pub const FillProportionally: Self = Self(3);
}

unsafe impl Encode for NSSegmentDistribution {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSSegmentDistribution {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Display one or more buttons in a single horizontal group.
    ///
    /// ## Overview
    ///
    /// The `NSSegmentedControl` class uses an [`NSSegmentedCell`](https://developer.apple.com/documentation/appkit/nssegmentedcell) class to implement much of the control’s functionality. Most methods in `NSSegmentedControl` are simply cover methods that call the corresponding method in [`NSSegmentedCell`](https://developer.apple.com/documentation/appkit/nssegmentedcell). The methods of [`NSSegmentedCell`](https://developer.apple.com/documentation/appkit/nssegmentedcell) that do not have covers relate to accessing and setting values for tags and tooltips, programatically setting the key segment, and establishing the mode of the control.
    ///
    /// The features of a segmented control include the following:
    ///
    /// - A segment can have an image, text (label), menu, tooltip, and tag.
    ///
    /// - A segmented control can contain images or text, but not both.
    ///
    /// - Either the control or individual segments can be enabled or disabled.
    ///
    /// - Segmented controls have four tracking modes, described in [`NSSegmentSwitchTracking`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/switchtracking). You use these modes with the [`trackingMode`](https://developer.apple.com/documentation/appkit/nssegmentedcontrol/trackingmode) property.
    ///
    /// - Each segment can be either a fixed width or autosized to fit the contents.
    ///
    /// - If a segment has text and is marked as autosizing, then the text may be truncated so that the control completely fits.
    ///
    /// - If an image is too large to fit in a segment, it is clipped.
    ///
    /// - If Full Keyboard Access is enabled in System Preferences > Keyboard, the keyboard may be used to move between and select segments.
    ///
    ///
    #[unsafe(super(NSControl, NSView, NSResponder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "NSControl", feature = "NSResponder", feature = "NSView"))]
    pub struct NSSegmentedControl;
);

#[cfg(all(
    feature = "NSAccessibilityProtocols",
    feature = "NSControl",
    feature = "NSResponder",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSAccessibility for NSSegmentedControl {}
);

#[cfg(all(
    feature = "NSAccessibilityProtocols",
    feature = "NSControl",
    feature = "NSResponder",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSAccessibilityElementProtocol for NSSegmentedControl {}
);

#[cfg(all(
    feature = "NSAnimation",
    feature = "NSControl",
    feature = "NSResponder",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSAnimatablePropertyContainer for NSSegmentedControl {}
);

#[cfg(all(
    feature = "NSAppearance",
    feature = "NSControl",
    feature = "NSResponder",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSAppearanceCustomization for NSSegmentedControl {}
);

#[cfg(all(feature = "NSControl", feature = "NSResponder", feature = "NSView"))]
extern_conformance!(
    unsafe impl NSCoding for NSSegmentedControl {}
);

#[cfg(all(
    feature = "NSControl",
    feature = "NSDragging",
    feature = "NSResponder",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSDraggingDestination for NSSegmentedControl {}
);

#[cfg(all(feature = "NSControl", feature = "NSResponder", feature = "NSView"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSSegmentedControl {}
);

#[cfg(all(
    feature = "NSControl",
    feature = "NSResponder",
    feature = "NSUserInterfaceCompression",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSUserInterfaceCompression for NSSegmentedControl {}
);

#[cfg(all(
    feature = "NSControl",
    feature = "NSResponder",
    feature = "NSUserInterfaceItemIdentification",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSUserInterfaceItemIdentification for NSSegmentedControl {}
);

#[cfg(all(feature = "NSControl", feature = "NSResponder", feature = "NSView"))]
impl NSSegmentedControl {
    extern_methods!(
        #[unsafe(method(segmentCount))]
        #[unsafe(method_family = none)]
        pub fn segmentCount(&self) -> NSInteger;

        /// Setter for [`segmentCount`][Self::segmentCount].
        #[unsafe(method(setSegmentCount:))]
        #[unsafe(method_family = none)]
        pub fn setSegmentCount(&self, segment_count: NSInteger);

        #[unsafe(method(selectedSegment))]
        #[unsafe(method_family = none)]
        pub fn selectedSegment(&self) -> NSInteger;

        /// Setter for [`selectedSegment`][Self::selectedSegment].
        #[unsafe(method(setSelectedSegment:))]
        #[unsafe(method_family = none)]
        pub fn setSelectedSegment(&self, selected_segment: NSInteger);

        #[unsafe(method(selectSegmentWithTag:))]
        #[unsafe(method_family = none)]
        pub fn selectSegmentWithTag(&self, tag: NSInteger) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(setWidth:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setWidth_forSegment(&self, width: CGFloat, segment: NSInteger);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(widthForSegment:))]
        #[unsafe(method_family = none)]
        pub fn widthForSegment(&self, segment: NSInteger) -> CGFloat;

        #[cfg(feature = "NSImage")]
        #[unsafe(method(setImage:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setImage_forSegment(&self, image: Option<&NSImage>, segment: NSInteger);

        #[cfg(feature = "NSImage")]
        #[unsafe(method(imageForSegment:))]
        #[unsafe(method_family = none)]
        pub fn imageForSegment(&self, segment: NSInteger) -> Option<Retained<NSImage>>;

        #[cfg(feature = "NSCell")]
        #[unsafe(method(setImageScaling:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setImageScaling_forSegment(&self, scaling: NSImageScaling, segment: NSInteger);

        #[cfg(feature = "NSCell")]
        #[unsafe(method(imageScalingForSegment:))]
        #[unsafe(method_family = none)]
        pub fn imageScalingForSegment(&self, segment: NSInteger) -> NSImageScaling;

        #[unsafe(method(setLabel:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setLabel_forSegment(&self, label: &NSString, segment: NSInteger);

        #[unsafe(method(labelForSegment:))]
        #[unsafe(method_family = none)]
        pub fn labelForSegment(&self, segment: NSInteger) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSMenu")]
        #[unsafe(method(setMenu:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setMenu_forSegment(&self, menu: Option<&NSMenu>, segment: NSInteger);

        #[cfg(feature = "NSMenu")]
        #[unsafe(method(menuForSegment:))]
        #[unsafe(method_family = none)]
        pub fn menuForSegment(&self, segment: NSInteger) -> Option<Retained<NSMenu>>;

        #[unsafe(method(setSelected:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setSelected_forSegment(&self, selected: bool, segment: NSInteger);

        #[unsafe(method(isSelectedForSegment:))]
        #[unsafe(method_family = none)]
        pub fn isSelectedForSegment(&self, segment: NSInteger) -> bool;

        #[unsafe(method(setEnabled:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setEnabled_forSegment(&self, enabled: bool, segment: NSInteger);

        #[unsafe(method(isEnabledForSegment:))]
        #[unsafe(method_family = none)]
        pub fn isEnabledForSegment(&self, segment: NSInteger) -> bool;

        #[unsafe(method(setToolTip:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setToolTip_forSegment(&self, tool_tip: Option<&NSString>, segment: NSInteger);

        #[unsafe(method(toolTipForSegment:))]
        #[unsafe(method_family = none)]
        pub fn toolTipForSegment(&self, segment: NSInteger) -> Option<Retained<NSString>>;

        #[unsafe(method(setTag:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setTag_forSegment(&self, tag: NSInteger, segment: NSInteger);

        #[unsafe(method(tagForSegment:))]
        #[unsafe(method_family = none)]
        pub fn tagForSegment(&self, segment: NSInteger) -> NSInteger;

        #[unsafe(method(setShowsMenuIndicator:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setShowsMenuIndicator_forSegment(
            &self,
            shows_menu_indicator: bool,
            segment: NSInteger,
        );

        #[unsafe(method(showsMenuIndicatorForSegment:))]
        #[unsafe(method_family = none)]
        pub fn showsMenuIndicatorForSegment(&self, segment: NSInteger) -> bool;

        #[unsafe(method(segmentStyle))]
        #[unsafe(method_family = none)]
        pub fn segmentStyle(&self) -> NSSegmentStyle;

        /// Setter for [`segmentStyle`][Self::segmentStyle].
        #[unsafe(method(setSegmentStyle:))]
        #[unsafe(method_family = none)]
        pub fn setSegmentStyle(&self, segment_style: NSSegmentStyle);

        #[unsafe(method(isSpringLoaded))]
        #[unsafe(method_family = none)]
        pub fn isSpringLoaded(&self) -> bool;

        /// Setter for [`isSpringLoaded`][Self::isSpringLoaded].
        #[unsafe(method(setSpringLoaded:))]
        #[unsafe(method_family = none)]
        pub fn setSpringLoaded(&self, spring_loaded: bool);

        #[unsafe(method(trackingMode))]
        #[unsafe(method_family = none)]
        pub fn trackingMode(&self) -> NSSegmentSwitchTracking;

        /// Setter for [`trackingMode`][Self::trackingMode].
        #[unsafe(method(setTrackingMode:))]
        #[unsafe(method_family = none)]
        pub fn setTrackingMode(&self, tracking_mode: NSSegmentSwitchTracking);

        #[unsafe(method(doubleValueForSelectedSegment))]
        #[unsafe(method_family = none)]
        pub fn doubleValueForSelectedSegment(&self) -> c_double;

        #[cfg(feature = "NSColor")]
        #[unsafe(method(selectedSegmentBezelColor))]
        #[unsafe(method_family = none)]
        pub fn selectedSegmentBezelColor(&self) -> Option<Retained<NSColor>>;

        #[cfg(feature = "NSColor")]
        /// Setter for [`selectedSegmentBezelColor`][Self::selectedSegmentBezelColor].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSelectedSegmentBezelColor:))]
        #[unsafe(method_family = none)]
        pub fn setSelectedSegmentBezelColor(&self, selected_segment_bezel_color: Option<&NSColor>);

        #[unsafe(method(indexOfSelectedItem))]
        #[unsafe(method_family = none)]
        pub fn indexOfSelectedItem(&self) -> NSInteger;

        #[cfg(feature = "NSText")]
        #[unsafe(method(setAlignment:forSegment:))]
        #[unsafe(method_family = none)]
        pub fn setAlignment_forSegment(&self, alignment: NSTextAlignment, segment: NSInteger);

        #[cfg(feature = "NSText")]
        #[unsafe(method(alignmentForSegment:))]
        #[unsafe(method_family = none)]
        pub fn alignmentForSegment(&self, segment: NSInteger) -> NSTextAlignment;

        #[unsafe(method(segmentDistribution))]
        #[unsafe(method_family = none)]
        pub fn segmentDistribution(&self) -> NSSegmentDistribution;

        /// Setter for [`segmentDistribution`][Self::segmentDistribution].
        #[unsafe(method(setSegmentDistribution:))]
        #[unsafe(method_family = none)]
        pub fn setSegmentDistribution(&self, segment_distribution: NSSegmentDistribution);

        #[cfg(feature = "NSUserInterfaceCompression")]
        #[unsafe(method(compressWithPrioritizedCompressionOptions:))]
        #[unsafe(method_family = none)]
        pub fn compressWithPrioritizedCompressionOptions(
            &self,
            prioritized_options: &NSArray<NSUserInterfaceCompressionOptions>,
        );

        #[cfg(feature = "NSUserInterfaceCompression")]
        #[unsafe(method(minimumSizeWithPrioritizedCompressionOptions:))]
        #[unsafe(method_family = none)]
        pub fn minimumSizeWithPrioritizedCompressionOptions(
            &self,
            prioritized_options: &NSArray<NSUserInterfaceCompressionOptions>,
        ) -> NSSize;

        #[cfg(feature = "NSUserInterfaceCompression")]
        #[unsafe(method(activeCompressionOptions))]
        #[unsafe(method_family = none)]
        pub fn activeCompressionOptions(&self) -> Retained<NSUserInterfaceCompressionOptions>;

        #[unsafe(method(borderShape))]
        #[unsafe(method_family = none)]
        pub fn borderShape(&self) -> NSControlBorderShape;

        /// Setter for [`borderShape`][Self::borderShape].
        #[unsafe(method(setBorderShape:))]
        #[unsafe(method_family = none)]
        pub fn setBorderShape(&self, border_shape: NSControlBorderShape);
    );
}

/// Methods declared on superclass `NSControl`.
#[cfg(all(feature = "NSControl", feature = "NSResponder", feature = "NSView"))]
impl NSSegmentedControl {
    extern_methods!(
        #[unsafe(method(initWithFrame:))]
        #[unsafe(method_family = init)]
        pub fn initWithFrame(this: Allocated<Self>, frame_rect: NSRect) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSResponder`.
#[cfg(all(feature = "NSControl", feature = "NSResponder", feature = "NSView"))]
impl NSSegmentedControl {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "NSControl", feature = "NSResponder", feature = "NSView"))]
impl NSSegmentedControl {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// NSSegmentedControlConvenience.
#[cfg(all(feature = "NSControl", feature = "NSResponder", feature = "NSView"))]
impl NSSegmentedControl {
    extern_methods!(
        /// Creates a standard segmented control containing one segment for each of the provided labels.
        ///
        /// Parameter `labels`: An array of localized label strings to use for the control's segments.
        ///
        /// Parameter `trackingMode`: The selection mode for the control. The NSSegmentSwitchTracking enum describes the possible values and their effects.
        ///
        /// Parameter `target`: The target object that receives action messages from the control.
        ///
        /// Parameter `action`: The action message sent by the control.
        ///
        /// Returns: An initialized segmented control.
        ///
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `action` must be a valid selector.
        #[unsafe(method(segmentedControlWithLabels:trackingMode:target:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn segmentedControlWithLabels_trackingMode_target_action(
            labels: &NSArray<NSString>,
            tracking_mode: NSSegmentSwitchTracking,
            target: Option<&AnyObject>,
            action: Option<Sel>,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(feature = "NSImage")]
        /// Creates a standard segmented control containing one segment for each of the provided images. To ensure accessibility for this control, set the accessibilityDescription property on each of the provided images.
        ///
        /// Parameter `images`: An array of image objects to use for the control's segments.
        ///
        /// Parameter `trackingMode`: The selection mode for the control. The NSSegmentSwitchTracking enum describes the possible values and their effects.
        ///
        /// Parameter `target`: The target object that receives action messages from the control.
        ///
        /// Parameter `action`: The action message sent by the control.
        ///
        /// Returns: An initialized segmented control.
        ///
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `action` must be a valid selector.
        #[unsafe(method(segmentedControlWithImages:trackingMode:target:action:))]
        #[unsafe(method_family = none)]
        pub unsafe fn segmentedControlWithImages_trackingMode_target_action(
            images: &NSArray<NSImage>,
            tracking_mode: NSSegmentSwitchTracking,
            target: Option<&AnyObject>,
            action: Option<Sel>,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;
    );
}
