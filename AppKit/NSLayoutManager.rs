//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
#[cfg(target_vendor = "apple")]
use objc2_core_graphics::*;
use objc2_foundation::*;

use crate::*;

/// Constants that describe the text layout orientation.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSTextLayoutOrientation(pub NSInteger);
impl NSTextLayoutOrientation {
    /// Lines render horizontally, each line following the previous from top to bottom.
    #[doc(alias = "NSTextLayoutOrientationHorizontal")]
    pub const Horizontal: Self = Self(0);
    /// Lines render vertically, each line following the previous from right to left.
    #[doc(alias = "NSTextLayoutOrientationVertical")]
    pub const Vertical: Self = Self(1);
}

unsafe impl Encode for NSTextLayoutOrientation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSTextLayoutOrientation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Glyph properties.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSGlyphProperty(pub NSInteger);
bitflags::bitflags! {
    impl NSGlyphProperty: NSInteger {
/// The null glyph, which the layout manager ignores.
        #[doc(alias = "NSGlyphPropertyNull")]
        const Null = 1<<0;
/// A glyph representing a control character.
///
/// ## Discussion
///
/// Control character such as tab, attachment, and so on, that has associated special behavior.
///
///
        #[doc(alias = "NSGlyphPropertyControlCharacter")]
        const ControlCharacter = 1<<1;
/// A glyph with a changeable width, such as a white space character.
        #[doc(alias = "NSGlyphPropertyElastic")]
        const Elastic = 1<<2;
/// A glyph that combines several properties.
///
/// ## Discussion
///
/// A glyph of this type typically represents characters in the Unicode Mn class.
///
///
        #[doc(alias = "NSGlyphPropertyNonBaseCharacter")]
        const NonBaseCharacter = 1<<3;
    }
}

unsafe impl Encode for NSGlyphProperty {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSGlyphProperty {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that describe actions for control characters.
///
/// ## Overview
///
/// These constants [`layoutManager:shouldUseAction:forControlCharacterAtIndex:`](https://developer.apple.com/documentation/appkit/nslayoutmanagerdelegate/layoutmanager(_:shoulduse:forcontrolcharacterat:)) delegate method uses.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSControlCharacterAction(pub NSInteger);
bitflags::bitflags! {
    impl NSControlCharacterAction: NSInteger {
/// An action that removes the glyph from layout.
///
/// ## Discussion
///
/// Glyphs with this action are filtered out from layout ([`notShownAttributeForGlyphAtIndex:`](https://developer.apple.com/documentation/appkit/nslayoutmanager/notshownattribute(forglyphat:)) `== YES` for the glyph).
///
///
        #[doc(alias = "NSControlCharacterActionZeroAdvancement")]
        const ZeroAdvancement = 1<<0;
/// An action that adds whitespace.
///
/// ## Discussion
///
/// The width for a glyph with this action is determined by the delegate method [`layoutManager:shouldUseAction:forControlCharacterAtIndex:`](https://developer.apple.com/documentation/appkit/nslayoutmanagerdelegate/layoutmanager(_:shoulduse:forcontrolcharacterat:)) if the method is implemented; otherwise, same as `NSControlCharacterZeroAdvancementAction`.
///
///
        #[doc(alias = "NSControlCharacterActionWhitespace")]
        const Whitespace = 1<<1;
/// An action that inserts a horizontal tab.
        #[doc(alias = "NSControlCharacterActionHorizontalTab")]
        const HorizontalTab = 1<<2;
/// An action that causes a line break.
        #[doc(alias = "NSControlCharacterActionLineBreak")]
        const LineBreak = 1<<3;
/// An action that causes a paragraph break.
///
/// ## Discussion
///
/// The value in [`firstLineHeadIndent`](https://developer.apple.com/documentation/appkit/nsparagraphstyle/firstlineheadindent) is used for the following glyph.
///
///
        #[doc(alias = "NSControlCharacterActionParagraphBreak")]
        const ParagraphBreak = 1<<4;
/// An action that triggers a break in layout for the current container.
        #[doc(alias = "NSControlCharacterActionContainerBreak")]
        const ContainerBreak = 1<<5;
    }
}

unsafe impl Encode for NSControlCharacterAction {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSControlCharacterAction {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A set of methods that define the orientation of text for an object.
    ///
    /// ## Overview
    ///
    /// In macOS, the [`NSTextContainer`](https://developer.apple.com/documentation/appkit/nstextcontainer) and [`NSTextView`](https://developer.apple.com/documentation/appkit/nstextview) classes adopt this protocol; in iOS, only the [`NSTextContainer`](https://developer.apple.com/documentation/appkit/nstextcontainer) class implements it. An [`NSTextContainer`](https://developer.apple.com/documentation/appkit/nstextcontainer) object returns the value from its associated text view when present; otherwise, it returns [`NSTextLayoutOrientationHorizontal`](https://developer.apple.com/documentation/appkit/nslayoutmanager/textlayoutorientation/horizontal) by default. If you define a custom [`NSTextContainer`](https://developer.apple.com/documentation/appkit/nstextcontainer) object, you can override this method and return [`NSTextLayoutOrientationVertical`](https://developer.apple.com/documentation/appkit/nslayoutmanager/textlayoutorientation/vertical) to support laying out text vertically.
    ///
    ///
    pub unsafe trait NSTextLayoutOrientationProvider {
        #[unsafe(method(layoutOrientation))]
        #[unsafe(method_family = none)]
        fn layoutOrientation(&self) -> NSTextLayoutOrientation;
    }
);

/// Constants that determine the layout manager’s behavior during layout.
///
/// ## Overview
///
/// These constants define the behavior of `NSLayoutManager` and `NSTypesetter` when laying out lines. They are used by [`typesetterBehavior`](https://developer.apple.com/documentation/appkit/nslayoutmanager/typesetterbehavior-swift.property) to control the compatibility level of the typesetter.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSTypesetterBehavior(pub NSInteger);
impl NSTypesetterBehavior {
    /// The current typesetter behavior in the current operating system.
    ///
    /// ## Discussion
    ///
    /// For OS X v10.2, this behavior is identical to `NSTypesetterBehavior_10_2`. If you use this behavior setting, you cannot necessarily rely on line width and height metrics remaining the same across different versions of macOS.
    ///
    ///
    #[doc(alias = "NSTypesetterLatestBehavior")]
    pub const LatestBehavior: Self = Self(-1);
    /// The original typesetter behavior, as shipped with macOS 10.1 and earlier.
    #[doc(alias = "NSTypesetterOriginalBehavior")]
    pub const OriginalBehavior: Self = Self(0);
    /// The macOS 10.2 typesetting behavior that is still compatible with the original typesetter behavior.
    ///
    /// ## Discussion
    ///
    /// The typesetting behavior is the same as `NSTypesetterBehavior_10_2`, but using line widths and height metric calculations that are the same as with `NSTypesetterOriginalBehavior`.
    ///
    ///
    #[doc(alias = "NSTypesetterBehavior_10_2_WithCompatibility")]
    pub const Behavior_10_2_WithCompatibility: Self = Self(1);
    /// The typesetter behavior introduced in macOS 10.2.
    ///
    /// ## Discussion
    ///
    /// This typesetter behavior provides enhanced line and character spacing accuracy and supports more languages than the original typesetter behavior.
    ///
    ///
    #[doc(alias = "NSTypesetterBehavior_10_2")]
    pub const Behavior_10_2: Self = Self(2);
    /// The typesetter behavior introduced in macOS 10.3.
    #[doc(alias = "NSTypesetterBehavior_10_3")]
    pub const Behavior_10_3: Self = Self(3);
    /// The typesetter behavior introduced in macOS 10.4.
    #[doc(alias = "NSTypesetterBehavior_10_4")]
    pub const Behavior_10_4: Self = Self(4);
}

unsafe impl Encode for NSTypesetterBehavior {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSTypesetterBehavior {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that coordinates the layout and display of text characters.
    ///
    /// ## Overview
    ///
    /// [`NSLayoutManager`](https://developer.apple.com/documentation/appkit/nslayoutmanager) maps Unicode character codes to glyphs, sets the glyphs in a series of [`NSTextContainer`](https://developer.apple.com/documentation/appkit/nstextcontainer) objects, and displays them in a series of [`NSTextView`](https://developer.apple.com/documentation/appkit/nstextview) objects. In addition to its core function of laying out text, a layout manager object coordinates its text view objects, provides services to those text views to support [`NSRulerView`](https://developer.apple.com/documentation/appkit/nsrulerview) instances for editing paragraph styles, and handles the layout and display of text attributes not inherent in glyphs (such as underline or strikethrough). You can create a subclass of [`NSLayoutManager`](https://developer.apple.com/documentation/appkit/nslayoutmanager) to handle additional text attributes, whether inherent or not.
    ///
    /// ### Text Antialiasing
    ///
    /// [`NSLayoutManager`](https://developer.apple.com/documentation/appkit/nslayoutmanager) provides the threshold for text antialiasing. It looks at the `AppleAntiAliasingThreshold` default value. If the font size is smaller than or equal to this threshold size, the text is rendered aliased by [`NSLayoutManager`](https://developer.apple.com/documentation/appkit/nslayoutmanager). In macOS, you can change the threshold value from the Appearance pane of System Preferences.
    ///
    /// ### Thread Safety of NSLayoutManager
    ///
    /// Generally speaking, a specific layout manager (and associated objects) should not be used in more than one block, operation, or thread at a time. Most layout managers are used on the main thread, since it is the main thread on which their text views are displayed, and since background layout occurs on the main thread.
    ///
    /// If you want to use a layout manager on a background thread, first make sure that text views associated with that layout manager (if any) are not displayed while the layout manager is being used on the background thread, and, second, turn off background layout for that layout manager while it is being used on the background thread. The most effective way to ensure that no text view is displayed, without knowing deep implementation, is just not to connect a text view to the layout manager.
    ///
    /// ### Noncontiguous Layout
    ///
    /// Noncontiguous layout is an optional layout manager behavior. Previously, both glyph generation and layout were always performed, in order, from the beginning to the end of the document. When noncontiguous layout is turned on, however, the layout manager gains the option of performing glyph generation or layout for one portion of the document without having done so for previous sections. This can provide significant performance improvements for large documents.
    ///
    /// Noncontiguous layout is not turned on automatically because direct clients of `NSLayoutManager` typically have relied on the previous behavior—for example, by forcing layout for a specific glyph range, and then assuming that previous glyphs would therefore be laid out. Clients who use [`NSLayoutManager`](https://developer.apple.com/documentation/appkit/nslayoutmanager) only indirectly—for example, those who use [`NSTextView`](https://developer.apple.com/documentation/appkit/nstextview) without directly calling the underlying layout manager—can usually turn on noncontiguous layout without difficulty. Clients using [`NSLayoutManager`](https://developer.apple.com/documentation/appkit/nslayoutmanager) directly need to examine their usage before turning on noncontiguous layout.
    ///
    /// Enable noncontiguous layout using the [`allowsNonContiguousLayout`](https://developer.apple.com/documentation/appkit/nslayoutmanager/allowsnoncontiguouslayout) property. In addition, see the other methods in [Causing glyph generation and layout](https://developer.apple.com/documentation/appkit/nslayoutmanager#causing-glyph-generation-and-layout), many of which enable you to ensure that glyph generation and layout are performed for specified portions of the text. The behavior of a number of other layout manager methods is affected by the state of noncontiguous layout, as noted in the discussion sections of those method descriptions.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSLayoutManager;
);

extern_conformance!(
    unsafe impl NSCoding for NSLayoutManager {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSLayoutManager {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NSLayoutManager {}
);

impl NSLayoutManager {
    extern_methods!(
        /// ************************** Initialization ***************************
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSTextStorage")]
        /// ************************* Text storage **************************
        ///
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(textStorage))]
        #[unsafe(method_family = none)]
        pub unsafe fn textStorage(&self) -> Option<Retained<NSTextStorage>>;

        #[cfg(feature = "NSTextStorage")]
        /// Setter for [`textStorage`][Self::textStorage].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setTextStorage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTextStorage(&self, text_storage: Option<&NSTextStorage>);

        #[cfg(feature = "NSTextStorage")]
        #[unsafe(method(replaceTextStorage:))]
        #[unsafe(method_family = none)]
        pub fn replaceTextStorage(&self, new_text_storage: &NSTextStorage);

        #[cfg(feature = "NSTextContainer")]
        /// ************************** Text containers ***************************
        #[unsafe(method(textContainers))]
        #[unsafe(method_family = none)]
        pub fn textContainers(&self) -> Retained<NSArray<NSTextContainer>>;

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(addTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn addTextContainer(&self, container: &NSTextContainer);

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(insertTextContainer:atIndex:))]
        #[unsafe(method_family = none)]
        pub fn insertTextContainer_atIndex(&self, container: &NSTextContainer, index: NSUInteger);

        #[unsafe(method(removeTextContainerAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn removeTextContainerAtIndex(&self, index: NSUInteger);

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(textContainerChangedGeometry:))]
        #[unsafe(method_family = none)]
        pub fn textContainerChangedGeometry(&self, container: &NSTextContainer);

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(textContainerChangedTextView:))]
        #[unsafe(method_family = none)]
        pub fn textContainerChangedTextView(&self, container: &NSTextContainer);

        /// ************************** Delegate ***************************
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSLayoutManagerDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSLayoutManagerDelegate>>);

        /// ********************* Global layout manager options **********************
        #[unsafe(method(showsInvisibleCharacters))]
        #[unsafe(method_family = none)]
        pub fn showsInvisibleCharacters(&self) -> bool;

        /// Setter for [`showsInvisibleCharacters`][Self::showsInvisibleCharacters].
        #[unsafe(method(setShowsInvisibleCharacters:))]
        #[unsafe(method_family = none)]
        pub fn setShowsInvisibleCharacters(&self, shows_invisible_characters: bool);

        #[unsafe(method(showsControlCharacters))]
        #[unsafe(method_family = none)]
        pub fn showsControlCharacters(&self) -> bool;

        /// Setter for [`showsControlCharacters`][Self::showsControlCharacters].
        #[unsafe(method(setShowsControlCharacters:))]
        #[unsafe(method_family = none)]
        pub fn setShowsControlCharacters(&self, shows_control_characters: bool);

        #[unsafe(method(usesDefaultHyphenation))]
        #[unsafe(method_family = none)]
        pub fn usesDefaultHyphenation(&self) -> bool;

        /// Setter for [`usesDefaultHyphenation`][Self::usesDefaultHyphenation].
        #[unsafe(method(setUsesDefaultHyphenation:))]
        #[unsafe(method_family = none)]
        pub fn setUsesDefaultHyphenation(&self, uses_default_hyphenation: bool);

        #[unsafe(method(usesFontLeading))]
        #[unsafe(method_family = none)]
        pub fn usesFontLeading(&self) -> bool;

        /// Setter for [`usesFontLeading`][Self::usesFontLeading].
        #[unsafe(method(setUsesFontLeading:))]
        #[unsafe(method_family = none)]
        pub fn setUsesFontLeading(&self, uses_font_leading: bool);

        #[unsafe(method(allowsNonContiguousLayout))]
        #[unsafe(method_family = none)]
        pub fn allowsNonContiguousLayout(&self) -> bool;

        /// Setter for [`allowsNonContiguousLayout`][Self::allowsNonContiguousLayout].
        #[unsafe(method(setAllowsNonContiguousLayout:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsNonContiguousLayout(&self, allows_non_contiguous_layout: bool);

        #[unsafe(method(hasNonContiguousLayout))]
        #[unsafe(method_family = none)]
        pub fn hasNonContiguousLayout(&self) -> bool;

        #[unsafe(method(limitsLayoutForSuspiciousContents))]
        #[unsafe(method_family = none)]
        pub fn limitsLayoutForSuspiciousContents(&self) -> bool;

        /// Setter for [`limitsLayoutForSuspiciousContents`][Self::limitsLayoutForSuspiciousContents].
        #[unsafe(method(setLimitsLayoutForSuspiciousContents:))]
        #[unsafe(method_family = none)]
        pub fn setLimitsLayoutForSuspiciousContents(
            &self,
            limits_layout_for_suspicious_contents: bool,
        );

        #[unsafe(method(backgroundLayoutEnabled))]
        #[unsafe(method_family = none)]
        pub fn backgroundLayoutEnabled(&self) -> bool;

        /// Setter for [`backgroundLayoutEnabled`][Self::backgroundLayoutEnabled].
        #[unsafe(method(setBackgroundLayoutEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setBackgroundLayoutEnabled(&self, background_layout_enabled: bool);

        #[cfg(feature = "NSCell")]
        #[unsafe(method(defaultAttachmentScaling))]
        #[unsafe(method_family = none)]
        pub fn defaultAttachmentScaling(&self) -> NSImageScaling;

        #[cfg(feature = "NSCell")]
        /// Setter for [`defaultAttachmentScaling`][Self::defaultAttachmentScaling].
        #[unsafe(method(setDefaultAttachmentScaling:))]
        #[unsafe(method_family = none)]
        pub fn setDefaultAttachmentScaling(&self, default_attachment_scaling: NSImageScaling);

        #[cfg(feature = "NSTypesetter")]
        /// ********************* Typesetter **********************
        #[unsafe(method(typesetter))]
        #[unsafe(method_family = none)]
        pub fn typesetter(&self) -> Retained<NSTypesetter>;

        #[cfg(feature = "NSTypesetter")]
        /// Setter for [`typesetter`][Self::typesetter].
        #[unsafe(method(setTypesetter:))]
        #[unsafe(method_family = none)]
        pub fn setTypesetter(&self, typesetter: &NSTypesetter);

        #[unsafe(method(typesetterBehavior))]
        #[unsafe(method_family = none)]
        pub fn typesetterBehavior(&self) -> NSTypesetterBehavior;

        /// Setter for [`typesetterBehavior`][Self::typesetterBehavior].
        #[unsafe(method(setTypesetterBehavior:))]
        #[unsafe(method_family = none)]
        pub fn setTypesetterBehavior(&self, typesetter_behavior: NSTypesetterBehavior);

        /// ************************ Invalidation *************************
        ///
        /// # Safety
        ///
        /// `actual_char_range` must be a valid pointer or null.
        #[unsafe(method(invalidateGlyphsForCharacterRange:changeInLength:actualCharacterRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidateGlyphsForCharacterRange_changeInLength_actualCharacterRange(
            &self,
            char_range: NSRange,
            delta: NSInteger,
            actual_char_range: NSRangePointer,
        );

        /// # Safety
        ///
        /// `actual_char_range` must be a valid pointer or null.
        #[unsafe(method(invalidateLayoutForCharacterRange:actualCharacterRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidateLayoutForCharacterRange_actualCharacterRange(
            &self,
            char_range: NSRange,
            actual_char_range: NSRangePointer,
        );

        #[unsafe(method(invalidateDisplayForCharacterRange:))]
        #[unsafe(method_family = none)]
        pub fn invalidateDisplayForCharacterRange(&self, char_range: NSRange);

        #[unsafe(method(invalidateDisplayForGlyphRange:))]
        #[unsafe(method_family = none)]
        pub fn invalidateDisplayForGlyphRange(&self, glyph_range: NSRange);

        #[cfg(feature = "NSTextStorage")]
        #[unsafe(method(processEditingForTextStorage:edited:range:changeInLength:invalidatedRange:))]
        #[unsafe(method_family = none)]
        pub fn processEditingForTextStorage_edited_range_changeInLength_invalidatedRange(
            &self,
            text_storage: &NSTextStorage,
            edit_mask: NSTextStorageEditActions,
            new_char_range: NSRange,
            delta: NSInteger,
            invalidated_char_range: NSRange,
        );

        /// ********************** Causing glyph generation and layout ***********************
        #[unsafe(method(ensureGlyphsForCharacterRange:))]
        #[unsafe(method_family = none)]
        pub fn ensureGlyphsForCharacterRange(&self, char_range: NSRange);

        #[unsafe(method(ensureGlyphsForGlyphRange:))]
        #[unsafe(method_family = none)]
        pub fn ensureGlyphsForGlyphRange(&self, glyph_range: NSRange);

        #[unsafe(method(ensureLayoutForCharacterRange:))]
        #[unsafe(method_family = none)]
        pub fn ensureLayoutForCharacterRange(&self, char_range: NSRange);

        #[unsafe(method(ensureLayoutForGlyphRange:))]
        #[unsafe(method_family = none)]
        pub fn ensureLayoutForGlyphRange(&self, glyph_range: NSRange);

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(ensureLayoutForTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn ensureLayoutForTextContainer(&self, container: &NSTextContainer);

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(ensureLayoutForBoundingRect:inTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn ensureLayoutForBoundingRect_inTextContainer(
            &self,
            bounds: NSRect,
            container: &NSTextContainer,
        );

        #[cfg(all(feature = "NSFont", feature = "objc2-core-graphics"))]
        #[cfg(target_vendor = "apple")]
        /// ********************** Set glyphs and glyph properties ***********************
        ///
        /// # Safety
        ///
        /// - `glyphs` must be a valid pointer.
        /// - `props` must be a valid pointer.
        /// - `char_indexes` must be a valid pointer.
        #[unsafe(method(setGlyphs:properties:characterIndexes:font:forGlyphRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGlyphs_properties_characterIndexes_font_forGlyphRange(
            &self,
            glyphs: NonNull<CGGlyph>,
            props: NonNull<NSGlyphProperty>,
            char_indexes: NonNull<NSUInteger>,
            a_font: &NSFont,
            glyph_range: NSRange,
        );

        /// ********************** Get glyphs and glyph properties ***********************
        #[unsafe(method(numberOfGlyphs))]
        #[unsafe(method_family = none)]
        pub fn numberOfGlyphs(&self) -> NSUInteger;

        #[cfg(feature = "objc2-core-graphics")]
        #[cfg(target_vendor = "apple")]
        /// # Safety
        ///
        /// `is_valid_index` must be a valid pointer or null.
        #[unsafe(method(CGGlyphAtIndex:isValidIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn CGGlyphAtIndex_isValidIndex(
            &self,
            glyph_index: NSUInteger,
            is_valid_index: *mut Bool,
        ) -> CGGlyph;

        #[cfg(feature = "objc2-core-graphics")]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(CGGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn CGGlyphAtIndex(&self, glyph_index: NSUInteger) -> CGGlyph;

        #[unsafe(method(isValidGlyphIndex:))]
        #[unsafe(method_family = none)]
        pub fn isValidGlyphIndex(&self, glyph_index: NSUInteger) -> bool;

        #[unsafe(method(propertyForGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn propertyForGlyphAtIndex(&self, glyph_index: NSUInteger) -> NSGlyphProperty;

        #[unsafe(method(characterIndexForGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn characterIndexForGlyphAtIndex(&self, glyph_index: NSUInteger) -> NSUInteger;

        #[unsafe(method(glyphIndexForCharacterAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn glyphIndexForCharacterAtIndex(&self, char_index: NSUInteger) -> NSUInteger;

        #[cfg(feature = "objc2-core-graphics")]
        #[cfg(target_vendor = "apple")]
        /// # Safety
        ///
        /// - `glyph_buffer` must be a valid pointer or null.
        /// - `props` must be a valid pointer or null.
        /// - `char_index_buffer` must be a valid pointer or null.
        /// - `bidi_level_buffer` must be a valid pointer or null.
        #[unsafe(method(getGlyphsInRange:glyphs:properties:characterIndexes:bidiLevels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getGlyphsInRange_glyphs_properties_characterIndexes_bidiLevels(
            &self,
            glyph_range: NSRange,
            glyph_buffer: *mut CGGlyph,
            props: *mut NSGlyphProperty,
            char_index_buffer: *mut NSUInteger,
            bidi_level_buffer: *mut c_uchar,
        ) -> NSUInteger;

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(setTextContainer:forGlyphRange:))]
        #[unsafe(method_family = none)]
        pub fn setTextContainer_forGlyphRange(
            &self,
            container: &NSTextContainer,
            glyph_range: NSRange,
        );

        #[unsafe(method(setLineFragmentRect:forGlyphRange:usedRect:))]
        #[unsafe(method_family = none)]
        pub fn setLineFragmentRect_forGlyphRange_usedRect(
            &self,
            fragment_rect: NSRect,
            glyph_range: NSRange,
            used_rect: NSRect,
        );

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(setExtraLineFragmentRect:usedRect:textContainer:))]
        #[unsafe(method_family = none)]
        pub fn setExtraLineFragmentRect_usedRect_textContainer(
            &self,
            fragment_rect: NSRect,
            used_rect: NSRect,
            container: &NSTextContainer,
        );

        #[unsafe(method(setLocation:forStartOfGlyphRange:))]
        #[unsafe(method_family = none)]
        pub fn setLocation_forStartOfGlyphRange(&self, location: NSPoint, glyph_range: NSRange);

        #[unsafe(method(setNotShownAttribute:forGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setNotShownAttribute_forGlyphAtIndex(&self, flag: bool, glyph_index: NSUInteger);

        #[unsafe(method(setDrawsOutsideLineFragment:forGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setDrawsOutsideLineFragment_forGlyphAtIndex(
            &self,
            flag: bool,
            glyph_index: NSUInteger,
        );

        #[unsafe(method(setAttachmentSize:forGlyphRange:))]
        #[unsafe(method_family = none)]
        pub fn setAttachmentSize_forGlyphRange(
            &self,
            attachment_size: NSSize,
            glyph_range: NSRange,
        );

        /// ********************** Get layout information ***********************
        ///
        /// # Safety
        ///
        /// - `char_index` must be a valid pointer or null.
        /// - `glyph_index` must be a valid pointer or null.
        #[unsafe(method(getFirstUnlaidCharacterIndex:glyphIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getFirstUnlaidCharacterIndex_glyphIndex(
            &self,
            char_index: *mut NSUInteger,
            glyph_index: *mut NSUInteger,
        );

        #[unsafe(method(firstUnlaidCharacterIndex))]
        #[unsafe(method_family = none)]
        pub fn firstUnlaidCharacterIndex(&self) -> NSUInteger;

        #[unsafe(method(firstUnlaidGlyphIndex))]
        #[unsafe(method_family = none)]
        pub fn firstUnlaidGlyphIndex(&self) -> NSUInteger;

        #[cfg(feature = "NSTextContainer")]
        /// # Safety
        ///
        /// `effective_glyph_range` must be a valid pointer or null.
        #[unsafe(method(textContainerForGlyphAtIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textContainerForGlyphAtIndex_effectiveRange(
            &self,
            glyph_index: NSUInteger,
            effective_glyph_range: NSRangePointer,
        ) -> Option<Retained<NSTextContainer>>;

        #[cfg(feature = "NSTextContainer")]
        /// # Safety
        ///
        /// `effective_glyph_range` must be a valid pointer or null.
        #[unsafe(method(textContainerForGlyphAtIndex:effectiveRange:withoutAdditionalLayout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textContainerForGlyphAtIndex_effectiveRange_withoutAdditionalLayout(
            &self,
            glyph_index: NSUInteger,
            effective_glyph_range: NSRangePointer,
            flag: bool,
        ) -> Option<Retained<NSTextContainer>>;

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(usedRectForTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn usedRectForTextContainer(&self, container: &NSTextContainer) -> NSRect;

        /// # Safety
        ///
        /// `effective_glyph_range` must be a valid pointer or null.
        #[unsafe(method(lineFragmentRectForGlyphAtIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn lineFragmentRectForGlyphAtIndex_effectiveRange(
            &self,
            glyph_index: NSUInteger,
            effective_glyph_range: NSRangePointer,
        ) -> NSRect;

        /// # Safety
        ///
        /// `effective_glyph_range` must be a valid pointer or null.
        #[unsafe(method(lineFragmentRectForGlyphAtIndex:effectiveRange:withoutAdditionalLayout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn lineFragmentRectForGlyphAtIndex_effectiveRange_withoutAdditionalLayout(
            &self,
            glyph_index: NSUInteger,
            effective_glyph_range: NSRangePointer,
            flag: bool,
        ) -> NSRect;

        /// # Safety
        ///
        /// `effective_glyph_range` must be a valid pointer or null.
        #[unsafe(method(lineFragmentUsedRectForGlyphAtIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn lineFragmentUsedRectForGlyphAtIndex_effectiveRange(
            &self,
            glyph_index: NSUInteger,
            effective_glyph_range: NSRangePointer,
        ) -> NSRect;

        /// # Safety
        ///
        /// `effective_glyph_range` must be a valid pointer or null.
        #[unsafe(method(lineFragmentUsedRectForGlyphAtIndex:effectiveRange:withoutAdditionalLayout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn lineFragmentUsedRectForGlyphAtIndex_effectiveRange_withoutAdditionalLayout(
            &self,
            glyph_index: NSUInteger,
            effective_glyph_range: NSRangePointer,
            flag: bool,
        ) -> NSRect;

        #[unsafe(method(extraLineFragmentRect))]
        #[unsafe(method_family = none)]
        pub fn extraLineFragmentRect(&self) -> NSRect;

        #[unsafe(method(extraLineFragmentUsedRect))]
        #[unsafe(method_family = none)]
        pub fn extraLineFragmentUsedRect(&self) -> NSRect;

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(extraLineFragmentTextContainer))]
        #[unsafe(method_family = none)]
        pub fn extraLineFragmentTextContainer(&self) -> Option<Retained<NSTextContainer>>;

        #[unsafe(method(locationForGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn locationForGlyphAtIndex(&self, glyph_index: NSUInteger) -> NSPoint;

        #[unsafe(method(notShownAttributeForGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn notShownAttributeForGlyphAtIndex(&self, glyph_index: NSUInteger) -> bool;

        #[unsafe(method(drawsOutsideLineFragmentForGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn drawsOutsideLineFragmentForGlyphAtIndex(&self, glyph_index: NSUInteger) -> bool;

        #[unsafe(method(attachmentSizeForGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn attachmentSizeForGlyphAtIndex(&self, glyph_index: NSUInteger) -> NSSize;

        #[unsafe(method(truncatedGlyphRangeInLineFragmentForGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn truncatedGlyphRangeInLineFragmentForGlyphAtIndex(
            &self,
            glyph_index: NSUInteger,
        ) -> NSRange;

        /// ********************** More sophisticated queries ***********************
        ///
        /// # Safety
        ///
        /// `actual_char_range` must be a valid pointer or null.
        #[unsafe(method(glyphRangeForCharacterRange:actualCharacterRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn glyphRangeForCharacterRange_actualCharacterRange(
            &self,
            char_range: NSRange,
            actual_char_range: NSRangePointer,
        ) -> NSRange;

        /// # Safety
        ///
        /// `actual_glyph_range` must be a valid pointer or null.
        #[unsafe(method(characterRangeForGlyphRange:actualGlyphRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn characterRangeForGlyphRange_actualGlyphRange(
            &self,
            glyph_range: NSRange,
            actual_glyph_range: NSRangePointer,
        ) -> NSRange;

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(glyphRangeForTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn glyphRangeForTextContainer(&self, container: &NSTextContainer) -> NSRange;

        #[unsafe(method(rangeOfNominallySpacedGlyphsContainingIndex:))]
        #[unsafe(method_family = none)]
        pub fn rangeOfNominallySpacedGlyphsContainingIndex(
            &self,
            glyph_index: NSUInteger,
        ) -> NSRange;

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(boundingRectForGlyphRange:inTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn boundingRectForGlyphRange_inTextContainer(
            &self,
            glyph_range: NSRange,
            container: &NSTextContainer,
        ) -> NSRect;

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(glyphRangeForBoundingRect:inTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn glyphRangeForBoundingRect_inTextContainer(
            &self,
            bounds: NSRect,
            container: &NSTextContainer,
        ) -> NSRange;

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(glyphRangeForBoundingRectWithoutAdditionalLayout:inTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn glyphRangeForBoundingRectWithoutAdditionalLayout_inTextContainer(
            &self,
            bounds: NSRect,
            container: &NSTextContainer,
        ) -> NSRange;

        #[cfg(all(feature = "NSTextContainer", feature = "objc2-core-foundation"))]
        /// # Safety
        ///
        /// `partial_fraction` must be a valid pointer or null.
        #[unsafe(method(glyphIndexForPoint:inTextContainer:fractionOfDistanceThroughGlyph:))]
        #[unsafe(method_family = none)]
        pub unsafe fn glyphIndexForPoint_inTextContainer_fractionOfDistanceThroughGlyph(
            &self,
            point: NSPoint,
            container: &NSTextContainer,
            partial_fraction: *mut CGFloat,
        ) -> NSUInteger;

        #[cfg(feature = "NSTextContainer")]
        #[unsafe(method(glyphIndexForPoint:inTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn glyphIndexForPoint_inTextContainer(
            &self,
            point: NSPoint,
            container: &NSTextContainer,
        ) -> NSUInteger;

        #[cfg(all(feature = "NSTextContainer", feature = "objc2-core-foundation"))]
        #[unsafe(method(fractionOfDistanceThroughGlyphForPoint:inTextContainer:))]
        #[unsafe(method_family = none)]
        pub fn fractionOfDistanceThroughGlyphForPoint_inTextContainer(
            &self,
            point: NSPoint,
            container: &NSTextContainer,
        ) -> CGFloat;

        #[cfg(all(feature = "NSTextContainer", feature = "objc2-core-foundation"))]
        /// # Safety
        ///
        /// `partial_fraction` must be a valid pointer or null.
        #[unsafe(method(characterIndexForPoint:inTextContainer:fractionOfDistanceBetweenInsertionPoints:))]
        #[unsafe(method_family = none)]
        pub unsafe fn characterIndexForPoint_inTextContainer_fractionOfDistanceBetweenInsertionPoints(
            &self,
            point: NSPoint,
            container: &NSTextContainer,
            partial_fraction: *mut CGFloat,
        ) -> NSUInteger;

        #[cfg(feature = "objc2-core-foundation")]
        /// # Safety
        ///
        /// - `positions` must be a valid pointer or null.
        /// - `char_indexes` must be a valid pointer or null.
        #[unsafe(method(getLineFragmentInsertionPointsForCharacterAtIndex:alternatePositions:inDisplayOrder:positions:characterIndexes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLineFragmentInsertionPointsForCharacterAtIndex_alternatePositions_inDisplayOrder_positions_characterIndexes(
            &self,
            char_index: NSUInteger,
            a_flag: bool,
            d_flag: bool,
            positions: *mut CGFloat,
            char_indexes: *mut NSUInteger,
        ) -> NSUInteger;

        #[cfg(all(feature = "NSTextContainer", feature = "block2"))]
        #[unsafe(method(enumerateLineFragmentsForGlyphRange:usingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateLineFragmentsForGlyphRange_usingBlock(
            &self,
            glyph_range: NSRange,
            block: &block2::DynBlock<
                dyn Fn(NSRect, NSRect, NonNull<NSTextContainer>, NSRange, NonNull<Bool>),
            >,
        );

        #[cfg(all(feature = "NSTextContainer", feature = "block2"))]
        #[unsafe(method(enumerateEnclosingRectsForGlyphRange:withinSelectedGlyphRange:inTextContainer:usingBlock:))]
        #[unsafe(method_family = none)]
        pub fn enumerateEnclosingRectsForGlyphRange_withinSelectedGlyphRange_inTextContainer_usingBlock(
            &self,
            glyph_range: NSRange,
            selected_range: NSRange,
            text_container: &NSTextContainer,
            block: &block2::DynBlock<dyn Fn(NSRect, NonNull<Bool>)>,
        );

        /// ********************** Drawing support ***********************
        #[unsafe(method(drawBackgroundForGlyphRange:atPoint:))]
        #[unsafe(method_family = none)]
        pub fn drawBackgroundForGlyphRange_atPoint(&self, glyphs_to_show: NSRange, origin: NSPoint);

        #[unsafe(method(drawGlyphsForGlyphRange:atPoint:))]
        #[unsafe(method_family = none)]
        pub fn drawGlyphsForGlyphRange_atPoint(&self, glyphs_to_show: NSRange, origin: NSPoint);

        #[cfg(all(
            feature = "NSFont",
            feature = "objc2-core-foundation",
            feature = "objc2-core-graphics"
        ))]
        #[cfg(target_vendor = "apple")]
        /// # Safety
        ///
        /// - `glyphs` must be a valid pointer.
        /// - `positions` must be a valid pointer.
        /// - `attributes` generic should be of the correct type.
        #[unsafe(method(showCGGlyphs:positions:count:font:textMatrix:attributes:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn showCGGlyphs_positions_count_font_textMatrix_attributes_inContext(
            &self,
            glyphs: NonNull<CGGlyph>,
            positions: NonNull<CGPoint>,
            glyph_count: NSInteger,
            font: &NSFont,
            text_matrix: CGAffineTransform,
            attributes: &NSDictionary<NSAttributedStringKey, AnyObject>,
            cg_context: &CGContext,
        );

        #[cfg(feature = "NSColor")]
        /// # Safety
        ///
        /// `rect_array` must be a valid pointer.
        #[unsafe(method(fillBackgroundRectArray:count:forCharacterRange:color:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fillBackgroundRectArray_count_forCharacterRange_color(
            &self,
            rect_array: NonNull<NSRect>,
            rect_count: NSUInteger,
            char_range: NSRange,
            color: &NSColor,
        );

        #[cfg(all(feature = "NSAttributedString", feature = "objc2-core-foundation"))]
        #[unsafe(method(drawUnderlineForGlyphRange:underlineType:baselineOffset:lineFragmentRect:lineFragmentGlyphRange:containerOrigin:))]
        #[unsafe(method_family = none)]
        pub fn drawUnderlineForGlyphRange_underlineType_baselineOffset_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(
            &self,
            glyph_range: NSRange,
            underline_val: NSUnderlineStyle,
            baseline_offset: CGFloat,
            line_rect: NSRect,
            line_glyph_range: NSRange,
            container_origin: NSPoint,
        );

        #[cfg(feature = "NSAttributedString")]
        #[unsafe(method(underlineGlyphRange:underlineType:lineFragmentRect:lineFragmentGlyphRange:containerOrigin:))]
        #[unsafe(method_family = none)]
        pub fn underlineGlyphRange_underlineType_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(
            &self,
            glyph_range: NSRange,
            underline_val: NSUnderlineStyle,
            line_rect: NSRect,
            line_glyph_range: NSRange,
            container_origin: NSPoint,
        );

        #[cfg(all(feature = "NSAttributedString", feature = "objc2-core-foundation"))]
        #[unsafe(method(drawStrikethroughForGlyphRange:strikethroughType:baselineOffset:lineFragmentRect:lineFragmentGlyphRange:containerOrigin:))]
        #[unsafe(method_family = none)]
        pub fn drawStrikethroughForGlyphRange_strikethroughType_baselineOffset_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(
            &self,
            glyph_range: NSRange,
            strikethrough_val: NSUnderlineStyle,
            baseline_offset: CGFloat,
            line_rect: NSRect,
            line_glyph_range: NSRange,
            container_origin: NSPoint,
        );

        #[cfg(feature = "NSAttributedString")]
        #[unsafe(method(strikethroughGlyphRange:strikethroughType:lineFragmentRect:lineFragmentGlyphRange:containerOrigin:))]
        #[unsafe(method_family = none)]
        pub fn strikethroughGlyphRange_strikethroughType_lineFragmentRect_lineFragmentGlyphRange_containerOrigin(
            &self,
            glyph_range: NSRange,
            strikethrough_val: NSUnderlineStyle,
            line_rect: NSRect,
            line_glyph_range: NSRange,
            container_origin: NSPoint,
        );

        #[cfg(feature = "NSCell")]
        #[unsafe(method(showAttachmentCell:inRect:characterIndex:))]
        #[unsafe(method_family = none)]
        pub fn showAttachmentCell_inRect_characterIndex(
            &self,
            cell: &NSCell,
            rect: NSRect,
            attachment_index: NSUInteger,
        );

        #[cfg(feature = "NSTextTable")]
        /// ************************ Block information *************************
        #[unsafe(method(setLayoutRect:forTextBlock:glyphRange:))]
        #[unsafe(method_family = none)]
        pub fn setLayoutRect_forTextBlock_glyphRange(
            &self,
            rect: NSRect,
            block: &NSTextBlock,
            glyph_range: NSRange,
        );

        #[cfg(feature = "NSTextTable")]
        #[unsafe(method(setBoundsRect:forTextBlock:glyphRange:))]
        #[unsafe(method_family = none)]
        pub fn setBoundsRect_forTextBlock_glyphRange(
            &self,
            rect: NSRect,
            block: &NSTextBlock,
            glyph_range: NSRange,
        );

        #[cfg(feature = "NSTextTable")]
        #[unsafe(method(layoutRectForTextBlock:glyphRange:))]
        #[unsafe(method_family = none)]
        pub fn layoutRectForTextBlock_glyphRange(
            &self,
            block: &NSTextBlock,
            glyph_range: NSRange,
        ) -> NSRect;

        #[cfg(feature = "NSTextTable")]
        #[unsafe(method(boundsRectForTextBlock:glyphRange:))]
        #[unsafe(method_family = none)]
        pub fn boundsRectForTextBlock_glyphRange(
            &self,
            block: &NSTextBlock,
            glyph_range: NSRange,
        ) -> NSRect;

        #[cfg(feature = "NSTextTable")]
        /// # Safety
        ///
        /// `effective_glyph_range` must be a valid pointer or null.
        #[unsafe(method(layoutRectForTextBlock:atIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn layoutRectForTextBlock_atIndex_effectiveRange(
            &self,
            block: &NSTextBlock,
            glyph_index: NSUInteger,
            effective_glyph_range: NSRangePointer,
        ) -> NSRect;

        #[cfg(feature = "NSTextTable")]
        /// # Safety
        ///
        /// `effective_glyph_range` must be a valid pointer or null.
        #[unsafe(method(boundsRectForTextBlock:atIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn boundsRectForTextBlock_atIndex_effectiveRange(
            &self,
            block: &NSTextBlock,
            glyph_index: NSUInteger,
            effective_glyph_range: NSRangePointer,
        ) -> NSRect;

        /// ********************** Temporary attribute support ***********************
        ///
        /// # Safety
        ///
        /// `effective_char_range` must be a valid pointer or null.
        #[unsafe(method(temporaryAttributesAtCharacterIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryAttributesAtCharacterIndex_effectiveRange(
            &self,
            char_index: NSUInteger,
            effective_char_range: NSRangePointer,
        ) -> Retained<NSDictionary<NSAttributedStringKey, AnyObject>>;

        /// # Safety
        ///
        /// `attrs` generic should be of the correct type.
        #[unsafe(method(setTemporaryAttributes:forCharacterRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTemporaryAttributes_forCharacterRange(
            &self,
            attrs: &NSDictionary<NSAttributedStringKey, AnyObject>,
            char_range: NSRange,
        );

        /// # Safety
        ///
        /// `attrs` generic should be of the correct type.
        #[unsafe(method(addTemporaryAttributes:forCharacterRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTemporaryAttributes_forCharacterRange(
            &self,
            attrs: &NSDictionary<NSAttributedStringKey, AnyObject>,
            char_range: NSRange,
        );

        #[unsafe(method(removeTemporaryAttribute:forCharacterRange:))]
        #[unsafe(method_family = none)]
        pub fn removeTemporaryAttribute_forCharacterRange(
            &self,
            attr_name: &NSAttributedStringKey,
            char_range: NSRange,
        );

        /// # Safety
        ///
        /// `range` must be a valid pointer or null.
        #[unsafe(method(temporaryAttribute:atCharacterIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryAttribute_atCharacterIndex_effectiveRange(
            &self,
            attr_name: &NSAttributedStringKey,
            location: NSUInteger,
            range: NSRangePointer,
        ) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// `range` must be a valid pointer or null.
        #[unsafe(method(temporaryAttribute:atCharacterIndex:longestEffectiveRange:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryAttribute_atCharacterIndex_longestEffectiveRange_inRange(
            &self,
            attr_name: &NSAttributedStringKey,
            location: NSUInteger,
            range: NSRangePointer,
            range_limit: NSRange,
        ) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// `range` must be a valid pointer or null.
        #[unsafe(method(temporaryAttributesAtCharacterIndex:longestEffectiveRange:inRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporaryAttributesAtCharacterIndex_longestEffectiveRange_inRange(
            &self,
            location: NSUInteger,
            range: NSRangePointer,
            range_limit: NSRange,
        ) -> Retained<NSDictionary<NSAttributedStringKey, AnyObject>>;

        /// # Safety
        ///
        /// `value` should be of the correct type.
        #[unsafe(method(addTemporaryAttribute:value:forCharacterRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTemporaryAttribute_value_forCharacterRange(
            &self,
            attr_name: &NSAttributedStringKey,
            value: &AnyObject,
            char_range: NSRange,
        );

        #[cfg(all(feature = "NSFont", feature = "objc2-core-foundation"))]
        /// ***************************** Font metrics *****************************
        #[unsafe(method(defaultLineHeightForFont:))]
        #[unsafe(method_family = none)]
        pub fn defaultLineHeightForFont(&self, the_font: &NSFont) -> CGFloat;

        #[cfg(all(feature = "NSFont", feature = "objc2-core-foundation"))]
        #[unsafe(method(defaultBaselineOffsetForFont:))]
        #[unsafe(method_family = none)]
        pub fn defaultBaselineOffsetForFont(&self, the_font: &NSFont) -> CGFloat;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSLayoutManager {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSLayoutManager {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSTextViewSupport.
impl NSLayoutManager {
    extern_methods!(
        #[cfg(all(
            feature = "NSParagraphStyle",
            feature = "NSResponder",
            feature = "NSRulerMarker",
            feature = "NSRulerView",
            feature = "NSText",
            feature = "NSTextView",
            feature = "NSView"
        ))]
        /// *************************** Ruler support ****************************
        #[unsafe(method(rulerMarkersForTextView:paragraphStyle:ruler:))]
        #[unsafe(method_family = none)]
        pub fn rulerMarkersForTextView_paragraphStyle_ruler(
            &self,
            view: &NSTextView,
            style: &NSParagraphStyle,
            ruler: &NSRulerView,
        ) -> Retained<NSArray<NSRulerMarker>>;

        #[cfg(all(
            feature = "NSParagraphStyle",
            feature = "NSResponder",
            feature = "NSRulerView",
            feature = "NSText",
            feature = "NSTextView",
            feature = "NSView"
        ))]
        #[unsafe(method(rulerAccessoryViewForTextView:paragraphStyle:ruler:enabled:))]
        #[unsafe(method_family = none)]
        pub fn rulerAccessoryViewForTextView_paragraphStyle_ruler_enabled(
            &self,
            view: &NSTextView,
            style: &NSParagraphStyle,
            ruler: &NSRulerView,
            is_enabled: bool,
        ) -> Option<Retained<NSView>>;

        #[cfg(all(feature = "NSResponder", feature = "NSWindow"))]
        /// ********************** First responder support ***********************
        #[unsafe(method(layoutManagerOwnsFirstResponderInWindow:))]
        #[unsafe(method_family = none)]
        pub fn layoutManagerOwnsFirstResponderInWindow(&self, window: &NSWindow) -> bool;

        #[cfg(all(
            feature = "NSResponder",
            feature = "NSText",
            feature = "NSTextView",
            feature = "NSView"
        ))]
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(firstTextView))]
        #[unsafe(method_family = none)]
        pub unsafe fn firstTextView(&self, mtm: MainThreadMarker) -> Option<Retained<NSTextView>>;

        #[cfg(all(
            feature = "NSResponder",
            feature = "NSText",
            feature = "NSTextView",
            feature = "NSView"
        ))]
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(textViewForBeginningOfSelection))]
        #[unsafe(method_family = none)]
        pub unsafe fn textViewForBeginningOfSelection(
            &self,
            mtm: MainThreadMarker,
        ) -> Option<Retained<NSTextView>>;
    );
}

extern_protocol!(
    /// A set of optional methods that delegates of layout manager objects implement.
    pub unsafe trait NSLayoutManagerDelegate: NSObjectProtocol {
        #[cfg(all(feature = "NSFont", feature = "objc2-core-graphics"))]
        #[cfg(target_vendor = "apple")]
        /// ********************** Glyph generation ***********************
        ///
        /// # Safety
        ///
        /// - `glyphs` must be a valid pointer.
        /// - `props` must be a valid pointer.
        /// - `char_indexes` must be a valid pointer.
        #[optional]
        #[unsafe(method(layoutManager:shouldGenerateGlyphs:properties:characterIndexes:font:forGlyphRange:))]
        #[unsafe(method_family = none)]
        unsafe fn layoutManager_shouldGenerateGlyphs_properties_characterIndexes_font_forGlyphRange(
            &self,
            layout_manager: &NSLayoutManager,
            glyphs: NonNull<CGGlyph>,
            props: NonNull<NSGlyphProperty>,
            char_indexes: NonNull<NSUInteger>,
            a_font: &NSFont,
            glyph_range: NSRange,
        ) -> NSUInteger;

        #[cfg(feature = "objc2-core-foundation")]
        /// ********************** Line layout ***********************
        #[optional]
        #[unsafe(method(layoutManager:lineSpacingAfterGlyphAtIndex:withProposedLineFragmentRect:))]
        #[unsafe(method_family = none)]
        fn layoutManager_lineSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(
            &self,
            layout_manager: &NSLayoutManager,
            glyph_index: NSUInteger,
            rect: NSRect,
        ) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[optional]
        #[unsafe(method(layoutManager:paragraphSpacingBeforeGlyphAtIndex:withProposedLineFragmentRect:))]
        #[unsafe(method_family = none)]
        fn layoutManager_paragraphSpacingBeforeGlyphAtIndex_withProposedLineFragmentRect(
            &self,
            layout_manager: &NSLayoutManager,
            glyph_index: NSUInteger,
            rect: NSRect,
        ) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[optional]
        #[unsafe(method(layoutManager:paragraphSpacingAfterGlyphAtIndex:withProposedLineFragmentRect:))]
        #[unsafe(method_family = none)]
        fn layoutManager_paragraphSpacingAfterGlyphAtIndex_withProposedLineFragmentRect(
            &self,
            layout_manager: &NSLayoutManager,
            glyph_index: NSUInteger,
            rect: NSRect,
        ) -> CGFloat;

        #[optional]
        #[unsafe(method(layoutManager:shouldUseAction:forControlCharacterAtIndex:))]
        #[unsafe(method_family = none)]
        fn layoutManager_shouldUseAction_forControlCharacterAtIndex(
            &self,
            layout_manager: &NSLayoutManager,
            action: NSControlCharacterAction,
            char_index: NSUInteger,
        ) -> NSControlCharacterAction;

        #[optional]
        #[unsafe(method(layoutManager:shouldBreakLineByWordBeforeCharacterAtIndex:))]
        #[unsafe(method_family = none)]
        fn layoutManager_shouldBreakLineByWordBeforeCharacterAtIndex(
            &self,
            layout_manager: &NSLayoutManager,
            char_index: NSUInteger,
        ) -> bool;

        #[optional]
        #[unsafe(method(layoutManager:shouldBreakLineByHyphenatingBeforeCharacterAtIndex:))]
        #[unsafe(method_family = none)]
        fn layoutManager_shouldBreakLineByHyphenatingBeforeCharacterAtIndex(
            &self,
            layout_manager: &NSLayoutManager,
            char_index: NSUInteger,
        ) -> bool;

        #[cfg(feature = "NSTextContainer")]
        #[optional]
        #[unsafe(method(layoutManager:boundingBoxForControlGlyphAtIndex:forTextContainer:proposedLineFragment:glyphPosition:characterIndex:))]
        #[unsafe(method_family = none)]
        fn layoutManager_boundingBoxForControlGlyphAtIndex_forTextContainer_proposedLineFragment_glyphPosition_characterIndex(
            &self,
            layout_manager: &NSLayoutManager,
            glyph_index: NSUInteger,
            text_container: &NSTextContainer,
            proposed_rect: NSRect,
            glyph_position: NSPoint,
            char_index: NSUInteger,
        ) -> NSRect;

        #[cfg(all(feature = "NSTextContainer", feature = "objc2-core-foundation"))]
        /// # Safety
        ///
        /// - `line_fragment_rect` must be a valid pointer.
        /// - `line_fragment_used_rect` must be a valid pointer.
        /// - `baseline_offset` must be a valid pointer.
        #[optional]
        #[unsafe(method(layoutManager:shouldSetLineFragmentRect:lineFragmentUsedRect:baselineOffset:inTextContainer:forGlyphRange:))]
        #[unsafe(method_family = none)]
        unsafe fn layoutManager_shouldSetLineFragmentRect_lineFragmentUsedRect_baselineOffset_inTextContainer_forGlyphRange(
            &self,
            layout_manager: &NSLayoutManager,
            line_fragment_rect: NonNull<NSRect>,
            line_fragment_used_rect: NonNull<NSRect>,
            baseline_offset: NonNull<CGFloat>,
            text_container: &NSTextContainer,
            glyph_range: NSRange,
        ) -> bool;

        /// ********************** Layout processing ***********************
        #[optional]
        #[unsafe(method(layoutManagerDidInvalidateLayout:))]
        #[unsafe(method_family = none)]
        fn layoutManagerDidInvalidateLayout(&self, sender: &NSLayoutManager);

        #[cfg(feature = "NSTextContainer")]
        #[optional]
        #[unsafe(method(layoutManager:didCompleteLayoutForTextContainer:atEnd:))]
        #[unsafe(method_family = none)]
        fn layoutManager_didCompleteLayoutForTextContainer_atEnd(
            &self,
            layout_manager: &NSLayoutManager,
            text_container: Option<&NSTextContainer>,
            layout_finished_flag: bool,
        );

        #[cfg(feature = "NSTextContainer")]
        #[optional]
        #[unsafe(method(layoutManager:textContainer:didChangeGeometryFromSize:))]
        #[unsafe(method_family = none)]
        fn layoutManager_textContainer_didChangeGeometryFromSize(
            &self,
            layout_manager: &NSLayoutManager,
            text_container: &NSTextContainer,
            old_size: NSSize,
        );

        /// # Safety
        ///
        /// - `attrs` generic should be of the correct type.
        /// - `effective_char_range` must be a valid pointer or null.
        #[optional]
        #[unsafe(method(layoutManager:shouldUseTemporaryAttributes:forDrawingToScreen:atCharacterIndex:effectiveRange:))]
        #[unsafe(method_family = none)]
        unsafe fn layoutManager_shouldUseTemporaryAttributes_forDrawingToScreen_atCharacterIndex_effectiveRange(
            &self,
            layout_manager: &NSLayoutManager,
            attrs: &NSDictionary<NSAttributedStringKey, AnyObject>,
            to_screen: bool,
            char_index: NSUInteger,
            effective_char_range: NSRangePointer,
        ) -> Option<Retained<NSDictionary<NSAttributedStringKey, AnyObject>>>;
    }
);

/// The glyph is soft.
#[deprecated]
pub const NSGlyphAttributeSoft: c_uint = 0;
/// The glyph is elastic.
#[deprecated]
pub const NSGlyphAttributeElastic: c_uint = 1;
/// The bidirectional level of the glyph.
#[deprecated]
pub const NSGlyphAttributeBidiLevel: c_uint = 2;
/// The glyph inscription attribute.
///
/// ## Discussion
///
/// See [`NSGlyphInscription`](https://developer.apple.com/documentation/appkit/nsglyphinscription) for possible values.
///
///
#[deprecated]
pub const NSGlyphAttributeInscribe: c_uint = 5;

/// Constants that specify how a glyph is laid out relative to the previous glyph.
///
/// ## Overview
///
/// The glyph inscription constants are possible values for the glyph attribute [`NSGlyphAttributeInscribe`](https://developer.apple.com/documentation/appkit/nsglyphattributeinscribe); glyph inscriptions are set during glyph generation. The only constants that the text system currently uses are `NSGlyphInscribeBase` (for most glyphs) and `NSGlyphInscribeOverstrike` (for nonbase glyphs). Nonbase glyphs occur when diacritical marks are applied to a base character, and the font does not have a single glyph to represent the combination.
///
/// For example, if a font did not contain a single glyph for ü, but did contain separate glyphs for u and ¨, then it could be rendered with a base glyph u followed by a nonbase glyph ¨. In that case the nonbase glyph would have the value `NSGlyphInscribeOverstrike` for the inscribe attribute.
///
///
// NS_ENUM
#[deprecated = "Use NSGlyphProperty instead"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSGlyphInscription(pub NSUInteger);
impl NSGlyphInscription {
    /// A base glyph; a character that the font can represent with a single glyph.
    #[doc(alias = "NSGlyphInscribeBase")]
    #[deprecated]
    pub const InscribeBase: Self = Self(0);
    /// A glyph is rendered below the previous glyph.
    #[doc(alias = "NSGlyphInscribeBelow")]
    #[deprecated]
    pub const InscribeBelow: Self = Self(1);
    /// A glyph is rendered above the previous glyph.
    #[doc(alias = "NSGlyphInscribeAbove")]
    #[deprecated]
    pub const InscribeAbove: Self = Self(2);
    /// A glyph is rendered on top of the previous glyph.
    #[doc(alias = "NSGlyphInscribeOverstrike")]
    #[deprecated]
    pub const InscribeOverstrike: Self = Self(3);
    /// A glyph is rendered on top and below the previous glyph.
    #[doc(alias = "NSGlyphInscribeOverBelow")]
    #[deprecated]
    pub const InscribeOverBelow: Self = Self(4);
}

unsafe impl Encode for NSGlyphInscription {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSGlyphInscription {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// NSLayoutManagerDeprecated.
impl NSLayoutManager {
    extern_methods!(
        #[cfg(feature = "NSFont")]
        /// # Safety
        ///
        /// `is_valid_index` must be a valid pointer or null.
        #[unsafe(method(glyphAtIndex:isValidIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn glyphAtIndex_isValidIndex(
            &self,
            glyph_index: NSUInteger,
            is_valid_index: *mut Bool,
        ) -> NSGlyph;

        #[cfg(feature = "NSFont")]
        #[unsafe(method(glyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn glyphAtIndex(&self, glyph_index: NSUInteger) -> NSGlyph;

        #[cfg(feature = "NSTextContainer")]
        /// # Safety
        ///
        /// `rect_count` must be a valid pointer.
        #[unsafe(method(rectArrayForCharacterRange:withinSelectedCharacterRange:inTextContainer:rectCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rectArrayForCharacterRange_withinSelectedCharacterRange_inTextContainer_rectCount(
            &self,
            char_range: NSRange,
            sel_char_range: NSRange,
            container: &NSTextContainer,
            rect_count: NonNull<NSUInteger>,
        ) -> NSRectArray;

        #[cfg(feature = "NSTextContainer")]
        /// # Safety
        ///
        /// `rect_count` must be a valid pointer.
        #[unsafe(method(rectArrayForGlyphRange:withinSelectedGlyphRange:inTextContainer:rectCount:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rectArrayForGlyphRange_withinSelectedGlyphRange_inTextContainer_rectCount(
            &self,
            glyph_range: NSRange,
            sel_glyph_range: NSRange,
            container: &NSTextContainer,
            rect_count: NonNull<NSUInteger>,
        ) -> NSRectArray;

        #[deprecated]
        #[unsafe(method(usesScreenFonts))]
        #[unsafe(method_family = none)]
        pub fn usesScreenFonts(&self) -> bool;

        /// Setter for [`usesScreenFonts`][Self::usesScreenFonts].
        #[deprecated]
        #[unsafe(method(setUsesScreenFonts:))]
        #[unsafe(method_family = none)]
        pub fn setUsesScreenFonts(&self, uses_screen_fonts: bool);

        #[cfg(feature = "NSFont")]
        #[deprecated]
        #[unsafe(method(substituteFontForFont:))]
        #[unsafe(method_family = none)]
        pub fn substituteFontForFont(&self, original_font: &NSFont) -> Retained<NSFont>;

        #[cfg(feature = "NSFont")]
        /// # Safety
        ///
        /// `glyphs` must be a valid pointer.
        #[deprecated = "Use -setGlyphs:properties:characterIndexes:font:forGlyphRange instead"]
        #[unsafe(method(insertGlyphs:length:forStartingGlyphAtIndex:characterIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertGlyphs_length_forStartingGlyphAtIndex_characterIndex(
            &self,
            glyphs: NonNull<NSGlyph>,
            length: NSUInteger,
            glyph_index: NSUInteger,
            char_index: NSUInteger,
        );

        #[cfg(feature = "NSFont")]
        #[deprecated = "Use -setGlyphs:properties:characterIndexes:font:forGlyphRange instead"]
        #[unsafe(method(insertGlyph:atGlyphIndex:characterIndex:))]
        #[unsafe(method_family = none)]
        pub fn insertGlyph_atGlyphIndex_characterIndex(
            &self,
            glyph: NSGlyph,
            glyph_index: NSUInteger,
            char_index: NSUInteger,
        );

        #[cfg(feature = "NSFont")]
        #[deprecated = "Use -setGlyphs:properties:characterIndexes:font:forGlyphRange instead"]
        #[unsafe(method(replaceGlyphAtIndex:withGlyph:))]
        #[unsafe(method_family = none)]
        pub fn replaceGlyphAtIndex_withGlyph(&self, glyph_index: NSUInteger, new_glyph: NSGlyph);

        #[deprecated = "Use -setGlyphs:properties:characterIndexes:font:forGlyphRange instead"]
        #[unsafe(method(deleteGlyphsInRange:))]
        #[unsafe(method_family = none)]
        pub fn deleteGlyphsInRange(&self, glyph_range: NSRange);

        #[deprecated = "Use -setGlyphs:properties:characterIndexes:font:forGlyphRange instead"]
        #[unsafe(method(setCharacterIndex:forGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setCharacterIndex_forGlyphAtIndex(
            &self,
            char_index: NSUInteger,
            glyph_index: NSUInteger,
        );

        #[deprecated = "Use -setGlyphs:properties:characterIndexes:font:forGlyphRange instead"]
        #[unsafe(method(setIntAttribute:value:forGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn setIntAttribute_value_forGlyphAtIndex(
            &self,
            attribute_tag: NSInteger,
            val: NSInteger,
            glyph_index: NSUInteger,
        );

        #[deprecated = "Use -setGlyphs:properties:characterIndexes:font:forGlyphRange instead"]
        #[unsafe(method(invalidateGlyphsOnLayoutInvalidationForGlyphRange:))]
        #[unsafe(method_family = none)]
        pub fn invalidateGlyphsOnLayoutInvalidationForGlyphRange(&self, glyph_range: NSRange);

        #[deprecated = "Use -getGlyphsInRange:glyphs:properties:characterIndexes:bidiLevels: instead"]
        #[unsafe(method(intAttribute:forGlyphAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn intAttribute_forGlyphAtIndex(
            &self,
            attribute_tag: NSInteger,
            glyph_index: NSUInteger,
        ) -> NSInteger;

        #[cfg(feature = "NSFont")]
        /// # Safety
        ///
        /// - `glyph_buffer` must be a valid pointer or null.
        /// - `char_index_buffer` must be a valid pointer or null.
        /// - `inscribe_buffer` must be a valid pointer or null.
        /// - `elastic_buffer` must be a valid pointer or null.
        #[deprecated = "Use -getGlyphsInRange:glyphs:properties:characterIndexes:bidiLevels: instead"]
        #[unsafe(method(getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits(
            &self,
            glyph_range: NSRange,
            glyph_buffer: *mut NSGlyph,
            char_index_buffer: *mut NSUInteger,
            inscribe_buffer: *mut NSGlyphInscription,
            elastic_buffer: *mut Bool,
        ) -> NSUInteger;

        #[cfg(feature = "NSFont")]
        /// # Safety
        ///
        /// - `glyph_buffer` must be a valid pointer or null.
        /// - `char_index_buffer` must be a valid pointer or null.
        /// - `inscribe_buffer` must be a valid pointer or null.
        /// - `elastic_buffer` must be a valid pointer or null.
        /// - `bidi_level_buffer` must be a valid pointer or null.
        #[deprecated = "Use -getGlyphsInRange:glyphs:properties:characterIndexes:bidiLevels: instead"]
        #[unsafe(method(getGlyphsInRange:glyphs:characterIndexes:glyphInscriptions:elasticBits:bidiLevels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getGlyphsInRange_glyphs_characterIndexes_glyphInscriptions_elasticBits_bidiLevels(
            &self,
            glyph_range: NSRange,
            glyph_buffer: *mut NSGlyph,
            char_index_buffer: *mut NSUInteger,
            inscribe_buffer: *mut NSGlyphInscription,
            elastic_buffer: *mut Bool,
            bidi_level_buffer: *mut c_uchar,
        ) -> NSUInteger;

        #[cfg(feature = "NSFont")]
        /// # Safety
        ///
        /// `glyph_array` must be a valid pointer or null.
        #[deprecated = "Use -getGlyphsInRange:glyphs:properties:characterIndexes:bidiLevels: instead"]
        #[unsafe(method(getGlyphs:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getGlyphs_range(
            &self,
            glyph_array: *mut NSGlyph,
            glyph_range: NSRange,
        ) -> NSUInteger;

        /// # Safety
        ///
        /// `actual_char_range` must be a valid pointer or null.
        #[deprecated = "Use -invalidateLayoutForCharacterRange:actualCharacterRange: instead"]
        #[unsafe(method(invalidateLayoutForCharacterRange:isSoft:actualCharacterRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidateLayoutForCharacterRange_isSoft_actualCharacterRange(
            &self,
            char_range: NSRange,
            flag: bool,
            actual_char_range: NSRangePointer,
        );

        #[cfg(feature = "NSTextStorage")]
        #[deprecated = "Use -processEditingForTextStorage:edited:range:changeInLength:invalidatedRange: instead"]
        #[unsafe(method(textStorage:edited:range:changeInLength:invalidatedRange:))]
        #[unsafe(method_family = none)]
        pub fn textStorage_edited_range_changeInLength_invalidatedRange(
            &self,
            str: &NSTextStorage,
            edited_mask: NSTextStorageEditedOptions,
            new_char_range: NSRange,
            delta: NSInteger,
            invalidated_char_range: NSRange,
        );

        /// # Safety
        ///
        /// - `locations` must be a valid pointer.
        /// - `glyph_indexes` must be a valid pointer.
        #[deprecated = "Use -setLocation:forStartOfGlyphRange: instead"]
        #[unsafe(method(setLocations:startingGlyphIndexes:count:forGlyphRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocations_startingGlyphIndexes_count_forGlyphRange(
            &self,
            locations: NSPointArray,
            glyph_indexes: NonNull<NSUInteger>,
            count: NSUInteger,
            glyph_range: NSRange,
        );

        #[cfg(all(feature = "NSColor", feature = "NSFont"))]
        /// # Safety
        ///
        /// `glyphs` must be a valid pointer.
        #[deprecated = "Use -showCGGlyphs:positions:count:font:matrix:attributes:inContext: instead"]
        #[unsafe(method(showPackedGlyphs:length:glyphRange:atPoint:font:color:printingAdjustment:))]
        #[unsafe(method_family = none)]
        pub unsafe fn showPackedGlyphs_length_glyphRange_atPoint_font_color_printingAdjustment(
            &self,
            glyphs: NonNull<c_char>,
            glyph_len: NSUInteger,
            glyph_range: NSRange,
            point: NSPoint,
            font: &NSFont,
            color: &NSColor,
            printing_adjustment: NSSize,
        );

        #[cfg(all(
            feature = "NSFont",
            feature = "NSGraphicsContext",
            feature = "objc2-core-graphics"
        ))]
        #[cfg(target_vendor = "apple")]
        /// # Safety
        ///
        /// - `glyphs` must be a valid pointer.
        /// - `positions` must be a valid pointer.
        /// - `attributes` generic should be of the correct type.
        #[deprecated]
        #[unsafe(method(showCGGlyphs:positions:count:font:matrix:attributes:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn showCGGlyphs_positions_count_font_matrix_attributes_inContext(
            &self,
            glyphs: NonNull<CGGlyph>,
            positions: NonNull<NSPoint>,
            glyph_count: NSUInteger,
            font: &NSFont,
            text_matrix: &NSAffineTransform,
            attributes: &NSDictionary<NSAttributedStringKey, AnyObject>,
            graphics_context: &NSGraphicsContext,
        );

        #[deprecated = "Please use usesDefaultHyphenation or -[NSParagraphStyle hyphenationFactor] instead."]
        #[unsafe(method(hyphenationFactor))]
        #[unsafe(method_family = none)]
        pub fn hyphenationFactor(&self) -> c_float;

        /// Setter for [`hyphenationFactor`][Self::hyphenationFactor].
        #[deprecated = "Please use usesDefaultHyphenation or -[NSParagraphStyle hyphenationFactor] instead."]
        #[unsafe(method(setHyphenationFactor:))]
        #[unsafe(method_family = none)]
        pub fn setHyphenationFactor(&self, hyphenation_factor: c_float);
    );
}

/// NSGlyphGeneration.
impl NSLayoutManager {
    extern_methods!(
        #[cfg(feature = "NSGlyphGenerator")]
        #[unsafe(method(glyphGenerator))]
        #[unsafe(method_family = none)]
        pub fn glyphGenerator(&self) -> Retained<NSGlyphGenerator>;

        #[cfg(feature = "NSGlyphGenerator")]
        /// Setter for [`glyphGenerator`][Self::glyphGenerator].
        #[unsafe(method(setGlyphGenerator:))]
        #[unsafe(method_family = none)]
        pub fn setGlyphGenerator(&self, glyph_generator: &NSGlyphGenerator);
    );
}

#[cfg(feature = "NSGlyphGenerator")]
extern_conformance!(
    unsafe impl NSGlyphStorage for NSLayoutManager {}
);
