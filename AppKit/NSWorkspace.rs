//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-uniform-type-identifiers")]
#[cfg(target_vendor = "apple")]
use objc2_uniform_type_identifiers::*;

use crate::*;

/// Constants that describe options for creating icons.
///
/// ## Overview
///
/// Use these constants with the [`setIcon:forFile:options:`](https://developer.apple.com/documentation/appkit/nsworkspace/seticon(_:forfile:options:)) method. You can combine these using the C bitwise OR operator.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSWorkspaceIconCreationOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSWorkspaceIconCreationOptions: NSUInteger {
/// An option to suppress generation of the QuickDraw format icon representations that are used in macOS 10.0 through macOS 10.4.
        #[doc(alias = "NSExcludeQuickDrawElementsIconCreationOption")]
        const ExcludeQuickDrawElementsIconCreationOption = 1<<1;
/// An option to suppress generation of the new higher resolution icon representations that are supported in macOS 10.4.
        #[doc(alias = "NSExclude10_4ElementsIconCreationOption")]
        const Exclude10_4ElementsIconCreationOption = 1<<2;
    }
}

unsafe impl Encode for NSWorkspaceIconCreationOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSWorkspaceIconCreationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A workspace that can launch other apps and perform a variety of file-handling services.
    ///
    /// ## Overview
    ///
    /// There is one shared [`NSWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace) object per app. You use the class method [`sharedWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace/shared) to access it. For example, the following statement uses an [`NSWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace) object to request that a file be opened in the TextEdit app:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["NSWorkspace.shared.openFile(\"/Myfiles/README\", withApplication: \"TextEdit\")"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[[NSWorkspace sharedWorkspace] openFile:@\"/Myfiles/README\" withApplication:@\"TextEdit\"];"], metadata: None }] }] })
    /// You can use the workspace object to:
    ///
    /// - Open, manipulate, and get information about files and devices.
    ///
    /// - Track changes to the file system, devices, and the user database.
    ///
    /// - Get and set Finder information for files.
    ///
    /// - Launch apps.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSWorkspace;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSWorkspace {}
);

impl NSWorkspace {
    extern_methods!(
        #[unsafe(method(sharedWorkspace))]
        #[unsafe(method_family = none)]
        pub fn sharedWorkspace() -> Retained<NSWorkspace>;

        #[unsafe(method(notificationCenter))]
        #[unsafe(method_family = none)]
        pub fn notificationCenter(&self) -> Retained<NSNotificationCenter>;

        #[unsafe(method(openURL:))]
        #[unsafe(method_family = none)]
        pub fn openURL(&self, url: &NSURL) -> bool;

        #[cfg(all(feature = "NSRunningApplication", feature = "block2"))]
        #[unsafe(method(openURL:configuration:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn openURL_configuration_completionHandler(
            &self,
            url: &NSURL,
            configuration: &NSWorkspaceOpenConfiguration,
            completion_handler: Option<
                &block2::DynBlock<dyn Fn(*mut NSRunningApplication, *mut NSError)>,
            >,
        );

        #[cfg(all(feature = "NSRunningApplication", feature = "block2"))]
        #[unsafe(method(openURLs:withApplicationAtURL:configuration:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn openURLs_withApplicationAtURL_configuration_completionHandler(
            &self,
            urls: &NSArray<NSURL>,
            application_url: &NSURL,
            configuration: &NSWorkspaceOpenConfiguration,
            completion_handler: Option<
                &block2::DynBlock<dyn Fn(*mut NSRunningApplication, *mut NSError)>,
            >,
        );

        #[cfg(all(feature = "NSRunningApplication", feature = "block2"))]
        #[unsafe(method(openApplicationAtURL:configuration:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn openApplicationAtURL_configuration_completionHandler(
            &self,
            application_url: &NSURL,
            configuration: &NSWorkspaceOpenConfiguration,
            completion_handler: Option<
                &block2::DynBlock<dyn Fn(*mut NSRunningApplication, *mut NSError)>,
            >,
        );

        #[unsafe(method(selectFile:inFileViewerRootedAtPath:))]
        #[unsafe(method_family = none)]
        pub fn selectFile_inFileViewerRootedAtPath(
            &self,
            full_path: Option<&NSString>,
            root_full_path: &NSString,
        ) -> bool;

        #[unsafe(method(activateFileViewerSelectingURLs:))]
        #[unsafe(method_family = none)]
        pub fn activateFileViewerSelectingURLs(&self, file_ur_ls: &NSArray<NSURL>);

        #[unsafe(method(showSearchResultsForQueryString:))]
        #[unsafe(method_family = none)]
        pub fn showSearchResultsForQueryString(&self, query_string: &NSString) -> bool;

        #[unsafe(method(noteFileSystemChanged:))]
        #[unsafe(method_family = none)]
        pub fn noteFileSystemChanged_(&self, path: &NSString);

        #[unsafe(method(isFilePackageAtPath:))]
        #[unsafe(method_family = none)]
        pub fn isFilePackageAtPath(&self, full_path: &NSString) -> bool;

        #[cfg(feature = "NSImage")]
        #[unsafe(method(iconForFile:))]
        #[unsafe(method_family = none)]
        pub fn iconForFile(&self, full_path: &NSString) -> Retained<NSImage>;

        #[cfg(feature = "NSImage")]
        #[unsafe(method(iconForFiles:))]
        #[unsafe(method_family = none)]
        pub fn iconForFiles(&self, full_paths: &NSArray<NSString>) -> Option<Retained<NSImage>>;

        #[cfg(all(feature = "NSImage", feature = "objc2-uniform-type-identifiers"))]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(iconForContentType:))]
        #[unsafe(method_family = none)]
        pub fn iconForContentType(&self, content_type: &UTType) -> Retained<NSImage>;

        #[cfg(feature = "NSImage")]
        #[unsafe(method(setIcon:forFile:options:))]
        #[unsafe(method_family = none)]
        pub fn setIcon_forFile_options(
            &self,
            image: Option<&NSImage>,
            full_path: &NSString,
            options: NSWorkspaceIconCreationOptions,
        ) -> bool;

        #[unsafe(method(fileLabels))]
        #[unsafe(method_family = none)]
        pub fn fileLabels(&self) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "NSColor")]
        #[unsafe(method(fileLabelColors))]
        #[unsafe(method_family = none)]
        pub fn fileLabelColors(&self) -> Retained<NSArray<NSColor>>;

        #[cfg(feature = "block2")]
        #[unsafe(method(recycleURLs:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn recycleURLs_completionHandler(
            &self,
            ur_ls: &NSArray<NSURL>,
            handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<NSDictionary<NSURL, NSURL>>, *mut NSError)>,
            >,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(duplicateURLs:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn duplicateURLs_completionHandler(
            &self,
            ur_ls: &NSArray<NSURL>,
            handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<NSDictionary<NSURL, NSURL>>, *mut NSError)>,
            >,
        );

        /// # Safety
        ///
        /// - `removable_flag` must be a valid pointer or null.
        /// - `writable_flag` must be a valid pointer or null.
        /// - `unmountable_flag` must be a valid pointer or null.
        #[unsafe(method(getFileSystemInfoForPath:isRemovable:isWritable:isUnmountable:description:type:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getFileSystemInfoForPath_isRemovable_isWritable_isUnmountable_description_type(
            &self,
            full_path: &NSString,
            removable_flag: *mut Bool,
            writable_flag: *mut Bool,
            unmountable_flag: *mut Bool,
            description: Option<&mut Option<Retained<NSString>>>,
            file_system_type: Option<&mut Option<Retained<NSString>>>,
        ) -> bool;

        #[unsafe(method(unmountAndEjectDeviceAtPath:))]
        #[unsafe(method_family = none)]
        pub fn unmountAndEjectDeviceAtPath(&self, path: &NSString) -> bool;

        #[unsafe(method(unmountAndEjectDeviceAtURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn unmountAndEjectDeviceAtURL_error(
            &self,
            url: &NSURL,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(extendPowerOffBy:))]
        #[unsafe(method_family = none)]
        pub fn extendPowerOffBy(&self, requested: NSInteger) -> NSInteger;

        #[unsafe(method(hideOtherApplications))]
        #[unsafe(method_family = none)]
        pub fn hideOtherApplications(&self);

        #[unsafe(method(URLForApplicationWithBundleIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn URLForApplicationWithBundleIdentifier(
            &self,
            bundle_identifier: &NSString,
        ) -> Option<Retained<NSURL>>;

        #[unsafe(method(URLsForApplicationsWithBundleIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn URLsForApplicationsWithBundleIdentifier(
            &self,
            bundle_identifier: &NSString,
        ) -> Retained<NSArray<NSURL>>;

        #[unsafe(method(URLForApplicationToOpenURL:))]
        #[unsafe(method_family = none)]
        pub fn URLForApplicationToOpenURL(&self, url: &NSURL) -> Option<Retained<NSURL>>;

        #[unsafe(method(URLsForApplicationsToOpenURL:))]
        #[unsafe(method_family = none)]
        pub fn URLsForApplicationsToOpenURL(&self, url: &NSURL) -> Retained<NSArray<NSURL>>;

        #[cfg(feature = "block2")]
        #[unsafe(method(setDefaultApplicationAtURL:toOpenContentTypeOfFileAtURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn setDefaultApplicationAtURL_toOpenContentTypeOfFileAtURL_completionHandler(
            &self,
            application_url: &NSURL,
            url: &NSURL,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(setDefaultApplicationAtURL:toOpenURLsWithScheme:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn setDefaultApplicationAtURL_toOpenURLsWithScheme_completionHandler(
            &self,
            application_url: &NSURL,
            url_scheme: &NSString,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(setDefaultApplicationAtURL:toOpenFileAtURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn setDefaultApplicationAtURL_toOpenFileAtURL_completionHandler(
            &self,
            application_url: &NSURL,
            url: &NSURL,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(URLForApplicationToOpenContentType:))]
        #[unsafe(method_family = none)]
        pub fn URLForApplicationToOpenContentType(
            &self,
            content_type: &UTType,
        ) -> Option<Retained<NSURL>>;

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(URLsForApplicationsToOpenContentType:))]
        #[unsafe(method_family = none)]
        pub fn URLsForApplicationsToOpenContentType(
            &self,
            content_type: &UTType,
        ) -> Retained<NSArray<NSURL>>;

        #[cfg(all(feature = "block2", feature = "objc2-uniform-type-identifiers"))]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(setDefaultApplicationAtURL:toOpenContentType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn setDefaultApplicationAtURL_toOpenContentType_completionHandler(
            &self,
            application_url: &NSURL,
            content_type: &UTType,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "NSRunningApplication")]
        #[unsafe(method(frontmostApplication))]
        #[unsafe(method_family = none)]
        pub fn frontmostApplication(&self) -> Option<Retained<NSRunningApplication>>;

        #[cfg(feature = "NSRunningApplication")]
        #[unsafe(method(menuBarOwningApplication))]
        #[unsafe(method_family = none)]
        pub fn menuBarOwningApplication(&self) -> Option<Retained<NSRunningApplication>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSWorkspace {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSWorkspace {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

extern_class!(
    /// The configuration options for opening URLs or launching apps.
    ///
    /// ## Overview
    ///
    /// Create an [`NSWorkspaceOpenConfiguration`](https://developer.apple.com/documentation/appkit/nsworkspace/openconfiguration) object before launching an app or opening a URL using the shared [`NSWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace) object. Use the properties of this object to customize the behavior of the launched app or the handling of the URLs. For example, you might tell the app to hide itself immediately after launch.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSWorkspaceOpenConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for NSWorkspaceOpenConfiguration {}
);

unsafe impl CopyingHelper for NSWorkspaceOpenConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSWorkspaceOpenConfiguration {}
);

impl NSWorkspaceOpenConfiguration {
    extern_methods!(
        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub fn configuration() -> Retained<Self>;

        #[unsafe(method(promptsUserIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn promptsUserIfNeeded(&self) -> bool;

        /// Setter for [`promptsUserIfNeeded`][Self::promptsUserIfNeeded].
        #[unsafe(method(setPromptsUserIfNeeded:))]
        #[unsafe(method_family = none)]
        pub fn setPromptsUserIfNeeded(&self, prompts_user_if_needed: bool);

        #[unsafe(method(addsToRecentItems))]
        #[unsafe(method_family = none)]
        pub fn addsToRecentItems(&self) -> bool;

        /// Setter for [`addsToRecentItems`][Self::addsToRecentItems].
        #[unsafe(method(setAddsToRecentItems:))]
        #[unsafe(method_family = none)]
        pub fn setAddsToRecentItems(&self, adds_to_recent_items: bool);

        #[unsafe(method(activates))]
        #[unsafe(method_family = none)]
        pub fn activates(&self) -> bool;

        /// Setter for [`activates`][Self::activates].
        #[unsafe(method(setActivates:))]
        #[unsafe(method_family = none)]
        pub fn setActivates(&self, activates: bool);

        #[unsafe(method(hides))]
        #[unsafe(method_family = none)]
        pub fn hides(&self) -> bool;

        /// Setter for [`hides`][Self::hides].
        #[unsafe(method(setHides:))]
        #[unsafe(method_family = none)]
        pub fn setHides(&self, hides: bool);

        #[unsafe(method(hidesOthers))]
        #[unsafe(method_family = none)]
        pub fn hidesOthers(&self) -> bool;

        /// Setter for [`hidesOthers`][Self::hidesOthers].
        #[unsafe(method(setHidesOthers:))]
        #[unsafe(method_family = none)]
        pub fn setHidesOthers(&self, hides_others: bool);

        #[unsafe(method(isForPrinting))]
        #[unsafe(method_family = none)]
        pub fn isForPrinting(&self) -> bool;

        /// Setter for [`isForPrinting`][Self::isForPrinting].
        #[unsafe(method(setForPrinting:))]
        #[unsafe(method_family = none)]
        pub fn setForPrinting(&self, for_printing: bool);

        #[unsafe(method(createsNewApplicationInstance))]
        #[unsafe(method_family = none)]
        pub fn createsNewApplicationInstance(&self) -> bool;

        /// Setter for [`createsNewApplicationInstance`][Self::createsNewApplicationInstance].
        #[unsafe(method(setCreatesNewApplicationInstance:))]
        #[unsafe(method_family = none)]
        pub fn setCreatesNewApplicationInstance(&self, creates_new_application_instance: bool);

        #[unsafe(method(allowsRunningApplicationSubstitution))]
        #[unsafe(method_family = none)]
        pub fn allowsRunningApplicationSubstitution(&self) -> bool;

        /// Setter for [`allowsRunningApplicationSubstitution`][Self::allowsRunningApplicationSubstitution].
        #[unsafe(method(setAllowsRunningApplicationSubstitution:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsRunningApplicationSubstitution(
            &self,
            allows_running_application_substitution: bool,
        );

        #[unsafe(method(arguments))]
        #[unsafe(method_family = none)]
        pub fn arguments(&self) -> Retained<NSArray<NSString>>;

        /// Setter for [`arguments`][Self::arguments].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setArguments:))]
        #[unsafe(method_family = none)]
        pub fn setArguments(&self, arguments: &NSArray<NSString>);

        #[unsafe(method(environment))]
        #[unsafe(method_family = none)]
        pub fn environment(&self) -> Retained<NSDictionary<NSString, NSString>>;

        /// Setter for [`environment`][Self::environment].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setEnvironment:))]
        #[unsafe(method_family = none)]
        pub fn setEnvironment(&self, environment: &NSDictionary<NSString, NSString>);

        #[unsafe(method(appleEvent))]
        #[unsafe(method_family = none)]
        pub fn appleEvent(&self) -> Option<Retained<NSAppleEventDescriptor>>;

        /// Setter for [`appleEvent`][Self::appleEvent].
        #[unsafe(method(setAppleEvent:))]
        #[unsafe(method_family = none)]
        pub fn setAppleEvent(&self, apple_event: Option<&NSAppleEventDescriptor>);

        #[unsafe(method(requiresUniversalLinks))]
        #[unsafe(method_family = none)]
        pub fn requiresUniversalLinks(&self) -> bool;

        /// Setter for [`requiresUniversalLinks`][Self::requiresUniversalLinks].
        #[unsafe(method(setRequiresUniversalLinks:))]
        #[unsafe(method_family = none)]
        pub fn setRequiresUniversalLinks(&self, requires_universal_links: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSWorkspaceOpenConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSWorkspaceOpenConfiguration {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// Keys that indicate how to display a new desktop image.
///
/// ## Discussion
///
/// Specify the following keys when calling the [`setDesktopImageURL:forScreen:options:error:`](https://developer.apple.com/documentation/appkit/nsworkspace/setdesktopimageurl(_:for:options:)) method.
///
///
// NS_TYPED_ENUM
pub type NSWorkspaceDesktopImageOptionKey = NSString;

extern "C" {
    /// A key that contains the behavior to use when scaling the image.
    ///
    /// ## Discussion
    ///
    /// The value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) object that contains an [`NSImageScaling`](https://developer.apple.com/documentation/appkit/nsimagescaling) constant as declared in [`NSCell`](https://developer.apple.com/documentation/appkit/nscell). If you don’t include this key, the workspace object uses [`NSImageScaleProportionallyUpOrDown`](https://developer.apple.com/documentation/appkit/nsimagescaling/scaleproportionallyupordown). [`NSImageScaleProportionallyDown`](https://developer.apple.com/documentation/appkit/nsimagescaling/scaleproportionallydown) isn’t supported.
    ///
    ///
    pub static NSWorkspaceDesktopImageScalingKey: &'static NSWorkspaceDesktopImageOptionKey;
}

extern "C" {
    /// A key that contains the behavior to use when clipping the image.
    ///
    /// ## Discussion
    ///
    /// The value is an [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) containing a Boolean, which affects the interpretation of Proportional scaling types. When the value is [`false`](https://developer.apple.com/documentation/swift/false), the workspace object makes the image fully visible, but it may include empty space on the sides or top and bottom. When the value is [`true`](https://developer.apple.com/documentation/swift/true), the image fills the entire screen, but may be clipped. If you don’t specify this key, the workspace assumes a value of [`false`](https://developer.apple.com/documentation/swift/false).  Non-proportional scaling types ignore this value.
    ///
    ///
    pub static NSWorkspaceDesktopImageAllowClippingKey: &'static NSWorkspaceDesktopImageOptionKey;
}

extern "C" {
    /// A key that contains the behavior to use when filling the empty space around the image.
    ///
    /// ## Discussion
    ///
    /// The value is the [`NSColor`](https://developer.apple.com/documentation/appkit/nscolor) object to use when filling any empty space around the image. If you don’t specify this key, the workspace object uses a default color. Currently, the system supports only colors that use or can be converted to use the [`NSCalibratedRGBColorSpace`](https://developer.apple.com/documentation/appkit/nscolorspacename/calibratedrgb) color space. The system also ignores any alpha value in the color you specify.
    ///
    ///
    pub static NSWorkspaceDesktopImageFillColorKey: &'static NSWorkspaceDesktopImageOptionKey;
}

/// NSDesktopImages.
impl NSWorkspace {
    extern_methods!(
        #[cfg(feature = "NSScreen")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(setDesktopImageURL:forScreen:options:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDesktopImageURL_forScreen_options_error(
            &self,
            url: &NSURL,
            screen: &NSScreen,
            options: &NSDictionary<NSWorkspaceDesktopImageOptionKey, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(feature = "NSScreen")]
        #[unsafe(method(desktopImageURLForScreen:))]
        #[unsafe(method_family = none)]
        pub fn desktopImageURLForScreen(&self, screen: &NSScreen) -> Option<Retained<NSURL>>;

        #[cfg(feature = "NSScreen")]
        #[unsafe(method(desktopImageOptionsForScreen:))]
        #[unsafe(method_family = none)]
        pub fn desktopImageOptionsForScreen(
            &self,
            screen: &NSScreen,
        ) -> Option<Retained<NSDictionary<NSWorkspaceDesktopImageOptionKey, AnyObject>>>;
    );
}

/// The types of privileged file operations that can be authorized by the user.
///
/// ## Overview
///
/// To enable your app to prompt the user for these file permissions, you must have a Privileged File Operation entitlement. If you have an app on the Mac App Store or plan to submit your app for review, you can [request this entitlement](https://developer.apple.com/go/?id=workspace-authorization).
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSWorkspaceAuthorizationType(pub NSInteger);
impl NSWorkspaceAuthorizationType {
    /// Authorization for the app to create a symbolic link.
    ///
    /// ## Discussion
    ///
    /// Signifies that the user has granted authorization for [`createSymbolicLinkAtURL:withDestinationURL:error:`](https://developer.apple.com/documentation/foundation/filemanager/createsymboliclink(at:withdestinationurl:)).
    ///
    ///
    #[doc(alias = "NSWorkspaceAuthorizationTypeCreateSymbolicLink")]
    pub const CreateSymbolicLink: Self = Self(0);
    /// Authorization for the app to change specific file attributes.
    ///
    /// ## Discussion
    ///
    /// Signifies that the user has granted authorization for [`setAttributes:ofItemAtPath:error:`](https://developer.apple.com/documentation/foundation/filemanager/setattributes(_:ofitematpath:)).
    ///
    /// Only these attributes can be modified:
    ///
    /// - [`NSFileOwnerAccountID`](https://developer.apple.com/documentation/foundation/fileattributekey/owneraccountid)
    ///
    /// - [`NSFileGroupOwnerAccountID`](https://developer.apple.com/documentation/foundation/fileattributekey/groupowneraccountid)
    ///
    /// - [`NSFilePosixPermissions`](https://developer.apple.com/documentation/foundation/fileattributekey/posixpermissions)
    ///
    ///
    #[doc(alias = "NSWorkspaceAuthorizationTypeSetAttributes")]
    pub const SetAttributes: Self = Self(1);
    /// Authorization for the app to perform an atomic file write without changing the target file’s permissions.
    ///
    /// ## Discussion
    ///
    /// Signifies that the user has granted authorization for [`replaceItemAtURL:withItemAtURL:backupItemName:options:resultingItemURL:error:`](https://developer.apple.com/documentation/foundation/filemanager/replaceitem(at:withitemat:backupitemname:options:resultingitemurl:)). When you use a [`NSFileManager`](https://developer.apple.com/documentation/foundation/filemanager) with this authorization, the file manager ignores the `backupItemName` and `options` parameters.
    ///
    ///
    #[doc(alias = "NSWorkspaceAuthorizationTypeReplaceFile")]
    pub const ReplaceFile: Self = Self(2);
}

unsafe impl Encode for NSWorkspaceAuthorizationType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSWorkspaceAuthorizationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The authorization granted to the app by the user.
    ///
    /// ## Overview
    ///
    /// To enable your app to prompt the user for these file permissions, you must have a Privileged File Operation entitlement. If you have an app on the Mac App Store or plan to submit your app for review, you can [request this entitlement](https://developer.apple.com/go/?id=workspace-authorization).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSWorkspaceAuthorization;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSWorkspaceAuthorization {}
);

impl NSWorkspaceAuthorization {
    extern_methods!();
}

/// Methods declared on superclass `NSObject`.
impl NSWorkspaceAuthorization {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSWorkspaceAuthorization {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSWorkspaceAuthorization.
impl NSWorkspace {
    extern_methods!(
        #[cfg(feature = "block2")]
        #[unsafe(method(requestAuthorizationOfType:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn requestAuthorizationOfType_completionHandler(
            &self,
            r#type: NSWorkspaceAuthorizationType,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSWorkspaceAuthorization, *mut NSError),
            >,
        );
    );
}

mod private_NSFileManagerNSWorkspaceAuthorization {
    pub trait Sealed {}
}

/// Category "NSWorkspaceAuthorization" on [`NSFileManager`].
#[doc(alias = "NSWorkspaceAuthorization")]
pub unsafe trait NSFileManagerNSWorkspaceAuthorization:
    ClassType + Sized + private_NSFileManagerNSWorkspaceAuthorization::Sealed
{
    extern_methods!(
        #[unsafe(method(fileManagerWithAuthorization:))]
        #[unsafe(method_family = none)]
        fn fileManagerWithAuthorization(authorization: &NSWorkspaceAuthorization)
            -> Retained<Self>;
    );
}

impl private_NSFileManagerNSWorkspaceAuthorization::Sealed for NSFileManager {}
unsafe impl NSFileManagerNSWorkspaceAuthorization for NSFileManager {}

extern "C" {
    /// The value corresponding to this key is an instance of [`NSRunningApplication`](https://developer.apple.com/documentation/appkit/nsrunningapplication) that reflects the affected app.
    pub static NSWorkspaceApplicationKey: &'static NSString;
}

extern "C" {
    /// A notification that the workspace posts when the Finder is about to launch an app.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The `userInfo` dictionary contains the [`NSWorkspaceApplicationKey`](https://developer.apple.com/documentation/appkit/nsworkspace/applicationuserinfokey) key with a corresponding instance of [`NSRunningApplication`](https://developer.apple.com/documentation/appkit/nsrunningapplication) that represents the affected app.
    ///
    /// The system doesn’t post this notification for background apps or for apps that have the `LSUIElement` key in their `Info.plist` file. If you want to know when all apps (including background apps) launch or terminate, use key-value observing to monitor the value that returns from the [`runningApplications`](https://developer.apple.com/documentation/appkit/nsworkspace/runningapplications) method.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceWillLaunchApplicationNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when a new app starts up.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The `userInfo` dictionary contains the [`NSWorkspaceApplicationKey`](https://developer.apple.com/documentation/appkit/nsworkspace/applicationuserinfokey) key with a corresponding instance of [`NSRunningApplication`](https://developer.apple.com/documentation/appkit/nsrunningapplication) that represents the affected app.
    ///
    /// The system doesn’t post this notification for background apps or for apps that have the [`LSUIElement`](https://developer.apple.com/documentation/bundleresources/information-property-list/lsuielement) key in their `Info.plist` file. If you want to know when all apps (including background apps) launch or terminate, use key-value observing to monitor the value that returns from the [`runningApplications`](https://developer.apple.com/documentation/appkit/nsworkspace/runningapplications) method.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidLaunchApplicationNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when an app finishes executing.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The `userInfo` dictionary contains the [`NSWorkspaceApplicationKey`](https://developer.apple.com/documentation/appkit/nsworkspace/applicationuserinfokey) key with a corresponding instance of [`NSRunningApplication`](https://developer.apple.com/documentation/appkit/nsrunningapplication) that represents the affected app.
    ///
    /// The system doesn’t post this notification for background apps or for apps that have the `LSUIElement` key in their `Info.plist` file. If you want to know when all apps (including background apps) launch or terminate, use key-value observing to monitor the value that returns from the [`runningApplications`](https://developer.apple.com/documentation/appkit/nsworkspace/runningapplications) method.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidTerminateApplicationNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the Finder hides an app.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared [`NSWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace) instance. The `userInfo` dictionary contains the [`NSWorkspaceApplicationKey`](https://developer.apple.com/documentation/appkit/nsworkspace/applicationuserinfokey) key with a corresponding instance of [`NSRunningApplication`](https://developer.apple.com/documentation/appkit/nsrunningapplication) that represents the affected app.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidHideApplicationNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the Finder unhides an app.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared [`NSWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace) instance. The `userInfo` dictionary contains the [`NSWorkspaceApplicationKey`](https://developer.apple.com/documentation/appkit/nsworkspace/applicationuserinfokey) key with a corresponding instance of [`NSRunningApplication`](https://developer.apple.com/documentation/appkit/nsrunningapplication) that represents the affected app.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidUnhideApplicationNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the Finder is about to activate an app.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The `userInfo` dictionary contains the [`NSWorkspaceApplicationKey`](https://developer.apple.com/documentation/appkit/nsworkspace/applicationuserinfokey) key with a corresponding instance of [`NSRunningApplication`](https://developer.apple.com/documentation/appkit/nsrunningapplication) that represents the affected app.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidActivateApplicationNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the Finder deactivates an app.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The `userInfo` dictionary contains the [`NSWorkspaceApplicationKey`](https://developer.apple.com/documentation/appkit/nsworkspace/applicationuserinfokey) key with a corresponding instance of [`NSRunningApplication`](https://developer.apple.com/documentation/appkit/nsrunningapplication) that represents the affected app.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidDeactivateApplicationNotification: &'static NSNotificationName;
}

extern "C" {
    /// A string containing the user-visible name of the volume.
    pub static NSWorkspaceVolumeLocalizedNameKey: &'static NSString;
}

extern "C" {
    /// A URL containing the mount path of the volume.
    pub static NSWorkspaceVolumeURLKey: &'static NSString;
}

extern "C" {
    /// A string containing the old user-visible name of the volume
    pub static NSWorkspaceVolumeOldLocalizedNameKey: &'static NSString;
}

extern "C" {
    /// A URL containing the old mount path of the volume
    pub static NSWorkspaceVolumeOldURLKey: &'static NSString;
}

extern "C" {
    /// A notification that the workspace posts when a new device mounts.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared [`NSWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace) instance.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidMountNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the Finder unmounts a device.
    ///
    /// ## Discussion
    ///
    /// This notification posts even if a volume becomes forcibly and immediately unavailable, such as when simply unplugging a drive.
    ///
    /// The notification object is the shared `NSWorkspace` instance. The `userInfo` dictionary contains a key `@"NSDevicePath"` that returns the path where the device mounts as a string.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidUnmountNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the Finder is about to unmount a device.
    ///
    /// ## Discussion
    ///
    /// This notification doesn’t post if a volume becomes forcibly and immediately unavailable, such as when simply unplugging a drive.
    ///
    /// The notification object is the shared `NSWorkspace` instance. The `userInfo` dictionary contains a key `@"NSDevicePath"` that returns the path where the device mounts as a string.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceWillUnmountNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when a volume changes its name or mount path.
    ///
    /// ## Discussion
    ///
    /// These notifications typically change simultaneously, in which case, the workspace posts only one notification.
    ///
    /// The notification object is the shared [`NSWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace) instance. The `userInfo` dictionary may contain the following keys:
    ///
    /// - [`NSWorkspaceVolumeLocalizedNameKey`](https://developer.apple.com/documentation/appkit/nsworkspace/localizedvolumenameuserinfokey)
    ///
    /// - [`NSWorkspaceVolumeURLKey`](https://developer.apple.com/documentation/appkit/nsworkspace/volumeurluserinfokey)
    ///
    /// - [`NSWorkspaceVolumeOldLocalizedNameKey`](https://developer.apple.com/documentation/appkit/nsworkspace/oldlocalizedvolumenameuserinfokey)
    ///
    /// - [`NSWorkspaceVolumeOldURLKey`](https://developer.apple.com/documentation/appkit/nsworkspace/oldvolumeurluserinfokey)
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidRenameVolumeNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the user requests a logout or powers off the device.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. This notification doesn’t contain a `userInfo` dictionary.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceWillPowerOffNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts before the device goes to sleep.
    ///
    /// ## Discussion
    ///
    /// An observer of this message can delay sleep for up to 30 seconds while handling this notification.
    ///
    /// The notification object is the shared `NSWorkspace` instance. The notification doesn’t contain a `userInfo` dictionary.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceWillSleepNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the device wakes from sleep.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The notification doesn’t contain a `userInfo` dictionary.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidWakeNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the device’s screen goes to sleep.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The notification doesn’t contain a `userInfo` dictionary.
    ///
    /// Not many apps use this notification, but it can be useful for certain hardware-based drawing decisions, for example when using OpenGL.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceScreensDidSleepNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the device’s screens wake.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The notification doesn’t contain a `userInfo` dictionary.
    ///
    /// Not many apps use this notification, but it can be useful for certain hardware-based drawing decisions, for example when using OpenGL.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceScreensDidWakeNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts after a user session switches in.
    ///
    /// ## Discussion
    ///
    /// This notification allows an app to re-enable some processing, such as when a switched-out session switches back in.
    ///
    /// The notification object is the shared [`NSWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace) instance. The notification doesn’t contain a `userInfo` dictionary.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceSessionDidBecomeActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts before a user session switches out.
    ///
    /// ## Discussion
    ///
    /// This notification allows an app to disable some processing, such as when its user session switches out, and re-enable when that session switches back in.
    ///
    /// The notification object is the shared [`NSWorkspace`](https://developer.apple.com/documentation/appkit/nsworkspace) instance. The notification doesn’t contain a `userInfo` dictionary.
    ///
    /// If an app launches in an inactive session, the workspace sends [`NSWorkspaceSessionDidResignActiveNotification`](https://developer.apple.com/documentation/appkit/nsworkspace/sessiondidresignactivenotification) after [`NSApplicationWillFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/willfinishlaunchingnotification) and before sending [`NSApplicationDidFinishLaunchingNotification`](https://developer.apple.com/documentation/appkit/nsapplication/didfinishlaunchingnotification).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceSessionDidResignActiveNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when the Finder file labels or colors change.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The notification doesn’t contain a `userInfo` dictionary.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceDidChangeFileLabelsNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that the workspace posts when a Spaces change occurs.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The notification doesn’t contain a `userInfo` dictionary.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceActiveSpaceDidChangeNotification: &'static NSNotificationName;
}

/// Constants that define types of file operations.
///
/// ## Overview
///
/// These constants specify different types of file operations used by [`performFileOperation:source:destination:files:tag:`](https://developer.apple.com/documentation/appkit/nsworkspace/performfileoperation(_:source:destination:files:tag:)).
///
///
#[deprecated]
// NS_TYPED_ENUM
pub type NSWorkspaceFileOperationName = NSString;

/// Constants specifying how you want to launch an app
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSWorkspaceLaunchOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSWorkspaceLaunchOptions: NSUInteger {
/// Print items instead of opening them.
        #[doc(alias = "NSWorkspaceLaunchAndPrint")]
#[deprecated = "Use -[NSWorkspaceOpenConfiguration setForPrinting:YES] instead."]
        const AndPrint = 0x00000002;
/// Display an error panel to the user if a failure occurs.
        #[doc(alias = "NSWorkspaceLaunchWithErrorPresentation")]
#[deprecated = "Use -[NSWorkspaceOpenConfiguration setPromptsUserIfNeeded:YES] instead."]
        const WithErrorPresentation = 0x00000040;
/// Causes launch to fail if the target is background-only.
        #[doc(alias = "NSWorkspaceLaunchInhibitingBackgroundOnly")]
#[deprecated = "This option does nothing."]
        const InhibitingBackgroundOnly = 0x00000080;
/// Do not add the app or documents to the Recents menu.
        #[doc(alias = "NSWorkspaceLaunchWithoutAddingToRecents")]
#[deprecated = "Use -[NSWorkspaceOpenConfiguration setAddsToRecentItems:YES] instead."]
        const WithoutAddingToRecents = 0x00000100;
/// Launch the app but do not bring it into the foreground.
        #[doc(alias = "NSWorkspaceLaunchWithoutActivation")]
#[deprecated = "Use -[NSWorkspaceOpenConfiguration setActivates:NO] instead."]
        const WithoutActivation = 0x00000200;
/// Launch the app and return the results asynchronously.
        #[doc(alias = "NSWorkspaceLaunchAsync")]
#[deprecated = "When using NSWorkspaceOpenConfiguration, all launches are asynchronous."]
        const Async = 0x00010000;
/// Create a new instance of the app, even if one is already running.
        #[doc(alias = "NSWorkspaceLaunchNewInstance")]
#[deprecated = "Use -[NSWorkspaceOpenConfiguration setCreatesNewApplicationInstance:YES] instead."]
        const NewInstance = 0x00080000;
/// Tell the app to hide itself as soon as it finishes launching.
        #[doc(alias = "NSWorkspaceLaunchAndHide")]
#[deprecated = "Use -[NSWorkspaceOpenConfiguration setHides:YES] instead."]
        const AndHide = 0x00100000;
/// Hide all apps except the newly launched one.
        #[doc(alias = "NSWorkspaceLaunchAndHideOthers")]
#[deprecated = "Use -[NSWorkspaceOpenConfiguration setHidesOthers:YES] instead."]
        const AndHideOthers = 0x00200000;
/// Launch the app asynchronously and launch it in the Classic environment, if required.
        #[doc(alias = "NSWorkspaceLaunchDefault")]
#[deprecated = "Use NSWorkspaceOpenConfiguration instead."]
        const Default = NSWorkspaceLaunchOptions::Async.0;
/// Start up the Classic compatibility environment, if it is required by the app.
        #[doc(alias = "NSWorkspaceLaunchAllowingClassicStartup")]
#[deprecated = "The Classic environment is no longer supported."]
        const AllowingClassicStartup = 0x00020000;
/// Force the app to launch in the Classic compatibility environment.
        #[doc(alias = "NSWorkspaceLaunchPreferringClassic")]
#[deprecated = "The Classic environment is no longer supported."]
        const PreferringClassic = 0x00040000;
    }
}

unsafe impl Encode for NSWorkspaceLaunchOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSWorkspaceLaunchOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The following keys can be used in the configuration dictionary of the [`launchApplicationAtURL:options:configuration:error:`](https://developer.apple.com/documentation/appkit/nsworkspace/launchapplication(at:options:configuration:)) method.  Each key is optional, and if omitted, default behavior is applied.
#[deprecated = "Use NSWorkspaceOpenConfiguration instead."]
// NS_TYPED_ENUM
pub type NSWorkspaceLaunchConfigurationKey = NSString;

extern "C" {
    /// The value is the first NSAppleEventDescriptor to send to the new app.  If an instance of the app is already running, this is sent to that app.
    #[deprecated = "Use -[NSWorkspaceOpenConfiguration setAppleEvent:] instead."]
    pub static NSWorkspaceLaunchConfigurationAppleEvent: &'static NSWorkspaceLaunchConfigurationKey;
}

extern "C" {
    /// The value is an `NSArray` of `NSStrings`, passed to the new app in the `argv` parameter.  Ignored if a new instance of the app is not launched. This constant is not available to sandboxed apps.
    #[deprecated = "Use -[NSWorkspaceOpenConfiguration setArguments:] instead."]
    pub static NSWorkspaceLaunchConfigurationArguments: &'static NSWorkspaceLaunchConfigurationKey;
}

extern "C" {
    /// The value is an `NSDictionary`, mapping `NSStrings` to `NSStrings`, containing environment variables to set for the new app.  Ignored if a new instance of the app is not launched. This constant is not available to sandboxed apps.
    #[deprecated = "Use -[NSWorkspaceOpenConfiguration setEnvironment:] instead."]
    pub static NSWorkspaceLaunchConfigurationEnvironment:
        &'static NSWorkspaceLaunchConfigurationKey;
}

extern "C" {
    /// The value is an NSNumber containing an Mach-O Architecture constant.  Ignored if a new instance of the app is not launched.
    #[deprecated = "Do not specify an architecutre. When unspecified, the architecture for a new application instance will be determined based on the available architectures in its executable."]
    pub static NSWorkspaceLaunchConfigurationArchitecture:
        &'static NSWorkspaceLaunchConfigurationKey;
}

/// NSDeprecated.
impl NSWorkspace {
    extern_methods!(
        #[deprecated = "Use -[NSWorkspace openURL:] instead."]
        #[unsafe(method(openFile:))]
        #[unsafe(method_family = none)]
        pub fn openFile(&self, full_path: &NSString) -> bool;

        #[deprecated = "Use -[NSWorkspace openURLs:withApplicationAtURL:configuration:completionHandler:] instead."]
        #[unsafe(method(openFile:withApplication:))]
        #[unsafe(method_family = none)]
        pub fn openFile_withApplication(
            &self,
            full_path: &NSString,
            app_name: Option<&NSString>,
        ) -> bool;

        #[deprecated = "Use -[NSWorkspace openURLs:withApplicationAtURL:configuration:completionHandler:] instead."]
        #[unsafe(method(openFile:withApplication:andDeactivate:))]
        #[unsafe(method_family = none)]
        pub fn openFile_withApplication_andDeactivate(
            &self,
            full_path: &NSString,
            app_name: Option<&NSString>,
            flag: bool,
        ) -> bool;

        #[deprecated = "Use -[NSWorkspace openApplicationAtURL:configuration:completionHandler:] instead."]
        #[unsafe(method(launchApplication:))]
        #[unsafe(method_family = none)]
        pub fn launchApplication(&self, app_name: &NSString) -> bool;

        #[cfg(feature = "NSRunningApplication")]
        /// # Safety
        ///
        /// `configuration` generic should be of the correct type.
        #[deprecated = "Use -[NSWorkspace openApplicationAtURL:configuration:completionHandler:] instead."]
        #[unsafe(method(launchApplicationAtURL:options:configuration:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn launchApplicationAtURL_options_configuration_error(
            &self,
            url: &NSURL,
            options: NSWorkspaceLaunchOptions,
            configuration: &NSDictionary<NSWorkspaceLaunchConfigurationKey, AnyObject>,
        ) -> Result<Retained<NSRunningApplication>, Retained<NSError>>;

        #[cfg(feature = "NSRunningApplication")]
        /// # Safety
        ///
        /// `configuration` generic should be of the correct type.
        #[deprecated = "Use -[NSWorkspace openURL:configuration:completionHandler:] instead."]
        #[unsafe(method(openURL:options:configuration:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn openURL_options_configuration_error(
            &self,
            url: &NSURL,
            options: NSWorkspaceLaunchOptions,
            configuration: &NSDictionary<NSWorkspaceLaunchConfigurationKey, AnyObject>,
        ) -> Result<Retained<NSRunningApplication>, Retained<NSError>>;

        #[cfg(feature = "NSRunningApplication")]
        /// # Safety
        ///
        /// `configuration` generic should be of the correct type.
        #[deprecated = "Use -[NSWorkspace openURLs:withApplicationAtURL:configuration:completionHandler:] instead."]
        #[unsafe(method(openURLs:withApplicationAtURL:options:configuration:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn openURLs_withApplicationAtURL_options_configuration_error(
            &self,
            urls: &NSArray<NSURL>,
            application_url: &NSURL,
            options: NSWorkspaceLaunchOptions,
            configuration: &NSDictionary<NSWorkspaceLaunchConfigurationKey, AnyObject>,
        ) -> Result<Retained<NSRunningApplication>, Retained<NSError>>;

        #[deprecated = "Use -[NSWorkspace openApplicationAtURL:configuration:completionHandler:] instead."]
        #[unsafe(method(launchApplication:showIcon:autolaunch:))]
        #[unsafe(method_family = none)]
        pub fn launchApplication_showIcon_autolaunch(
            &self,
            app_name: &NSString,
            show_icon: bool,
            autolaunch: bool,
        ) -> bool;

        #[deprecated = "Use -[NSWorkspace URLForApplicationWithBundleIdentifier:] instead."]
        #[unsafe(method(fullPathForApplication:))]
        #[unsafe(method_family = none)]
        pub fn fullPathForApplication(&self, app_name: &NSString) -> Option<Retained<NSString>>;

        #[deprecated = "Use -[NSWorkspace URLForApplicationWithBundleIdentifier:] instead."]
        #[unsafe(method(absolutePathForAppBundleWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn absolutePathForAppBundleWithIdentifier(
            &self,
            bundle_identifier: &NSString,
        ) -> Option<Retained<NSString>>;

        #[deprecated = "Use -[NSWorkspace openApplicationAtURL:configuration:completionHandler:] instead."]
        #[unsafe(method(launchAppWithBundleIdentifier:options:additionalEventParamDescriptor:launchIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn launchAppWithBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifier(
            &self,
            bundle_identifier: &NSString,
            options: NSWorkspaceLaunchOptions,
            descriptor: Option<&NSAppleEventDescriptor>,
            identifier: Option<&mut Option<Retained<NSNumber>>>,
        ) -> bool;

        #[deprecated = "Use -[NSWorkspace openURLs:withApplicationAtURL:configuration:completionHandler:] instead."]
        #[unsafe(method(openURLs:withAppBundleIdentifier:options:additionalEventParamDescriptor:launchIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn openURLs_withAppBundleIdentifier_options_additionalEventParamDescriptor_launchIdentifiers(
            &self,
            urls: &NSArray<NSURL>,
            bundle_identifier: Option<&NSString>,
            options: NSWorkspaceLaunchOptions,
            descriptor: Option<&NSAppleEventDescriptor>,
            identifiers: Option<&mut Option<Retained<NSArray<NSNumber>>>>,
        ) -> bool;

        #[deprecated]
        #[unsafe(method(openTempFile:))]
        #[unsafe(method_family = none)]
        pub fn openTempFile(&self, full_path: &NSString) -> bool;

        #[deprecated]
        #[unsafe(method(findApplications))]
        #[unsafe(method_family = none)]
        pub fn findApplications(&self);

        #[deprecated]
        #[unsafe(method(noteUserDefaultsChanged))]
        #[unsafe(method_family = none)]
        pub fn noteUserDefaultsChanged(&self);

        #[cfg(feature = "NSImage")]
        #[deprecated]
        #[unsafe(method(slideImage:from:to:))]
        #[unsafe(method_family = none)]
        pub fn slideImage_from_to(&self, image: &NSImage, from_point: NSPoint, to_point: NSPoint);

        #[deprecated]
        #[unsafe(method(checkForRemovableMedia))]
        #[unsafe(method_family = none)]
        pub fn checkForRemovableMedia(&self);

        #[deprecated]
        #[unsafe(method(noteFileSystemChanged))]
        #[unsafe(method_family = none)]
        pub fn noteFileSystemChanged(&self);

        #[deprecated]
        #[unsafe(method(fileSystemChanged))]
        #[unsafe(method_family = none)]
        pub fn fileSystemChanged(&self) -> bool;

        #[deprecated]
        #[unsafe(method(userDefaultsChanged))]
        #[unsafe(method_family = none)]
        pub fn userDefaultsChanged(&self) -> bool;

        #[deprecated]
        #[unsafe(method(mountNewRemovableMedia))]
        #[unsafe(method_family = none)]
        pub fn mountNewRemovableMedia(&self) -> Option<Retained<NSArray>>;

        #[deprecated = "Use -[NSWorkspace frontmostApplication] instead."]
        #[unsafe(method(activeApplication))]
        #[unsafe(method_family = none)]
        pub fn activeApplication(&self) -> Option<Retained<NSDictionary>>;

        #[deprecated = "Use -[NSFileManager mountedVolumeURLsIncludingResourceValuesForKeys:options:] instead."]
        #[unsafe(method(mountedLocalVolumePaths))]
        #[unsafe(method_family = none)]
        pub fn mountedLocalVolumePaths(&self) -> Option<Retained<NSArray>>;

        #[deprecated = "Use -[NSFileManager mountedVolumeURLsIncludingResourceValuesForKeys:options:] instead."]
        #[unsafe(method(mountedRemovableMedia))]
        #[unsafe(method_family = none)]
        pub fn mountedRemovableMedia(&self) -> Option<Retained<NSArray>>;

        #[deprecated = "Use -[NSWorkspace runningApplications] instead."]
        #[unsafe(method(launchedApplications))]
        #[unsafe(method_family = none)]
        pub fn launchedApplications(&self) -> Option<Retained<NSArray>>;

        #[cfg(all(feature = "NSImage", feature = "NSResponder", feature = "NSView"))]
        #[deprecated = "Use -[NSWorkspace openURL:] instead."]
        #[unsafe(method(openFile:fromImage:at:inView:))]
        #[unsafe(method_family = none)]
        pub fn openFile_fromImage_at_inView(
            &self,
            full_path: &NSString,
            image: Option<&NSImage>,
            point: NSPoint,
            view: Option<&NSView>,
        ) -> bool;

        /// # Safety
        ///
        /// - `files` generic should be of the correct type.
        /// - `tag` must be a valid pointer or null.
        #[deprecated]
        #[unsafe(method(performFileOperation:source:destination:files:tag:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performFileOperation_source_destination_files_tag(
            &self,
            operation: &NSWorkspaceFileOperationName,
            source: &NSString,
            destination: &NSString,
            files: &NSArray,
            tag: *mut NSInteger,
        ) -> bool;

        #[deprecated = "Use -[NSWorkspace URLForApplicationToOpenURL:] to get the URL of an application that will open a given item, or -[NSURL getResourceValue:forKey:error:] with NSURLContentTypeKey to get the type of the given item."]
        #[unsafe(method(getInfoForFile:application:type:))]
        #[unsafe(method_family = none)]
        pub fn getInfoForFile_application_type(
            &self,
            full_path: &NSString,
            app_name: Option<&mut Option<Retained<NSString>>>,
            r#type: Option<&mut Option<Retained<NSString>>>,
        ) -> bool;

        #[cfg(feature = "NSImage")]
        #[deprecated = "Use -[NSWorkspace iconForContentType:] instead."]
        #[unsafe(method(iconForFileType:))]
        #[unsafe(method_family = none)]
        pub fn iconForFileType(&self, file_type: &NSString) -> Retained<NSImage>;

        #[deprecated = "Use -[NSURL getResourceValue:forKey:error:] with NSURLContentTypeKey instead."]
        #[unsafe(method(typeOfFile:error:_))]
        #[unsafe(method_family = none)]
        pub fn typeOfFile_error(
            &self,
            absolute_file_path: &NSString,
        ) -> Result<Retained<NSString>, Retained<NSError>>;

        #[deprecated = "Use UTType.localizedDescription instead."]
        #[unsafe(method(localizedDescriptionForType:))]
        #[unsafe(method_family = none)]
        pub fn localizedDescriptionForType(
            &self,
            type_name: &NSString,
        ) -> Option<Retained<NSString>>;

        #[deprecated = "Use UTType.preferredFilenameExtension instead."]
        #[unsafe(method(preferredFilenameExtensionForType:))]
        #[unsafe(method_family = none)]
        pub fn preferredFilenameExtensionForType(
            &self,
            type_name: &NSString,
        ) -> Option<Retained<NSString>>;

        #[deprecated = "Use +[UTType typesWithTag:tagClass:conformingToType:] to get a list of candidate types, then check if the input type conforms to any of them."]
        #[unsafe(method(filenameExtension:isValidForType:))]
        #[unsafe(method_family = none)]
        pub fn filenameExtension_isValidForType(
            &self,
            filename_extension: &NSString,
            type_name: &NSString,
        ) -> bool;

        #[deprecated = "Use -[UTType conformsToType:] instead."]
        #[unsafe(method(type:conformsToType:))]
        #[unsafe(method_family = none)]
        pub fn type_conformsToType(
            &self,
            first_type_name: &NSString,
            second_type_name: &NSString,
        ) -> bool;
    );
}

extern "C" {
    /// Move file to destination.
    ///
    /// ## Discussion
    ///
    /// Behaves the same as [`moveItemAtURL:toURL:error:`](https://developer.apple.com/documentation/foundation/filemanager/moveitem(at:to:)).
    ///
    ///
    #[deprecated = "Use -[NSFileManager moveItemAtURL:toURL:error:] instead."]
    pub static NSWorkspaceMoveOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Copy file to destination.
    ///
    /// ## Discussion
    ///
    /// Behaves the same as [`copyItemAtURL:toURL:error:`](https://developer.apple.com/documentation/foundation/filemanager/copyitem(at:to:)).
    ///
    ///
    #[deprecated = "Use -[NSFileManager copyItemAtURL:toURL:error:] instead."]
    pub static NSWorkspaceCopyOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Create hard link to file in destination.
    ///
    /// ## Discussion
    ///
    /// Behaves the same as [`linkItemAtURL:toURL:error:`](https://developer.apple.com/documentation/foundation/filemanager/linkitem(at:to:)).
    ///
    ///
    #[deprecated = "Use -[NSFileManager linkItemAtURL:toURL:error:] instead."]
    pub static NSWorkspaceLinkOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Compress file. This operation always returns an error.
    #[deprecated = "This operation is unimplemented."]
    pub static NSWorkspaceCompressOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Decompress file. This operation always returns an error.
    #[deprecated = "This operation is unimplemented."]
    pub static NSWorkspaceDecompressOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Encrypt file. This operation always returns an error.
    #[deprecated = "This operation is unimplemented."]
    pub static NSWorkspaceEncryptOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Decrypt file. This operation always returns an error.
    #[deprecated = "This operation is unimplemented."]
    pub static NSWorkspaceDecryptOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Destroy file.
    ///
    /// ## Discussion
    ///
    /// Behaves the same as  [`removeItemAtURL:error:`](https://developer.apple.com/documentation/foundation/filemanager/removeitem(at:)).
    ///
    ///
    #[deprecated = "Use -[NSFileManager removeItemAtURL:error:] instead."]
    pub static NSWorkspaceDestroyOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Move file to trash.
    ///
    /// ## Discussion
    ///
    /// The file is moved to the trash folder on the volume containing the file using the same semantics as [`NSWorkspaceMoveOperation`](https://developer.apple.com/documentation/appkit/nsworkspace/fileoperationname/moveoperation). If a file with the same name currently exists in the trash folder, the new file is renamed. If no trash folder exists on the volume containing the file, the operation fails.
    ///
    ///
    #[deprecated = "Use -[NSWorkspace recycleURLs:completionHandler:] instead."]
    pub static NSWorkspaceRecycleOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Duplicate file in source directory.
    #[deprecated = "Use -[NSWorkspace duplicateURLs:completionHandler:] instead."]
    pub static NSWorkspaceDuplicateOperation: &'static NSWorkspaceFileOperationName;
}

extern "C" {
    /// Posted when a file operation has been performed in the receiving app.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The `userInfo` dictionary contains a key `@"NSOperationNumber"` with a `NSNumber` object containing an integer indicating the type of file operation
    ///
    ///
    #[deprecated]
    pub static NSWorkspaceDidPerformFileOperationNotification: &'static NSNotificationName;
}

extern "C" {
    /// Plain (untyped) file.
    #[deprecated]
    pub static NSPlainFileType: &'static NSString;
}

extern "C" {
    /// Directory.
    #[deprecated]
    pub static NSDirectoryFileType: &'static NSString;
}

extern "C" {
    /// Cocoa app.
    #[deprecated]
    pub static NSApplicationFileType: &'static NSString;
}

extern "C" {
    /// File-system mount point.
    #[deprecated]
    pub static NSFilesystemFileType: &'static NSString;
}

extern "C" {
    /// Executable shell command.
    #[deprecated]
    pub static NSShellCommandFileType: &'static NSString;
}
