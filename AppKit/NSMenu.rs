//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// Specifies the style of a menu.
/// When set as a value on `NSMenu.presentationStyle`, determines how
/// the given menu is presented.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSMenuPresentationStyle(pub NSInteger);
impl NSMenuPresentationStyle {
    /// The default presentation style for a menu.
    ///
    /// ## Discussion
    ///
    /// When you select this style of menu the system presents the menu as either a popup or context menu based on the context.
    ///
    /// This is the default presentation style for a menu.
    ///
    ///
    /// The default presentation style. Typically means the menu will
    /// be presented as either a popup or pulldown menu, based on the
    /// context.
    #[doc(alias = "NSMenuPresentationStyleRegular")]
    pub const Regular: Self = Self(0);
    /// A menu presentation style where items to display align horizontally.
    ///
    /// ## Discussion
    ///
    /// You can turn any menu into a palette menu by setting the menu’s presentation style to `.palette`. For each menu item, set its image. For template images, AppKit automatically adds the appropriate selection tint. Alternatively you can set the [`offStateImage`](https://developer.apple.com/documentation/appkit/nsmenuitem/offstateimage) and the [`onStateImage`](https://developer.apple.com/documentation/appkit/nsmenuitem/onstateimage). Use the `onStateImage` to indicate selection.
    ///
    /// The following example creates a presentation style menu that displays a list of sport images. When a menu item selects, the system automatically tints the image.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/21c356aaf796657a7dcbe1a9dfe26cf3/media-4304532~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/8563e34565a1851e905ce287868a8bb1/media-4304532%402x.png 2x" />
    ///     <img alt="A palette style menu that expands to the right from a selected sports menu item listing a series of sport images horizonally. The second item in the list is tinted indicating selection." src="https://docs-assets.developer.apple.com/published/8563e34565a1851e905ce287868a8bb1/media-4304532%402x.png" />
    /// </picture>
    ///
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let parentMenu = NSMenu()", "", "// Create a menu.", "let paletteMenu = NSMenu()", "let symbols = [\"figure.barre\", \"figure.american.football\", \"figure.soccer\", \"figure.fishing\", \"figure.roll\"]", "for symbol in symbols {", "    let item = NSMenuItem(title: symbol, action: nil, keyEquivalent: \"\")", "    item.image = NSImage(systemSymbolName: symbol, accessibilityDescription: symbol)", "    paletteMenu.addItem(item)", "}", "", "// Set the presentation style of the menu to palette.", "paletteMenu.presentationStyle = .palette", "", "// Create a menu item for the palette.", "let paletteMenuItem = NSMenuItem()", "paletteMenuItem.submenu = paletteMenu", "", "// Create a menu and corresponding menu item to contain the palette menu item.", "let menu = NSMenu(title: \"Sports\")", "menu.addItem(.sectionHeader(title: \"Sports Menu\"))", "menu.addItem(paletteMenuItem)", "", "let menuItem = NSMenuItem()", "menuItem.title = \"Sports\"", "menuItem.submenu = menu", "", "// Add the menu containing the palette to the parent menu.", "parentMenu.addItem(menuItem)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSMenu *parentMenu = [[NSMenu alloc] init];", "", "// Create a menu.", "NSMenu *paletteMenu = [[NSMenu alloc] init];", "NSArray *symbols = @[@\"figure.barre\", @\"figure.american.football\", @\"figure.soccer\", @\"figure.fishing\", @\"figure.roll\"];", "int index;", "for(NSInteger index = 0; index < symbols.count; index++) {", "    NSString *symbol = symbols[index];", "    NSMenuItem *item = [[NSMenuItem alloc] initWithTitle:symbol action:nil keyEquivalent:@\"\"];", "    item.image = [NSImage imageWithSystemSymbolName:symbol accessibilityDescription:@\"\"];", "    [paletteMenu addItem:item];", "}", "", "// Set the presentation style of the menu to palette.", "paletteMenu.presentationStyle = NSMenuPresentationStylePalette;", "", "// Create a menu item for the palette.", "NSMenuItem *paletteMenuItem = [[NSMenuItem alloc] init];", "paletteMenuItem.submenu = paletteMenu;", "", "// Create a menu and corresponding menu item to contain the palette menu item.", "NSMenu *menu = [[NSMenu alloc] initWithTitle:@\"Sports\"];", "[menu addItem:[NSMenuItem sectionHeaderWithTitle:@\"Sports Menu\"]];", "[menu addItem:paletteMenuItem];", "", "NSMenuItem *menuItem = [[NSMenuItem alloc] init];", "menuItem.title = @\"Sports\";", "menuItem.submenu = menu;", "", "// Add the menu containing the palette to the parent menu.", "[parentMenu addItem:menuItem];"], metadata: None }] }] })
    ///
    /// The menu marked as palette is to be displayed in place of the
    /// menu item presenting it, with its items aligned horizontally.
    #[doc(alias = "NSMenuPresentationStylePalette")]
    pub const Palette: Self = Self(1);
}

unsafe impl Encode for NSMenuPresentationStyle {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSMenuPresentationStyle {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Describes how the menu manages selection states of the menu items that belong to the same selection group.
///
/// ## Overview
///
/// This doesn’t apply to menu items that have distinct target-action values.
///
///
/// When set as a value on `NSMenu.selectionMode`, determines how the
/// menu manages selection states of the menu items that belong to
/// the same selection group.
///
/// This does not apply to menu items that have distinct
/// target/action values.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSMenuSelectionMode(pub NSInteger);
impl NSMenuSelectionMode {
    /// A selection mode where the menu determines the appropriate selection mode based on the context and its constants.
    /// The menu will determine the appropriate selection mode based
    /// on the context and its contents.
    #[doc(alias = "NSMenuSelectionModeAutomatic")]
    pub const Automatic: Self = Self(0);
    /// A selection mode where someone can select at most one menu item in the same selection group at the same time.
    ///
    /// ## Discussion
    ///
    /// A change in selection deselects any previously selected item.
    ///
    ///
    /// The user will be allowed to select at most one menu item in
    /// the same selection group at a time. A change in selection
    /// will deselect any previously selected item.
    #[doc(alias = "NSMenuSelectionModeSelectOne")]
    pub const SelectOne: Self = Self(1);
    /// A selection mode where someone can select multiple items in the menu.
    ///
    /// ## Discussion
    ///
    /// A change in selection doesn’t automatically deselect any previously selected item in the same selection group.
    ///
    ///
    /// The user can select multiple items in the menu. A change in
    /// selection will not automatically deselect any previously
    /// selected item in the same selection group.
    #[doc(alias = "NSMenuSelectionModeSelectAny")]
    pub const SelectAny: Self = Self(2);
}

unsafe impl Encode for NSMenuSelectionMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSMenuSelectionMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that manages an app’s menus.
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSMenu;
);

#[cfg(feature = "NSAccessibilityProtocols")]
extern_conformance!(
    unsafe impl NSAccessibility for NSMenu {}
);

#[cfg(feature = "NSAccessibilityProtocols")]
extern_conformance!(
    unsafe impl NSAccessibilityElementProtocol for NSMenu {}
);

#[cfg(feature = "NSAppearance")]
extern_conformance!(
    unsafe impl NSAppearanceCustomization for NSMenu {}
);

extern_conformance!(
    unsafe impl NSCoding for NSMenu {}
);

extern_conformance!(
    unsafe impl NSCopying for NSMenu {}
);

unsafe impl CopyingHelper for NSMenu {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSMenu {}
);

#[cfg(feature = "NSUserInterfaceItemIdentification")]
extern_conformance!(
    unsafe impl NSUserInterfaceItemIdentification for NSMenu {}
);

impl NSMenu {
    extern_methods!(
        #[unsafe(method(initWithTitle:))]
        #[unsafe(method_family = init)]
        pub fn initWithTitle(this: Allocated<Self>, title: &NSString) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(this: Allocated<Self>, coder: &NSCoder) -> Retained<Self>;

        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub fn title(&self) -> Retained<NSString>;

        /// Setter for [`title`][Self::title].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTitle:))]
        #[unsafe(method_family = none)]
        pub fn setTitle(&self, title: &NSString);

        #[cfg(all(feature = "NSEvent", feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(popUpContextMenu:withEvent:forView:))]
        #[unsafe(method_family = none)]
        pub fn popUpContextMenu_withEvent_forView(menu: &NSMenu, event: &NSEvent, view: &NSView);

        #[cfg(all(
            feature = "NSEvent",
            feature = "NSFont",
            feature = "NSResponder",
            feature = "NSView"
        ))]
        #[unsafe(method(popUpContextMenu:withEvent:forView:withFont:))]
        #[unsafe(method_family = none)]
        pub fn popUpContextMenu_withEvent_forView_withFont(
            menu: &NSMenu,
            event: &NSEvent,
            view: &NSView,
            font: Option<&NSFont>,
        );

        #[cfg(all(feature = "NSMenuItem", feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(popUpMenuPositioningItem:atLocation:inView:))]
        #[unsafe(method_family = none)]
        pub fn popUpMenuPositioningItem_atLocation_inView(
            &self,
            item: Option<&NSMenuItem>,
            location: NSPoint,
            view: Option<&NSView>,
        ) -> bool;

        #[unsafe(method(setMenuBarVisible:))]
        #[unsafe(method_family = none)]
        pub fn setMenuBarVisible(visible: bool, mtm: MainThreadMarker);

        #[unsafe(method(menuBarVisible))]
        #[unsafe(method_family = none)]
        pub fn menuBarVisible(mtm: MainThreadMarker) -> bool;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(supermenu))]
        #[unsafe(method_family = none)]
        pub unsafe fn supermenu(&self) -> Option<Retained<NSMenu>>;

        /// Setter for [`supermenu`][Self::supermenu].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setSupermenu:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupermenu(&self, supermenu: Option<&NSMenu>);

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(insertItem:atIndex:))]
        #[unsafe(method_family = none)]
        pub fn insertItem_atIndex(&self, new_item: &NSMenuItem, index: NSInteger);

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(addItem:))]
        #[unsafe(method_family = none)]
        pub fn addItem(&self, new_item: &NSMenuItem);

        #[cfg(feature = "NSMenuItem")]
        /// # Safety
        ///
        /// `selector` must be a valid selector.
        #[unsafe(method(insertItemWithTitle:action:keyEquivalent:atIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertItemWithTitle_action_keyEquivalent_atIndex(
            &self,
            string: &NSString,
            selector: Option<Sel>,
            char_code: &NSString,
            index: NSInteger,
        ) -> Retained<NSMenuItem>;

        #[cfg(feature = "NSMenuItem")]
        /// # Safety
        ///
        /// `selector` must be a valid selector.
        #[unsafe(method(addItemWithTitle:action:keyEquivalent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addItemWithTitle_action_keyEquivalent(
            &self,
            string: &NSString,
            selector: Option<Sel>,
            char_code: &NSString,
        ) -> Retained<NSMenuItem>;

        #[unsafe(method(removeItemAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn removeItemAtIndex(&self, index: NSInteger);

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(removeItem:))]
        #[unsafe(method_family = none)]
        pub fn removeItem(&self, item: &NSMenuItem);

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(setSubmenu:forItem:))]
        #[unsafe(method_family = none)]
        pub fn setSubmenu_forItem(&self, menu: Option<&NSMenu>, item: &NSMenuItem);

        #[unsafe(method(removeAllItems))]
        #[unsafe(method_family = none)]
        pub fn removeAllItems(&self);

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(itemArray))]
        #[unsafe(method_family = none)]
        pub fn itemArray(&self) -> Retained<NSArray<NSMenuItem>>;

        #[cfg(feature = "NSMenuItem")]
        /// Setter for [`itemArray`][Self::itemArray].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setItemArray:))]
        #[unsafe(method_family = none)]
        pub fn setItemArray(&self, item_array: &NSArray<NSMenuItem>);

        #[unsafe(method(numberOfItems))]
        #[unsafe(method_family = none)]
        pub fn numberOfItems(&self) -> NSInteger;

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(itemAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn itemAtIndex(&self, index: NSInteger) -> Option<Retained<NSMenuItem>>;

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(indexOfItem:))]
        #[unsafe(method_family = none)]
        pub fn indexOfItem(&self, item: &NSMenuItem) -> NSInteger;

        #[unsafe(method(indexOfItemWithTitle:))]
        #[unsafe(method_family = none)]
        pub fn indexOfItemWithTitle(&self, title: &NSString) -> NSInteger;

        #[unsafe(method(indexOfItemWithTag:))]
        #[unsafe(method_family = none)]
        pub fn indexOfItemWithTag(&self, tag: NSInteger) -> NSInteger;

        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[unsafe(method(indexOfItemWithRepresentedObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn indexOfItemWithRepresentedObject(
            &self,
            object: Option<&AnyObject>,
        ) -> NSInteger;

        #[unsafe(method(indexOfItemWithSubmenu:))]
        #[unsafe(method_family = none)]
        pub fn indexOfItemWithSubmenu(&self, submenu: Option<&NSMenu>) -> NSInteger;

        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `action_selector` must be a valid selector.
        #[unsafe(method(indexOfItemWithTarget:andAction:))]
        #[unsafe(method_family = none)]
        pub unsafe fn indexOfItemWithTarget_andAction(
            &self,
            target: Option<&AnyObject>,
            action_selector: Option<Sel>,
        ) -> NSInteger;

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(itemWithTitle:))]
        #[unsafe(method_family = none)]
        pub fn itemWithTitle(&self, title: &NSString) -> Option<Retained<NSMenuItem>>;

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(itemWithTag:))]
        #[unsafe(method_family = none)]
        pub fn itemWithTag(&self, tag: NSInteger) -> Option<Retained<NSMenuItem>>;

        #[unsafe(method(autoenablesItems))]
        #[unsafe(method_family = none)]
        pub fn autoenablesItems(&self) -> bool;

        /// Setter for [`autoenablesItems`][Self::autoenablesItems].
        #[unsafe(method(setAutoenablesItems:))]
        #[unsafe(method_family = none)]
        pub fn setAutoenablesItems(&self, autoenables_items: bool);

        #[unsafe(method(update))]
        #[unsafe(method_family = none)]
        pub fn update(&self);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(performKeyEquivalent:))]
        #[unsafe(method_family = none)]
        pub fn performKeyEquivalent(&self, event: &NSEvent) -> bool;

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(itemChanged:))]
        #[unsafe(method_family = none)]
        pub fn itemChanged(&self, item: &NSMenuItem);

        #[unsafe(method(performActionForItemAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn performActionForItemAtIndex(&self, index: NSInteger);

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSMenuDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSMenuDelegate>>);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(menuBarHeight))]
        #[unsafe(method_family = none)]
        pub fn menuBarHeight(&self) -> CGFloat;

        #[unsafe(method(cancelTracking))]
        #[unsafe(method_family = none)]
        pub fn cancelTracking(&self);

        #[unsafe(method(cancelTrackingWithoutAnimation))]
        #[unsafe(method_family = none)]
        pub fn cancelTrackingWithoutAnimation(&self);

        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(highlightedItem))]
        #[unsafe(method_family = none)]
        pub fn highlightedItem(&self) -> Option<Retained<NSMenuItem>>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(minimumWidth))]
        #[unsafe(method_family = none)]
        pub fn minimumWidth(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`minimumWidth`][Self::minimumWidth].
        #[unsafe(method(setMinimumWidth:))]
        #[unsafe(method_family = none)]
        pub fn setMinimumWidth(&self, minimum_width: CGFloat);

        #[unsafe(method(size))]
        #[unsafe(method_family = none)]
        pub fn size(&self) -> NSSize;

        #[cfg(feature = "NSFont")]
        #[unsafe(method(font))]
        #[unsafe(method_family = none)]
        pub fn font(&self) -> Option<Retained<NSFont>>;

        #[cfg(feature = "NSFont")]
        /// Setter for [`font`][Self::font].
        ///
        /// # Safety
        ///
        /// `font` might not allow `None`.
        #[unsafe(method(setFont:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFont(&self, font: Option<&NSFont>);

        #[unsafe(method(allowsContextMenuPlugIns))]
        #[unsafe(method_family = none)]
        pub fn allowsContextMenuPlugIns(&self) -> bool;

        /// Setter for [`allowsContextMenuPlugIns`][Self::allowsContextMenuPlugIns].
        #[unsafe(method(setAllowsContextMenuPlugIns:))]
        #[unsafe(method_family = none)]
        pub fn setAllowsContextMenuPlugIns(&self, allows_context_menu_plug_ins: bool);

        #[unsafe(method(automaticallyInsertsWritingToolsItems))]
        #[unsafe(method_family = none)]
        pub fn automaticallyInsertsWritingToolsItems(&self) -> bool;

        /// Setter for [`automaticallyInsertsWritingToolsItems`][Self::automaticallyInsertsWritingToolsItems].
        #[unsafe(method(setAutomaticallyInsertsWritingToolsItems:))]
        #[unsafe(method_family = none)]
        pub fn setAutomaticallyInsertsWritingToolsItems(
            &self,
            automatically_inserts_writing_tools_items: bool,
        );

        #[unsafe(method(showsStateColumn))]
        #[unsafe(method_family = none)]
        pub fn showsStateColumn(&self) -> bool;

        /// Setter for [`showsStateColumn`][Self::showsStateColumn].
        #[unsafe(method(setShowsStateColumn:))]
        #[unsafe(method_family = none)]
        pub fn setShowsStateColumn(&self, shows_state_column: bool);

        #[cfg(feature = "NSUserInterfaceLayout")]
        #[unsafe(method(userInterfaceLayoutDirection))]
        #[unsafe(method_family = none)]
        pub fn userInterfaceLayoutDirection(&self) -> NSUserInterfaceLayoutDirection;

        #[cfg(feature = "NSUserInterfaceLayout")]
        /// Setter for [`userInterfaceLayoutDirection`][Self::userInterfaceLayoutDirection].
        #[unsafe(method(setUserInterfaceLayoutDirection:))]
        #[unsafe(method_family = none)]
        pub fn setUserInterfaceLayoutDirection(
            &self,
            user_interface_layout_direction: NSUserInterfaceLayoutDirection,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSMenu {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// NSPaletteMenus.
impl NSMenu {
    extern_methods!(
        #[cfg(all(feature = "NSColor", feature = "block2"))]
        /// Creates a palette menu displaying user-selectable color
        /// tags using the provided array of colors and optional titles.
        ///
        /// Note that the palette menu is configured for display as an inline menu; you must set it as the submenu of another menu item, contained in a standard menu.
        /// The palette menu cannot be used to invoke the `popUpMenuPositioningItem` method, or attached directly to a popup button or toolbar item.
        ///
        ///
        /// Returns: An autoconfigured palette menu.
        #[unsafe(method(paletteMenuWithColors:titles:selectionHandler:))]
        #[unsafe(method_family = none)]
        pub fn paletteMenuWithColors_titles_selectionHandler(
            colors: &NSArray<NSColor>,
            item_titles: &NSArray<NSString>,
            on_selection_change: Option<&block2::DynBlock<dyn Fn(NonNull<NSMenu>)>>,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(all(feature = "NSColor", feature = "NSImage", feature = "block2"))]
        /// Creates a palette menu displaying user-selectable color tags
        /// using the provided template image, tinted using the specified
        /// array of colors.
        ///
        /// Optionally allows observing changes to the selection state in
        /// the compact menu. The block is invoked after the selection
        /// has been updated. Currently selected items can be retrieved
        /// from the `selectedItems` property.
        ///
        /// Note that the palette menu is configured for display as an inline menu; you must set it as the submenu of another menu item, contained in a standard menu.
        /// The palette menu cannot be used to invoke the `popUpMenuPositioningItem` method, or attached directly to a popup button or toolbar item.
        ///
        ///
        /// Returns: An autoconfigured palette menu.
        #[unsafe(method(paletteMenuWithColors:titles:templateImage:selectionHandler:))]
        #[unsafe(method_family = none)]
        pub fn paletteMenuWithColors_titles_templateImage_selectionHandler(
            colors: &NSArray<NSColor>,
            item_titles: &NSArray<NSString>,
            image: &NSImage,
            on_selection_change: Option<&block2::DynBlock<dyn Fn(NonNull<NSMenu>)>>,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        /// The presentation style of the menu.
        ///
        ///
        /// Note: This property is not respected if the menu is the main
        /// menu of the app.
        #[unsafe(method(presentationStyle))]
        #[unsafe(method_family = none)]
        pub fn presentationStyle(&self) -> NSMenuPresentationStyle;

        /// Setter for [`presentationStyle`][Self::presentationStyle].
        #[unsafe(method(setPresentationStyle:))]
        #[unsafe(method_family = none)]
        pub fn setPresentationStyle(&self, presentation_style: NSMenuPresentationStyle);

        /// The selection mode of the menu.
        ///
        /// Note the selection mode only has effect on menu items that
        /// belong to the same selection group. A selection group consists
        /// of the items with the same target/action.
        #[unsafe(method(selectionMode))]
        #[unsafe(method_family = none)]
        pub fn selectionMode(&self) -> NSMenuSelectionMode;

        /// Setter for [`selectionMode`][Self::selectionMode].
        #[unsafe(method(setSelectionMode:))]
        #[unsafe(method_family = none)]
        pub fn setSelectionMode(&self, selection_mode: NSMenuSelectionMode);

        #[cfg(feature = "NSMenuItem")]
        /// The menu items that are selected.
        ///
        /// An item is selected when its state is `NSControl.StateValue.on`.
        ///
        ///
        /// Note: This property is settable. Setting `selectedItems` will
        /// select any items that are contained in the provided array, and
        /// deselect any previously selected items that are not in the array.
        #[unsafe(method(selectedItems))]
        #[unsafe(method_family = none)]
        pub fn selectedItems(&self) -> Retained<NSArray<NSMenuItem>>;

        #[cfg(feature = "NSMenuItem")]
        /// Setter for [`selectedItems`][Self::selectedItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSelectedItems:))]
        #[unsafe(method_family = none)]
        pub fn setSelectedItems(&self, selected_items: &NSArray<NSMenuItem>);
    );
}

/// NSSubmenuAction.
impl NSMenu {
    extern_methods!(
        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(submenuAction:))]
        #[unsafe(method_family = none)]
        pub unsafe fn submenuAction(&self, sender: Option<&AnyObject>);
    );
}

extern_protocol!(
    pub unsafe trait NSMenuItemValidation: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "NSMenuItem")]
        #[unsafe(method(validateMenuItem:))]
        #[unsafe(method_family = none)]
        fn validateMenuItem(&self, menu_item: &NSMenuItem) -> bool;
    }
);

extern_protocol!(
    /// The optional methods implemented by delegates of [`NSMenu`](https://developer.apple.com/documentation/appkit/nsmenu) objects to manage menu display and handle some events.
    pub unsafe trait NSMenuDelegate: NSObjectProtocol + MainThreadOnly {
        #[optional]
        #[unsafe(method(menuNeedsUpdate:))]
        #[unsafe(method_family = none)]
        fn menuNeedsUpdate(&self, menu: &NSMenu);

        #[optional]
        #[unsafe(method(numberOfItemsInMenu:))]
        #[unsafe(method_family = none)]
        fn numberOfItemsInMenu(&self, menu: &NSMenu) -> NSInteger;

        #[cfg(feature = "NSMenuItem")]
        #[optional]
        #[unsafe(method(menu:updateItem:atIndex:shouldCancel:))]
        #[unsafe(method_family = none)]
        fn menu_updateItem_atIndex_shouldCancel(
            &self,
            menu: &NSMenu,
            item: &NSMenuItem,
            index: NSInteger,
            should_cancel: bool,
        ) -> bool;

        #[optional]
        #[unsafe(method(menuWillOpen:))]
        #[unsafe(method_family = none)]
        fn menuWillOpen(&self, menu: &NSMenu);

        #[optional]
        #[unsafe(method(menuDidClose:))]
        #[unsafe(method_family = none)]
        fn menuDidClose(&self, menu: &NSMenu);

        #[cfg(feature = "NSMenuItem")]
        #[optional]
        #[unsafe(method(menu:willHighlightItem:))]
        #[unsafe(method_family = none)]
        fn menu_willHighlightItem(&self, menu: &NSMenu, item: Option<&NSMenuItem>);

        #[cfg(feature = "NSScreen")]
        #[optional]
        #[unsafe(method(confinementRectForMenu:onScreen:))]
        #[unsafe(method_family = none)]
        fn confinementRectForMenu_onScreen(
            &self,
            menu: &NSMenu,
            screen: Option<&NSScreen>,
        ) -> NSRect;
    }
);

/// These constants are used as a bitmask for specifying a set of menu or menu item properties, and are contained by the [`propertiesToUpdate`](https://developer.apple.com/documentation/appkit/nsmenu/propertiestoupdate) property.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSMenuProperties(pub NSUInteger);
bitflags::bitflags! {
    impl NSMenuProperties: NSUInteger {
/// The menu item’s title.
        #[doc(alias = "NSMenuPropertyItemTitle")]
        const ItemTitle = 1<<0;
/// The menu item’s attributed string title.
        #[doc(alias = "NSMenuPropertyItemAttributedTitle")]
        const ItemAttributedTitle = 1<<1;
/// The menu item’s key equivalent.
        #[doc(alias = "NSMenuPropertyItemKeyEquivalent")]
        const ItemKeyEquivalent = 1<<2;
/// The menu image.
        #[doc(alias = "NSMenuPropertyItemImage")]
        const ItemImage = 1<<3;
/// Whether the menu item is enabled or disabled.
        #[doc(alias = "NSMenuPropertyItemEnabled")]
        const ItemEnabled = 1<<4;
/// The menu item’s accessibility description.
        #[doc(alias = "NSMenuPropertyItemAccessibilityDescription")]
        const ItemAccessibilityDescription = 1<<5;
    }
}

unsafe impl Encode for NSMenuProperties {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSMenuProperties {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// NSMenuPropertiesToUpdate.
impl NSMenu {
    extern_methods!(
        #[unsafe(method(propertiesToUpdate))]
        #[unsafe(method_family = none)]
        pub fn propertiesToUpdate(&self) -> NSMenuProperties;
    );
}

extern "C" {
    /// Posted just before the application dispatches a menu item’s action method to the menu item’s target.
    ///
    /// ## Discussion
    ///
    /// The notification object is the instance of `NSMenu` containing the chosen menu item. The `userInfo` dictionary contains the following information.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "@\"MenuItem\"" }] }], [Paragraph { inline_content: [Text { text: "The menu item that was chosen." }] }]]], alignments: None, metadata: None })
    ///
    pub static NSMenuWillSendActionNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted just after the application dispatches a menu item’s action method to the menu item’s target.
    ///
    /// ## Discussion
    ///
    /// The notification object is the instance of `NSMenu` containing the chosen menu item. The `userInfo` dictionary contains the following information.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "@\"MenuItem\"" }] }], [Paragraph { inline_content: [Text { text: "The menu item that was chosen." }] }]]], alignments: None, metadata: None })
    ///
    pub static NSMenuDidSendActionNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted after a menu item is added to the menu.
    ///
    /// ## Discussion
    ///
    /// The notification object is the instance of `NSMenu` that just added the new menu item. The `userInfo` dictionary contains the following information.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "@\"NSMenuItemIndex\"" }] }], [Paragraph { inline_content: [Text { text: "An " }, CodeVoice { code: "NSNumber" }, Text { text: " object containing the integer index of the menu item that was added." }] }]]], alignments: None, metadata: None })
    ///
    pub static NSMenuDidAddItemNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted after a menu item is removed from the menu.
    ///
    /// ## Discussion
    ///
    /// The notification object is the instance of `NSMenu` that just removed the menu item. The `userInfo` dictionary contains the following information.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "@\"NSMenuItemIndex\"" }] }], [Paragraph { inline_content: [Text { text: "An " }, CodeVoice { code: "NSNumber" }, Text { text: " object containing the integer index of the menu item that was removed. Note that this index may no longer be valid and in any event no longer points to the menu item that was removed." }] }]]], alignments: None, metadata: None })
    ///
    pub static NSMenuDidRemoveItemNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted after a menu item in the menu changes appearance.
    ///
    /// ## Discussion
    ///
    /// Changes include enabling/disabling, changes in state, and changes to title. The notification object is the instance of `NSMenu` with the menu item that changed. The `userInfo` dictionary contains the following information.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "@\"NSMenuItemIndex\"" }] }], [Paragraph { inline_content: [Text { text: "An " }, CodeVoice { code: "NSNumber" }, Text { text: " object containing the integer index of the menu item that changed." }] }]]], alignments: None, metadata: None })
    ///
    pub static NSMenuDidChangeItemNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted when menu tracking begins.
    ///
    /// ## Discussion
    ///
    /// The notification object is the main menu bar (`[NSApp mainMenu]`) or the root menu of a popup button. This notification does not contain a `userInfo` dictionary.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This notification is available in versions 10.3 and 10.4 of macOS, however it is not publicly declared so you must declare the name constant as an `extern`, for example:
    ///
    /// ```objc
    /// extern NSString *NSMenuDidBeginTrackingNotification;
    /// ```
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSMenuDidBeginTrackingNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted when menu tracking ends, even if no action is sent.
    ///
    /// ## Discussion
    ///
    /// The notification object is the main menu bar (`[NSApp mainMenu]`) or the root menu of a popup button. This notification does not contain a `userInfo` dictionary.
    ///
    ///
    pub static NSMenuDidEndTrackingNotification: &'static NSNotificationName;
}

/// NSDeprecated.
impl NSMenu {
    extern_methods!(
        /// # Safety
        ///
        /// - `menu_rep` should be of the correct type.
        /// - `menu_rep` might not allow `None`.
        #[deprecated]
        #[unsafe(method(setMenuRepresentation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMenuRepresentation(&self, menu_rep: Option<&AnyObject>);

        #[deprecated]
        #[unsafe(method(menuRepresentation))]
        #[unsafe(method_family = none)]
        pub fn menuRepresentation(&self) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// - `menu_rep` should be of the correct type.
        /// - `menu_rep` might not allow `None`.
        #[deprecated]
        #[unsafe(method(setContextMenuRepresentation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContextMenuRepresentation(&self, menu_rep: Option<&AnyObject>);

        #[deprecated]
        #[unsafe(method(contextMenuRepresentation))]
        #[unsafe(method_family = none)]
        pub fn contextMenuRepresentation(&self) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// - `menu_rep` should be of the correct type.
        /// - `menu_rep` might not allow `None`.
        #[deprecated]
        #[unsafe(method(setTearOffMenuRepresentation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTearOffMenuRepresentation(&self, menu_rep: Option<&AnyObject>);

        #[deprecated]
        #[unsafe(method(tearOffMenuRepresentation))]
        #[unsafe(method_family = none)]
        pub fn tearOffMenuRepresentation(&self) -> Option<Retained<AnyObject>>;

        #[deprecated]
        #[unsafe(method(menuZone))]
        #[unsafe(method_family = none)]
        pub fn menuZone(mtm: MainThreadMarker) -> *mut NSZone;

        /// # Safety
        ///
        /// `zone` must be a valid pointer.
        #[deprecated]
        #[unsafe(method(setMenuZone:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMenuZone(zone: *mut NSZone, mtm: MainThreadMarker);

        #[deprecated]
        #[unsafe(method(attachedMenu))]
        #[unsafe(method_family = none)]
        pub fn attachedMenu(&self) -> Option<Retained<NSMenu>>;

        #[deprecated]
        #[unsafe(method(isAttached))]
        #[unsafe(method_family = none)]
        pub fn isAttached(&self) -> bool;

        #[deprecated]
        #[unsafe(method(sizeToFit))]
        #[unsafe(method_family = none)]
        pub fn sizeToFit(&self);

        /// # Safety
        ///
        /// `submenu` might not allow `None`.
        #[deprecated]
        #[unsafe(method(locationForSubmenu:))]
        #[unsafe(method_family = none)]
        pub unsafe fn locationForSubmenu(&self, submenu: Option<&NSMenu>) -> NSPoint;

        #[deprecated]
        #[unsafe(method(menuChangedMessagesEnabled))]
        #[unsafe(method_family = none)]
        pub fn menuChangedMessagesEnabled(&self) -> bool;

        /// Setter for [`menuChangedMessagesEnabled`][Self::menuChangedMessagesEnabled].
        #[deprecated]
        #[unsafe(method(setMenuChangedMessagesEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setMenuChangedMessagesEnabled(&self, menu_changed_messages_enabled: bool);

        #[cfg(feature = "NSEvent")]
        #[deprecated]
        #[unsafe(method(helpRequested:))]
        #[unsafe(method_family = none)]
        pub fn helpRequested(&self, event_ptr: &NSEvent);

        #[deprecated]
        #[unsafe(method(isTornOff))]
        #[unsafe(method_family = none)]
        pub fn isTornOff(&self) -> bool;
    );
}
