//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// The supported pasteboard types.
// NS_TYPED_EXTENSIBLE_ENUM
pub type NSPasteboardType = NSString;

extern "C" {
    /// String data.
    ///
    /// ## Discussion
    ///
    /// Apps that adopt App Sandbox cannot access files identified using the [`NSPasteboardTypeString`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/string) pasteboard type. Instead, use an [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) object, a bookmark, or a filename pasteboard type.
    ///
    ///
    pub static NSPasteboardTypeString: &'static NSPasteboardType;
}

extern "C" {
    /// PDF data.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`NSPasteboardTypePDF`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/pdf) instead.
    ///
    ///
    pub static NSPasteboardTypePDF: &'static NSPasteboardType;
}

extern "C" {
    /// Tag Image File Format (TIFF) data.
    pub static NSPasteboardTypeTIFF: &'static NSPasteboardType;
}

extern "C" {
    /// PNG image data.
    pub static NSPasteboardTypePNG: &'static NSPasteboardType;
}

extern "C" {
    /// Rich Text Format (RTF) data.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`NSPasteboardTypeRTF`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/rtf) instead.
    ///
    ///
    pub static NSPasteboardTypeRTF: &'static NSPasteboardType;
}

extern "C" {
    /// RTFD formatted file contents.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`NSPasteboardTypeRTFD`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/rtfd) instead.
    ///
    ///
    pub static NSPasteboardTypeRTFD: &'static NSPasteboardType;
}

extern "C" {
    /// Type for HTML content.
    ///
    /// ## Discussion
    ///
    /// An `NSTextView` object can read HTML data, but not write it.
    ///
    /// In macOS 10.6 and later, use [`NSPasteboardTypeHTML`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/html) instead.
    ///
    ///
    pub static NSPasteboardTypeHTML: &'static NSPasteboardType;
}

extern "C" {
    /// Tab-separated fields of text.
    pub static NSPasteboardTypeTabularText: &'static NSPasteboardType;
}

extern "C" {
    /// Font and character information.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`NSPasteboardTypeFont`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/font) instead.
    ///
    ///
    pub static NSPasteboardTypeFont: &'static NSPasteboardType;
}

extern "C" {
    /// Paragraph formatting information.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`NSPasteboardTypeRuler`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/ruler) instead.
    ///
    ///
    pub static NSPasteboardTypeRuler: &'static NSPasteboardType;
}

extern "C" {
    /// Color data.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`NSPasteboardTypeColor`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/color) (and you read and write colors directly to and from the pasteboard).
    ///
    ///
    pub static NSPasteboardTypeColor: &'static NSPasteboardType;
}

extern "C" {
    /// Sound data.
    pub static NSPasteboardTypeSound: &'static NSPasteboardType;
}

extern "C" {
    /// Multiple text selection.
    pub static NSPasteboardTypeMultipleTextSelection: &'static NSPasteboardType;
}

extern "C" {
    /// Type for the Find panel metadata property list.
    pub static NSPasteboardTypeTextFinderOptions: &'static NSPasteboardType;
}

extern "C" {
    /// URL data for one file or resource.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`writeObjects:`](https://developer.apple.com/documentation/appkit/nspasteboard/writeobjects(_:)) to write URLs directly to the pasteboard instead.
    ///
    /// In macOS 10.5 and earlier, write an URL to a pasteboard using the [`writeToPasteboard:`](https://developer.apple.com/documentation/foundation/nsurl/write(to:)) method of [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl). To get an URL from a pasteboard, use the [`URLFromPasteboard:`](https://developer.apple.com/documentation/foundation/nsurl/init(frompasteboard:)) method of [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl).
    ///
    ///
    pub static NSPasteboardTypeURL: &'static NSPasteboardType;
}

extern "C" {
    /// A file URL.
    pub static NSPasteboardTypeFileURL: &'static NSPasteboardType;
}

/// Constants that represent the standard pasteboard names.
// NS_TYPED_EXTENSIBLE_ENUM
pub type NSPasteboardName = NSString;

extern "C" {
    /// The pasteboard you use to perform ordinary cut, copy, and paste operations.
    pub static NSPasteboardNameGeneral: &'static NSPasteboardName;
}

extern "C" {
    /// The pasteboard that holds font and character information and supports Copy Font and Paste Font commands that the text editor may implement.
    pub static NSPasteboardNameFont: &'static NSPasteboardName;
}

extern "C" {
    /// The pasteboard that holds information about paragraph formats and supports the Copy Ruler and Paste Ruler commands that the text editor may implement.
    pub static NSPasteboardNameRuler: &'static NSPasteboardName;
}

extern "C" {
    /// The pasteboard that holds information about the current state of the active application’s find panel.
    pub static NSPasteboardNameFind: &'static NSPasteboardName;
}

extern "C" {
    /// The pasteboard that stores data to move as the result of a drag operation.
    pub static NSPasteboardNameDrag: &'static NSPasteboardName;
}

/// A value indicating pasteboard access behavior.
/// A value indicating pasteboard access behavior.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSPasteboardAccessBehavior(pub NSInteger);
impl NSPasteboardAccessBehavior {
    /// The default behavior for the General pasteboard is to ask upon programmatic access. All other pasteboards default to always allow access. If an app has never triggered a pasteboard access alert, its General pasteboard will report `.default` behavior. Such an app is not shown in the corresponding System Settings pane. Once programmatic pasteboard access triggers the first pasteboard access alert, the state automatically changes to `.ask`. At this point the app starts being shown in System Settings, where the user can toggle the behavior between `.ask`, `.alwaysAllow`, and `.alwaysDeny`.
    /// The default behavior for the General pasteboard is to ask upon programmatic access. All other pasteboards default to always allow access.
    /// If an app has never triggered a pasteboard access alert, its General pasteboard will report `.default` behavior. Such an app is not shown in the corresponding System Settings pane.
    /// Once programmatic pasteboard access triggers the first pasteboard access alert, the state automatically changes to `.ask`. At this point the app starts being shown in System Settings, where the user can toggle the behavior between `.ask`, `.alwaysAllow`, and `.alwaysDeny`.
    #[doc(alias = "NSPasteboardAccessBehaviorDefault")]
    pub const Default: Self = Self(0);
    /// The system will notify the user and ask for permission before granting pasteboard access. However, access that is both user originated and paste related will always be allowed, and will not result in a notification. The app is listed in the corresponding System Settings pane.
    /// The system will notify the user and ask for permission before granting pasteboard access. However, access that is both user originated and paste related will always be allowed, and will not result in a notification. The app is listed in the corresponding System Settings pane.
    #[doc(alias = "NSPasteboardAccessBehaviorAsk")]
    pub const Ask: Self = Self(1);
    /// The system will automatically allow all pasteboard access, without notifying the user.  The app is listed in the corresponding System Settings pane.
    /// The system will automatically allow all pasteboard access, without notifying the user.  The app is listed in the corresponding System Settings pane.
    #[doc(alias = "NSPasteboardAccessBehaviorAlwaysAllow")]
    pub const AlwaysAllow: Self = Self(2);
    /// The system will automatically deny all pasteboard access, without notifying the user. However, access that is both user originated and paste related will always be allowed, and will not result in a notification. The app is listed in the corresponding System Settings pane.
    /// The system will automatically deny all pasteboard access, without notifying the user. However, access that is both user originated and paste related will always be allowed, and will not result in a notification. The app is listed in the corresponding System Settings pane.
    #[doc(alias = "NSPasteboardAccessBehaviorAlwaysDeny")]
    pub const AlwaysDeny: Self = Self(3);
}

unsafe impl Encode for NSPasteboardAccessBehavior {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSPasteboardAccessBehavior {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A pattern to detect on the pasteboard, such as a URL, text, or a number.
/// A pattern to detect on the pasteboard, such as a URL, text, or a number.
// NS_TYPED_ENUM
pub type NSPasteboardDetectionPattern = NSString;

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that consists of a web URL.
    ///
    /// ## Return Value
    ///
    /// NSString value, suitable for implementing “Paste and Go”
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that consists of a web URL.
    ///
    /// Returns: NSString value, suitable for implementing "Paste and Go"
    pub static NSPasteboardDetectionPatternProbableWebURL: &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string suitable for use as a web search term.
    ///
    /// ## Return Value
    ///
    /// NSString value, suitable for implementing “Paste and Search”
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string suitable for use as a web search term.
    ///
    /// Returns: NSString value, suitable for implementing "Paste and Search"
    pub static NSPasteboardDetectionPatternProbableWebSearch: &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that consists of a numeric value.
    ///
    /// ## Return Value
    ///
    /// NSNumber value
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that consists of a numeric value.
    ///
    /// Returns: NSNumber value
    pub static NSPasteboardDetectionPatternNumber: &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that contains a URL.
    ///
    /// ## Return Value
    ///
    /// Array of DDMatchLink values
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that contains a URL.
    ///
    /// Returns: array of DDMatchLink values
    pub static NSPasteboardDetectionPatternLink: &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that contains a phone number.
    ///
    /// ## Return Value
    ///
    /// Array of DDMatchPhoneNumber values
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that contains a phone number.
    ///
    /// Returns: array of DDMatchPhoneNumber values
    pub static NSPasteboardDetectionPatternPhoneNumber: &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that contains an email address.
    ///
    /// ## Return Value
    ///
    /// Array of DDMatchEmailAddress values
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that contains an email address.
    ///
    /// Returns: array of DDMatchEmailAddress values
    pub static NSPasteboardDetectionPatternEmailAddress: &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that contains a postal address.
    ///
    /// ## Return Value
    ///
    /// Array of DDMatchPostalAddress values
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that contains a postal address.
    ///
    /// Returns: array of DDMatchPostalAddress values
    pub static NSPasteboardDetectionPatternPostalAddress: &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that contains a calendar event.
    ///
    /// ## Return Value
    ///
    /// Array of DDMatchCalendarEvent values
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that contains a calendar event.
    ///
    /// Returns: array of DDMatchCalendarEvent values
    pub static NSPasteboardDetectionPatternCalendarEvent: &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that contains a parcel tracking number and carrier.
    ///
    /// ## Return Value
    ///
    /// Array of DDMatchShipmentTrackingNumber values
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that contains a parcel tracking number and carrier.
    ///
    /// Returns: array of DDMatchShipmentTrackingNumber values
    pub static NSPasteboardDetectionPatternShipmentTrackingNumber:
        &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that contains a flight number.
    ///
    /// ## Return Value
    ///
    /// Array of DDMatchFlightNumber values
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that contains a flight number.
    ///
    /// Returns: array of DDMatchFlightNumber values
    pub static NSPasteboardDetectionPatternFlightNumber: &'static NSPasteboardDetectionPattern;
}

extern "C" {
    /// A pattern that indicates the pasteboard detects a string that contains an amount of money.
    ///
    /// ## Return Value
    ///
    /// Array of DDMatchMoneyAmount values
    ///
    ///
    /// A pattern that indicates the pasteboard detects a string that contains an amount of money.
    ///
    /// Returns: array of DDMatchMoneyAmount values
    pub static NSPasteboardDetectionPatternMoneyAmount: &'static NSPasteboardDetectionPattern;
}

/// A metadata type to detect on the pasteboard.
/// A metadata type to detect on the pasteboard.
// NS_TYPED_ENUM
pub type NSPasteboardMetadataType = NSString;

extern "C" {
    /// A metadata type that returns the content type if the pasteboard detects a reference to a file.
    ///
    /// ## Return Value
    ///
    /// UTType value for the detected content type of the file URL, if a file URL type is present.
    ///
    ///
    /// A metadata type that returns the content type if the pasteboard detects a reference to a file.
    ///
    /// Returns: UTType value for the detected content type of the file URL, if a file URL type is present.
    pub static NSPasteboardMetadataTypeContentType: &'static NSPasteboardMetadataType;
}

/// Options for preparing the pasteboard.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSPasteboardContentsOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSPasteboardContentsOptions: NSUInteger {
/// The pasteboard contents are available only on the current device, and not on any other devices.
        #[doc(alias = "NSPasteboardContentsCurrentHostOnly")]
        const CurrentHostOnly = 1<<0;
    }
}

unsafe impl Encode for NSPasteboardContentsOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSPasteboardContentsOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Options for reading pasteboard data.
///
/// ## Discussion
///
/// These options can be used for both the [`readObjectsForClasses:options:`](https://developer.apple.com/documentation/appkit/nspasteboard/readobjects(forclasses:options:)) and [`canReadObjectForClasses:options:`](https://developer.apple.com/documentation/appkit/nspasteboard/canreadobject(forclasses:options:)) methods, unless otherwise specified.  The currently available options allow for customization of how URLS are read from the pasteboard.
///
///
// NS_TYPED_ENUM
pub type NSPasteboardReadingOptionKey = NSString;

extern "C" {
    /// Option for reading URLs to restrict the results to file URLs only.
    ///
    /// ## Discussion
    ///
    /// The value for this key is an `NSNumber` object with a boolean value.
    ///
    ///
    pub static NSPasteboardURLReadingFileURLsOnlyKey: &'static NSPasteboardReadingOptionKey;
}

extern "C" {
    /// Option for reading URLs to restrict the results to URLs with contents that conform to any of the provided UTI types.
    ///
    /// ## Discussion
    ///
    /// If the content type of a URL cannot be determined, it will not be considered to match.  The value for this key is an array of UTI type strings.
    ///
    ///
    pub static NSPasteboardURLReadingContentsConformToTypesKey:
        &'static NSPasteboardReadingOptionKey;
}

extern_class!(
    /// An object that transfers data to and from the pasteboard server.
    ///
    /// ## Overview
    ///
    /// The pasteboard server is shared by all running apps. It contains data that the user has cut or copied, as well as other data that one application wants to transfer to another. [`NSPasteboard`](https://developer.apple.com/documentation/appkit/nspasteboard) objects are an application’s sole interface to the server and to all pasteboard operations.
    ///
    /// An [`NSPasteboard`](https://developer.apple.com/documentation/appkit/nspasteboard) object is also used to transfer data between apps and service providers listed in each application’s Services menu. The drag pasteboard is used to transfer data that is being dragged by the user.
    ///
    /// A pasteboard can contain multiple items. You can directly write or read any object that implements the [`NSPasteboardWriting`](https://developer.apple.com/documentation/appkit/nspasteboardwriting) or [`NSPasteboardReading`](https://developer.apple.com/documentation/appkit/nspasteboardreading) [Protocol](https://developer.apple.com/library/archive/documentation/General/Conceptual/DevPedia-CocoaCore/Protocol.html#//apple_ref/doc/uid/TP40008195-CH45) respectively. This allows you to write and read common items such as URLs, colors, images, strings, attributed strings, and sounds without an intermediary object. Your custom classes can also implement these protocols for use with the pasteboard.
    ///
    /// Writing methods such as [`setData:forType:`](https://developer.apple.com/documentation/appkit/nspasteboard/setdata(_:fortype:)) provide a convenient means of writing to the first pasteboard item, without having to create the first pasteboard item. You can use code like this, for example:
    ///
    /// ```objc
    /// [pboard clearContents];
    /// [pboard setData:data forType:type];
    /// ```
    ///
    /// The general pasteboard, available by way of the [`generalPasteboard`](https://developer.apple.com/documentation/appkit/nspasteboard/general) class method, automatically participates with the Universal Clipboard feature in macOS 10.12 and later and in iOS 10.0 and later. There is no macOS API for interacting with this feature.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSPasteboard;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSPasteboard {}
);

impl NSPasteboard {
    extern_methods!(
        #[unsafe(method(generalPasteboard))]
        #[unsafe(method_family = none)]
        pub fn generalPasteboard() -> Retained<NSPasteboard>;

        #[unsafe(method(pasteboardWithName:))]
        #[unsafe(method_family = none)]
        pub fn pasteboardWithName(name: &NSPasteboardName) -> Retained<NSPasteboard>;

        #[unsafe(method(pasteboardWithUniqueName))]
        #[unsafe(method_family = none)]
        pub fn pasteboardWithUniqueName() -> Retained<NSPasteboard>;

        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub fn name(&self) -> Retained<NSPasteboardName>;

        #[unsafe(method(changeCount))]
        #[unsafe(method_family = none)]
        pub fn changeCount(&self) -> NSInteger;

        /// The current pasteboard access behavior. The user can customize this behavior per-app in System Settings for any app that has triggered a pasteboard access alert in the past.
        #[unsafe(method(accessBehavior))]
        #[unsafe(method_family = none)]
        pub fn accessBehavior(&self) -> NSPasteboardAccessBehavior;

        #[unsafe(method(prepareForNewContentsWithOptions:))]
        #[unsafe(method_family = none)]
        pub fn prepareForNewContentsWithOptions(
            &self,
            options: NSPasteboardContentsOptions,
        ) -> NSInteger;

        #[unsafe(method(clearContents))]
        #[unsafe(method_family = none)]
        pub fn clearContents(&self) -> NSInteger;

        #[unsafe(method(writeObjects:))]
        #[unsafe(method_family = none)]
        pub fn writeObjects(
            &self,
            objects: &NSArray<ProtocolObject<dyn NSPasteboardWriting>>,
        ) -> bool;

        /// # Safety
        ///
        /// - `class_array` generic probably has further requirements.
        /// - `options` generic should be of the correct type.
        #[unsafe(method(readObjectsForClasses:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readObjectsForClasses_options(
            &self,
            class_array: &NSArray<AnyClass>,
            options: Option<&NSDictionary<NSPasteboardReadingOptionKey, AnyObject>>,
        ) -> Option<Retained<NSArray>>;

        #[cfg(feature = "NSPasteboardItem")]
        #[unsafe(method(pasteboardItems))]
        #[unsafe(method_family = none)]
        pub fn pasteboardItems(&self) -> Option<Retained<NSArray<NSPasteboardItem>>>;

        #[cfg(feature = "NSPasteboardItem")]
        #[unsafe(method(indexOfPasteboardItem:))]
        #[unsafe(method_family = none)]
        pub fn indexOfPasteboardItem(&self, pasteboard_item: &NSPasteboardItem) -> NSUInteger;

        #[unsafe(method(canReadItemWithDataConformingToTypes:))]
        #[unsafe(method_family = none)]
        pub fn canReadItemWithDataConformingToTypes(&self, types: &NSArray<NSString>) -> bool;

        /// # Safety
        ///
        /// - `class_array` generic probably has further requirements.
        /// - `options` generic should be of the correct type.
        #[unsafe(method(canReadObjectForClasses:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canReadObjectForClasses_options(
            &self,
            class_array: &NSArray<AnyClass>,
            options: Option<&NSDictionary<NSPasteboardReadingOptionKey, AnyObject>>,
        ) -> bool;

        /// # Safety
        ///
        /// `new_owner` should be of the correct type.
        #[unsafe(method(declareTypes:owner:))]
        #[unsafe(method_family = none)]
        pub unsafe fn declareTypes_owner(
            &self,
            new_types: &NSArray<NSPasteboardType>,
            new_owner: Option<&AnyObject>,
        ) -> NSInteger;

        /// # Safety
        ///
        /// `new_owner` should be of the correct type.
        #[unsafe(method(addTypes:owner:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTypes_owner(
            &self,
            new_types: &NSArray<NSPasteboardType>,
            new_owner: Option<&AnyObject>,
        ) -> NSInteger;

        #[unsafe(method(types))]
        #[unsafe(method_family = none)]
        pub fn types(&self) -> Option<Retained<NSArray<NSPasteboardType>>>;

        #[unsafe(method(availableTypeFromArray:))]
        #[unsafe(method_family = none)]
        pub fn availableTypeFromArray(
            &self,
            types: &NSArray<NSPasteboardType>,
        ) -> Option<Retained<NSPasteboardType>>;

        #[unsafe(method(setData:forType:))]
        #[unsafe(method_family = none)]
        pub fn setData_forType(&self, data: Option<&NSData>, data_type: &NSPasteboardType) -> bool;

        /// # Safety
        ///
        /// `plist` should be of the correct type.
        #[unsafe(method(setPropertyList:forType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPropertyList_forType(
            &self,
            plist: &AnyObject,
            data_type: &NSPasteboardType,
        ) -> bool;

        #[unsafe(method(setString:forType:))]
        #[unsafe(method_family = none)]
        pub fn setString_forType(&self, string: &NSString, data_type: &NSPasteboardType) -> bool;

        #[unsafe(method(dataForType:))]
        #[unsafe(method_family = none)]
        pub fn dataForType(&self, data_type: &NSPasteboardType) -> Option<Retained<NSData>>;

        #[unsafe(method(propertyListForType:))]
        #[unsafe(method_family = none)]
        pub fn propertyListForType(
            &self,
            data_type: &NSPasteboardType,
        ) -> Option<Retained<AnyObject>>;

        #[unsafe(method(stringForType:))]
        #[unsafe(method_family = none)]
        pub fn stringForType(&self, data_type: &NSPasteboardType) -> Option<Retained<NSString>>;

        #[cfg(feature = "block2")]
        /// Determines whether the first pasteboard item matches the specified patterns, without notifying the person using the app.
        ///
        /// This method only gives an indication of whether the first pasteboard item matches a particular pattern, and doesn’t allow the app to access the item's contents. As a result, the system doesn’t notify the person using the app about reading the contents of the pasteboard.
        ///
        /// The following example shows how to use this method to find email and postal addresses in the first pasteboard item:
        ///
        /// ```obj-c
        /// [NSPasteboard.generalPasteboard
        /// detectPatternsForPatterns:[NSSet setWithArray:
        /// @
        /// [NSPasteboardDetectionPatternEmailAddress,
        /// NSPasteboardDetectionPatternPostalAddress]]
        /// completionHandler:^(NSSet
        /// <NSPasteboardDetectionPattern
        /// > *matchedPatterns, NSError *error) {
        /// if (error) {
        /// NSLog(
        /// "
        /// Error: %
        /// "
        /// , error);
        /// return;
        /// }
        /// BOOL matchedEmail = [matchedPatterns containsObject:NSPasteboardDetectionPatternEmailAddress];
        /// BOOL matchedPostal = [matchedPatterns containsObject: NSPasteboardDetectionPatternPostalAddress];
        /// if (matchedEmail) {
        /// NSLog(
        /// "
        /// Email address(es) detected");
        /// }
        /// if (matchedPostal) {
        /// NSLog(
        /// "
        /// Postal address(es) detected");
        /// }
        /// if (!matchedEmail
        /// &
        /// &
        /// !matchedPostal) {
        /// NSLog(
        /// "
        /// Matched neither email nor postal addresses.");
        /// }
        /// }];
        /// ```
        ///
        /// - Parameters:
        /// - patterns: The patterns to detect on the pasteboard.
        /// - completionHandler: A block the system invokes after detecting patterns on the pasteboard. The block receives either a set with the patterns the system finds on the pasteboard or an error if detection fails.
        #[unsafe(method(detectPatternsForPatterns:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn detectPatternsForPatterns_completionHandler(
            &self,
            patterns: &NSSet<NSPasteboardDetectionPattern>,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSSet<NSPasteboardDetectionPattern>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Determines whether the first pasteboard item matches the specified patterns, reading the contents if it finds a match.
        ///
        /// For details about the types returned for each pattern, see ``NSPasteboardDetectionPattern``.
        ///
        /// The following example shows how to use this method to find web URLs and web search terms in the first pasteboard item:
        ///
        /// ```obj-c
        /// [NSPasteboard.generalPasteboard
        /// detectValuesForPatterns:[NSSet setWithArray:
        /// @
        /// [NSPasteboardDetectionPatternProbableWebSearch,
        /// NSPasteboardDetectionPatternProbableWebURL]]
        /// completionHandler:^(NSDictionary
        /// <NSPasteboardDetectionPattern
        /// , id> *patternValues, NSError *error) {
        /// if (error) {
        /// NSLog(
        /// "
        /// Error: %
        /// "
        /// , error);
        /// return;
        /// }
        /// NSString *searchString = (NSString*)patternValues[NSPasteboardDetectionPatternProbableWebSearch];
        /// NSString *urlString = (NSString*)patternValues[NSPasteboardDetectionPatternProbableWebURL] ;
        /// if (searchString != nil) {
        /// NSLog(
        /// "
        /// Web search retrieved: %
        /// "
        /// , searchString);
        /// }
        /// if (urlString != nil) {
        /// NSLog(
        /// "
        /// Web URL retrieved: %
        /// "
        /// , urlString);
        /// }
        /// if (searchString == nil
        /// &
        /// &
        /// urlString == nil) {
        /// NSLog(
        /// "
        /// No web patterns retrieved.");
        /// }
        /// }];
        /// ```
        ///
        /// > Important: If the system finds a match when calling this method, the system informs the person using the app that the app is trying to read the contents of the pasteboard. If the person denies access to the pasteboard, the completion handler receives an error.
        ///
        /// - Parameters:
        /// - patterns: The patterns to detect on the pasteboard.
        /// - completionHandler: A block the system invokes after detecting patterns on the pasteboard. The block returns either a dictionary with the patterns the system finds on the pasteboard or an error if detection fails. The dictionary keys specify the matched patterns and the values specify the corresponding content of the pasteboard.
        #[unsafe(method(detectValuesForPatterns:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn detectValuesForPatterns_completionHandler(
            &self,
            patterns: &NSSet<NSPasteboardDetectionPattern>,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSDictionary<NSPasteboardDetectionPattern, AnyObject>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Determines available metadata from the specified metadata types for the first pasteboard item, without notifying the person using the app.
        ///
        /// This method only gives access to limited types of metadata and doesn’t allow the app to access the contents. As a result, the system doesn’t notify the person using the app about reading the contents of the pasteboard.
        ///
        /// For details about the metadata returned for each type, see ``NSPasteboardMetadataType``.
        ///
        /// The following example shows how to use this method to find the content type of a file reference in the first item on the pasteboard:
        ///
        /// ```obj-c
        /// [NSPasteboard.generalPasteboard
        /// detectMetadataForTypes:[NSSet setWithArray:
        /// @
        /// [NSPasteboardMetadataTypeContentType]]
        /// completionHandler:^(NSDictionary
        /// <NSPasteboardMetadataType
        /// , id> *metadata, NSError *error) {
        /// if (error) {
        /// NSLog(
        /// "
        /// Error: %
        /// "
        /// , error);
        /// return;
        /// }
        /// UTType *contentType = (UTType*)metadata[NSPasteboardMetadataTypeContentType];
        /// if (contentType) {
        /// NSLog(
        /// "
        /// Content type is: %
        /// "
        /// , contentType.identifier);
        /// } else {
        /// NSLog(
        /// "
        /// Couldn't get content type");
        /// }
        /// }];
        /// ```
        ///
        /// - Parameters:
        /// - types: The metadata types to detect on the pasteboard.
        /// - completionHandler: A block the system invokes after detecting metadata on the pasteboard. The block receives either a dictionary with the metadata types the system finds on the pasteboard or an error if detection fails. The dictionary keys specify the matched metadata types and the values specify the corresponding metadata.
        #[unsafe(method(detectMetadataForTypes:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn detectMetadataForTypes_completionHandler(
            &self,
            types: &NSSet<NSPasteboardMetadataType>,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSDictionary<NSPasteboardMetadataType, AnyObject>, *mut NSError),
            >,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSPasteboard {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSPasteboard {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// FilterServices.
impl NSPasteboard {
    extern_methods!(
        #[unsafe(method(typesFilterableTo:))]
        #[unsafe(method_family = none)]
        pub fn typesFilterableTo(r#type: &NSPasteboardType) -> Retained<NSArray<NSPasteboardType>>;

        #[unsafe(method(pasteboardByFilteringFile:))]
        #[unsafe(method_family = none)]
        pub fn pasteboardByFilteringFile(filename: &NSString) -> Retained<NSPasteboard>;

        #[unsafe(method(pasteboardByFilteringData:ofType:))]
        #[unsafe(method_family = none)]
        pub fn pasteboardByFilteringData_ofType(
            data: &NSData,
            r#type: &NSPasteboardType,
        ) -> Retained<NSPasteboard>;

        #[unsafe(method(pasteboardByFilteringTypesInPasteboard:))]
        #[unsafe(method_family = none)]
        pub fn pasteboardByFilteringTypesInPasteboard(
            pboard: &NSPasteboard,
        ) -> Retained<NSPasteboard>;
    );
}

extern_protocol!(
    /// An object that serves as a data provider for data types that use lazy data fulfillment from a pasteboard request.
    pub unsafe trait NSPasteboardTypeOwner: NSObjectProtocol {
        #[unsafe(method(pasteboard:provideDataForType:))]
        #[unsafe(method_family = none)]
        fn pasteboard_provideDataForType(&self, sender: &NSPasteboard, r#type: &NSPasteboardType);

        #[optional]
        #[unsafe(method(pasteboardChangedOwner:))]
        #[unsafe(method_family = none)]
        fn pasteboardChangedOwner(&self, sender: &NSPasteboard);
    }
);

/// Type to specify options for writing to a pasteboard.
///
/// ## Overview
///
/// For possible values, see [Pasteboard Writing Options](https://developer.apple.com/documentation/appkit/pasteboard-writing-options).
///
///
/// * NSPasteboardWriting and NSPasteboardReading Protocols **
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSPasteboardWritingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSPasteboardWritingOptions: NSUInteger {
/// Data for a type with this option is promised, not immediately written.
        #[doc(alias = "NSPasteboardWritingPromised")]
        const Promised = 1<<9;
    }
}

unsafe impl Encode for NSPasteboardWritingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSPasteboardWritingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A set of methods that defines the interface for retrieving a representation of an object that can be written to a pasteboard.
    ///
    /// ## Overview
    ///
    /// The Cocoa framework classes [`NSString`](https://developer.apple.com/documentation/foundation/nsstring), [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring), [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl), [`NSColor`](https://developer.apple.com/documentation/appkit/nscolor), [`NSSound`](https://developer.apple.com/documentation/appkit/nssound), [`NSImage`](https://developer.apple.com/documentation/appkit/nsimage), and [`NSPasteboardItem`](https://developer.apple.com/documentation/appkit/nspasteboarditem) implement this protocol. You can make your custom class conform to this protocol so that you can write instances of the class to a pasteboard using the [`writeObjects:`](https://developer.apple.com/documentation/appkit/nspasteboard/writeobjects(_:)) method of [`NSPasteboard`](https://developer.apple.com/documentation/appkit/nspasteboard).
    ///
    ///
    pub unsafe trait NSPasteboardWriting: NSObjectProtocol {
        #[unsafe(method(writableTypesForPasteboard:))]
        #[unsafe(method_family = none)]
        fn writableTypesForPasteboard(
            &self,
            pasteboard: &NSPasteboard,
        ) -> Retained<NSArray<NSPasteboardType>>;

        #[optional]
        #[unsafe(method(writingOptionsForType:pasteboard:))]
        #[unsafe(method_family = none)]
        fn writingOptionsForType_pasteboard(
            &self,
            r#type: &NSPasteboardType,
            pasteboard: &NSPasteboard,
        ) -> NSPasteboardWritingOptions;

        #[unsafe(method(pasteboardPropertyListForType:))]
        #[unsafe(method_family = none)]
        fn pasteboardPropertyListForType(
            &self,
            r#type: &NSPasteboardType,
        ) -> Option<Retained<AnyObject>>;
    }
);

/// Options that specify how to interpret data on the pasteboard when initializing pasteboard data.
///
/// ## Overview
///
/// You can specify only one option. If you don’t specify an option, the system uses the default [`NSPasteboardReadingAsData`](https://developer.apple.com/documentation/appkit/nspasteboard/readingoptions/asdata).
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSPasteboardReadingOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSPasteboardReadingOptions: NSUInteger {
/// An option to read data from the pasteboard as-is and return it as a data object.
///
/// ## Discussion
///
/// This is the default value. AppKit returns the data in an [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) object.
///
///
        #[doc(alias = "NSPasteboardReadingAsData")]
        const AsData = 0;
/// An option to read data from the pasteboard and convert it to a string object.
///
/// ## Discussion
///
/// AppKit puts the data in an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) object.
///
///
        #[doc(alias = "NSPasteboardReadingAsString")]
        const AsString = 1<<0;
/// An option to read data from the pasteboard and unserialize it as a property list.
        #[doc(alias = "NSPasteboardReadingAsPropertyList")]
        const AsPropertyList = 1<<1;
/// An option to read data from the pasteboard and use it to initialize the object.
///
/// ## Discussion
///
/// AppKit initializes the object using its [`initWithCoder:`](https://developer.apple.com/documentation/foundation/nscoding/init(coder:)) method.
///
///
        #[doc(alias = "NSPasteboardReadingAsKeyedArchive")]
        const AsKeyedArchive = 1<<2;
    }
}

unsafe impl Encode for NSPasteboardReadingOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSPasteboardReadingOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A set of methods that defines the interface for initializing an object from a pasteboard.
    ///
    /// ## Overview
    ///
    /// The Cocoa framework classes [`NSString`](https://developer.apple.com/documentation/foundation/nsstring), [`NSAttributedString`](https://developer.apple.com/documentation/foundation/nsattributedstring), [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl), [`NSColor`](https://developer.apple.com/documentation/appkit/nscolor), [`NSSound`](https://developer.apple.com/documentation/appkit/nssound), [`NSImage`](https://developer.apple.com/documentation/appkit/nsimage), and [`NSPasteboardItem`](https://developer.apple.com/documentation/appkit/nspasteboarditem) implement this protocol. You can make your custom class conform to this protocol so that you can read instances from a pasteboard using the [`readObjectsForClasses:options:`](https://developer.apple.com/documentation/appkit/nspasteboard/readobjects(forclasses:options:)) method of [`NSPasteboard`](https://developer.apple.com/documentation/appkit/nspasteboard).
    ///
    ///
    pub unsafe trait NSPasteboardReading: NSObjectProtocol {
        #[unsafe(method(readableTypesForPasteboard:))]
        #[unsafe(method_family = none)]
        fn readableTypesForPasteboard(
            pasteboard: &NSPasteboard,
        ) -> Retained<NSArray<NSPasteboardType>>;

        #[optional]
        #[unsafe(method(readingOptionsForType:pasteboard:))]
        #[unsafe(method_family = none)]
        fn readingOptionsForType_pasteboard(
            r#type: &NSPasteboardType,
            pasteboard: &NSPasteboard,
        ) -> NSPasteboardReadingOptions;

        /// # Safety
        ///
        /// `property_list` should be of the correct type.
        #[optional]
        #[unsafe(method(initWithPasteboardPropertyList:ofType:))]
        #[unsafe(method_family = init)]
        unsafe fn initWithPasteboardPropertyList_ofType(
            this: Allocated<Self>,
            property_list: &AnyObject,
            r#type: &NSPasteboardType,
        ) -> Option<Retained<Self>>;
    }
);

mod private_NSURLNSPasteboardSupport {
    pub trait Sealed {}
}

/// Category "NSPasteboardSupport" on [`NSURL`].
#[doc(alias = "NSPasteboardSupport")]
pub unsafe trait NSURLNSPasteboardSupport:
    ClassType + Sized + private_NSURLNSPasteboardSupport::Sealed
{
    extern_methods!(
        #[unsafe(method(URLFromPasteboard:))]
        #[unsafe(method_family = none)]
        fn URLFromPasteboard(paste_board: &NSPasteboard) -> Option<Retained<NSURL>>;

        #[unsafe(method(writeToPasteboard:))]
        #[unsafe(method_family = none)]
        fn writeToPasteboard(&self, paste_board: &NSPasteboard);
    );
}

impl private_NSURLNSPasteboardSupport::Sealed for NSURL {}
unsafe impl NSURLNSPasteboardSupport for NSURL {}

extern_conformance!(
    unsafe impl NSPasteboardReading for NSURL {}
);

extern_conformance!(
    unsafe impl NSPasteboardWriting for NSURL {}
);

extern_conformance!(
    unsafe impl NSPasteboardReading for NSString {}
);

extern_conformance!(
    unsafe impl NSPasteboardWriting for NSString {}
);

/// NSFileContents.
///
/// * File Contents **
impl NSPasteboard {
    extern_methods!(
        #[unsafe(method(writeFileContents:))]
        #[unsafe(method_family = none)]
        pub fn writeFileContents(&self, filename: &NSString) -> bool;

        #[unsafe(method(readFileContentsType:toFile:))]
        #[unsafe(method_family = none)]
        pub fn readFileContentsType_toFile(
            &self,
            r#type: Option<&NSPasteboardType>,
            filename: &NSString,
        ) -> Option<Retained<NSString>>;

        #[unsafe(method(writeFileWrapper:))]
        #[unsafe(method_family = none)]
        pub fn writeFileWrapper(&self, wrapper: &NSFileWrapper) -> bool;

        #[unsafe(method(readFileWrapper))]
        #[unsafe(method_family = none)]
        pub fn readFileWrapper(&self) -> Option<Retained<NSFileWrapper>>;
    );
}

extern "C" {
    /// A representation of a file’s contents.
    ///
    /// ## Discussion
    ///
    /// The file contents pboard type allowed you to synthesize a pboard type for a file’s contents based on the file’s extension.
    ///
    /// In macOS 10.6 and later, you should use the UTI of a file to represent its contents instead.
    ///
    ///
    pub static NSFileContentsPboardType: &'static NSPasteboardType;
}

/// Returns a pasteboard type based on the passed file type.
///
/// ## Discussion
///
/// Returns an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) to a pasteboard type representing a filename based on the supplied string `fileType`.
///
///
#[inline]
pub extern "C-unwind" fn NSCreateFilenamePboardType(
    file_type: &NSString,
) -> Option<Retained<NSPasteboardType>> {
    extern "C-unwind" {
        fn NSCreateFilenamePboardType(file_type: &NSString) -> *mut NSPasteboardType;
    }
    let ret = unsafe { NSCreateFilenamePboardType(file_type) };
    unsafe { Retained::from_raw(ret) }
}

/// Returns a pasteboard type based on the passed file type.
///
/// ## Discussion
///
/// Returns an [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) to a pasteboard type representing a file’s contents based on the supplied string `fileType`. `fileType` should generally be the extension part of a filename. The conversion from a named file type to a pasteboard type is simple; no mapping to standard pasteboard types is attempted.
///
///
#[inline]
pub extern "C-unwind" fn NSCreateFileContentsPboardType(
    file_type: &NSString,
) -> Option<Retained<NSPasteboardType>> {
    extern "C-unwind" {
        fn NSCreateFileContentsPboardType(file_type: &NSString) -> *mut NSPasteboardType;
    }
    let ret = unsafe { NSCreateFileContentsPboardType(file_type) };
    unsafe { Retained::from_raw(ret) }
}

/// A file type based on the passed pasteboard type.
///
/// ## Discussion
///
/// This function is the inverse of both [`NSCreateFileContentsPboardType`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/filecontentstype(forpathextension:)) and [`NSCreateFilenamePboardType`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/filenametype(forpathextension:)). When passed a pasteboard type as returned by those functions, it returns the extension or filename from which the type was derived. It returns `nil` if `pboardType` isn’t a pasteboard type created by those functions.
///
///
#[inline]
pub extern "C-unwind" fn NSGetFileType(
    pboard_type: &NSPasteboardType,
) -> Option<Retained<NSString>> {
    extern "C-unwind" {
        fn NSGetFileType(pboard_type: &NSPasteboardType) -> *mut NSString;
    }
    let ret = unsafe { NSGetFileType(pboard_type) };
    unsafe { Retained::retain_autoreleased(ret) }
}

/// Returns an array of file types based on the passed pasteboard types.
///
/// ## Discussion
///
/// Accepts a null-terminated array of pointers to pasteboard types and returns a null-terminated array of the unique extensions and filenames from the file content and filename types found in the input array. It returns `nil` if the input array contains no file content or filename types. The returned array is allocated and must be freed by the caller. The pointers in the return array point into strings passed in the input array.
///
///
#[inline]
pub extern "C-unwind" fn NSGetFileTypes(
    pboard_types: &NSArray<NSPasteboardType>,
) -> Option<Retained<NSArray<NSString>>> {
    extern "C-unwind" {
        fn NSGetFileTypes(pboard_types: &NSArray<NSPasteboardType>) -> *mut NSArray<NSString>;
    }
    let ret = unsafe { NSGetFileTypes(pboard_types) };
    unsafe { Retained::retain_autoreleased(ret) }
}

extern "C" {
    /// `NSString` data.
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Deprecated
    /// In apps that adopt App Sandbox, use an [`NSURL`](https://developer.apple.com/documentation/foundation/nsurl) object, a bookmark, or a filename pasteboard type instead. In a nonsandboxed app, you can also use the [`string`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/string) pasteboard type.
    ///
    ///
    ///
    /// </div>
    ///
    /// * Deprecated **
    #[deprecated]
    pub static NSStringPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// An array of `NSString` objects designating one or more filenames.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`writeObjects(_:)`](https://developer.apple.com/documentation/appkit/nspasteboard/writeobjects(_:)) to write file URLs to the pasteboard.
    ///
    ///
    #[deprecated = "Create multiple pasteboard items with NSPasteboardTypeFileURL or kUTTypeFileURL instead"]
    pub static NSFilenamesPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// `NSString` data.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`tiff`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/tiff) instead.
    ///
    ///
    #[deprecated]
    pub static NSTIFFPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// Rich Text Format (RTF) data.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`rtf`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/rtf) instead.
    ///
    ///
    #[deprecated]
    pub static NSRTFPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// An `NSString` object containing tab-separated fields of text.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`tabularText`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/tabulartext) instead.
    ///
    ///
    #[deprecated]
    pub static NSTabularTextPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// Font and character information.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`font`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/font) instead.
    ///
    ///
    #[deprecated]
    pub static NSFontPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// Paragraph formatting information.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`ruler`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/ruler) instead.
    ///
    ///
    #[deprecated]
    pub static NSRulerPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// `NSColor` data.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`color`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/color) (and you read and write colors directly to and from the pasteboard).
    ///
    ///
    #[deprecated]
    pub static NSColorPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// RTFD formatted file contents.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`rtfd`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/rtfd) instead.
    ///
    ///
    #[deprecated]
    pub static NSRTFDPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// HTML (which an `NSTextView` object can read from, but not write to).
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`html`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/html) instead.
    ///
    ///
    #[deprecated]
    pub static NSHTMLPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// `NSURL` data for one file or resource.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`writeObjects(_:)`](https://developer.apple.com/documentation/appkit/nspasteboard/writeobjects(_:)) to write URLs directly to the pasteboard instead.
    ///
    /// In OS X v10.5 and earlier: to write an URL to a pasteboard you use [`write(to:)`](https://developer.apple.com/documentation/foundation/nsurl/write(to:)) ([`NSURL`](https://developer.apple.com/documentation/foundation/nsurl)); to get an URL from a pasteboard you use [`init(fromPasteboard:)`](https://developer.apple.com/documentation/foundation/nsurl/init(frompasteboard:)) ([`NSURL`](https://developer.apple.com/documentation/foundation/nsurl)).
    ///
    ///
    #[deprecated]
    pub static NSURLPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// PDF data.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`pdf`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/pdf) instead.
    ///
    ///
    #[deprecated]
    pub static NSPDFPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// Multiple text selection.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use [`multipleTextSelection`](https://developer.apple.com/documentation/appkit/nspasteboard/pasteboardtype/multipletextselection) instead.
    ///
    ///
    #[deprecated]
    pub static NSMultipleTextSelectionPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// Encapsulated PostScript (EPS) code.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use `@"com.adobe.encapsulated-postscript"` instead.
    ///
    ///
    #[deprecated]
    pub static NSPostScriptPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// VCard data.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use `(NSString *)kUTTypeVCard` instead.
    ///
    ///
    #[deprecated]
    pub static NSVCardPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// Ink text data.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use `(NSString *)kUTTypeInkText` instead.
    ///
    /// For information on ink text objects, see Using Ink Services in Your Application.
    ///
    ///
    #[deprecated]
    pub static NSInkTextPboardType: &'static NSPasteboardType;
}

extern "C" {
    /// Promised files.
    ///
    /// ## Discussion
    ///
    /// In macOS 10.6 and later, use `(NSString *)kPasteboardTypeFileURLPromise` instead.
    ///
    /// For information on promised files, see [Dragging Files](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DragandDrop/Tasks/DraggingFiles.html#//apple_ref/doc/uid/20001288) in [Drag and Drop Programming Topics](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DragandDrop/DragandDrop.html#//apple_ref/doc/uid/10000069i).
    ///
    ///
    #[deprecated]
    pub static NSFilesPromisePboardType: &'static NSPasteboardType;
}

extern "C" {
    /// Type for the Find panel metadata property list.
    #[deprecated]
    pub static NSPasteboardTypeFindPanelSearchOptions: &'static NSPasteboardType;
}

extern "C" {
    /// The pasteboard used for ordinary cut, copy, and paste operations.
    ///
    /// ## Discussion
    ///
    /// This pasteboard holds the contents of the last selection that’s been cut or copied.
    ///
    ///
    #[deprecated]
    pub static NSGeneralPboard: &'static NSPasteboardName;
}

extern "C" {
    /// The pasteboard that holds font and character information and supports Copy Font and Paste Font commands that may be implemented in a text editor.
    #[deprecated]
    pub static NSFontPboard: &'static NSPasteboardName;
}

extern "C" {
    /// The pasteboard that holds information about paragraph formats and supports the Copy Ruler and Paste Ruler commands implemented in a text editor.
    #[deprecated]
    pub static NSRulerPboard: &'static NSPasteboardName;
}

extern "C" {
    /// The pasteboard that holds information about the current state of the active application’s find panel.
    ///
    /// ## Discussion
    ///
    /// This information permits users to enter a search string into the find panel, then switch to another application to conduct another search.
    ///
    ///
    #[deprecated]
    pub static NSFindPboard: &'static NSPasteboardName;
}

extern "C" {
    /// The pasteboard that stores data to be moved as the result of a drag operation.
    ///
    /// ## Discussion
    ///
    /// For additional information on working with the drag pasteboard, see [Drag and Drop Programming Topics](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/DragandDrop/DragandDrop.html#//apple_ref/doc/uid/10000069i).
    ///
    ///
    #[deprecated]
    pub static NSDragPboard: &'static NSPasteboardName;
}

extern "C" {
    /// QuickDraw picture data.
    ///
    /// ## Discussion
    ///
    /// The PICT format was formally deprecated in OS X v10.4 along with QuickDraw. You should not be explicitly providing or looking for PICT data on the pasteboard.
    ///
    /// To aid in this deprecation, if PICT is the only image type on the pasteboard, as is sometimes the case when copying images from 32-bit Carbon applications, a translated image type will be automatically reported and provided by `NSPasteboard`. The translated type is added to the types array ahead of PICT so that the deprecated PICT format is not the preferred format. In addition, when an application provides image data to `NSPasteboard`, the Carbon Pasteboard Manager will automatically make a PICT translation available to 32-bit Carbon applications.
    ///
    /// Although `NSPICTPboardType`, and its UTI equivalent `kUTTypePICT`, will appear in a pasteboard’s type array retrieved from the existing `NSPasteboard` API, it may cease to be reported in future releases.
    ///
    ///
    #[deprecated]
    pub static NSPICTPboardType: &'static NSPasteboardType;
}
