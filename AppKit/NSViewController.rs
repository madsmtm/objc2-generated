//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Animation options for view transitions in a view controller.
///
/// ## Overview
///
/// The up and down slide animation options are disjoint and you cannot combine them.
///
/// Likewise, the left and right slide animation options are disjoint and you cannot combine them.
///
/// User interaction with transitioning views is prevented for all animation options except the [`NSViewControllerTransitionAllowUserInteraction`](https://developer.apple.com/documentation/appkit/nsviewcontroller/transitionoptions/allowuserinteraction) option.
///
///
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSViewControllerTransitionOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSViewControllerTransitionOptions: NSUInteger {
/// A transition with no animation (the default). Specifying another animation option from this enumeration overrides this option.
        #[doc(alias = "NSViewControllerTransitionNone")]
        const None = 0x0;
/// A transition animation that fades the new view in and simultaneously fades the old view out. You can combine this animation option with any of the “slide” options in this enumeration.
        #[doc(alias = "NSViewControllerTransitionCrossfade")]
        const Crossfade = 0x1;
/// A transition animation that slides the old view up while the new view comes into view from the bottom.  In other words, both views slide up.
        #[doc(alias = "NSViewControllerTransitionSlideUp")]
        const SlideUp = 0x10;
/// A transition animation that slides the old view down while the new view slides into view from the top. In other words, both views slide down.
        #[doc(alias = "NSViewControllerTransitionSlideDown")]
        const SlideDown = 0x20;
/// A transition animation that slides the old view to the left while the new view slides into view from the right. In other words, both views slide to the left.
        #[doc(alias = "NSViewControllerTransitionSlideLeft")]
        const SlideLeft = 0x40;
/// A transition animation that slides the old view to the right while the new view slides into view from the left.  In other words, both views slide to the right.
        #[doc(alias = "NSViewControllerTransitionSlideRight")]
        const SlideRight = 0x80;
/// A transition animation that reflects the user interface layout direction ([`userInterfaceLayoutDirection`](https://developer.apple.com/documentation/appkit/nsapplication/userinterfacelayoutdirection)) in a “forward” manner, as follows:
///
/// ## Discussion
///
/// - For left-to-right user interface layout direction, the [`NSViewControllerTransitionSlideLeft`](https://developer.apple.com/documentation/appkit/nsviewcontroller/transitionoptions/slideleft) animation option.
///
/// - For right-to-left user interface layout direction, the [`NSViewControllerTransitionSlideRight`](https://developer.apple.com/documentation/appkit/nsviewcontroller/transitionoptions/slideright) animation option.
///
///
        #[doc(alias = "NSViewControllerTransitionSlideForward")]
        const SlideForward = 0x140;
/// A transition animation that reflects the user interface layout direction ([`userInterfaceLayoutDirection`](https://developer.apple.com/documentation/appkit/nsapplication/userinterfacelayoutdirection)) in a “backward” manner, as follows
///
/// ## Discussion
///
/// - For left-to-right user interface layout direction, the [`NSViewControllerTransitionSlideRight`](https://developer.apple.com/documentation/appkit/nsviewcontroller/transitionoptions/slideright) animation option.
///
/// - For right-to-left user interface layout direction, the [`NSViewControllerTransitionSlideLeft`](https://developer.apple.com/documentation/appkit/nsviewcontroller/transitionoptions/slideleft) animation option.
///
///
        #[doc(alias = "NSViewControllerTransitionSlideBackward")]
        const SlideBackward = 0x180;
/// A transition animation that allows user interaction during the transition.
        #[doc(alias = "NSViewControllerTransitionAllowUserInteraction")]
        const AllowUserInteraction = 0x1000;
    }
}

unsafe impl Encode for NSViewControllerTransitionOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSViewControllerTransitionOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A controller that manages a view, typically loaded from a nib file.
    ///
    /// ## Overview
    ///
    /// View controller management includes:
    ///
    /// - Memory management of top-level objects similar to that performed by the [`NSWindowController`](https://developer.apple.com/documentation/appkit/nswindowcontroller) class, taking the same care to prevent reference cycles when controls are bound to the nib file’s owner.
    ///
    /// - Declaring a generic [`view`](https://developer.apple.com/documentation/appkit/nsviewcontroller/view) property, to make it easy to establish bindings in the nib to an object that isn’t yet known at nib-loading time or readily available to the code that’s doing the nib loading.
    ///
    /// - Implementing the key-value binding NSEditor informal protocol, so that apps using a view controller can easily make bound controls in the views commit or discard changes by the user.
    ///
    /// In macOS 10.10 and later, a view controller offers a full set of life cycle methods, allowing you to manage the content of a window in a way that is on a par with iOS view controller management. These methods, presented in order here to reflect a typical cycle, are:
    ///
    /// _View life cycle:_
    ///
    /// 1. [`viewDidLoad`](https://developer.apple.com/documentation/appkit/nsviewcontroller/viewdidload())
    ///
    /// 2. [`viewWillAppear`](https://developer.apple.com/documentation/appkit/nsviewcontroller/viewwillappear())
    ///
    /// 3. [`viewDidAppear`](https://developer.apple.com/documentation/appkit/nsviewcontroller/viewdidappear())
    ///
    /// _User interaction cycle:_
    ///
    /// 1. [`updateViewConstraints`](https://developer.apple.com/documentation/appkit/nsviewcontroller/updateviewconstraints())
    ///
    /// 2. [`viewWillLayout`](https://developer.apple.com/documentation/appkit/nsviewcontroller/viewwilllayout())
    ///
    /// 3. [`viewDidLayout`](https://developer.apple.com/documentation/appkit/nsviewcontroller/viewdidlayout())
    ///
    /// 4. [`viewWillDisappear`](https://developer.apple.com/documentation/appkit/nsviewcontroller/viewwilldisappear())
    ///
    /// 5. [`viewDidDisappear`](https://developer.apple.com/documentation/appkit/nsviewcontroller/viewdiddisappear())
    ///
    /// In addition, in macOS 10.10 and later, a view controller participates in the responder chain. You can implement action methods directly in the view controller. Corresponding actions that originate in the view controller’s view proceed up the responder chain and are handled by those methods.
    ///
    /// Prior to OS X v10.10, a typical usage pattern for loading a nib file was to subclass [`NSViewController`](https://developer.apple.com/documentation/appkit/nsviewcontroller) and override its [`loadView`](https://developer.apple.com/documentation/appkit/nsviewcontroller/loadview()) method to call `[super loadView]`. But in macOS 10.10 and later, the [`loadView`](https://developer.apple.com/documentation/appkit/nsviewcontroller/loadview()) method automatically looks for a nib file with the same name as the view controller. To take advantage of this behavior, name a nib file after its corresponding view controller and pass `nil` to both parameters of the [`initWithNibName:bundle:`](https://developer.apple.com/documentation/appkit/nsviewcontroller/init(nibname:bundle:)) method.
    ///
    /// A view controller employs lazy loading of its view: Immediately after a view controller is loaded into memory, the value of its [`viewLoaded`](https://developer.apple.com/documentation/appkit/nsviewcontroller/isviewloaded) property is [`false`](https://developer.apple.com/documentation/swift/false). The value changes to [`true`](https://developer.apple.com/documentation/swift/true) after the [`loadView`](https://developer.apple.com/documentation/appkit/nsviewcontroller/loadview()) method returns and just before the system calls the [`viewDidLoad`](https://developer.apple.com/documentation/appkit/nsviewcontroller/viewdidload()) method.
    ///
    /// A view controller is meant to be highly reusable, such as for dynamically representing various objects. For example, the  [`addAccessoryController:`](https://developer.apple.com/documentation/appkit/nspagelayout/addaccessorycontroller(_:)) methods of the [`NSPageLayout`](https://developer.apple.com/documentation/appkit/nspagelayout) and [`NSPrintPanel`](https://developer.apple.com/documentation/appkit/nsprintpanel) classes take an [`NSViewController`](https://developer.apple.com/documentation/appkit/nsviewcontroller) instance as the argument, and set the [`representedObject`](https://developer.apple.com/documentation/appkit/nsviewcontroller/representedobject) property to the [`NSPrintInfo`](https://developer.apple.com/documentation/appkit/nsprintinfo) object that is to be shown to the user. This allows a developer to easily create new printing accessory views using bindings and the [`NSPrintInfo`](https://developer.apple.com/documentation/appkit/nsprintinfo) class’s key-value coding and key-value observing compliance. When the user dismisses a printing dialog, the  [`NSPageLayout`](https://developer.apple.com/documentation/appkit/nspagelayout) and [`NSPrintPanel`](https://developer.apple.com/documentation/appkit/nsprintpanel) classes each send NSEditor messages to each accessory view controller to ensure that the user’s changes have been committed or discarded properly. The titles of the accessories are retrieved from the view controllers and shown to the user in menus that the user can choose from.
    ///
    ///
    #[unsafe(super(NSResponder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSResponder")]
    pub struct NSViewController;
);

#[cfg(feature = "NSResponder")]
extern_conformance!(
    unsafe impl NSCoding for NSViewController {}
);

#[cfg(all(feature = "NSKeyValueBinding", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSEditor for NSViewController {}
);

#[cfg(feature = "NSResponder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSViewController {}
);

#[cfg(all(feature = "NSResponder", feature = "NSStoryboardSegue"))]
extern_conformance!(
    unsafe impl NSSeguePerforming for NSViewController {}
);

#[cfg(all(feature = "NSResponder", feature = "NSUserInterfaceItemIdentification"))]
extern_conformance!(
    unsafe impl NSUserInterfaceItemIdentification for NSViewController {}
);

#[cfg(feature = "NSResponder")]
impl NSViewController {
    extern_methods!(
        #[cfg(feature = "NSNib")]
        #[unsafe(method(initWithNibName:bundle:))]
        #[unsafe(method_family = init)]
        pub fn initWithNibName_bundle(
            this: Allocated<Self>,
            nib_name_or_nil: Option<&NSNibName>,
            nib_bundle_or_nil: Option<&NSBundle>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSNib")]
        #[unsafe(method(nibName))]
        #[unsafe(method_family = none)]
        pub fn nibName(&self) -> Option<Retained<NSNibName>>;

        #[unsafe(method(nibBundle))]
        #[unsafe(method_family = none)]
        pub fn nibBundle(&self) -> Option<Retained<NSBundle>>;

        #[unsafe(method(representedObject))]
        #[unsafe(method_family = none)]
        pub fn representedObject(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`representedObject`][Self::representedObject].
        ///
        /// # Safety
        ///
        /// `represented_object` should be of the correct type.
        #[unsafe(method(setRepresentedObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRepresentedObject(&self, represented_object: Option<&AnyObject>);

        #[unsafe(method(title))]
        #[unsafe(method_family = none)]
        pub fn title(&self) -> Option<Retained<NSString>>;

        /// Setter for [`title`][Self::title].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTitle:))]
        #[unsafe(method_family = none)]
        pub fn setTitle(&self, title: Option<&NSString>);

        #[cfg(feature = "NSView")]
        #[unsafe(method(view))]
        #[unsafe(method_family = none)]
        pub fn view(&self) -> Retained<NSView>;

        #[cfg(feature = "NSView")]
        /// Setter for [`view`][Self::view].
        #[unsafe(method(setView:))]
        #[unsafe(method_family = none)]
        pub fn setView(&self, view: &NSView);

        #[cfg(feature = "NSView")]
        #[unsafe(method(viewIfLoaded))]
        #[unsafe(method_family = none)]
        pub fn viewIfLoaded(&self) -> Option<Retained<NSView>>;

        #[unsafe(method(loadView))]
        #[unsafe(method_family = none)]
        pub fn loadView(&self);

        #[unsafe(method(loadViewIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn loadViewIfNeeded(&self);

        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_commit_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(commitEditingWithDelegate:didCommitSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn commitEditingWithDelegate_didCommitSelector_contextInfo(
            &self,
            delegate: Option<&AnyObject>,
            did_commit_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[unsafe(method(commitEditing))]
        #[unsafe(method_family = none)]
        pub fn commitEditing(&self) -> bool;

        #[unsafe(method(discardEditing))]
        #[unsafe(method_family = none)]
        pub fn discardEditing(&self);

        #[unsafe(method(viewDidLoad))]
        #[unsafe(method_family = none)]
        pub fn viewDidLoad(&self);

        #[unsafe(method(isViewLoaded))]
        #[unsafe(method_family = none)]
        pub fn isViewLoaded(&self) -> bool;

        #[unsafe(method(viewWillAppear))]
        #[unsafe(method_family = none)]
        pub fn viewWillAppear(&self);

        #[unsafe(method(viewDidAppear))]
        #[unsafe(method_family = none)]
        pub fn viewDidAppear(&self);

        #[unsafe(method(viewWillDisappear))]
        #[unsafe(method_family = none)]
        pub fn viewWillDisappear(&self);

        #[unsafe(method(viewDidDisappear))]
        #[unsafe(method_family = none)]
        pub fn viewDidDisappear(&self);

        #[unsafe(method(preferredContentSize))]
        #[unsafe(method_family = none)]
        pub fn preferredContentSize(&self) -> NSSize;

        /// Setter for [`preferredContentSize`][Self::preferredContentSize].
        #[unsafe(method(setPreferredContentSize:))]
        #[unsafe(method_family = none)]
        pub fn setPreferredContentSize(&self, preferred_content_size: NSSize);

        #[unsafe(method(updateViewConstraints))]
        #[unsafe(method_family = none)]
        pub fn updateViewConstraints(&self);

        #[unsafe(method(viewWillLayout))]
        #[unsafe(method_family = none)]
        pub fn viewWillLayout(&self);

        #[unsafe(method(viewDidLayout))]
        #[unsafe(method_family = none)]
        pub fn viewDidLayout(&self);
    );
}

/// Methods declared on superclass `NSResponder`.
#[cfg(feature = "NSResponder")]
impl NSViewController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSResponder")]
impl NSViewController {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// NSViewControllerPresentation.
#[cfg(feature = "NSResponder")]
impl NSViewController {
    extern_methods!(
        #[unsafe(method(presentViewController:animator:))]
        #[unsafe(method_family = none)]
        pub fn presentViewController_animator(
            &self,
            view_controller: &NSViewController,
            animator: &ProtocolObject<dyn NSViewControllerPresentationAnimator>,
        );

        #[unsafe(method(dismissViewController:))]
        #[unsafe(method_family = none)]
        pub fn dismissViewController(&self, view_controller: &NSViewController);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(dismissController:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissController(&self, sender: Option<&AnyObject>);

        #[unsafe(method(presentedViewControllers))]
        #[unsafe(method_family = none)]
        pub fn presentedViewControllers(&self) -> Option<Retained<NSArray<NSViewController>>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(presentingViewController))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentingViewController(&self) -> Option<Retained<NSViewController>>;
    );
}

/// NSViewControllerPresentationAndTransitionStyles.
#[cfg(feature = "NSResponder")]
impl NSViewController {
    extern_methods!(
        #[unsafe(method(presentViewControllerAsSheet:))]
        #[unsafe(method_family = none)]
        pub fn presentViewControllerAsSheet(&self, view_controller: &NSViewController);

        #[unsafe(method(presentViewControllerAsModalWindow:))]
        #[unsafe(method_family = none)]
        pub fn presentViewControllerAsModalWindow(&self, view_controller: &NSViewController);

        #[cfg(all(feature = "NSPopover", feature = "NSView"))]
        #[unsafe(method(presentViewController:asPopoverRelativeToRect:ofView:preferredEdge:behavior:))]
        #[unsafe(method_family = none)]
        pub fn presentViewController_asPopoverRelativeToRect_ofView_preferredEdge_behavior(
            &self,
            view_controller: &NSViewController,
            positioning_rect: NSRect,
            positioning_view: &NSView,
            preferred_edge: NSRectEdge,
            behavior: NSPopoverBehavior,
        );

        #[cfg(all(feature = "NSPopover", feature = "NSView"))]
        #[unsafe(method(presentViewController:asPopoverRelativeToRect:ofView:preferredEdge:behavior:hasFullSizeContent:))]
        #[unsafe(method_family = none)]
        pub fn presentViewController_asPopoverRelativeToRect_ofView_preferredEdge_behavior_hasFullSizeContent(
            &self,
            view_controller: &NSViewController,
            positioning_rect: NSRect,
            positioning_view: &NSView,
            preferred_edge: NSRectEdge,
            behavior: NSPopoverBehavior,
            has_full_size_content: bool,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(transitionFromViewController:toViewController:options:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn transitionFromViewController_toViewController_options_completionHandler(
            &self,
            from_view_controller: &NSViewController,
            to_view_controller: &NSViewController,
            options: NSViewControllerTransitionOptions,
            completion: Option<&block2::DynBlock<dyn Fn()>>,
        );
    );
}

/// NSViewControllerContainer.
#[cfg(feature = "NSResponder")]
impl NSViewController {
    extern_methods!(
        #[unsafe(method(parentViewController))]
        #[unsafe(method_family = none)]
        pub fn parentViewController(&self) -> Option<Retained<NSViewController>>;

        #[unsafe(method(childViewControllers))]
        #[unsafe(method_family = none)]
        pub fn childViewControllers(&self) -> Retained<NSArray<NSViewController>>;

        /// Setter for [`childViewControllers`][Self::childViewControllers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setChildViewControllers:))]
        #[unsafe(method_family = none)]
        pub fn setChildViewControllers(&self, child_view_controllers: &NSArray<NSViewController>);

        #[unsafe(method(addChildViewController:))]
        #[unsafe(method_family = none)]
        pub fn addChildViewController(&self, child_view_controller: &NSViewController);

        #[unsafe(method(removeFromParentViewController))]
        #[unsafe(method_family = none)]
        pub fn removeFromParentViewController(&self);

        #[unsafe(method(insertChildViewController:atIndex:))]
        #[unsafe(method_family = none)]
        pub fn insertChildViewController_atIndex(
            &self,
            child_view_controller: &NSViewController,
            index: NSInteger,
        );

        #[unsafe(method(removeChildViewControllerAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn removeChildViewControllerAtIndex(&self, index: NSInteger);

        #[unsafe(method(preferredContentSizeDidChangeForViewController:))]
        #[unsafe(method_family = none)]
        pub fn preferredContentSizeDidChangeForViewController(
            &self,
            view_controller: &NSViewController,
        );

        #[unsafe(method(viewWillTransitionToSize:))]
        #[unsafe(method_family = none)]
        pub fn viewWillTransitionToSize(&self, new_size: NSSize);
    );
}

extern_protocol!(
    /// A set of methods that let you define animations to play when transitioning between two view controllers.
    ///
    /// ## Overview
    ///
    /// Implement this protocol only if you want to provide custom animations. You might find what you need in the [`NSViewControllerTransitionOptions`](https://developer.apple.com/documentation/appkit/nsviewcontroller/transitionoptions) enumeration, which provides many predefined animations.
    ///
    /// A class that adopts this protocol is responsible for both presenting and dismissing a view controller.
    ///
    ///
    pub unsafe trait NSViewControllerPresentationAnimator:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(feature = "NSResponder")]
        #[unsafe(method(animatePresentationOfViewController:fromViewController:))]
        #[unsafe(method_family = none)]
        fn animatePresentationOfViewController_fromViewController(
            &self,
            view_controller: &NSViewController,
            from_view_controller: &NSViewController,
        );

        #[cfg(feature = "NSResponder")]
        #[unsafe(method(animateDismissalOfViewController:fromViewController:))]
        #[unsafe(method_family = none)]
        fn animateDismissalOfViewController_fromViewController(
            &self,
            view_controller: &NSViewController,
            from_view_controller: &NSViewController,
        );
    }
);

/// NSViewControllerStoryboardingMethods.
#[cfg(feature = "NSResponder")]
impl NSViewController {
    extern_methods!(
        #[cfg(feature = "NSStoryboard")]
        #[unsafe(method(storyboard))]
        #[unsafe(method_family = none)]
        pub fn storyboard(&self) -> Option<Retained<NSStoryboard>>;
    );
}

/// NSExtensionAdditions.
#[cfg(feature = "NSResponder")]
impl NSViewController {
    extern_methods!(
        #[unsafe(method(extensionContext))]
        #[unsafe(method_family = none)]
        pub fn extensionContext(&self) -> Option<Retained<NSExtensionContext>>;

        #[cfg(feature = "NSView")]
        #[unsafe(method(sourceItemView))]
        #[unsafe(method_family = none)]
        pub fn sourceItemView(&self) -> Option<Retained<NSView>>;

        #[cfg(feature = "NSView")]
        /// Setter for [`sourceItemView`][Self::sourceItemView].
        #[unsafe(method(setSourceItemView:))]
        #[unsafe(method_family = none)]
        pub fn setSourceItemView(&self, source_item_view: Option<&NSView>);

        #[unsafe(method(preferredScreenOrigin))]
        #[unsafe(method_family = none)]
        pub fn preferredScreenOrigin(&self) -> NSPoint;

        /// Setter for [`preferredScreenOrigin`][Self::preferredScreenOrigin].
        #[unsafe(method(setPreferredScreenOrigin:))]
        #[unsafe(method_family = none)]
        pub fn setPreferredScreenOrigin(&self, preferred_screen_origin: NSPoint);

        #[unsafe(method(preferredMinimumSize))]
        #[unsafe(method_family = none)]
        pub fn preferredMinimumSize(&self) -> NSSize;

        #[unsafe(method(preferredMaximumSize))]
        #[unsafe(method_family = none)]
        pub fn preferredMaximumSize(&self) -> NSSize;
    );
}

#[cfg(feature = "NSResponder")]
extern_conformance!(
    unsafe impl NSExtensionRequestHandling for NSViewController {}
);
