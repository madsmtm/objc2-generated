//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSDirectionalRectEdge(pub NSUInteger);
bitflags::bitflags! {
    impl NSDirectionalRectEdge: NSUInteger {
        #[doc(alias = "NSDirectionalRectEdgeNone")]
        const None = 0;
        #[doc(alias = "NSDirectionalRectEdgeTop")]
        const Top = 1<<0;
        #[doc(alias = "NSDirectionalRectEdgeLeading")]
        const Leading = 1<<1;
        #[doc(alias = "NSDirectionalRectEdgeBottom")]
        const Bottom = 1<<2;
        #[doc(alias = "NSDirectionalRectEdgeTrailing")]
        const Trailing = 1<<3;
        #[doc(alias = "NSDirectionalRectEdgeAll")]
        const All = NSDirectionalRectEdge::Top.0|NSDirectionalRectEdge::Leading.0|NSDirectionalRectEdge::Bottom.0|NSDirectionalRectEdge::Trailing.0;
    }
}

unsafe impl Encode for NSDirectionalRectEdge {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSDirectionalRectEdge {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The inset distances for views, taking the user interface layout direction into account.
#[cfg(feature = "objc2-core-foundation")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct NSDirectionalEdgeInsets {
    pub top: CGFloat,
    pub leading: CGFloat,
    pub bottom: CGFloat,
    pub trailing: CGFloat,
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Encode for NSDirectionalEdgeInsets {
    const ENCODING: Encoding = Encoding::Struct(
        "NSDirectionalEdgeInsets",
        &[
            <CGFloat>::ENCODING,
            <CGFloat>::ENCODING,
            <CGFloat>::ENCODING,
            <CGFloat>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl RefEncode for NSDirectionalEdgeInsets {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Send for NSDirectionalEdgeInsets {}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl Sync for NSDirectionalEdgeInsets {}

extern "C" {
    /// A directional edge insets structure whose top, leading, bottom, and trailing fields all have a value of `0`.
    #[cfg(feature = "objc2-core-foundation")]
    pub static NSDirectionalEdgeInsetsZero: NSDirectionalEdgeInsets;
}

/// Constants that specify alignment to an edge or a set of edges depending on the user interface layout direction.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSRectAlignment(pub NSInteger);
impl NSRectAlignment {
    /// Has no specified alignment.
    #[doc(alias = "NSRectAlignmentNone")]
    pub const None: Self = Self(0);
    /// Aligns to the top edge.
    #[doc(alias = "NSRectAlignmentTop")]
    pub const Top: Self = Self(1);
    /// Aligns to the top and leading edges.
    #[doc(alias = "NSRectAlignmentTopLeading")]
    pub const TopLeading: Self = Self(2);
    /// Aligns to the leading edge.
    #[doc(alias = "NSRectAlignmentLeading")]
    pub const Leading: Self = Self(3);
    /// Aligns to the bottom and leading edges.
    #[doc(alias = "NSRectAlignmentBottomLeading")]
    pub const BottomLeading: Self = Self(4);
    /// Aligns to the bottom edge.
    #[doc(alias = "NSRectAlignmentBottom")]
    pub const Bottom: Self = Self(5);
    /// Aligns to the bottom and trailing edges.
    #[doc(alias = "NSRectAlignmentBottomTrailing")]
    pub const BottomTrailing: Self = Self(6);
    /// Aligns to the trailing edge.
    #[doc(alias = "NSRectAlignmentTrailing")]
    pub const Trailing: Self = Self(7);
    /// Aligns to the top and trailing edges.
    #[doc(alias = "NSRectAlignmentTopTrailing")]
    pub const TopTrailing: Self = Self(8);
}

unsafe impl Encode for NSRectAlignment {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSRectAlignment {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "objc2-core-foundation")]
impl NSDirectionalEdgeInsets {
    // TODO: pub fn NSDirectionalEdgeInsetsMake(top: CGFloat,leading: CGFloat,bottom: CGFloat,trailing: CGFloat,) -> NSDirectionalEdgeInsets;
}

extern_class!(
    /// An object that defines scroll direction, section spacing, and headers or footers for the layout.
    ///
    /// ## Overview
    ///
    /// You use a layout configuration to modify a collection view layout’s default scroll direction, add extra spacing between each section of the layout, and add headers or footers to the entire layout.
    ///
    /// You can pass in this configuration when creating an [`NSCollectionViewCompositionalLayout`](https://developer.apple.com/documentation/appkit/nscollectionviewcompositionallayout), or you can set the [`configuration`](https://developer.apple.com/documentation/appkit/nscollectionviewcompositionallayout/configuration) property on an existing layout. If you modify the configuration on an existing layout, the system invalidates the layout so that it will be updated with the new configuration.
    ///
    /// ```swift
    /// let headerFooterSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),
    ///                                              heightDimension: .estimated(44))
    ///
    /// let header = NSCollectionLayoutBoundarySupplementaryItem(layoutSize: headerFooterSize,
    ///                                                         elementKind: "header",
    ///                                                           alignment: .top)
    /// let footer = NSCollectionLayoutBoundarySupplementaryItem(layoutSize: headerFooterSize,
    ///                                                         elementKind: "footer",
    ///                                                           alignment: .bottom)
    ///
    /// let config = NSCollectionViewCompositionalLayoutConfiguration()
    /// config.interSectionSpacing = 20
    /// config.scrollDirection = .horizontal
    /// config.boundarySupplementaryItems = [header, footer]
    /// ```
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionViewCompositionalLayoutConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionViewCompositionalLayoutConfiguration {}
);

unsafe impl CopyingHelper for NSCollectionViewCompositionalLayoutConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionViewCompositionalLayoutConfiguration {}
);

impl NSCollectionViewCompositionalLayoutConfiguration {
    extern_methods!(
        #[cfg(feature = "NSCollectionViewFlowLayout")]
        #[unsafe(method(scrollDirection))]
        #[unsafe(method_family = none)]
        pub fn scrollDirection(&self) -> NSCollectionViewScrollDirection;

        #[cfg(feature = "NSCollectionViewFlowLayout")]
        /// Setter for [`scrollDirection`][Self::scrollDirection].
        #[unsafe(method(setScrollDirection:))]
        #[unsafe(method_family = none)]
        pub fn setScrollDirection(&self, scroll_direction: NSCollectionViewScrollDirection);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(interSectionSpacing))]
        #[unsafe(method_family = none)]
        pub fn interSectionSpacing(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`interSectionSpacing`][Self::interSectionSpacing].
        #[unsafe(method(setInterSectionSpacing:))]
        #[unsafe(method_family = none)]
        pub fn setInterSectionSpacing(&self, inter_section_spacing: CGFloat);

        #[unsafe(method(boundarySupplementaryItems))]
        #[unsafe(method_family = none)]
        pub fn boundarySupplementaryItems(
            &self,
        ) -> Retained<NSArray<NSCollectionLayoutBoundarySupplementaryItem>>;

        /// Setter for [`boundarySupplementaryItems`][Self::boundarySupplementaryItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBoundarySupplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn setBoundarySupplementaryItems(
            &self,
            boundary_supplementary_items: &NSArray<NSCollectionLayoutBoundarySupplementaryItem>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NSCollectionViewCompositionalLayoutConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// A closure that creates and returns each of the layout’s sections.
///
/// ## Discussion
///
/// You use a section provider to create a compositional layout ([`NSCollectionViewCompositionalLayout`](https://developer.apple.com/documentation/appkit/nscollectionviewcompositionallayout)) that has multiple sections with different layouts. The section provider keeps track of the index of the section that it’s currently creating, so you can configure each section differently.
///
/// For example, the following code shows a section provider that creates a two-column layout in the first section, and a four-column layout in each section after the first section.
///
/// ```swift
/// func createPerSectionLayout() -> NSCollectionViewLayout {
///     let layout = NSCollectionViewCompositionalLayout { (sectionIndex: Int,
///         layoutEnvironment: NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection? in
///         
///         let columns = sectionIndex == 0 ? 2 : 4
///         
///         let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),
///                                              heightDimension: .fractionalHeight(1.0))
///         let item = NSCollectionLayoutItem(layoutSize: itemSize)
///         
///         let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),
///                                               heightDimension: .absolute(44))
///         let group = NSCollectionLayoutGroup.horizontal(layoutSize: groupSize,
///                                                           subitem: item,
///                                                             count: columns)
///         
///         let section = NSCollectionLayoutSection(group: group)
///         return section
///     }
///     return layout
/// }
/// ```
///
/// A section provider is also invoked in response to system events such as changes in system font size. You can use this opportunity to adapt the layout to different layout environments by inspecting information about the current layout environment ([`NSCollectionLayoutEnvironment`](https://developer.apple.com/documentation/appkit/nscollectionlayoutenvironment)) and using that information to configure each section.
///
/// For example, the following code shows a section provider that creates a two-column layout when the width of the section’s container is less than 800 points, and a four-column layout otherwise.
///
/// ```swift
/// func createAdaptiveLayout() -> NSCollectionViewLayout {
///     let layout = NSCollectionViewCompositionalLayout { (sectionIndex: Int,
///         layoutEnvironment: NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection in
///
///         let columns = layoutEnvironment.container.effectiveContentSize.width < 800 ? 2 : 4
///         
///         let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),
///                                              heightDimension: .fractionalHeight(1.0))
///         let item = NSCollectionLayoutItem(layoutSize: itemSize)
///         
///         let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),
///                                               heightDimension: .absolute(44))
///         let group = NSCollectionLayoutGroup.horizontal(layoutSize: groupSize,
///                                                           subitem: item,
///                                                             count: columns)
///         
///         let section = NSCollectionLayoutSection(group: group)
///         return section
///     }
///     return layout
/// }
/// ```
///
///
#[cfg(feature = "block2")]
pub type NSCollectionViewCompositionalLayoutSectionProvider = *mut block2::DynBlock<
    dyn Fn(
        NSInteger,
        NonNull<ProtocolObject<dyn NSCollectionLayoutEnvironment>>,
    ) -> *mut NSCollectionLayoutSection,
>;

extern_class!(
    /// A layout object that lets you combine items in highly adaptive and flexible visual arrangements.
    ///
    /// ## Overview
    ///
    /// A compositional layout is a type of collection view layout. It’s designed to be composable, flexible, and fast, letting you build any kind of visual arrangement for your content by combining—or compositing—each smaller component into a full layout.
    ///
    /// A compositional layout is composed of one or more sections that break up the layout into distinct visual groupings. Each section is composed of groups of individual items, the smallest unit of data you want to present. A group might lay out its items in a horizontal row, a vertical column, or a custom arrangement.
    ///
    /// You combine the components by building up from items into a group, from groups into a section, and finally into a full layout, like in this example of a basic list layout:
    ///
    /// ```swift
    /// func createBasicListLayout() -> NSCollectionViewLayout {
    ///     let itemSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),
    ///                                          heightDimension: .fractionalHeight(1.0))
    ///     let item = NSCollectionLayoutItem(layoutSize: itemSize)
    ///   
    ///     let groupSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),
    ///                                           heightDimension: .absolute(44))
    ///     let group = NSCollectionLayoutGroup.horizontal(layoutSize: groupSize,
    ///                                                      subitems: [item])
    ///   
    ///     let section = NSCollectionLayoutSection(group: group)
    ///
    ///     let layout = NSCollectionViewCompositionalLayout(section: section)
    ///     return layout
    /// }
    /// ```
    ///
    ///
    #[unsafe(super(NSCollectionViewLayout, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSCollectionViewLayout")]
    pub struct NSCollectionViewCompositionalLayout;
);

#[cfg(feature = "NSCollectionViewLayout")]
extern_conformance!(
    unsafe impl NSCoding for NSCollectionViewCompositionalLayout {}
);

#[cfg(feature = "NSCollectionViewLayout")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionViewCompositionalLayout {}
);

#[cfg(feature = "NSCollectionViewLayout")]
impl NSCollectionViewCompositionalLayout {
    extern_methods!(
        #[unsafe(method(initWithSection:))]
        #[unsafe(method_family = init)]
        pub fn initWithSection(
            this: Allocated<Self>,
            section: &NSCollectionLayoutSection,
        ) -> Retained<Self>;

        #[unsafe(method(initWithSection:configuration:))]
        #[unsafe(method_family = init)]
        pub fn initWithSection_configuration(
            this: Allocated<Self>,
            section: &NSCollectionLayoutSection,
            configuration: &NSCollectionViewCompositionalLayoutConfiguration,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `section_provider` must be a valid pointer.
        #[unsafe(method(initWithSectionProvider:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSectionProvider(
            this: Allocated<Self>,
            section_provider: NSCollectionViewCompositionalLayoutSectionProvider,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `section_provider` must be a valid pointer.
        #[unsafe(method(initWithSectionProvider:configuration:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSectionProvider_configuration(
            this: Allocated<Self>,
            section_provider: NSCollectionViewCompositionalLayoutSectionProvider,
            configuration: &NSCollectionViewCompositionalLayoutConfiguration,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(configuration))]
        #[unsafe(method_family = none)]
        pub fn configuration(&self) -> Retained<NSCollectionViewCompositionalLayoutConfiguration>;

        /// Setter for [`configuration`][Self::configuration].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn setConfiguration(
            &self,
            configuration: &NSCollectionViewCompositionalLayoutConfiguration,
        );
    );
}

/// The scrolling behavior of the layout’s sections in relation to the main layout axis.
///
/// ## Overview
///
/// By default, each section lays out its content along the main axis of its layout, defined by the layout configuration’s [`scrollDirection`](https://developer.apple.com/documentation/appkit/nscollectionviewcompositionallayoutconfiguration/scrolldirection) property. You can change this behavior for a particular section by setting its [`orthogonalScrollingBehavior`](https://developer.apple.com/documentation/appkit/nscollectionlayoutsection/orthogonalscrollingbehavior) property to a different value than its default [`NSCollectionLayoutSectionOrthogonalScrollingBehaviorNone`](https://developer.apple.com/documentation/appkit/nscollectionlayoutsectionorthogonalscrollingbehavior/none). Setting any other value for this property makes the section lay out its content orthogonally to the main layout axis.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSCollectionLayoutSectionOrthogonalScrollingBehavior(pub NSInteger);
impl NSCollectionLayoutSectionOrthogonalScrollingBehavior {
    /// The section does not allow users to scroll its content orthogonally.
    #[doc(alias = "NSCollectionLayoutSectionOrthogonalScrollingBehaviorNone")]
    pub const None: Self = Self(0);
    /// The section allows users to scroll its content orthogonally with continuous scrolling.
    #[doc(alias = "NSCollectionLayoutSectionOrthogonalScrollingBehaviorContinuous")]
    pub const Continuous: Self = Self(1);
    /// The section allows users to scroll its content orthogonally, coming to a natural stop at the leading boundary of the visible group.
    #[doc(
        alias = "NSCollectionLayoutSectionOrthogonalScrollingBehaviorContinuousGroupLeadingBoundary"
    )]
    pub const ContinuousGroupLeadingBoundary: Self = Self(2);
    /// The section allows users to page its content orthogonally.
    #[doc(alias = "NSCollectionLayoutSectionOrthogonalScrollingBehaviorPaging")]
    pub const Paging: Self = Self(3);
    /// The section allows users to page its content orthogonally one group at a time.
    #[doc(alias = "NSCollectionLayoutSectionOrthogonalScrollingBehaviorGroupPaging")]
    pub const GroupPaging: Self = Self(4);
    /// The section allows users to page its content orthogonally one group at a time, centering each group.
    #[doc(alias = "NSCollectionLayoutSectionOrthogonalScrollingBehaviorGroupPagingCentered")]
    pub const GroupPagingCentered: Self = Self(5);
}

unsafe impl Encode for NSCollectionLayoutSectionOrthogonalScrollingBehavior {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSCollectionLayoutSectionOrthogonalScrollingBehavior {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A closure called before each layout cycle to allow modification of items in a section immediately before they’re displayed.
///
/// ## Discussion
///
/// Each section of a collection view layout can have a visible items invalidation handler. You use this handler to perform custom animations on the items currently visible within the bounds of that section. The handler is called before each layout cycle, any time an animation occurs in that section due to changes such as adding or removing items, scrolling the section, or rotating the device.
///
/// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let section = NSCollectionLayoutSection(group: group)", "    ", "section.visibleItemsInvalidationHandler = { visibleItems, scrollOffset, layoutEnvironment in", "    // Perform animations on the visible items.", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSection *section = [NSCollectionLayoutSection sectionWithGroup:group];", "", "[section setVisibleItemsInvalidationHandler:^(NSArray<id<NSCollectionLayoutVisibleItem>> *visibleItems, CGPoint contentOffset, id<NSCollectionLayoutEnvironment> layoutEnvironment) {", "    // Perform animations on the visible items.", "}];"], metadata: None }] }] })
///
#[cfg(feature = "block2")]
pub type NSCollectionLayoutSectionVisibleItemsInvalidationHandler = *mut block2::DynBlock<
    dyn Fn(
        NonNull<NSArray<ProtocolObject<dyn NSCollectionLayoutVisibleItem>>>,
        NSPoint,
        NonNull<ProtocolObject<dyn NSCollectionLayoutEnvironment>>,
    ),
>;

extern_class!(
    /// A container that combines a set of groups into distinct visual groupings.
    ///
    /// ## Overview
    ///
    /// A collection view layout has one or more sections. Sections provide a way to separate the layout into distinct pieces.
    ///
    /// Each section can have the same layout or a different layout than the other sections in the collection view. A section’s layout is determined by the properties of the group ([`NSCollectionLayoutGroup`](https://developer.apple.com/documentation/appkit/nscollectionlayoutgroup)) that’s used to create the section.
    ///
    /// In the Photos app, each section in the Years page uses the same layout. In the App Store, the Apps page displays several sections with different content arrangements.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/29142d3707bbfb8205cfef012723bedb/media-3568661~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/3a145ace5c9cd5a165dbc9c2759c035f/media-3568661%402x.png 2x" />
    ///     <img alt="Schematic representation of the App Store app on iOS, showing a collection view with a compositional layout. The layout is composed of two horizontally-scrolling sections that have different layouts. The top section shows one group with one item visible onscreen, with other groups peeking in from the sides of the screen. The bottom section shows one group that’s a column of three cells, each of those cells being an item. The two different sections are highlighted and labeled as sections." src="https://docs-assets.developer.apple.com/published/3a145ace5c9cd5a165dbc9c2759c035f/media-3568661%402x.png" />
    /// </picture>
    ///
    ///
    /// Each section can have its own background, header, and footer to distinguish it from other sections.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutSection;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutSection {}
);

unsafe impl CopyingHelper for NSCollectionLayoutSection {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutSection {}
);

impl NSCollectionLayoutSection {
    extern_methods!(
        #[unsafe(method(sectionWithGroup:))]
        #[unsafe(method_family = none)]
        pub fn sectionWithGroup(group: &NSCollectionLayoutGroup) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(contentInsets))]
        #[unsafe(method_family = none)]
        pub fn contentInsets(&self) -> NSDirectionalEdgeInsets;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`contentInsets`][Self::contentInsets].
        #[unsafe(method(setContentInsets:))]
        #[unsafe(method_family = none)]
        pub fn setContentInsets(&self, content_insets: NSDirectionalEdgeInsets);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(interGroupSpacing))]
        #[unsafe(method_family = none)]
        pub fn interGroupSpacing(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`interGroupSpacing`][Self::interGroupSpacing].
        #[unsafe(method(setInterGroupSpacing:))]
        #[unsafe(method_family = none)]
        pub fn setInterGroupSpacing(&self, inter_group_spacing: CGFloat);

        #[unsafe(method(orthogonalScrollingBehavior))]
        #[unsafe(method_family = none)]
        pub fn orthogonalScrollingBehavior(
            &self,
        ) -> NSCollectionLayoutSectionOrthogonalScrollingBehavior;

        /// Setter for [`orthogonalScrollingBehavior`][Self::orthogonalScrollingBehavior].
        #[unsafe(method(setOrthogonalScrollingBehavior:))]
        #[unsafe(method_family = none)]
        pub fn setOrthogonalScrollingBehavior(
            &self,
            orthogonal_scrolling_behavior: NSCollectionLayoutSectionOrthogonalScrollingBehavior,
        );

        #[unsafe(method(boundarySupplementaryItems))]
        #[unsafe(method_family = none)]
        pub fn boundarySupplementaryItems(
            &self,
        ) -> Retained<NSArray<NSCollectionLayoutBoundarySupplementaryItem>>;

        /// Setter for [`boundarySupplementaryItems`][Self::boundarySupplementaryItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBoundarySupplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn setBoundarySupplementaryItems(
            &self,
            boundary_supplementary_items: &NSArray<NSCollectionLayoutBoundarySupplementaryItem>,
        );

        #[unsafe(method(supplementariesFollowContentInsets))]
        #[unsafe(method_family = none)]
        pub fn supplementariesFollowContentInsets(&self) -> bool;

        /// Setter for [`supplementariesFollowContentInsets`][Self::supplementariesFollowContentInsets].
        #[unsafe(method(setSupplementariesFollowContentInsets:))]
        #[unsafe(method_family = none)]
        pub fn setSupplementariesFollowContentInsets(
            &self,
            supplementaries_follow_content_insets: bool,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 3 must be a valid pointer.
        #[unsafe(method(visibleItemsInvalidationHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn visibleItemsInvalidationHandler(
            &self,
        ) -> NSCollectionLayoutSectionVisibleItemsInvalidationHandler;

        #[cfg(feature = "block2")]
        /// Setter for [`visibleItemsInvalidationHandler`][Self::visibleItemsInvalidationHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `visible_items_invalidation_handler` must be a valid pointer or null.
        #[unsafe(method(setVisibleItemsInvalidationHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setVisibleItemsInvalidationHandler(
            &self,
            visible_items_invalidation_handler: NSCollectionLayoutSectionVisibleItemsInvalidationHandler,
        );

        #[unsafe(method(decorationItems))]
        #[unsafe(method_family = none)]
        pub fn decorationItems(&self) -> Retained<NSArray<NSCollectionLayoutDecorationItem>>;

        /// Setter for [`decorationItems`][Self::decorationItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDecorationItems:))]
        #[unsafe(method_family = none)]
        pub fn setDecorationItems(
            &self,
            decoration_items: &NSArray<NSCollectionLayoutDecorationItem>,
        );
    );
}

extern_class!(
    /// The most basic component of a collection view’s layout.
    ///
    /// ## Overview
    ///
    /// An item is a blueprint for how to size, space, and arrange an individual piece of content in your collection view. An item represents a single view that’s rendered onscreen. Generally, an item is a cell, but items can be supplementary views like headers, footers, and other decorations.
    ///
    /// For example, in the Photos app, an item might represent a single photo. In the App Store app, an item might be a cell displaying information about an individual app in a list of featured apps, such as the app icon, app name, tagline, and download button.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/5f87b68259e0fb25503940360e298357/media-3568665~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/4969747519bcd95bb15d128d7a712ae1/media-3568665%402x.png 2x" />
    ///     <img alt="Schematic representation of the App Store app on iOS, showing a collection view with a compositional layout. The layout is composed of two horizontally-scrolling sections that have different layouts. The top section shows one group with one item visible onscreen, with other groups peeking in from the sides of the screen. The bottom section shows one group that’s a column of three cells, each of those cells being an item. The two different types of items are highlighted and labeled as items." src="https://docs-assets.developer.apple.com/published/5f87b68259e0fb25503940360e298357/media-3568665~dark%402x.png" />
    /// </picture>
    ///
    ///
    /// Each item specifies its own size in terms of a width dimension and a height dimension. Items can express their dimensions relative to their container, as an absolute value, or as an estimated value that might change at runtime, like in response to a change in system font size. For more information, see [`NSCollectionLayoutDimension`](https://developer.apple.com/documentation/appkit/nscollectionlayoutdimension).
    ///
    /// You combine items into groups that determine how those items are arranged in relation to each other. For more information, see [`NSCollectionLayoutGroup`](https://developer.apple.com/documentation/appkit/nscollectionlayoutgroup).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutItem {}
);

impl NSCollectionLayoutItem {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(contentInsets))]
        #[unsafe(method_family = none)]
        pub fn contentInsets(&self) -> NSDirectionalEdgeInsets;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`contentInsets`][Self::contentInsets].
        #[unsafe(method(setContentInsets:))]
        #[unsafe(method_family = none)]
        pub fn setContentInsets(&self, content_insets: NSDirectionalEdgeInsets);

        #[unsafe(method(edgeSpacing))]
        #[unsafe(method_family = none)]
        pub fn edgeSpacing(&self) -> Option<Retained<NSCollectionLayoutEdgeSpacing>>;

        /// Setter for [`edgeSpacing`][Self::edgeSpacing].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setEdgeSpacing:))]
        #[unsafe(method_family = none)]
        pub fn setEdgeSpacing(&self, edge_spacing: Option<&NSCollectionLayoutEdgeSpacing>);

        #[unsafe(method(layoutSize))]
        #[unsafe(method_family = none)]
        pub fn layoutSize(&self) -> Retained<NSCollectionLayoutSize>;

        #[unsafe(method(supplementaryItems))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItems(&self) -> Retained<NSArray<NSCollectionLayoutSupplementaryItem>>;
    );
}

extern_class!(
    /// An item used in a group with a custom layout arrangement.
    ///
    /// ## Overview
    ///
    /// You use a custom item if you want to specify a layout with a custom arrangement, like a radial or diagonal layout. You use custom items within a group that’s created with [`customGroupWithLayoutSize:itemProvider:`](https://developer.apple.com/documentation/appkit/nscollectionlayoutgroup/custom(layoutsize:itemprovider:)).
    ///
    /// Instead of providing a layout size for the custom item, like you do when you create an [`NSCollectionLayoutItem`](https://developer.apple.com/documentation/appkit/nscollectionlayoutitem), you provide a frame instead.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutGroupCustomItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutGroupCustomItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutGroupCustomItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutGroupCustomItem {}
);

impl NSCollectionLayoutGroupCustomItem {
    extern_methods!(
        #[unsafe(method(customItemWithFrame:))]
        #[unsafe(method_family = none)]
        pub fn customItemWithFrame(frame: NSRect, mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(customItemWithFrame:zIndex:))]
        #[unsafe(method_family = none)]
        pub fn customItemWithFrame_zIndex(
            frame: NSRect,
            z_index: NSInteger,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(frame))]
        #[unsafe(method_family = none)]
        pub fn frame(&self) -> NSRect;

        #[unsafe(method(zIndex))]
        #[unsafe(method_family = none)]
        pub fn zIndex(&self) -> NSInteger;
    );
}

/// A closure that creates and returns each of the custom group’s items.
///
/// ## Discussion
///
/// You use a custom item provider to supply the item arrangement when creating a group using the [`customGroupWithLayoutSize:itemProvider:`](https://developer.apple.com/documentation/appkit/nscollectionlayoutgroup/custom(layoutsize:itemprovider:)) initializer.
///
///
#[cfg(feature = "block2")]
pub type NSCollectionLayoutGroupCustomItemProvider = *mut block2::DynBlock<
    dyn Fn(
        NonNull<ProtocolObject<dyn NSCollectionLayoutEnvironment>>,
    ) -> NonNull<NSArray<NSCollectionLayoutGroupCustomItem>>,
>;

extern_class!(
    /// A container for a set of items that lays out the items along a path.
    ///
    /// ## Overview
    ///
    /// Groups determine how the items in a collection view lay out in relation to each other. A group might lay out its items in a horizontal row, a vertical column, or a custom arrangement. A group determines the rules for how items are rendered in relation to each other, but in itself doesn’t render any content.
    ///
    /// For example, in the Photos app, a group of items is a row of photos. In the App Store app, a group might be a single column of cells (items) arranged in a vertical column.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/6d64c3ffd95d486a938762c7f5e92122/media-3568663~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/fc57f40cd933b8fdf6ee5bc26e52d7fa/media-3568663%402x.png 2x" />
    ///     <img alt="Schematic representation of the App Store app on iOS, showing a collection view with a compositional layout. The layout is composed of horizontally-scrolling sections that have different layouts. The top section shows one group with one item visible onscreen, with other groups peeking in from the sides of the screen. The bottom section shows one group that’s a column of three cells, each of those cells being an item. The two different types of groups are highlighted and labeled as groups." src="https://docs-assets.developer.apple.com/published/fc57f40cd933b8fdf6ee5bc26e52d7fa/media-3568663%402x.png" />
    /// </picture>
    ///
    ///
    /// Each group specifies its own size in terms of a width dimension and a height dimension. Groups can express their dimensions relative to their container, as an absolute value, or as an estimated value that might change at runtime, like in response to a change in system font size. For more information, see [`NSCollectionLayoutDimension`](https://developer.apple.com/documentation/appkit/nscollectionlayoutdimension).
    ///
    /// Because a group is a subclass of [`NSCollectionLayoutItem`](https://developer.apple.com/documentation/appkit/nscollectionlayoutitem), it behaves like an item. You can combine a group with other items and groups into more complex layouts.
    ///
    ///
    /// ![Illustration of group nesting in a compositional layout. A larger group contains one large item on the leading side and two smaller items stacked vertically in a nested group on the trailing side.](https://docs-assets.developer.apple.com/published/47daaa6eb89261c15d6bcb264846aa1b/media-3568666%402x.png)
    ///
    ///
    /// After you configure a group, you must initialize a section ([`NSCollectionLayoutSection`](https://developer.apple.com/documentation/appkit/nscollectionlayoutsection)) of your collection view layout with that group.
    ///
    ///
    #[unsafe(super(NSCollectionLayoutItem, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutGroup;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutGroup {}
);

unsafe impl CopyingHelper for NSCollectionLayoutGroup {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutGroup {}
);

impl NSCollectionLayoutGroup {
    extern_methods!(
        #[unsafe(method(horizontalGroupWithLayoutSize:subitem:count:))]
        #[unsafe(method_family = none)]
        pub fn horizontalGroupWithLayoutSize_subitem_count(
            layout_size: &NSCollectionLayoutSize,
            subitem: &NSCollectionLayoutItem,
            count: NSInteger,
        ) -> Retained<Self>;

        #[unsafe(method(horizontalGroupWithLayoutSize:subitems:))]
        #[unsafe(method_family = none)]
        pub fn horizontalGroupWithLayoutSize_subitems(
            layout_size: &NSCollectionLayoutSize,
            subitems: &NSArray<NSCollectionLayoutItem>,
        ) -> Retained<Self>;

        #[unsafe(method(verticalGroupWithLayoutSize:subitem:count:))]
        #[unsafe(method_family = none)]
        pub fn verticalGroupWithLayoutSize_subitem_count(
            layout_size: &NSCollectionLayoutSize,
            subitem: &NSCollectionLayoutItem,
            count: NSInteger,
        ) -> Retained<Self>;

        #[unsafe(method(verticalGroupWithLayoutSize:subitems:))]
        #[unsafe(method_family = none)]
        pub fn verticalGroupWithLayoutSize_subitems(
            layout_size: &NSCollectionLayoutSize,
            subitems: &NSArray<NSCollectionLayoutItem>,
        ) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `item_provider` must be a valid pointer.
        #[unsafe(method(customGroupWithLayoutSize:itemProvider:))]
        #[unsafe(method_family = none)]
        pub unsafe fn customGroupWithLayoutSize_itemProvider(
            layout_size: &NSCollectionLayoutSize,
            item_provider: NSCollectionLayoutGroupCustomItemProvider,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(supplementaryItems))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItems(&self) -> Retained<NSArray<NSCollectionLayoutSupplementaryItem>>;

        /// Setter for [`supplementaryItems`][Self::supplementaryItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSupplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn setSupplementaryItems(
            &self,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        );

        #[unsafe(method(interItemSpacing))]
        #[unsafe(method_family = none)]
        pub fn interItemSpacing(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;

        /// Setter for [`interItemSpacing`][Self::interItemSpacing].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setInterItemSpacing:))]
        #[unsafe(method_family = none)]
        pub fn setInterItemSpacing(&self, inter_item_spacing: Option<&NSCollectionLayoutSpacing>);

        #[unsafe(method(subitems))]
        #[unsafe(method_family = none)]
        pub fn subitems(&self) -> Retained<NSArray<NSCollectionLayoutItem>>;

        #[unsafe(method(visualDescription))]
        #[unsafe(method_family = none)]
        pub fn visualDescription(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSCollectionLayoutItem`.
impl NSCollectionLayoutGroup {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// An individual dimension representing an item’s width or height in a collection view.
    ///
    /// ## Overview
    ///
    /// Each item in a collection view has an explicit width dimension and height dimension, which combine to define the item’s size ([`NSCollectionLayoutSize`](https://developer.apple.com/documentation/appkit/nscollectionlayoutsize)).
    ///
    /// You can express an item’s dimensions using an absolute, estimated, or fractional value.
    ///
    /// Use an _absolute value_ to specify exact dimensions, like a 44 x 44 point square:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let absoluteSize = NSCollectionLayoutSize(widthDimension: .absolute(44),", "                                         heightDimension: .absolute(44))"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *absoluteSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:44.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];"], metadata: None }] }] })
    /// Use an _estimated value_ if the size of your content might change at runtime, such as when data is loaded or in response to a change in system font size. You provide an initial estimated size and the system computes the actual value later.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let estimatedSize = NSCollectionLayoutSize(widthDimension: .estimated(200),", "                                          heightDimension: .estimated(100))"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *estimatedSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension estimatedDimension:200.0] heightDimension:[NSCollectionLayoutDimension estimatedDimension:100.0]];"], metadata: None }] }] })
    /// Use a _fractional value_ to define a value that’s relative to a dimension of the item’s container. This option simplifies specifying aspect ratios. For example, the following item has a width and a height that are both equal to 20% of its container’s width, creating a square that grows and shrinks as the size of its container changes.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let fractionalSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(0.2),", "                                           heightDimension: .fractionalWidth(0.2))"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *fractionalSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:0.2] heightDimension:[NSCollectionLayoutDimension fractionalWidthDimension:0.2]];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutDimension;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutDimension {}
);

unsafe impl CopyingHelper for NSCollectionLayoutDimension {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutDimension {}
);

impl NSCollectionLayoutDimension {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(fractionalWidthDimension:))]
        #[unsafe(method_family = none)]
        pub fn fractionalWidthDimension(
            fractional_width: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(fractionalHeightDimension:))]
        #[unsafe(method_family = none)]
        pub fn fractionalHeightDimension(
            fractional_height: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(absoluteDimension:))]
        #[unsafe(method_family = none)]
        pub fn absoluteDimension(
            absolute_dimension: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(estimatedDimension:))]
        #[unsafe(method_family = none)]
        pub fn estimatedDimension(
            estimated_dimension: CGFloat,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(isFractionalWidth))]
        #[unsafe(method_family = none)]
        pub fn isFractionalWidth(&self) -> bool;

        #[unsafe(method(isFractionalHeight))]
        #[unsafe(method_family = none)]
        pub fn isFractionalHeight(&self) -> bool;

        #[unsafe(method(isAbsolute))]
        #[unsafe(method_family = none)]
        pub fn isAbsolute(&self) -> bool;

        #[unsafe(method(isEstimated))]
        #[unsafe(method_family = none)]
        pub fn isEstimated(&self) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(dimension))]
        #[unsafe(method_family = none)]
        pub fn dimension(&self) -> CGFloat;
    );
}

extern_class!(
    /// The width and the height of an item in a collection view.
    ///
    /// ## Overview
    ///
    /// A size is a pair of dimensions ([`NSCollectionLayoutDimension`](https://developer.apple.com/documentation/appkit/nscollectionlayoutdimension)): a width dimension and a height dimension. Every component of a collection view layout has an explicit size.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutSize;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutSize {}
);

unsafe impl CopyingHelper for NSCollectionLayoutSize {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutSize {}
);

impl NSCollectionLayoutSize {
    extern_methods!(
        #[unsafe(method(sizeWithWidthDimension:heightDimension:))]
        #[unsafe(method_family = none)]
        pub fn sizeWithWidthDimension_heightDimension(
            width: &NSCollectionLayoutDimension,
            height: &NSCollectionLayoutDimension,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(widthDimension))]
        #[unsafe(method_family = none)]
        pub fn widthDimension(&self) -> Retained<NSCollectionLayoutDimension>;

        #[unsafe(method(heightDimension))]
        #[unsafe(method_family = none)]
        pub fn heightDimension(&self) -> Retained<NSCollectionLayoutDimension>;
    );
}

extern_class!(
    /// An object that defines the space between or around items in a collection view.
    ///
    /// ## Overview
    ///
    /// In a collection view layout, you use a spacing object to specify both the amount of space and the way in which it’s calculated.
    ///
    /// You can express spacing using fixed or flexible spacing.
    ///
    /// Use _fixed spacing_ to provide an exact amount of space. For example, the following code creates exactly 200 points of space between the items in the group.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["group.interItemSpacing = .fixed(200.0)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[group setInterItemSpacing: [NSCollectionLayoutSpacing fixedSpacing:200.0]];"], metadata: None }] }] })
    /// Use _flexible spacing_ to provide a minimum amount of space that can grow as more space becomes available. For example, the following code creates at least 200 points of space between the items in the group. As more space becomes available, items are respaced evenly in the additional space.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["group.interItemSpacing = .flexible(200.0)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["[group setInterItemSpacing: [NSCollectionLayoutSpacing flexibleSpacing:200.0]];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutSpacing;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutSpacing {}
);

unsafe impl CopyingHelper for NSCollectionLayoutSpacing {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutSpacing {}
);

impl NSCollectionLayoutSpacing {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(flexibleSpacing:))]
        #[unsafe(method_family = none)]
        pub fn flexibleSpacing(flexible_spacing: CGFloat, mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(fixedSpacing:))]
        #[unsafe(method_family = none)]
        pub fn fixedSpacing(fixed_spacing: CGFloat, mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(spacing))]
        #[unsafe(method_family = none)]
        pub fn spacing(&self) -> CGFloat;

        #[unsafe(method(isFlexibleSpacing))]
        #[unsafe(method_family = none)]
        pub fn isFlexibleSpacing(&self) -> bool;

        #[unsafe(method(isFixedSpacing))]
        #[unsafe(method_family = none)]
        pub fn isFixedSpacing(&self) -> bool;
    );
}

extern_class!(
    /// An object that defines the space around the edges of items in a collection view.
    ///
    /// ## Overview
    ///
    /// You use edge spacing to create additional spacing around the edges of an item to adjust the position of the item in relation to its container and other items.
    ///
    /// The leading and trailing spaces within edge spacing differ in left-to-right versus right-to-left environments. In a left-to-right environment, the leading space is on the left, and the trailing space is on the right. In a right-to-left environment, the leading space is on the right, and the trailing space is on the left. This difference ensures that your collection view layout is built with support for right-to-left languages.
    ///
    /// The following diagram shows the difference between adding 2 points of trailing edge spacing in a left-to-right versus a right-to-left environment.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/0eb1dca0c8e3363af7104445aa047c88/media-3570381~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/a315a0a064f715f044a87ad23b139457/media-3570381%402x.png 2x" />
    ///     <img alt="Two diagrams that compare edge spacing in a left-to-right and a right-to-left environment. Both diagrams show a group of three square items in a row. The first diagram, labeled trailing in left-to-right environment, shows trailing space on the right of each item, implying that leading space is on the left. The second diagram, labeled trailing in right-to-left environment, shows trailing space on the left of each item, implying that leading space is on the right." src="https://docs-assets.developer.apple.com/published/a315a0a064f715f044a87ad23b139457/media-3570381%402x.png" />
    /// </picture>
    ///
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutEdgeSpacing;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutEdgeSpacing {}
);

unsafe impl CopyingHelper for NSCollectionLayoutEdgeSpacing {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutEdgeSpacing {}
);

impl NSCollectionLayoutEdgeSpacing {
    extern_methods!(
        #[unsafe(method(spacingForLeading:top:trailing:bottom:))]
        #[unsafe(method_family = none)]
        pub fn spacingForLeading_top_trailing_bottom(
            leading: Option<&NSCollectionLayoutSpacing>,
            top: Option<&NSCollectionLayoutSpacing>,
            trailing: Option<&NSCollectionLayoutSpacing>,
            bottom: Option<&NSCollectionLayoutSpacing>,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(leading))]
        #[unsafe(method_family = none)]
        pub fn leading(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;

        #[unsafe(method(top))]
        #[unsafe(method_family = none)]
        pub fn top(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;

        #[unsafe(method(trailing))]
        #[unsafe(method_family = none)]
        pub fn trailing(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;

        #[unsafe(method(bottom))]
        #[unsafe(method_family = none)]
        pub fn bottom(&self) -> Option<Retained<NSCollectionLayoutSpacing>>;
    );
}

extern_class!(
    /// An object used to add an extra visual decoration to an item in a collection view.
    ///
    /// ## Overview
    ///
    /// You use supplementary items to attach additional views to your content. For example, you might attach a badge to an item or a frame around a group. A supplementary item follows the index path of the item it’s attached to.
    ///
    /// If you want to create a header or footer for your layout or its sections, use a boundary supplementary item (<````NSCollectionLayoutBoundarySupplementaryItem``>) instead.
    ///
    /// Each type of supplementary item must have a unique element kind. Consider tracking these strings together in a way that makes it straightforward to identify each element, for example:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["struct ElementKind {", "    static let badge = \"badge-element-kind\"", "    static let background = \"background-element-kind\"", "    static let sectionHeader = \"section-header-element-kind\"", "    static let sectionFooter = \"section-footer-element-kind\"", "    static let layoutHeader = \"layout-header-element-kind\"", "    static let layoutFooter = \"layout-footer-element-kind\"", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSString* const ELEMENT_KIND_BADGE = @\"badge-element-kind\";", "NSString* const ELEMENT_KIND_BACKGROUND = @\"background-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_HEADER = @\"section-header-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_FOOTER = @\"section-footer-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_HEADER = @\"layout-header-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_FOOTER = @\"layout-footer-element-kind\";"], metadata: None }] }] })
    /// Add supplementary items to an item by passing in an array of supplementary items when you construct the item:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let itemSize = NSCollectionLayoutSize(widthDimension: .absolute(44),", "                                     heightDimension: .absolute(44))", "    ", "let badgeAnchor = NSCollectionLayoutAnchor(edges: [.top, .trailing],", "                                fractionalOffset: CGPoint(x: 0.3, y: -0.3))", "   ", "let badgeSize = NSCollectionLayoutSize(widthDimension: .absolute(20),", "                                      heightDimension: .absolute(20))", "    ", "let badge = NSCollectionLayoutSupplementaryItem(layoutSize: badgeSize,", "                                               elementKind: ElementKind.badge,", "                                           containerAnchor: badgeAnchor)", "    ", "let item = NSCollectionLayoutItem(layoutSize: itemSize,", "                          supplementaryItems: [badge])"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *itemSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:44.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];", "", "NSCollectionLayoutAnchor *badgeAnchor = [NSCollectionLayoutAnchor layoutAnchorWithEdges: NSDirectionalRectEdgeTop|NSDirectionalRectEdgeTrailing fractionalOffset:CGPointMake(0.3, -0.3)];", "", "NSCollectionLayoutSize *badgeSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:20.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:20.0]];", "", "NSCollectionLayoutSupplementaryItem *badge = [NSCollectionLayoutSupplementaryItem supplementaryItemWithLayoutSize:badgeSize elementKind:ELEMENT_KIND_BADGE containerAnchor:badgeAnchor];", "", "NSCollectionLayoutItem *item = [NSCollectionLayoutItem itemWithLayoutSize:itemSize supplementaryItems:@[badge]];", ""], metadata: None }] }] })
    ///
    #[unsafe(super(NSCollectionLayoutItem, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutSupplementaryItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutSupplementaryItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutSupplementaryItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutSupplementaryItem {}
);

impl NSCollectionLayoutSupplementaryItem {
    extern_methods!(
        #[unsafe(method(supplementaryItemWithLayoutSize:elementKind:containerAnchor:))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItemWithLayoutSize_elementKind_containerAnchor(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            container_anchor: &NSCollectionLayoutAnchor,
        ) -> Retained<Self>;

        #[unsafe(method(supplementaryItemWithLayoutSize:elementKind:containerAnchor:itemAnchor:))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItemWithLayoutSize_elementKind_containerAnchor_itemAnchor(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            container_anchor: &NSCollectionLayoutAnchor,
            item_anchor: &NSCollectionLayoutAnchor,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(zIndex))]
        #[unsafe(method_family = none)]
        pub fn zIndex(&self) -> NSInteger;

        /// Setter for [`zIndex`][Self::zIndex].
        #[unsafe(method(setZIndex:))]
        #[unsafe(method_family = none)]
        pub fn setZIndex(&self, z_index: NSInteger);

        #[unsafe(method(elementKind))]
        #[unsafe(method_family = none)]
        pub fn elementKind(&self) -> Retained<NSString>;

        #[unsafe(method(containerAnchor))]
        #[unsafe(method_family = none)]
        pub fn containerAnchor(&self) -> Retained<NSCollectionLayoutAnchor>;

        #[unsafe(method(itemAnchor))]
        #[unsafe(method_family = none)]
        pub fn itemAnchor(&self) -> Option<Retained<NSCollectionLayoutAnchor>>;
    );
}

/// Methods declared on superclass `NSCollectionLayoutItem`.
impl NSCollectionLayoutSupplementaryItem {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// An object used to add headers or footers to a collection view.
    ///
    /// ## Overview
    ///
    /// A boundary supplementary item is a specialized type of supplementary item ([`NSCollectionLayoutSupplementaryItem`](https://developer.apple.com/documentation/appkit/nscollectionlayoutsupplementaryitem)). You use boundary supplementary items to add headers or footers to a section of a collection view or the entire collection view.
    ///
    /// Each type of supplementary item must have a unique element kind. Consider tracking these strings together in a way that makes it straightforward to identify each element, for example:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["struct ElementKind {", "    static let badge = \"badge-element-kind\"", "    static let background = \"background-element-kind\"", "    static let sectionHeader = \"section-header-element-kind\"", "    static let sectionFooter = \"section-footer-element-kind\"", "    static let layoutHeader = \"layout-header-element-kind\"", "    static let layoutFooter = \"layout-footer-element-kind\"", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSString* const ELEMENT_KIND_BADGE = @\"badge-element-kind\";", "NSString* const ELEMENT_KIND_BACKGROUND = @\"background-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_HEADER = @\"section-header-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_FOOTER = @\"section-footer-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_HEADER = @\"layout-header-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_FOOTER = @\"layout-footer-element-kind\";"], metadata: None }] }] })
    /// Add boundary supplementary items to a section by setting that section’s [`boundarySupplementaryItems`](https://developer.apple.com/documentation/appkit/nscollectionviewcompositionallayoutconfiguration/boundarysupplementaryitems) property:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let section = NSCollectionLayoutSection(group: group)", "", "let headerFooterSize = NSCollectionLayoutSize(widthDimension: .fractionalWidth(1.0),", "                                             heightDimension: .estimated(44))", "    ", "let sectionHeader = NSCollectionLayoutBoundarySupplementaryItem(layoutSize: headerFooterSize,", "                                                               elementKind: ElementKind.sectionHeader,", "                                                                 alignment: .top)", "let sectionFooter = NSCollectionLayoutBoundarySupplementaryItem(layoutSize: headerFooterSize,", "                                                               elementKind: ElementKind.sectionFooter,", "                                                                 alignment: .bottom)", "    ", "section.boundarySupplementaryItems = [sectionHeader, sectionFooter]"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSection *section = [NSCollectionLayoutSection sectionWithGroup:group];", "", "NSCollectionLayoutSize *headerFooterSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension fractionalWidthDimension:1.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];", "", "NSCollectionLayoutBoundarySupplementaryItem *sectionHeader = [NSCollectionLayoutBoundarySupplementaryItem boundarySupplementaryItemWithLayoutSize: headerFooterSize elementKind: ELEMENT_KIND_SECTION_HEADER alignment: NSRectAlignmentTop];", "", "NSCollectionLayoutBoundarySupplementaryItem *sectionFooter = [NSCollectionLayoutBoundarySupplementaryItem boundarySupplementaryItemWithLayoutSize: headerFooterSize elementKind: ELEMENT_KIND_SECTION_FOOTER alignment: NSRectAlignmentBottom];", "", "[section setBoundarySupplementaryItems: @[sectionHeader, sectionFooter]];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSCollectionLayoutSupplementaryItem, NSCollectionLayoutItem, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutBoundarySupplementaryItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutBoundarySupplementaryItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutBoundarySupplementaryItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutBoundarySupplementaryItem {}
);

impl NSCollectionLayoutBoundarySupplementaryItem {
    extern_methods!(
        #[unsafe(method(boundarySupplementaryItemWithLayoutSize:elementKind:alignment:))]
        #[unsafe(method_family = none)]
        pub fn boundarySupplementaryItemWithLayoutSize_elementKind_alignment(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            alignment: NSRectAlignment,
        ) -> Retained<Self>;

        #[unsafe(method(boundarySupplementaryItemWithLayoutSize:elementKind:alignment:absoluteOffset:))]
        #[unsafe(method_family = none)]
        pub fn boundarySupplementaryItemWithLayoutSize_elementKind_alignment_absoluteOffset(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            alignment: NSRectAlignment,
            absolute_offset: NSPoint,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(extendsBoundary))]
        #[unsafe(method_family = none)]
        pub fn extendsBoundary(&self) -> bool;

        /// Setter for [`extendsBoundary`][Self::extendsBoundary].
        #[unsafe(method(setExtendsBoundary:))]
        #[unsafe(method_family = none)]
        pub fn setExtendsBoundary(&self, extends_boundary: bool);

        #[unsafe(method(pinToVisibleBounds))]
        #[unsafe(method_family = none)]
        pub fn pinToVisibleBounds(&self) -> bool;

        /// Setter for [`pinToVisibleBounds`][Self::pinToVisibleBounds].
        #[unsafe(method(setPinToVisibleBounds:))]
        #[unsafe(method_family = none)]
        pub fn setPinToVisibleBounds(&self, pin_to_visible_bounds: bool);

        #[unsafe(method(alignment))]
        #[unsafe(method_family = none)]
        pub fn alignment(&self) -> NSRectAlignment;

        #[unsafe(method(offset))]
        #[unsafe(method_family = none)]
        pub fn offset(&self) -> NSPoint;
    );
}

/// Methods declared on superclass `NSCollectionLayoutSupplementaryItem`.
impl NSCollectionLayoutBoundarySupplementaryItem {
    extern_methods!(
        #[unsafe(method(supplementaryItemWithLayoutSize:elementKind:containerAnchor:))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItemWithLayoutSize_elementKind_containerAnchor(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            container_anchor: &NSCollectionLayoutAnchor,
        ) -> Retained<Self>;

        #[unsafe(method(supplementaryItemWithLayoutSize:elementKind:containerAnchor:itemAnchor:))]
        #[unsafe(method_family = none)]
        pub fn supplementaryItemWithLayoutSize_elementKind_containerAnchor_itemAnchor(
            layout_size: &NSCollectionLayoutSize,
            element_kind: &NSString,
            container_anchor: &NSCollectionLayoutAnchor,
            item_anchor: &NSCollectionLayoutAnchor,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSCollectionLayoutItem`.
impl NSCollectionLayoutBoundarySupplementaryItem {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// An object used to add a background to a section of a collection view.
    ///
    /// ## Overview
    ///
    /// Each type of decoration item must have a unique element kind. Consider tracking these strings together in a way that makes it straightforward to identify each element, for example:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["struct ElementKind {", "    static let badge = \"badge-element-kind\"", "    static let background = \"background-element-kind\"", "    static let sectionHeader = \"section-header-element-kind\"", "    static let sectionFooter = \"section-footer-element-kind\"", "    static let layoutHeader = \"layout-header-element-kind\"", "    static let layoutFooter = \"layout-footer-element-kind\"", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSString* const ELEMENT_KIND_BADGE = @\"badge-elemn’s-kind\";", "NSString* const ELEMENT_KIND_BACKGROUND = @\"background-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_HEADER = @\"section-header-element-kind\";", "NSString* const ELEMENT_KIND_SECTION_FOOTER = @\"section-footer-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_HEADER = @\"layout-header-element-kind\";", "NSString* const ELEMENT_KIND_LAYOUT_FOOTER = @\"layout-footer-element-kind\";"], metadata: None }] }] })
    /// Add a background to a section by setting that section’s [`decorationItems`](https://developer.apple.com/documentation/appkit/nscollectionlayoutsection/decorationitems) property:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let sectionBackground = NSCollectionLayoutDecorationItem.background(", "        elementKind: ElementKind.background)", "", "section.decorationItems = [sectionBackground]", "", "let layout = UICollectionViewCompositionalLayout(section: section)", "layout.register(", "    SectionBackgroundDecorationView.self,", "    forDecorationViewOfKind: ElementKind.background)", "return layout"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutDecorationItem *sectionBackground = [NSCollectionLayoutDecorationItem backgroundDecorationItemWithElementKind: ELEMENT_KIND_BACKGROUND];", "", "[section setDecorationItems: @[sectionBackground]];", "", "UICollectionViewCompositionalLayout *layout = [[UICollectionViewCompositionalLayout alloc] initWithSection: section];", "[layout registerClass: [SectionBackgroundDecorationView class] forDecorationViewOfKind: ELEMENT_KIND_BACKGROUND];", "return layout;"], metadata: None }] }] })
    ///
    #[unsafe(super(NSCollectionLayoutItem, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutDecorationItem;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutDecorationItem {}
);

unsafe impl CopyingHelper for NSCollectionLayoutDecorationItem {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutDecorationItem {}
);

impl NSCollectionLayoutDecorationItem {
    extern_methods!(
        #[unsafe(method(backgroundDecorationItemWithElementKind:))]
        #[unsafe(method_family = none)]
        pub fn backgroundDecorationItemWithElementKind(
            element_kind: &NSString,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(zIndex))]
        #[unsafe(method_family = none)]
        pub fn zIndex(&self) -> NSInteger;

        /// Setter for [`zIndex`][Self::zIndex].
        #[unsafe(method(setZIndex:))]
        #[unsafe(method_family = none)]
        pub fn setZIndex(&self, z_index: NSInteger);

        #[unsafe(method(elementKind))]
        #[unsafe(method_family = none)]
        pub fn elementKind(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSCollectionLayoutItem`.
impl NSCollectionLayoutDecorationItem {
    extern_methods!(
        #[unsafe(method(itemWithLayoutSize:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize(layout_size: &NSCollectionLayoutSize) -> Retained<Self>;

        #[unsafe(method(itemWithLayoutSize:supplementaryItems:))]
        #[unsafe(method_family = none)]
        pub fn itemWithLayoutSize_supplementaryItems(
            layout_size: &NSCollectionLayoutSize,
            supplementary_items: &NSArray<NSCollectionLayoutSupplementaryItem>,
        ) -> Retained<Self>;
    );
}

extern_class!(
    /// An object that defines how to attach a supplementary item to an item in a collection view.
    ///
    /// ## Overview
    ///
    /// You use an anchor to attach a supplementary item to a specific item. An anchor contains information about where on the item your supplementary item is attached, including:
    ///
    /// - An edge or set of edges. You can attach a supplementary item to a single edge, or to a corner by specifying two adjacent edges.
    ///
    /// - An offset from the item. By default, the supplementary item is anchored within the specified edges of the item it’s attached to. You can change this location by providing a custom offset when you create an anchor.
    ///
    /// ### Edges
    ///
    /// The leading and trailing edges for anchors differ in left-to-right versus right-to-left environments. In a left-to-right environment, the leading edge is on the left, and the trailing edge is on the right. In a right-to-left environment, the leading edge is on the right, and the trailing edge is on the left. This difference ensures that your collection view layout is built with support for right-to-left languages.
    ///
    /// The following diagram shows anchor placement for the specified edges in a left-to-right environment.
    ///
    ///
    /// <picture>
    ///     <source media="(prefers-color-scheme: dark)" srcset="https://docs-assets.developer.apple.com/published/90a0677fdd2f803d9388e6a44dca75c3/media-3570665~dark%402x.png 2x" />
    ///     <source media="(prefers-color-scheme: light)" srcset="https://docs-assets.developer.apple.com/published/b7e68b458cab77379003c0ce5e2ef3e9/media-3570665%402x.png 2x" />
    ///     <img alt="Diagram showing anchor positions. Top, bottom, leading, and trailing anchors are on the halfway point on their respective edges. The anchors defined by the edge combinations top and leading, top and trailing, bottom and leading, and bottom and trailing are in the corners between each of those sets of edges." src="https://docs-assets.developer.apple.com/published/b7e68b458cab77379003c0ce5e2ef3e9/media-3570665%402x.png" />
    /// </picture>
    ///
    ///
    /// ### Offset
    ///
    /// You can express anchor offset in these ways:
    ///
    /// - Absolute value. The offset is calculated as a point value. For example, an absolute x offset of `30.0` means that the origin of the supplementary item is offset by 30 points in the positive x direction.
    ///
    /// - Fractional value. The offset is calculated as a fraction of the supplementary item’s dimensions. For example, a fractional x offset of `0.3` means that the origin of the supplementary item is offset by 30% of the supplementary item’s width in the positive x direction.
    ///
    /// The following code creates a basic badge and attaches it to an item’s top trailing corner.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let itemSize = NSCollectionLayoutSize(widthDimension: .absolute(44),", "                                     heightDimension: .absolute(44))", "    ", "let badgeAnchor = NSCollectionLayoutAnchor(edges: [.top, .trailing],", "                                fractionalOffset: CGPoint(x: 0.3, y: -0.3))", "    ", "let badgeSize = NSCollectionLayoutSize(widthDimension: .absolute(20),", "                                      heightDimension: .absolute(20))", "    ", "let badge = NSCollectionLayoutSupplementaryItem(layoutSize: badgeSize,", "                                               elementKind: \"badge\",", "                                           containerAnchor: badgeAnchor)", "    ", "let item = NSCollectionLayoutItem(layoutSize: itemSize,", "                          supplementaryItems: [badge])", ""], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["NSCollectionLayoutSize *itemSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:44.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:44.0]];", "", "NSCollectionLayoutAnchor *badgeAnchor = [NSCollectionLayoutAnchor layoutAnchorWithEdges: NSDirectionalRectEdgeTop|NSDirectionalRectEdgeTrailing fractionalOffset:CGPointMake(0.3, -0.3)];", "", "NSCollectionLayoutSize *badgeSize = [NSCollectionLayoutSize sizeWithWidthDimension:[NSCollectionLayoutDimension absoluteDimension:20.0] heightDimension:[NSCollectionLayoutDimension absoluteDimension:20.0]];", "", "NSCollectionLayoutSupplementaryItem *badge = [NSCollectionLayoutSupplementaryItem supplementaryItemWithLayoutSize:badgeSize elementKind:ELEMENT_KIND_BADGE containerAnchor:badgeAnchor];", "", "NSCollectionLayoutItem *item = [NSCollectionLayoutItem itemWithLayoutSize:itemSize supplementaryItems:@[badge]];"], metadata: None }] }] })
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionLayoutAnchor;
);

extern_conformance!(
    unsafe impl NSCopying for NSCollectionLayoutAnchor {}
);

unsafe impl CopyingHelper for NSCollectionLayoutAnchor {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NSCollectionLayoutAnchor {}
);

impl NSCollectionLayoutAnchor {
    extern_methods!(
        #[unsafe(method(layoutAnchorWithEdges:))]
        #[unsafe(method_family = none)]
        pub fn layoutAnchorWithEdges(
            edges: NSDirectionalRectEdge,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(layoutAnchorWithEdges:absoluteOffset:))]
        #[unsafe(method_family = none)]
        pub fn layoutAnchorWithEdges_absoluteOffset(
            edges: NSDirectionalRectEdge,
            absolute_offset: NSPoint,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(layoutAnchorWithEdges:fractionalOffset:))]
        #[unsafe(method_family = none)]
        pub fn layoutAnchorWithEdges_fractionalOffset(
            edges: NSDirectionalRectEdge,
            fractional_offset: NSPoint,
            mtm: MainThreadMarker,
        ) -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(mtm: MainThreadMarker) -> Retained<Self>;

        #[unsafe(method(edges))]
        #[unsafe(method_family = none)]
        pub fn edges(&self) -> NSDirectionalRectEdge;

        #[unsafe(method(offset))]
        #[unsafe(method_family = none)]
        pub fn offset(&self) -> NSPoint;

        #[unsafe(method(isAbsoluteOffset))]
        #[unsafe(method_family = none)]
        pub fn isAbsoluteOffset(&self) -> bool;

        #[unsafe(method(isFractionalOffset))]
        #[unsafe(method_family = none)]
        pub fn isFractionalOffset(&self) -> bool;
    );
}

extern_protocol!(
    /// A protocol used to provide information about the size and content insets of a layout’s container.
    ///
    /// ## Overview
    ///
    /// In a section provider, you use the [`container`](https://developer.apple.com/documentation/appkit/nscollectionlayoutenvironment/container) property of the layout environment ([`NSCollectionLayoutEnvironment`](https://developer.apple.com/documentation/appkit/nscollectionlayoutenvironment)) to get information about the container of the layout, such as its size and content insets. Knowing about the container’s size while rendering the layout’s sections helps you make decisions about how to display the layout.
    ///
    ///
    pub unsafe trait NSCollectionLayoutContainer: NSObjectProtocol + MainThreadOnly {
        #[unsafe(method(contentSize))]
        #[unsafe(method_family = none)]
        fn contentSize(&self) -> NSSize;

        #[unsafe(method(effectiveContentSize))]
        #[unsafe(method_family = none)]
        fn effectiveContentSize(&self) -> NSSize;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(contentInsets))]
        #[unsafe(method_family = none)]
        fn contentInsets(&self) -> NSDirectionalEdgeInsets;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(effectiveContentInsets))]
        #[unsafe(method_family = none)]
        fn effectiveContentInsets(&self) -> NSDirectionalEdgeInsets;
    }
);

extern_protocol!(
    /// A protocol used to provide information about the layout’s container and environment traits, such as size classes and display scale factor.
    ///
    /// ## Overview
    ///
    /// In a section provider, you use the layout environment to get information about the context that the layout appears in. You can get information about the layout’s container, such as its size and content insets, and the traits of its environment, such as size classes, display scale factor, and user interface idiom. You use this information while rendering the layout’s sections to help you make decisions about how to display the layout.
    ///
    /// For example, the following code uses the layout environment’s trait collection to check whether the UI is in Dark Mode while creating the layout’s sections.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["let layout = UICollectionViewCompositionalLayout { (sectionIndex: Int,", "    layoutEnvironment: NSCollectionLayoutEnvironment) -> NSCollectionLayoutSection in", "        ", "    if layoutEnvironment.traitCollection.userInterfaceStyle == .dark {", "        return sectionForUserInterfaceStyle(.dark)", "    } else {", "        return sectionForUserInterfaceStyle(.light)", "    }", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["UICollectionViewCompositionalLayout *layout = [[UICollectionViewCompositionalLayout alloc] initWithSectionProvider:^NSCollectionLayoutSection *(NSInteger section, id<NSCollectionLayoutEnvironment> layoutEnvironment) {", "    if (layoutEnvironment.traitCollection.userInterfaceStyle == UIUserInterfaceStyleDark) {", "        return [self sectionForUserInterfaceStyle: UIUserInterfaceStyleDark];", "    } else {", "        return [self sectionForUserInterfaceStyle: UIUserInterfaceStyleLight];", "    }", "}];"], metadata: None }] }] })
    ///
    pub unsafe trait NSCollectionLayoutEnvironment:
        NSObjectProtocol + MainThreadOnly
    {
        #[unsafe(method(container))]
        #[unsafe(method_family = none)]
        fn container(&self) -> Retained<ProtocolObject<dyn NSCollectionLayoutContainer>>;
    }
);

extern_protocol!(
    /// An item that’s currently visible within the bounds of a section.
    ///
    /// ## Overview
    ///
    /// A visible item represents an item in a collection view that’s currently visible onscreen, such as a cell, supplementary view, or decoration. You access a specific section’s visible items in its visible item invalidation handler ([`NSCollectionLayoutSectionVisibleItemsInvalidationHandler`](https://developer.apple.com/documentation/appkit/nscollectionlayoutsectionvisibleitemsinvalidationhandler)), stored in the [`visibleItemsInvalidationHandler`](https://developer.apple.com/documentation/appkit/nscollectionlayoutsection/visibleitemsinvalidationhandler) property. The handler is called before each layout cycle, any time an animation occurs in that section due to changes such as adding or removing items, scrolling the section, or rotating the device.
    ///
    ///
    pub unsafe trait NSCollectionLayoutVisibleItem:
        NSObjectProtocol + MainThreadOnly
    {
        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(alpha))]
        #[unsafe(method_family = none)]
        fn alpha(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`alpha`][Self::alpha].
        #[unsafe(method(setAlpha:))]
        #[unsafe(method_family = none)]
        fn setAlpha(&self, alpha: CGFloat);

        #[unsafe(method(zIndex))]
        #[unsafe(method_family = none)]
        fn zIndex(&self) -> NSInteger;

        /// Setter for [`zIndex`][Self::zIndex].
        #[unsafe(method(setZIndex:))]
        #[unsafe(method_family = none)]
        fn setZIndex(&self, z_index: NSInteger);

        #[unsafe(method(isHidden))]
        #[unsafe(method_family = none)]
        fn isHidden(&self) -> bool;

        /// Setter for [`isHidden`][Self::isHidden].
        #[unsafe(method(setHidden:))]
        #[unsafe(method_family = none)]
        fn setHidden(&self, hidden: bool);

        #[unsafe(method(center))]
        #[unsafe(method_family = none)]
        fn center(&self) -> NSPoint;

        /// Setter for [`center`][Self::center].
        #[unsafe(method(setCenter:))]
        #[unsafe(method_family = none)]
        fn setCenter(&self, center: NSPoint);

        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        fn name(&self) -> Retained<NSString>;

        #[unsafe(method(indexPath))]
        #[unsafe(method_family = none)]
        fn indexPath(&self) -> Retained<NSIndexPath>;

        #[unsafe(method(frame))]
        #[unsafe(method_family = none)]
        fn frame(&self) -> NSRect;

        #[unsafe(method(bounds))]
        #[unsafe(method_family = none)]
        fn bounds(&self) -> NSRect;

        #[cfg(feature = "NSCollectionViewLayout")]
        #[unsafe(method(representedElementCategory))]
        #[unsafe(method_family = none)]
        fn representedElementCategory(&self) -> NSCollectionElementCategory;

        #[unsafe(method(representedElementKind))]
        #[unsafe(method_family = none)]
        fn representedElementKind(&self) -> Option<Retained<NSString>>;
    }
);
