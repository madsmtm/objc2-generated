//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// A set of methods that a scrubber data source object implements to provide items to the scrubber from an associated data collection in your app.
    pub unsafe trait NSScrubberDataSource: NSObjectProtocol + MainThreadOnly {
        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(numberOfItemsForScrubber:))]
        #[unsafe(method_family = none)]
        fn numberOfItemsForScrubber(&self, scrubber: &NSScrubber) -> NSInteger;

        #[cfg(all(
            feature = "NSResponder",
            feature = "NSScrubberItemView",
            feature = "NSView"
        ))]
        #[unsafe(method(scrubber:viewForItemAtIndex:))]
        #[unsafe(method_family = none)]
        fn scrubber_viewForItemAtIndex(
            &self,
            scrubber: &NSScrubber,
            index: NSInteger,
        ) -> Retained<NSScrubberItemView>;
    }
);

extern_protocol!(
    /// A set of methods that a scrubber delegate implements to respond to user interactions.
    pub unsafe trait NSScrubberDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[optional]
        #[unsafe(method(scrubber:didSelectItemAtIndex:))]
        #[unsafe(method_family = none)]
        fn scrubber_didSelectItemAtIndex(&self, scrubber: &NSScrubber, selected_index: NSInteger);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[optional]
        #[unsafe(method(scrubber:didHighlightItemAtIndex:))]
        #[unsafe(method_family = none)]
        fn scrubber_didHighlightItemAtIndex(
            &self,
            scrubber: &NSScrubber,
            highlighted_index: NSInteger,
        );

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[optional]
        #[unsafe(method(scrubber:didChangeVisibleRange:))]
        #[unsafe(method_family = none)]
        fn scrubber_didChangeVisibleRange(&self, scrubber: &NSScrubber, visible_range: NSRange);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[optional]
        #[unsafe(method(didBeginInteractingWithScrubber:))]
        #[unsafe(method_family = none)]
        fn didBeginInteractingWithScrubber(&self, scrubber: &NSScrubber);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[optional]
        #[unsafe(method(didFinishInteractingWithScrubber:))]
        #[unsafe(method_family = none)]
        fn didFinishInteractingWithScrubber(&self, scrubber: &NSScrubber);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[optional]
        #[unsafe(method(didCancelInteractingWithScrubber:))]
        #[unsafe(method_family = none)]
        fn didCancelInteractingWithScrubber(&self, scrubber: &NSScrubber);
    }
);

/// The scrolling behavior for a scrubber.
///
/// ## Overview
///
/// Scrolling is either _fixed_ or _free_. For details on how to choose the correct scrolling mode for your app, see [Choose a scrubber touch-interaction model](https://developer.apple.com/documentation/appkit/nsscrubber#choose-a-scrubber-touch-interaction-model).
///
///
/// Determines the interaction mode for a NSScrubber control.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSScrubberMode(pub NSInteger);
impl NSScrubberMode {
    /// A scrolling mode in which scrubber items remain fixed in place, and the item under the user’s finger is highlighted.
    ///
    /// ## Discussion
    ///
    /// When a user swipes horizontally across the scrubber, the scrubber items remain fixed in place and the item under the user’s finger highlights. At the conclusion of the touch interaction, the last-highlighted item is selected.
    ///
    /// For details on how to choose the correct mode for your app, see [Choose a scrubber touch-interaction model](https://developer.apple.com/documentation/appkit/nsscrubber#choose-a-scrubber-touch-interaction-model).
    ///
    ///
    #[doc(alias = "NSScrubberModeFixed")]
    pub const Fixed: Self = Self(0);
    /// A scrolling mode in which the scrubber scrolls as the user swipes horizontally across the scrubber.
    ///
    /// ## Discussion
    ///
    /// When a user swipes horizontally across the scrubber, the scrubber scrolls. To select an item, the user must tap or press it without moving their finger horizontally.
    ///
    /// Free-mode interaction changes depending on the value the scrubber’s [`continuous`](https://developer.apple.com/documentation/appkit/nsscrubber/iscontinuous) property. For details on how to choose the correct mode for your app, see [Choose a scrubber touch-interaction model](https://developer.apple.com/documentation/appkit/nsscrubber#choose-a-scrubber-touch-interaction-model).
    ///
    ///
    #[doc(alias = "NSScrubberModeFree")]
    pub const Free: Self = Self(1);
}

unsafe impl Encode for NSScrubberMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSScrubberMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The specified preferred alignment of items within the scrubber, when they come to rest following a user’s scrolling or paging interaction.
///
/// ## Overview
///
/// For details on how to choose the right alignment option for your app, see [Choose a scrubber touch-interaction model](https://developer.apple.com/documentation/appkit/nsscrubber#choose-a-scrubber-touch-interaction-model).
///
///
/// NSScrubberAlignment specifies the preferred alignment of elements within the control.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSScrubberAlignment(pub NSInteger);
impl NSScrubberAlignment {
    /// No preference for item alignment.
    #[doc(alias = "NSScrubberAlignmentNone")]
    pub const None: Self = Self(0);
    /// Leading alignment of items within the scrubber.
    ///
    /// ## Discussion
    ///
    /// Leading alignment depends on the writing direction of the system language. Alignment is to the left for left-to-right languages, and to the right for right-to-left languages.
    ///
    ///
    #[doc(alias = "NSScrubberAlignmentLeading")]
    pub const Leading: Self = Self(1);
    /// Trailing alignment of items within the scrubber.
    ///
    /// ## Discussion
    ///
    /// Trailing alignment depends on the writing direction of the system language. Alignment is to the right for left-to-right languages, and to the left for right-to-left languages.
    ///
    ///
    #[doc(alias = "NSScrubberAlignmentTrailing")]
    pub const Trailing: Self = Self(2);
    /// Center alignment of items within the scrubber.
    #[doc(alias = "NSScrubberAlignmentCenter")]
    pub const Center: Self = Self(3);
}

unsafe impl Encode for NSScrubberAlignment {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSScrubberAlignment {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An abstract class that provides decorative accessory views for selected and highlighted items within a scrubber control.
    ///
    /// ## Overview
    ///
    /// Choose a selection style ([`outlineOverlayStyle`](https://developer.apple.com/documentation/appkit/nsscrubberselectionstyle/outlineoverlay) or [`roundedBackgroundStyle`](https://developer.apple.com/documentation/appkit/nsscrubberselectionstyle/roundedbackground)), or create a custom selection style by subclassing [`NSScrubberSelectionStyle`](https://developer.apple.com/documentation/appkit/nsscrubberselectionstyle) and overriding [`makeSelectionView`](https://developer.apple.com/documentation/appkit/nsscrubberselectionstyle/makeselectionview()).
    ///
    ///
    /// `NSScrubberSelectionStyle`is an abstract class that provides decorative accessory views for selected and highlighted items within a NSScrubber control. Class properties provide convenient access to built-in styles. For a completely custom style, subclassers can override
    /// `-makeSelectionView`to create and configure arbitrary
    /// `NSScrubberSelectionView`subclasses.
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSScrubberSelectionStyle;
);

extern_conformance!(
    unsafe impl NSCoding for NSScrubberSelectionStyle {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSScrubberSelectionStyle {}
);

impl NSScrubberSelectionStyle {
    extern_methods!(
        #[unsafe(method(outlineOverlayStyle))]
        #[unsafe(method_family = none)]
        pub fn outlineOverlayStyle(mtm: MainThreadMarker) -> Retained<NSScrubberSelectionStyle>;

        #[unsafe(method(roundedBackgroundStyle))]
        #[unsafe(method_family = none)]
        pub fn roundedBackgroundStyle(mtm: MainThreadMarker) -> Retained<NSScrubberSelectionStyle>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(this: Allocated<Self>, coder: &NSCoder) -> Retained<Self>;

        #[cfg(all(
            feature = "NSResponder",
            feature = "NSScrubberItemView",
            feature = "NSView"
        ))]
        #[unsafe(method(makeSelectionView))]
        #[unsafe(method_family = none)]
        pub fn makeSelectionView(&self) -> Option<Retained<NSScrubberSelectionView>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSScrubberSelectionStyle {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_class!(
    /// A customizable item picker control for the Touch Bar.
    ///
    /// ## Overview
    ///
    /// On supported MacBook Pro models, you can use a scrubber (an instance of the [`NSScrubber`](https://developer.apple.com/documentation/appkit/nsscrubber) class) to provide a horizontally-oriented, item-picker control in the Touch Bar. Use a scrubber to let the user pick an item from a related collection, such as a photo from a library or a date from a date range.
    ///
    /// Refer to the following sample code projects which demonstrate how to use [`NSTouchBar`](https://developer.apple.com/documentation/appkit/nstouchbar) and related classes, including the [`NSScrubber`](https://developer.apple.com/documentation/appkit/nsscrubber) class:
    ///
    /// - [Creating and Customizing the Touch Bar](https://developer.apple.com/documentation/appkit/creating-and-customizing-the-touch-bar)
    ///
    /// - [Integrating a Toolbar and Touch Bar into Your App](https://developer.apple.com/documentation/appkit/integrating-a-toolbar-and-touch-bar-into-your-app)
    ///
    /// Each item that appears in a scrubber is a specialized view that supports selection and scrubber-appropriate decorations. The scrubber keeps track of its items by their index positions.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Take care to understand the Touch Bar term _items_. An item for a scrubber _is_ a view — an [`NSScrubberItemView`](https://developer.apple.com/documentation/appkit/nsscrubberitemview) instance — at a specific index position in the scrubber. This is analogous to a row in a table. An item for a bar (an instance of the [`NSTouchBar`](https://developer.apple.com/documentation/appkit/nstouchbar) class), by contrast, is an [`NSTouchBarItem`](https://developer.apple.com/documentation/appkit/nstouchbaritem) instance, which _has_ a view.
    ///
    ///
    ///
    /// </div>
    /// There are many classes in the scrubber API, as well as a delegate protocol, a data source protocol, and a callback-based layout API. The design pattern is reminiscent of that used for a collection view (an instance of the [`NSCollectionView`](https://developer.apple.com/documentation/appkit/nscollectionview) class). You might find it helpful to refer to the [`NSCollectionView`](https://developer.apple.com/documentation/appkit/nscollectionview) overview for background. Be aware, though of the differences. For example, while scrubbers and collection views both employ a [`makeItemWithIdentifier:owner:`](https://developer.apple.com/documentation/appkit/nsscrubber/makeitem(withidentifier:owner:)) method, and both employ a reuse queue, a scrubber is subclassed from the [`NSView`](https://developer.apple.com/documentation/appkit/nsview) class while a collection view is subclassed from the [`NSViewController`](https://developer.apple.com/documentation/appkit/nsviewcontroller) class.
    ///
    /// A scrubber employs:
    ///
    /// - The _scrubber object_ itself (an instance of the [`NSScrubber`](https://developer.apple.com/documentation/appkit/nsscrubber) class), which serves as a container view that shows a subview for each scrubber item, and which employs a reuse-queue pattern for efficiency and performance.
    ///
    /// - A _data source_ (conforming to the [`NSScrubberDataSource`](https://developer.apple.com/documentation/appkit/nsscrubberdatasource) protocol), which provides scrubber items to the scrubber, on demand, from an associated data collection in your app. Specify the data source in the scrubber’s [`dataSource`](https://developer.apple.com/documentation/appkit/nsscrubber/datasource) property
    ///
    /// - A _delegate_ (conforming to the [`NSScrubberDelegate`](https://developer.apple.com/documentation/appkit/nsscrubberdelegate) protocol), which responds to user interaction — such as with its [`didBeginInteractingWithScrubber:`](https://developer.apple.com/documentation/appkit/nsscrubberdelegate/didbegininteracting(with:)) and [`didCancelInteractingWithScrubber:`](https://developer.apple.com/documentation/appkit/nsscrubberdelegate/didcancelinteracting(with:)) methods. Specify the delegate in the scrubber’s [`delegate`](https://developer.apple.com/documentation/appkit/nsscrubber/delegate) property. You can also use the delegate to respond to the highlighting and selection of scrubber items, and to respond to changes in which items are visible in the scrubber.
    ///
    /// - A _layout_ (an instance of a subclass of the [`NSScrubberLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout) abstract class, typically the [`NSScrubberFlowLayout`](https://developer.apple.com/documentation/appkit/nsscrubberflowlayout) concrete subclass). You implement a layout to respond to calls, from the system, to return view specifications for the items to be displayed in the scrubber. The layout, in this way, assists in arranging and decorating the scrubber’s contained items, and in providing appearance changes in response to user interaction. Specify the layout in the scrubber’s [`scrubberLayout`](https://developer.apple.com/documentation/appkit/nsscrubber/scrubberlayout) property.
    ///
    /// Before learning how to use a scrubber in the Touch Bar, be sure you read the overview for the [`NSTouchBar`](https://developer.apple.com/documentation/appkit/nstouchbar) class.
    ///
    /// ### Scrubber data source and delegate
    ///
    /// A scrubber employs a data source and a delegate, using a pattern similar to that used for collection views, as follows:
    ///
    /// **Data source.** To supply items for a scrubber, implement an object that conforms to the [`NSScrubberDataSource`](https://developer.apple.com/documentation/appkit/nsscrubberdatasource) protocol and specify that object in the scrubber’s [`dataSource`](https://developer.apple.com/documentation/appkit/nsscrubber/datasource) property. There are two built-in item types, provided by the [`NSScrubberTextItemView`](https://developer.apple.com/documentation/appkit/nsscrubbertextitemview) and [`NSScrubberImageItemView`](https://developer.apple.com/documentation/appkit/nsscrubberimageitemview) concrete classes. For more on scrubber items, see [Scrubber items](https://developer.apple.com/documentation/appkit/nsscrubber#scrubber-items).
    ///
    /// The following code shows an example implementation of the [`numberOfItems`](https://developer.apple.com/documentation/appkit/nsscrubber/numberofitems) datasource method, returning the count of items displayed by the scrubber.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func numberOfItems(for scrubber: NSScrubber) -> Int {", "   return self.scrubberItems.count;", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["- (NSInteger)numberOfItemsForScrubber:(NSScrubber *)theScrubber {", "   return self.scrubberItems.count;", "}", ""], metadata: None }] }] })
    /// In addition to the count of scrubber items, you use the datasource method to provide individual items with the [`scrubber:viewForItemAtIndex:`](https://developer.apple.com/documentation/appkit/nsscrubberdatasource/scrubber(_:viewforitemat:)) method. An example implementation is shown in the following code.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func scrubber(_ scrubber: NSScrubber, viewForItemAt index: Int) -> NSScrubberItemView {    let itemView = scrubber.makeItem(withIdentifier: \"TextScrubberItemIdentifier\", owner: self) as! NSScrubberTextItemView", "    itemView.title = String(index)", "    return itemView", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["- (NSScrubberItemView *)scrubber:(NSScrubber *)theScrubber viewForItemAtIndex:(NSInteger)index {", "    NSScrubberTextItemView *itemView = [scrubber makeItemWithIdentifier:textScrubberItemIdentifier owner:self];", "    if (index < 10) {", "        itemView.title = [@(index) stringValue];", "    }", "    return itemView;", "}"], metadata: None }] }] })
    /// To optimize resource usage and performance, a scrubber employs a reuse queue that’s similar to the reuse queue for an [`NSCollectionView`](https://developer.apple.com/documentation/appkit/nscollectionview) object.
    ///
    /// **Delegate.** To respond to user interactions and to visibility, highlighting, and selection changes, implement a delegate object that conforms to the [`NSScrubberDelegate`](https://developer.apple.com/documentation/appkit/nsscrubberdelegate) protocol and specify that object in the scrubber’s [`delegate`](https://developer.apple.com/documentation/appkit/nsscrubber/delegate) property.
    ///
    /// The following code shows a minimal implementation of the [`scrubber:didSelectItemAtIndex:`](https://developer.apple.com/documentation/appkit/nsscrubberdelegate/scrubber(_:didselectitemat:)) delegate method for a scrubber.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func scrubber(_ scrubber: NSScrubber, didSelectItemAt index: Int) {", "    // Log the index value for the item the user selected", "    print(\"\\(#function) at index \\(index)\")", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["- (void)scrubber:(NSScrubber *)scrubber didSelectItemAtIndex:(NSInteger)selectedIndex {", "    // Log the index value for the item the user selected    NSLog(@\"selectedIndex = %ld\", selectedIndex);", "}"], metadata: None }] }] })
    /// ### Choose a scrubber touch-interaction model
    ///
    /// A scrubber offers many built-in permutations for touch interaction. By subclassing a scrubber, you can customize touch interaction.
    ///
    /// To specify a scrubber’s touch-interaction model, set values for the following, cooperating scrubber properties: [`mode`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.property), [`continuous`](https://developer.apple.com/documentation/appkit/nsscrubber/iscontinuous), and [`itemAlignment`](https://developer.apple.com/documentation/appkit/nsscrubber/itemalignment). Here’s how to choose the right permutation of values for these properties:
    ///
    /// **Scrolling or fixed.** Decide whether you want the scrubber to _scroll_ to track horizontal finger movement across the scrubber, or to remain _fixed_ in place as the finger moves.
    ///
    /// - For scrolling, specify the [`NSScrubberModeFree`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.enum/free) value for the scrubber’s [`mode`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.property) property.
    ///
    /// - For a fixed scrubber, specify the [`NSScrubberModeFixed`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.enum/fixed) value for the [`mode`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.property) property (this is the default value). In this case, if the user’s finger reaches the left or right edge of the scrubber view and there are items beyond the edge, the scrubber automatically scrolls to bring those items into view.
    ///
    /// **Selection style.** Decide whether you want item selection to take place only upon a deliberate selection gesture, or continuously during horizontal finger movement on the scrubber.
    ///
    /// - For deliberate selection, specify a value of [`false`](https://developer.apple.com/documentation/swift/false) for the scrubber’s [`continuous`](https://developer.apple.com/documentation/appkit/nsscrubber/iscontinuous) property (this is the default value). In _free_ (scrolling) mode, the user must then tap an item to highlight and select it. In _fixed_ (non-scrolling) mode, ending interaction with the scrubber, by lifting the finger, selects the most-recently highlighted item. However, if there is already a highlighted item before interaction starts, and the user resumes interacting with the (fixed mode) scrubber on that item, selection changes continuously, tracking the user’s finger — even though the [`continuous`](https://developer.apple.com/documentation/appkit/nsscrubber/iscontinuous) property value is [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    /// - For continuous selection, specify a value of [`true`](https://developer.apple.com/documentation/swift/true) for the [`continuous`](https://developer.apple.com/documentation/appkit/nsscrubber/iscontinuous) property. Item selection behavior then depends on the [`mode`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.property) and [`itemAlignment`](https://developer.apple.com/documentation/appkit/nsscrubber/itemalignment) property values, as described in [Position-based scrubber item selection](https://developer.apple.com/documentation/appkit/nsscrubber#position-based-scrubber-item-selection).
    ///
    /// **Item alignment.** The setting in the scrubber’s [`itemAlignment`](https://developer.apple.com/documentation/appkit/nsscrubber/itemalignment) property affects two things: 1) item highlighting and selection, and 2) the resting position of scrubber items after manual or automatic scrolling. Available values for this property are [`NSScrubberAlignmentLeading`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/leading), [`NSScrubberAlignmentCenter`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/center), [`NSScrubberAlignmentTrailing`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/trailing), and [`NSScrubberAlignmentNone`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/none). See the [`NSScrubberAlignment`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment) enumeration for details on how these constants work.
    ///
    /// Your choices for scrolling, selection, and alignment jointly impact highlighting and selection behavior. For details on highlighting and selection, see [Position-based scrubber item selection](https://developer.apple.com/documentation/appkit/nsscrubber#position-based-scrubber-item-selection). Your choice for alignment also impacts scrubber-item resting-position behavior following a scroll interaction. For details on resting position, see [Scrubber item resting position](https://developer.apple.com/documentation/appkit/nsscrubber#scrubber-item-resting-position).
    ///
    /// ### Position-based scrubber item selection
    ///
    /// In free mode with continuous selection style (the [`mode`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.property) property value is [`NSScrubberModeFree`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.enum/free) and the [`continuous`](https://developer.apple.com/documentation/appkit/nsscrubber/iscontinuous) property value is `YES` for this configuration), the scrubber item on the alignment axis is automatically highlighted and selected. The _alignment axis_ is the left edge, right edge, or center of the scrubber, as you specify by setting the value of the [`itemAlignment`](https://developer.apple.com/documentation/appkit/nsscrubber/itemalignment) property using constants from the [`NSScrubberAlignment`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment) enumeration. Specifying an alignment axis of [`NSScrubberAlignmentNone`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/none) is equivalent to a value of [`NSScrubberAlignmentCenter`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/center) for position-based item selection.
    ///
    /// In free mode with deliberate selection style (the [`mode`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.property) property value is [`NSScrubberModeFree`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.enum/free) and the [`continuous`](https://developer.apple.com/documentation/appkit/nsscrubber/iscontinuous) property value is `NO` for this configuration), the system ignores the [`itemAlignment`](https://developer.apple.com/documentation/appkit/nsscrubber/itemalignment) property value in terms of item selection.
    ///
    /// In fixed mode (the [`mode`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.property) property value is [`NSScrubberModeFixed`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.enum/fixed) for this configuration), the system ignores the [`itemAlignment`](https://developer.apple.com/documentation/appkit/nsscrubber/itemalignment) property value in terms of item selection — no matter which value you specify for the [`continuous`](https://developer.apple.com/documentation/appkit/nsscrubber/iscontinuous) property.
    ///
    /// ### Scrubber item resting position
    ///
    /// The value you provide in the [`itemAlignment`](https://developer.apple.com/documentation/appkit/nsscrubber/itemalignment) property specifies the automatic scrubber item resting position that follows manual or automatic scrolling. (This value also affects item highlighting and selection, as described in [Choose a scrubber touch-interaction model](https://developer.apple.com/documentation/appkit/nsscrubber#choose-a-scrubber-touch-interaction-model).) The system respects your setting for resting position irrespective of the values of the [`mode`](https://developer.apple.com/documentation/appkit/nsscrubber/mode-swift.property) and [`continuous`](https://developer.apple.com/documentation/appkit/nsscrubber/iscontinuous) properties.
    ///
    /// Specifically:
    ///
    /// - [`NSScrubberAlignmentLeading`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/leading) — In a left-to-right language, the scrubber comes to rest, following manual or automatic scrolling, so that the left edge of the leftmost scrubber item is coincident with the left edge of the scrubber.
    ///
    /// - [`NSScrubberAlignmentCenter`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/center) — The scrubber comes to rest, following manual or automatic scrolling, so that a scrubber item is perfectly centered in the scrubber.
    ///
    /// - [`NSScrubberAlignmentTrailing`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/trailing) — In a left-to-right language, the scrubber comes to rest, following manual or automatic scrolling, so that the right edge of the rightmost scrubber item is coincident with the right edge of the scrubber.
    ///
    /// - [`NSScrubberAlignmentNone`](https://developer.apple.com/documentation/appkit/nsscrubber/alignment/none) — Following manual or automatic scrolling, the scrubber comes to rest without attempting to align any scrubber item.
    ///
    /// ### Scrubber layout
    ///
    /// A scrubber configures the views for its items with the help of two classes, [`NSScrubberLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout) and [`NSScrubberLayoutAttributes`](https://developer.apple.com/documentation/appkit/nsscrubberlayoutattributes), as described in this section.
    ///
    /// #### Layout implementation
    ///
    /// A _layout_ is a concrete implementation of the [`NSScrubberLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout) abstract class. AppKit provides two concrete, preconfigured layout subclasses: [`NSScrubberFlowLayout`](https://developer.apple.com/documentation/appkit/nsscrubberflowlayout) and [`NSScrubberProportionalLayout`](https://developer.apple.com/documentation/appkit/nsscrubberproportionallayout). If you use one of these built-in layout types, there’s no additional layout code to write, apart from adding your choice of built-in layout to the scrubber’s [`scrubberLayout`](https://developer.apple.com/documentation/appkit/nsscrubber/scrubberlayout) property. This Swift example shows this simple step for the flow layout:
    ///
    /// ```swift
    /// myInformationScrubber.scrubberLayout = NSScrubberFlowLayout()
    /// ```
    ///
    /// To create a custom layout, subclass the [`NSScrubberLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout) class and implement its callback methods. Unlike a view delegate (such as used for a table view), which provides _views_ on demand, scrubber layout callbacks provide _view specifications_ on demand. Using these callbacks, you specify:
    ///
    /// - Scrubber item geometry
    ///
    /// - Scrubber item appearance
    ///
    /// - Layout life cycle for state management
    ///
    /// Specify the overall visual dimensions of a custom scrubber when you create it, using the [`initWithFrame:`](https://developer.apple.com/documentation/appkit/nsscrubber/init(frame:)) or [`initWithCoder:`](https://developer.apple.com/documentation/appkit/nsscrubber/init(coder:)) initializer, or by using Interface Builder.
    ///
    /// Return the total width and height for the elements in a custom scrubber, including those not currently visible, using the [`scrubberContentSize`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/scrubbercontentsize) property in your layout. Specify height and width in points. To use the standard height, specify a value of `30`.
    ///
    /// Specify the geometry and appearance for items in your custom scrubber, using the two required callback methods that each return instances of the [`NSScrubberLayoutAttributes`](https://developer.apple.com/documentation/appkit/nsscrubberlayoutattributes) class. The system calls one or another of these methods, as it needs to, as a user interacts with a layout’s owning scrubber:
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Callback method" }] }], [Paragraph { inline_content: [Text { text: "How to use" }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.appkit/documentation/AppKit/NSScrubberLayout/layoutAttributesForItem(at:)", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Return " }, Emphasis { inline_content: [Text { text: "one" }] }, Text { text: " " }, Reference { identifier: "doc://com.apple.appkit/documentation/AppKit/NSScrubberLayoutAttributes", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " instance that specifies the view attribute values for the one scrubber item at the index position requested by the system in the method call." }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.appkit/documentation/AppKit/NSScrubberLayout/layoutAttributesForItems(in:)", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Return the " }, Emphasis { inline_content: [Text { text: "set of" }] }, Text { text: " " }, Reference { identifier: "doc://com.apple.appkit/documentation/AppKit/NSScrubberLayoutAttributes", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " instances that, together, specify the per-item view attributes for the items within the visible rectangle requested by the system in the method call. The set you return must contain one layout attributes object for each item in the rectangle." }] }]]], alignments: None, metadata: None })
    /// You can explicitly invalidate a layout by calling the [`invalidateLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/invalidatelayout()) method. Do this whenever your app changes a scrubber’s information in a way that requires a layout update. For example, if you change the text shown in one or more items, invalidate the layout.
    ///
    /// You can specify layout life cycle in terms of the conditions under which a layout should be automatically invalidated, such as when the user selects something different in the layout’s owning scrubber. The API for automatic invalidation consists of the following two properties and one method:
    ///
    /// - [`shouldInvalidateLayoutForSelectionChange`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/shouldinvalidatelayoutforselectionchange)
    ///
    /// - [`shouldInvalidateLayoutForHighlightChange`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/shouldinvalidatelayoutforhighlightchange)
    ///
    /// - [`shouldInvalidateLayoutForChangeFromVisibleRect:toVisibleRect:`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/shouldinvalidatelayoutforchange(fromvisiblerect:tovisiblerect:))
    ///
    /// For example, if you design a scrubber’s layout characteristics to depend on which of its items is selected by the user, return a value of [`true`](https://developer.apple.com/documentation/swift/true) from the scrubber’s [`shouldInvalidateLayoutForSelectionChange`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/shouldinvalidatelayoutforselectionchange) method.A _layout attributes_ object is an instance of the [`NSScrubberLayoutAttributes`](https://developer.apple.com/documentation/appkit/nsscrubberlayoutattributes) class, which you configure to describe the view for a single item. The class offers the following built-in attributes for you to work with:
    ///
    /// - [`itemIndex`](https://developer.apple.com/documentation/appkit/nsscrubberlayoutattributes/itemindex) — The item’s index position within the scrubber
    ///
    /// - [`frame`](https://developer.apple.com/documentation/appkit/nsscrubberlayoutattributes/frame) — The item’s frame rectangle
    ///
    /// - [`alpha`](https://developer.apple.com/documentation/appkit/nsscrubberlayoutattributes/alpha) — The item’s transparency
    ///
    /// You can specify additional item attributes by subclassing the [`NSScrubberLayoutAttributes`](https://developer.apple.com/documentation/appkit/nsscrubberlayoutattributes) class. For example, you could specify a geometric transform attribute.
    ///
    /// If you’re using a custom [`NSScrubberLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout) subclass, provide an implementation for the [`invalidateLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/invalidatelayout()) method to clear any custom layout state, such as by discarding cached data.
    ///
    /// #### Prepare for redrawing
    ///
    /// The flip side of layout invalidation (as described in [Layout implementation](https://developer.apple.com/documentation/appkit/nsscrubber#layout-implementation)) is preparation for redrawing, which you perform in a layout’s [`prepareLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/prepare()) method. The goal of layout preparation is to optimize performance. A scrubber calls the [`prepareLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/prepare()) method exactly once between invalidation and redrawing. Complete as much one-time, up-front layout work as you can, in advance of redrawing, in this step. For example, your [`prepareLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/prepare()) implementation should perform initial layout calculations and should fill caches needed during drawing.
    ///
    /// After the [`prepareLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/prepare()) method returns, the system updates the scrubber view hierarchy with repeated calls to three [`NSScrubberLayout`](https://developer.apple.com/documentation/appkit/nsscrubberlayout) methods: [`layoutAttributesForItemAtIndex:`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/layoutattributesforitem(at:)), [`layoutAttributesForItemsInRect:`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/layoutattributesforitems(in:)), and [`scrubberContentSize`](https://developer.apple.com/documentation/appkit/nsscrubberlayout/scrubbercontentsize). Implement these methods to provide return values as quickly as possible, taking advantage of the work you did during layout preparation.
    ///
    /// ### Scrubber items
    ///
    /// The view that represents a scrubber item is provided by your data source object, using the [`scrubber:viewForItemAtIndex:`](https://developer.apple.com/documentation/appkit/nsscrubberdatasource/scrubber(_:viewforitemat:)) protocol method. AppKit provides two purpose-built view classes you can use, both of which are concrete subclasses of the abstract [`NSScrubberItemView`](https://developer.apple.com/documentation/appkit/nsscrubberitemview) class:
    ///
    /// - [`NSScrubberImageItemView`](https://developer.apple.com/documentation/appkit/nsscrubberimageitemview) has `image`, [`imageView`](https://developer.apple.com/documentation/appkit/nsscrubberimageitemview/imageview), and [`imageAlignment`](https://developer.apple.com/documentation/appkit/nsscrubberimageitemview/imagealignment) properties
    ///
    /// - [`NSScrubberTextItemView`](https://developer.apple.com/documentation/appkit/nsscrubbertextitemview) has [`textField`](https://developer.apple.com/documentation/appkit/nsscrubbertextitemview/textfield) and `title` properties
    ///
    /// To create a custom item, subclass these or their abstract superclass, [`NSScrubberItemView`](https://developer.apple.com/documentation/appkit/nsscrubberitemview).
    ///
    /// ### Scrubbers and the responder chain
    ///
    /// To show a scrubber, associate it with an [`NSTouchBar`](https://developer.apple.com/documentation/appkit/nstouchbar) object (adding it, as the view for a custom item or popover item, to the bar) and then associate the bar with the appropriate responder object in your app. The system then shows the scrubber in the Touch Bar only at appropriate times. For more information on bars and the responder chain, read the overview for the [`NSTouchBar`](https://developer.apple.com/documentation/appkit/nstouchbar) class.
    ///
    /// ### Choose between a scrubber and a scroll view
    ///
    /// When choosing between a scrubber and a scroll view, use a scrubber unless the amount of content, or the nature of your content, doesn’t work well in a scrubber. Scrubber interaction is optimized for the Touch Bar, typically making a scrubber the better option for letting the user pick from among several choices, such as dates in a calendar.
    ///
    ///
    /// `NSScrubber`is a control designed for the NSTouchBar environment.
    ///
    /// `NSScrubber`arranges a finite number of "items" (represented by views of type
    /// `NSScrubberItemView`) according to a layout object (see
    /// `NSScrubberLayout`), and provides several methods for navigating and selecting those items.
    ///
    /// Clients provide data to
    /// `NSScrubber`via a data source object (see the
    /// `NSScrubberDataSource`protocol) and react to user interaction via a delegate object (see the
    /// `NSScrubberDelegate`protocol).
    #[unsafe(super(NSView, NSResponder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "NSResponder", feature = "NSView"))]
    pub struct NSScrubber;
);

#[cfg(all(
    feature = "NSAccessibilityProtocols",
    feature = "NSResponder",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSAccessibility for NSScrubber {}
);

#[cfg(all(
    feature = "NSAccessibilityProtocols",
    feature = "NSResponder",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSAccessibilityElementProtocol for NSScrubber {}
);

#[cfg(all(feature = "NSAnimation", feature = "NSResponder", feature = "NSView"))]
extern_conformance!(
    unsafe impl NSAnimatablePropertyContainer for NSScrubber {}
);

#[cfg(all(feature = "NSAppearance", feature = "NSResponder", feature = "NSView"))]
extern_conformance!(
    unsafe impl NSAppearanceCustomization for NSScrubber {}
);

#[cfg(all(feature = "NSResponder", feature = "NSView"))]
extern_conformance!(
    unsafe impl NSCoding for NSScrubber {}
);

#[cfg(all(feature = "NSDragging", feature = "NSResponder", feature = "NSView"))]
extern_conformance!(
    unsafe impl NSDraggingDestination for NSScrubber {}
);

#[cfg(all(feature = "NSResponder", feature = "NSView"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSScrubber {}
);

#[cfg(all(
    feature = "NSResponder",
    feature = "NSUserInterfaceItemIdentification",
    feature = "NSView"
))]
extern_conformance!(
    unsafe impl NSUserInterfaceItemIdentification for NSScrubber {}
);

#[cfg(all(feature = "NSResponder", feature = "NSView"))]
impl NSScrubber {
    extern_methods!(
        #[unsafe(method(dataSource))]
        #[unsafe(method_family = none)]
        pub fn dataSource(&self) -> Option<Retained<ProtocolObject<dyn NSScrubberDataSource>>>;

        /// Setter for [`dataSource`][Self::dataSource].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDataSource:))]
        #[unsafe(method_family = none)]
        pub fn setDataSource(&self, data_source: Option<&ProtocolObject<dyn NSScrubberDataSource>>);

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self) -> Option<Retained<ProtocolObject<dyn NSScrubberDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn NSScrubberDelegate>>);

        #[cfg(feature = "NSScrubberLayout")]
        #[unsafe(method(scrubberLayout))]
        #[unsafe(method_family = none)]
        pub fn scrubberLayout(&self) -> Retained<NSScrubberLayout>;

        #[cfg(feature = "NSScrubberLayout")]
        /// Setter for [`scrubberLayout`][Self::scrubberLayout].
        #[unsafe(method(setScrubberLayout:))]
        #[unsafe(method_family = none)]
        pub fn setScrubberLayout(&self, scrubber_layout: &NSScrubberLayout);

        /// Returns the number of items represented by the scrubber control.
        #[unsafe(method(numberOfItems))]
        #[unsafe(method_family = none)]
        pub fn numberOfItems(&self) -> NSInteger;

        /// The index of the currently highlighted item within the control. If there is no highlighted item, the value of this property is (-1).
        #[unsafe(method(highlightedIndex))]
        #[unsafe(method_family = none)]
        pub fn highlightedIndex(&self) -> NSInteger;

        /// The index of the selected item within the control. If there is no selected item, the value of this property is (-1). Setting this property through the animator proxy will animate the selection change. Programmatic selection changes do not trigger delegate callbacks.
        #[unsafe(method(selectedIndex))]
        #[unsafe(method_family = none)]
        pub fn selectedIndex(&self) -> NSInteger;

        /// Setter for [`selectedIndex`][Self::selectedIndex].
        #[unsafe(method(setSelectedIndex:))]
        #[unsafe(method_family = none)]
        pub fn setSelectedIndex(&self, selected_index: NSInteger);

        /// Describes the interaction mode for the scrubber control. See the
        /// `NSScrubberMode`enumeration for a list of possible values. The default value is
        /// `NSScrubberModeFixed.`
        #[unsafe(method(mode))]
        #[unsafe(method_family = none)]
        pub fn mode(&self) -> NSScrubberMode;

        /// Setter for [`mode`][Self::mode].
        #[unsafe(method(setMode:))]
        #[unsafe(method_family = none)]
        pub fn setMode(&self, mode: NSScrubberMode);

        /// If the value of
        /// `itemAlignment`is not
        /// `NSScrubberAlignmentNone,`the scrubber will ensure that some item rests at the preferred alignment within the control following a scrolling or paging interaction. The default value is
        /// `NSScrubberAlignmentNone.`
        #[unsafe(method(itemAlignment))]
        #[unsafe(method_family = none)]
        pub fn itemAlignment(&self) -> NSScrubberAlignment;

        /// Setter for [`itemAlignment`][Self::itemAlignment].
        #[unsafe(method(setItemAlignment:))]
        #[unsafe(method_family = none)]
        pub fn setItemAlignment(&self, item_alignment: NSScrubberAlignment);

        /// When
        /// `continuous`is
        /// `YES,`panning over the control in
        /// `NSScrubberModeFixed`will immediately select the item under the user's finger, and scrolling in
        /// `NSScrubberModeFree`will continuously select items as they pass through the current
        /// `itemAlignment.`The default is
        /// `NO.`
        #[unsafe(method(isContinuous))]
        #[unsafe(method_family = none)]
        pub fn isContinuous(&self) -> bool;

        /// Setter for [`isContinuous`][Self::isContinuous].
        #[unsafe(method(setContinuous:))]
        #[unsafe(method_family = none)]
        pub fn setContinuous(&self, continuous: bool);

        /// When
        /// `floatsSelectionViews`is
        /// `YES,`the selection decorations provided by
        /// `selectionBackgroundStyle`and
        /// `selectionOverlayStyle`will smoothly float between selected items, rather than animating their entrance/exit in-place. The default is
        /// `NO.`
        #[unsafe(method(floatsSelectionViews))]
        #[unsafe(method_family = none)]
        pub fn floatsSelectionViews(&self) -> bool;

        /// Setter for [`floatsSelectionViews`][Self::floatsSelectionViews].
        #[unsafe(method(setFloatsSelectionViews:))]
        #[unsafe(method_family = none)]
        pub fn setFloatsSelectionViews(&self, floats_selection_views: bool);

        /// Specifies a style of decoration to place behind items that are selected and/or highlighted. The default value is
        /// `nil,`indicating no built-in background decoration.
        #[unsafe(method(selectionBackgroundStyle))]
        #[unsafe(method_family = none)]
        pub fn selectionBackgroundStyle(&self) -> Option<Retained<NSScrubberSelectionStyle>>;

        /// Setter for [`selectionBackgroundStyle`][Self::selectionBackgroundStyle].
        #[unsafe(method(setSelectionBackgroundStyle:))]
        #[unsafe(method_family = none)]
        pub fn setSelectionBackgroundStyle(
            &self,
            selection_background_style: Option<&NSScrubberSelectionStyle>,
        );

        /// Specifies a style of decoration to place above items that are selected and/or highlighted. The default value is
        /// `nil,`indicating no built-in overlay decoration.
        #[unsafe(method(selectionOverlayStyle))]
        #[unsafe(method_family = none)]
        pub fn selectionOverlayStyle(&self) -> Option<Retained<NSScrubberSelectionStyle>>;

        /// Setter for [`selectionOverlayStyle`][Self::selectionOverlayStyle].
        #[unsafe(method(setSelectionOverlayStyle:))]
        #[unsafe(method_family = none)]
        pub fn setSelectionOverlayStyle(
            &self,
            selection_overlay_style: Option<&NSScrubberSelectionStyle>,
        );

        /// If
        /// `showsArrowButtons`is
        /// `YES,`the control provides leading and trailing arrow buttons. Tapping an arrow button moves the selection index by one element; pressing and holding repeatedly moves the selection. The default is
        /// `NO.`
        #[unsafe(method(showsArrowButtons))]
        #[unsafe(method_family = none)]
        pub fn showsArrowButtons(&self) -> bool;

        /// Setter for [`showsArrowButtons`][Self::showsArrowButtons].
        #[unsafe(method(setShowsArrowButtons:))]
        #[unsafe(method_family = none)]
        pub fn setShowsArrowButtons(&self, shows_arrow_buttons: bool);

        /// If
        /// `showsAdditionalContentIndicators`is
        /// `YES,`the control will draw a fade effect to indicate that there is additional unscrolled content. The default is
        /// `NO.`
        #[unsafe(method(showsAdditionalContentIndicators))]
        #[unsafe(method_family = none)]
        pub fn showsAdditionalContentIndicators(&self) -> bool;

        /// Setter for [`showsAdditionalContentIndicators`][Self::showsAdditionalContentIndicators].
        #[unsafe(method(setShowsAdditionalContentIndicators:))]
        #[unsafe(method_family = none)]
        pub fn setShowsAdditionalContentIndicators(
            &self,
            shows_additional_content_indicators: bool,
        );

        #[cfg(feature = "NSColor")]
        /// If set,
        /// `backgroundColor`is displayed behind the scrubber content. The background color is suppressed if the scrubber is assigned a non-nil
        /// `backgroundView.`The default value is
        /// `nil.`
        #[unsafe(method(backgroundColor))]
        #[unsafe(method_family = none)]
        pub fn backgroundColor(&self) -> Option<Retained<NSColor>>;

        #[cfg(feature = "NSColor")]
        /// Setter for [`backgroundColor`][Self::backgroundColor].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBackgroundColor:))]
        #[unsafe(method_family = none)]
        pub fn setBackgroundColor(&self, background_color: Option<&NSColor>);

        /// If non-nil, the
        /// `backgroundView`is displayed below the scrubber content. The view's layout is managed by
        /// `NSScrubber`to match the content area. If this property is non-nil, the
        /// `backgroundColor`property has no effect. The default value is
        /// `nil.`
        #[unsafe(method(backgroundView))]
        #[unsafe(method_family = none)]
        pub fn backgroundView(&self) -> Option<Retained<NSView>>;

        /// Setter for [`backgroundView`][Self::backgroundView].
        #[unsafe(method(setBackgroundView:))]
        #[unsafe(method_family = none)]
        pub fn setBackgroundView(&self, background_view: Option<&NSView>);

        #[unsafe(method(initWithFrame:))]
        #[unsafe(method_family = init)]
        pub fn initWithFrame(this: Allocated<Self>, frame_rect: NSRect) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(this: Allocated<Self>, coder: &NSCoder) -> Retained<Self>;

        /// Invalidate all data within the scrubber control, triggering a reload of all content, and clearing the current selection.
        #[unsafe(method(reloadData))]
        #[unsafe(method_family = none)]
        pub fn reloadData(&self);

        #[cfg(feature = "block2")]
        /// Updates inside the
        /// `performSequentialBatchUpdates`block are processed and displayed all at once, including insertion, removal, moving, reloading items, and changing the selected index. Changes are performed iteratively using the same semantics as
        /// `NSMutableArray.`NSScrubber expects its dataSource to reflect the changes made inside
        /// `-performSequentialBatchUpdates:`immediately after the
        /// `updateBlock`finishes executing.
        #[unsafe(method(performSequentialBatchUpdates:))]
        #[unsafe(method_family = none)]
        pub fn performSequentialBatchUpdates(&self, update_block: &block2::DynBlock<dyn Fn() + '_>);

        /// Inserts new items at the specified indexes. NSScrubber will request views for each new index from the
        /// `dataSource.`This method uses the same semantics as
        /// `NSMutableArray;`each index in the set specifies the destination index after all previous insertions have occurred. Therefore, an NSIndexSet of [1,2,3] will result in three new contiguous items.
        #[unsafe(method(insertItemsAtIndexes:))]
        #[unsafe(method_family = none)]
        pub fn insertItemsAtIndexes(&self, indexes: &NSIndexSet);

        /// Removes the items at the specified indexes. This method uses the same semantics as
        /// `NSMutableArray.`
        #[unsafe(method(removeItemsAtIndexes:))]
        #[unsafe(method_family = none)]
        pub fn removeItemsAtIndexes(&self, indexes: &NSIndexSet);

        /// Reloads the items at the specified indexes. NSScrubber will request new views for each item and smoothly crossfade between them before discarding the original views.
        #[unsafe(method(reloadItemsAtIndexes:))]
        #[unsafe(method_family = none)]
        pub fn reloadItemsAtIndexes(&self, indexes: &NSIndexSet);

        /// Moves an item from one index to another.
        /// `oldIndex`refers to the item's index prior to the movement, whereas
        /// `newIndex`refers to the item's final location.
        #[unsafe(method(moveItemAtIndex:toIndex:))]
        #[unsafe(method_family = none)]
        pub fn moveItemAtIndex_toIndex(&self, old_index: NSInteger, new_index: NSInteger);

        /// Scrolls an item to a given alignment within the control. If
        /// `NSScrubberAlignmentNone`is provided, then the control scrolls the minimum amount necessary to make the item visible. Scrolling is animated if called on the animator proxy.
        #[unsafe(method(scrollItemAtIndex:toAlignment:))]
        #[unsafe(method_family = none)]
        pub fn scrollItemAtIndex_toAlignment(
            &self,
            index: NSInteger,
            alignment: NSScrubberAlignment,
        );

        #[cfg(feature = "NSScrubberItemView")]
        /// Returns the
        /// `NSScrubberItemView`for the given index, if one currently exists; returns
        /// `nil`otherwise.
        #[unsafe(method(itemViewForItemAtIndex:))]
        #[unsafe(method_family = none)]
        pub fn itemViewForItemAtIndex(
            &self,
            index: NSInteger,
        ) -> Option<Retained<NSScrubberItemView>>;

        #[cfg(feature = "NSUserInterfaceItemIdentification")]
        /// Registers a
        /// `NSScrubberItemView`class to be instantiated for the given
        /// `itemIdentifier.`Raises an exception if
        /// `itemViewClass`is not a subclass of
        /// `NSScrubberItemView.`Passing
        /// `nil`for
        /// `itemViewClass`removes a previous registration. Registrations made through this method do not persist through NSCoding.
        ///
        /// # Safety
        ///
        /// `item_view_class` probably has further requirements.
        #[unsafe(method(registerClass:forItemIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerClass_forItemIdentifier(
            &self,
            item_view_class: Option<&AnyClass>,
            item_identifier: &NSUserInterfaceItemIdentifier,
        );

        #[cfg(all(feature = "NSNib", feature = "NSUserInterfaceItemIdentification"))]
        /// Register a nib to be instantiated for the given
        /// `itemIdentifier.`The nib must contain a top-level object which is a subclass of NSScrubberItemView; otherwise,
        /// `-makeItemWithIdentifier:`may return
        /// `nil`for this identifier. Passing
        /// `nil`for
        /// `nib`removes a previous registration.
        #[unsafe(method(registerNib:forItemIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn registerNib_forItemIdentifier(
            &self,
            nib: Option<&NSNib>,
            item_identifier: &NSUserInterfaceItemIdentifier,
        );

        #[cfg(all(
            feature = "NSScrubberItemView",
            feature = "NSUserInterfaceItemIdentification"
        ))]
        /// Creates or reuses a
        /// `NSScrubberItemView`corresponding to the provided
        /// `itemIdentifier.``NSScrubber`searches, in order: the reuse queue, the list of registered classes, and then the list of registered nibs. If the reuse queue is empty, and there is no Class or Interface Builder archive registered for the
        /// `itemIdentifier,`this method returns
        /// `nil.`
        ///
        /// # Safety
        ///
        /// `owner` should be of the correct type.
        #[unsafe(method(makeItemWithIdentifier:owner:))]
        #[unsafe(method_family = none)]
        pub unsafe fn makeItemWithIdentifier_owner(
            &self,
            item_identifier: &NSUserInterfaceItemIdentifier,
            owner: Option<&AnyObject>,
        ) -> Option<Retained<NSScrubberItemView>>;
    );
}

/// Methods declared on superclass `NSResponder`.
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
impl NSScrubber {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
impl NSScrubber {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}
