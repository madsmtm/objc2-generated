//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// Layout priority used to indicate the relative importance of constraints, allowing Auto Layout to make appropriate tradeoffs when satisfying the constraints of the system as a whole.
// NS_TYPED_EXTENSIBLE_ENUM
pub type NSLayoutPriority = c_float;

/// A required constraint.
///
/// ## Discussion
///
/// Do not specify a layout constraint that exceeds this number.
///
///
pub static NSLayoutPriorityRequired: NSLayoutPriority = 1000 as _;

/// Priority level with which a button resists compressing its content.
///
/// ## Discussion
///
/// Note that the level is higher than [`NSLayoutPriorityWindowSizeStayPut`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/priority-swift.struct/windowsizestayput). This means dragging to resize a window will not make buttons clip, rather the window frame is constrained.
///
///
pub static NSLayoutPriorityDefaultHigh: NSLayoutPriority = 750 as _;

/// Appropriate priority level for a drag that may end up resizing the window.
///
/// ## Discussion
///
/// This drag does not need to explicitly resize the window. The user might be dragging around window contents, and it might be desirable for the window get bigger to accommodate those contents.
///
///
pub static NSLayoutPriorityDragThatCanResizeWindow: NSLayoutPriority = 510 as _;

/// Priority level for the window’s current size.
///
/// ## Discussion
///
/// It’s generally not appropriate to make a constraint at exactly this priority. You want to be higher or lower. Constraints with higher priorities can adjust the window’s size. Constraints with lower priorities must be fulfilled using the current window size.
///
///
pub static NSLayoutPriorityWindowSizeStayPut: NSLayoutPriority = 500 as _;

/// Priority level at which a split view divider, say, is dragged.
///
/// ## Discussion
///
/// A constraint with this priority cannot resize the window.
///
///
pub static NSLayoutPriorityDragThatCannotResizeWindow: NSLayoutPriority = 490 as _;

/// Priority level at which a button hugs its contents horizontally.
pub static NSLayoutPriorityDefaultLow: NSLayoutPriority = 250 as _;

/// When you send a [`fittingSize`](https://developer.apple.com/documentation/appkit/nsview/fittingsize) message to a view, the smallest size that is large enough for the view’s contents is computed.
///
/// ## Discussion
///
/// This is the priority level with which the view wants to be as small as possible in that computation. It’s quite low. It is generally not appropriate to make a constraint at exactly this priority. You want to be higher or lower.
///
///
pub static NSLayoutPriorityFittingSizeCompression: NSLayoutPriority = 50 as _;

/// The layout constraint orientation, either horizontal or vertical, that the constraint uses to enforce layout between objects.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSLayoutConstraintOrientation(pub NSInteger);
impl NSLayoutConstraintOrientation {
    /// The constraint orientation applied to laying out the horizontal relationship between objects.
    #[doc(alias = "NSLayoutConstraintOrientationHorizontal")]
    pub const Horizontal: Self = Self(0);
    /// The constraint orientation applied to laying out the vertical relationship between objects.
    #[doc(alias = "NSLayoutConstraintOrientationVertical")]
    pub const Vertical: Self = Self(1);
}

unsafe impl Encode for NSLayoutConstraintOrientation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSLayoutConstraintOrientation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The relation between the first attribute and the modified second attribute in a constraint.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSLayoutRelation(pub NSInteger);
impl NSLayoutRelation {
    /// The constraint requires the first attribute to be less than or equal to the modified second attribute.
    #[doc(alias = "NSLayoutRelationLessThanOrEqual")]
    pub const LessThanOrEqual: Self = Self(-1);
    /// The constraint requires the first attribute to be exactly equal to the modified second attribute.
    #[doc(alias = "NSLayoutRelationEqual")]
    pub const Equal: Self = Self(0);
    /// The constraint requires the first attribute to be greater than or equal to the modified second attribute.
    #[doc(alias = "NSLayoutRelationGreaterThanOrEqual")]
    pub const GreaterThanOrEqual: Self = Self(1);
}

unsafe impl Encode for NSLayoutRelation {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSLayoutRelation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The part of the object’s visual representation that should be used to get the value for the constraint.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSLayoutAttribute(pub NSInteger);
impl NSLayoutAttribute {
    /// The left side of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeLeft")]
    pub const Left: Self = Self(1);
    /// The right side of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeRight")]
    pub const Right: Self = Self(2);
    /// The top of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeTop")]
    pub const Top: Self = Self(3);
    /// The bottom of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeBottom")]
    pub const Bottom: Self = Self(4);
    /// The leading edge of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeLeading")]
    pub const Leading: Self = Self(5);
    /// The trailing edge of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeTrailing")]
    pub const Trailing: Self = Self(6);
    /// The width of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeWidth")]
    pub const Width: Self = Self(7);
    /// The height of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeHeight")]
    pub const Height: Self = Self(8);
    /// The center along the x-axis of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeCenterX")]
    pub const CenterX: Self = Self(9);
    /// The center along the y-axis of the object’s alignment rectangle.
    #[doc(alias = "NSLayoutAttributeCenterY")]
    pub const CenterY: Self = Self(10);
    /// The object’s baseline.
    ///
    /// ## Discussion
    ///
    /// For objects with more than one line of text, this is the baseline for the bottommost line of text.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeLastBaseline")]
    pub const LastBaseline: Self = Self(11);
    #[doc(alias = "NSLayoutAttributeBaseline")]
    pub const Baseline: Self = Self(NSLayoutAttribute::LastBaseline.0);
    /// The object’s baseline.
    ///
    /// ## Discussion
    ///
    /// For objects with more than one line of text, this is the baseline for the topmost line of text.
    ///
    ///
    #[doc(alias = "NSLayoutAttributeFirstBaseline")]
    pub const FirstBaseline: Self = Self(12);
    /// A placeholder value for indicating that the constraint’s second item and second attribute aren’t used in any calculations.
    ///
    /// ## Discussion
    ///
    /// Use this value when creating a constraint that assigns a constant to an attribute. For example, `item1.height >= 40`. If a constraint only has one item, set the second item to `nil`, and set the second attribute to [`NSLayoutAttributeNotAnAttribute`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/notanattribute).
    ///
    ///
    #[doc(alias = "NSLayoutAttributeNotAnAttribute")]
    pub const NotAnAttribute: Self = Self(0);
}

unsafe impl Encode for NSLayoutAttribute {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSLayoutAttribute {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A bit mask that specifies both a part of an interface element to align and a direction for the alignment between two interface elements.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSLayoutFormatOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSLayoutFormatOptions: NSUInteger {
/// Align all specified interface elements using [`NSLayoutAttributeLeft`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/left) on each.
        #[doc(alias = "NSLayoutFormatAlignAllLeft")]
        const AlignAllLeft = 1<<NSLayoutAttribute::Left.0;
/// Align all specified interface elements using [`NSLayoutAttributeRight`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/right) on each.
        #[doc(alias = "NSLayoutFormatAlignAllRight")]
        const AlignAllRight = 1<<NSLayoutAttribute::Right.0;
/// Align all specified interface elements using [`NSLayoutAttributeTop`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/top) on each.
        #[doc(alias = "NSLayoutFormatAlignAllTop")]
        const AlignAllTop = 1<<NSLayoutAttribute::Top.0;
/// Align all specified interface elements using [`NSLayoutAttributeBottom`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/bottom) on each.
        #[doc(alias = "NSLayoutFormatAlignAllBottom")]
        const AlignAllBottom = 1<<NSLayoutAttribute::Bottom.0;
/// Align all specified interface elements using [`NSLayoutAttributeLeading`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/leading) on each.
        #[doc(alias = "NSLayoutFormatAlignAllLeading")]
        const AlignAllLeading = 1<<NSLayoutAttribute::Leading.0;
/// Align all specified interface elements using [`NSLayoutAttributeTrailing`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/trailing) on each.
        #[doc(alias = "NSLayoutFormatAlignAllTrailing")]
        const AlignAllTrailing = 1<<NSLayoutAttribute::Trailing.0;
/// Align all specified interface elements using [`NSLayoutAttributeCenterX`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/centerx) on each.
        #[doc(alias = "NSLayoutFormatAlignAllCenterX")]
        const AlignAllCenterX = 1<<NSLayoutAttribute::CenterX.0;
/// Align all specified interface elements using [`NSLayoutAttributeCenterY`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/attribute/centery) on each.
        #[doc(alias = "NSLayoutFormatAlignAllCenterY")]
        const AlignAllCenterY = 1<<NSLayoutAttribute::CenterY.0;
/// Align all specified interface elements using the last baseline of each one.
        #[doc(alias = "NSLayoutFormatAlignAllLastBaseline")]
        const AlignAllLastBaseline = 1<<NSLayoutAttribute::LastBaseline.0;
/// Align all specified interface elements using the first baseline of each one.
        #[doc(alias = "NSLayoutFormatAlignAllFirstBaseline")]
        const AlignAllFirstBaseline = 1<<NSLayoutAttribute::FirstBaseline.0;
        #[doc(alias = "NSLayoutFormatAlignAllBaseline")]
        const AlignAllBaseline = NSLayoutFormatOptions::AlignAllLastBaseline.0;
/// Bit mask that can be combined with an [`NSLayoutFormatOptions`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/formatoptions) variable to yield only the alignment portion of the format options.
        #[doc(alias = "NSLayoutFormatAlignmentMask")]
        const AlignmentMask = 0xFFFF;
/// Arrange objects in order based on the normal text flow for the current user interface language. In left-to-right languages (like English), this arrangement results in the first object being placed farthest to the left, the next one to its right, and so on. In right-to-left languages (like Arabic or Hebrew), the ordering is reversed.
        #[doc(alias = "NSLayoutFormatDirectionLeadingToTrailing")]
        const DirectionLeadingToTrailing = 0<<16;
/// Arrange objects in order from left to right.
        #[doc(alias = "NSLayoutFormatDirectionLeftToRight")]
        const DirectionLeftToRight = 1<<16;
/// Arrange objects in order from right to left.
        #[doc(alias = "NSLayoutFormatDirectionRightToLeft")]
        const DirectionRightToLeft = 2<<16;
/// A bit mask that can be combined with an [`NSLayoutFormatOptions`](https://developer.apple.com/documentation/appkit/nslayoutconstraint/formatoptions) variable to yield only the direction portion of the format options.
        #[doc(alias = "NSLayoutFormatDirectionMask")]
        const DirectionMask = 0x3<<16;
    }
}

unsafe impl Encode for NSLayoutFormatOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSLayoutFormatOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The relationship between two user interface objects that must be satisfied by the constraint-based layout system.
    ///
    /// ## Overview
    ///
    /// Each constraint is a linear equation with the following format:
    ///
    /// ```objc
    /// item1.attribute1 = multiplier × item2.attribute2 + constant
    /// ```
    ///
    /// In this equation, `attribute1` and `attribute2` are the variables that Auto Layout can adjust when solving these constraints. The other values are defined when you create the constraint. For example, If you’re defining the relative position of two buttons, you might say “the leading edge of the second button should be 8 points after the trailing edge of the first button.” The linear equation for this relationship is shown below:
    ///
    /// ```objc
    /// // positive values move to the right in left-to-right languages like English.
    /// button2.leading = 1.0 × button1.trailing + 8.0
    /// ```
    ///
    /// Auto Layout then modifies the values of the specified leading and trailing edges until both sides of the equation are equal. Note that Auto Layout does not simply assign the value of the right side of this equation to the left side. Instead, the system can modify either attribute or both attributes as needed to solve for this constraint.
    ///
    /// The fact that constraints are equations (and not assignment operators) means that you can switch the order of the items in the equation as needed to more clearly express the desired relationship. However, if you switch the order, you must also invert the multiplier and constant. For example, the following two equations produce identical constraints:
    ///
    /// ```objc
    /// // These equations produce identical constraints
    /// button2.leading = 1.0 × button1.trailing + 8.0
    /// button1.trailing = 1.0 × button2.leading - 8.0
    /// ```
    ///
    /// A valid layout is defined as a set constraints with one and only one possible solution. Valid layouts are also referred to as a nonambiguous, nonconflicting layouts. Constraints with more than one solution are ambiguous. Constraints with no valid solutions are conflicting. For more information on resolving ambiguous and conflicting constraints, see [Types of Errors](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/TypesofErrors.html#//apple_ref/doc/uid/TP40010853-CH17) in [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853).
    ///
    /// Additionally, constraints are not limited to equality relationships. They can also use greater than or equal to (>=) or less than or equal to (<=) to describe the relationship between the two attributes. Constraints also have priorities between 1 and 1,000. Constraints with a priority of 1,000 are required. All priorities less than 1,000 are optional. By default, all constraints are required (priority = 1,000).
    ///
    /// After solving for the required constraints, Auto Layout tries to solve all the optional constraints in priority order from highest to lowest. If it cannot solve for an optional constraint, it tries to come as close as possible to the desired result, and then moves on to the next constraint.
    ///
    /// This combination of inequalities, equalities, and priorities gives you a great amount of flexibility and power. By combining multiple constraints, you can define layouts that dynamically adapt as the size and location of the elements in your user interface change. For some example layouts, see [Stack Views](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/LayoutUsingStackViews.html#//apple_ref/doc/uid/TP40010853-CH11) in [Auto Layout Guide](https://developer.apple.com/library/archive/documentation/UserExperience/Conceptual/AutolayoutPG/index.html#//apple_ref/doc/uid/TP40010853).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSLayoutConstraint;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSLayoutConstraint {}
);

impl NSLayoutConstraint {
    extern_methods!(
        /// # Safety
        ///
        /// - `metrics` generic should be of the correct type.
        /// - `views` generic should be of the correct type.
        #[unsafe(method(constraintsWithVisualFormat:options:metrics:views:))]
        #[unsafe(method_family = none)]
        pub unsafe fn constraintsWithVisualFormat_options_metrics_views(
            format: &NSString,
            opts: NSLayoutFormatOptions,
            metrics: Option<&NSDictionary<NSString, AnyObject>>,
            views: &NSDictionary<NSString, AnyObject>,
        ) -> Retained<NSArray<NSLayoutConstraint>>;

        #[cfg(feature = "objc2-core-foundation")]
        /// # Safety
        ///
        /// - `view1` should be of the correct type.
        /// - `view2` should be of the correct type.
        #[unsafe(method(constraintWithItem:attribute:relatedBy:toItem:attribute:multiplier:constant:))]
        #[unsafe(method_family = none)]
        pub unsafe fn constraintWithItem_attribute_relatedBy_toItem_attribute_multiplier_constant(
            view1: &AnyObject,
            attr1: NSLayoutAttribute,
            relation: NSLayoutRelation,
            view2: Option<&AnyObject>,
            attr2: NSLayoutAttribute,
            multiplier: CGFloat,
            c: CGFloat,
        ) -> Retained<Self>;

        #[unsafe(method(priority))]
        #[unsafe(method_family = none)]
        pub fn priority(&self) -> NSLayoutPriority;

        /// Setter for [`priority`][Self::priority].
        #[unsafe(method(setPriority:))]
        #[unsafe(method_family = none)]
        pub fn setPriority(&self, priority: NSLayoutPriority);

        #[unsafe(method(shouldBeArchived))]
        #[unsafe(method_family = none)]
        pub fn shouldBeArchived(&self) -> bool;

        /// Setter for [`shouldBeArchived`][Self::shouldBeArchived].
        #[unsafe(method(setShouldBeArchived:))]
        #[unsafe(method_family = none)]
        pub fn setShouldBeArchived(&self, should_be_archived: bool);

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(firstItem))]
        #[unsafe(method_family = none)]
        pub unsafe fn firstItem(&self) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(secondItem))]
        #[unsafe(method_family = none)]
        pub unsafe fn secondItem(&self) -> Option<Retained<AnyObject>>;

        #[unsafe(method(firstAttribute))]
        #[unsafe(method_family = none)]
        pub fn firstAttribute(&self) -> NSLayoutAttribute;

        #[unsafe(method(secondAttribute))]
        #[unsafe(method_family = none)]
        pub fn secondAttribute(&self) -> NSLayoutAttribute;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(firstAnchor))]
        #[unsafe(method_family = none)]
        pub fn firstAnchor(&self) -> Retained<NSLayoutAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(secondAnchor))]
        #[unsafe(method_family = none)]
        pub fn secondAnchor(&self) -> Option<Retained<NSLayoutAnchor>>;

        #[unsafe(method(relation))]
        #[unsafe(method_family = none)]
        pub fn relation(&self) -> NSLayoutRelation;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(multiplier))]
        #[unsafe(method_family = none)]
        pub fn multiplier(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(constant))]
        #[unsafe(method_family = none)]
        pub fn constant(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`constant`][Self::constant].
        #[unsafe(method(setConstant:))]
        #[unsafe(method_family = none)]
        pub fn setConstant(&self, constant: CGFloat);

        #[unsafe(method(isActive))]
        #[unsafe(method_family = none)]
        pub fn isActive(&self) -> bool;

        /// Setter for [`isActive`][Self::isActive].
        #[unsafe(method(setActive:))]
        #[unsafe(method_family = none)]
        pub fn setActive(&self, active: bool);

        #[unsafe(method(activateConstraints:))]
        #[unsafe(method_family = none)]
        pub fn activateConstraints(constraints: &NSArray<NSLayoutConstraint>);

        #[unsafe(method(deactivateConstraints:))]
        #[unsafe(method_family = none)]
        pub fn deactivateConstraints(constraints: &NSArray<NSLayoutConstraint>);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSLayoutConstraint {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSLayoutConstraint {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSIdentifier.
impl NSLayoutConstraint {
    extern_methods!(
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub fn identifier(&self) -> Option<Retained<NSString>>;

        /// Setter for [`identifier`][Self::identifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn setIdentifier(&self, identifier: Option<&NSString>);
    );
}

impl NSLayoutConstraint {
    extern_methods!();
}

#[cfg(feature = "NSAnimation")]
extern_conformance!(
    unsafe impl NSAnimatablePropertyContainer for NSLayoutConstraint {}
);

/// NSConstraintBasedLayoutInstallingConstraints.
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
impl NSView {
    extern_methods!(
        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(leadingAnchor))]
        #[unsafe(method_family = none)]
        pub fn leadingAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(trailingAnchor))]
        #[unsafe(method_family = none)]
        pub fn trailingAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(leftAnchor))]
        #[unsafe(method_family = none)]
        pub fn leftAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(rightAnchor))]
        #[unsafe(method_family = none)]
        pub fn rightAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(topAnchor))]
        #[unsafe(method_family = none)]
        pub fn topAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(bottomAnchor))]
        #[unsafe(method_family = none)]
        pub fn bottomAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(widthAnchor))]
        #[unsafe(method_family = none)]
        pub fn widthAnchor(&self) -> Retained<NSLayoutDimension>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(heightAnchor))]
        #[unsafe(method_family = none)]
        pub fn heightAnchor(&self) -> Retained<NSLayoutDimension>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(centerXAnchor))]
        #[unsafe(method_family = none)]
        pub fn centerXAnchor(&self) -> Retained<NSLayoutXAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(centerYAnchor))]
        #[unsafe(method_family = none)]
        pub fn centerYAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(firstBaselineAnchor))]
        #[unsafe(method_family = none)]
        pub fn firstBaselineAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[cfg(feature = "NSLayoutAnchor")]
        #[unsafe(method(lastBaselineAnchor))]
        #[unsafe(method_family = none)]
        pub fn lastBaselineAnchor(&self) -> Retained<NSLayoutYAxisAnchor>;

        #[unsafe(method(constraints))]
        #[unsafe(method_family = none)]
        pub fn constraints(&self) -> Retained<NSArray<NSLayoutConstraint>>;

        #[unsafe(method(addConstraint:))]
        #[unsafe(method_family = none)]
        pub fn addConstraint(&self, constraint: &NSLayoutConstraint);

        #[unsafe(method(addConstraints:))]
        #[unsafe(method_family = none)]
        pub fn addConstraints(&self, constraints: &NSArray<NSLayoutConstraint>);

        #[unsafe(method(removeConstraint:))]
        #[unsafe(method_family = none)]
        pub fn removeConstraint(&self, constraint: &NSLayoutConstraint);

        #[unsafe(method(removeConstraints:))]
        #[unsafe(method_family = none)]
        pub fn removeConstraints(&self, constraints: &NSArray<NSLayoutConstraint>);
    );
}

/// NSConstraintBasedLayoutCoreMethods.
#[cfg(all(feature = "NSResponder", feature = "NSWindow"))]
impl NSWindow {
    extern_methods!(
        #[unsafe(method(updateConstraintsIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn updateConstraintsIfNeeded(&self);

        #[unsafe(method(layoutIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn layoutIfNeeded(&self);
    );
}

/// NSConstraintBasedLayoutCoreMethods.
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
impl NSView {
    extern_methods!(
        #[unsafe(method(updateConstraintsForSubtreeIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn updateConstraintsForSubtreeIfNeeded(&self);

        #[unsafe(method(updateConstraints))]
        #[unsafe(method_family = none)]
        pub fn updateConstraints(&self);

        #[unsafe(method(needsUpdateConstraints))]
        #[unsafe(method_family = none)]
        pub fn needsUpdateConstraints(&self) -> bool;

        /// Setter for [`needsUpdateConstraints`][Self::needsUpdateConstraints].
        #[unsafe(method(setNeedsUpdateConstraints:))]
        #[unsafe(method_family = none)]
        pub fn setNeedsUpdateConstraints(&self, needs_update_constraints: bool);
    );
}

/// NSConstraintBasedCompatibility.
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
impl NSView {
    extern_methods!(
        #[unsafe(method(translatesAutoresizingMaskIntoConstraints))]
        #[unsafe(method_family = none)]
        pub fn translatesAutoresizingMaskIntoConstraints(&self) -> bool;

        /// Setter for [`translatesAutoresizingMaskIntoConstraints`][Self::translatesAutoresizingMaskIntoConstraints].
        #[unsafe(method(setTranslatesAutoresizingMaskIntoConstraints:))]
        #[unsafe(method_family = none)]
        pub fn setTranslatesAutoresizingMaskIntoConstraints(
            &self,
            translates_autoresizing_mask_into_constraints: bool,
        );

        #[unsafe(method(requiresConstraintBasedLayout))]
        #[unsafe(method_family = none)]
        pub fn requiresConstraintBasedLayout(mtm: MainThreadMarker) -> bool;
    );
}

extern "C" {
    /// Used to indicate that a view has no intrinsic metric for a given numeric property.
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated]
    pub static NSViewNoInstrinsicMetric: CGFloat;
}

extern "C" {
    /// A value that tells the layout system to ignore the intrinsic size value for a given dimension.
    ///
    /// ## Discussion
    ///
    /// Specify this value if a view doesn’t have an intrinsic height or width. For example, a horizontal slider has an intrinsic height but might have no intrinsic width.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static NSViewNoIntrinsicMetric: CGFloat;
}

/// NSConstraintBasedLayoutLayering.
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
impl NSView {
    extern_methods!(
        #[unsafe(method(alignmentRectForFrame:))]
        #[unsafe(method_family = none)]
        pub fn alignmentRectForFrame(&self, frame: NSRect) -> NSRect;

        #[unsafe(method(frameForAlignmentRect:))]
        #[unsafe(method_family = none)]
        pub fn frameForAlignmentRect(&self, alignment_rect: NSRect) -> NSRect;

        #[unsafe(method(alignmentRectInsets))]
        #[unsafe(method_family = none)]
        pub fn alignmentRectInsets(&self) -> NSEdgeInsets;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(firstBaselineOffsetFromTop))]
        #[unsafe(method_family = none)]
        pub fn firstBaselineOffsetFromTop(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(lastBaselineOffsetFromBottom))]
        #[unsafe(method_family = none)]
        pub fn lastBaselineOffsetFromBottom(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(baselineOffsetFromBottom))]
        #[unsafe(method_family = none)]
        pub fn baselineOffsetFromBottom(&self) -> CGFloat;

        #[unsafe(method(intrinsicContentSize))]
        #[unsafe(method_family = none)]
        pub fn intrinsicContentSize(&self) -> NSSize;

        #[unsafe(method(invalidateIntrinsicContentSize))]
        #[unsafe(method_family = none)]
        pub fn invalidateIntrinsicContentSize(&self);

        #[unsafe(method(contentHuggingPriorityForOrientation:))]
        #[unsafe(method_family = none)]
        pub fn contentHuggingPriorityForOrientation(
            &self,
            orientation: NSLayoutConstraintOrientation,
        ) -> NSLayoutPriority;

        #[unsafe(method(setContentHuggingPriority:forOrientation:))]
        #[unsafe(method_family = none)]
        pub fn setContentHuggingPriority_forOrientation(
            &self,
            priority: NSLayoutPriority,
            orientation: NSLayoutConstraintOrientation,
        );

        #[unsafe(method(contentCompressionResistancePriorityForOrientation:))]
        #[unsafe(method_family = none)]
        pub fn contentCompressionResistancePriorityForOrientation(
            &self,
            orientation: NSLayoutConstraintOrientation,
        ) -> NSLayoutPriority;

        #[unsafe(method(setContentCompressionResistancePriority:forOrientation:))]
        #[unsafe(method_family = none)]
        pub fn setContentCompressionResistancePriority_forOrientation(
            &self,
            priority: NSLayoutPriority,
            orientation: NSLayoutConstraintOrientation,
        );

        #[unsafe(method(isHorizontalContentSizeConstraintActive))]
        #[unsafe(method_family = none)]
        pub fn isHorizontalContentSizeConstraintActive(&self) -> bool;

        /// Setter for [`isHorizontalContentSizeConstraintActive`][Self::isHorizontalContentSizeConstraintActive].
        #[unsafe(method(setHorizontalContentSizeConstraintActive:))]
        #[unsafe(method_family = none)]
        pub fn setHorizontalContentSizeConstraintActive(
            &self,
            horizontal_content_size_constraint_active: bool,
        );

        #[unsafe(method(isVerticalContentSizeConstraintActive))]
        #[unsafe(method_family = none)]
        pub fn isVerticalContentSizeConstraintActive(&self) -> bool;

        /// Setter for [`isVerticalContentSizeConstraintActive`][Self::isVerticalContentSizeConstraintActive].
        #[unsafe(method(setVerticalContentSizeConstraintActive:))]
        #[unsafe(method_family = none)]
        pub fn setVerticalContentSizeConstraintActive(
            &self,
            vertical_content_size_constraint_active: bool,
        );
    );
}

/// NSConstraintBasedLayoutLayering.
#[cfg(all(feature = "NSControl", feature = "NSResponder", feature = "NSView"))]
impl NSControl {
    extern_methods!(
        #[cfg(feature = "NSCell")]
        #[unsafe(method(invalidateIntrinsicContentSizeForCell:))]
        #[unsafe(method_family = none)]
        pub fn invalidateIntrinsicContentSizeForCell(&self, cell: &NSCell);
    );
}

/// NSConstraintBasedLayoutAnchoring.
#[cfg(all(feature = "NSResponder", feature = "NSWindow"))]
impl NSWindow {
    extern_methods!(
        #[unsafe(method(anchorAttributeForOrientation:))]
        #[unsafe(method_family = none)]
        pub fn anchorAttributeForOrientation(
            &self,
            orientation: NSLayoutConstraintOrientation,
        ) -> NSLayoutAttribute;

        #[unsafe(method(setAnchorAttribute:forOrientation:))]
        #[unsafe(method_family = none)]
        pub fn setAnchorAttribute_forOrientation(
            &self,
            attr: NSLayoutAttribute,
            orientation: NSLayoutConstraintOrientation,
        );
    );
}

/// NSConstraintBasedLayoutFittingSize.
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
impl NSView {
    extern_methods!(
        #[unsafe(method(fittingSize))]
        #[unsafe(method_family = none)]
        pub fn fittingSize(&self) -> NSSize;
    );
}

/// NSConstraintBasedLayoutDebugging.
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
impl NSView {
    extern_methods!(
        #[unsafe(method(constraintsAffectingLayoutForOrientation:))]
        #[unsafe(method_family = none)]
        pub fn constraintsAffectingLayoutForOrientation(
            &self,
            orientation: NSLayoutConstraintOrientation,
        ) -> Retained<NSArray<NSLayoutConstraint>>;

        #[unsafe(method(hasAmbiguousLayout))]
        #[unsafe(method_family = none)]
        pub fn hasAmbiguousLayout(&self) -> bool;

        #[unsafe(method(exerciseAmbiguityInLayout))]
        #[unsafe(method_family = none)]
        pub fn exerciseAmbiguityInLayout(&self);
    );
}

/// NSConstraintBasedLayoutDebugging.
#[cfg(all(feature = "NSResponder", feature = "NSWindow"))]
impl NSWindow {
    extern_methods!(
        #[unsafe(method(visualizeConstraints:))]
        #[unsafe(method_family = none)]
        pub fn visualizeConstraints(&self, constraints: Option<&NSArray<NSLayoutConstraint>>);
    );
}
