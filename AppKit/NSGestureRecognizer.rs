//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// The current state of the gesture recognizer.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSGestureRecognizerState(pub NSInteger);
impl NSGestureRecognizerState {
    /// The gesture recognizer has not yet recognized its gesture but may be evaluating events. This is the default state.
    #[doc(alias = "NSGestureRecognizerStatePossible")]
    pub const Possible: Self = Self(0);
    /// The gesture recognizer has recognized a sequence of events as a continuous gesture. It calls its action method at the next cycle of the run loop.
    #[doc(alias = "NSGestureRecognizerStateBegan")]
    pub const Began: Self = Self(1);
    /// The gesture recognizer has detected a change to a continuous gesture. It calls its action method at the next cycle of the run loop.
    #[doc(alias = "NSGestureRecognizerStateChanged")]
    pub const Changed: Self = Self(2);
    /// The gesture recognizer has detected the end of a continuous gesture. It calls its action method at the next cycle of the run loop and resets its state to [`NSGestureRecognizerStatePossible`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.enum/possible).
    #[doc(alias = "NSGestureRecognizerStateEnded")]
    pub const Ended: Self = Self(3);
    /// The gesture recognizer received events that resulted in the cancellation of a continuous gesture. It calls its action method at the next cycle of the run loop and resets its state to [`NSGestureRecognizerStatePossible`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.enum/possible).
    #[doc(alias = "NSGestureRecognizerStateCancelled")]
    pub const Cancelled: Self = Self(4);
    /// The gesture recognizer failed to recognize its gesture and will not call its action method. The gesture recognizer resets itself to the [`NSGestureRecognizerStatePossible`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.enum/possible) state.
    #[doc(alias = "NSGestureRecognizerStateFailed")]
    pub const Failed: Self = Self(5);
    /// The gesture recognizer successfully recognized its gesture. It calls its action method at the next cycle of the run loop and resets its state to [`NSGestureRecognizerStatePossible`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.enum/possible).
    #[doc(alias = "NSGestureRecognizerStateRecognized")]
    pub const Recognized: Self = Self(NSGestureRecognizerState::Ended.0);
}

unsafe impl Encode for NSGestureRecognizerState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSGestureRecognizerState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that monitors events and calls its action method when a predefined sequence of events occur.
    ///
    /// ## Overview
    ///
    /// A gesture recognizer might recognize a single click, a click and drag, or a sequence of events that imply rotation. You do not create instances of this class directly. This class is an abstract base class that defines the common behavior for all gesture recognizers. When using a gesture recognizer in your app, create an instance of one of the concrete subclasses.
    ///
    /// The concrete subclasses of [`NSGestureRecognizer`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer) are the following:
    ///
    /// - [`NSClickGestureRecognizer`](https://developer.apple.com/documentation/appkit/nsclickgesturerecognizer)
    ///
    /// - [`NSMagnificationGestureRecognizer`](https://developer.apple.com/documentation/appkit/nsmagnificationgesturerecognizer)
    ///
    /// - [`NSPanGestureRecognizer`](https://developer.apple.com/documentation/appkit/nspangesturerecognizer)
    ///
    /// - [`NSPressGestureRecognizer`](https://developer.apple.com/documentation/appkit/nspressgesturerecognizer)
    ///
    /// - [`NSRotationGestureRecognizer`](https://developer.apple.com/documentation/appkit/nsrotationgesturerecognizer)
    ///
    /// A gesture recognizer operates on events in a specific view (or in any of that view’s subviews). After creating a gesture recognizer, attach it to one of your views using the [`addGestureRecognizer:`](https://developer.apple.com/documentation/appkit/nsview/addgesturerecognizer(_:)) method. Events received by your app are forwarded automatically to any relevant gesture recognizers before they are sent to the corresponding view. The gesture recognizer can delay the further progression of the events until recognition is complete or allow the events to be delivered normally.
    ///
    /// A gesture recognizer can detect gestures that are either discrete or continuous in nature. A click gesture is discrete because it involves a mouse-down and mouse-up event without any mouse movements in between. By contrast, a pan or rotation gesture is continuous because it involves tracking mouse movements over a period of time.
    ///
    /// During the gesture recognition process, a gesture recognizer calls the action method of its associated target object to report the state of the recognition process. For discrete gestures, the action method is typically called only once when the gesture is recognized. For continuous gestures, it may be called multiple times depending on the current state of the gesture recognizer. In that situation, you can use your action method to perform appropriate tasks, such as creating animations for any mouse-related movements, in addition to handling the final results of the gesture recognition process.
    ///
    /// A gesture recognizer has only one action method and one target object, and the method must conform to one of the following signatures:
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["func handleGesture() { }", "func handleGesture(gestureRecognizer: NSGestureRecognizer) { }"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["- (void)handleGesture;", "- (void)handleGesture:(NSGestureRecognizer *)gestureRecognizer;"], metadata: None }] }] })
    /// When your code needs additional information about the particulars of a gesture, define your action method to include the gesture recognizer parameter. You almost always want the gesture recognizer object when handling continuous gestures. For example, for a rotation gesture, you would use the gesture recognizer object to get the updated rotation value. You can also use the gesture recognizer object to get the location of where the gesture occurred.
    ///
    /// ### State Transitions
    ///
    /// Gesture recognizers operate within a predefined state machine, transitioning from state to state as they handle events. All gesture recognizers begin in the Possible ([`NSGestureRecognizerStatePossible`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.enum/possible)) state, but the possible transitions differ for continuous and discrete gestures.
    ///
    /// Discrete gestures transition from the Possible state directly to the Recognized ([`NSGestureRecognizerStateRecognized`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.enum/recognized)) or Failed ([`NSGestureRecognizerStateFailed`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.enum/failed)) state, depending on whether they successfully interpret the gesture. When a discrete gesture recognizer transitions to the Recognized state, it calls the action method of its target object.
    ///
    /// For continuous gestures, the state transitions are as follows:
    ///
    /// - Possible —> Began —> [Changed] —> Cancelled
    ///
    /// - Possible —> Began —> [Changed] —> Ended
    ///
    /// The Changed state is optional and may occur multiple times before the Cancelled or Ended state is reached. Many state transitions cause the gesture recognizer to call its action method. Setting the [`state`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.property) property to [`NSGestureRecognizerStateChanged`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.enum/changed) while monitoring events also calls the action method. You can use these calls to update the state of your app or update any custom animations.
    ///
    /// For a list of possible states, see the constants in [`NSGestureRecognizerState`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/state-swift.enum).
    ///
    /// ### Subclassing Notes
    ///
    /// You may create a subclass of `NSGestureRecognizer` that recognizes a distinctive gesture—for example, a “check mark” gesture. A custom gesture recognizer implements any appropriate event-related methods to detect its gesture along with a few other methods for managing state information.
    ///
    /// All gesture recognizers must update the value in the state property at appropriate times. Specifically, you must update it for all state transitions. For more information about the possible state transitions of a gesture recognizer, see [State Transitions](https://developer.apple.com/documentation/appkit/nsgesturerecognizer#state-transitions).
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  [`NSGestureRecognizer`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer) does not support handing off event tracking to other non-gesture recognizer mechanisms (for example drag and drop and pop-up menus).
    ///
    ///
    ///
    /// </div>
    /// #### Methods to Override
    ///
    /// When creating your own gesture recognizer subclass:
    ///
    /// - Implement the [`reset`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/reset()) method and any other relevant methods in Methods for Subclasses.
    ///
    /// - Override the [`locationInView:`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/location(in:)) method as needed to specify an appropriate point for your gesture.
    ///
    /// AppKit waits for a mouse-down event, magnify event, or rotation event to occur before starting the gesture recognition process. A gesture recognizer that used only key-down events to recognize its gesture would not have its [`keyDown:`](https://developer.apple.com/documentation/appkit/nsgesturerecognizer/keydown(with:)) method called until a mouse-down, magnify, or rotation event started the recognition process.
    ///
    /// #### Alternatives to Subclassing
    ///
    /// The `NSGestureRecognizer` class defines the common behaviors that can be configured for all concrete gesture recognizers. It also supports a delegate—an object that adopts the [`NSGestureRecognizerDelegate`](https://developer.apple.com/documentation/appkit/nsgesturerecognizerdelegate) protocol—for handling finer-grained customization of some behaviors without the need for subclassing. For example, you can use the delegate to create dependencies between specific gesture recognizer objects.
    ///
    /// For more information about using the delegate to control the behavior of your gesture recognizers, see [`NSGestureRecognizerDelegate`](https://developer.apple.com/documentation/appkit/nsgesturerecognizerdelegate).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSGestureRecognizer;
);

extern_conformance!(
    unsafe impl NSCoding for NSGestureRecognizer {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSGestureRecognizer {}
);

impl NSGestureRecognizer {
    extern_methods!(
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `action` must be a valid selector.
        #[unsafe(method(initWithTarget:action:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTarget_action(
            this: Allocated<Self>,
            target: Option<&AnyObject>,
            action: Option<Sel>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(target))]
        #[unsafe(method_family = none)]
        pub fn target(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`target`][Self::target].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        ///
        /// # Safety
        ///
        /// `target` should be of the correct type.
        #[unsafe(method(setTarget:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTarget(&self, target: Option<&AnyObject>);

        #[unsafe(method(action))]
        #[unsafe(method_family = none)]
        pub fn action(&self) -> Option<Sel>;

        /// Setter for [`action`][Self::action].
        ///
        /// # Safety
        ///
        /// `action` must be a valid selector.
        #[unsafe(method(setAction:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAction(&self, action: Option<Sel>);

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub fn delegate(&self)
            -> Option<Retained<ProtocolObject<dyn NSGestureRecognizerDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn NSGestureRecognizerDelegate>>,
        );

        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub fn setEnabled(&self, enabled: bool);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(view))]
        #[unsafe(method_family = none)]
        pub fn view(&self) -> Option<Retained<NSView>>;

        #[cfg(feature = "NSPressureConfiguration")]
        #[unsafe(method(pressureConfiguration))]
        #[unsafe(method_family = none)]
        pub fn pressureConfiguration(&self) -> Retained<NSPressureConfiguration>;

        #[cfg(feature = "NSPressureConfiguration")]
        /// Setter for [`pressureConfiguration`][Self::pressureConfiguration].
        #[unsafe(method(setPressureConfiguration:))]
        #[unsafe(method_family = none)]
        pub fn setPressureConfiguration(&self, pressure_configuration: &NSPressureConfiguration);

        #[unsafe(method(delaysPrimaryMouseButtonEvents))]
        #[unsafe(method_family = none)]
        pub fn delaysPrimaryMouseButtonEvents(&self) -> bool;

        /// Setter for [`delaysPrimaryMouseButtonEvents`][Self::delaysPrimaryMouseButtonEvents].
        #[unsafe(method(setDelaysPrimaryMouseButtonEvents:))]
        #[unsafe(method_family = none)]
        pub fn setDelaysPrimaryMouseButtonEvents(&self, delays_primary_mouse_button_events: bool);

        #[unsafe(method(delaysSecondaryMouseButtonEvents))]
        #[unsafe(method_family = none)]
        pub fn delaysSecondaryMouseButtonEvents(&self) -> bool;

        /// Setter for [`delaysSecondaryMouseButtonEvents`][Self::delaysSecondaryMouseButtonEvents].
        #[unsafe(method(setDelaysSecondaryMouseButtonEvents:))]
        #[unsafe(method_family = none)]
        pub fn setDelaysSecondaryMouseButtonEvents(
            &self,
            delays_secondary_mouse_button_events: bool,
        );

        #[unsafe(method(delaysOtherMouseButtonEvents))]
        #[unsafe(method_family = none)]
        pub fn delaysOtherMouseButtonEvents(&self) -> bool;

        /// Setter for [`delaysOtherMouseButtonEvents`][Self::delaysOtherMouseButtonEvents].
        #[unsafe(method(setDelaysOtherMouseButtonEvents:))]
        #[unsafe(method_family = none)]
        pub fn setDelaysOtherMouseButtonEvents(&self, delays_other_mouse_button_events: bool);

        #[unsafe(method(delaysKeyEvents))]
        #[unsafe(method_family = none)]
        pub fn delaysKeyEvents(&self) -> bool;

        /// Setter for [`delaysKeyEvents`][Self::delaysKeyEvents].
        #[unsafe(method(setDelaysKeyEvents:))]
        #[unsafe(method_family = none)]
        pub fn setDelaysKeyEvents(&self, delays_key_events: bool);

        #[unsafe(method(delaysMagnificationEvents))]
        #[unsafe(method_family = none)]
        pub fn delaysMagnificationEvents(&self) -> bool;

        /// Setter for [`delaysMagnificationEvents`][Self::delaysMagnificationEvents].
        #[unsafe(method(setDelaysMagnificationEvents:))]
        #[unsafe(method_family = none)]
        pub fn setDelaysMagnificationEvents(&self, delays_magnification_events: bool);

        #[unsafe(method(delaysRotationEvents))]
        #[unsafe(method_family = none)]
        pub fn delaysRotationEvents(&self) -> bool;

        /// Setter for [`delaysRotationEvents`][Self::delaysRotationEvents].
        #[unsafe(method(setDelaysRotationEvents:))]
        #[unsafe(method_family = none)]
        pub fn setDelaysRotationEvents(&self, delays_rotation_events: bool);

        #[cfg(all(feature = "NSResponder", feature = "NSView"))]
        #[unsafe(method(locationInView:))]
        #[unsafe(method_family = none)]
        pub fn locationInView(&self, view: Option<&NSView>) -> NSPoint;

        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub fn name(&self) -> Option<Retained<NSString>>;

        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub fn setName(&self, name: Option<&NSString>);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(modifierFlags))]
        #[unsafe(method_family = none)]
        pub fn modifierFlags(&self) -> NSEventModifierFlags;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSGestureRecognizer {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// NSTouchBar.
impl NSGestureRecognizer {
    extern_methods!(
        #[cfg(feature = "NSTouch")]
        #[unsafe(method(allowedTouchTypes))]
        #[unsafe(method_family = none)]
        pub fn allowedTouchTypes(&self) -> NSTouchTypeMask;

        #[cfg(feature = "NSTouch")]
        /// Setter for [`allowedTouchTypes`][Self::allowedTouchTypes].
        #[unsafe(method(setAllowedTouchTypes:))]
        #[unsafe(method_family = none)]
        pub fn setAllowedTouchTypes(&self, allowed_touch_types: NSTouchTypeMask);
    );
}

extern_protocol!(
    /// A set of methods for fine-tuning a gesture recognizer’s behavior.
    ///
    /// ## Overview
    ///
    /// Use the methods in this protocol to establish dynamic dependencies between gesture recognizers and to prevent a single gesture recognizer from acting at all.
    ///
    ///
    pub unsafe trait NSGestureRecognizerDelegate: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "NSEvent")]
        #[optional]
        #[unsafe(method(gestureRecognizer:shouldAttemptToRecognizeWithEvent:))]
        #[unsafe(method_family = none)]
        fn gestureRecognizer_shouldAttemptToRecognizeWithEvent(
            &self,
            gesture_recognizer: &NSGestureRecognizer,
            event: &NSEvent,
        ) -> bool;

        #[optional]
        #[unsafe(method(gestureRecognizerShouldBegin:))]
        #[unsafe(method_family = none)]
        fn gestureRecognizerShouldBegin(&self, gesture_recognizer: &NSGestureRecognizer) -> bool;

        #[optional]
        #[unsafe(method(gestureRecognizer:shouldRecognizeSimultaneouslyWithGestureRecognizer:))]
        #[unsafe(method_family = none)]
        fn gestureRecognizer_shouldRecognizeSimultaneouslyWithGestureRecognizer(
            &self,
            gesture_recognizer: &NSGestureRecognizer,
            other_gesture_recognizer: &NSGestureRecognizer,
        ) -> bool;

        #[optional]
        #[unsafe(method(gestureRecognizer:shouldRequireFailureOfGestureRecognizer:))]
        #[unsafe(method_family = none)]
        fn gestureRecognizer_shouldRequireFailureOfGestureRecognizer(
            &self,
            gesture_recognizer: &NSGestureRecognizer,
            other_gesture_recognizer: &NSGestureRecognizer,
        ) -> bool;

        #[optional]
        #[unsafe(method(gestureRecognizer:shouldBeRequiredToFailByGestureRecognizer:))]
        #[unsafe(method_family = none)]
        fn gestureRecognizer_shouldBeRequiredToFailByGestureRecognizer(
            &self,
            gesture_recognizer: &NSGestureRecognizer,
            other_gesture_recognizer: &NSGestureRecognizer,
        ) -> bool;

        #[cfg(feature = "NSTouch")]
        #[optional]
        #[unsafe(method(gestureRecognizer:shouldReceiveTouch:))]
        #[unsafe(method_family = none)]
        fn gestureRecognizer_shouldReceiveTouch(
            &self,
            gesture_recognizer: &NSGestureRecognizer,
            touch: &NSTouch,
        ) -> bool;
    }
);

/// NSSubclassUse.
impl NSGestureRecognizer {
    extern_methods!(
        /// Setter for [`state`][Self::state].
        #[unsafe(method(setState:))]
        #[unsafe(method_family = none)]
        pub fn setState(&self, state: NSGestureRecognizerState);

        #[unsafe(method(reset))]
        #[unsafe(method_family = none)]
        pub fn reset(&self);

        #[unsafe(method(canPreventGestureRecognizer:))]
        #[unsafe(method_family = none)]
        pub fn canPreventGestureRecognizer(
            &self,
            prevented_gesture_recognizer: &NSGestureRecognizer,
        ) -> bool;

        #[unsafe(method(canBePreventedByGestureRecognizer:))]
        #[unsafe(method_family = none)]
        pub fn canBePreventedByGestureRecognizer(
            &self,
            preventing_gesture_recognizer: &NSGestureRecognizer,
        ) -> bool;

        #[unsafe(method(shouldRequireFailureOfGestureRecognizer:))]
        #[unsafe(method_family = none)]
        pub fn shouldRequireFailureOfGestureRecognizer(
            &self,
            other_gesture_recognizer: &NSGestureRecognizer,
        ) -> bool;

        #[unsafe(method(shouldBeRequiredToFailByGestureRecognizer:))]
        #[unsafe(method_family = none)]
        pub fn shouldBeRequiredToFailByGestureRecognizer(
            &self,
            other_gesture_recognizer: &NSGestureRecognizer,
        ) -> bool;

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(mouseDown:))]
        #[unsafe(method_family = none)]
        pub fn mouseDown(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(rightMouseDown:))]
        #[unsafe(method_family = none)]
        pub fn rightMouseDown(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(otherMouseDown:))]
        #[unsafe(method_family = none)]
        pub fn otherMouseDown(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(mouseUp:))]
        #[unsafe(method_family = none)]
        pub fn mouseUp(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(rightMouseUp:))]
        #[unsafe(method_family = none)]
        pub fn rightMouseUp(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(otherMouseUp:))]
        #[unsafe(method_family = none)]
        pub fn otherMouseUp(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(mouseDragged:))]
        #[unsafe(method_family = none)]
        pub fn mouseDragged(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(rightMouseDragged:))]
        #[unsafe(method_family = none)]
        pub fn rightMouseDragged(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(otherMouseDragged:))]
        #[unsafe(method_family = none)]
        pub fn otherMouseDragged(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(mouseCancelled:))]
        #[unsafe(method_family = none)]
        pub fn mouseCancelled(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(keyDown:))]
        #[unsafe(method_family = none)]
        pub fn keyDown(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(keyUp:))]
        #[unsafe(method_family = none)]
        pub fn keyUp(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(flagsChanged:))]
        #[unsafe(method_family = none)]
        pub fn flagsChanged(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(tabletPoint:))]
        #[unsafe(method_family = none)]
        pub fn tabletPoint(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(magnifyWithEvent:))]
        #[unsafe(method_family = none)]
        pub fn magnifyWithEvent(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(rotateWithEvent:))]
        #[unsafe(method_family = none)]
        pub fn rotateWithEvent(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(pressureChangeWithEvent:))]
        #[unsafe(method_family = none)]
        pub fn pressureChangeWithEvent(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(touchesBeganWithEvent:))]
        #[unsafe(method_family = none)]
        pub fn touchesBeganWithEvent(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(touchesMovedWithEvent:))]
        #[unsafe(method_family = none)]
        pub fn touchesMovedWithEvent(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(touchesEndedWithEvent:))]
        #[unsafe(method_family = none)]
        pub fn touchesEndedWithEvent(&self, event: &NSEvent);

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(touchesCancelledWithEvent:))]
        #[unsafe(method_family = none)]
        pub fn touchesCancelledWithEvent(&self, event: &NSEvent);
    );
}
