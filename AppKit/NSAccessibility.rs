//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

mod private_NSObjectNSAccessibility {
    pub trait Sealed {}
}

/// Category "NSAccessibility" on [`NSObject`].
///
/// * Accessibility Informal Protocol **
#[doc(alias = "NSAccessibility")]
pub unsafe trait NSObjectNSAccessibility:
    ClassType + Sized + private_NSObjectNSAccessibility::Sealed
{
    extern_methods!(
        #[cfg(feature = "NSAccessibilityConstants")]
        #[deprecated = "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)"]
        #[unsafe(method(accessibilityAttributeNames))]
        #[unsafe(method_family = none)]
        fn accessibilityAttributeNames(&self) -> Retained<NSArray<NSAccessibilityAttributeName>>;

        #[cfg(feature = "NSAccessibilityConstants")]
        #[deprecated = "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)"]
        #[unsafe(method(accessibilityAttributeValue:))]
        #[unsafe(method_family = none)]
        fn accessibilityAttributeValue(
            &self,
            attribute: &NSAccessibilityAttributeName,
        ) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSAccessibilityConstants")]
        #[deprecated = "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)"]
        #[unsafe(method(accessibilityIsAttributeSettable:))]
        #[unsafe(method_family = none)]
        fn accessibilityIsAttributeSettable(
            &self,
            attribute: &NSAccessibilityAttributeName,
        ) -> bool;

        #[cfg(feature = "NSAccessibilityConstants")]
        /// # Safety
        ///
        /// `value` should be of the correct type.
        #[deprecated = "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)"]
        #[unsafe(method(accessibilitySetValue:forAttribute:))]
        #[unsafe(method_family = none)]
        unsafe fn accessibilitySetValue_forAttribute(
            &self,
            value: Option<&AnyObject>,
            attribute: &NSAccessibilityAttributeName,
        );

        #[cfg(feature = "NSAccessibilityConstants")]
        #[deprecated = "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)"]
        #[unsafe(method(accessibilityParameterizedAttributeNames))]
        #[unsafe(method_family = none)]
        fn accessibilityParameterizedAttributeNames(
            &self,
        ) -> Retained<NSArray<NSAccessibilityParameterizedAttributeName>>;

        #[cfg(feature = "NSAccessibilityConstants")]
        /// # Safety
        ///
        /// `parameter` should be of the correct type.
        #[deprecated = "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)"]
        #[unsafe(method(accessibilityAttributeValue:forParameter:))]
        #[unsafe(method_family = none)]
        unsafe fn accessibilityAttributeValue_forParameter(
            &self,
            attribute: &NSAccessibilityParameterizedAttributeName,
            parameter: Option<&AnyObject>,
        ) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSAccessibilityConstants")]
        #[deprecated = "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)"]
        #[unsafe(method(accessibilityActionNames))]
        #[unsafe(method_family = none)]
        fn accessibilityActionNames(&self) -> Retained<NSArray<NSAccessibilityActionName>>;

        #[cfg(feature = "NSAccessibilityConstants")]
        #[deprecated = "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)"]
        #[unsafe(method(accessibilityActionDescription:))]
        #[unsafe(method_family = none)]
        fn accessibilityActionDescription(
            &self,
            action: &NSAccessibilityActionName,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSAccessibilityConstants")]
        #[deprecated = "Use the NSAccessibility protocol methods instead (see NSAccessibilityProtocols.h)"]
        #[unsafe(method(accessibilityPerformAction:))]
        #[unsafe(method_family = none)]
        fn accessibilityPerformAction(&self, action: &NSAccessibilityActionName);

        #[deprecated = "Use isAccessibilityElement instead"]
        #[unsafe(method(accessibilityIsIgnored))]
        #[unsafe(method_family = none)]
        fn accessibilityIsIgnored(&self) -> bool;

        #[unsafe(method(accessibilityHitTest:))]
        #[unsafe(method_family = none)]
        fn accessibilityHitTest(&self, point: NSPoint) -> Option<Retained<AnyObject>>;

        #[unsafe(method(accessibilityFocusedUIElement))]
        #[unsafe(method_family = none)]
        fn accessibilityFocusedUIElement(&self) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// `child` should be of the correct type.
        #[unsafe(method(accessibilityIndexOfChild:))]
        #[unsafe(method_family = none)]
        unsafe fn accessibilityIndexOfChild(&self, child: &AnyObject) -> NSUInteger;

        #[cfg(feature = "NSAccessibilityConstants")]
        #[unsafe(method(accessibilityArrayAttributeCount:))]
        #[unsafe(method_family = none)]
        fn accessibilityArrayAttributeCount(
            &self,
            attribute: &NSAccessibilityAttributeName,
        ) -> NSUInteger;

        #[cfg(feature = "NSAccessibilityConstants")]
        #[unsafe(method(accessibilityArrayAttributeValues:index:maxCount:))]
        #[unsafe(method_family = none)]
        fn accessibilityArrayAttributeValues_index_maxCount(
            &self,
            attribute: &NSAccessibilityAttributeName,
            index: NSUInteger,
            max_count: NSUInteger,
        ) -> Retained<NSArray>;

        #[unsafe(method(accessibilityNotifiesWhenDestroyed))]
        #[unsafe(method_family = none)]
        fn accessibilityNotifiesWhenDestroyed(&self) -> bool;
    );
}

impl private_NSObjectNSAccessibility::Sealed for NSObject {}
unsafe impl NSObjectNSAccessibility for NSObject {}

/// NSWorkspaceAccessibilityDisplay.
#[cfg(feature = "NSWorkspace")]
impl NSWorkspace {
    extern_methods!(
        #[unsafe(method(accessibilityDisplayShouldIncreaseContrast))]
        #[unsafe(method_family = none)]
        pub fn accessibilityDisplayShouldIncreaseContrast(&self) -> bool;

        #[unsafe(method(accessibilityDisplayShouldDifferentiateWithoutColor))]
        #[unsafe(method_family = none)]
        pub fn accessibilityDisplayShouldDifferentiateWithoutColor(&self) -> bool;

        #[unsafe(method(accessibilityDisplayShouldReduceTransparency))]
        #[unsafe(method_family = none)]
        pub fn accessibilityDisplayShouldReduceTransparency(&self) -> bool;

        #[unsafe(method(accessibilityDisplayShouldReduceMotion))]
        #[unsafe(method_family = none)]
        pub fn accessibilityDisplayShouldReduceMotion(&self) -> bool;

        #[unsafe(method(accessibilityDisplayShouldInvertColors))]
        #[unsafe(method_family = none)]
        pub fn accessibilityDisplayShouldInvertColors(&self) -> bool;
    );
}

/// NSWorkspaceAccessibility.
#[cfg(feature = "NSWorkspace")]
impl NSWorkspace {
    extern_methods!(
        #[unsafe(method(isVoiceOverEnabled))]
        #[unsafe(method_family = none)]
        pub fn isVoiceOverEnabled(&self) -> bool;

        #[unsafe(method(isSwitchControlEnabled))]
        #[unsafe(method_family = none)]
        pub fn isSwitchControlEnabled(&self) -> bool;
    );
}

extern "C" {
    /// A notification that the workspace posts when any of the accessibility display options change.
    ///
    /// ## Discussion
    ///
    /// The notification object is the shared `NSWorkspace` instance. The notification doesn’t contain a `userInfo` dictionary.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  To receive this notification, use [`notificationCenter`](https://developer.apple.com/documentation/appkit/nsworkspace/notificationcenter) to register for it. If you use a different notification center to register, you won’t receive the notification.
    ///
    ///
    ///
    /// </div>
    ///
    pub static NSWorkspaceAccessibilityDisplayOptionsDidChangeNotification:
        &'static NSNotificationName;
}

/// Returns the frame in screen coordinates.
///
/// ## Discussion
///
/// Given a frame in the specified view’s coordinates, it returns the same frame in the screen’s coordinates.
///
///
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
#[inline]
pub extern "C-unwind" fn NSAccessibilityFrameInView(parent_view: &NSView, frame: NSRect) -> NSRect {
    extern "C-unwind" {
        fn NSAccessibilityFrameInView(parent_view: &NSView, frame: NSRect) -> NSRect;
    }
    unsafe { NSAccessibilityFrameInView(parent_view, frame) }
}

/// Returns the point in screen coordinates.
///
/// ## Discussion
///
/// Given a point in the specified view’s coordinates, it returns the same point in the screen’s coordinates.
///
///
#[cfg(all(feature = "NSResponder", feature = "NSView"))]
#[inline]
pub extern "C-unwind" fn NSAccessibilityPointInView(
    parent_view: &NSView,
    point: NSPoint,
) -> NSPoint {
    extern "C-unwind" {
        fn NSAccessibilityPointInView(parent_view: &NSView, point: NSPoint) -> NSPoint;
    }
    unsafe { NSAccessibilityPointInView(parent_view, point) }
}

/// Sets whether the app may have protected content.
///
/// ## Discussion
///
/// Uses the value of `flag` to specify whether the app may have protected content. Protected content is identified by a value of [`true`](https://developer.apple.com/documentation/swift/true) for `NSAccessibilityContainsProtectedContentAttribute`, but if `NSAccessibilitySetMayContainProtectedContent` returns [`false`](https://developer.apple.com/documentation/swift/false), the value of `NSAccessibilityContainsProtectedContentAttribute` is ignored. This function returns [`true`](https://developer.apple.com/documentation/swift/true) on success.
///
///
#[inline]
pub extern "C-unwind" fn NSAccessibilitySetMayContainProtectedContent(flag: bool) -> bool {
    extern "C-unwind" {
        fn NSAccessibilitySetMayContainProtectedContent(flag: Bool) -> Bool;
    }
    unsafe { NSAccessibilitySetMayContainProtectedContent(Bool::new(flag)) }.as_bool()
}

/// Returns a standard description for a role and subrole.
///
/// ## Discussion
///
/// You should pass `nil` to this function if there is no subrole. This function returns a description of a standard role. For example, if you implement a button widget that does not inherit from [`NSButton`](https://developer.apple.com/documentation/appkit/nsbutton), you should use this function to return a localized role description matching that returned by a standard button.
///
///
#[cfg(feature = "NSAccessibilityConstants")]
#[inline]
pub extern "C-unwind" fn NSAccessibilityRoleDescription(
    role: &NSAccessibilityRole,
    subrole: Option<&NSAccessibilitySubrole>,
) -> Option<Retained<NSString>> {
    extern "C-unwind" {
        fn NSAccessibilityRoleDescription(
            role: &NSAccessibilityRole,
            subrole: Option<&NSAccessibilitySubrole>,
        ) -> *mut NSString;
    }
    let ret = unsafe { NSAccessibilityRoleDescription(role, subrole) };
    unsafe { Retained::retain_autoreleased(ret) }
}

/// Returns a standard role description for a user interface element.
///
/// ## Discussion
///
/// This function is like the [`NSAccessibilityRoleDescription`](https://developer.apple.com/documentation/appkit/nsaccessibility-swift.struct/role/description(with:)) function, except that it queries `element` to get the role and subrole. The [`NSAccessibilityRoleDescription`](https://developer.apple.com/documentation/appkit/nsaccessibility-swift.struct/role/description(with:)) function is more efficient, but this function is useful for accessorizing base classes so that they properly handle derived classes, which may override the subrole or even the role.
///
///
///
/// # Safety
///
/// `element` should be of the correct type.
#[inline]
pub unsafe extern "C-unwind" fn NSAccessibilityRoleDescriptionForUIElement(
    element: &AnyObject,
) -> Option<Retained<NSString>> {
    extern "C-unwind" {
        fn NSAccessibilityRoleDescriptionForUIElement(element: &AnyObject) -> *mut NSString;
    }
    let ret = unsafe { NSAccessibilityRoleDescriptionForUIElement(element) };
    unsafe { Retained::retain_autoreleased(ret) }
}

/// Returns a standard description for an action.
///
/// ## Discussion
///
/// This function returns a standard description for `action`.
///
///
#[cfg(feature = "NSAccessibilityConstants")]
#[inline]
pub extern "C-unwind" fn NSAccessibilityActionDescription(
    action: &NSAccessibilityActionName,
) -> Option<Retained<NSString>> {
    extern "C-unwind" {
        fn NSAccessibilityActionDescription(action: &NSAccessibilityActionName) -> *mut NSString;
    }
    let ret = unsafe { NSAccessibilityActionDescription(action) };
    unsafe { Retained::retain_autoreleased(ret) }
}

extern "C-unwind" {
    /// Raises an error if the parameter is the wrong type or has an illegal value
    ///
    /// ## Discussion
    ///
    /// Raises an error if a parameter is the wrong type or has an illegal value. This function can also be used to raise an error if an attempt is made to set an attribute’s value with the wrong type or an illegal value.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `element` should be of the correct type.
    /// - `element` might not allow `None`.
    /// - `attribute` might not allow `None`.
    /// - `value` should be of the correct type.
    /// - `value` might not allow `None`.
    #[cfg(feature = "NSAccessibilityConstants")]
    #[deprecated = "Exceptions are no longer appropriate for indicating errors in accessibility API. Unexpected values should be handled through appropriate type checking."]
    pub fn NSAccessibilityRaiseBadArgumentException(
        element: Option<&AnyObject>,
        attribute: Option<&NSAccessibilityAttributeName>,
        value: Option<&AnyObject>,
    );
}

/// Returns an unignored accessibility object, ascending the hierarchy, if necessary.
///
/// ## Discussion
///
/// Tests whether `element` is an ignored object, returning either `element`, if it is not ignored, or the first unignored ancestor of `element`.
///
///
/// * Ignored UIElements Utilities **
///
/// # Safety
///
/// `element` should be of the correct type.
#[inline]
pub unsafe extern "C-unwind" fn NSAccessibilityUnignoredAncestor(
    element: &AnyObject,
) -> Option<Retained<AnyObject>> {
    extern "C-unwind" {
        fn NSAccessibilityUnignoredAncestor(element: &AnyObject) -> *mut AnyObject;
    }
    let ret = unsafe { NSAccessibilityUnignoredAncestor(element) };
    unsafe { Retained::retain_autoreleased(ret) }
}

/// Returns an unignored accessibility object, descending the hierarchy, if necessary.
///
/// ## Discussion
///
/// Tests whether `element` is an ignored object, returning either `element`, if it is not ignored, or the first unignored descendant of `element`. Use this function only if you know there is a linear, one-to-one, hierarchy below `element`. Otherwise, if `element` has either no unignored children or multiple unignored children, this function fails and returns `nil`.
///
///
///
/// # Safety
///
/// `element` should be of the correct type.
#[inline]
pub unsafe extern "C-unwind" fn NSAccessibilityUnignoredDescendant(
    element: &AnyObject,
) -> Option<Retained<AnyObject>> {
    extern "C-unwind" {
        fn NSAccessibilityUnignoredDescendant(element: &AnyObject) -> *mut AnyObject;
    }
    let ret = unsafe { NSAccessibilityUnignoredDescendant(element) };
    unsafe { Retained::retain_autoreleased(ret) }
}

/// Returns a list of unignored accessibility objects, descending the hierarchy, if necessary.
///
/// ## Discussion
///
/// This function first tests whether `originalChildren` contains any ignored objects. If the array contains no ignored objects, the function returns `originalChildren`. If the array contains ignored objects, this function returns a new array that contains the contents of `originalChildren`, but with each ignored object replaced by its unignored descendant.
///
///
///
/// # Safety
///
/// `original_children` generic should be of the correct type.
#[inline]
pub unsafe extern "C-unwind" fn NSAccessibilityUnignoredChildren(
    original_children: &NSArray,
) -> Retained<NSArray> {
    extern "C-unwind" {
        fn NSAccessibilityUnignoredChildren(original_children: &NSArray) -> *mut NSArray;
    }
    let ret = unsafe { NSAccessibilityUnignoredChildren(original_children) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

/// Returns a list of unignored accessibility objects, descending the hierarchy, if necessary.
///
/// ## Discussion
///
/// Tests whether `originalChild` is an ignored object and returns an array containing either `originalChild`, if it is not ignored, or its unignored descendants.
///
///
///
/// # Safety
///
/// `original_child` should be of the correct type.
#[inline]
pub unsafe extern "C-unwind" fn NSAccessibilityUnignoredChildrenForOnlyChild(
    original_child: &AnyObject,
) -> Retained<NSArray> {
    extern "C-unwind" {
        fn NSAccessibilityUnignoredChildrenForOnlyChild(original_child: &AnyObject)
            -> *mut NSArray;
    }
    let ret = unsafe { NSAccessibilityUnignoredChildrenForOnlyChild(original_child) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    /// Sends a notification to any observing assistive apps.
    ///
    /// ## Discussion
    ///
    /// Sends `notification` to any assistive applications that register to receive the notification from the user interface object `element` in your app. Accessibility notifications require special handling, so they can’t post using [`NSNotificationCenter`](https://developer.apple.com/documentation/foundation/notificationcenter).
    ///
    ///
    /// * Posting Notifications **
    ///
    /// # Safety
    ///
    /// `element` should be of the correct type.
    #[cfg(feature = "NSAccessibilityConstants")]
    pub fn NSAccessibilityPostNotification(
        element: &AnyObject,
        notification: &NSAccessibilityNotificationName,
    );
}
