//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A representation of the state of the data in a view at a specific point in time.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  If you’re working in a Swift codebase, always use [`NSDiffableDataSourceSnapshot`](https://developer.apple.com/documentation/appkit/nsdiffabledatasourcesnapshot-swift.struct) instead of `NSDiffableDataSourceSnapshotReference`.
    ///
    ///
    ///
    /// </div>
    /// Diffable data sources use _snapshots_ to provide data for collection views and table views. Through a snapshot, you set up the initial state of the data that displays in a view, and later update that data.
    ///
    /// The data in a snapshot is made up of the sections and items you want to display, in the specific order you want to display them. You configure what to display by adding, deleting, or moving the sections and items.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Each of your sections and items must have unique identifiers.
    ///
    ///
    ///
    /// </div>
    /// To display data in a view using a snapshot:
    ///
    /// 1. Create a snapshot and populate it with the state of the data you want to display.
    ///
    /// 2. Apply the snapshot to reflect the changes in the UI.
    ///
    /// You can create and configure a snapshot in one of these ways:
    ///
    /// - Create an empty snapshot, then append sections and items to it.
    ///
    /// - Get the current snapshot by calling the diffable data source’s [`snapshot`](https://developer.apple.com/documentation/appkit/nscollectionviewdiffabledatasourcereference/snapshot()) method, then modify that snapshot to reflect the new state of the data that you want to display.
    ///
    /// For example, the following code creates an empty snapshot, and populates it with a single section with three items. Then, it applies the snapshot, animating the UI updates between the previous state and the new state represented in the snapshot.
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["// Create a snapshot.", "var snapshot = NSDiffableDataSourceSnapshot<Int, UUID>()        ", "", "// Populate the snapshot.", "snapshot.appendSections([0])", "snapshot.appendItems([UUID(), UUID(), UUID()])", "", "// Apply the snapshot.", "dataSource.apply(snapshot, animatingDifferences: true)"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["// Create a snapshot.", "NSDiffableDataSourceSnapshot<NSNumber *, NSUUID *> *snapshot = [[NSDiffableDataSourceSnapshot alloc] init];", "", "// Populate the snapshot.", "[snapshot appendSectionsWithIdentifiers:@[@0]];", "[snapshot appendItemsWithIdentifiers:@[[NSUUID UUID], [NSUUID UUID], [NSUUID UUID]]];", "", "// Apply the snapshot.", "[self.dataSource applySnapshot:snapshot animatingDifferences:YES];"], metadata: None }] }] })
    /// For more information, see the diffable data source types:
    ///
    /// - [`UICollectionViewDiffableDataSource`](https://developer.apple.com/documentation/uikit/uicollectionviewdiffabledatasource-9tqpa)
    ///
    /// - [`UITableViewDiffableDataSource`](https://developer.apple.com/documentation/uikit/uitableviewdiffabledatasource-2euir)
    ///
    /// - [`NSCollectionViewDiffableDataSource`](https://developer.apple.com/documentation/appkit/nscollectionviewdiffabledatasourcereference)
    ///
    /// ### Bridging
    ///
    /// Avoid using this type in Swift code. Only use this type to bridge from Objective-C code to Swift code by typecasting from a snapshot reference to a snapshot:
    ///
    /// ```swift
    /// let snapshot = snapshotReference as NSDiffableDataSourceSnapshot<Int, UUID>
    /// ```
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSDiffableDataSourceSnapshot<
        SectionIdentifierType: ?Sized = AnyObject,
        ItemIdentifierType: ?Sized = AnyObject,
    >;
);

impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
    NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    /// Unchecked conversion of the generic parameters.
    ///
    /// # Safety
    ///
    /// The generics must be valid to reinterpret as the given types.
    #[inline]
    pub unsafe fn cast_unchecked<
        NewSectionIdentifierType: ?Sized + Message,
        NewItemIdentifierType: ?Sized + Message,
    >(
        &self,
    ) -> &NSDiffableDataSourceSnapshot<NewSectionIdentifierType, NewItemIdentifierType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized, ItemIdentifierType: ?Sized> NSCopying
        for NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

unsafe impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
    CopyingHelper for NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    type Result = Self;
}

extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized, ItemIdentifierType: ?Sized> NSObjectProtocol
        for NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        #[unsafe(method(numberOfItems))]
        #[unsafe(method_family = none)]
        pub fn numberOfItems(&self) -> NSInteger;

        #[unsafe(method(numberOfSections))]
        #[unsafe(method_family = none)]
        pub fn numberOfSections(&self) -> NSInteger;

        #[unsafe(method(sectionIdentifiers))]
        #[unsafe(method_family = none)]
        pub fn sectionIdentifiers(&self) -> Retained<NSArray<SectionIdentifierType>>;

        #[unsafe(method(itemIdentifiers))]
        #[unsafe(method_family = none)]
        pub fn itemIdentifiers(&self) -> Retained<NSArray<ItemIdentifierType>>;

        #[unsafe(method(numberOfItemsInSection:))]
        #[unsafe(method_family = none)]
        pub fn numberOfItemsInSection(
            &self,
            section_identifier: &SectionIdentifierType,
        ) -> NSInteger;

        #[unsafe(method(itemIdentifiersInSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn itemIdentifiersInSectionWithIdentifier(
            &self,
            section_identifier: &SectionIdentifierType,
        ) -> Retained<NSArray<ItemIdentifierType>>;

        #[unsafe(method(sectionIdentifierForSectionContainingItemIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn sectionIdentifierForSectionContainingItemIdentifier(
            &self,
            item_identifier: &ItemIdentifierType,
        ) -> Option<Retained<SectionIdentifierType>>;

        #[unsafe(method(indexOfItemIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn indexOfItemIdentifier(&self, item_identifier: &ItemIdentifierType) -> NSInteger;

        #[unsafe(method(indexOfSectionIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn indexOfSectionIdentifier(
            &self,
            section_identifier: &SectionIdentifierType,
        ) -> NSInteger;

        #[unsafe(method(appendItemsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn appendItemsWithIdentifiers(&self, identifiers: &NSArray<ItemIdentifierType>);

        #[unsafe(method(appendItemsWithIdentifiers:intoSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn appendItemsWithIdentifiers_intoSectionWithIdentifier(
            &self,
            identifiers: &NSArray<ItemIdentifierType>,
            section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(insertItemsWithIdentifiers:beforeItemWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn insertItemsWithIdentifiers_beforeItemWithIdentifier(
            &self,
            identifiers: &NSArray<ItemIdentifierType>,
            item_identifier: &ItemIdentifierType,
        );

        #[unsafe(method(insertItemsWithIdentifiers:afterItemWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn insertItemsWithIdentifiers_afterItemWithIdentifier(
            &self,
            identifiers: &NSArray<ItemIdentifierType>,
            item_identifier: &ItemIdentifierType,
        );

        #[unsafe(method(deleteItemsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn deleteItemsWithIdentifiers(&self, identifiers: &NSArray<ItemIdentifierType>);

        #[unsafe(method(deleteAllItems))]
        #[unsafe(method_family = none)]
        pub fn deleteAllItems(&self);

        #[unsafe(method(moveItemWithIdentifier:beforeItemWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn moveItemWithIdentifier_beforeItemWithIdentifier(
            &self,
            from_identifier: &ItemIdentifierType,
            to_identifier: &ItemIdentifierType,
        );

        #[unsafe(method(moveItemWithIdentifier:afterItemWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn moveItemWithIdentifier_afterItemWithIdentifier(
            &self,
            from_identifier: &ItemIdentifierType,
            to_identifier: &ItemIdentifierType,
        );

        #[unsafe(method(reloadItemsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn reloadItemsWithIdentifiers(&self, identifiers: &NSArray<ItemIdentifierType>);

        #[unsafe(method(appendSectionsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn appendSectionsWithIdentifiers(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
        );

        #[unsafe(method(insertSectionsWithIdentifiers:beforeSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn insertSectionsWithIdentifiers_beforeSectionWithIdentifier(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
            to_section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(insertSectionsWithIdentifiers:afterSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn insertSectionsWithIdentifiers_afterSectionWithIdentifier(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
            to_section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(deleteSectionsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn deleteSectionsWithIdentifiers(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
        );

        #[unsafe(method(moveSectionWithIdentifier:beforeSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn moveSectionWithIdentifier_beforeSectionWithIdentifier(
            &self,
            from_section_identifier: &SectionIdentifierType,
            to_section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(moveSectionWithIdentifier:afterSectionWithIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn moveSectionWithIdentifier_afterSectionWithIdentifier(
            &self,
            from_section_identifier: &SectionIdentifierType,
            to_section_identifier: &SectionIdentifierType,
        );

        #[unsafe(method(reloadSectionsWithIdentifiers:))]
        #[unsafe(method_family = none)]
        pub fn reloadSectionsWithIdentifiers(
            &self,
            section_identifiers: &NSArray<SectionIdentifierType>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl<SectionIdentifierType: Message, ItemIdentifierType: Message> DefaultRetained
    for NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>
{
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// A closure that configures and returns a collection view’s supplementary view, such as a header or footer, from a diffable data source.
///
/// Parameters:
/// - collectionView: The collection view to configure this supplementary view for.
///
/// - kind: The kind of supplementary view to provide. The layout object that supports the supplementary view defines the value of this string.
///
/// - indexPath: The index path that specifies the location of the supplementary view in the collection view.
///
///
/// ## Return Value
///
/// A non-`nil` configured supplementary view object. The supplementary view provider must return a valid view object to the collection view.
///
///
#[cfg(all(
    feature = "NSCollectionView",
    feature = "NSResponder",
    feature = "NSView",
    feature = "block2"
))]
pub type NSCollectionViewDiffableDataSourceSupplementaryViewProvider = *mut block2::DynBlock<
    dyn Fn(NonNull<NSCollectionView>, NonNull<NSString>, NonNull<NSIndexPath>) -> *mut NSView,
>;

extern_class!(
    /// The object you use to manage data and provide items for a collection view.
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  If you’re working in a Swift codebase, always use [`NSCollectionViewDiffableDataSource`](https://developer.apple.com/documentation/appkit/nscollectionviewdiffabledatasource-axww) instead of `NSCollectionViewDiffableDataSourceReference`.
    ///
    ///
    ///
    /// </div>
    /// A _diffable data source_ object is a specialized type of data source that works together with your collection view object. It provides the behavior you need to manage updates to your collection view’s data and UI in a simple, efficient way. It also conforms to the [`NSCollectionViewDataSource`](https://developer.apple.com/documentation/appkit/nscollectionviewdatasource) protocol and provides implementations for all of the protocol’s methods.
    ///
    /// To fill a collection view with data:
    ///
    /// 1. Connect a diffable data source to your collection view.
    ///
    /// 2. Implement an item provider to configure your collection view’s items.
    ///
    /// 3. Generate the current state of the data.
    ///
    /// 4. Display the data in the UI.
    ///
    /// To connect a diffable data source to a collection view, you create the diffable data source using its [`initWithCollectionView:itemProvider:`](https://developer.apple.com/documentation/appkit/nscollectionviewdiffabledatasourcereference/init(collectionview:itemprovider:)) initializer, passing in the collection view you want to associate with that data source. You also pass in an item provider, where you configure each of your items to determine how to display your data in the UI.
    ///
    /// ```swift
    /// dataSource = NSCollectionViewDiffableDataSource<Int, UUID>(collectionView: collectionView) {
    ///     (collectionView: NSCollectionView, indexPath: IndexPath, itemIdentifier: UUID) -> NSCollectionViewItem? in
    ///     // configure and return item
    /// }
    /// ```
    ///
    /// Then, you generate the current state of the data and display the data in the UI by constructing and applying a snapshot. For more information, see [`NSDiffableDataSourceSnapshot`](https://developer.apple.com/documentation/appkit/nsdiffabledatasourcesnapshotreference).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSCollectionViewDiffableDataSource<
        SectionIdentifierType: ?Sized = AnyObject,
        ItemIdentifierType: ?Sized = AnyObject,
    >;
);

impl<SectionIdentifierType: ?Sized + Message, ItemIdentifierType: ?Sized + Message>
    NSCollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
{
    /// Unchecked conversion of the generic parameters.
    ///
    /// # Safety
    ///
    /// The generics must be valid to reinterpret as the given types.
    #[inline]
    pub unsafe fn cast_unchecked<
        NewSectionIdentifierType: ?Sized + Message,
        NewItemIdentifierType: ?Sized + Message,
    >(
        &self,
    ) -> &NSCollectionViewDiffableDataSource<NewSectionIdentifierType, NewItemIdentifierType> {
        unsafe { &*((self as *const Self).cast()) }
    }
}

extern_conformance!(
    unsafe impl<SectionIdentifierType: ?Sized, ItemIdentifierType: ?Sized> NSObjectProtocol
        for NSCollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
    {
    }
);

impl<SectionIdentifierType: Message, ItemIdentifierType: Message>
    NSCollectionViewDiffableDataSource<SectionIdentifierType, ItemIdentifierType>
{
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(snapshot))]
        #[unsafe(method_family = none)]
        pub fn snapshot(
            &self,
        ) -> Retained<NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>>;

        #[unsafe(method(applySnapshot:animatingDifferences:))]
        #[unsafe(method_family = none)]
        pub fn applySnapshot_animatingDifferences(
            &self,
            snapshot: &NSDiffableDataSourceSnapshot<SectionIdentifierType, ItemIdentifierType>,
            animating_differences: bool,
        );

        #[unsafe(method(itemIdentifierForIndexPath:))]
        #[unsafe(method_family = none)]
        pub fn itemIdentifierForIndexPath(
            &self,
            index_path: &NSIndexPath,
        ) -> Option<Retained<ItemIdentifierType>>;

        #[unsafe(method(indexPathForItemIdentifier:))]
        #[unsafe(method_family = none)]
        pub fn indexPathForItemIdentifier(
            &self,
            identifier: &ItemIdentifierType,
        ) -> Option<Retained<NSIndexPath>>;

        #[cfg(all(
            feature = "NSCollectionView",
            feature = "NSResponder",
            feature = "NSView",
            feature = "block2"
        ))]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer.
        /// - The returned block's argument 3 must be a valid pointer.
        #[unsafe(method(supplementaryViewProvider))]
        #[unsafe(method_family = none)]
        pub unsafe fn supplementaryViewProvider(
            &self,
            mtm: MainThreadMarker,
        ) -> NSCollectionViewDiffableDataSourceSupplementaryViewProvider;

        #[cfg(all(
            feature = "NSCollectionView",
            feature = "NSResponder",
            feature = "NSView",
            feature = "block2"
        ))]
        /// Setter for [`supplementaryViewProvider`][Self::supplementaryViewProvider].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `supplementary_view_provider` must be a valid pointer or null.
        #[unsafe(method(setSupplementaryViewProvider:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupplementaryViewProvider(
            &self,
            supplementary_view_provider: NSCollectionViewDiffableDataSourceSupplementaryViewProvider,
        );
    );
}
