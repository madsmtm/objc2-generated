//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Values that indicate a document’s edit status.
///
/// ## Overview
///
/// These constants indicate how a document should operate on its change count and are passed to the [`updateChangeCount:`](https://developer.apple.com/documentation/appkit/nsdocument/updatechangecount(_:)) method.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSDocumentChangeType(pub NSUInteger);
impl NSDocumentChangeType {
    /// Increment change count.
    ///
    /// ## Discussion
    ///
    /// Pass this value to the [`updateChangeCount:`](https://developer.apple.com/documentation/appkit/nsdocument/updatechangecount(_:)) method to indicate that a single change has been done. For example, the built-in undo support in the [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) class passes this value whenever a document receives an [`NSUndoManagerDidCloseUndoGroupNotification`](https://developer.apple.com/documentation/foundation/nsnotification/name-swift.struct/nsundomanagerdidcloseundogroup) notification from its own undo manager.
    ///
    ///
    #[doc(alias = "NSChangeDone")]
    pub const ChangeDone: Self = Self(0);
    /// Decrement change count.
    ///
    /// ## Discussion
    ///
    /// A single change has been undone. For example, the built-in undo support of [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) passes this value whenever a document receives an [`NSUndoManagerDidUndoChangeNotification`](https://developer.apple.com/documentation/foundation/nsnotification/name-swift.struct/nsundomanagerdidundochange) from its own undo manager.
    ///
    ///
    #[doc(alias = "NSChangeUndone")]
    pub const ChangeUndone: Self = Self(1);
    /// A single change has been redone.
    ///
    /// ## Discussion
    ///
    /// For example, the built-in undo support of [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) passes this value whenever a document receives an [`NSUndoManagerDidRedoChangeNotification`](https://developer.apple.com/documentation/foundation/nsnotification/name-swift.struct/nsundomanagerdidredochange) from its own undo manager.
    ///
    ///
    #[doc(alias = "NSChangeRedone")]
    pub const ChangeRedone: Self = Self(5);
    /// Set change count to 0.
    ///
    /// ## Discussion
    ///
    /// The document has been synchronized with its file or file package. For example, [`saveToURL:ofType:forSaveOperation:error:`](https://developer.apple.com/documentation/appkit/nsdocument/savetourl:oftype:forsaveoperation:error:) passes this value for a successful [`NSSaveOperation`](https://developer.apple.com/documentation/appkit/nsdocument/saveoperationtype/saveoperation) or [`NSSaveAsOperation`](https://developer.apple.com/documentation/appkit/nsdocument/saveoperationtype/saveasoperation). The [`revertDocumentToSaved:`](https://developer.apple.com/documentation/appkit/nsdocument/reverttosaved(_:)) method does too.
    ///
    ///
    #[doc(alias = "NSChangeCleared")]
    pub const ChangeCleared: Self = Self(2);
    /// The document has been initialized with the contents of a file or file package other than the one whose location is in the `fileURL` property, and therefore can’t possibly be synchronized with its persistent representation.
    ///
    /// ## Discussion
    ///
    /// For example, [`initForURL:withContentsOfURL:ofType:error:`](https://developer.apple.com/documentation/appkit/nsdocument/init(for:withcontentsof:oftype:)) passes this value when the two passed-in URLs are not equal to indicate that an autosaved document is being reopened.
    ///
    ///
    #[doc(alias = "NSChangeReadOtherContents")]
    pub const ChangeReadOtherContents: Self = Self(3);
    /// The document’s contents have been autosaved.
    ///
    /// ## Discussion
    ///
    /// For example, [`saveToURL:ofType:forSaveOperation:error:`](https://developer.apple.com/documentation/appkit/nsdocument/savetourl:oftype:forsaveoperation:error:) passes this value for a successful [`NSAutosaveOperation`](https://developer.apple.com/documentation/appkit/nssaveoperationtype/nsautosaveoperation).
    ///
    ///
    #[doc(alias = "NSChangeAutosaved")]
    pub const ChangeAutosaved: Self = Self(4);
    /// A discardable change has been done.
    ///
    /// ## Discussion
    ///
    /// Discardable changes cause the document to be edited. In a locked document, for example, discardable changes may be thrown away instead of prompting the user to save them. Combine this value with the appropriate kind of change, [`NSChangeDone`](https://developer.apple.com/documentation/appkit/nsdocument/changetype/changedone), [`NSChangeUndone`](https://developer.apple.com/documentation/appkit/nsdocument/changetype/changeundone), or [`NSChangeRedone`](https://developer.apple.com/documentation/appkit/nsdocument/changetype/changeredone), using the C bitwise OR operator. For example, a discardable change is `NSChangeDone | NSChangeDiscardable`.
    ///
    ///
    #[doc(alias = "NSChangeDiscardable")]
    pub const ChangeDiscardable: Self = Self(256);
}

unsafe impl Encode for NSDocumentChangeType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSDocumentChangeType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants for specifying the type of document-save operation to perform.
///
/// ## Overview
///
/// These values are used with method parameters of type [`NSSaveOperationType`](https://developer.apple.com/documentation/appkit/nsdocument/saveoperationtype). Depending on the method, the save operation type can affect the title of the Save dialog and can affect which files are displayed in the dialog.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSSaveOperationType(pub NSUInteger);
impl NSSaveOperationType {
    /// An operation that overwrites a document’s file or file package with the document’s contents.
    #[doc(alias = "NSSaveOperation")]
    pub const SaveOperation: Self = Self(0);
    /// An operation that writes the document’s contents to a new location and updates the document to point to that location
    #[doc(alias = "NSSaveAsOperation")]
    pub const SaveAsOperation: Self = Self(1);
    /// An operation that writes a copy of the document’s contents to the specified location, without changing the original document’s location.
    #[doc(alias = "NSSaveToOperation")]
    pub const SaveToOperation: Self = Self(2);
    /// An operation that overwrites the document’s current contents with autosave data.
    #[doc(alias = "NSAutosaveInPlaceOperation")]
    pub const AutosaveInPlaceOperation: Self = Self(4);
    /// An operation that writes an autosave version of the file to a different location.
    ///
    /// ## Discussion
    ///
    /// For an [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) subclass that overrides [`autosavesInPlace`](https://developer.apple.com/documentation/appkit/nsdocument/autosavesinplace) to have the value [`true`](https://developer.apple.com/documentation/swift/true), this is used during autosaving of documents that have never been saved and therefore do not yet have a document file that can be overwritten during autosaving. `NSDocument` may also pass `NSAutosaveElsewhereOperation` when invoking `writeSafelyToURL:ofType:forSaveOperation:error:` while duplicating or reverting a document.
    ///
    ///
    #[doc(alias = "NSAutosaveElsewhereOperation")]
    pub const AutosaveElsewhereOperation: Self = Self(3);
    /// An operation that writes a document’s contents to a new file or file package even though the user has not explicitly requested it, then changes the document’s current location to point to the just-written file or file package.
    #[doc(alias = "NSAutosaveAsOperation")]
    pub const AutosaveAsOperation: Self = Self(5);
    /// Old name for the [`NSDocument.SaveOperationType.autosaveElsewhereOperation`](https://developer.apple.com/documentation/appkit/nsdocument/saveoperationtype/autosaveelsewhereoperation) operation type.
    #[doc(alias = "NSAutosaveOperation")]
    #[deprecated = "Use NSAutosaveElsewhereOperation instead"]
    pub const AutosaveOperation: Self = Self(3);
}

unsafe impl Encode for NSSaveOperationType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSSaveOperationType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An abstract class that defines the interface for macOS documents.
    ///
    /// ## Overview
    ///
    /// A document is an object that can internally represent data displayed in a window and that can read data from and write data to a file or file package. Documents create and manage one or more window controllers and are in turn managed by a document controller. Documents respond to first-responder action messages to save, revert, and print their data.
    ///
    /// Conceptually, a document is a container for a body of information identified by a name under which it is stored in a disk file. In this sense, however, the document is not the same as the file but is an object in memory that owns and manages the document data. In the context of AppKit, a document is an instance of a custom [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) subclass that knows how to represent internally, in one or more formats, persistent data that is displayed in windows.
    ///
    /// A document can read that data from a file and write it to a file. It is also the first-responder target for many menu commands related to documents, such as Save, Revert, and Print. A document manages its window’s edited status and is set up to perform undo and redo operations. When a window is closing, the document is asked before the window delegate to approve the closing.
    ///
    /// [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) is one of the triad of AppKit classes that establish an architectural basis for document-based apps (the others being [`NSDocumentController`](https://developer.apple.com/documentation/appkit/nsdocumentcontroller) and [`NSWindowController`](https://developer.apple.com/documentation/appkit/nswindowcontroller)).
    ///
    /// For more information about using [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) in a document-based app, see [Developing a Document-Based App](https://developer.apple.com/documentation/appkit/developing-a-document-based-app).
    ///
    /// ### Subclassing NSDocument
    ///
    /// The [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) class is designed to be subclassed. That is, the [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) class is abstract, and your app must create at least one [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) subclass in order to use the document architecture. To create a useful [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) subclass, you must override some methods, and you can optionally override others.
    ///
    /// The [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) class itself knows how to handle document data as undifferentiated lumps; although it understands that these lumps are typed, it knows nothing about particular types. In their overrides of the data-based reading and writing methods, subclasses must add the knowledge of particular types and how data of the document’s native type is structured internally. Subclasses are also responsible for the creation of the window controllers that manage document windows and for the implementation of undo and redo. The `NSDocument` class takes care of much of the rest, including generally managing the state of the document.
    ///
    /// See [Document-Based App Programming Guide for Mac](https://developer.apple.com/library/archive/documentation/DataManagement/Conceptual/DocBasedAppProgrammingGuideForOSX/Introduction/Introduction.html#//apple_ref/doc/uid/TP40011179) for more information about creating subclasses of [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument), particularly the list of primitive methods that subclasses must override and those that you can optionally override.
    ///
    /// ### Document Saving Behavior
    ///
    /// The [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) class implements document saving in a way that preserves, when possible, various attributes of each document, including:
    ///
    /// - Creation date
    ///
    /// - Permissions/privileges
    ///
    /// - Location of the document’s icon in its parent folder’s Icon View Finder window
    ///
    /// - Value of the document’s Show Extension setting
    ///
    /// Care is also taken to save documents in a way that does not break any user-created aliases that may point to documents. As a result, some methods in any class of `NSDocument` may be invoked with parameters that do not have the same meaning as they did in early releases of macOS. It is important that overrides of [`writeToURL:ofType:error:`](https://developer.apple.com/documentation/appkit/nsdocument/write(to:oftype:)) and [`writeToURL:ofType:forSaveOperation:originalContentsURL:error:`](https://developer.apple.com/documentation/appkit/nsdocument/write(to:oftype:for:originalcontentsurl:)) make no assumptions about the file paths passed as parameters, including:
    ///
    /// - The location to which the file is being written. This location might be a hidden temporary directory.
    ///
    /// - The name of the file being written. It is possible that this file has no obvious relation to the document name.
    ///
    /// - The relation of any file being passed, including the original file, to the value in [`fileURL`](https://developer.apple.com/documentation/appkit/nsdocument/fileurl).
    ///
    /// When updating your app to link against OS X v10.5, keep in mind that it is usually more appropriate to invoke in your app code one of the `NSDocument` `save...` methods than one of the `write...` methods. The `write...` methods are there primarily for you to override. The [`saveToURL:ofType:forSaveOperation:error:`](https://developer.apple.com/documentation/appkit/nsdocument/savetourl:oftype:forsaveoperation:error:) method that is meant always to be invoked during document saving, sets the [`fileModificationDate`](https://developer.apple.com/documentation/appkit/nsdocument/filemodificationdate) property  with the file’s new modification date after it has been written (for [`NSSaveOperation`](https://developer.apple.com/documentation/appkit/nsdocument/saveoperationtype/saveoperation) and [`NSSaveAsOperation`](https://developer.apple.com/documentation/appkit/nsdocument/saveoperationtype/saveasoperation) only).
    ///
    /// Likewise, it’s usually more appropriate to invoke in your app code one of the `NSDocument` `revert...` methods than one of the `read...` methods. The `read...` methods are there primarily for you to override. The [`revertToContentsOfURL:ofType:error:`](https://developer.apple.com/documentation/appkit/nsdocument/revert(tocontentsof:oftype:)) method that is meant always to be invoked during rereading of an open document, sets the [`fileModificationDate`](https://developer.apple.com/documentation/appkit/nsdocument/filemodificationdate) property with the file’s modification date after it has been read.
    ///
    /// ### iCloud Support
    ///
    /// The [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) class implements the file coordination support that is required for an iCloud-enabled, document-based Mac app (see [How iCloud Document Storage Works](https://developer.apple.com/library/archive/documentation/General/Conceptual/iCloudDesignGuide/Chapters/DesigningForDocumentsIniCloud.html#//apple_ref/doc/uid/TP40012094-CH2-SW10) in [iCloud Design Guide](https://developer.apple.com/library/archive/documentation/General/Conceptual/iCloudDesignGuide/Chapters/Introduction.html#//apple_ref/doc/uid/TP40012094)). In addition, this class’s methods for moving and renaming documents, new in OS X v10.8, ensure that these operations are performed in a safe manner for iCloud-enabled apps.
    ///
    /// ### Multicore Considerations
    ///
    /// In macOS 10.6 and later, `NSDocument` supports the ability to open multiple documents concurrently. However, this support requires the cooperation of the document object. If your document subclass is able to read specific document types independently of other similar documents, you should override the [`canConcurrentlyReadDocumentsOfType:`](https://developer.apple.com/documentation/appkit/nsdocument/canconcurrentlyreaddocuments(oftype:)) class method and return [`true`](https://developer.apple.com/documentation/swift/true) for the appropriate document types. If specific document types rely on shared state information, however, you should return [`false`](https://developer.apple.com/documentation/swift/false) for those types.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSDocument;
);

#[cfg(feature = "NSKeyValueBinding")]
extern_conformance!(
    unsafe impl NSEditorRegistration for NSDocument {}
);

extern_conformance!(
    unsafe impl NSFilePresenter for NSDocument {}
);

#[cfg(feature = "NSMenu")]
extern_conformance!(
    unsafe impl NSMenuItemValidation for NSDocument {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSDocument {}
);

#[cfg(feature = "NSUserInterfaceValidation")]
extern_conformance!(
    unsafe impl NSUserInterfaceValidations for NSDocument {}
);

impl NSDocument {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(initWithType:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithType_error(
            this: Allocated<Self>,
            type_name: &NSString,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[unsafe(method(canConcurrentlyReadDocumentsOfType:))]
        #[unsafe(method_family = none)]
        pub fn canConcurrentlyReadDocumentsOfType(
            type_name: &NSString,
            mtm: MainThreadMarker,
        ) -> bool;

        #[unsafe(method(initWithContentsOfURL:ofType:error:_))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL_ofType_error(
            this: Allocated<Self>,
            url: &NSURL,
            type_name: &NSString,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[unsafe(method(initForURL:withContentsOfURL:ofType:error:_))]
        #[unsafe(method_family = init)]
        pub fn initForURL_withContentsOfURL_ofType_error(
            this: Allocated<Self>,
            url_or_nil: Option<&NSURL>,
            contents_url: &NSURL,
            type_name: &NSString,
        ) -> Result<Retained<Self>, Retained<NSError>>;

        #[unsafe(method(fileType))]
        #[unsafe(method_family = none)]
        pub fn fileType(&self) -> Option<Retained<NSString>>;

        /// Setter for [`fileType`][Self::fileType].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFileType:))]
        #[unsafe(method_family = none)]
        pub fn setFileType(&self, file_type: Option<&NSString>);

        #[unsafe(method(fileURL))]
        #[unsafe(method_family = none)]
        pub fn fileURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`fileURL`][Self::fileURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFileURL:))]
        #[unsafe(method_family = none)]
        pub fn setFileURL(&self, file_url: Option<&NSURL>);

        #[unsafe(method(fileModificationDate))]
        #[unsafe(method_family = none)]
        pub fn fileModificationDate(&self) -> Option<Retained<NSDate>>;

        /// Setter for [`fileModificationDate`][Self::fileModificationDate].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFileModificationDate:))]
        #[unsafe(method_family = none)]
        pub fn setFileModificationDate(&self, file_modification_date: Option<&NSDate>);

        #[unsafe(method(isDraft))]
        #[unsafe(method_family = none)]
        pub fn isDraft(&self) -> bool;

        /// Setter for [`isDraft`][Self::isDraft].
        #[unsafe(method(setDraft:))]
        #[unsafe(method_family = none)]
        pub fn setDraft(&self, draft: bool);

        #[cfg(feature = "block2")]
        #[unsafe(method(performActivityWithSynchronousWaiting:usingBlock:))]
        #[unsafe(method_family = none)]
        pub fn performActivityWithSynchronousWaiting_usingBlock(
            &self,
            wait_synchronously: bool,
            block: &block2::DynBlock<dyn Fn(NonNull<block2::DynBlock<dyn Fn()>>)>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(continueActivityUsingBlock:))]
        #[unsafe(method_family = none)]
        pub fn continueActivityUsingBlock(&self, block: &block2::DynBlock<dyn Fn() + '_>);

        #[cfg(feature = "block2")]
        #[unsafe(method(continueAsynchronousWorkOnMainThreadUsingBlock:))]
        #[unsafe(method_family = none)]
        pub fn continueAsynchronousWorkOnMainThreadUsingBlock(
            &self,
            block: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(performSynchronousFileAccessUsingBlock:))]
        #[unsafe(method_family = none)]
        pub fn performSynchronousFileAccessUsingBlock(
            &self,
            block: &block2::DynBlock<dyn Fn() + '_>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(performAsynchronousFileAccessUsingBlock:))]
        #[unsafe(method_family = none)]
        pub fn performAsynchronousFileAccessUsingBlock(
            &self,
            block: &block2::DynBlock<dyn Fn(NonNull<block2::DynBlock<dyn Fn()>>)>,
        );

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(revertDocumentToSaved:))]
        #[unsafe(method_family = none)]
        pub unsafe fn revertDocumentToSaved(&self, sender: Option<&AnyObject>);

        #[unsafe(method(revertToContentsOfURL:ofType:error:_))]
        #[unsafe(method_family = none)]
        pub fn revertToContentsOfURL_ofType_error(
            &self,
            url: &NSURL,
            type_name: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(readFromURL:ofType:error:_))]
        #[unsafe(method_family = none)]
        pub fn readFromURL_ofType_error(
            &self,
            url: &NSURL,
            type_name: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(readFromFileWrapper:ofType:error:_))]
        #[unsafe(method_family = none)]
        pub fn readFromFileWrapper_ofType_error(
            &self,
            file_wrapper: &NSFileWrapper,
            type_name: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(readFromData:ofType:error:_))]
        #[unsafe(method_family = none)]
        pub fn readFromData_ofType_error(
            &self,
            data: &NSData,
            type_name: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(isEntireFileLoaded))]
        #[unsafe(method_family = none)]
        pub fn isEntireFileLoaded(&self) -> bool;

        #[unsafe(method(writeToURL:ofType:error:_))]
        #[unsafe(method_family = none)]
        pub fn writeToURL_ofType_error(
            &self,
            url: &NSURL,
            type_name: &NSString,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(fileWrapperOfType:error:_))]
        #[unsafe(method_family = none)]
        pub fn fileWrapperOfType_error(
            &self,
            type_name: &NSString,
        ) -> Result<Retained<NSFileWrapper>, Retained<NSError>>;

        #[unsafe(method(dataOfType:error:_))]
        #[unsafe(method_family = none)]
        pub fn dataOfType_error(
            &self,
            type_name: &NSString,
        ) -> Result<Retained<NSData>, Retained<NSError>>;

        #[unsafe(method(unblockUserInteraction))]
        #[unsafe(method_family = none)]
        pub fn unblockUserInteraction(&self);

        #[unsafe(method(autosavingIsImplicitlyCancellable))]
        #[unsafe(method_family = none)]
        pub fn autosavingIsImplicitlyCancellable(&self) -> bool;

        #[unsafe(method(writeSafelyToURL:ofType:forSaveOperation:error:_))]
        #[unsafe(method_family = none)]
        pub fn writeSafelyToURL_ofType_forSaveOperation_error(
            &self,
            url: &NSURL,
            type_name: &NSString,
            save_operation: NSSaveOperationType,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(writeToURL:ofType:forSaveOperation:originalContentsURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn writeToURL_ofType_forSaveOperation_originalContentsURL_error(
            &self,
            url: &NSURL,
            type_name: &NSString,
            save_operation: NSSaveOperationType,
            absolute_original_contents_url: Option<&NSURL>,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(fileAttributesToWriteToURL:ofType:forSaveOperation:originalContentsURL:error:_))]
        #[unsafe(method_family = none)]
        pub fn fileAttributesToWriteToURL_ofType_forSaveOperation_originalContentsURL_error(
            &self,
            url: &NSURL,
            type_name: &NSString,
            save_operation: NSSaveOperationType,
            absolute_original_contents_url: Option<&NSURL>,
        ) -> Result<Retained<NSDictionary<NSString, AnyObject>>, Retained<NSError>>;

        #[unsafe(method(keepBackupFile))]
        #[unsafe(method_family = none)]
        pub fn keepBackupFile(&self) -> bool;

        #[unsafe(method(backupFileURL))]
        #[unsafe(method_family = none)]
        pub fn backupFileURL(&self) -> Option<Retained<NSURL>>;

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(saveDocument:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveDocument(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(saveDocumentAs:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveDocumentAs(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(saveDocumentTo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveDocumentTo(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_save_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(saveDocumentWithDelegate:didSaveSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveDocumentWithDelegate_didSaveSelector_contextInfo(
            &self,
            delegate: Option<&AnyObject>,
            did_save_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_save_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(runModalSavePanelForSaveOperation:delegate:didSaveSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runModalSavePanelForSaveOperation_delegate_didSaveSelector_contextInfo(
            &self,
            save_operation: NSSaveOperationType,
            delegate: Option<&AnyObject>,
            did_save_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[unsafe(method(savePanelShowsFileFormatsControl))]
        #[unsafe(method_family = none)]
        pub fn savePanelShowsFileFormatsControl(&self) -> bool;

        #[cfg(all(
            feature = "NSPanel",
            feature = "NSResponder",
            feature = "NSSavePanel",
            feature = "NSWindow"
        ))]
        #[unsafe(method(prepareSavePanel:))]
        #[unsafe(method_family = none)]
        pub fn prepareSavePanel(&self, save_panel: &NSSavePanel) -> bool;

        #[unsafe(method(fileNameExtensionWasHiddenInLastRunSavePanel))]
        #[unsafe(method_family = none)]
        pub fn fileNameExtensionWasHiddenInLastRunSavePanel(&self) -> bool;

        #[unsafe(method(fileTypeFromLastRunSavePanel))]
        #[unsafe(method_family = none)]
        pub fn fileTypeFromLastRunSavePanel(&self) -> Option<Retained<NSString>>;

        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_save_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(saveToURL:ofType:forSaveOperation:delegate:didSaveSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveToURL_ofType_forSaveOperation_delegate_didSaveSelector_contextInfo(
            &self,
            url: &NSURL,
            type_name: &NSString,
            save_operation: NSSaveOperationType,
            delegate: Option<&AnyObject>,
            did_save_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(saveToURL:ofType:forSaveOperation:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn saveToURL_ofType_forSaveOperation_completionHandler(
            &self,
            url: &NSURL,
            type_name: &NSString,
            save_operation: NSSaveOperationType,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[unsafe(method(canAsynchronouslyWriteToURL:ofType:forSaveOperation:))]
        #[unsafe(method_family = none)]
        pub fn canAsynchronouslyWriteToURL_ofType_forSaveOperation(
            &self,
            url: &NSURL,
            type_name: &NSString,
            save_operation: NSSaveOperationType,
        ) -> bool;

        #[unsafe(method(checkAutosavingSafetyAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub fn checkAutosavingSafetyAndReturnError(&self) -> Result<(), Retained<NSError>>;

        #[unsafe(method(scheduleAutosaving))]
        #[unsafe(method_family = none)]
        pub fn scheduleAutosaving(&self);

        #[unsafe(method(hasUnautosavedChanges))]
        #[unsafe(method_family = none)]
        pub fn hasUnautosavedChanges(&self) -> bool;

        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_autosave_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(autosaveDocumentWithDelegate:didAutosaveSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn autosaveDocumentWithDelegate_didAutosaveSelector_contextInfo(
            &self,
            delegate: Option<&AnyObject>,
            did_autosave_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(autosaveWithImplicitCancellability:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn autosaveWithImplicitCancellability_completionHandler(
            &self,
            autosaving_is_implicitly_cancellable: bool,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[unsafe(method(autosavesInPlace))]
        #[unsafe(method_family = none)]
        pub fn autosavesInPlace(mtm: MainThreadMarker) -> bool;

        #[unsafe(method(preservesVersions))]
        #[unsafe(method_family = none)]
        pub fn preservesVersions(mtm: MainThreadMarker) -> bool;

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(browseDocumentVersions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn browseDocumentVersions(&self, sender: Option<&AnyObject>);

        #[unsafe(method(isBrowsingVersions))]
        #[unsafe(method_family = none)]
        pub fn isBrowsingVersions(&self) -> bool;

        #[cfg(feature = "block2")]
        #[unsafe(method(stopBrowsingVersionsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub fn stopBrowsingVersionsWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn()>>,
        );

        #[unsafe(method(autosavesDrafts))]
        #[unsafe(method_family = none)]
        pub fn autosavesDrafts(mtm: MainThreadMarker) -> bool;

        #[unsafe(method(autosavingFileType))]
        #[unsafe(method_family = none)]
        pub fn autosavingFileType(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(autosavedContentsFileURL))]
        #[unsafe(method_family = none)]
        pub fn autosavedContentsFileURL(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`autosavedContentsFileURL`][Self::autosavedContentsFileURL].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setAutosavedContentsFileURL:))]
        #[unsafe(method_family = none)]
        pub fn setAutosavedContentsFileURL(&self, autosaved_contents_file_url: Option<&NSURL>);

        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `should_close_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(canCloseDocumentWithDelegate:shouldCloseSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn canCloseDocumentWithDelegate_shouldCloseSelector_contextInfo(
            &self,
            delegate: &AnyObject,
            should_close_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[unsafe(method(close))]
        #[unsafe(method_family = none)]
        pub fn close(&self);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(duplicateDocument:))]
        #[unsafe(method_family = none)]
        pub unsafe fn duplicateDocument(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_duplicate_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(duplicateDocumentWithDelegate:didDuplicateSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn duplicateDocumentWithDelegate_didDuplicateSelector_contextInfo(
            &self,
            delegate: Option<&AnyObject>,
            did_duplicate_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[unsafe(method(duplicateAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub fn duplicateAndReturnError(&self) -> Result<Retained<NSDocument>, Retained<NSError>>;

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(renameDocument:))]
        #[unsafe(method_family = none)]
        pub unsafe fn renameDocument(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(moveDocumentToUbiquityContainer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn moveDocumentToUbiquityContainer(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(moveDocument:))]
        #[unsafe(method_family = none)]
        pub unsafe fn moveDocument(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "block2")]
        #[unsafe(method(moveDocumentWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub fn moveDocumentWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(Bool)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(moveToURL:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn moveToURL_completionHandler(
            &self,
            url: &NSURL,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(lockDocument:))]
        #[unsafe(method_family = none)]
        pub unsafe fn lockDocument(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(unlockDocument:))]
        #[unsafe(method_family = none)]
        pub unsafe fn unlockDocument(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "block2")]
        #[unsafe(method(lockDocumentWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub fn lockDocumentWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(Bool)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(lockWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub fn lockWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(unlockDocumentWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub fn unlockDocumentWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(Bool)>>,
        );

        #[cfg(feature = "block2")]
        #[unsafe(method(unlockWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub fn unlockWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        #[unsafe(method(isLocked))]
        #[unsafe(method_family = none)]
        pub fn isLocked(&self) -> bool;

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(runPageLayout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runPageLayout(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "NSPrintInfo")]
        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_run_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(runModalPageLayoutWithPrintInfo:delegate:didRunSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runModalPageLayoutWithPrintInfo_delegate_didRunSelector_contextInfo(
            &self,
            print_info: &NSPrintInfo,
            delegate: Option<&AnyObject>,
            did_run_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[cfg(feature = "NSPageLayout")]
        #[unsafe(method(preparePageLayout:))]
        #[unsafe(method_family = none)]
        pub fn preparePageLayout(&self, page_layout: &NSPageLayout) -> bool;

        #[cfg(feature = "NSPrintInfo")]
        #[unsafe(method(shouldChangePrintInfo:))]
        #[unsafe(method_family = none)]
        pub fn shouldChangePrintInfo(&self, new_print_info: &NSPrintInfo) -> bool;

        #[cfg(feature = "NSPrintInfo")]
        #[unsafe(method(printInfo))]
        #[unsafe(method_family = none)]
        pub fn printInfo(&self) -> Retained<NSPrintInfo>;

        #[cfg(feature = "NSPrintInfo")]
        /// Setter for [`printInfo`][Self::printInfo].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPrintInfo:))]
        #[unsafe(method_family = none)]
        pub fn setPrintInfo(&self, print_info: &NSPrintInfo);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(printDocument:))]
        #[unsafe(method_family = none)]
        pub unsafe fn printDocument(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "NSPrintInfo")]
        /// # Safety
        ///
        /// - `print_settings` generic should be of the correct type.
        /// - `delegate` should be of the correct type.
        /// - `did_print_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(printDocumentWithSettings:showPrintPanel:delegate:didPrintSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn printDocumentWithSettings_showPrintPanel_delegate_didPrintSelector_contextInfo(
            &self,
            print_settings: &NSDictionary<NSPrintInfoAttributeKey, AnyObject>,
            show_print_panel: bool,
            delegate: Option<&AnyObject>,
            did_print_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[cfg(all(feature = "NSPrintInfo", feature = "NSPrintOperation"))]
        /// # Safety
        ///
        /// `print_settings` generic should be of the correct type.
        #[unsafe(method(printOperationWithSettings:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn printOperationWithSettings_error(
            &self,
            print_settings: &NSDictionary<NSPrintInfoAttributeKey, AnyObject>,
        ) -> Result<Retained<NSPrintOperation>, Retained<NSError>>;

        #[cfg(feature = "NSPrintOperation")]
        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_run_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(runModalPrintOperation:delegate:didRunSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn runModalPrintOperation_delegate_didRunSelector_contextInfo(
            &self,
            print_operation: &NSPrintOperation,
            delegate: Option<&AnyObject>,
            did_run_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(saveDocumentToPDF:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveDocumentToPDF(&self, sender: Option<&AnyObject>);

        #[cfg(feature = "NSPrintOperation")]
        #[unsafe(method(PDFPrintOperation))]
        #[unsafe(method_family = none)]
        pub fn PDFPrintOperation(&self) -> Retained<NSPrintOperation>;

        #[unsafe(method(allowsDocumentSharing))]
        #[unsafe(method_family = none)]
        pub fn allowsDocumentSharing(&self) -> bool;

        #[cfg(all(feature = "NSSharingService", feature = "block2"))]
        #[unsafe(method(shareDocumentWithSharingService:completionHandler:))]
        #[unsafe(method_family = none)]
        pub fn shareDocumentWithSharingService_completionHandler(
            &self,
            sharing_service: &NSSharingService,
            completion_handler: Option<&block2::DynBlock<dyn Fn(Bool)>>,
        );

        #[cfg(feature = "NSSharingService")]
        #[unsafe(method(prepareSharingServicePicker:))]
        #[unsafe(method_family = none)]
        pub fn prepareSharingServicePicker(&self, sharing_service_picker: &NSSharingServicePicker);

        #[cfg(feature = "NSPreviewRepresentingActivityItem")]
        #[unsafe(method(previewRepresentableActivityItems))]
        #[unsafe(method_family = none)]
        pub fn previewRepresentableActivityItems(
            &self,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn NSPreviewRepresentableActivityItem>>>>;

        #[cfg(feature = "NSPreviewRepresentingActivityItem")]
        /// Setter for [`previewRepresentableActivityItems`][Self::previewRepresentableActivityItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPreviewRepresentableActivityItems:))]
        #[unsafe(method_family = none)]
        pub fn setPreviewRepresentableActivityItems(
            &self,
            preview_representable_activity_items: Option<
                &NSArray<ProtocolObject<dyn NSPreviewRepresentableActivityItem>>,
            >,
        );

        #[unsafe(method(isDocumentEdited))]
        #[unsafe(method_family = none)]
        pub fn isDocumentEdited(&self) -> bool;

        #[unsafe(method(isInViewingMode))]
        #[unsafe(method_family = none)]
        pub fn isInViewingMode(&self) -> bool;

        #[unsafe(method(updateChangeCount:))]
        #[unsafe(method_family = none)]
        pub fn updateChangeCount(&self, change: NSDocumentChangeType);

        #[unsafe(method(changeCountTokenForSaveOperation:))]
        #[unsafe(method_family = none)]
        pub fn changeCountTokenForSaveOperation(
            &self,
            save_operation: NSSaveOperationType,
        ) -> Retained<AnyObject>;

        /// # Safety
        ///
        /// `change_count_token` should be of the correct type.
        #[unsafe(method(updateChangeCountWithToken:forSaveOperation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateChangeCountWithToken_forSaveOperation(
            &self,
            change_count_token: &AnyObject,
            save_operation: NSSaveOperationType,
        );

        #[unsafe(method(undoManager))]
        #[unsafe(method_family = none)]
        pub fn undoManager(&self) -> Option<Retained<NSUndoManager>>;

        /// Setter for [`undoManager`][Self::undoManager].
        #[unsafe(method(setUndoManager:))]
        #[unsafe(method_family = none)]
        pub fn setUndoManager(&self, undo_manager: Option<&NSUndoManager>);

        #[unsafe(method(hasUndoManager))]
        #[unsafe(method_family = none)]
        pub fn hasUndoManager(&self) -> bool;

        /// Setter for [`hasUndoManager`][Self::hasUndoManager].
        #[unsafe(method(setHasUndoManager:))]
        #[unsafe(method_family = none)]
        pub fn setHasUndoManager(&self, has_undo_manager: bool);

        #[cfg(all(feature = "NSResponder", feature = "NSWindow"))]
        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_present_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(presentError:modalForWindow:delegate:didPresentSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentError_modalForWindow_delegate_didPresentSelector_contextInfo(
            &self,
            error: &NSError,
            window: &NSWindow,
            delegate: Option<&AnyObject>,
            did_present_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[unsafe(method(presentError:))]
        #[unsafe(method_family = none)]
        pub fn presentError(&self, error: &NSError) -> bool;

        #[unsafe(method(willPresentError:))]
        #[unsafe(method_family = none)]
        pub fn willPresentError(&self, error: &NSError) -> Retained<NSError>;

        #[unsafe(method(willNotPresentError:))]
        #[unsafe(method_family = none)]
        pub fn willNotPresentError(&self, error: &NSError);

        #[unsafe(method(makeWindowControllers))]
        #[unsafe(method_family = none)]
        pub fn makeWindowControllers(&self);

        #[cfg(feature = "NSNib")]
        #[unsafe(method(windowNibName))]
        #[unsafe(method_family = none)]
        pub fn windowNibName(&self) -> Option<Retained<NSNibName>>;

        #[cfg(all(feature = "NSResponder", feature = "NSWindowController"))]
        #[unsafe(method(windowControllerWillLoadNib:))]
        #[unsafe(method_family = none)]
        pub fn windowControllerWillLoadNib(&self, window_controller: &NSWindowController);

        #[cfg(all(feature = "NSResponder", feature = "NSWindowController"))]
        #[unsafe(method(windowControllerDidLoadNib:))]
        #[unsafe(method_family = none)]
        pub fn windowControllerDidLoadNib(&self, window_controller: &NSWindowController);

        #[cfg(all(feature = "NSResponder", feature = "NSWindow"))]
        #[unsafe(method(setWindow:))]
        #[unsafe(method_family = none)]
        pub fn setWindow(&self, window: Option<&NSWindow>);

        #[cfg(all(feature = "NSResponder", feature = "NSWindowController"))]
        #[unsafe(method(addWindowController:))]
        #[unsafe(method_family = none)]
        pub fn addWindowController(&self, window_controller: &NSWindowController);

        #[cfg(all(feature = "NSResponder", feature = "NSWindowController"))]
        #[unsafe(method(removeWindowController:))]
        #[unsafe(method_family = none)]
        pub fn removeWindowController(&self, window_controller: &NSWindowController);

        #[unsafe(method(showWindows))]
        #[unsafe(method_family = none)]
        pub fn showWindows(&self);

        #[cfg(all(feature = "NSResponder", feature = "NSWindowController"))]
        #[unsafe(method(windowControllers))]
        #[unsafe(method_family = none)]
        pub fn windowControllers(&self) -> Retained<NSArray<NSWindowController>>;

        #[cfg(all(feature = "NSResponder", feature = "NSWindowController"))]
        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `should_close_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[unsafe(method(shouldCloseWindowController:delegate:shouldCloseSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn shouldCloseWindowController_delegate_shouldCloseSelector_contextInfo(
            &self,
            window_controller: &NSWindowController,
            delegate: Option<&AnyObject>,
            should_close_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[unsafe(method(displayName))]
        #[unsafe(method_family = none)]
        pub fn displayName(&self) -> Retained<NSString>;

        #[unsafe(method(defaultDraftName))]
        #[unsafe(method_family = none)]
        pub fn defaultDraftName(&self) -> Retained<NSString>;

        #[cfg(all(feature = "NSResponder", feature = "NSWindow"))]
        #[unsafe(method(windowForSheet))]
        #[unsafe(method_family = none)]
        pub fn windowForSheet(&self) -> Option<Retained<NSWindow>>;

        #[unsafe(method(readableTypes))]
        #[unsafe(method_family = none)]
        pub fn readableTypes(mtm: MainThreadMarker) -> Retained<NSArray<NSString>>;

        #[unsafe(method(writableTypes))]
        #[unsafe(method_family = none)]
        pub fn writableTypes(mtm: MainThreadMarker) -> Retained<NSArray<NSString>>;

        #[unsafe(method(isNativeType:))]
        #[unsafe(method_family = none)]
        pub fn isNativeType(r#type: &NSString, mtm: MainThreadMarker) -> bool;

        #[unsafe(method(writableTypesForSaveOperation:))]
        #[unsafe(method_family = none)]
        pub fn writableTypesForSaveOperation(
            &self,
            save_operation: NSSaveOperationType,
        ) -> Retained<NSArray<NSString>>;

        #[unsafe(method(fileNameExtensionForType:saveOperation:))]
        #[unsafe(method_family = none)]
        pub fn fileNameExtensionForType_saveOperation(
            &self,
            type_name: &NSString,
            save_operation: NSSaveOperationType,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "NSUserInterfaceValidation")]
        #[unsafe(method(validateUserInterfaceItem:))]
        #[unsafe(method_family = none)]
        pub fn validateUserInterfaceItem(
            &self,
            item: &ProtocolObject<dyn NSValidatedUserInterfaceItem>,
        ) -> bool;

        #[unsafe(method(usesUbiquitousStorage))]
        #[unsafe(method_family = none)]
        pub fn usesUbiquitousStorage(mtm: MainThreadMarker) -> bool;

        #[unsafe(method(presentedItemURL))]
        #[unsafe(method_family = none)]
        pub fn presentedItemURL(&self) -> Option<Retained<NSURL>>;

        #[unsafe(method(observedPresentedItemUbiquityAttributes))]
        #[unsafe(method_family = none)]
        pub fn observedPresentedItemUbiquityAttributes(&self) -> Retained<NSSet<NSURLResourceKey>>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `reader` block must be sendable.
        #[unsafe(method(relinquishPresentedItemToReader:))]
        #[unsafe(method_family = none)]
        pub unsafe fn relinquishPresentedItemToReader(
            &self,
            reader: &block2::DynBlock<dyn Fn(*mut block2::DynBlock<dyn Fn()>)>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `writer` block must be sendable.
        #[unsafe(method(relinquishPresentedItemToWriter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn relinquishPresentedItemToWriter(
            &self,
            writer: &block2::DynBlock<dyn Fn(*mut block2::DynBlock<dyn Fn()>)>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(savePresentedItemChangesWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn savePresentedItemChangesWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `completion_handler` block must be sendable.
        #[unsafe(method(accommodatePresentedItemDeletionWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn accommodatePresentedItemDeletionWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[unsafe(method(presentedItemDidMoveToURL:))]
        #[unsafe(method_family = none)]
        pub fn presentedItemDidMoveToURL(&self, new_url: &NSURL);

        #[unsafe(method(presentedItemDidChange))]
        #[unsafe(method_family = none)]
        pub fn presentedItemDidChange(&self);

        #[unsafe(method(presentedItemDidChangeUbiquityAttributes:))]
        #[unsafe(method_family = none)]
        pub fn presentedItemDidChangeUbiquityAttributes(
            &self,
            attributes: &NSSet<NSURLResourceKey>,
        );

        #[unsafe(method(presentedItemDidGainVersion:))]
        #[unsafe(method_family = none)]
        pub fn presentedItemDidGainVersion(&self, version: &NSFileVersion);

        #[unsafe(method(presentedItemDidLoseVersion:))]
        #[unsafe(method_family = none)]
        pub fn presentedItemDidLoseVersion(&self, version: &NSFileVersion);

        #[unsafe(method(presentedItemDidResolveConflictVersion:))]
        #[unsafe(method_family = none)]
        pub fn presentedItemDidResolveConflictVersion(&self, version: &NSFileVersion);
    );
}

/// Methods declared on superclass `NSObject`.
impl NSDocument {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// NSDeprecated.
impl NSDocument {
    extern_methods!(
        #[deprecated]
        #[unsafe(method(shouldRunSavePanelWithAccessoryView))]
        #[unsafe(method_family = none)]
        pub fn shouldRunSavePanelWithAccessoryView(&self) -> bool;

        #[deprecated = "Use -saveToURL:ofType:forSaveOperation:completionHandler: instead"]
        #[unsafe(method(saveToURL:ofType:forSaveOperation:error:_))]
        #[unsafe(method_family = none)]
        pub fn saveToURL_ofType_forSaveOperation_error(
            &self,
            url: &NSURL,
            type_name: &NSString,
            save_operation: NSSaveOperationType,
        ) -> Result<(), Retained<NSError>>;

        #[deprecated]
        #[unsafe(method(dataRepresentationOfType:))]
        #[unsafe(method_family = none)]
        pub fn dataRepresentationOfType(&self, r#type: &NSString) -> Option<Retained<NSData>>;

        #[deprecated]
        #[unsafe(method(fileAttributesToWriteToFile:ofType:saveOperation:))]
        #[unsafe(method_family = none)]
        pub fn fileAttributesToWriteToFile_ofType_saveOperation(
            &self,
            full_document_path: &NSString,
            document_type_name: &NSString,
            save_operation_type: NSSaveOperationType,
        ) -> Option<Retained<NSDictionary>>;

        #[deprecated]
        #[unsafe(method(fileName))]
        #[unsafe(method_family = none)]
        pub fn fileName(&self) -> Option<Retained<NSString>>;

        #[deprecated]
        #[unsafe(method(fileWrapperRepresentationOfType:))]
        #[unsafe(method_family = none)]
        pub fn fileWrapperRepresentationOfType(
            &self,
            r#type: &NSString,
        ) -> Option<Retained<NSFileWrapper>>;

        #[deprecated]
        #[unsafe(method(initWithContentsOfFile:ofType:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfFile_ofType(
            this: Allocated<Self>,
            absolute_path: &NSString,
            type_name: &NSString,
        ) -> Option<Retained<Self>>;

        #[deprecated]
        #[unsafe(method(initWithContentsOfURL:ofType:))]
        #[unsafe(method_family = init)]
        pub fn initWithContentsOfURL_ofType(
            this: Allocated<Self>,
            url: &NSURL,
            type_name: &NSString,
        ) -> Option<Retained<Self>>;

        #[deprecated]
        #[unsafe(method(loadDataRepresentation:ofType:))]
        #[unsafe(method_family = none)]
        pub fn loadDataRepresentation_ofType(&self, data: &NSData, r#type: &NSString) -> bool;

        #[deprecated]
        #[unsafe(method(loadFileWrapperRepresentation:ofType:))]
        #[unsafe(method_family = none)]
        pub fn loadFileWrapperRepresentation_ofType(
            &self,
            wrapper: &NSFileWrapper,
            r#type: &NSString,
        ) -> bool;

        #[deprecated]
        #[unsafe(method(printShowingPrintPanel:))]
        #[unsafe(method_family = none)]
        pub fn printShowingPrintPanel(&self, flag: bool);

        #[deprecated]
        #[unsafe(method(readFromFile:ofType:))]
        #[unsafe(method_family = none)]
        pub fn readFromFile_ofType(&self, file_name: &NSString, r#type: &NSString) -> bool;

        #[deprecated]
        #[unsafe(method(readFromURL:ofType:))]
        #[unsafe(method_family = none)]
        pub fn readFromURL_ofType(&self, url: &NSURL, r#type: &NSString) -> bool;

        #[deprecated]
        #[unsafe(method(revertToSavedFromFile:ofType:))]
        #[unsafe(method_family = none)]
        pub fn revertToSavedFromFile_ofType(&self, file_name: &NSString, r#type: &NSString)
            -> bool;

        #[deprecated]
        #[unsafe(method(revertToSavedFromURL:ofType:))]
        #[unsafe(method_family = none)]
        pub fn revertToSavedFromURL_ofType(&self, url: &NSURL, r#type: &NSString) -> bool;

        #[cfg(feature = "NSPrintInfo")]
        #[deprecated]
        #[unsafe(method(runModalPageLayoutWithPrintInfo:))]
        #[unsafe(method_family = none)]
        pub fn runModalPageLayoutWithPrintInfo(&self, print_info: &NSPrintInfo) -> NSInteger;

        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `did_save_selector` must be a valid selector.
        /// - `context_info` must be a valid pointer or null.
        #[deprecated]
        #[unsafe(method(saveToFile:saveOperation:delegate:didSaveSelector:contextInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveToFile_saveOperation_delegate_didSaveSelector_contextInfo(
            &self,
            file_name: &NSString,
            save_operation: NSSaveOperationType,
            delegate: Option<&AnyObject>,
            did_save_selector: Option<Sel>,
            context_info: *mut c_void,
        );

        #[deprecated]
        #[unsafe(method(setFileName:))]
        #[unsafe(method_family = none)]
        pub fn setFileName(&self, file_name: Option<&NSString>);

        #[deprecated]
        #[unsafe(method(writeToFile:ofType:))]
        #[unsafe(method_family = none)]
        pub fn writeToFile_ofType(&self, file_name: &NSString, r#type: &NSString) -> bool;

        #[deprecated]
        #[unsafe(method(writeToFile:ofType:originalFile:saveOperation:))]
        #[unsafe(method_family = none)]
        pub fn writeToFile_ofType_originalFile_saveOperation(
            &self,
            full_document_path: &NSString,
            document_type_name: &NSString,
            full_original_document_path: Option<&NSString>,
            save_operation_type: NSSaveOperationType,
        ) -> bool;

        #[deprecated]
        #[unsafe(method(writeToURL:ofType:))]
        #[unsafe(method_family = none)]
        pub fn writeToURL_ofType(&self, url: &NSURL, r#type: &NSString) -> bool;

        #[deprecated]
        #[unsafe(method(writeWithBackupToFile:ofType:saveOperation:))]
        #[unsafe(method_family = none)]
        pub fn writeWithBackupToFile_ofType_saveOperation(
            &self,
            full_document_path: &NSString,
            document_type_name: &NSString,
            save_operation_type: NSSaveOperationType,
        ) -> bool;
    );
}
