//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-image")]
#[cfg(target_vendor = "apple")]
use objc2_core_image::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-quartz-core")]
#[cfg(target_vendor = "apple")]
use objc2_quartz_core::*;

use crate::*;

/// Constants that specify the autoresizing behaviors for views.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSAutoresizingMaskOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NSAutoresizingMaskOptions: NSUInteger {
/// The view cannot be resized.
        #[doc(alias = "NSViewNotSizable")]
        const ViewNotSizable = 0;
/// The left margin between the view and its superview is flexible.
        #[doc(alias = "NSViewMinXMargin")]
        const ViewMinXMargin = 1;
/// The view’s width is flexible.
        #[doc(alias = "NSViewWidthSizable")]
        const ViewWidthSizable = 2;
/// The right margin between the view and its superview is flexible.
        #[doc(alias = "NSViewMaxXMargin")]
        const ViewMaxXMargin = 4;
/// The bottom margin between the view and its superview is flexible.
        #[doc(alias = "NSViewMinYMargin")]
        const ViewMinYMargin = 8;
/// The view’s height is flexible.
        #[doc(alias = "NSViewHeightSizable")]
        const ViewHeightSizable = 16;
/// The top margin between the view and its superview is flexible.
        #[doc(alias = "NSViewMaxYMargin")]
        const ViewMaxYMargin = 32;
    }
}

unsafe impl Encode for NSAutoresizingMaskOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSAutoresizingMaskOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// These constants specify the type of a view’s border.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSBorderType(pub NSUInteger);
impl NSBorderType {
    /// No border.
    #[doc(alias = "NSNoBorder")]
    pub const NoBorder: Self = Self(0);
    /// A black line border around the view.
    #[doc(alias = "NSLineBorder")]
    pub const LineBorder: Self = Self(1);
    /// A concave border that makes the view look sunken.
    #[doc(alias = "NSBezelBorder")]
    pub const BezelBorder: Self = Self(2);
    /// A thin border that looks etched around the image.
    #[doc(alias = "NSGrooveBorder")]
    pub const GrooveBorder: Self = Self(3);
}

unsafe impl Encode for NSBorderType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NSBorderType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Constants that specify how layer resizing is handled when a view is layer-backed or layer-hosting. For more information, see the  [`layerContentsRedrawPolicy`](https://developer.apple.com/documentation/appkit/nsview/layercontentsredrawpolicy-swift.property) property.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSViewLayerContentsRedrawPolicy(pub NSInteger);
impl NSViewLayerContentsRedrawPolicy {
    /// Leave the layer’s contents alone. Never mark the layer as needing display, or draw the view’s contents to the layer. This is how developer created layers (layer-hosting views) are treated.
    #[doc(alias = "NSViewLayerContentsRedrawNever")]
    pub const Never: Self = Self(0);
    /// Any of the `setNeedsDisplay` methods sent to the view will cause the view redraw the affected layer parts by invoking the view’s [`drawRect:`](https://developer.apple.com/documentation/appkit/nsview/draw(_:)), but neither the layer or the view are marked as needing display when the view’s size changes.
    #[doc(alias = "NSViewLayerContentsRedrawOnSetNeedsDisplay")]
    pub const OnSetNeedsDisplay: Self = Self(1);
    /// Resize the view’s backing-layer and redraw the view to the layer when the view’s size changes. If the resize is animated, AppKit will drive the resize animation itself and will do this resize and redraw at each step of the animation. Affected parts of the layer will also be redrawn when the view is marked as needing display. This mode is a superset of [`NSViewLayerContentsRedrawOnSetNeedsDisplay`](https://developer.apple.com/documentation/appkit/nsview/layercontentsredrawpolicy-swift.enum/onsetneedsdisplay). This is the way that layer-backed views are currently treated.
    #[doc(alias = "NSViewLayerContentsRedrawDuringViewResize")]
    pub const DuringViewResize: Self = Self(2);
    /// Resize the layer and redraw the view to the layer when the view’s size changes. This will be done just once at the beginning of a resize animation, not at each frame of the animation. Affected parts of the layer will also be redrawn when the view is marked as needing display. This mode is a superset of [`NSViewLayerContentsRedrawOnSetNeedsDisplay`](https://developer.apple.com/documentation/appkit/nsview/layercontentsredrawpolicy-swift.enum/onsetneedsdisplay).
    #[doc(alias = "NSViewLayerContentsRedrawBeforeViewResize")]
    pub const BeforeViewResize: Self = Self(3);
    /// Redraw the layer contents at the new size and crossfade from the old contents to the new contents. Use this in conjunction with the [`NSViewLayerContentsPlacement`](https://developer.apple.com/documentation/appkit/nsview/layercontentsplacement-swift.enum) constants to get a nice crossfade animation for complex layer-backed views that cannot update correctly at each step of the animation.
    #[doc(alias = "NSViewLayerContentsRedrawCrossfade")]
    pub const Crossfade: Self = Self(4);
}

unsafe impl Encode for NSViewLayerContentsRedrawPolicy {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSViewLayerContentsRedrawPolicy {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// These constants specify the location of the layer content when the content is not rerendered in response to view resizing. For more information, see the [`layerContentsPlacement`](https://developer.apple.com/documentation/appkit/nsview/layercontentsplacement-swift.property) property.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NSViewLayerContentsPlacement(pub NSInteger);
impl NSViewLayerContentsPlacement {
    /// The content is resized to fit the entire bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementScaleAxesIndependently")]
    pub const ScaleAxesIndependently: Self = Self(0);
    /// The content is resized to fit the bounds rectangle, preserving the aspect of the content. If the content does not completely fill the bounds rectangle, the content is centered in the partial axis.
    #[doc(alias = "NSViewLayerContentsPlacementScaleProportionallyToFit")]
    pub const ScaleProportionallyToFit: Self = Self(1);
    /// The content is resized to completely fill the bounds rectangle, while still preserving the aspect of the content. The content is centered in the axis it exceeds.
    #[doc(alias = "NSViewLayerContentsPlacementScaleProportionallyToFill")]
    pub const ScaleProportionallyToFill: Self = Self(2);
    /// The content is horizontally and vertically centered in the bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementCenter")]
    pub const Center: Self = Self(3);
    /// The content is horizontally centered at the top-edge of the bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementTop")]
    pub const Top: Self = Self(4);
    /// The content is positioned in the top-right corner of the bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementTopRight")]
    pub const TopRight: Self = Self(5);
    /// The content is vertically centered at the right-edge of the bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementRight")]
    pub const Right: Self = Self(6);
    /// The content is positioned in the bottom-right corner of the bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementBottomRight")]
    pub const BottomRight: Self = Self(7);
    /// The content is horizontally centered at the bottom-edge of the bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementBottom")]
    pub const Bottom: Self = Self(8);
    /// The content is positioned in the bottom-left corner of the bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementBottomLeft")]
    pub const BottomLeft: Self = Self(9);
    /// The content is vertically centered at the left-edge of the bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementLeft")]
    pub const Left: Self = Self(10);
    /// The content is positioned in the top-left corner of the bounds rectangle.
    #[doc(alias = "NSViewLayerContentsPlacementTopLeft")]
    pub const TopLeft: Self = Self(11);
}

unsafe impl Encode for NSViewLayerContentsPlacement {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NSViewLayerContentsPlacement {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This type describes the rectangle used to track the mouse.
///
/// ## Discussion
///
/// If the value of this type is 0, it is invalid. See the methods [`addTrackingRect:owner:userData:assumeInside:`](https://developer.apple.com/documentation/appkit/nsview/addtrackingrect(_:owner:userdata:assumeinside:)) and [`removeTrackingRect:`](https://developer.apple.com/documentation/appkit/nsview/removetrackingrect(_:)).
///
///
pub type NSTrackingRectTag = NSInteger;

/// This type describes the rectangle used to identify a tooltip rectangle.
///
/// ## Discussion
///
/// If the value of this type is 0, it is invalid. See the methods [`addToolTipRect:owner:userData:`](https://developer.apple.com/documentation/appkit/nsview/addtooltip(_:owner:userdata:)) and[`removeToolTip:`](https://developer.apple.com/documentation/appkit/nsview/removetooltip(_:)).
///
///
pub type NSToolTipTag = NSInteger;

extern_class!(
    /// The infrastructure for drawing, printing, and handling events in an app.
    ///
    /// ## Overview
    ///
    /// You typically don’t use [`NSView`](https://developer.apple.com/documentation/appkit/nsview) objects directly. Instead, you use objects that descend from [`NSView`](https://developer.apple.com/documentation/appkit/nsview) or you subclass [`NSView`](https://developer.apple.com/documentation/appkit/nsview) yourself and override its methods to implement the behavior you need. An instance of the [`NSView`](https://developer.apple.com/documentation/appkit/nsview) class (or one of its subclasses) is commonly known as a view object, or simply as a view.
    ///
    /// Views handle the presentation and interaction with your app’s visible content. You arrange one or more views inside an [`NSWindow`](https://developer.apple.com/documentation/appkit/nswindow) object, which acts as a wrapper for your content. A view object defines a rectangular region for drawing and receiving mouse events. Views handle other chores as well, including the dragging of icons and working with the [`NSScrollView`](https://developer.apple.com/documentation/appkit/nsscrollview) class to support efficient scrolling.
    ///
    /// AppKit handles most of your app’s [`NSView`](https://developer.apple.com/documentation/appkit/nsview) management. Unless you’re implementing a concrete subclass of [`NSView`](https://developer.apple.com/documentation/appkit/nsview) or working intimately with the content of the view hierarchy at runtime, you don’t need to know much about this class’s interface. For any view, there are many methods that you can use as-is. The following methods are commonly used.
    ///
    /// - [`frame`](https://developer.apple.com/documentation/appkit/nsview/frame) returns the location and size of the [`NSView`](https://developer.apple.com/documentation/appkit/nsview) object.
    ///
    /// - [`bounds`](https://developer.apple.com/documentation/appkit/nsview/bounds) returns the internal origin and size of the [`NSView`](https://developer.apple.com/documentation/appkit/nsview) object.
    ///
    /// - [`needsDisplay`](https://developer.apple.com/documentation/appkit/nsview/needsdisplay) determines whether the [`NSView`](https://developer.apple.com/documentation/appkit/nsview) object needs to be redrawn.
    ///
    /// - [`window`](https://developer.apple.com/documentation/appkit/nsview/window) returns the [`NSWindow`](https://developer.apple.com/documentation/appkit/nswindow) object that contains the [`NSView`](https://developer.apple.com/documentation/appkit/nsview) object.
    ///
    /// - [`drawRect:`](https://developer.apple.com/documentation/appkit/nsview/draw(_:)) draws the [`NSView`](https://developer.apple.com/documentation/appkit/nsview) object. (All subclasses must implement this method, but it’s rarely invoked explicitly.) An alternative to drawing is to update the layer directly using the [`updateLayer`](https://developer.apple.com/documentation/appkit/nsview/updatelayer()) method.
    ///
    /// For more information on how `NSView` instances handle event and action messages, see [Cocoa Event Handling Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/EventOverview/Introduction/Introduction.html#//apple_ref/doc/uid/10000060i). For more information on displaying tooltips and contextual menus, see [Displaying Contextual Menus](https://developer.apple.com/documentation/appkit/nsmenu#displaying-contextual-menus) and [Managing Tooltips](https://developer.apple.com/documentation/appkit/nswindow#managing-tooltips).
    ///
    /// ### Subclassing notes
    ///
    /// `NSView` is perhaps the most important class in AppKit when it comes to subclassing and inheritance. Most user-interface objects you see in a Cocoa application are objects that inherit from `NSView`. If you want to create an object that draws itself in a special way, or that responds to mouse clicks in a special way, you would create a custom subclass of `NSView` (or of a class that inherits from `NSView`). Subclassing `NSView` is such a common and important procedure that several technical documents describe how to both draw in custom subclasses and respond to events in custom subclasses. See [Cocoa Drawing Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/CocoaDrawingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40003290) and [Cocoa Event Handling Guide](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/EventOverview/Introduction/Introduction.html#//apple_ref/doc/uid/10000060i) (especially “[Handling Mouse Events](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/EventOverview/HandlingMouseEvents/HandlingMouseEvents.html#//apple_ref/doc/uid/10000060i-CH6)” and “[Mouse Events](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/EventOverview/EventObjectsTypes/EventObjectsTypes.html#//apple_ref/doc/uid/10000060i-CH4-SW10)”).
    ///
    /// #### Handling events in your subclass
    ///
    /// If you subclass [`NSView`](https://developer.apple.com/documentation/appkit/nsview) directly and handle specific types of events, don’t call `super` in the implementations of your event-related methods. Views inherit their event-handling capabilities from their [`NSResponder`](https://developer.apple.com/documentation/appkit/nsresponder) parent class. The default behavior for responders is to pass events up the responder chain, which isn’t the behavior you typically want for a custom view. Therefore, don’t call `super` if your view implements any of the following methods and handles the event:
    ///
    /// - [`mouseDown:`](https://developer.apple.com/documentation/appkit/nsresponder/mousedown(with:))
    ///
    /// - [`mouseDragged:`](https://developer.apple.com/documentation/appkit/nsresponder/mousedragged(with:))
    ///
    /// - [`mouseUp:`](https://developer.apple.com/documentation/appkit/nsresponder/mouseup(with:))
    ///
    /// - [`mouseMoved:`](https://developer.apple.com/documentation/appkit/nsresponder/mousemoved(with:))
    ///
    /// - [`mouseEntered:`](https://developer.apple.com/documentation/appkit/nsresponder/mouseentered(with:))
    ///
    /// - [`mouseExited:`](https://developer.apple.com/documentation/appkit/nsresponder/mouseexited(with:))
    ///
    /// - [`rightMouseDragged:`](https://developer.apple.com/documentation/appkit/nsresponder/rightmousedragged(with:))
    ///
    /// - [`rightMouseUp:`](https://developer.apple.com/documentation/appkit/nsresponder/rightmouseup(with:))
    ///
    /// - [`otherMouseDown:`](https://developer.apple.com/documentation/appkit/nsresponder/othermousedown(with:))
    ///
    /// - [`otherMouseDragged:`](https://developer.apple.com/documentation/appkit/nsresponder/othermousedragged(with:))
    ///
    /// - [`otherMouseUp:`](https://developer.apple.com/documentation/appkit/nsresponder/othermouseup(with:))
    ///
    /// - [`scrollWheel:`](https://developer.apple.com/documentation/appkit/nsresponder/scrollwheel(with:))
    ///
    /// - [`keyDown:`](https://developer.apple.com/documentation/appkit/nsresponder/keydown(with:))
    ///
    /// - [`keyUp:`](https://developer.apple.com/documentation/appkit/nsresponder/keyup(with:))
    ///
    /// - [`flagsChanged:`](https://developer.apple.com/documentation/appkit/nsresponder/flagschanged(with:))
    ///
    /// - [`tabletPoint:`](https://developer.apple.com/documentation/appkit/nsresponder/tabletpoint(with:))
    ///
    /// - [`tabletProximity:`](https://developer.apple.com/documentation/appkit/nsresponder/tabletproximity(with:))
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  `NSView` changes the default behavior of [`rightMouseDown:`](https://developer.apple.com/documentation/appkit/nsresponder/rightmousedown(with:)) so that it calls [`menuForEvent:`](https://developer.apple.com/documentation/appkit/nsview/menu(for:)) and, if non `nil`, presents the contextual menu. In macOS 10.7 and later, if the event is not handled, `NSView` passes the event up the responder chain. Because of these behaviorial changes, call `super` when implementing [`rightMouseDown:`](https://developer.apple.com/documentation/appkit/nsresponder/rightmousedown(with:)) in your custom `NSView` subclasses.
    ///
    ///
    ///
    /// </div>
    /// If your view descends from a class other than `NSView`, call `super` to let the parent view handle any events that you don’t.
    ///
    ///
    #[unsafe(super(NSResponder, NSObject))]
    #[thread_kind = MainThreadOnly]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSResponder")]
    pub struct NSView;
);

#[cfg(all(feature = "NSAccessibilityProtocols", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSAccessibility for NSView {}
);

#[cfg(all(feature = "NSAccessibilityProtocols", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSAccessibilityElementProtocol for NSView {}
);

#[cfg(all(feature = "NSAnimation", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSAnimatablePropertyContainer for NSView {}
);

#[cfg(all(feature = "NSAppearance", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSAppearanceCustomization for NSView {}
);

#[cfg(feature = "NSResponder")]
extern_conformance!(
    unsafe impl NSCoding for NSView {}
);

#[cfg(all(feature = "NSDragging", feature = "NSResponder"))]
extern_conformance!(
    unsafe impl NSDraggingDestination for NSView {}
);

#[cfg(feature = "NSResponder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSView {}
);

#[cfg(all(feature = "NSResponder", feature = "NSUserInterfaceItemIdentification"))]
extern_conformance!(
    unsafe impl NSUserInterfaceItemIdentification for NSView {}
);

#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[unsafe(method(initWithFrame:))]
        #[unsafe(method_family = init)]
        pub fn initWithFrame(this: Allocated<Self>, frame_rect: NSRect) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(window))]
        #[unsafe(method_family = none)]
        pub fn window(&self) -> Option<Retained<NSWindow>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(superview))]
        #[unsafe(method_family = none)]
        pub unsafe fn superview(&self) -> Option<Retained<NSView>>;

        #[unsafe(method(subviews))]
        #[unsafe(method_family = none)]
        pub fn subviews(&self) -> Retained<NSArray<NSView>>;

        /// Setter for [`subviews`][Self::subviews].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSubviews:))]
        #[unsafe(method_family = none)]
        pub fn setSubviews(&self, subviews: &NSArray<NSView>);

        #[unsafe(method(isDescendantOf:))]
        #[unsafe(method_family = none)]
        pub fn isDescendantOf(&self, view: &NSView) -> bool;

        #[unsafe(method(ancestorSharedWithView:))]
        #[unsafe(method_family = none)]
        pub fn ancestorSharedWithView(&self, view: &NSView) -> Option<Retained<NSView>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(opaqueAncestor))]
        #[unsafe(method_family = none)]
        pub unsafe fn opaqueAncestor(&self) -> Option<Retained<NSView>>;

        #[unsafe(method(isHidden))]
        #[unsafe(method_family = none)]
        pub fn isHidden(&self) -> bool;

        /// Setter for [`isHidden`][Self::isHidden].
        #[unsafe(method(setHidden:))]
        #[unsafe(method_family = none)]
        pub fn setHidden(&self, hidden: bool);

        #[unsafe(method(isHiddenOrHasHiddenAncestor))]
        #[unsafe(method_family = none)]
        pub fn isHiddenOrHasHiddenAncestor(&self) -> bool;

        /// # Safety
        ///
        /// - `rects` must be a valid pointer or null.
        /// - `count` must be a valid pointer or null.
        #[unsafe(method(getRectsBeingDrawn:count:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getRectsBeingDrawn_count(
            &self,
            rects: *mut *const NSRect,
            count: *mut NSInteger,
        );

        #[unsafe(method(needsToDrawRect:))]
        #[unsafe(method_family = none)]
        pub fn needsToDrawRect(&self, rect: NSRect) -> bool;

        #[unsafe(method(wantsDefaultClipping))]
        #[unsafe(method_family = none)]
        pub fn wantsDefaultClipping(&self) -> bool;

        #[unsafe(method(viewDidHide))]
        #[unsafe(method_family = none)]
        pub fn viewDidHide(&self);

        #[unsafe(method(viewDidUnhide))]
        #[unsafe(method_family = none)]
        pub fn viewDidUnhide(&self);

        #[unsafe(method(addSubview:))]
        #[unsafe(method_family = none)]
        pub fn addSubview(&self, view: &NSView);

        #[cfg(feature = "NSGraphics")]
        #[unsafe(method(addSubview:positioned:relativeTo:))]
        #[unsafe(method_family = none)]
        pub fn addSubview_positioned_relativeTo(
            &self,
            view: &NSView,
            place: NSWindowOrderingMode,
            other_view: Option<&NSView>,
        );

        /// # Safety
        ///
        /// - `compare` must be implemented correctly.
        /// - `context` must be a valid pointer or null.
        #[unsafe(method(sortSubviewsUsingFunction:context:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sortSubviewsUsingFunction_context(
            &self,
            compare: unsafe extern "C-unwind" fn(
                NonNull<NSView>,
                NonNull<NSView>,
                *mut c_void,
            ) -> NSComparisonResult,
            context: *mut c_void,
        );

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(viewWillMoveToWindow:))]
        #[unsafe(method_family = none)]
        pub fn viewWillMoveToWindow(&self, new_window: Option<&NSWindow>);

        #[unsafe(method(viewDidMoveToWindow))]
        #[unsafe(method_family = none)]
        pub fn viewDidMoveToWindow(&self);

        #[unsafe(method(viewWillMoveToSuperview:))]
        #[unsafe(method_family = none)]
        pub fn viewWillMoveToSuperview(&self, new_superview: Option<&NSView>);

        #[unsafe(method(viewDidMoveToSuperview))]
        #[unsafe(method_family = none)]
        pub fn viewDidMoveToSuperview(&self);

        #[unsafe(method(didAddSubview:))]
        #[unsafe(method_family = none)]
        pub fn didAddSubview(&self, subview: &NSView);

        #[unsafe(method(willRemoveSubview:))]
        #[unsafe(method_family = none)]
        pub fn willRemoveSubview(&self, subview: &NSView);

        #[unsafe(method(removeFromSuperview))]
        #[unsafe(method_family = none)]
        pub fn removeFromSuperview(&self);

        #[unsafe(method(replaceSubview:with:))]
        #[unsafe(method_family = none)]
        pub fn replaceSubview_with(&self, old_view: &NSView, new_view: &NSView);

        #[unsafe(method(removeFromSuperviewWithoutNeedingDisplay))]
        #[unsafe(method_family = none)]
        pub fn removeFromSuperviewWithoutNeedingDisplay(&self);

        #[unsafe(method(viewDidChangeBackingProperties))]
        #[unsafe(method_family = none)]
        pub fn viewDidChangeBackingProperties(&self);

        #[unsafe(method(postsFrameChangedNotifications))]
        #[unsafe(method_family = none)]
        pub fn postsFrameChangedNotifications(&self) -> bool;

        /// Setter for [`postsFrameChangedNotifications`][Self::postsFrameChangedNotifications].
        #[unsafe(method(setPostsFrameChangedNotifications:))]
        #[unsafe(method_family = none)]
        pub fn setPostsFrameChangedNotifications(&self, posts_frame_changed_notifications: bool);

        #[unsafe(method(resizeSubviewsWithOldSize:))]
        #[unsafe(method_family = none)]
        pub fn resizeSubviewsWithOldSize(&self, old_size: NSSize);

        #[unsafe(method(resizeWithOldSuperviewSize:))]
        #[unsafe(method_family = none)]
        pub fn resizeWithOldSuperviewSize(&self, old_size: NSSize);

        #[unsafe(method(autoresizesSubviews))]
        #[unsafe(method_family = none)]
        pub fn autoresizesSubviews(&self) -> bool;

        /// Setter for [`autoresizesSubviews`][Self::autoresizesSubviews].
        #[unsafe(method(setAutoresizesSubviews:))]
        #[unsafe(method_family = none)]
        pub fn setAutoresizesSubviews(&self, autoresizes_subviews: bool);

        #[unsafe(method(autoresizingMask))]
        #[unsafe(method_family = none)]
        pub fn autoresizingMask(&self) -> NSAutoresizingMaskOptions;

        /// Setter for [`autoresizingMask`][Self::autoresizingMask].
        #[unsafe(method(setAutoresizingMask:))]
        #[unsafe(method_family = none)]
        pub fn setAutoresizingMask(&self, autoresizing_mask: NSAutoresizingMaskOptions);

        #[unsafe(method(setFrameOrigin:))]
        #[unsafe(method_family = none)]
        pub fn setFrameOrigin(&self, new_origin: NSPoint);

        #[unsafe(method(setFrameSize:))]
        #[unsafe(method_family = none)]
        pub fn setFrameSize(&self, new_size: NSSize);

        #[unsafe(method(frame))]
        #[unsafe(method_family = none)]
        pub fn frame(&self) -> NSRect;

        /// Setter for [`frame`][Self::frame].
        #[unsafe(method(setFrame:))]
        #[unsafe(method_family = none)]
        pub fn setFrame(&self, frame: NSRect);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(frameRotation))]
        #[unsafe(method_family = none)]
        pub fn frameRotation(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`frameRotation`][Self::frameRotation].
        #[unsafe(method(setFrameRotation:))]
        #[unsafe(method_family = none)]
        pub fn setFrameRotation(&self, frame_rotation: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(frameCenterRotation))]
        #[unsafe(method_family = none)]
        pub fn frameCenterRotation(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`frameCenterRotation`][Self::frameCenterRotation].
        #[unsafe(method(setFrameCenterRotation:))]
        #[unsafe(method_family = none)]
        pub fn setFrameCenterRotation(&self, frame_center_rotation: CGFloat);

        #[unsafe(method(setBoundsOrigin:))]
        #[unsafe(method_family = none)]
        pub fn setBoundsOrigin(&self, new_origin: NSPoint);

        #[unsafe(method(setBoundsSize:))]
        #[unsafe(method_family = none)]
        pub fn setBoundsSize(&self, new_size: NSSize);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(boundsRotation))]
        #[unsafe(method_family = none)]
        pub fn boundsRotation(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`boundsRotation`][Self::boundsRotation].
        #[unsafe(method(setBoundsRotation:))]
        #[unsafe(method_family = none)]
        pub fn setBoundsRotation(&self, bounds_rotation: CGFloat);

        #[unsafe(method(translateOriginToPoint:))]
        #[unsafe(method_family = none)]
        pub fn translateOriginToPoint(&self, translation: NSPoint);

        #[unsafe(method(scaleUnitSquareToSize:))]
        #[unsafe(method_family = none)]
        pub fn scaleUnitSquareToSize(&self, new_unit_size: NSSize);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(rotateByAngle:))]
        #[unsafe(method_family = none)]
        pub fn rotateByAngle(&self, angle: CGFloat);

        #[unsafe(method(bounds))]
        #[unsafe(method_family = none)]
        pub fn bounds(&self) -> NSRect;

        /// Setter for [`bounds`][Self::bounds].
        #[unsafe(method(setBounds:))]
        #[unsafe(method_family = none)]
        pub fn setBounds(&self, bounds: NSRect);

        #[unsafe(method(isFlipped))]
        #[unsafe(method_family = none)]
        pub fn isFlipped(&self) -> bool;

        #[unsafe(method(isRotatedFromBase))]
        #[unsafe(method_family = none)]
        pub fn isRotatedFromBase(&self) -> bool;

        #[unsafe(method(isRotatedOrScaledFromBase))]
        #[unsafe(method_family = none)]
        pub fn isRotatedOrScaledFromBase(&self) -> bool;

        #[unsafe(method(isOpaque))]
        #[unsafe(method_family = none)]
        pub fn isOpaque(&self) -> bool;

        #[unsafe(method(convertPoint:fromView:))]
        #[unsafe(method_family = none)]
        pub fn convertPoint_fromView(&self, point: NSPoint, view: Option<&NSView>) -> NSPoint;

        #[unsafe(method(convertPoint:toView:))]
        #[unsafe(method_family = none)]
        pub fn convertPoint_toView(&self, point: NSPoint, view: Option<&NSView>) -> NSPoint;

        #[unsafe(method(convertSize:fromView:))]
        #[unsafe(method_family = none)]
        pub fn convertSize_fromView(&self, size: NSSize, view: Option<&NSView>) -> NSSize;

        #[unsafe(method(convertSize:toView:))]
        #[unsafe(method_family = none)]
        pub fn convertSize_toView(&self, size: NSSize, view: Option<&NSView>) -> NSSize;

        #[unsafe(method(convertRect:fromView:))]
        #[unsafe(method_family = none)]
        pub fn convertRect_fromView(&self, rect: NSRect, view: Option<&NSView>) -> NSRect;

        #[unsafe(method(convertRect:toView:))]
        #[unsafe(method_family = none)]
        pub fn convertRect_toView(&self, rect: NSRect, view: Option<&NSView>) -> NSRect;

        #[unsafe(method(backingAlignedRect:options:))]
        #[unsafe(method_family = none)]
        pub fn backingAlignedRect_options(
            &self,
            rect: NSRect,
            options: NSAlignmentOptions,
        ) -> NSRect;

        #[unsafe(method(centerScanRect:))]
        #[unsafe(method_family = none)]
        pub fn centerScanRect(&self, rect: NSRect) -> NSRect;

        #[unsafe(method(convertPointToBacking:))]
        #[unsafe(method_family = none)]
        pub fn convertPointToBacking(&self, point: NSPoint) -> NSPoint;

        #[unsafe(method(convertPointFromBacking:))]
        #[unsafe(method_family = none)]
        pub fn convertPointFromBacking(&self, point: NSPoint) -> NSPoint;

        #[unsafe(method(convertSizeToBacking:))]
        #[unsafe(method_family = none)]
        pub fn convertSizeToBacking(&self, size: NSSize) -> NSSize;

        #[unsafe(method(convertSizeFromBacking:))]
        #[unsafe(method_family = none)]
        pub fn convertSizeFromBacking(&self, size: NSSize) -> NSSize;

        #[unsafe(method(convertRectToBacking:))]
        #[unsafe(method_family = none)]
        pub fn convertRectToBacking(&self, rect: NSRect) -> NSRect;

        #[unsafe(method(convertRectFromBacking:))]
        #[unsafe(method_family = none)]
        pub fn convertRectFromBacking(&self, rect: NSRect) -> NSRect;

        #[unsafe(method(convertPointToLayer:))]
        #[unsafe(method_family = none)]
        pub fn convertPointToLayer(&self, point: NSPoint) -> NSPoint;

        #[unsafe(method(convertPointFromLayer:))]
        #[unsafe(method_family = none)]
        pub fn convertPointFromLayer(&self, point: NSPoint) -> NSPoint;

        #[unsafe(method(convertSizeToLayer:))]
        #[unsafe(method_family = none)]
        pub fn convertSizeToLayer(&self, size: NSSize) -> NSSize;

        #[unsafe(method(convertSizeFromLayer:))]
        #[unsafe(method_family = none)]
        pub fn convertSizeFromLayer(&self, size: NSSize) -> NSSize;

        #[unsafe(method(convertRectToLayer:))]
        #[unsafe(method_family = none)]
        pub fn convertRectToLayer(&self, rect: NSRect) -> NSRect;

        #[unsafe(method(convertRectFromLayer:))]
        #[unsafe(method_family = none)]
        pub fn convertRectFromLayer(&self, rect: NSRect) -> NSRect;

        #[unsafe(method(canDrawConcurrently))]
        #[unsafe(method_family = none)]
        pub fn canDrawConcurrently(&self) -> bool;

        /// Setter for [`canDrawConcurrently`][Self::canDrawConcurrently].
        #[unsafe(method(setCanDrawConcurrently:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCanDrawConcurrently(&self, can_draw_concurrently: bool);

        #[deprecated = "If a view needs display, -drawRect: or -updateLayer will be called automatically when the view is able to draw.  To check whether a view is in a window, call -window.  To check whether a view is hidden, call -isHiddenOrHasHiddenAncestor."]
        #[unsafe(method(canDraw))]
        #[unsafe(method_family = none)]
        pub fn canDraw(&self) -> bool;

        #[unsafe(method(setNeedsDisplayInRect:))]
        #[unsafe(method_family = none)]
        pub fn setNeedsDisplayInRect(&self, invalid_rect: NSRect);

        #[unsafe(method(needsDisplay))]
        #[unsafe(method_family = none)]
        pub fn needsDisplay(&self) -> bool;

        /// Setter for [`needsDisplay`][Self::needsDisplay].
        #[unsafe(method(setNeedsDisplay:))]
        #[unsafe(method_family = none)]
        pub fn setNeedsDisplay(&self, needs_display: bool);

        #[deprecated = "To draw, subclass NSView and implement -drawRect:; AppKit's automatic deferred display mechanism will call -drawRect: as necessary to display the view."]
        #[unsafe(method(lockFocus))]
        #[unsafe(method_family = none)]
        pub fn lockFocus(&self);

        #[deprecated = "To draw, subclass NSView and implement -drawRect:; AppKit's automatic deferred display mechanism will call -drawRect: as necessary to display the view."]
        #[unsafe(method(unlockFocus))]
        #[unsafe(method_family = none)]
        pub fn unlockFocus(&self);

        #[deprecated = "To draw, subclass NSView and implement -drawRect:; AppKit's automatic deferred display mechanism will call -drawRect: as necessary to display the view."]
        #[unsafe(method(lockFocusIfCanDraw))]
        #[unsafe(method_family = none)]
        pub fn lockFocusIfCanDraw(&self) -> bool;

        #[cfg(feature = "NSGraphicsContext")]
        #[deprecated = "Use -[NSView displayRectIgnoringOpacity:inContext:] to draw a view subtree into a graphics context."]
        #[unsafe(method(lockFocusIfCanDrawInContext:))]
        #[unsafe(method_family = none)]
        pub fn lockFocusIfCanDrawInContext(&self, context: &NSGraphicsContext) -> bool;

        #[unsafe(method(focusView))]
        #[unsafe(method_family = none)]
        pub fn focusView(mtm: MainThreadMarker) -> Option<Retained<NSView>>;

        /// The portion of the view that isn’t clipped by its superviews.
        ///
        /// Visibility, as reflected by this property, doesn’t account for whether other view or window objects overlap the current view or whether the current view is installed in a window at all. This value of this property is `NSZeroRect` if the current view is effectively hidden.
        ///
        /// During a printing operation, the visible rectangle is further clipped to the page being imaged.
        #[unsafe(method(visibleRect))]
        #[unsafe(method_family = none)]
        pub fn visibleRect(&self) -> NSRect;

        #[unsafe(method(display))]
        #[unsafe(method_family = none)]
        pub fn display(&self);

        #[unsafe(method(displayIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn displayIfNeeded(&self);

        #[unsafe(method(displayIfNeededIgnoringOpacity))]
        #[unsafe(method_family = none)]
        pub fn displayIfNeededIgnoringOpacity(&self);

        #[unsafe(method(displayRect:))]
        #[unsafe(method_family = none)]
        pub fn displayRect(&self, rect: NSRect);

        #[unsafe(method(displayIfNeededInRect:))]
        #[unsafe(method_family = none)]
        pub fn displayIfNeededInRect(&self, rect: NSRect);

        #[unsafe(method(displayRectIgnoringOpacity:))]
        #[unsafe(method_family = none)]
        pub fn displayRectIgnoringOpacity(&self, rect: NSRect);

        #[unsafe(method(displayIfNeededInRectIgnoringOpacity:))]
        #[unsafe(method_family = none)]
        pub fn displayIfNeededInRectIgnoringOpacity(&self, rect: NSRect);

        #[unsafe(method(drawRect:))]
        #[unsafe(method_family = none)]
        pub fn drawRect(&self, dirty_rect: NSRect);

        #[cfg(feature = "NSGraphicsContext")]
        #[unsafe(method(displayRectIgnoringOpacity:inContext:))]
        #[unsafe(method_family = none)]
        pub fn displayRectIgnoringOpacity_inContext(
            &self,
            rect: NSRect,
            context: &NSGraphicsContext,
        );

        #[cfg(all(feature = "NSBitmapImageRep", feature = "NSImageRep"))]
        #[unsafe(method(bitmapImageRepForCachingDisplayInRect:))]
        #[unsafe(method_family = none)]
        pub fn bitmapImageRepForCachingDisplayInRect(
            &self,
            rect: NSRect,
        ) -> Option<Retained<NSBitmapImageRep>>;

        #[cfg(all(feature = "NSBitmapImageRep", feature = "NSImageRep"))]
        #[unsafe(method(cacheDisplayInRect:toBitmapImageRep:))]
        #[unsafe(method_family = none)]
        pub fn cacheDisplayInRect_toBitmapImageRep(
            &self,
            rect: NSRect,
            bitmap_image_rep: &NSBitmapImageRep,
        );

        #[unsafe(method(viewWillDraw))]
        #[unsafe(method_family = none)]
        pub fn viewWillDraw(&self);

        #[unsafe(method(scrollPoint:))]
        #[unsafe(method_family = none)]
        pub fn scrollPoint(&self, point: NSPoint);

        #[unsafe(method(scrollRectToVisible:))]
        #[unsafe(method_family = none)]
        pub fn scrollRectToVisible(&self, rect: NSRect) -> bool;

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(autoscroll:))]
        #[unsafe(method_family = none)]
        pub fn autoscroll(&self, event: &NSEvent) -> bool;

        #[unsafe(method(adjustScroll:))]
        #[unsafe(method_family = none)]
        pub fn adjustScroll(&self, new_visible: NSRect) -> NSRect;

        #[deprecated = "Use NSScrollView to achieve scrolling views."]
        #[unsafe(method(scrollRect:by:))]
        #[unsafe(method_family = none)]
        pub fn scrollRect_by(&self, rect: NSRect, delta: NSSize);

        #[unsafe(method(translateRectsNeedingDisplayInRect:by:))]
        #[unsafe(method_family = none)]
        pub fn translateRectsNeedingDisplayInRect_by(&self, clip_rect: NSRect, delta: NSSize);

        #[unsafe(method(hitTest:))]
        #[unsafe(method_family = none)]
        pub fn hitTest(&self, point: NSPoint) -> Option<Retained<NSView>>;

        #[unsafe(method(mouse:inRect:))]
        #[unsafe(method_family = none)]
        pub fn mouse_inRect(&self, point: NSPoint, rect: NSRect) -> bool;

        #[unsafe(method(viewWithTag:))]
        #[unsafe(method_family = none)]
        pub fn viewWithTag(&self, tag: NSInteger) -> Option<Retained<NSView>>;

        #[unsafe(method(tag))]
        #[unsafe(method_family = none)]
        pub fn tag(&self) -> NSInteger;

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(performKeyEquivalent:))]
        #[unsafe(method_family = none)]
        pub fn performKeyEquivalent(&self, event: &NSEvent) -> bool;

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(acceptsFirstMouse:))]
        #[unsafe(method_family = none)]
        pub fn acceptsFirstMouse(&self, event: Option<&NSEvent>) -> bool;

        #[cfg(feature = "NSEvent")]
        #[unsafe(method(shouldDelayWindowOrderingForEvent:))]
        #[unsafe(method_family = none)]
        pub fn shouldDelayWindowOrderingForEvent(&self, event: &NSEvent) -> bool;

        #[unsafe(method(needsPanelToBecomeKey))]
        #[unsafe(method_family = none)]
        pub fn needsPanelToBecomeKey(&self) -> bool;

        #[unsafe(method(mouseDownCanMoveWindow))]
        #[unsafe(method_family = none)]
        pub fn mouseDownCanMoveWindow(&self) -> bool;

        #[deprecated = "Use allowedTouchTypes instead"]
        #[unsafe(method(acceptsTouchEvents))]
        #[unsafe(method_family = none)]
        pub fn acceptsTouchEvents(&self) -> bool;

        /// Setter for [`acceptsTouchEvents`][Self::acceptsTouchEvents].
        #[deprecated = "Use allowedTouchTypes instead"]
        #[unsafe(method(setAcceptsTouchEvents:))]
        #[unsafe(method_family = none)]
        pub fn setAcceptsTouchEvents(&self, accepts_touch_events: bool);

        #[unsafe(method(wantsRestingTouches))]
        #[unsafe(method_family = none)]
        pub fn wantsRestingTouches(&self) -> bool;

        /// Setter for [`wantsRestingTouches`][Self::wantsRestingTouches].
        #[unsafe(method(setWantsRestingTouches:))]
        #[unsafe(method_family = none)]
        pub fn setWantsRestingTouches(&self, wants_resting_touches: bool);

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(makeBackingLayer))]
        #[unsafe(method_family = none)]
        pub fn makeBackingLayer(&self) -> Retained<CALayer>;

        #[unsafe(method(layerContentsRedrawPolicy))]
        #[unsafe(method_family = none)]
        pub fn layerContentsRedrawPolicy(&self) -> NSViewLayerContentsRedrawPolicy;

        /// Setter for [`layerContentsRedrawPolicy`][Self::layerContentsRedrawPolicy].
        #[unsafe(method(setLayerContentsRedrawPolicy:))]
        #[unsafe(method_family = none)]
        pub fn setLayerContentsRedrawPolicy(
            &self,
            layer_contents_redraw_policy: NSViewLayerContentsRedrawPolicy,
        );

        #[unsafe(method(layerContentsPlacement))]
        #[unsafe(method_family = none)]
        pub fn layerContentsPlacement(&self) -> NSViewLayerContentsPlacement;

        /// Setter for [`layerContentsPlacement`][Self::layerContentsPlacement].
        #[unsafe(method(setLayerContentsPlacement:))]
        #[unsafe(method_family = none)]
        pub fn setLayerContentsPlacement(
            &self,
            layer_contents_placement: NSViewLayerContentsPlacement,
        );

        #[unsafe(method(wantsLayer))]
        #[unsafe(method_family = none)]
        pub fn wantsLayer(&self) -> bool;

        /// Setter for [`wantsLayer`][Self::wantsLayer].
        #[unsafe(method(setWantsLayer:))]
        #[unsafe(method_family = none)]
        pub fn setWantsLayer(&self, wants_layer: bool);

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(layer))]
        #[unsafe(method_family = none)]
        pub fn layer(&self) -> Option<Retained<CALayer>>;

        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(target_vendor = "apple")]
        /// Setter for [`layer`][Self::layer].
        #[unsafe(method(setLayer:))]
        #[unsafe(method_family = none)]
        pub fn setLayer(&self, layer: Option<&CALayer>);

        #[unsafe(method(wantsUpdateLayer))]
        #[unsafe(method_family = none)]
        pub fn wantsUpdateLayer(&self) -> bool;

        #[unsafe(method(updateLayer))]
        #[unsafe(method_family = none)]
        pub fn updateLayer(&self);

        #[unsafe(method(canDrawSubviewsIntoLayer))]
        #[unsafe(method_family = none)]
        pub fn canDrawSubviewsIntoLayer(&self) -> bool;

        /// Setter for [`canDrawSubviewsIntoLayer`][Self::canDrawSubviewsIntoLayer].
        #[unsafe(method(setCanDrawSubviewsIntoLayer:))]
        #[unsafe(method_family = none)]
        pub fn setCanDrawSubviewsIntoLayer(&self, can_draw_subviews_into_layer: bool);

        #[unsafe(method(layoutSubtreeIfNeeded))]
        #[unsafe(method_family = none)]
        pub fn layoutSubtreeIfNeeded(&self);

        #[unsafe(method(layout))]
        #[unsafe(method_family = none)]
        pub fn layout(&self);

        #[unsafe(method(needsLayout))]
        #[unsafe(method_family = none)]
        pub fn needsLayout(&self) -> bool;

        /// Setter for [`needsLayout`][Self::needsLayout].
        #[unsafe(method(setNeedsLayout:))]
        #[unsafe(method_family = none)]
        pub fn setNeedsLayout(&self, needs_layout: bool);

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(alphaValue))]
        #[unsafe(method_family = none)]
        pub fn alphaValue(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`alphaValue`][Self::alphaValue].
        #[unsafe(method(setAlphaValue:))]
        #[unsafe(method_family = none)]
        pub fn setAlphaValue(&self, alpha_value: CGFloat);

        #[unsafe(method(layerUsesCoreImageFilters))]
        #[unsafe(method_family = none)]
        pub fn layerUsesCoreImageFilters(&self) -> bool;

        /// Setter for [`layerUsesCoreImageFilters`][Self::layerUsesCoreImageFilters].
        #[unsafe(method(setLayerUsesCoreImageFilters:))]
        #[unsafe(method_family = none)]
        pub fn setLayerUsesCoreImageFilters(&self, layer_uses_core_image_filters: bool);

        #[cfg(feature = "objc2-core-image")]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(backgroundFilters))]
        #[unsafe(method_family = none)]
        pub fn backgroundFilters(&self) -> Retained<NSArray<CIFilter>>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(target_vendor = "apple")]
        /// Setter for [`backgroundFilters`][Self::backgroundFilters].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setBackgroundFilters:))]
        #[unsafe(method_family = none)]
        pub fn setBackgroundFilters(&self, background_filters: &NSArray<CIFilter>);

        #[cfg(feature = "objc2-core-image")]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(compositingFilter))]
        #[unsafe(method_family = none)]
        pub fn compositingFilter(&self) -> Option<Retained<CIFilter>>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(target_vendor = "apple")]
        /// Setter for [`compositingFilter`][Self::compositingFilter].
        #[unsafe(method(setCompositingFilter:))]
        #[unsafe(method_family = none)]
        pub fn setCompositingFilter(&self, compositing_filter: Option<&CIFilter>);

        #[cfg(feature = "objc2-core-image")]
        #[cfg(target_vendor = "apple")]
        #[unsafe(method(contentFilters))]
        #[unsafe(method_family = none)]
        pub fn contentFilters(&self) -> Retained<NSArray<CIFilter>>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(target_vendor = "apple")]
        /// Setter for [`contentFilters`][Self::contentFilters].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setContentFilters:))]
        #[unsafe(method_family = none)]
        pub fn setContentFilters(&self, content_filters: &NSArray<CIFilter>);

        #[cfg(feature = "NSShadow")]
        #[unsafe(method(shadow))]
        #[unsafe(method_family = none)]
        pub fn shadow(&self) -> Option<Retained<NSShadow>>;

        #[cfg(feature = "NSShadow")]
        /// Setter for [`shadow`][Self::shadow].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setShadow:))]
        #[unsafe(method_family = none)]
        pub fn setShadow(&self, shadow: Option<&NSShadow>);

        #[unsafe(method(clipsToBounds))]
        #[unsafe(method_family = none)]
        pub fn clipsToBounds(&self) -> bool;

        /// Setter for [`clipsToBounds`][Self::clipsToBounds].
        #[unsafe(method(setClipsToBounds:))]
        #[unsafe(method_family = none)]
        pub fn setClipsToBounds(&self, clips_to_bounds: bool);

        #[unsafe(method(postsBoundsChangedNotifications))]
        #[unsafe(method_family = none)]
        pub fn postsBoundsChangedNotifications(&self) -> bool;

        /// Setter for [`postsBoundsChangedNotifications`][Self::postsBoundsChangedNotifications].
        #[unsafe(method(setPostsBoundsChangedNotifications:))]
        #[unsafe(method_family = none)]
        pub fn setPostsBoundsChangedNotifications(&self, posts_bounds_changed_notifications: bool);

        #[cfg(feature = "NSScrollView")]
        #[unsafe(method(enclosingScrollView))]
        #[unsafe(method_family = none)]
        pub fn enclosingScrollView(&self) -> Option<Retained<NSScrollView>>;

        #[cfg(all(feature = "NSEvent", feature = "NSMenu"))]
        #[unsafe(method(menuForEvent:))]
        #[unsafe(method_family = none)]
        pub fn menuForEvent(&self, event: &NSEvent) -> Option<Retained<NSMenu>>;

        #[cfg(feature = "NSMenu")]
        #[unsafe(method(defaultMenu))]
        #[unsafe(method_family = none)]
        pub fn defaultMenu(mtm: MainThreadMarker) -> Option<Retained<NSMenu>>;

        #[cfg(all(feature = "NSEvent", feature = "NSMenu"))]
        /// A contextual menu is being opened from the receiving view.
        /// The view should update any visual state in response — such as making a selection.
        ///
        /// Parameter `menu`: The contextual menu that is being opened on the view
        ///
        /// Parameter `event`: The event that caused the menu to open.
        #[unsafe(method(willOpenMenu:withEvent:))]
        #[unsafe(method_family = none)]
        pub fn willOpenMenu_withEvent(&self, menu: &NSMenu, event: &NSEvent);

        #[cfg(all(feature = "NSEvent", feature = "NSMenu"))]
        /// A contextual menu shown from the receiving view has been closed. This is only called if the menu had been opened and the view previously received
        /// `-willOpenMenu:withEvent:.`The view should update any visual state in response — such as removing a temporary selection.
        ///
        /// Parameter `menu`: The contextual menu that was open on the view
        ///
        /// Parameter `event`: The event that caused the menu to close. This may be nil if there is no specific event that triggered the closing.
        #[unsafe(method(didCloseMenu:withEvent:))]
        #[unsafe(method_family = none)]
        pub fn didCloseMenu_withEvent(&self, menu: &NSMenu, event: Option<&NSEvent>);

        #[unsafe(method(toolTip))]
        #[unsafe(method_family = none)]
        pub fn toolTip(&self) -> Option<Retained<NSString>>;

        /// Setter for [`toolTip`][Self::toolTip].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setToolTip:))]
        #[unsafe(method_family = none)]
        pub fn setToolTip(&self, tool_tip: Option<&NSString>);

        /// # Safety
        ///
        /// - `owner` should be of the correct type.
        /// - `data` must be a valid pointer or null.
        #[unsafe(method(addToolTipRect:owner:userData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addToolTipRect_owner_userData(
            &self,
            rect: NSRect,
            owner: &AnyObject,
            data: *mut c_void,
        ) -> NSToolTipTag;

        #[unsafe(method(removeToolTip:))]
        #[unsafe(method_family = none)]
        pub fn removeToolTip(&self, tag: NSToolTipTag);

        #[unsafe(method(removeAllToolTips))]
        #[unsafe(method_family = none)]
        pub fn removeAllToolTips(&self);

        #[unsafe(method(viewWillStartLiveResize))]
        #[unsafe(method_family = none)]
        pub fn viewWillStartLiveResize(&self);

        #[unsafe(method(viewDidEndLiveResize))]
        #[unsafe(method_family = none)]
        pub fn viewDidEndLiveResize(&self);

        #[unsafe(method(inLiveResize))]
        #[unsafe(method_family = none)]
        pub fn inLiveResize(&self) -> bool;

        #[unsafe(method(preservesContentDuringLiveResize))]
        #[unsafe(method_family = none)]
        pub fn preservesContentDuringLiveResize(&self) -> bool;

        #[unsafe(method(rectPreservedDuringLiveResize))]
        #[unsafe(method_family = none)]
        pub fn rectPreservedDuringLiveResize(&self) -> NSRect;

        #[unsafe(method(getRectsExposedDuringLiveResize:count:))]
        #[unsafe(method_family = none)]
        pub fn getRectsExposedDuringLiveResize_count(
            &self,
            exposed_rects: &mut [NSRect; 4],
            count: &mut NSInteger,
        );

        #[cfg(feature = "NSTextInputContext")]
        #[unsafe(method(inputContext))]
        #[unsafe(method_family = none)]
        pub fn inputContext(&self) -> Option<Retained<NSTextInputContext>>;

        #[unsafe(method(rectForSmartMagnificationAtPoint:inRect:))]
        #[unsafe(method_family = none)]
        pub fn rectForSmartMagnificationAtPoint_inRect(
            &self,
            location: NSPoint,
            visible_rect: NSRect,
        ) -> NSRect;

        #[cfg(feature = "NSUserInterfaceLayout")]
        #[unsafe(method(userInterfaceLayoutDirection))]
        #[unsafe(method_family = none)]
        pub fn userInterfaceLayoutDirection(&self) -> NSUserInterfaceLayoutDirection;

        #[cfg(feature = "NSUserInterfaceLayout")]
        /// Setter for [`userInterfaceLayoutDirection`][Self::userInterfaceLayoutDirection].
        #[unsafe(method(setUserInterfaceLayoutDirection:))]
        #[unsafe(method_family = none)]
        pub fn setUserInterfaceLayoutDirection(
            &self,
            user_interface_layout_direction: NSUserInterfaceLayoutDirection,
        );

        #[unsafe(method(prepareForReuse))]
        #[unsafe(method_family = none)]
        pub fn prepareForReuse(&self);

        #[unsafe(method(isCompatibleWithResponsiveScrolling))]
        #[unsafe(method_family = none)]
        pub fn isCompatibleWithResponsiveScrolling(mtm: MainThreadMarker) -> bool;

        #[unsafe(method(prepareContentInRect:))]
        #[unsafe(method_family = none)]
        pub fn prepareContentInRect(&self, rect: NSRect);

        #[unsafe(method(preparedContentRect))]
        #[unsafe(method_family = none)]
        pub fn preparedContentRect(&self) -> NSRect;

        /// Setter for [`preparedContentRect`][Self::preparedContentRect].
        #[unsafe(method(setPreparedContentRect:))]
        #[unsafe(method_family = none)]
        pub fn setPreparedContentRect(&self, prepared_content_rect: NSRect);

        #[unsafe(method(allowsVibrancy))]
        #[unsafe(method_family = none)]
        pub fn allowsVibrancy(&self) -> bool;

        /// Override point for reacting to the effective appearance of the receiver changing. At this point `effectiveAppearance` property reflects the new appearance.
        #[unsafe(method(viewDidChangeEffectiveAppearance))]
        #[unsafe(method_family = none)]
        pub fn viewDidChangeEffectiveAppearance(&self);
    );
}

/// Methods declared on superclass `NSResponder`.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

extern_protocol!(
    /// An optional layer delegate method for handling resolution changes.
    ///
    /// ## Overview
    ///
    /// Use this protocol to manage scale and contents for a layer hosted in a view. When a window changes its backing resolution, AppKit attempts to automatically update the `contentsScale` and `contents` of all `CALayer` objects in the window to match the new resolution. Layers backed by a view are updated automatically. Any layer whose `contents` property is set to an `NSImage` object is also updated automatically. Based on the `NSImage` object’s available representations, AppKit selects an appropriate bitmapped representation, or rasterizes a resolution-independent representation at the appropriate scale factor.
    ///
    /// For all other layers, AppKit checks whether the layer has a delegate that implements this protocol.  If so, AppKit asks the layer’s delegate whether it should automatically update the `contentsScale` for that layer to match the new scale factor of the window.
    ///
    ///
    pub unsafe trait NSViewLayerContentScaleDelegate: NSObjectProtocol {
        #[cfg(all(
            feature = "NSResponder",
            feature = "NSWindow",
            feature = "objc2-core-foundation",
            feature = "objc2-quartz-core"
        ))]
        #[cfg(target_vendor = "apple")]
        #[optional]
        #[unsafe(method(layer:shouldInheritContentsScale:fromWindow:))]
        #[unsafe(method_family = none)]
        fn layer_shouldInheritContentsScale_fromWindow(
            &self,
            layer: &CALayer,
            new_scale: CGFloat,
            window: &NSWindow,
        ) -> bool;
    }
);

extern_protocol!(
    /// A set of methods for dynamically associating a tool tip with a view.
    ///
    /// ## Overview
    ///
    /// Tool tips are hints displayed to the user when the mouse hovers over a view. Adopt this protocol in views for which you want to provide tool tips. If the view does not implement this protocol, the system uses the [`description`](https://developer.apple.com/documentation/objectivec/nsobjectprotocol/description) method instead.
    ///
    ///
    pub unsafe trait NSViewToolTipOwner: NSObjectProtocol + MainThreadOnly {
        #[cfg(feature = "NSResponder")]
        /// # Safety
        ///
        /// `data` must be a valid pointer or null.
        #[unsafe(method(view:stringForToolTip:point:userData:))]
        #[unsafe(method_family = none)]
        unsafe fn view_stringForToolTip_point_userData(
            &self,
            view: &NSView,
            tag: NSToolTipTag,
            point: NSPoint,
            data: *mut c_void,
        ) -> Retained<NSString>;
    }
);

extern_protocol!(
    ///
    /// ## Overview
    ///
    /// A protocol to request information from NSView subclasses about the selected content in the view.
    ///
    ///
    /// A protocol to request information from NSView subclasses about the selected content in the view.
    pub unsafe trait NSViewContentSelectionInfo: NSObjectProtocol {
        #[optional]
        #[unsafe(method(selectionAnchorRect))]
        #[unsafe(method_family = none)]
        fn selectionAnchorRect(&self) -> NSRect;
    }
);

/// NSKeyboardUI.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(nextKeyView))]
        #[unsafe(method_family = none)]
        pub unsafe fn nextKeyView(&self) -> Option<Retained<NSView>>;

        /// Setter for [`nextKeyView`][Self::nextKeyView].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setNextKeyView:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNextKeyView(&self, next_key_view: Option<&NSView>);

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(previousKeyView))]
        #[unsafe(method_family = none)]
        pub unsafe fn previousKeyView(&self) -> Option<Retained<NSView>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(nextValidKeyView))]
        #[unsafe(method_family = none)]
        pub unsafe fn nextValidKeyView(&self) -> Option<Retained<NSView>>;

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(previousValidKeyView))]
        #[unsafe(method_family = none)]
        pub unsafe fn previousValidKeyView(&self) -> Option<Retained<NSView>>;

        #[unsafe(method(canBecomeKeyView))]
        #[unsafe(method_family = none)]
        pub fn canBecomeKeyView(&self) -> bool;

        #[unsafe(method(setKeyboardFocusRingNeedsDisplayInRect:))]
        #[unsafe(method_family = none)]
        pub fn setKeyboardFocusRingNeedsDisplayInRect(&self, rect: NSRect);

        #[cfg(feature = "NSGraphics")]
        #[unsafe(method(focusRingType))]
        #[unsafe(method_family = none)]
        pub fn focusRingType(&self) -> NSFocusRingType;

        #[cfg(feature = "NSGraphics")]
        /// Setter for [`focusRingType`][Self::focusRingType].
        #[unsafe(method(setFocusRingType:))]
        #[unsafe(method_family = none)]
        pub fn setFocusRingType(&self, focus_ring_type: NSFocusRingType);

        #[cfg(feature = "NSGraphics")]
        #[unsafe(method(defaultFocusRingType))]
        #[unsafe(method_family = none)]
        pub fn defaultFocusRingType(mtm: MainThreadMarker) -> NSFocusRingType;

        #[unsafe(method(drawFocusRingMask))]
        #[unsafe(method_family = none)]
        pub fn drawFocusRingMask(&self);

        #[unsafe(method(focusRingMaskBounds))]
        #[unsafe(method_family = none)]
        pub fn focusRingMaskBounds(&self) -> NSRect;

        #[unsafe(method(noteFocusRingMaskChanged))]
        #[unsafe(method_family = none)]
        pub fn noteFocusRingMaskChanged(&self);
    );
}

/// NSPrinting.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[cfg(feature = "NSPasteboard")]
        #[unsafe(method(writeEPSInsideRect:toPasteboard:))]
        #[unsafe(method_family = none)]
        pub fn writeEPSInsideRect_toPasteboard(&self, rect: NSRect, pasteboard: &NSPasteboard);

        #[unsafe(method(dataWithEPSInsideRect:))]
        #[unsafe(method_family = none)]
        pub fn dataWithEPSInsideRect(&self, rect: NSRect) -> Retained<NSData>;

        #[cfg(feature = "NSPasteboard")]
        #[unsafe(method(writePDFInsideRect:toPasteboard:))]
        #[unsafe(method_family = none)]
        pub fn writePDFInsideRect_toPasteboard(&self, rect: NSRect, pasteboard: &NSPasteboard);

        #[unsafe(method(dataWithPDFInsideRect:))]
        #[unsafe(method_family = none)]
        pub fn dataWithPDFInsideRect(&self, rect: NSRect) -> Retained<NSData>;

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(print:))]
        #[unsafe(method_family = none)]
        pub unsafe fn print(&self, sender: Option<&AnyObject>);

        /// # Safety
        ///
        /// `range` must be a valid pointer.
        #[unsafe(method(knowsPageRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn knowsPageRange(&self, range: NSRangePointer) -> bool;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(heightAdjustLimit))]
        #[unsafe(method_family = none)]
        pub fn heightAdjustLimit(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        #[unsafe(method(widthAdjustLimit))]
        #[unsafe(method_family = none)]
        pub fn widthAdjustLimit(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// # Safety
        ///
        /// `new_right` must be a valid pointer.
        #[unsafe(method(adjustPageWidthNew:left:right:limit:))]
        #[unsafe(method_family = none)]
        pub unsafe fn adjustPageWidthNew_left_right_limit(
            &self,
            new_right: NonNull<CGFloat>,
            old_left: CGFloat,
            old_right: CGFloat,
            right_limit: CGFloat,
        );

        #[cfg(feature = "objc2-core-foundation")]
        /// # Safety
        ///
        /// `new_bottom` must be a valid pointer.
        #[unsafe(method(adjustPageHeightNew:top:bottom:limit:))]
        #[unsafe(method_family = none)]
        pub unsafe fn adjustPageHeightNew_top_bottom_limit(
            &self,
            new_bottom: NonNull<CGFloat>,
            old_top: CGFloat,
            old_bottom: CGFloat,
            bottom_limit: CGFloat,
        );

        #[unsafe(method(rectForPage:))]
        #[unsafe(method_family = none)]
        pub fn rectForPage(&self, page: NSInteger) -> NSRect;

        #[unsafe(method(locationOfPrintRect:))]
        #[unsafe(method_family = none)]
        pub fn locationOfPrintRect(&self, rect: NSRect) -> NSPoint;

        #[unsafe(method(drawPageBorderWithSize:))]
        #[unsafe(method_family = none)]
        pub fn drawPageBorderWithSize(&self, border_size: NSSize);

        #[unsafe(method(pageHeader))]
        #[unsafe(method_family = none)]
        pub fn pageHeader(&self) -> Retained<NSAttributedString>;

        #[unsafe(method(pageFooter))]
        #[unsafe(method_family = none)]
        pub fn pageFooter(&self) -> Retained<NSAttributedString>;

        /// * This method is obsolete.  It will never be invoked from within AppKit, and NSView's implementation of it does nothing. **
        #[deprecated = "This is never invoked and the NSView implementation does nothing"]
        #[unsafe(method(drawSheetBorderWithSize:))]
        #[unsafe(method_family = none)]
        pub fn drawSheetBorderWithSize(&self, border_size: NSSize);

        #[unsafe(method(printJobTitle))]
        #[unsafe(method_family = none)]
        pub fn printJobTitle(&self) -> Retained<NSString>;

        #[unsafe(method(beginDocument))]
        #[unsafe(method_family = none)]
        pub fn beginDocument(&self);

        #[unsafe(method(endDocument))]
        #[unsafe(method_family = none)]
        pub fn endDocument(&self);

        #[unsafe(method(beginPageInRect:atPlacement:))]
        #[unsafe(method_family = none)]
        pub fn beginPageInRect_atPlacement(&self, rect: NSRect, location: NSPoint);

        #[unsafe(method(endPage))]
        #[unsafe(method_family = none)]
        pub fn endPage(&self);
    );
}

/// NSDrag.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[cfg(all(
            feature = "NSDragging",
            feature = "NSDraggingItem",
            feature = "NSDraggingSession",
            feature = "NSEvent"
        ))]
        #[unsafe(method(beginDraggingSessionWithItems:event:source:))]
        #[unsafe(method_family = none)]
        pub fn beginDraggingSessionWithItems_event_source(
            &self,
            items: &NSArray<NSDraggingItem>,
            event: &NSEvent,
            source: &ProtocolObject<dyn NSDraggingSource>,
        ) -> Retained<NSDraggingSession>;

        #[cfg(feature = "NSPasteboard")]
        #[unsafe(method(registeredDraggedTypes))]
        #[unsafe(method_family = none)]
        pub fn registeredDraggedTypes(&self) -> Retained<NSArray<NSPasteboardType>>;

        #[cfg(feature = "NSPasteboard")]
        #[unsafe(method(registerForDraggedTypes:))]
        #[unsafe(method_family = none)]
        pub fn registerForDraggedTypes(&self, new_types: &NSArray<NSPasteboardType>);

        #[unsafe(method(unregisterDraggedTypes))]
        #[unsafe(method_family = none)]
        pub fn unregisterDraggedTypes(&self);
    );
}

/// These constants are keys that you can use in the options dictionary in [`enterFullScreenMode:withOptions:`](https://developer.apple.com/documentation/appkit/nsview/enterfullscreenmode(_:withoptions:)) and [`exitFullScreenModeWithOptions:`](https://developer.apple.com/documentation/appkit/nsview/exitfullscreenmode(options:)).
// NS_TYPED_ENUM
pub type NSViewFullScreenModeOptionKey = NSString;

extern "C" {
    /// Key whose corresponding value specifies whether the view should take over all screens.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an instance of [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) containing a Boolean value.
    ///
    ///
    pub static NSFullScreenModeAllScreens: &'static NSViewFullScreenModeOptionKey;
}

extern "C" {
    /// Key whose corresponding value specifies the full screen mode setting.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an instance of [`NSDictionary`](https://developer.apple.com/documentation/foundation/nsdictionary) that contains keys specified in Display Mode Standard Properties and Display Mode Optional Properties in [Quartz Display Services](https://developer.apple.com/documentation/coregraphics/quartz-display-services).
    ///
    /// When the [`NSFullScreenModeApplicationPresentationOptions`](https://developer.apple.com/documentation/appkit/nsview/fullscreenmodeoptionkey/fullscreenmodeapplicationpresentationoptions) is specified in the options dictionary specifying this option as well will cause an exception.
    ///
    ///
    pub static NSFullScreenModeSetting: &'static NSViewFullScreenModeOptionKey;
}

extern "C" {
    /// Key whose corresponding value specifies the screen mode window level.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an instance of [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) containing an integer value.
    ///
    ///
    pub static NSFullScreenModeWindowLevel: &'static NSViewFullScreenModeOptionKey;
}

extern "C" {
    /// Key whose corresponding value specifies the application presentation options.
    ///
    /// ## Discussion
    ///
    /// The corresponding value is an instance of [`NSNumber`](https://developer.apple.com/documentation/foundation/nsnumber) containing an unsigned integer value of [`NSApplicationPresentationOptions`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct). Those options can be combined using the C bit-wise `OR` operator before created the `NSNumber` instance. See [`NSApplication`](https://developer.apple.com/documentation/appkit/nsapplication) constants section [`NSApplicationPresentationOptions`](https://developer.apple.com/documentation/appkit/nsapplication/presentationoptions-swift.struct) for more information on these options.
    ///
    ///
    pub static NSFullScreenModeApplicationPresentationOptions:
        &'static NSViewFullScreenModeOptionKey;
}

/// NSFullScreenMode.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[cfg(feature = "NSScreen")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(enterFullScreenMode:withOptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enterFullScreenMode_withOptions(
            &self,
            screen: &NSScreen,
            options: Option<&NSDictionary<NSViewFullScreenModeOptionKey, AnyObject>>,
        ) -> bool;

        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(exitFullScreenModeWithOptions:))]
        #[unsafe(method_family = none)]
        pub unsafe fn exitFullScreenModeWithOptions(
            &self,
            options: Option<&NSDictionary<NSViewFullScreenModeOptionKey, AnyObject>>,
        );

        #[unsafe(method(isInFullScreenMode))]
        #[unsafe(method_family = none)]
        pub fn isInFullScreenMode(&self) -> bool;
    );
}

/// Keys to include in your definition.
// NS_TYPED_ENUM
pub type NSDefinitionOptionKey = NSString;

extern "C" {
    /// An optional key in the options dictionary that specifies the presentation type of the definition display.
    ///
    /// ## Discussion
    ///
    /// The value of this key is one of the constants in [`NSDefinitionPresentationType`](https://developer.apple.com/documentation/appkit/nsview/definitionpresentationtype).
    ///
    ///
    pub static NSDefinitionPresentationTypeKey: &'static NSDefinitionOptionKey;
}

/// Presentation options for the window.
// NS_TYPED_ENUM
pub type NSDefinitionPresentationType = NSString;

extern "C" {
    /// A possible value of the [`NSDefinitionPresentationTypeKey`](https://developer.apple.com/documentation/appkit/nsview/definitionoptionkey/presentationtype) dictionary key that produces a small overlay window at the string location,
    pub static NSDefinitionPresentationTypeOverlay: &'static NSDefinitionPresentationType;
}

extern "C" {
    /// A possible value of the [`NSDefinitionPresentationTypeKey`](https://developer.apple.com/documentation/appkit/nsview/definitionoptionkey/presentationtype) dictionary key that invokes Dictionary application to display the definition.
    pub static NSDefinitionPresentationTypeDictionaryApplication:
        &'static NSDefinitionPresentationType;
}

/// NSDefinition.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[unsafe(method(showDefinitionForAttributedString:atPoint:))]
        #[unsafe(method_family = none)]
        pub fn showDefinitionForAttributedString_atPoint(
            &self,
            attr_string: Option<&NSAttributedString>,
            text_baseline_origin: NSPoint,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(showDefinitionForAttributedString:range:options:baselineOriginProvider:))]
        #[unsafe(method_family = none)]
        pub unsafe fn showDefinitionForAttributedString_range_options_baselineOriginProvider(
            &self,
            attr_string: Option<&NSAttributedString>,
            target_range: NSRange,
            options: Option<&NSDictionary<NSDefinitionOptionKey, AnyObject>>,
            origin_provider: Option<&block2::DynBlock<dyn Fn(NSRange) -> NSPoint>>,
        );
    );
}

/// NSFindIndicator.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[unsafe(method(isDrawingFindIndicator))]
        #[unsafe(method_family = none)]
        pub fn isDrawingFindIndicator(&self) -> bool;
    );
}

/// NSGestureRecognizer.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[cfg(feature = "NSGestureRecognizer")]
        #[unsafe(method(gestureRecognizers))]
        #[unsafe(method_family = none)]
        pub fn gestureRecognizers(&self) -> Retained<NSArray<NSGestureRecognizer>>;

        #[cfg(feature = "NSGestureRecognizer")]
        /// Setter for [`gestureRecognizers`][Self::gestureRecognizers].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setGestureRecognizers:))]
        #[unsafe(method_family = none)]
        pub fn setGestureRecognizers(&self, gesture_recognizers: &NSArray<NSGestureRecognizer>);

        #[cfg(feature = "NSGestureRecognizer")]
        #[unsafe(method(addGestureRecognizer:))]
        #[unsafe(method_family = none)]
        pub fn addGestureRecognizer(&self, gesture_recognizer: &NSGestureRecognizer);

        #[cfg(feature = "NSGestureRecognizer")]
        #[unsafe(method(removeGestureRecognizer:))]
        #[unsafe(method_family = none)]
        pub fn removeGestureRecognizer(&self, gesture_recognizer: &NSGestureRecognizer);
    );
}

/// NSTouchBar.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[cfg(feature = "NSTouch")]
        #[unsafe(method(allowedTouchTypes))]
        #[unsafe(method_family = none)]
        pub fn allowedTouchTypes(&self) -> NSTouchTypeMask;

        #[cfg(feature = "NSTouch")]
        /// Setter for [`allowedTouchTypes`][Self::allowedTouchTypes].
        #[unsafe(method(setAllowedTouchTypes:))]
        #[unsafe(method_family = none)]
        pub fn setAllowedTouchTypes(&self, allowed_touch_types: NSTouchTypeMask);
    );
}

/// NSSafeAreas.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[unsafe(method(safeAreaInsets))]
        #[unsafe(method_family = none)]
        pub fn safeAreaInsets(&self) -> NSEdgeInsets;

        #[unsafe(method(additionalSafeAreaInsets))]
        #[unsafe(method_family = none)]
        pub fn additionalSafeAreaInsets(&self) -> NSEdgeInsets;

        /// Setter for [`additionalSafeAreaInsets`][Self::additionalSafeAreaInsets].
        #[unsafe(method(setAdditionalSafeAreaInsets:))]
        #[unsafe(method_family = none)]
        pub fn setAdditionalSafeAreaInsets(&self, additional_safe_area_insets: NSEdgeInsets);

        #[cfg(feature = "NSLayoutGuide")]
        #[unsafe(method(safeAreaLayoutGuide))]
        #[unsafe(method_family = none)]
        pub fn safeAreaLayoutGuide(&self) -> Retained<NSLayoutGuide>;

        #[unsafe(method(safeAreaRect))]
        #[unsafe(method_family = none)]
        pub fn safeAreaRect(&self) -> NSRect;

        #[cfg(feature = "NSLayoutGuide")]
        #[unsafe(method(layoutMarginsGuide))]
        #[unsafe(method_family = none)]
        pub fn layoutMarginsGuide(&self) -> Retained<NSLayoutGuide>;
    );
}

/// NSCompactControlSizeMetrics.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        /// When this property is true, any NSControls in the view or its descendants will be sized with compact
        /// metrics compatible with macOS 15 and earlier.
        /// Defaults to false
        #[unsafe(method(prefersCompactControlSizeMetrics))]
        #[unsafe(method_family = none)]
        pub fn prefersCompactControlSizeMetrics(&self) -> bool;

        /// Setter for [`prefersCompactControlSizeMetrics`][Self::prefersCompactControlSizeMetrics].
        #[unsafe(method(setPrefersCompactControlSizeMetrics:))]
        #[unsafe(method_family = none)]
        pub fn setPrefersCompactControlSizeMetrics(
            &self,
            prefers_compact_control_size_metrics: bool,
        );
    );
}

/// NSTrackingArea.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[cfg(feature = "NSTrackingArea")]
        #[unsafe(method(addTrackingArea:))]
        #[unsafe(method_family = none)]
        pub fn addTrackingArea(&self, tracking_area: &NSTrackingArea);

        #[cfg(feature = "NSTrackingArea")]
        #[unsafe(method(removeTrackingArea:))]
        #[unsafe(method_family = none)]
        pub fn removeTrackingArea(&self, tracking_area: &NSTrackingArea);

        #[cfg(feature = "NSTrackingArea")]
        #[unsafe(method(trackingAreas))]
        #[unsafe(method_family = none)]
        pub fn trackingAreas(&self) -> Retained<NSArray<NSTrackingArea>>;

        #[unsafe(method(updateTrackingAreas))]
        #[unsafe(method_family = none)]
        pub fn updateTrackingAreas(&self);

        #[cfg(feature = "NSCursor")]
        #[unsafe(method(addCursorRect:cursor:))]
        #[unsafe(method_family = none)]
        pub fn addCursorRect_cursor(&self, rect: NSRect, object: &NSCursor);

        #[cfg(feature = "NSCursor")]
        #[unsafe(method(removeCursorRect:cursor:))]
        #[unsafe(method_family = none)]
        pub fn removeCursorRect_cursor(&self, rect: NSRect, object: &NSCursor);

        #[unsafe(method(discardCursorRects))]
        #[unsafe(method_family = none)]
        pub fn discardCursorRects(&self);

        #[unsafe(method(resetCursorRects))]
        #[unsafe(method_family = none)]
        pub fn resetCursorRects(&self);

        /// # Safety
        ///
        /// - `owner` should be of the correct type.
        /// - `data` must be a valid pointer or null.
        #[unsafe(method(addTrackingRect:owner:userData:assumeInside:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addTrackingRect_owner_userData_assumeInside(
            &self,
            rect: NSRect,
            owner: &AnyObject,
            data: *mut c_void,
            flag: bool,
        ) -> NSTrackingRectTag;

        #[unsafe(method(removeTrackingRect:))]
        #[unsafe(method_family = none)]
        pub fn removeTrackingRect(&self, tag: NSTrackingRectTag);
    );
}

/// NSDisplayLink.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[cfg(feature = "objc2-quartz-core")]
        #[cfg(target_vendor = "apple")]
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `selector` must be a valid selector.
        #[unsafe(method(displayLinkWithTarget:selector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayLinkWithTarget_selector(
            &self,
            target: &AnyObject,
            selector: Sel,
        ) -> Retained<CADisplayLink>;
    );
}

/// NSDeprecated.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[cfg(all(feature = "NSEvent", feature = "NSImage", feature = "NSPasteboard"))]
        /// # Safety
        ///
        /// `source_obj` should be of the correct type.
        #[deprecated = "Use -beginDraggingSessionWithItems:event:source: instead"]
        #[unsafe(method(dragImage:at:offset:event:pasteboard:source:slideBack:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dragImage_at_offset_event_pasteboard_source_slideBack(
            &self,
            image: &NSImage,
            view_location: NSPoint,
            initial_offset: NSSize,
            event: &NSEvent,
            pboard: &NSPasteboard,
            source_obj: &AnyObject,
            slide_flag: bool,
        );

        #[cfg(feature = "NSEvent")]
        #[deprecated = "Use -beginDraggingSessionWithItems:event:source: instead"]
        #[unsafe(method(dragFile:fromRect:slideBack:event:))]
        #[unsafe(method_family = none)]
        pub fn dragFile_fromRect_slideBack_event(
            &self,
            filename: &NSString,
            rect: NSRect,
            flag: bool,
            event: &NSEvent,
        ) -> bool;

        #[cfg(feature = "NSEvent")]
        /// # Safety
        ///
        /// `source_object` should be of the correct type.
        #[deprecated = "Use -beginDraggingSessionWithItems:event:source: with an NSFilePromiseProvider instead"]
        #[unsafe(method(dragPromisedFilesOfTypes:fromRect:source:slideBack:event:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dragPromisedFilesOfTypes_fromRect_source_slideBack_event(
            &self,
            type_array: &NSArray<NSString>,
            rect: NSRect,
            source_object: &AnyObject,
            flag: bool,
            event: &NSEvent,
        ) -> bool;

        #[deprecated]
        #[unsafe(method(convertPointToBase:))]
        #[unsafe(method_family = none)]
        pub fn convertPointToBase(&self, point: NSPoint) -> NSPoint;

        #[deprecated]
        #[unsafe(method(convertPointFromBase:))]
        #[unsafe(method_family = none)]
        pub fn convertPointFromBase(&self, point: NSPoint) -> NSPoint;

        #[deprecated]
        #[unsafe(method(convertSizeToBase:))]
        #[unsafe(method_family = none)]
        pub fn convertSizeToBase(&self, size: NSSize) -> NSSize;

        #[deprecated]
        #[unsafe(method(convertSizeFromBase:))]
        #[unsafe(method_family = none)]
        pub fn convertSizeFromBase(&self, size: NSSize) -> NSSize;

        #[deprecated]
        #[unsafe(method(convertRectToBase:))]
        #[unsafe(method_family = none)]
        pub fn convertRectToBase(&self, rect: NSRect) -> NSRect;

        #[deprecated]
        #[unsafe(method(convertRectFromBase:))]
        #[unsafe(method_family = none)]
        pub fn convertRectFromBase(&self, rect: NSRect) -> NSRect;

        #[deprecated = "This has always returned NO and had no effect on macOS"]
        #[unsafe(method(performMnemonic:))]
        #[unsafe(method_family = none)]
        pub fn performMnemonic(&self, string: &NSString) -> bool;

        #[deprecated = "This method no longer does anything"]
        #[unsafe(method(shouldDrawColor))]
        #[unsafe(method_family = none)]
        pub fn shouldDrawColor(&self) -> bool;

        #[deprecated]
        #[unsafe(method(gState))]
        #[unsafe(method_family = none)]
        pub fn gState(&self) -> NSInteger;

        #[deprecated]
        #[unsafe(method(allocateGState))]
        #[unsafe(method_family = none)]
        pub fn allocateGState(&self);

        #[deprecated]
        #[unsafe(method(setUpGState))]
        #[unsafe(method_family = none)]
        pub fn setUpGState(&self);

        #[deprecated]
        #[unsafe(method(renewGState))]
        #[unsafe(method_family = none)]
        pub fn renewGState(&self);
    );
}

/// NSWritingToolsCoordinator.
#[cfg(feature = "NSResponder")]
impl NSView {
    extern_methods!(
        #[cfg(feature = "NSWritingToolsCoordinator")]
        #[unsafe(method(writingToolsCoordinator))]
        #[unsafe(method_family = none)]
        pub fn writingToolsCoordinator(&self) -> Option<Retained<NSWritingToolsCoordinator>>;

        #[cfg(feature = "NSWritingToolsCoordinator")]
        /// Setter for [`writingToolsCoordinator`][Self::writingToolsCoordinator].
        #[unsafe(method(setWritingToolsCoordinator:))]
        #[unsafe(method_family = none)]
        pub fn setWritingToolsCoordinator(
            &self,
            writing_tools_coordinator: Option<&NSWritingToolsCoordinator>,
        );
    );
}

extern "C" {
    /// A notification that posts when the view’s frame rectangle changes to a new value.
    ///
    /// ## Discussion
    ///
    /// This notification posts only when the view’s [`postsFrameChangedNotifications`](https://developer.apple.com/documentation/appkit/nsview/postsframechangednotifications) property is [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    /// The notification object is the `NSView` object whose frame rectangle has changed. This notification does not contain a `userInfo` dictionary.
    ///
    /// The following methods can result in notification posting:
    ///
    /// - [`frame`](https://developer.apple.com/documentation/appkit/nsview/frame)
    ///
    /// - [`setFrameOrigin:`](https://developer.apple.com/documentation/appkit/nsview/setframeorigin(_:))
    ///
    /// - [`frameRotation`](https://developer.apple.com/documentation/appkit/nsview/framerotation)
    ///
    /// - [`setFrameSize:`](https://developer.apple.com/documentation/appkit/nsview/setframesize(_:))
    ///
    ///
    pub static NSViewFrameDidChangeNotification: &'static NSNotificationName;
}

extern "C" {
    /// Deprecated in macOS 10.4 and later. Posted for an `NSView` object and each of its descendants (recursively) whenever the frame or bounds geometry of the view changed.
    ///
    /// ## Discussion
    ///
    /// Instead use `NSViewBoundsDidChangeNotification` and `NSViewFrameDidChangeNotification` to get the same information provided by this notification.
    ///
    /// The notification object is the view whose geometry changed. This notification does not contain a `userInfo` dictionary.
    ///
    ///
    #[deprecated]
    pub static NSViewFocusDidChangeNotification: &'static NSNotificationName;
}

extern "C" {
    /// A notification that posts when the view’s bounds rectangle changes to a new value independently of the frame rectangle.
    ///
    /// ## Discussion
    ///
    /// This notification posts only when the view’s [`postsBoundsChangedNotifications`](https://developer.apple.com/documentation/appkit/nsview/postsboundschangednotifications) property is [`true`](https://developer.apple.com/documentation/swift/true).
    ///
    /// The notification object is the `NSView` object whose bounds rectangle has changed. This notification does not contain a `userInfo` dictionary.
    ///
    /// The following methods can result in notification posting:
    ///
    /// - [`bounds`](https://developer.apple.com/documentation/appkit/nsview/bounds)
    ///
    /// - [`setBoundsOrigin:`](https://developer.apple.com/documentation/appkit/nsview/setboundsorigin(_:))
    ///
    /// - [`boundsRotation`](https://developer.apple.com/documentation/appkit/nsview/boundsrotation)
    ///
    /// - [`setBoundsSize:`](https://developer.apple.com/documentation/appkit/nsview/setboundssize(_:))
    ///
    /// - [`translateOriginToPoint:`](https://developer.apple.com/documentation/appkit/nsview/translateorigin(to:))
    ///
    /// - [`scaleUnitSquareToSize:`](https://developer.apple.com/documentation/appkit/nsview/scaleunitsquare(to:))
    ///
    /// - [`rotateByAngle:`](https://developer.apple.com/documentation/appkit/nsview/rotate(bydegrees:))
    ///
    /// Note that the bounds rectangle resizes automatically to track the frame rectangle. However, changes to the frame rectangle do not result in this bounds-changed notification.
    ///
    ///
    pub static NSViewBoundsDidChangeNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted whenever an `NSView` object that has attached surfaces (that is, `NSOpenGLContext` objects) moves to a different screen, or other cases where the `NSOpenGLContext` object needs to be updated.
    ///
    /// ## Discussion
    ///
    /// The notification object is the surface’s view. This notification does not contain a `userInfo` dictionary.
    ///
    ///
    #[deprecated = "Use NSOpenGLView instead."]
    pub static NSViewGlobalFrameDidChangeNotification: &'static NSNotificationName;
}

extern "C" {
    /// Posted whenever a view recalculates its tracking areas.
    ///
    /// ## Discussion
    ///
    /// It is sent after the view receives [`updateTrackingAreas`](https://developer.apple.com/documentation/appkit/nsview/updatetrackingareas()).
    ///
    ///
    pub static NSViewDidUpdateTrackingAreasNotification: &'static NSNotificationName;
}
