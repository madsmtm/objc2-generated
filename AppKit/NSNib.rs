//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

pub type NSNibName = NSString;

extern_class!(
    /// An object wrapper, or container, for an Interface Builder nib file.
    ///
    /// ## Overview
    ///
    /// An [`NSNib`](https://developer.apple.com/documentation/appkit/nsnib) object keeps the contents of a nib file resident in memory, ready for unarchiving and instantiation. When you create a nib object using the contents of a nib file, the object loads the contents of the referenced nib bundle—the object graph as well as any images and sounds—into memory; but it does not yet unarchive it. To unarchive all of the nib data and thus truly instantiate the nib you must call one of the `instantiate...` methods of `NSNib`.
    ///
    /// During the instantiation process, each object in the archive is unarchived and then initialized using the method befitting its type. View classes are initialized using their [`initWithFrame:`](https://developer.apple.com/documentation/appkit/nsview/init(frame:)) method. Custom objects are initialized using their `init` method. In the case of Cocoa views (and custom views that have options on an associated Interface Builder palette) the initialization process also reads in any values set by the user in Interface Builder.
    ///
    /// Once all objects have been instantiated and initialized from the archive, the nib loading code attempts to reestablish the connections between each object’s outlets and the corresponding target objects. If your custom objects have outlets, the `NSNib` object attempts to reestablish any connections you created in Interface Builder. It starts by trying to establish the connections using your object’s own methods first. For each outlet that needs a connection, the [`NSNib`](https://developer.apple.com/documentation/appkit/nsnib) object looks for a method of the form `set:` in your object. If that method exists, the nib object calls it, passing the target object as a parameter. If you did not define a setter method with that exact name, the [`NSNib`](https://developer.apple.com/documentation/appkit/nsnib) object searches the object for an instance variable (of type `IBOutlet id`) with the corresponding outlet name and tries to set its value directly. If an instance variable with the correct name cannot be found, initialization of that connection does not occur.
    ///
    /// After all objects have been initialized and their connections reestablished, each object receives an [`awakeFromNib`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/awakefromnib()) message. You can override this method in your custom objects to perform any additional initialization.
    ///
    /// ### Subclassing Notes
    ///
    /// You can subclass `NSNib` if you want to extend or specialize nib-loading behavior. For example, you could create a custom `NSNib` subclass that performs some post-processing on the top-level objects returned from the `instantiateNib...` methods. If you want to modify how nib instantiations are performed, it is recommended that you override the primitive method [`instantiateWithOwner:topLevelObjects:`](https://developer.apple.com/documentation/appkit/nsnib/instantiate(withowner:toplevelobjects:)). Note that the instance variables of `NSNib` are private and thus are not available to subclasses. Any override of [`initWithNibData:bundle:`](https://developer.apple.com/documentation/appkit/nsnib/init(nibdata:bundle:)) or [`initWithNibNamed:bundle:`](https://developer.apple.com/documentation/appkit/nsnib/init(nibnamed:bundle:)) should first invoke the superclass implementation.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NSNib;
);

extern_conformance!(
    unsafe impl NSCoding for NSNib {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NSNib {}
);

impl NSNib {
    extern_methods!(
        #[unsafe(method(initWithNibNamed:bundle:))]
        #[unsafe(method_family = init)]
        pub fn initWithNibNamed_bundle(
            this: Allocated<Self>,
            nib_name: &NSNibName,
            bundle: Option<&NSBundle>,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithNibData:bundle:))]
        #[unsafe(method_family = init)]
        pub fn initWithNibData_bundle(
            this: Allocated<Self>,
            nib_data: &NSData,
            bundle: Option<&NSBundle>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NSNib {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new() -> Retained<Self>;
    );
}

impl DefaultRetained for NSNib {
    #[inline]
    fn default_retained() -> Retained<Self> {
        Self::new()
    }
}

/// NSDeprecated.
impl NSNib {
    extern_methods!(
        /// # Safety
        ///
        /// `nib_file_url` might not allow `None`.
        #[deprecated]
        #[unsafe(method(initWithContentsOfURL:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithContentsOfURL(
            this: Allocated<Self>,
            nib_file_url: Option<&NSURL>,
        ) -> Option<Retained<Self>>;

        /// # Safety
        ///
        /// - `external_name_table` generic should be of the correct type.
        /// - `external_name_table` might not allow `None`.
        #[deprecated]
        #[unsafe(method(instantiateNibWithExternalNameTable:))]
        #[unsafe(method_family = none)]
        pub unsafe fn instantiateNibWithExternalNameTable(
            &self,
            external_name_table: Option<&NSDictionary>,
        ) -> bool;

        /// # Safety
        ///
        /// - `owner` should be of the correct type.
        /// - `owner` might not allow `None`.
        /// - `top_level_objects` generic should be of the correct type.
        /// - `top_level_objects` might not allow `None`.
        #[deprecated]
        #[unsafe(method(instantiateNibWithOwner:topLevelObjects:))]
        #[unsafe(method_family = none)]
        pub unsafe fn instantiateNibWithOwner_topLevelObjects(
            &self,
            owner: Option<&AnyObject>,
            top_level_objects: Option<&mut Option<Retained<NSArray>>>,
        ) -> bool;
    );
}

extern "C" {
    /// The external object that is responsible for the instantiated nib.
    ///
    /// ## Discussion
    ///
    /// This key is required.
    ///
    ///
    #[deprecated]
    pub static NSNibOwner: &'static NSString;
}

extern "C" {
    /// An `NSMutableArray` object that, if present, is populated with the top-level objects of the newly instantiated nib.
    ///
    /// ## Discussion
    ///
    /// Because you must allocate this array, you are responsible for its disposal. This key is optional.
    ///
    ///
    #[deprecated]
    pub static NSNibTopLevelObjects: &'static NSString;
}
