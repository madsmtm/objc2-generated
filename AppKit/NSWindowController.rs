//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A controller that manages a window, usually a window stored in a nib file.
    ///
    /// ## Overview
    ///
    /// Managing a window entails:
    ///
    /// - Loading and displaying the window
    ///
    /// - Closing the window when appropriate
    ///
    /// - Customizing the window’s title
    ///
    /// - Storing the window’s frame (size and location) in the defaults database
    ///
    /// - Cascading the window in relation to other document windows of the app
    ///
    /// A window controller can manage a window by itself or as a role player in AppKit’s document-based architecture, which also includes [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) and [`NSDocumentController`](https://developer.apple.com/documentation/appkit/nsdocumentcontroller) objects. In this architecture, a window controller is created and managed by a “document” (an instance of an `NSDocument` subclass) and, in turn, keeps a reference to the document.
    ///
    /// The relationship between a window controller and a nib file is important. Although a window controller can manage a programmatically created window, it usually manages a window in a nib file. The nib file can contain other top-level objects, including other windows, but the window controller’s responsibility is this primary window. The window controller is usually the owner of the nib file, even when it is part of a document-based app. Regardless of who is the file’s owner, the window controller is responsible for freeing all top-level objects in the nib file it loads.
    ///
    /// For simple documents—that is, documents with only one nib file containing a window—you need to do little directly with `NSWindowController`; AppKit creates one for you. However, if the default window controller is not sufficient, you can create a custom subclass of `NSWindowController`. For documents with multiple windows or panels, your document must create separate instances of `NSWindowController` (or of custom subclasses of `NSWindowController`), one for each window or panel. An example is a CAD app that has different windows for side, top, and front views of drawn objects. What you do in your [`NSDocument`](https://developer.apple.com/documentation/appkit/nsdocument) subclass determines whether the default `NSWindowController` or separately created and configured `NSWindowController` objects are used.
    ///
    /// ### Subclassing NSWindowController
    ///
    /// You should create a subclass of `NSWindowController` when you want to augment the default behavior, such as to give the window a custom title or to perform some setup tasks before the window is loaded. In your class’s initialization method, be sure to invoke on `super` either one of the `initWithWindowNibName:...` initializers or the [`initWithWindow:`](https://developer.apple.com/documentation/appkit/nswindowcontroller/init(window:)) initializer. The initializer you choose depends on whether the window object originates in a nib file or is programmatically created.
    ///
    /// You can also implement an [`NSWindowController`](https://developer.apple.com/documentation/appkit/nswindowcontroller) subclass to avoid requiring client code to get the corresponding nib’s filename and pass it to [`initWithWindowNibName:`](https://developer.apple.com/documentation/appkit/nswindowcontroller/init(windownibname:)) or [`initWithWindowNibName:owner:`](https://developer.apple.com/documentation/appkit/nswindowcontroller/init(windownibname:owner:)) when instantiating the window controller. The best way to do this is to override [`windowNibName`](https://developer.apple.com/documentation/appkit/nswindowcontroller/windownibname) to return the nib’s filename and instantiate the window controller by passing `nil` to [`initWithWindow:`](https://developer.apple.com/documentation/appkit/nswindowcontroller/init(window:)). Using the [`initWithWindow:`](https://developer.apple.com/documentation/appkit/nswindowcontroller/init(window:)) designated initializer simplifies compliance with Swift initializer requirements.
    ///
    /// Typically, you override one of the methods listed below.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Method Name" }] }], [Paragraph { inline_content: [Text { text: "Description" }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.appkit/documentation/AppKit/NSWindowController/windowWillLoad()", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Override to perform tasks before the window nib file is loaded." }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.appkit/documentation/AppKit/NSWindowController/windowDidLoad()", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Override to perform tasks after the window nib file is loaded." }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.appkit/documentation/AppKit/NSWindowController/windowTitle(forDocumentDisplayName:)", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Override to customize the window title." }] }]]], alignments: None, metadata: None })
    /// You can also override [`loadWindow`](https://developer.apple.com/documentation/appkit/nswindowcontroller/loadwindow()) to get different nib-searching or nib-loading behavior, although there is usually no need to do this.
    ///
    ///
    #[unsafe(super(NSResponder, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "NSResponder")]
    pub struct NSWindowController;
);

#[cfg(feature = "NSResponder")]
extern_conformance!(
    unsafe impl NSCoding for NSWindowController {}
);

#[cfg(feature = "NSResponder")]
extern_conformance!(
    unsafe impl NSObjectProtocol for NSWindowController {}
);

#[cfg(all(feature = "NSResponder", feature = "NSStoryboardSegue"))]
extern_conformance!(
    unsafe impl NSSeguePerforming for NSWindowController {}
);

#[cfg(feature = "NSResponder")]
impl NSWindowController {
    extern_methods!(
        #[cfg(feature = "NSWindow")]
        #[unsafe(method(initWithWindow:))]
        #[unsafe(method_family = init)]
        pub fn initWithWindow(this: Allocated<Self>, window: Option<&NSWindow>) -> Retained<Self>;

        /// # Safety
        ///
        /// `coder` possibly has further requirements.
        #[unsafe(method(initWithCoder:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCoder(
            this: Allocated<Self>,
            coder: &NSCoder,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "NSNib")]
        #[unsafe(method(initWithWindowNibName:))]
        #[unsafe(method_family = init)]
        pub fn initWithWindowNibName(
            this: Allocated<Self>,
            window_nib_name: &NSNibName,
        ) -> Retained<Self>;

        #[cfg(feature = "NSNib")]
        /// # Safety
        ///
        /// `owner` should be of the correct type.
        #[unsafe(method(initWithWindowNibName:owner:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithWindowNibName_owner(
            this: Allocated<Self>,
            window_nib_name: &NSNibName,
            owner: &AnyObject,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `owner` should be of the correct type.
        #[unsafe(method(initWithWindowNibPath:owner:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithWindowNibPath_owner(
            this: Allocated<Self>,
            window_nib_path: &NSString,
            owner: &AnyObject,
        ) -> Retained<Self>;

        #[cfg(feature = "NSNib")]
        #[unsafe(method(windowNibName))]
        #[unsafe(method_family = none)]
        pub fn windowNibName(&self) -> Option<Retained<NSNibName>>;

        #[unsafe(method(windowNibPath))]
        #[unsafe(method_family = none)]
        pub fn windowNibPath(&self) -> Option<Retained<NSString>>;

        #[unsafe(method(owner))]
        #[unsafe(method_family = none)]
        pub fn owner(&self) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(windowFrameAutosaveName))]
        #[unsafe(method_family = none)]
        pub fn windowFrameAutosaveName(&self) -> Retained<NSWindowFrameAutosaveName>;

        #[cfg(feature = "NSWindow")]
        /// Setter for [`windowFrameAutosaveName`][Self::windowFrameAutosaveName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setWindowFrameAutosaveName:))]
        #[unsafe(method_family = none)]
        pub fn setWindowFrameAutosaveName(
            &self,
            window_frame_autosave_name: &NSWindowFrameAutosaveName,
        );

        #[unsafe(method(shouldCascadeWindows))]
        #[unsafe(method_family = none)]
        pub fn shouldCascadeWindows(&self) -> bool;

        /// Setter for [`shouldCascadeWindows`][Self::shouldCascadeWindows].
        #[unsafe(method(setShouldCascadeWindows:))]
        #[unsafe(method_family = none)]
        pub fn setShouldCascadeWindows(&self, should_cascade_windows: bool);

        #[cfg(feature = "NSPreviewRepresentingActivityItem")]
        #[unsafe(method(previewRepresentableActivityItems))]
        #[unsafe(method_family = none)]
        pub fn previewRepresentableActivityItems(
            &self,
        ) -> Option<Retained<NSArray<ProtocolObject<dyn NSPreviewRepresentableActivityItem>>>>;

        #[cfg(feature = "NSPreviewRepresentingActivityItem")]
        /// Setter for [`previewRepresentableActivityItems`][Self::previewRepresentableActivityItems].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setPreviewRepresentableActivityItems:))]
        #[unsafe(method_family = none)]
        pub fn setPreviewRepresentableActivityItems(
            &self,
            preview_representable_activity_items: Option<
                &NSArray<ProtocolObject<dyn NSPreviewRepresentableActivityItem>>,
            >,
        );

        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(document))]
        #[unsafe(method_family = none)]
        pub unsafe fn document(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`document`][Self::document].
        ///
        /// # Safety
        ///
        /// - `document` should be of the correct type.
        /// - This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setDocument:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDocument(&self, document: Option<&AnyObject>);

        #[unsafe(method(setDocumentEdited:))]
        #[unsafe(method_family = none)]
        pub fn setDocumentEdited(&self, dirty_flag: bool);

        #[unsafe(method(shouldCloseDocument))]
        #[unsafe(method_family = none)]
        pub fn shouldCloseDocument(&self) -> bool;

        /// Setter for [`shouldCloseDocument`][Self::shouldCloseDocument].
        #[unsafe(method(setShouldCloseDocument:))]
        #[unsafe(method_family = none)]
        pub fn setShouldCloseDocument(&self, should_close_document: bool);

        #[unsafe(method(synchronizeWindowTitleWithDocumentName))]
        #[unsafe(method_family = none)]
        pub fn synchronizeWindowTitleWithDocumentName(&self);

        #[unsafe(method(windowTitleForDocumentDisplayName:))]
        #[unsafe(method_family = none)]
        pub fn windowTitleForDocumentDisplayName(
            &self,
            display_name: &NSString,
        ) -> Retained<NSString>;

        #[cfg(feature = "NSViewController")]
        #[unsafe(method(contentViewController))]
        #[unsafe(method_family = none)]
        pub fn contentViewController(&self) -> Option<Retained<NSViewController>>;

        #[cfg(feature = "NSViewController")]
        /// Setter for [`contentViewController`][Self::contentViewController].
        #[unsafe(method(setContentViewController:))]
        #[unsafe(method_family = none)]
        pub fn setContentViewController(&self, content_view_controller: Option<&NSViewController>);

        #[cfg(feature = "NSWindow")]
        #[unsafe(method(window))]
        #[unsafe(method_family = none)]
        pub fn window(&self) -> Option<Retained<NSWindow>>;

        #[cfg(feature = "NSWindow")]
        /// Setter for [`window`][Self::window].
        #[unsafe(method(setWindow:))]
        #[unsafe(method_family = none)]
        pub fn setWindow(&self, window: Option<&NSWindow>);

        #[unsafe(method(isWindowLoaded))]
        #[unsafe(method_family = none)]
        pub fn isWindowLoaded(&self) -> bool;

        #[unsafe(method(windowWillLoad))]
        #[unsafe(method_family = none)]
        pub fn windowWillLoad(&self);

        #[unsafe(method(windowDidLoad))]
        #[unsafe(method_family = none)]
        pub fn windowDidLoad(&self);

        #[unsafe(method(loadWindow))]
        #[unsafe(method_family = none)]
        pub fn loadWindow(&self);

        #[unsafe(method(close))]
        #[unsafe(method_family = none)]
        pub fn close(&self);

        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(showWindow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn showWindow(&self, sender: Option<&AnyObject>);
    );
}

/// Methods declared on superclass `NSResponder`.
#[cfg(feature = "NSResponder")]
impl NSWindowController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "NSResponder")]
impl NSWindowController {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub fn new(mtm: MainThreadMarker) -> Retained<Self>;
    );
}

/// NSWindowControllerStoryboardingMethods.
///
/// These methods are used to support using Storyboards with your app.
#[cfg(feature = "NSResponder")]
impl NSWindowController {
    extern_methods!(
        #[cfg(feature = "NSStoryboard")]
        #[unsafe(method(storyboard))]
        #[unsafe(method_family = none)]
        pub fn storyboard(&self) -> Option<Retained<NSStoryboard>>;
    );
}

/// NSWindowControllerDismissing.
#[cfg(feature = "NSResponder")]
impl NSWindowController {
    extern_methods!(
        /// # Safety
        ///
        /// `sender` should be of the correct type.
        #[unsafe(method(dismissController:))]
        #[unsafe(method_family = none)]
        pub unsafe fn dismissController(&self, sender: Option<&AnyObject>);
    );
}
