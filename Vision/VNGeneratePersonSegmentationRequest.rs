//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;

use crate::*;

/// Person segmentation level options to favor speed over recognition accuracy.
/// VNGeneratePersonSegmentationRequestQualityLevelAccurate is the default option.
///
/// fast - generates a low accuracy segmentation mask that can be used in streaming scenarios on devices that have a neural engine
/// balanced - generates a high accuracy segmentation mask
/// accurate - generates a mask based on the balanced output that includes matting refinement
/// The request may hold on to previous masks to improve temporal stability.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/vision/vngeneratepersonsegmentationrequestqualitylevel?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct VNGeneratePersonSegmentationRequestQualityLevel(pub NSUInteger);
impl VNGeneratePersonSegmentationRequestQualityLevel {
    #[doc(alias = "VNGeneratePersonSegmentationRequestQualityLevelAccurate")]
    pub const Accurate: Self = Self(0);
    #[doc(alias = "VNGeneratePersonSegmentationRequestQualityLevelBalanced")]
    pub const Balanced: Self = Self(1);
    #[doc(alias = "VNGeneratePersonSegmentationRequestQualityLevelFast")]
    pub const Fast: Self = Self(2);
}

unsafe impl Encode for VNGeneratePersonSegmentationRequestQualityLevel {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for VNGeneratePersonSegmentationRequestQualityLevel {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Performs person segmentation on an image generating a mask.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/vision/vngeneratepersonsegmentationrequest?language=objc)
    #[unsafe(super(VNStatefulRequest, VNImageBasedRequest, VNRequest, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(all(feature = "VNRequest", feature = "VNStatefulRequest"))]
    pub struct VNGeneratePersonSegmentationRequest;
);

#[cfg(all(feature = "VNRequest", feature = "VNStatefulRequest"))]
extern_conformance!(
    unsafe impl NSCopying for VNGeneratePersonSegmentationRequest {}
);

#[cfg(all(feature = "VNRequest", feature = "VNStatefulRequest"))]
unsafe impl CopyingHelper for VNGeneratePersonSegmentationRequest {
    type Result = Self;
}

#[cfg(all(feature = "VNRequest", feature = "VNStatefulRequest"))]
extern_conformance!(
    unsafe impl NSObjectProtocol for VNGeneratePersonSegmentationRequest {}
);

#[cfg(all(feature = "VNRequest", feature = "VNStatefulRequest"))]
impl VNGeneratePersonSegmentationRequest {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(initWithCompletionHandler:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCompletionHandler(
            this: Allocated<Self>,
            completion_handler: VNRequestCompletionHandler,
        ) -> Retained<Self>;

        #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
        /// # Safety
        ///
        /// `completion_handler` must be a valid pointer or null.
        #[unsafe(method(initWithFrameAnalysisSpacing:completionHandler:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithFrameAnalysisSpacing_completionHandler(
            this: Allocated<Self>,
            frame_analysis_spacing: CMTime,
            completion_handler: VNRequestCompletionHandler,
        ) -> Retained<Self>;

        /// The quality level selects which techniques will be used during the person segmentation. There are trade-offs between performance and accuracy.
        #[unsafe(method(qualityLevel))]
        #[unsafe(method_family = none)]
        pub unsafe fn qualityLevel(&self) -> VNGeneratePersonSegmentationRequestQualityLevel;

        /// Setter for [`qualityLevel`][Self::qualityLevel].
        #[unsafe(method(setQualityLevel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setQualityLevel(
            &self,
            quality_level: VNGeneratePersonSegmentationRequestQualityLevel,
        );

        /// Obtain the collection of supported output pixel formats for the configured request.
        #[unsafe(method(supportedOutputPixelFormatsAndReturnError:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedOutputPixelFormatsAndReturnError(
            &self,
        ) -> Result<Retained<NSArray<NSNumber>>, Retained<NSError>>;

        /// Pixel format type of the output buffer. Valid values are kCVPixelFormatType_OneComponent32Float, kCVPixelFormatType_OneComponent16Half, and kCVPixelFormatType_OneComponent8. Default is kCVPixelFormatType_OneComponent8.
        #[unsafe(method(outputPixelFormat))]
        #[unsafe(method_family = none)]
        pub unsafe fn outputPixelFormat(&self) -> OSType;

        /// Setter for [`outputPixelFormat`][Self::outputPixelFormat].
        #[unsafe(method(setOutputPixelFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOutputPixelFormat(&self, output_pixel_format: OSType);

        #[cfg(feature = "VNObservation")]
        #[unsafe(method(results))]
        #[unsafe(method_family = none)]
        pub unsafe fn results(&self) -> Option<Retained<NSArray<VNPixelBufferObservation>>>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/vision/vngeneratepersonsegmentationrequestrevision1?language=objc)
pub static VNGeneratePersonSegmentationRequestRevision1: NSUInteger = 1;
