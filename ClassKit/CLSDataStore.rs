//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// An interface the data store uses to request new contexts.
    ///
    /// ## Overview
    ///
    /// When you request a context from the data store, for example using a call to the [`descendantMatchingIdentifierPath:completion:`](https://developer.apple.com/documentation/classkit/clscontext/descendant(matchingidentifierpath:completion:)) method, the data store first tries to locate an existing context matching the search criterion (an identifier path in this case) in its database. Depending on certain conditions, the context might already exist in the database from the last time you requested it. If it does, the data store returns the stored context. But if it doesn’t exist, the data store asks its delegate to build a new context.
    ///
    /// Adopt the data store delegate protocol to provide contexts on demand.
    ///
    /// You can alternatively build contexts directly without relying on the delegate callback. However, it’s generally most efficient to use the delegate protocol, building contexts only when they’re missing from the data store.
    ///
    ///
    pub unsafe trait CLSDataStoreDelegate: NSObjectProtocol {
        #[cfg(all(feature = "CLSContext", feature = "CLSObject"))]
        /// Implement to return a new context with the supplied identifier as a child of the parent context.
        ///
        /// This method is invoked for missing contexts in:
        ///
        /// ```text
        ///  -[CLSDataStore contextsMatchingIdentifierPath:completion:]
        /// ```
        ///
        /// and
        ///
        /// ```text
        ///  -[CLSContext descendantMatchingIdentifierPath:completion:]
        /// ```
        ///
        /// It will be called successively for each identifier in the path that is not found. This helps centralize context creation in one place.
        ///
        /// Note: New contexts returned in this method are automatically saved.
        ///
        ///
        /// Parameter `identifier`: Identifier for the new context.
        ///
        /// Parameter `parentContext`: Parent of the new context.
        ///
        /// Parameter `parentIdentifierPath`: Ordered list of identifiers leading to the parent context.
        ///
        ///
        /// Returns: The new context for the supplied identifier. The new context is automatically saved.
        #[unsafe(method(createContextForIdentifier:parentContext:parentIdentifierPath:))]
        #[unsafe(method_family = none)]
        unsafe fn createContextForIdentifier_parentContext_parentIdentifierPath(
            &self,
            identifier: &NSString,
            parent_context: &CLSContext,
            parent_identifier_path: &NSArray<NSString>,
        ) -> Option<Retained<CLSContext>>;
    }
);

extern_class!(
    /// A container for all the ClassKit data in your app.
    ///
    /// ## Overview
    ///
    /// Use the ClassKit data store to build and access contexts ([`CLSContext`](https://developer.apple.com/documentation/classkit/clscontext) instances) that you use to advertise your app’s assignable content. Contexts in turn provide access to activities ([`CLSActivity`](https://developer.apple.com/documentation/classkit/clsactivity) instances) and activity items ([`CLSScoreItem`](https://developer.apple.com/documentation/classkit/clsscoreitem), [`CLSBinaryItem`](https://developer.apple.com/documentation/classkit/clsbinaryitem), and [`CLSQuantityItem`](https://developer.apple.com/documentation/classkit/clsquantityitem) instances) that you use to record progress through assignments. You don’t instantiate a data store yourself. Instead, use the single [`shared`](https://developer.apple.com/documentation/classkit/clsdatastore/shared) data store instance throughout your app.
    ///
    /// The data store provides access to the app’s one and only main context through the [`mainAppContext`](https://developer.apple.com/documentation/classkit/clsdatastore/mainappcontext) property. This property acts as the root context in your context hierarchy that you can use as a starting point when searching for descendant contexts.
    ///
    /// To build contexts, you adopt the [`CLSDataStoreDelegate`](https://developer.apple.com/documentation/classkit/clsdatastoredelegate) protocol in one of your classes, typically one that exists for the lifetime of your app, and assign an instance of that class as the shared data store’s [`delegate`](https://developer.apple.com/documentation/classkit/clsdatastore/delegate) property. Then, when the data store needs a context that it’s never seen before, it asks your delegate to build it.
    ///
    /// After you make changes to any context, activity, or activity item, call the data store’s [`saveWithCompletion:`](https://developer.apple.com/documentation/classkit/clsdatastore/save(completion:)) method to commit the changes, and propagate them through the network.
    ///
    ///
    /// The data store maintains and syncs your app's contexts.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CLSDataStore;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for CLSDataStore {}
);

impl CLSDataStore {
    extern_methods!(
        /// The data store provides read/write access to your app's ClassKit data.
        ///
        /// Data written to the data store is automatically synced via iCloud across the user's devices.
        #[unsafe(method(shared))]
        #[unsafe(method_family = none)]
        pub unsafe fn shared() -> Retained<CLSDataStore>;

        #[cfg(all(feature = "CLSContext", feature = "CLSObject"))]
        /// Fetch the top level context for the current app.
        ///
        /// The main context is automatically created. Add child contexts to this context to persist them in the data store.
        #[unsafe(method(mainAppContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn mainAppContext(&self) -> Retained<CLSContext>;

        #[cfg(all(feature = "CLSContext", feature = "CLSObject"))]
        /// Returns the context that is currently active. If no context is active, this will return nil.
        #[unsafe(method(activeContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn activeContext(&self) -> Option<Retained<CLSContext>>;

        #[cfg(all(feature = "CLSActivity", feature = "CLSObject"))]
        /// Returns the most recently started activity that is running.
        #[unsafe(method(runningActivity))]
        #[unsafe(method_family = none)]
        pub unsafe fn runningActivity(&self) -> Option<Retained<CLSActivity>>;

        /// The data store delegate allows for easy population of the app's context hierarchy.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self)
            -> Option<Retained<ProtocolObject<dyn CLSDataStoreDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn CLSDataStoreDelegate>>,
        );

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "block2")]
        /// Save changes made in the data store.
        ///
        /// Save new/modified/removed contexts, activities, etc. to the local store. In case of an error -[NSError userInfo] will contain the object that caused the error under the CLSErrorObjectKey..
        #[unsafe(method(saveWithCompletion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn saveWithCompletion(
            &self,
            completion: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        /// Complete all assigned actvities.
        ///
        /// Marks all of the currently active assigned activities for this contextPath as complete.
        #[unsafe(method(completeAllAssignedActivitiesMatching:))]
        #[unsafe(method_family = none)]
        pub unsafe fn completeAllAssignedActivitiesMatching(
            &self,
            context_path: &NSArray<NSString>,
        );
    );
}

/// Contexts.
impl CLSDataStore {
    extern_methods!(
        #[cfg(all(feature = "CLSContext", feature = "CLSObject", feature = "block2"))]
        /// Fetch contexts matching a predicate.
        ///
        /// For example: NSPredicate
        /// <topic
        /// == CLSContextTopicMath AND parent == someContext>.  Completion block may be called on a background thread.
        #[unsafe(method(contextsMatchingPredicate:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contextsMatchingPredicate_completion(
            &self,
            predicate: &NSPredicate,
            completion: &block2::DynBlock<dyn Fn(NonNull<NSArray<CLSContext>>, *mut NSError)>,
        );

        #[cfg(all(feature = "CLSContext", feature = "CLSObject", feature = "block2"))]
        /// Returns contexts matching a set of identifiers where each identifier is the parent of the following identifier.
        ///
        /// For example:
        /// `@["math-game",``"level1"]`returns two contexts where
        /// _math-game_is the parent of
        /// _level1._If there are any missing contexts, they will be filled in by calling the following method on the data store's delegate:
        ///
        /// ```text
        ///  -[CLSDataStoreDelegate createContextForIdentifier:parentContext:parentIdentifierPath:]
        /// ```
        ///
        /// If the dataStore does not have a delegate and there are missing contexts then an incomplete list of contexts will be passed to the completion handler.  Completion block may be called on a background thread.
        #[unsafe(method(contextsMatchingIdentifierPath:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn contextsMatchingIdentifierPath_completion(
            &self,
            identifier_path: &NSArray<NSString>,
            completion: &block2::DynBlock<dyn Fn(NonNull<NSArray<CLSContext>>, *mut NSError)>,
        );

        #[cfg(all(feature = "CLSContext", feature = "CLSObject"))]
        /// Mark a context for removal.
        ///
        /// Save to commit removal. Removal cascades and deletes all descendants.
        #[unsafe(method(removeContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeContext(&self, context: &CLSContext);

        #[cfg(all(feature = "CLSActivity", feature = "CLSObject", feature = "block2"))]
        /// Implement to fetch the current CLSActivity instance for your document to add progress to.
        ///
        /// Gets the currently CLSActivity for the file. If no current activity exists, one will be created for you.
        ///
        /// Parameter `url`: File url for the document.
        #[unsafe(method(fetchActivityForURL:completion:))]
        #[unsafe(method_family = none)]
        pub unsafe fn fetchActivityForURL_completion(
            &self,
            url: &NSURL,
            completion: &block2::DynBlock<dyn Fn(*mut CLSActivity, *mut NSError)>,
        );
    );
}
