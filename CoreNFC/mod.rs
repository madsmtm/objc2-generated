// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::unportable_markdown)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "CoreNFC", kind = "framework")]
extern "C" {}

use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcerrordomain?language=objc)
    pub static NFCErrorDomain: &'static NSErrorDomain;
}

/// Possible errors returned by CoreNFC framework reader session.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcreadererror?language=objc)
// NS_ERROR_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCReaderError(pub NSInteger);
impl NFCReaderError {
    #[doc(alias = "NFCReaderErrorUnsupportedFeature")]
    pub const ReaderErrorUnsupportedFeature: Self = Self(1);
    #[doc(alias = "NFCReaderErrorSecurityViolation")]
    pub const ReaderErrorSecurityViolation: Self = Self(2);
    #[doc(alias = "NFCReaderErrorInvalidParameter")]
    pub const ReaderErrorInvalidParameter: Self = Self(3);
    #[doc(alias = "NFCReaderErrorInvalidParameterLength")]
    pub const ReaderErrorInvalidParameterLength: Self = Self(4);
    #[doc(alias = "NFCReaderErrorParameterOutOfBound")]
    pub const ReaderErrorParameterOutOfBound: Self = Self(5);
    #[doc(alias = "NFCReaderErrorRadioDisabled")]
    pub const ReaderErrorRadioDisabled: Self = Self(6);
    #[doc(alias = "NFCReaderErrorIneligible")]
    pub const ReaderErrorIneligible: Self = Self(7);
    #[doc(alias = "NFCReaderTransceiveErrorTagConnectionLost")]
    pub const ReaderTransceiveErrorTagConnectionLost: Self = Self(100);
    #[doc(alias = "NFCReaderTransceiveErrorRetryExceeded")]
    pub const ReaderTransceiveErrorRetryExceeded: Self = Self(101);
    #[doc(alias = "NFCReaderTransceiveErrorTagResponseError")]
    pub const ReaderTransceiveErrorTagResponseError: Self = Self(102);
    #[doc(alias = "NFCReaderTransceiveErrorSessionInvalidated")]
    pub const ReaderTransceiveErrorSessionInvalidated: Self = Self(103);
    #[doc(alias = "NFCReaderTransceiveErrorTagNotConnected")]
    pub const ReaderTransceiveErrorTagNotConnected: Self = Self(104);
    #[doc(alias = "NFCReaderTransceiveErrorPacketTooLong")]
    pub const ReaderTransceiveErrorPacketTooLong: Self = Self(105);
    #[doc(alias = "NFCReaderSessionInvalidationErrorUserCanceled")]
    pub const ReaderSessionInvalidationErrorUserCanceled: Self = Self(200);
    #[doc(alias = "NFCReaderSessionInvalidationErrorSessionTimeout")]
    pub const ReaderSessionInvalidationErrorSessionTimeout: Self = Self(201);
    #[doc(alias = "NFCReaderSessionInvalidationErrorSessionTerminatedUnexpectedly")]
    pub const ReaderSessionInvalidationErrorSessionTerminatedUnexpectedly: Self = Self(202);
    #[doc(alias = "NFCReaderSessionInvalidationErrorSystemIsBusy")]
    pub const ReaderSessionInvalidationErrorSystemIsBusy: Self = Self(203);
    #[doc(alias = "NFCReaderSessionInvalidationErrorFirstNDEFTagRead")]
    pub const ReaderSessionInvalidationErrorFirstNDEFTagRead: Self = Self(204);
    #[doc(alias = "NFCTagCommandConfigurationErrorInvalidParameters")]
    pub const TagCommandConfigurationErrorInvalidParameters: Self = Self(300);
    #[doc(alias = "NFCNdefReaderSessionErrorTagNotWritable")]
    pub const NdefReaderSessionErrorTagNotWritable: Self = Self(400);
    #[doc(alias = "NFCNdefReaderSessionErrorTagUpdateFailure")]
    pub const NdefReaderSessionErrorTagUpdateFailure: Self = Self(401);
    #[doc(alias = "NFCNdefReaderSessionErrorTagSizeTooSmall")]
    pub const NdefReaderSessionErrorTagSizeTooSmall: Self = Self(402);
    #[doc(alias = "NFCNdefReaderSessionErrorZeroLengthMessage")]
    pub const NdefReaderSessionErrorZeroLengthMessage: Self = Self(403);
}

unsafe impl Encode for NFCReaderError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NFCReaderError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// Key in NSError userInfo dictionary.  The corresponding value is the NSUInteger error code from tag's response.
    /// Refer to ISO15693 specification for the error code values.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfciso15693tagresponseerrorkey?language=objc)
    pub static NFCISO15693TagResponseErrorKey: &'static NSString;
}

extern "C" {
    /// Key in NSError userInfo dictionary.  Presence of this key indicates the received response packet length is invalid.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfctagresponseunexpectedlengtherrorkey?language=objc)
    pub static NFCTagResponseUnexpectedLengthErrorKey: &'static NSString;
}

extern_protocol!(
    /// General reader session functions
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcreadersessionprotocol?language=objc)
    #[doc(alias = "NFCReaderSession")]
    #[name = "NFCReaderSession"]
    pub unsafe trait NFCReaderSessionProtocol: NSObjectProtocol {
        /// Returns: <i>
        /// YES
        /// </i>
        /// if the reader session is started and ready to use.
        ///
        ///
        /// The RF discovery polling begins immediately when a reader session is activated successfully.
        /// The
        ///
        /// ```text
        ///  readerSession:didDetectTags: @link/ will be called when a tag is detected.
        ///  
        ///
        /// ```
        #[unsafe(method(isReady))]
        #[unsafe(method_family = none)]
        unsafe fn isReady(&self) -> bool;

        /// Descriptive text message that is displayed on the alert action sheet once tag scanning has started.  The string can be update
        /// dynamically in any thread context as long as the session is valid.  This should be set prior to calling
        ///
        /// ```text
        ///  beginSession @link/ to display
        ///              the correct message.  Use this string to provide additional context about the NFC reader mode operation.
        ///  
        ///
        /// ```
        #[unsafe(method(alertMessage))]
        #[unsafe(method_family = none)]
        unsafe fn alertMessage(&self) -> Retained<NSString>;

        /// Setter for [`alertMessage`][Self::alertMessage].
        #[unsafe(method(setAlertMessage:))]
        #[unsafe(method_family = none)]
        unsafe fn setAlertMessage(&self, alert_message: &NSString);

        /// Starts the session.  The
        ///
        /// ```text
        ///  [NFCReaderSessionDelegate readerSessionDidBecomeActive:] @link/ will be called when the reader session
        ///                   is activated successfully.  @link [NFCReaderSessionDelegate readerSession:didDetectTags:] @link/ will return tag objects that are
        ///                   conformed to the @link NFCTag @link/ protocol.  @link [NFCReaderSessionDelegate readerSession:didInvalidateWithError:] will return
        ///                   errors related to the session start.
        ///  
        ///
        /// ```
        #[unsafe(method(beginSession))]
        #[unsafe(method_family = none)]
        unsafe fn beginSession(&self);

        /// Closes the reader session.  The session cannot be re-used.
        #[unsafe(method(invalidateSession))]
        #[unsafe(method_family = none)]
        unsafe fn invalidateSession(&self);

        /// Closes the reader session.  The session cannot be re-used.  The specified error message and an error symbol will be displayed momentarily
        /// on the action sheet before it is automatically dismissed.
        #[unsafe(method(invalidateSessionWithErrorMessage:))]
        #[unsafe(method_family = none)]
        unsafe fn invalidateSessionWithErrorMessage(&self, error_message: &NSString);
    }
);

extern_protocol!(
    /// General reader session callbacks
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcreadersessiondelegate?language=objc)
    pub unsafe trait NFCReaderSessionDelegate: NSObjectProtocol {
        /// Parameter `session`: The session object in the active state.
        ///
        ///
        /// Gets called when the NFC reader session has become active. RF is enabled and reader is scanning for tags.
        /// The
        ///
        /// ```text
        ///  readerSession:didDetectTags: @link/ will be called when a tag is detected.
        ///  
        ///
        /// ```
        #[unsafe(method(readerSessionDidBecomeActive:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSessionDidBecomeActive(&self, session: &NFCReaderSession);

        /// Parameter `session`: The session object that is invalidated.
        ///
        /// Parameter `error`: The error indicates the invalidation reason.
        ///
        ///
        /// Gets called when a session becomes invalid.  At this point the client is expected to discard
        /// the returned session object.
        #[unsafe(method(readerSession:didInvalidateWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSession_didInvalidateWithError(
            &self,
            session: &NFCReaderSession,
            error: &NSError,
        );

        /// Parameter `session`: The session object used for tag detection.
        ///
        /// Parameter `tags`: Array of
        ///
        /// ```text
        ///  NFCTag @link/ objects.
        ///
        ///  @discussion      Gets called when the reader detects NFC tag(s) in the polling sequence.
        ///  
        ///
        /// ```
        #[optional]
        #[unsafe(method(readerSession:didDetectTags:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSession_didDetectTags(
            &self,
            session: &NFCReaderSession,
            tags: &NSArray<ProtocolObject<dyn NFCTag>>,
        );
    }
);

extern_class!(
    /// This represents a NFC reader session for processing tags; this base class cannot be instantiate. Only one NFCReaderSession
    /// can be active at any time in the system.  Subsequent opened sessions will get queued up and processed by the system in FIFO order.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcreadersession?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCReaderSession;
);

extern_conformance!(
    unsafe impl NFCReaderSessionProtocol for NFCReaderSession {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCReaderSession {}
);

impl NFCReaderSession {
    extern_methods!(
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<AnyObject>>;

        /// YES if device supports NFC tag reading.
        #[unsafe(method(readingAvailable))]
        #[unsafe(method_family = none)]
        pub unsafe fn readingAvailable() -> bool;

        #[cfg(feature = "dispatch2")]
        /// The NFCReaderSessionDelegate delegate callbacks and the completion block handlers for tag operation will be dispatched on this queue.
        #[unsafe(method(sessionQueue))]
        #[unsafe(method_family = none)]
        pub unsafe fn sessionQueue(&self) -> Retained<DispatchQueue>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCReaderSession {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfctagtype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCTagType(pub NSUInteger);
impl NFCTagType {
    #[doc(alias = "NFCTagTypeISO15693")]
    pub const ISO15693: Self = Self(1);
    #[doc(alias = "NFCTagTypeFeliCa")]
    pub const FeliCa: Self = Self(2);
    #[doc(alias = "NFCTagTypeISO7816Compatible")]
    pub const ISO7816Compatible: Self = Self(3);
    #[doc(alias = "NFCTagTypeMiFare")]
    pub const MiFare: Self = Self(4);
}

unsafe impl Encode for NFCTagType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NFCTagType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A NFC / RFID tag object conforms to this protocol.  The NFCReaderSession returns an instance of this type when a tag is detected.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfctag?language=objc)
    pub unsafe trait NFCTag: NSObjectProtocol + NSSecureCoding + NSCopying {
        /// See
        ///
        /// ```text
        ///  CNFCTagType @link/
        ///  
        ///
        /// ```
        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        unsafe fn r#type(&self) -> NFCTagType;

        /// Session that provides this tag.
        #[unsafe(method(session))]
        #[unsafe(method_family = none)]
        unsafe fn session(&self) -> Option<Retained<ProtocolObject<dyn NFCReaderSessionProtocol>>>;

        /// Returns: <i>
        /// YES
        /// </i>
        /// if tag is available in the current reader session.  A tag remove from the RF field will become
        /// unavailable.  Tag in disconnected state will return NO.
        ///
        ///
        /// Check whether a detected tag is available.
        #[unsafe(method(isAvailable))]
        #[unsafe(method_family = none)]
        unsafe fn isAvailable(&self) -> bool;

        /// Returns: Returns self if it conforms to the NFCISO15693Tag protocol; else returns nil.
        #[unsafe(method(asNFCISO15693Tag))]
        #[unsafe(method_family = none)]
        unsafe fn asNFCISO15693Tag(&self) -> Option<Retained<ProtocolObject<dyn NFCISO15693Tag>>>;

        /// Returns: Returns self if it conforms to the NFCISO7816Tag protocol; else returns nil.
        #[unsafe(method(asNFCISO7816Tag))]
        #[unsafe(method_family = none)]
        unsafe fn asNFCISO7816Tag(&self) -> Option<Retained<ProtocolObject<dyn NFCISO7816Tag>>>;

        /// Returns nil if tag does not conform to NFCFeliCaTag.
        #[unsafe(method(asNFCFeliCaTag))]
        #[unsafe(method_family = none)]
        unsafe fn asNFCFeliCaTag(&self) -> Option<Retained<ProtocolObject<dyn NFCFeliCaTag>>>;

        /// Returns nil if tag does not conform to NFCMiFareTag.
        #[unsafe(method(asNFCMiFareTag))]
        #[unsafe(method_family = none)]
        unsafe fn asNFCMiFareTag(&self) -> Option<Retained<ProtocolObject<dyn NFCMiFareTag>>>;
    }
);

extern_class!(
    /// Define configuration parameters for tag commands.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfctagcommandconfiguration?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCTagCommandConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for NFCTagCommandConfiguration {}
);

unsafe impl CopyingHelper for NFCTagCommandConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCTagCommandConfiguration {}
);

impl NFCTagCommandConfiguration {
    extern_methods!(
        /// Maximum number of retries.  Valid value is 0 to 256.  Default is 0.
        #[unsafe(method(maximumRetries))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumRetries(&self) -> NSUInteger;

        /// Setter for [`maximumRetries`][Self::maximumRetries].
        #[unsafe(method(setMaximumRetries:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumRetries(&self, maximum_retries: NSUInteger);

        /// Delay in seconds before retry occurs.  Default is 0.
        #[unsafe(method(retryInterval))]
        #[unsafe(method_family = none)]
        pub unsafe fn retryInterval(&self) -> NSTimeInterval;

        /// Setter for [`retryInterval`][Self::retryInterval].
        #[unsafe(method(setRetryInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRetryInterval(&self, retry_interval: NSTimeInterval);
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCTagCommandConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Tag reader session delegate
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfctagreadersessiondelegate?language=objc)
    pub unsafe trait NFCTagReaderSessionDelegate: NSObjectProtocol {
        /// Parameter `session`: The session object that is invalidated.
        ///
        /// Parameter `error`: The error indicates the invalidation reason.
        ///
        ///
        /// Gets called when a session becomes invalid.  At this point the client is expected to discard
        /// the returned session object.
        #[unsafe(method(tagReaderSession:didInvalidateWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn tagReaderSession_didInvalidateWithError(
            &self,
            session: &NFCTagReaderSession,
            error: &NSError,
        );

        /// Parameter `session`: The session object in the active state.
        ///
        ///
        /// Gets called when the NFC reader session has become active. RF is enabled and reader is scanning for tags.
        /// The
        ///
        /// ```text
        ///  readerSession:didDetectTags: @link/ will be called when a tag is detected.
        ///  
        ///
        /// ```
        #[optional]
        #[unsafe(method(tagReaderSessionDidBecomeActive:))]
        #[unsafe(method_family = none)]
        unsafe fn tagReaderSessionDidBecomeActive(&self, session: &NFCTagReaderSession);

        /// Parameter `session`: The session object used for tag detection.
        ///
        /// Parameter `tags`: Array of
        ///
        /// ```text
        ///  NFCTag @link/ objects.
        ///
        ///  @discussion      Gets called when the reader detects NFC tag(s) in the polling sequence.
        ///  
        ///
        /// ```
        #[optional]
        #[unsafe(method(tagReaderSession:didDetectTags:))]
        #[unsafe(method_family = none)]
        unsafe fn tagReaderSession_didDetectTags(
            &self,
            session: &NFCTagReaderSession,
            tags: &NSArray<ProtocolObject<dyn NFCTag>>,
        );
    }
);

/// This is an exclusive value that cannot be combine with other NFCPollingOption values; this will override all other combinations.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcpollingoption?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCPollingOption(pub NSInteger);
bitflags::bitflags! {
    impl NFCPollingOption: NSInteger {
        #[doc(alias = "NFCPollingISO14443")]
        const ISO14443 = 0x1;
        #[doc(alias = "NFCPollingISO15693")]
        const ISO15693 = 0x2;
        #[doc(alias = "NFCPollingISO18092")]
        const ISO18092 = 0x4;
        #[doc(alias = "NFCPollingPACE")]
        const PACE = 0x8;
    }
}

unsafe impl Encode for NFCPollingOption {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NFCPollingOption {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Reader session for processing NFC tags supporting one of the
    ///
    /// ```text
    ///  NFCTagType @link/ types.  @link [NFCTagReaderSessionDelegate readerSession:didDetectTags:] @link/
    ///               will return tag objects matching the requested type for the session.  This session requires the "com.apple.developer.nfc.readersession.formats" entitlement
    ///               in your process.  In addition your application's Info.plist must contain a non-empty usage description string. @link NFCReaderErrorSecurityViolation @link/ will be
    ///               returned from @link [NFCTagReaderSessionDelegate tagReaderSession:didInvalidateWithError:] @link/ if the required entitlement is missing when session is started.
    ///
    ///  NOTE:
    ///  - Only one NFCReaderSession can be active at any time in the system. Subsequent opened sessions will get queued up and processed by the system in FIFO order.
    ///  - If the session is configured with @link NFCPollingISO14443 @link/ and an ISO7816 compliant MiFare tag that contains one of the applications listed in the
    ///    "com.apple.developer.nfc.readersession.iso7816.select-identifiers" array in Info.plist is found, then @link [NFCTagReaderSessionDelegate readerSession:didDetectTags:] @link/
    ///    will return a tag instance conform to the @link NFCISO7816Tag @link/ protocol.
    ///  - Use of @link NFCPollingPACE @link/ requires "PACE" to be added into the "com.apple.developer.nfc.readersession.formats" entitlement.
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfctagreadersession?language=objc)
    #[unsafe(super(NFCReaderSession, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCTagReaderSession;
);

extern_conformance!(
    unsafe impl NFCReaderSessionProtocol for NFCTagReaderSession {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCTagReaderSession {}
);

impl NFCTagReaderSession {
    extern_methods!(
        #[unsafe(method(connectedTag))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectedTag(&self) -> Option<Retained<ProtocolObject<dyn NFCTag>>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Parameter `pollingOption`: Configures the RF polling of the reader session; multiple options can be OR'ed together.  This option affects the possible NFC tag type discover.
        ///
        /// Parameter `delegate`: The session will hold a weak ARC reference to this
        ///
        /// ```text
        ///  NFCTagReaderSessionDelegate @link/ object.
        ///  @param queue         A dispatch queue where NFCTagReaderSessionDelegate delegate callbacks will be dispatched to.  A <i>nil</i> value will
        ///                       cause the creation of a serial dispatch queue internally for the session.  The session object will retain the provided dispatch queue.
        ///
        ///  @return              A new NFCTagReaderSession instance.
        ///  
        ///
        /// ```
        #[unsafe(method(initWithPollingOption:delegate:queue:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPollingOption_delegate_queue(
            this: Allocated<Self>,
            polling_option: NFCPollingOption,
            delegate: &ProtocolObject<dyn NFCTagReaderSessionDelegate>,
            queue: Option<&DispatchQueue>,
        ) -> Retained<Self>;

        /// Restart the polling sequence in this session to discover new tags.  New tags discovered from polling will return in the subsequent
        ///
        /// ```text
        ///  [NFCTagReaderSessionDelegate tagReaderSession:didDetectTags:]
        ///              @link/ call. Tags that are returned previously by @link [NFCTagReaderSessionDelegate tagReaderSession:didDetectTags:] @link/ will become invalid,
        ///              and all references to these tags shall be removed to properly release the resources.  Calling this method on an invalidated session
        ///              will have no effect; a new reader session is required to restart the reader.
        ///  
        ///
        /// ```
        #[unsafe(method(restartPolling))]
        #[unsafe(method_family = none)]
        pub unsafe fn restartPolling(&self);

        #[cfg(feature = "block2")]
        /// Parameter `tag`: A NFCTag protocol compliant tag object that will be connected to.
        ///
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///
        ///  @discussion  This method establishes a tag connection and activates the tag.  Connecting to the same tag that is currently opened has no effect.
        ///               Connecting to a different tag will automatically terminate the previous tag connection and put it into the halt state.  Tag stays in the
        ///               connected state until another tag is connected or the polling is restarted.
        ///  
        ///
        /// ```
        #[unsafe(method(connectToTag:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectToTag_completionHandler(
            &self,
            tag: &ProtocolObject<dyn NFCTag>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCTagReaderSession {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// NDEF reader session callbacks.  Presence of the -readerSession:didDetectTags: optional method will change the session behavior
    /// into a read-write session where
    ///
    /// ```text
    ///  NFCNDEFTag @link/ objects are returned.
    ///
    ///  @note       A read-write session does not trigger the -readerSession:didDetectNDEFs: method.
    ///  @note       A read-write session does not get invalidate automatically after a successful tag detection.  Invalidation occurs when
    ///              the invalidation method is called explicitly or the 60 seconds session time limit is reached.
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcndefreadersessiondelegate?language=objc)
    pub unsafe trait NFCNDEFReaderSessionDelegate: NSObjectProtocol {
        /// Parameter `session`: The session object that is invalidated.
        ///
        /// Parameter `error`: The error indicates the invalidation reason.
        ///
        ///
        /// Gets called when a session becomes invalid.  At this point the client is expected to discard
        /// the returned session object.
        #[unsafe(method(readerSession:didInvalidateWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSession_didInvalidateWithError(
            &self,
            session: &NFCNDEFReaderSession,
            error: &NSError,
        );

        /// Parameter `session`: The session object used for tag detection.
        ///
        /// Parameter `messages`: Array of
        ///
        /// ```text
        ///  NFCNDEFMessage @link/ objects.
        ///
        ///  @discussion      Gets called when the reader detects NFC tag(s) with NDEF messages in the polling sequence.  Polling
        ///                   is automatically restarted once the detected tag is removed from the reader's read range.  This method
        ///                   is only get call if the optional -readerSession:didDetectTags: method is not
        ///                   implemented.
        ///  
        ///
        /// ```
        #[unsafe(method(readerSession:didDetectNDEFs:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSession_didDetectNDEFs(
            &self,
            session: &NFCNDEFReaderSession,
            messages: &NSArray<NFCNDEFMessage>,
        );

        /// Parameter `session`: The session object used for NDEF tag detection.
        ///
        /// Parameter `tags`: Array of
        ///
        /// ```text
        ///  NFCNDEFTag @link/ objects.
        ///
        ///  @discussion      Gets called when the reader detects NDEF tag(s) in the RF field.  Presence of this method overrides -readerSession:didDetectNDEFs: and enables
        ///                   read-write capability for the session.
        ///  
        ///
        /// ```
        #[optional]
        #[unsafe(method(readerSession:didDetectTags:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSession_didDetectTags(
            &self,
            session: &NFCNDEFReaderSession,
            tags: &NSArray<ProtocolObject<dyn NFCNDEFTag>>,
        );

        /// Parameter `session`: The session object in the active state.
        ///
        ///
        /// Gets called when the NFC reader session has become active. RF is enabled and reader is scanning for tags.
        #[optional]
        #[unsafe(method(readerSessionDidBecomeActive:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSessionDidBecomeActive(&self, session: &NFCNDEFReaderSession);
    }
);

extern_class!(
    /// NFC reader session for processing NFC Data Exchange Format (NDEF) tags.  This session requires the "com.apple.developer.nfc.readersession.formats"
    /// entitlement in your process.  In addition your application's Info.plist must contain a non-empty usage description string.
    ///
    /// ```text
    ///  NFCReaderErrorSecurityViolation @link/ will be returned from @link [NFCNDEFReaderSessionDelegate readerSession:didInvalidateWithError:] @link/
    ///              if the required entitlement is missing when session is started.
    ///
    ///  @note       Only one NFCNDEFReaderSession can be active at any time in the system. Subsequent opened sessions will get queued up and processed by the system in FIFO order.
    ///  @note       If the delegate object implements the optional -readerSession:didDetectTags: method the NFCNDEFReaderSession will become a read-write session; see @link
    ///              NFCNDEFReaderSessionDelegate @link/ for detail description.
    ///  @note       The error symbol will not be drawn on the action sheet if -invalidateSessionWithError: method is called on a session that is not a read-write session;
    ///              -invalidateSession: method should be used in a read-only session.
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcndefreadersession?language=objc)
    #[unsafe(super(NFCReaderSession, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCNDEFReaderSession;
);

extern_conformance!(
    unsafe impl NFCReaderSessionProtocol for NFCNDEFReaderSession {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCNDEFReaderSession {}
);

impl NFCNDEFReaderSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Parameter `delegate`: The session will hold a weak ARC reference to this
        ///
        /// ```text
        ///  NFCNDEFReaderSessionDelegate @link/ object.
        ///  @param queue     A dispatch queue where NFCNDEFReaderSessionDelegate delegate callbacks will be dispatched to.  A <i>nil</i> value will
        ///                   cause the creation of a serial dispatch queue internally for the session.  The session object will retain the provided dispatch queue.
        ///  @param invalidateAfterFirstRead  Session will automatically invalidate after the first NDEF tag is read successfully when this is set to YES, and
        ///                                   -readerSession:didInvalidateWithError: will return NFCReaderSessionInvalidationErrorFirstNDEFTagRead in this case.
        ///                                   Set to NO if the delegate object implements the -readerSession:didDetectTags: optional method.
        ///
        ///  @return          A new NFCNDEFReaderSession instance.
        ///
        ///  @discussion      A NDEF reader session will scan and detect NFC Forum tags that contain a valid NDEF message.  NFC Forum Tag type 1 to 5 that
        ///                   is NDEF formatted are supported.  A modal system UI will present once -beginSession is called to inform the start of the session; the UI sheet
        ///                   is automatically dismissed when the session is invalidated either by the user or by calling -invalidateSession.  The alertMessage property shall be set
        ///                   prior to -beginSession to display a message on the action sheet UI for the tag scanning operation.
        ///
        ///                   The reader session has the following properties:
        ///                   + An opened session has a 60 seconds time limit restriction after -beginSession is called; -readerSession:didInvalidateWithError: will return
        ///                   NFCReaderSessionInvalidationErrorSessionTimeout error when the time limit is reached.
        ///                   + Only 1 active reader session is allowed in the system; -readerSession:didInvalidateWithError: will return NFCReaderSessionInvalidationErrorSystemIsBusy
        ///                   when a new reader session is initiated by -beginSession when there is an active reader session.  
        ///                   + -readerSession:didInvalidateWithError: will return NFCReaderSessionInvalidationErrorUserCanceled when user clicks on the done button on the UI.
        ///                   + -readerSession:didInvalidateWithError: will return NFCReaderSessionInvalidationErrorSessionTerminatedUnexpectedly when the client application enters
        ///                   the background state.
        ///                   + -readerSession:didInvalidateWithError: will return NFCReaderErrorUnsupportedFeature when 1) reader mode feature is not available on the hardware,
        ///                   2) client application does not have the required entitlement.
        ///
        ///                   The session's mode of operation is determined by the implementation of the delegate object.  The -readerSession:didDetectTags: optional method will
        ///                   enable the read-write capability and suppress the -readerSession:didDetectNDEFs: callback for the session.
        ///  
        ///
        /// ```
        #[unsafe(method(initWithDelegate:queue:invalidateAfterFirstRead:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDelegate_queue_invalidateAfterFirstRead(
            this: Allocated<Self>,
            delegate: &ProtocolObject<dyn NFCNDEFReaderSessionDelegate>,
            queue: Option<&DispatchQueue>,
            invalidate_after_first_read: bool,
        ) -> Retained<Self>;

        /// Restart the polling sequence in this session to discover new NDEF tags.  New tags discovered from polling will return in the subsequent
        ///
        /// ```text
        ///  [NFCNDEFReaderSessionDelegate readerSession:didDetectTags:]
        ///              @link/ call.  Tags that are returned previously by @link [NFCNDEFReaderSessionDelegate -readerSession:didDetectTags:] @link/ will become invalid,
        ///              and all references to these tags shall be removed to properly release the resources.  Calling this method on an invalidated session
        ///              will have no effect; a new reader session is required to restart the reader. Calling this method on an instance initiated with a delegate object that does not implement
        ///              the optional -readerSession:didDetectTags: method has no effect as RF polling restart is done automatically.
        ///  
        ///
        /// ```
        #[unsafe(method(restartPolling))]
        #[unsafe(method_family = none)]
        pub unsafe fn restartPolling(&self);

        #[cfg(feature = "block2")]
        /// Parameter `tag`: A NFCTag protocol compliant tag object that will be connect to.
        ///
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///
        ///  @discussion  This method establishes a tag connection and activates the tag.  Connecting to the same tag that is currently opened has no effect.
        ///               Connecting to a different tag will automatically terminate the previous tag connection and put it into the halt state.  Tag stays in the
        ///               connected state until another tag is connected or the polling is restarted.
        ///  
        ///
        /// ```
        #[unsafe(method(connectToTag:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectToTag_completionHandler(
            &self,
            tag: &ProtocolObject<dyn NFCNDEFTag>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCNDEFReaderSession {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

mod private_NSUserActivityCoreNFC {
    pub trait Sealed {}
}

/// Category "CoreNFC" on [`NSUserActivity`].
#[doc(alias = "CoreNFC")]
pub unsafe trait NSUserActivityCoreNFC:
    ClassType + Sized + private_NSUserActivityCoreNFC::Sealed
{
    extern_methods!(
        /// The NFC NDEF message with an Universal Link object that triggers the application launch.
        #[unsafe(method(ndefMessagePayload))]
        #[unsafe(method_family = none)]
        unsafe fn ndefMessagePayload(&self) -> Retained<NFCNDEFMessage>;
    );
}

impl private_NSUserActivityCoreNFC::Sealed for NSUserActivity {}
unsafe impl NSUserActivityCoreNFC for NSUserActivity {}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfciso15693requestflag?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCISO15693RequestFlag(pub u8);
bitflags::bitflags! {
    impl NFCISO15693RequestFlag: u8 {
        #[doc(alias = "NFCISO15693RequestFlagDualSubCarriers")]
        const DualSubCarriers = 1<<0;
        #[doc(alias = "NFCISO15693RequestFlagHighDataRate")]
        const HighDataRate = 1<<1;
        #[doc(alias = "NFCISO15693RequestFlagProtocolExtension")]
        const ProtocolExtension = 1<<3;
        #[doc(alias = "NFCISO15693RequestFlagSelect")]
        const Select = 1<<4;
        #[doc(alias = "NFCISO15693RequestFlagAddress")]
        const Address = 1<<5;
        #[doc(alias = "NFCISO15693RequestFlagOption")]
        const Option = 1<<6;
        #[doc(alias = "NFCISO15693RequestFlagCommandSpecificBit8")]
        const CommandSpecificBit8 = 1<<7;
#[deprecated]
        const RequestFlagDualSubCarriers = NFCISO15693RequestFlag::DualSubCarriers.0;
#[deprecated]
        const RequestFlagHighDataRate = NFCISO15693RequestFlag::HighDataRate.0;
#[deprecated]
        const RequestFlagProtocolExtension = NFCISO15693RequestFlag::ProtocolExtension.0;
#[deprecated]
        const RequestFlagSelect = NFCISO15693RequestFlag::Select.0;
#[deprecated]
        const RequestFlagAddress = NFCISO15693RequestFlag::Address.0;
#[deprecated]
        const RequestFlagOption = NFCISO15693RequestFlag::Option.0;
    }
}

unsafe impl Encode for NFCISO15693RequestFlag {
    const ENCODING: Encoding = u8::ENCODING;
}

unsafe impl RefEncode for NFCISO15693RequestFlag {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/requestflag?language=objc)
pub type RequestFlag = NFCISO15693RequestFlag;

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfciso15693responseflag?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCISO15693ResponseFlag(pub u8);
bitflags::bitflags! {
    impl NFCISO15693ResponseFlag: u8 {
        #[doc(alias = "NFCISO15693ResponseFlagError")]
        const Error = 1<<0;
        #[doc(alias = "NFCISO15693ResponseFlagResponseBufferValid")]
        const ResponseBufferValid = 1<<1;
        #[doc(alias = "NFCISO15693ResponseFlagFinalResponse")]
        const FinalResponse = 1<<2;
        #[doc(alias = "NFCISO15693ResponseFlagProtocolExtension")]
        const ProtocolExtension = 1<<3;
        #[doc(alias = "NFCISO15693ResponseFlagBlockSecurityStatusBit5")]
        const BlockSecurityStatusBit5 = 1<<4;
        #[doc(alias = "NFCISO15693ResponseFlagBlockSecurityStatusBit6")]
        const BlockSecurityStatusBit6 = 1<<5;
        #[doc(alias = "NFCISO15693ResponseFlagWaitTimeExtension")]
        const WaitTimeExtension = 1<<6;
    }
}

unsafe impl Encode for NFCISO15693ResponseFlag {
    const ENCODING: Encoding = u8::ENCODING;
}

unsafe impl RefEncode for NFCISO15693ResponseFlag {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// Configuration options for the Manufacturer Custom command.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfciso15693customcommandconfiguration?language=objc)
    #[unsafe(super(NFCTagCommandConfiguration, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCISO15693CustomCommandConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for NFCISO15693CustomCommandConfiguration {}
);

unsafe impl CopyingHelper for NFCISO15693CustomCommandConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCISO15693CustomCommandConfiguration {}
);

impl NFCISO15693CustomCommandConfiguration {
    extern_methods!(
        /// Manufacturer code. Valid range is 0x00 to 0xFF.
        #[unsafe(method(manufacturerCode))]
        #[unsafe(method_family = none)]
        pub unsafe fn manufacturerCode(&self) -> NSUInteger;

        /// Setter for [`manufacturerCode`][Self::manufacturerCode].
        #[unsafe(method(setManufacturerCode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setManufacturerCode(&self, manufacturer_code: NSUInteger);

        /// Manufacturer Custom Command Index.  Valid range is 0xA0 to 0xDF.
        #[unsafe(method(customCommandCode))]
        #[unsafe(method_family = none)]
        pub unsafe fn customCommandCode(&self) -> NSUInteger;

        /// Setter for [`customCommandCode`][Self::customCommandCode].
        #[unsafe(method(setCustomCommandCode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCustomCommandCode(&self, custom_command_code: NSUInteger);

        /// Custom request data.
        #[unsafe(method(requestParameters))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestParameters(&self) -> Retained<NSData>;

        /// Setter for [`requestParameters`][Self::requestParameters].
        #[unsafe(method(setRequestParameters:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRequestParameters(&self, request_parameters: &NSData);

        /// Parameter `manufacturerCode`: 8 bits manufacturer code.
        ///
        /// Parameter `customCommandCode`: 8 bits custom command code.  Valid range is 0xA0 to 0xDF.
        ///
        /// Parameter `requestParameters`: Optional custom request parameters.
        ///
        ///
        /// Initialize with default zero maximum retry and zero retry interval.
        #[unsafe(method(initWithManufacturerCode:customCommandCode:requestParameters:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithManufacturerCode_customCommandCode_requestParameters(
            this: Allocated<Self>,
            manufacturer_code: NSUInteger,
            custom_command_code: NSUInteger,
            request_parameters: Option<&NSData>,
        ) -> Retained<Self>;

        /// Parameter `manufacturerCode`: 8 bits manufacturer code.
        ///
        /// Parameter `customCommandCode`: 8 bits custom command code.  Valid range is 0xA0 to 0xDF.
        ///
        /// Parameter `requestParameters`: Optional custom request parameters.
        ///
        /// Parameter `maximumRetries`: Maximum number of retry attempt when tag response is not received.
        ///
        /// Parameter `retryInterval`: Time interval wait between each retry attempt.
        #[unsafe(method(initWithManufacturerCode:customCommandCode:requestParameters:maximumRetries:retryInterval:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithManufacturerCode_customCommandCode_requestParameters_maximumRetries_retryInterval(
            this: Allocated<Self>,
            manufacturer_code: NSUInteger,
            custom_command_code: NSUInteger,
            request_parameters: Option<&NSData>,
            maximum_retries: NSUInteger,
            retry_interval: NSTimeInterval,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCISO15693CustomCommandConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Configuration options for the Read Multiple Blocks command.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfciso15693readmultipleblocksconfiguration?language=objc)
    #[unsafe(super(NFCTagCommandConfiguration, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCISO15693ReadMultipleBlocksConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for NFCISO15693ReadMultipleBlocksConfiguration {}
);

unsafe impl CopyingHelper for NFCISO15693ReadMultipleBlocksConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCISO15693ReadMultipleBlocksConfiguration {}
);

impl NFCISO15693ReadMultipleBlocksConfiguration {
    extern_methods!(
        /// Range to read in blocks.  Valid start index range is 0x00 to 0xFF.  Length shall not be 0.
        #[unsafe(method(range))]
        #[unsafe(method_family = none)]
        pub unsafe fn range(&self) -> NSRange;

        /// Setter for [`range`][Self::range].
        #[unsafe(method(setRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRange(&self, range: NSRange);

        /// Number of blocks to read per Read Multiple Blocks command. This may be limited by the tag hardware.
        #[unsafe(method(chunkSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn chunkSize(&self) -> NSUInteger;

        /// Setter for [`chunkSize`][Self::chunkSize].
        #[unsafe(method(setChunkSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setChunkSize(&self, chunk_size: NSUInteger);

        /// Initialize with default zero maximum retry and zero retry interval.
        #[unsafe(method(initWithRange:chunkSize:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithRange_chunkSize(
            this: Allocated<Self>,
            range: NSRange,
            chunk_size: NSUInteger,
        ) -> Retained<Self>;

        /// Parameter `range`: Read range specify by the starting block index and the total number of blocks.
        ///
        /// Parameter `chunkSize`: Specify number of blocks parameter for the Read multiple blocks command.
        ///
        /// Parameter `maximumRetries`: Maximum number of retry attempt when tag response is not received.
        ///
        /// Parameter `retryInterval`: Time interval wait between each retry attempt.
        #[unsafe(method(initWithRange:chunkSize:maximumRetries:retryInterval:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithRange_chunkSize_maximumRetries_retryInterval(
            this: Allocated<Self>,
            range: NSRange,
            chunk_size: NSUInteger,
            maximum_retries: NSUInteger,
            retry_interval: NSTimeInterval,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCISO15693ReadMultipleBlocksConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A
    ///
    /// ```text
    ///  NFCISO15693ReaderSession @link/ or @link NFCTagReaderSession @link/ reader session returns an instance conforming
    ///               to this protocol when an ISO15693 tag is detected.  Unless it is specified all block completion handlers are dispatched on the
    ///               reader session work queue that is associated with the tag.  Your process requires to include the "com.apple.developer.nfc.readersession.formats"
    ///               entitlement to receive this tag object from the @link NFCReaderSessionDelegate @link/ delegate.
    ///               @link NFCReaderErrorSecurityViolation @link/ will be returned from the @link NFCTagReaderSessionDelegate @link/ invalidation method if the required
    ///               entitlement is missing when session is started.
    ///               Tag must be in the connected state for NFCNDEFTag protocol properties and methods to work correctly.  Each data frame send out by the reader may not
    ///               exceed 256 bytes total.
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfciso15693tag?language=objc)
    pub unsafe trait NFCISO15693Tag: NFCTag + NFCNDEFTag {
        /// The 64 bit hardware UID of the tag. Data is in Big Endian byte order.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        unsafe fn identifier(&self) -> Retained<NSData>;

        /// The IC manufacturer code (bits 56 – 49) in UID according to ISO/IEC 7816-6:2004.
        #[unsafe(method(icManufacturerCode))]
        #[unsafe(method_family = none)]
        unsafe fn icManufacturerCode(&self) -> NSUInteger;

        /// The IC serial number (bits 48 – 1) in UID assigned by the manufacturer.  Data is in Big Endian byte order.
        #[unsafe(method(icSerialNumber))]
        #[unsafe(method_family = none)]
        unsafe fn icSerialNumber(&self) -> Retained<NSData>;

        #[cfg(feature = "block2")]
        /// Parameter `commandConfiguration`: Configuration for the Manufacturer Custom Command.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                               responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion Send a manufacturer dependent custom command using command code range from 0xA0 to 0xDF.  Refer to ISO15693-3
        ///              specification for details.
        ///  
        ///
        /// ```
        #[unsafe(method(sendCustomCommandWithConfiguration:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn sendCustomCommandWithConfiguration_completionHandler(
            &self,
            command_configuration: &NFCISO15693CustomCommandConfiguration,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `readConfiguration`: Configuration For the Read Multiple Blocks command.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           Successfully read data blocks will be returned from NSData object.  All blocks are concatenated into the NSData object.
        ///
        ///  @discussion  Performs read operation using Read Multiple Blocks command (0x23 command code) as defined in ISO15693-3 specification.
        ///               Multiple Read Multiple Blocks commands will be sent if necessary to complete the operation.
        ///  
        ///
        /// ```
        #[unsafe(method(readMultipleBlocksWithConfiguration:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn readMultipleBlocksWithConfiguration_completionHandler(
            &self,
            read_configuration: &NFCISO15693ReadMultipleBlocksConfiguration,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Stay quiet command (0x02 command code) as defined in ISO15693-3 specification.
        ///  
        ///
        /// ```
        #[unsafe(method(stayQuietWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn stayQuietWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockNumber`: Block number. Blocks are numbered from 0 to 255 inclusively.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           Successfully read data blocks will be returned from NSData object. If Option flag in the request flags is set,
        ///                           then first byte of data block will contain the associated block security status.
        ///
        ///  @discussion              Read single block command (0x20 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(readSingleBlockWithRequestFlags:blockNumber:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn readSingleBlockWithRequestFlags_blockNumber_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_number: u8,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockNumber`: Block number. Blocks are numbered from 0 to 255 inclusively.
        ///
        /// Parameter `dataBlock`: A single block of data.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Write single block command (0x21 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(writeSingleBlockWithRequestFlags:blockNumber:dataBlock:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn writeSingleBlockWithRequestFlags_blockNumber_dataBlock_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_number: u8,
            data_block: &NSData,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockNumber`: Block number. Blocks are numbered from 0 to 255 inclusively.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           Successfully read data blocks will be returned from NSData object.
        ///
        ///  @discussion              Lock block command (0x22 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///
        /// ```
        #[unsafe(method(lockBlockWithRequestFlags:blockNumber:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn lockBlockWithRequestFlags_blockNumber_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_number: u8,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockRange`: The range of blocks.  Valid start index range is 0 to 255 inclusively.  Valid length is 1 to 256 inclusively.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           Successfully read data blocks will be returned from NSArray of NSData object. If Option flag in the request flags is set,
        ///                           then first byte of each returned data block will contain the associated block security status.  Each data block element
        ///                           would have identical size.
        ///
        ///  @discussion              Read multiple blocks command (0x23 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(readMultipleBlocksWithRequestFlags:blockRange:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn readMultipleBlocksWithRequestFlags_blockRange_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_range: NSRange,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSData>>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockRange`: The range of blocks.  Valid start index range is 0 to 255 inclusively.  Valid length is 1 to 256 inclusively.
        ///
        /// Parameter `dataBlocks`: Blocks of data represent in NSArray of NSData.  The number of blocks shall match the length value of the blockRange parameter.
        /// Each block element should have identical size and should match the physical block size of the tag.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Write multiple blocks command (0x24 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(writeMultipleBlocksWithRequestFlags:blockRange:dataBlocks:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn writeMultipleBlocksWithRequestFlags_blockRange_dataBlocks_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_range: NSRange,
            data_blocks: &NSArray<NSData>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Select command (0x25 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(selectWithRequestFlags:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn selectWithRequestFlags_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Reset To Ready command (0x26 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(resetToReadyWithRequestFlags:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn resetToReadyWithRequestFlags_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `afi`: Application Family Identifier.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Write AFI command (0x27 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(writeAFIWithRequestFlag:afi:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn writeAFIWithRequestFlag_afi_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            afi: u8,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Lock AFI command (0x28 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(lockAFIWithRequestFlag:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn lockAFIWithRequestFlag_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `dsfid`: Data Storage Format Identifier.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Write DSFID command (0x29 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(writeDSFIDWithRequestFlag:dsfid:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn writeDSFIDWithRequestFlag_dsfid_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            dsfid: u8,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Use the replacement -lockDSFIDWithRequestFlag:completionHandler:.
        ///  
        ///
        /// ```
        #[deprecated]
        #[unsafe(method(lockDFSIDWithRequestFlag:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn lockDFSIDWithRequestFlag_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Lock DSFID command (0x2A command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(lockDSFIDWithRequestFlag:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn lockDSFIDWithRequestFlag_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           Value of -1 will be returned from dsfid, afi, blockSize, blockCount, or icReference if tag response does not contain the information.
        ///                           blockSize returns the actual block size in bytes ranged from 1 to 32.  blockCount returns the actual number of blocks
        ///                           ranged from 1 to 256 blocks.
        ///
        ///  @discussion              Use the replacement -getSystemInfoAndUIDWithRequestFlag:completionHandler:.
        ///  
        ///
        /// ```
        #[deprecated]
        #[unsafe(method(getSystemInfoWithRequestFlag:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn getSystemInfoWithRequestFlag_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            completion_handler: &block2::DynBlock<
                dyn Fn(NSInteger, NSInteger, NSInteger, NSInteger, NSInteger, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           Value of -1 will be returned from dsfid, afi, blockSize, blockCount, or icReference, and a nil UID value if tag response does not contain the information.
        ///                           blockSize returns the actual block size in bytes ranged from 1 to 32.  blockCount returns the actual number of blocks
        ///                           ranged from 1 to 256 blocks.  64bits UID value in little endian byte order from the response packet is returned.
        ///
        ///  @discussion              Get system information command (0x2B command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///
        /// ```
        #[unsafe(method(getSystemInfoAndUIDWithRequestFlag:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn getSystemInfoAndUIDWithRequestFlag_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            completion_handler: &block2::DynBlock<
                dyn Fn(
                    *mut NSData,
                    NSInteger,
                    NSInteger,
                    NSInteger,
                    NSInteger,
                    NSInteger,
                    *mut NSError,
                ),
            >,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockRange`: The range of blocks.  Valid start index range is 0 to 255 inclusively.  Valid length is 1 to 256 inclusively.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           The 8 bits security status of the requested blocks are returned in NSArray; the array will be empty when error occurs.
        ///
        ///  @discussion              Get multiple block security status command (0x2C command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(getMultipleBlockSecurityStatusWithRequestFlag:blockRange:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn getMultipleBlockSecurityStatusWithRequestFlag_blockRange_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_range: NSRange,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSNumber>>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockRange`: The range of blocks.  Valid start index range is 0 to 255 inclusively.  Valid length is 1 to 256 inclusively.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        ///
        ///
        /// Fast read multiple blocks command (0x2D command code) as defined in ISO15693-3 specification.
        #[unsafe(method(fastReadMultipleBlocksWithRequestFlag:blockRange:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn fastReadMultipleBlocksWithRequestFlag_blockRange_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_range: NSRange,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSData>>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `customCommandCode`: Custom command code defined by the IC manufacturer.  Valid range is 0xA0 to 0xDF inclusively.
        ///
        /// Parameter `customRequestParameters`: Custom request parameters defined by the command.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                                   A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                                   responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                                   The custom response parameters are returned on success.
        ///
        ///  @discussion                      Custom command (0xA0 to 0xDF command code) as defined in ISO15693-3 specification.  IC manufacturer code from the tag is
        ///                                   automatically inserted after the command byte before appending the custom request parameters in forming the packet.
        ///  
        ///
        /// ```
        #[unsafe(method(customCommandWithRequestFlag:customCommandCode:customRequestParameters:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn customCommandWithRequestFlag_customCommandCode_customRequestParameters_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            custom_command_code: NSInteger,
            custom_request_parameters: &NSData,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockNumber`: 2 bytes block number, valid range from 0 to 65535 inclusively.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           If Option flag in the request flags is set, then first byte of the returned data block will contain the associated block security status.
        ///
        ///  @discussion              Extended read single block command (0x30 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(extendedReadSingleBlockWithRequestFlags:blockNumber:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedReadSingleBlockWithRequestFlags_blockNumber_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_number: NSInteger,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockNumber`: 2 bytes block number, valid range from 0 to 65535 inclusively.
        ///
        /// Parameter `dataBlock`: A single block of data.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Extended write single block command (0x31 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(extendedWriteSingleBlockWithRequestFlags:blockNumber:dataBlock:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedWriteSingleBlockWithRequestFlags_blockNumber_dataBlock_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_number: NSInteger,
            data_block: &NSData,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockNumber`: 2 bytes block number, valid range from 0 to 65535 inclusively.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Extended lock single block command (0x32 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(extendedLockBlockWithRequestFlags:blockNumber:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedLockBlockWithRequestFlags_blockNumber_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_number: NSInteger,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockRange`: The range of blocks.  Valid start index range is 0 to 65535 inclusively.  Valid length is 1 to 65536 inclusively.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           Successfully read data blocks will be returned from NSData object.  If Option flag in the request flags is set,
        ///                           then first byte of each returned data blocks will contain the associated block security status.
        ///
        ///  @discussion              Extended read multiple block command (0x33 command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(extendedReadMultipleBlocksWithRequestFlags:blockRange:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedReadMultipleBlocksWithRequestFlags_blockRange_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_range: NSRange,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSData>>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockRange`: The range of blocks.  Valid start index range is 0 to 65535 inclusively.  Valid length is 1 to 65536 inclusively.
        ///
        /// Parameter `dataBlocks`: Blocks of data represented in NSArray of NSData.  The number of blocks shall match the length value of the blockRange parameter.
        /// Each block element should have identical size and should match the physical block size of the tag.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion              Extended write multiple block command (0x34 command code) as defined in ISO15693-3 specification. Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(extendedWriteMultipleBlocksWithRequestFlags:blockRange:dataBlocks:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedWriteMultipleBlocksWithRequestFlags_blockRange_dataBlocks_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_range: NSRange,
            data_blocks: &NSArray<NSData>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `cryptoSuiteIdentifier`: 8 bits Crypto Suite Indicator as defined in ISO/IEC 29167 specification.
        ///
        /// Parameter `message`: Content of the Authenticate command as dictated by the Crypto Suite Indicator.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                               A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                               responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                               Successfully command response will be return as NSData object excluding the 8 bits response flag.
        ///
        ///  @discussion                  Authenticate command (0x35 command code) as defined in ISO15693-3 specification.  Please note that in-process reply is returned to the caller without any processing.
        ///  
        ///
        /// ```
        #[unsafe(method(authenticateWithRequestFlags:cryptoSuiteIdentifier:message:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn authenticateWithRequestFlags_cryptoSuiteIdentifier_message_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            crypto_suite_identifier: NSInteger,
            message: &NSData,
            completion_handler: &block2::DynBlock<
                dyn Fn(NFCISO15693ResponseFlag, NonNull<NSData>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `keyIdentifier`: 8 bits key identifier
        ///
        /// Parameter `message`: Content of the Key Update command as dictated by the Crypto Suite Indicator used in Authenticate.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           Successfully command response will be return as NSData object excluding the 8 bits response flag.
        ///
        ///  @discussion              Key update command (0x36 command code) as defined in ISO15693-3 specification.  Please note that in-process reply is returned to the caller without any processing.
        ///  
        ///
        /// ```
        #[unsafe(method(keyUpdateWithRequestFlags:keyIdentifier:message:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn keyUpdateWithRequestFlags_keyIdentifier_message_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            key_identifier: NSInteger,
            message: &NSData,
            completion_handler: &block2::DynBlock<
                dyn Fn(NFCISO15693ResponseFlag, NonNull<NSData>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `cryptoSuiteIdentifier`: 8 bits Crypto Suite Indicator as defined in ISO/IEC 29167 specification.
        ///
        /// Parameter `message`: Content of the Key Update command as dictated by the Crypto Suite Indicator used in Authenticate.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                               A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                               responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///
        ///  @discussion                  Challenge command (0x39 command code) as defined in ISO15693-3 specification.
        ///  
        ///
        /// ```
        #[unsafe(method(challengeWithRequestFlags:cryptoSuiteIdentifier:message:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn challengeWithRequestFlags_cryptoSuiteIdentifier_message_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            crypto_suite_identifier: NSInteger,
            message: &NSData,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           Successfully command response will be return as NSData object excluding the 8 bits response flag.
        ///
        ///  @discussion              Read buffer command (0x3A command code) as defined in ISO15693-3 specification.
        ///  
        ///
        /// ```
        #[unsafe(method(readBufferWithRequestFlags:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn readBufferWithRequestFlags_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            completion_handler: &block2::DynBlock<
                dyn Fn(NFCISO15693ResponseFlag, NonNull<NSData>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `blockRange`: The range of blocks.  Valid start index range is 0 to 255 inclusively.  Valid length is 1 to 256 inclusively.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///                           A @link NFCISO15693TagResponseErrorKey @link/ in NSError userInfo dictionary is returned when the tag
        ///                           responded to the command with an error, and the error code value is defined in ISO15693-3 specification.
        ///                           The 8 bits security status of the requested blocks are returned in NSArray; the array will be empty when error occurs.
        ///
        ///  @discussion              Get multiple block security status command (0x3C command code) as defined in ISO15693-3 specification.  Address flag is automatically
        ///                           enforced by default and the tag's UID is sent with the command; setting RequestFlagSelect to flags will disable the Address flag.
        ///  
        ///
        /// ```
        #[unsafe(method(extendedGetMultipleBlockSecurityStatusWithRequestFlag:blockRange:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedGetMultipleBlockSecurityStatusWithRequestFlag_blockRange_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_range: NSRange,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSNumber>>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        ///
        ///
        /// Fast read multiple blocks command (0x3D command code) as defined in ISO15693-3 specification.
        #[unsafe(method(extendedFastReadMultipleBlocksWithRequestFlag:blockRange:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn extendedFastReadMultipleBlocksWithRequestFlag_blockRange_completionHandler(
            &self,
            flags: NFCISO15693RequestFlag,
            block_range: NSRange,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSData>>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `flags`: Request flags.
        ///
        /// Parameter `commandCode`: 8 bits command code.
        ///
        /// Parameter `data`: Data follows after the command code.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        ///
        ///
        /// Send a command according to the ISO15693-3 specification.  The request data frame is concatenation of 8 bits request flag, 8 bits command code, and optional data.
        /// Total length of the data frame cannot exceed 256 bytes.  The 8 bits response flag and the data are returned in the completion handler.
        #[unsafe(method(sendRequestWithFlag:commandCode:data:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn sendRequestWithFlag_commandCode_data_completionHandler(
            &self,
            flags: NSInteger,
            command_code: NSInteger,
            data: Option<&NSData>,
            completion_handler: &block2::DynBlock<
                dyn Fn(NFCISO15693ResponseFlag, *mut NSData, *mut NSError),
            >,
        );
    }
);

extern_class!(
    /// Reader session for processing ISO15693 tags.
    ///
    /// ```text
    ///  [NFCReaderSessionDelegate readerSession:didDetectTags:] @link/ will return tag objects that
    ///              are conformed to the NFCISO15693Tag protocol.  This session requires the "com.apple.developer.nfc.readersession.formats" entitlement in your process.
    ///
    ///  NOTE:
    ///  Only one NFCReaderSession can be active at any time in the system. Subsequent opened sessions will get queued up and processed by the system in FIFO order.
    ///  The NFCISO15693 tag object returned by this session will only respond to the legacy APIs that are introduced in iOS11.
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfciso15693readersession?language=objc)
    #[unsafe(super(NFCReaderSession, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated]
    pub struct NFCISO15693ReaderSession;
);

extern_conformance!(
    unsafe impl NFCReaderSessionProtocol for NFCISO15693ReaderSession {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCISO15693ReaderSession {}
);

impl NFCISO15693ReaderSession {
    extern_methods!(
        #[deprecated]
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Parameter `delegate`: The session will hold a weak ARC reference to this
        ///
        /// ```text
        ///  NFCReaderSessionDelegate @link/ object.
        ///  @param queue     A dispatch queue where NFCReaderSessionDelegate delegate callbacks will be dispatched to.  A <i>nil</i> value will
        ///                   cause the creation of a serial dispatch queue internally for the session.  The session object will retain the provided dispatch queue.
        ///
        ///  @return          A new NFCISO15693ReaderSession instance.
        ///  
        ///
        /// ```
        #[deprecated = "No longer supported"]
        #[unsafe(method(initWithDelegate:queue:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDelegate_queue(
            this: Allocated<Self>,
            delegate: &ProtocolObject<dyn NFCReaderSessionDelegate>,
            queue: Option<&DispatchQueue>,
        ) -> Retained<Self>;

        /// Restart the polling sequence in this session to discover new tags.  Tags that are returned previously by
        ///
        /// ```text
        ///  [NFCReaderSessionDelegate readerSession:didDetectTags:]
        ///              @link/ will become invalid, and all references to these tags shall be removed to properly release the resources.  Calling this method on an invalidated session
        ///              will have no effect; a new reader session is required to restart the reader.
        ///  
        ///
        /// ```
        #[deprecated = "No longer supported"]
        #[unsafe(method(restartPolling))]
        #[unsafe(method_family = none)]
        pub unsafe fn restartPolling(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCISO15693ReaderSession {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcndefstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCNDEFStatus(pub NSUInteger);
impl NFCNDEFStatus {
    #[doc(alias = "NFCNDEFStatusNotSupported")]
    pub const NotSupported: Self = Self(1);
    #[doc(alias = "NFCNDEFStatusReadWrite")]
    pub const ReadWrite: Self = Self(2);
    #[doc(alias = "NFCNDEFStatusReadOnly")]
    pub const ReadOnly: Self = Self(3);
}

unsafe impl Encode for NFCNDEFStatus {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NFCNDEFStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// Operations on a NDEF formatted tag.  Unless it is specified all block completion handlers are dispatched on the session work queue that is associated with the tag.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcndeftag?language=objc)
    pub unsafe trait NFCNDEFTag: NSObjectProtocol + NSSecureCoding + NSCopying {
        /// Returns: <i>
        /// YES
        /// </i>
        /// if NDEF tag is available in the current reader session.  A tag remove from the RF field will become
        /// unavailable.  Tag in disconnected state will return NO.
        ///
        ///
        /// Check whether a detected NDEF tag is available.
        #[unsafe(method(isAvailable))]
        #[unsafe(method_family = none)]
        unsafe fn isAvailable(&self) -> bool;

        #[cfg(feature = "block2")]
        /// Parameter `completionHandler`: Return the NFCNDEFStatus of the tag.  capacity indicates the maximum NDEF message size in bytes that can be store on the tag.
        /// error returns a valid NSError object when query fails.
        ///
        ///
        /// Query the NDEF support status of the tag.
        #[unsafe(method(queryNDEFStatusWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn queryNDEFStatusWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(NFCNDEFStatus, NSUInteger, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `completionHandler`: Returns the NDEF message from read operation.  Successful read would return a valid NFCNDEFMessage object with NSError object set to nil;
        /// read failure returns a nil NFCNDEFMessage and a valid NSError object.
        ///
        ///
        /// Reads NDEF message from the tag.
        #[unsafe(method(readNDEFWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn readNDEFWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NFCNDEFMessage, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `completionHandler`: Returns operation status.  A nil NSError object indicates a successful write operation.
        ///
        ///
        /// Writes a NDEF message to the tag.
        #[unsafe(method(writeNDEF:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn writeNDEF_completionHandler(
            &self,
            ndef_message: &NFCNDEFMessage,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `completionHandler`: Returns operation status. A nil NSError object indicates a successful lock operation.
        ///
        ///
        /// Locks the NDEF tag to read-only state; tag can no longer be written afterward.  This is a permanent operation.  A successful lock operation via this method
        /// will change the NFCNDEFStatus value of the tag to
        ///
        /// ```text
        ///  NFCNDEFStatusReadOnly @link/.
        ///  
        ///
        /// ```
        #[unsafe(method(writeLockWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn writeLockWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSError)>,
        );
    }
);

/// Request code parameter for the polling command
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcfelicapollingrequestcode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCFeliCaPollingRequestCode(pub NSInteger);
impl NFCFeliCaPollingRequestCode {
    #[doc(alias = "NFCFeliCaPollingRequestCodeNoRequest")]
    pub const NoRequest: Self = Self(0);
    #[doc(alias = "NFCFeliCaPollingRequestCodeSystemCode")]
    pub const SystemCode: Self = Self(1);
    #[doc(alias = "NFCFeliCaPollingRequestCodeCommunicationPerformance")]
    pub const CommunicationPerformance: Self = Self(2);
    #[deprecated]
    pub const PollingRequestCodeNoRequest: Self = Self(NFCFeliCaPollingRequestCode::NoRequest.0);
    #[deprecated]
    pub const PollingRequestCodeSystemCode: Self = Self(NFCFeliCaPollingRequestCode::SystemCode.0);
    #[deprecated]
    pub const PollingRequestCodeCommunicationPerformance: Self =
        Self(NFCFeliCaPollingRequestCode::CommunicationPerformance.0);
}

unsafe impl Encode for NFCFeliCaPollingRequestCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NFCFeliCaPollingRequestCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/pollingrequestcode?language=objc)
pub type PollingRequestCode = NFCFeliCaPollingRequestCode;

/// Time slot parameter for the polling command
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcfelicapollingtimeslot?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCFeliCaPollingTimeSlot(pub NSInteger);
impl NFCFeliCaPollingTimeSlot {
    #[doc(alias = "NFCFeliCaPollingTimeSlotMax1")]
    pub const Max1: Self = Self(0);
    #[doc(alias = "NFCFeliCaPollingTimeSlotMax2")]
    pub const Max2: Self = Self(1);
    #[doc(alias = "NFCFeliCaPollingTimeSlotMax4")]
    pub const Max4: Self = Self(3);
    #[doc(alias = "NFCFeliCaPollingTimeSlotMax8")]
    pub const Max8: Self = Self(7);
    #[doc(alias = "NFCFeliCaPollingTimeSlotMax16")]
    pub const Max16: Self = Self(15);
    #[deprecated]
    pub const PollingTimeSlotMax1: Self = Self(NFCFeliCaPollingTimeSlot::Max1.0);
    #[deprecated]
    pub const PollingTimeSlotMax2: Self = Self(NFCFeliCaPollingTimeSlot::Max2.0);
    #[deprecated]
    pub const PollingTimeSlotMax4: Self = Self(NFCFeliCaPollingTimeSlot::Max4.0);
    #[deprecated]
    pub const PollingTimeSlotMax8: Self = Self(NFCFeliCaPollingTimeSlot::Max8.0);
    #[deprecated]
    pub const PollingTimeSlotMax16: Self = Self(NFCFeliCaPollingTimeSlot::Max16.0);
}

unsafe impl Encode for NFCFeliCaPollingTimeSlot {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NFCFeliCaPollingTimeSlot {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/pollingtimeslot?language=objc)
pub type PollingTimeSlot = NFCFeliCaPollingTimeSlot;

/// Encryption Identifier parameter in response of Request Service V2
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcfelicaencryptionid?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCFeliCaEncryptionId(pub NSInteger);
impl NFCFeliCaEncryptionId {
    #[doc(alias = "NFCFeliCaEncryptionIdAES")]
    pub const AES: Self = Self(0x4F);
    #[doc(alias = "NFCFeliCaEncryptionIdAES_DES")]
    pub const AES_DES: Self = Self(0x41);
    #[deprecated]
    pub const EncryptionIdAES: Self = Self(NFCFeliCaEncryptionId::AES.0);
    #[deprecated]
    pub const EncryptionIdAES_DES: Self = Self(NFCFeliCaEncryptionId::AES_DES.0);
}

unsafe impl Encode for NFCFeliCaEncryptionId {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NFCFeliCaEncryptionId {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/encryptionid?language=objc)
pub type EncryptionId = NFCFeliCaEncryptionId;

extern_protocol!(
    /// A
    ///
    /// ```text
    ///  NFCTagReaderSession @link/ reader session returns an instance conforming to this protocol
    ///               when a FeliCa tag is detected.  Unless it is specified all block completion handlers are dispatched on the
    ///               session work queue that is associated with the tag.  Your process requires to include the
    ///               "com.apple.developer.nfc.readersession.formats" entitlement and the "com.apple.developer.nfc.readersession.felica.systemcodes"
    ///               key in the application's Info.plist to receive this tag object from the @link NFCTagReaderSessionDelegate @link/ delegate.
    ///               @link NFCReaderErrorSecurityViolation @link/ will be returned from the @link NFCTagReaderSessionDelegate @link/ invalidation
    ///               method if the required entitlement is missing or "com.apple.developer.nfc.readersession.felica.systemcodes" does not contain
    ///               at least one valid entry.
    ///               When the reader discovers a FeliCa tag it automatically performs a Polling command using the system code values provided in the
    ///               "com.apple.developer.nfc.readersession.felica.systemcodes" in the specified array order. System code
    ///               specified in the array must not contain a wildcard value (0xFF) in the upper or the lower byte, i.e. full
    ///               matching value is required.  The tag is returned from the [NFCTagReaderSessionDelegate readerSession:didDetectTags:] call
    ///               on the first successful Polling command matching one of the system codes.  Tag will not be returned
    ///               to the NFCTagReaderSessionDelegate if no matching system is found based on entries listed in the Info.plist.
    ///               Tag must be in the connected state for NFCNDEFTag protocol properties and methods to work correctly.
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcfelicatag?language=objc)
    pub unsafe trait NFCFeliCaTag: NFCTag + NFCNDEFTag {
        /// This will match one of the entries in the "com.apple.developer.nfc.readersession.felica.systemcodes"
        /// in the Info.plist.
        #[unsafe(method(currentSystemCode))]
        #[unsafe(method_family = none)]
        unsafe fn currentSystemCode(&self) -> Retained<NSData>;

        /// It will be empty if system selection fails.
        #[unsafe(method(currentIDm))]
        #[unsafe(method_family = none)]
        unsafe fn currentIDm(&self) -> Retained<NSData>;

        #[cfg(feature = "block2")]
        /// Parameter `systemCode`: Designation of System Code.  Wildcard value (0xFF) in the upper or the lower byte is not supported.
        ///
        /// Parameter `requestCode`: Designation of Request Data output.
        ///
        /// Parameter `timeSlot`: Maximum number of slots possible to respond.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if the contactless transceive operation
        /// succeeds, else all other return values shall be ignored.  Non-zero length requestData is return when
        /// requestCode is a non-zero parameter and feature is supported by the tag.  The
        ///
        /// ```text
        ///  currentIDM @link/ property will be updated
        ///                           on each execution, except when an invalid systemCode is provided and the existing selected system will stay selected.
        ///
        ///  @discussion              Polling command defined by FeliCa card specification.  Refer to the FeliCa specification for details.
        ///                           System code must be one of the provided values in the "com.apple.developer.nfc.readersession.felica.systemcodes"
        ///                           in the Info.plist; @link NFCReaderErrorSecurityViolation @link/ will be returned when an invalid system code is used.
        ///                           Polling with wildcard value in the upper or lower byte is not supported.
        ///  
        ///
        /// ```
        #[unsafe(method(pollingWithSystemCode:requestCode:timeSlot:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn pollingWithSystemCode_requestCode_timeSlot_completionHandler(
            &self,
            system_code: &NSData,
            request_code: NFCFeliCaPollingRequestCode,
            time_slot: NFCFeliCaPollingTimeSlot,
            completion_handler: &block2::DynBlock<
                dyn Fn(NonNull<NSData>, NonNull<NSData>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Parameter `nodeCodeList`: Node Code list represented in a NSArray of NSData objects.  Number of nodes specified should be between 1 to 32 inclusive.
        /// Each node code should be 2 bytes stored in Little Endian format.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if the contactless transceive operation succeeds,
        /// else all other return values shall be ignored.  Node key version list is return as NSArray of NSData objects,
        /// and each data object is stored in Little Endian format per FeliCa specification.
        ///
        ///
        /// Request Service command defined by FeliCa card specification.  Refer to the FeliCa specification for details.
        #[unsafe(method(requestServiceWithNodeCodeList:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn requestServiceWithNodeCodeList_completionHandler(
            &self,
            node_code_list: &NSArray<NSData>,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSData>>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if the contactless transceive operation succeeds,
        /// else all other return values shall be ignored.  Valid mode value ranges from 0 to 3 inclusively.
        ///
        ///
        /// Request Response command defined by FeliCa card specification.  Refer to the FeliCa specification for details.
        #[unsafe(method(requestResponseWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn requestResponseWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(NSInteger, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `serviceCodeList`: Service Code list represented in a NSArray of NSData objects.  Number of nodes specified should be between 1 to 16 inclusive.
        /// Each service code should be 2 bytes stored in Little Endian format.
        ///
        /// Parameter `blockList`: Block List represent in a NSArray of NSData objects.  2-Byte or 3-Byte block list element is supported.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if the contactless transceive operation succeeds,
        /// else all other return values shall be ignored.  Valid read data blocks (block length of 16 bytes)
        /// are returned in NSArray of NSData objects when Status Flag 1 equals zero.
        ///
        ///
        /// Read Without Encryption command defined by FeliCa card specification.  Refer to the FeliCa specification for details.
        #[unsafe(method(readWithoutEncryptionWithServiceCodeList:blockList:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn readWithoutEncryptionWithServiceCodeList_blockList_completionHandler(
            &self,
            service_code_list: &NSArray<NSData>,
            block_list: &NSArray<NSData>,
            completion_handler: &block2::DynBlock<
                dyn Fn(NSInteger, NSInteger, NonNull<NSArray<NSData>>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Parameter `serviceCodeList`: Service Code list represented in a NSArray of NSData objects.  Number of nodes specified should be between 1 to 16 inclusive.
        /// Each service code should be 2 bytes stored in Little Endian format.
        ///
        /// Parameter `blockList`: Block List represent in a NSArray of NSData objects.  Total blockList items and blockData items should match.
        /// 2-Byte or 3-Byte block list element is supported.
        ///
        /// Parameter `blockData`: Block data represent in a NSArray of NSData objects.  Total blockList items and blockData items should match.
        /// Data block should be 16 bytes in length.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if the contactless transceive operation succeeds,
        /// else all other return values shall be ignored.
        ///
        ///
        /// Write Without Encryption command defined by FeliCa card specification.  Refer to the FeliCa specification for details.
        #[unsafe(method(writeWithoutEncryptionWithServiceCodeList:blockList:blockData:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn writeWithoutEncryptionWithServiceCodeList_blockList_blockData_completionHandler(
            &self,
            service_code_list: &NSArray<NSData>,
            block_list: &NSArray<NSData>,
            block_data: &NSArray<NSData>,
            completion_handler: &block2::DynBlock<dyn Fn(NSInteger, NSInteger, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if the contactless transceive operation succeeds,
        /// else all other return values shall be ignored.  Each system code is 2 bytes stored in Little Endian format.
        ///
        ///
        /// Request System Code command defined by FeliCa card specification.  Refer to the FeliCa specification for details.
        #[unsafe(method(requestSystemCodeWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn requestSystemCodeWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSArray<NSData>>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `nodeCodeList`: Node Code list represent in a NSArray of NSData.  Number of nodes specified should be between 1 to 32 inclusive.
        /// Each node code should be 2 bytes stored in Little Endian format.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if the contactless transceive operation succeeds,
        /// else all other return values shall be ignored.  encryptionIdentifier value shall be ignored if Status Flag 1 value indicates an error.
        /// nodeKeyVersionListAES and nodeKeyVersionListDES may be empty depending on the Status Flag 1 value and the Encryption Identifier value.
        /// The 2 bytes node key version (AES and DES) is in Little Endian format.
        ///
        ///
        /// Request Service V2 command defined by FeliCa card specification.  Refer to the FeliCa specification for details.
        #[unsafe(method(requestServiceV2WithNodeCodeList:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn requestServiceV2WithNodeCodeList_completionHandler(
            &self,
            node_code_list: &NSArray<NSData>,
            completion_handler: &block2::DynBlock<
                dyn Fn(
                    NSInteger,
                    NSInteger,
                    NFCFeliCaEncryptionId,
                    NonNull<NSArray<NSData>>,
                    NonNull<NSArray<NSData>>,
                    *mut NSError,
                ),
            >,
        );

        #[cfg(feature = "block2")]
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if the contactless transceive operation succeeds,
        /// else all other return values shall be ignored.  basicVersion and optionVersion may be empty depending on the Status Flag 1 value
        /// and if the tag supports AES/DES.
        ///
        ///
        /// Request Specification Version command defined by FeliCa card specification.  This command supports response format version `00`h.
        /// Refer to the FeliCa specification for details.
        #[unsafe(method(requestSpecificationVersionWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn requestSpecificationVersionWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(NSInteger, NSInteger, NonNull<NSData>, NonNull<NSData>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if the contactless transceive operation succeeds,
        /// else all other return values shall be ignored.
        ///
        ///
        /// Reset Mode command defined by FeliCa card specification.  Refer to the FeliCa specification for details.
        #[unsafe(method(resetModeWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn resetModeWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(NSInteger, NSInteger, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `commandPacket`: Command packet send to the FeliCa card.  Maximum packet length is 254.  Data length (LEN) byte and CRC bytes are calculated and inserted
        /// automatically to the provided packet data frame.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.
        ///
        ///  @discussion              Transmission of FeliCa Command Packet Data at the application layer.  Refer to the FeliCa specification for details.
        ///                           Manufacturer ID (IDm) of the currently selected system can be read from the currentIDm property.
        ///  
        ///
        /// ```
        #[unsafe(method(sendFeliCaCommandPacket:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn sendFeliCaCommandPacket_completionHandler(
            &self,
            command_packet: &NSData,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>, *mut NSError)>,
        );
    }
);

extern_class!(
    /// ISO7816 Application Data Unit (APDU).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfciso7816apdu?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCISO7816APDU;
);

extern_conformance!(
    unsafe impl NSCopying for NFCISO7816APDU {}
);

unsafe impl CopyingHelper for NFCISO7816APDU {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCISO7816APDU {}
);

impl NFCISO7816APDU {
    extern_methods!(
        #[unsafe(method(instructionClass))]
        #[unsafe(method_family = none)]
        pub unsafe fn instructionClass(&self) -> u8;

        #[unsafe(method(instructionCode))]
        #[unsafe(method_family = none)]
        pub unsafe fn instructionCode(&self) -> u8;

        #[unsafe(method(p1Parameter))]
        #[unsafe(method_family = none)]
        pub unsafe fn p1Parameter(&self) -> u8;

        #[unsafe(method(p2Parameter))]
        #[unsafe(method_family = none)]
        pub unsafe fn p2Parameter(&self) -> u8;

        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Option<Retained<NSData>>;

        #[unsafe(method(expectedResponseLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectedResponseLength(&self) -> NSInteger;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Parameter `instructionClass`: Instruction class (CLA) byte
        ///
        /// Parameter `instructionCode`: Instruction code (INS) byte
        ///
        /// Parameter `p1Parameter`: P1 parameter byte
        ///
        /// Parameter `p2Parameter`: P2 parameter byte
        ///
        /// Parameter `data`: Data to transmit.  Value of Lc field is set according to the data size.
        ///
        /// Parameter `expectedResponseLength`: Response data length (Le) in bytes. Valid range is from 1 to 65536 inclusively;
        /// -1 means no response data field is expected.  Use 256 if you want to send '00' as the short Le field
        /// assuming the data field is less than 256 bytes.  Use 65536 if you want to send '0000' as the extended
        /// Le field.
        ///
        ///
        /// Generates an ISO7816 APDU object.  The Lc value is generated base on the size of the data object; possible value ranges from
        /// 1 to 65535 inclusively.  Use
        ///
        /// ```text
        ///  -initWithData: @link/ in cases where a finer control on the APDU format is required.
        ///  
        ///
        /// ```
        #[unsafe(method(initWithInstructionClass:instructionCode:p1Parameter:p2Parameter:data:expectedResponseLength:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithInstructionClass_instructionCode_p1Parameter_p2Parameter_data_expectedResponseLength(
            this: Allocated<Self>,
            instruction_class: u8,
            instruction_code: u8,
            p1_parameter: u8,
            p2_parameter: u8,
            data: &NSData,
            expected_response_length: NSInteger,
        ) -> Retained<Self>;

        /// Parameter `data`: Data buffer containing the full APDU.
        ///
        ///
        /// Returns: nil if input data does not contain a valid APDU.
        #[unsafe(method(initWithData:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithData(this: Allocated<Self>, data: &NSData) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCISO7816APDU {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A
    ///
    /// ```text
    ///  NFCTagReaderSession @link/ reader session returns an instance conforming to this protocol
    ///               when an ISO7816 compatible tag is detected.  Unless it is specified all block completion handlers are dispatched on the
    ///               session work queue that is associated with the tag.  Your process requires to include the
    ///               "com.apple.developer.nfc.readersession.formats" entitlement and the "com.apple.developer.nfc.readersession.iso7816.select-identifiers"
    ///               key in the application's Info.plist to receive this tag object from the @link NFCTagReaderSessionDelegate @link/ delegate.
    ///               @link NFCReaderErrorSecurityViolation @link/ will be returned from the @link NFCTagReaderSessionDelegate @link/ invalidation
    ///               method if the required entitlement is missing or "com.apple.developer.nfc.readersession.iso7816.select-identifiers" does not contain
    ///               at least one valid entry.
    ///               When the reader discovered a compatible ISO7816 tag it automatically performs a SELECT command (by DF name) using the values provided in
    ///               "com.apple.developer.nfc.readersession.iso7816.select-identifiers" in the specified array order.  The tag is
    ///               returned from the [NFCTagReaderSessionDelegate readerSession:didDetectTags:] call on the first successful SELECT command.
    ///               The initialSelectedAID property returns the application identifier of the selected application.  Tag will not be returned
    ///               to the NFCTagReaderSessionDelegate if no application described in "com.apple.developer.nfc.readersession.iso7816.select-identifiers"
    ///               is found.  Tag must be in the connected state for NFCNDEFTag protocol properties and methods to work correctly.
    ///
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfciso7816tag?language=objc)
    pub unsafe trait NFCISO7816Tag: NFCTag + NFCNDEFTag {
        /// This will match one of the entries in the "com.apple.developer.nfc.readersession.iso7816.select-identifiers"
        /// in the Info.plist.
        #[unsafe(method(initialSelectedAID))]
        #[unsafe(method_family = none)]
        unsafe fn initialSelectedAID(&self) -> Retained<NSString>;

        /// The hardware UID of the tag.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        unsafe fn identifier(&self) -> Retained<NSData>;

        /// The optional historical bytes extracted from the Type A Answer To Select response.
        #[unsafe(method(historicalBytes))]
        #[unsafe(method_family = none)]
        unsafe fn historicalBytes(&self) -> Option<Retained<NSData>>;

        /// The optional Application Data bytes extracted from the Type B Answer To Request response.
        #[unsafe(method(applicationData))]
        #[unsafe(method_family = none)]
        unsafe fn applicationData(&self) -> Option<Retained<NSData>>;

        /// Indicates if
        ///
        /// ```text
        ///  applicationData @link/ follows proprietary data coding.  If false, the format of the application data is
        ///              defined in the ISO14443-3 specification.
        ///  
        ///
        /// ```
        #[unsafe(method(proprietaryApplicationDataCoding))]
        #[unsafe(method_family = none)]
        unsafe fn proprietaryApplicationDataCoding(&self) -> bool;

        #[cfg(feature = "block2")]
        /// Parameter `apdu`: The command APDU object
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag.  responseData may be
        ///                           empty.  Command processing status bytes (SW1-SW2) are always valid.
        ///
        ///  @discussion  Send a command APDU to the tag and receives a response APDU.  Note that a SELECT command with a P1 value of 0x04 (selection by DF name)
        ///               will be checked against the values listed in the "com.apple.developer.nfc.readersession.iso7816.select-identifiers" in the Info.plist.
        ///               Selecting an application outside of the permissible list will result in a NFCReaderErrorSecurityViolation error.
        ///  
        ///
        /// ```
        #[unsafe(method(sendCommandAPDU:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn sendCommandAPDU_completionHandler(
            &self,
            apdu: &NFCISO7816APDU,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>, u8, u8, *mut NSError)>,
        );
    }
);

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcmifarefamily?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCMiFareFamily(pub NSUInteger);
impl NFCMiFareFamily {
    #[doc(alias = "NFCMiFareUnknown")]
    pub const Unknown: Self = Self(1);
    #[doc(alias = "NFCMiFareUltralight")]
    pub const Ultralight: Self = Self(2);
    #[doc(alias = "NFCMiFarePlus")]
    pub const Plus: Self = Self(3);
    #[doc(alias = "NFCMiFareDESFire")]
    pub const DESFire: Self = Self(4);
}

unsafe impl Encode for NFCMiFareFamily {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NFCMiFareFamily {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// A
    ///
    /// ```text
    ///  NFCTagReaderSession @link/ reader session returns an instance conforming to this protocol when a MiFare tag is detected.  Unless it is specified
    ///               all block completion handlers are dispatched on the session work queue that is associated with the tag.  Your process requires to include the
    ///               "com.apple.developer.nfc.readersession.formats" entitlement to receive this tag object from the @link NFCTagReaderSessionDelegate @link/ delegate.
    ///               Tag must be in the connected state for NFCNDEFTag protocol properties and methods to work correctly.
    ///               @link NFCReaderErrorSecurityViolation @link/ will be returned from the @link NFCTagReaderSessionDelegate @link/ invalidation method if the required entitlement
    ///               is missing when session is started.
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcmifaretag?language=objc)
    pub unsafe trait NFCMiFareTag: NFCTag + NFCNDEFTag {
        #[unsafe(method(mifareFamily))]
        #[unsafe(method_family = none)]
        unsafe fn mifareFamily(&self) -> NFCMiFareFamily;

        /// The hardware UID of the tag.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        unsafe fn identifier(&self) -> Retained<NSData>;

        /// The optional historical bytes extracted from the Answer To Select response.
        #[unsafe(method(historicalBytes))]
        #[unsafe(method_family = none)]
        unsafe fn historicalBytes(&self) -> Option<Retained<NSData>>;

        #[cfg(feature = "block2")]
        /// Parameter `command`: The complete MiFare command.  CRC bytes are calculated and inserted automatically to the provided packet data frame.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds. A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error
        ///                           is returned when there is a communication issue with the tag. Successfully read data blocks will be returned from the NSData object.
        ///
        ///  @discussion              Send native MIFARE command to a tag.  Support MIFARE UltraLight, Plus, and DESFire products.
        ///                           Crypto1 protocol is not supported.  Command chaining is handled internally by the method and the full response composed of the
        ///                           individual fragment is returned in the completion handler.
        ///  
        ///
        /// ```
        #[unsafe(method(sendMiFareCommand:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn sendMiFareCommand_completionHandler(
            &self,
            command: &NSData,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Parameter `apdu`: The ISO7816-4 command APDU object.
        ///
        /// Parameter `completionHandler`: Completion handler called when the operation is completed.  error is nil if operation succeeds.
        /// A
        ///
        /// ```text
        ///  NFCErrorDomain @link/ error is returned when there is a communication issue with the tag or tag does not support ISO7816-4 commands,
        ///                           and all other parameters should be ignore.
        ///
        ///  @discussion  Send a ISO7816 command APDU to the tag and receives a response APDU.  Only available when @link mifareFamily @link/ returns NFCMiFarePlus, NFCMiFareDESFire.
        ///  
        ///
        /// ```
        #[unsafe(method(sendMiFareISO7816Command:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn sendMiFareISO7816Command_completionHandler(
            &self,
            apdu: &NFCISO7816APDU,
            completion_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>, u8, u8, *mut NSError)>,
        );
    }
);

/// Type Name Format value defined by NFC Data Exchange Format (NDEF) Technical Specification
/// from NFC Forum.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfctypenameformat?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCTypeNameFormat(pub u8);
impl NFCTypeNameFormat {
    #[doc(alias = "NFCTypeNameFormatEmpty")]
    pub const Empty: Self = Self(0x00);
    #[doc(alias = "NFCTypeNameFormatNFCWellKnown")]
    pub const NFCWellKnown: Self = Self(0x01);
    #[doc(alias = "NFCTypeNameFormatMedia")]
    pub const Media: Self = Self(0x02);
    #[doc(alias = "NFCTypeNameFormatAbsoluteURI")]
    pub const AbsoluteURI: Self = Self(0x03);
    #[doc(alias = "NFCTypeNameFormatNFCExternal")]
    pub const NFCExternal: Self = Self(0x04);
    #[doc(alias = "NFCTypeNameFormatUnknown")]
    pub const Unknown: Self = Self(0x05);
    #[doc(alias = "NFCTypeNameFormatUnchanged")]
    pub const Unchanged: Self = Self(0x06);
}

unsafe impl Encode for NFCTypeNameFormat {
    const ENCODING: Encoding = u8::ENCODING;
}

unsafe impl RefEncode for NFCTypeNameFormat {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A NDEF message payload consists of Type Name Format, Type, Payload Identifier, and Payload data.
    /// The NDEF payload cannot result into a record that is greater than 128KB in size.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcndefpayload?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCNDEFPayload;
);

extern_conformance!(
    unsafe impl NSCoding for NFCNDEFPayload {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCNDEFPayload {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NFCNDEFPayload {}
);

impl NFCNDEFPayload {
    extern_methods!(
        #[unsafe(method(typeNameFormat))]
        #[unsafe(method_family = none)]
        pub unsafe fn typeNameFormat(&self) -> NFCTypeNameFormat;

        /// Setter for [`typeNameFormat`][Self::typeNameFormat].
        #[unsafe(method(setTypeNameFormat:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTypeNameFormat(&self, type_name_format: NFCTypeNameFormat);

        #[unsafe(method(type))]
        #[unsafe(method_family = none)]
        pub unsafe fn r#type(&self) -> Retained<NSData>;

        /// Setter for [`type`][Self::type].
        #[unsafe(method(setType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setType(&self, r#type: &NSData);

        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSData>;

        /// Setter for [`identifier`][Self::identifier].
        #[unsafe(method(setIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentifier(&self, identifier: &NSData);

        #[unsafe(method(payload))]
        #[unsafe(method_family = none)]
        pub unsafe fn payload(&self) -> Retained<NSData>;

        /// Setter for [`payload`][Self::payload].
        #[unsafe(method(setPayload:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPayload(&self, payload: &NSData);

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Parameter `format`: NFCTypeNameFormat value.
        ///
        /// Parameter `type`: Identifier describing the type of the payload.  Empty data indicates field is absent from the payload.
        ///
        /// Parameter `identifier`: Identifier in the form of a URI reference.  Empty data indicates field is absent from the payload.
        ///
        /// Parameter `payload`: Payload data.  Empty data indicates field is absent from the payload.
        ///
        /// This initializer uses the maximum payload chunk size defined by the NFC NDEF specification, i.e. 2^32-1 octets.
        #[unsafe(method(initWithFormat:type:identifier:payload:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithFormat_type_identifier_payload(
            this: Allocated<Self>,
            format: NFCTypeNameFormat,
            r#type: &NSData,
            identifier: &NSData,
            payload: &NSData,
        ) -> Retained<Self>;

        /// Parameter `format`: NFCTypeNameFormat value.
        ///
        /// Parameter `type`: Identifier describing the type of the payload.  Empty data indicates field is absent from the payload.
        ///
        /// Parameter `identifier`: Identifier in the form of a URI reference.  Empty data indicates field is absent from the payload.
        ///
        /// Parameter `payload`: Payload data.  Empty data indicates field is absent from the payload.
        ///
        /// Parameter `chunkSize`: Maximum size of a payload chunk.  0 means no chunking on the payload, i.e. payload is fit in a single record.
        #[unsafe(method(initWithFormat:type:identifier:payload:chunkSize:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithFormat_type_identifier_payload_chunkSize(
            this: Allocated<Self>,
            format: NFCTypeNameFormat,
            r#type: &NSData,
            identifier: &NSData,
            payload: &NSData,
            chunk_size: usize,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCNDEFPayload {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// ConvenienceHelpers.
impl NFCNDEFPayload {
    extern_methods!(
        /// Parameter `uri`: URI string.  UTF-8 encoding representation will be used.
        ///
        ///
        /// Used for creating NDEF URI payloads which cannot be represented with NSURL object.  These are URIs that contain characters
        /// such as 'ä' and 'ö' which cannot be represent by the 7 bits ASCII encoding.
        #[unsafe(method(wellKnownTypeURIPayloadWithString:))]
        #[unsafe(method_family = none)]
        pub unsafe fn wellKnownTypeURIPayloadWithString(uri: &NSString) -> Option<Retained<Self>>;

        /// Parameter `url`: NSURL object.
        ///
        ///
        /// Preferred convenience function for creating NDEF URI payload with common URLs such as "https://www.apple.com" or "tel:+1-555-555-5555".
        #[unsafe(method(wellKnownTypeURIPayloadWithURL:))]
        #[unsafe(method_family = none)]
        pub unsafe fn wellKnownTypeURIPayloadWithURL(url: &NSURL) -> Option<Retained<Self>>;

        /// Parameter `text`: Text message.
        ///
        /// Parameter `locale`: NSLocale object.  IANA language code specified by the locale will be saved with the payload.
        #[unsafe(method(wellKnownTypeTextPayloadWithString:locale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn wellKnownTypeTextPayloadWithString_locale(
            text: &NSString,
            locale: &NSLocale,
        ) -> Option<Retained<Self>>;

        #[deprecated]
        #[unsafe(method(wellKnowTypeTextPayloadWithString:locale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn wellKnowTypeTextPayloadWithString_locale(
            text: &NSString,
            locale: &NSLocale,
        ) -> Option<Retained<Self>>;

        /// Returns: NSURL object base on a valid Well Known Type URI payload. nil if payload is not a URI.
        #[unsafe(method(wellKnownTypeURIPayload))]
        #[unsafe(method_family = none)]
        pub unsafe fn wellKnownTypeURIPayload(&self) -> Option<Retained<NSURL>>;

        /// Parameter `locale`: Returns NSLocale object that is constructed from the IANA language code stored with the text payload.
        ///
        /// Returns: NSString object base on a valid Well Known Type Text payload.  nil if payload is not a text.
        #[unsafe(method(wellKnownTypeTextPayloadWithLocale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn wellKnownTypeTextPayloadWithLocale(
            &self,
            locale: &mut Option<Retained<NSLocale>>,
        ) -> Option<Retained<NSString>>;
    );
}

extern_class!(
    /// A NDEF message consists of payload records.  The maximum size of the NDEF message is limited to 128KB.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcndefmessage?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCNDEFMessage;
);

extern_conformance!(
    unsafe impl NSCoding for NFCNDEFMessage {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCNDEFMessage {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for NFCNDEFMessage {}
);

impl NFCNDEFMessage {
    extern_methods!(
        /// Array of NFCNDEFPayload records contained in this message.
        #[unsafe(method(records))]
        #[unsafe(method_family = none)]
        pub unsafe fn records(&self) -> Retained<NSArray<NFCNDEFPayload>>;

        /// Setter for [`records`][Self::records].
        #[unsafe(method(setRecords:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRecords(&self, records: &NSArray<NFCNDEFPayload>);

        /// Length of the resulting NDEF message in bytes as it would be stored on a NFC tag.
        #[unsafe(method(length))]
        #[unsafe(method_family = none)]
        pub unsafe fn length(&self) -> NSUInteger;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Parameter `records`: NSArray of NFCNDEFPayload object.  An empty array will create an empty NDEF message.
        #[unsafe(method(initWithNDEFRecords:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithNDEFRecords(
            this: Allocated<Self>,
            records: &NSArray<NFCNDEFPayload>,
        ) -> Retained<Self>;

        /// Parameter `data`: NSData storing raw bytes of a complete NDEF message.  The data content will be validated; all NDEF payloads must
        /// be valid according to the NFC Forum NDEF RTD specification and it shall only contain a single NDEF message.
        #[unsafe(method(ndefMessageWithData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn ndefMessageWithData(data: &NSData) -> Option<Retained<Self>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCNDEFMessage {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcvasmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCVASMode(pub NSInteger);
impl NFCVASMode {
    #[doc(alias = "NFCVASModeURLOnly")]
    pub const URLOnly: Self = Self(0);
    #[doc(alias = "NFCVASModeNormal")]
    pub const Normal: Self = Self(1);
    #[deprecated]
    pub const VASModeURLOnly: Self = Self(NFCVASMode::URLOnly.0);
    #[deprecated]
    pub const VASModeNormal: Self = Self(NFCVASMode::Normal.0);
}

unsafe impl Encode for NFCVASMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NFCVASMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/vasmode?language=objc)
pub type VASMode = NFCVASMode;

extern_class!(
    /// Configuration for one GET VAS DATA command.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcvascommandconfiguration?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCVASCommandConfiguration;
);

extern_conformance!(
    unsafe impl NSCopying for NFCVASCommandConfiguration {}
);

unsafe impl CopyingHelper for NFCVASCommandConfiguration {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCVASCommandConfiguration {}
);

impl NFCVASCommandConfiguration {
    extern_methods!(
        /// VAS protocol mode.
        #[unsafe(method(mode))]
        #[unsafe(method_family = none)]
        pub unsafe fn mode(&self) -> NFCVASMode;

        /// Setter for [`mode`][Self::mode].
        #[unsafe(method(setMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMode(&self, mode: NFCVASMode);

        /// Wallet Pass Type Identifier of the Wallet Pass.  The string value will be used to calculate the
        /// Merchant ID value for the GET VAS DATA command.
        #[unsafe(method(passTypeIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn passTypeIdentifier(&self) -> Retained<NSString>;

        /// Setter for [`passTypeIdentifier`][Self::passTypeIdentifier].
        #[unsafe(method(setPassTypeIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPassTypeIdentifier(&self, pass_type_identifier: &NSString);

        /// Merchant URL object.  Maximum length of the URL is 64 characters, including the schema.
        /// Set to nil to disable the merchant URL.
        #[unsafe(method(url))]
        #[unsafe(method_family = none)]
        pub unsafe fn url(&self) -> Option<Retained<NSURL>>;

        /// Setter for [`url`][Self::url].
        #[unsafe(method(setUrl:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUrl(&self, url: Option<&NSURL>);

        /// Parameter `mode`: VAS operation mode
        ///
        /// Parameter `passTypeIdentifier`: Pass type identifier of the Wallet pass.
        ///
        /// Parameter `url`: URL for VAR URL Only mode.  Set to
        /// <i>
        /// nil
        /// </i>
        /// for VAS normal mode.
        #[unsafe(method(initWithVASMode:passTypeIdentifier:url:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithVASMode_passTypeIdentifier_url(
            this: Allocated<Self>,
            mode: NFCVASMode,
            pass_type_identifier: &NSString,
            url: Option<&NSURL>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCVASCommandConfiguration {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Response APDU status word.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcvaserrorcode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NFCVASErrorCode(pub NSInteger);
impl NFCVASErrorCode {
    #[doc(alias = "NFCVASErrorCodeSuccess")]
    pub const Success: Self = Self(0x9000);
    #[doc(alias = "NFCVASErrorCodeDataNotFound")]
    pub const DataNotFound: Self = Self(0x6A83);
    #[doc(alias = "NFCVASErrorCodeDataNotActivated")]
    pub const DataNotActivated: Self = Self(0x6287);
    #[doc(alias = "NFCVASErrorCodeWrongParameters")]
    pub const WrongParameters: Self = Self(0x6B00);
    #[doc(alias = "NFCVASErrorCodeWrongLCField")]
    pub const WrongLCField: Self = Self(0x6700);
    #[doc(alias = "NFCVASErrorCodeUserIntervention")]
    pub const UserIntervention: Self = Self(0x6984);
    #[doc(alias = "NFCVASErrorCodeIncorrectData")]
    pub const IncorrectData: Self = Self(0x6A80);
    #[doc(alias = "NFCVASErrorCodeUnsupportedApplicationVersion")]
    pub const UnsupportedApplicationVersion: Self = Self(0x6340);
    #[deprecated]
    pub const VASErrorCodeSuccess: Self = Self(NFCVASErrorCode::Success.0);
    #[deprecated]
    pub const VASErrorCodeDataNotFound: Self = Self(NFCVASErrorCode::DataNotFound.0);
    #[deprecated]
    pub const VASErrorCodeDataNotActivated: Self = Self(NFCVASErrorCode::DataNotActivated.0);
    #[deprecated]
    pub const VASErrorCodeWrongParameters: Self = Self(NFCVASErrorCode::WrongParameters.0);
    #[deprecated]
    pub const VASErrorCodeWrongLCField: Self = Self(NFCVASErrorCode::WrongLCField.0);
    #[deprecated]
    pub const VASErrorCodeUserIntervention: Self = Self(NFCVASErrorCode::UserIntervention.0);
    #[deprecated]
    pub const VASErrorCodeIncorrectData: Self = Self(NFCVASErrorCode::IncorrectData.0);
    #[deprecated]
    pub const VASErrorCodeUnsupportedApplicationVersion: Self =
        Self(NFCVASErrorCode::UnsupportedApplicationVersion.0);
}

unsafe impl Encode for NFCVASErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NFCVASErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/corenfc/vaserrorcode?language=objc)
pub type VASErrorCode = NFCVASErrorCode;

extern_class!(
    /// Response from one GET VAS DATA command.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcvasresponse?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCVASResponse;
);

extern_conformance!(
    unsafe impl NSCopying for NFCVASResponse {}
);

unsafe impl CopyingHelper for NFCVASResponse {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCVASResponse {}
);

impl NFCVASResponse {
    extern_methods!(
        /// Response APDU status.
        #[unsafe(method(status))]
        #[unsafe(method_family = none)]
        pub unsafe fn status(&self) -> NFCVASErrorCode;

        /// VAS data.
        #[unsafe(method(vasData))]
        #[unsafe(method_family = none)]
        pub unsafe fn vasData(&self) -> Retained<NSData>;

        /// Mobile token value.
        #[unsafe(method(mobileToken))]
        #[unsafe(method_family = none)]
        pub unsafe fn mobileToken(&self) -> Retained<NSData>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCVASResponse {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Value Added Service (VAS) reader session callbacks.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcvasreadersessiondelegate?language=objc)
    pub unsafe trait NFCVASReaderSessionDelegate: NSObjectProtocol {
        /// Parameter `session`: The session object in the active state.
        ///
        ///
        /// Gets called when the NFC reader session has become active. RF is enabled and reader is scanning for VAS tags.
        /// The
        ///
        /// ```text
        ///  readerSession:didReceiveVASResponses: @link/ will be called when a VAS transaction is completed.
        ///  
        ///
        /// ```
        #[optional]
        #[unsafe(method(readerSessionDidBecomeActive:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSessionDidBecomeActive(&self, session: &NFCVASReaderSession);

        /// Parameter `session`: The session object that is invalidated.
        ///
        /// Parameter `error`: The error indicates the invalidation reason.
        ///
        ///
        /// Gets called when a session becomes invalid.  At this point the client is expected to discard
        /// the returned session object.
        #[unsafe(method(readerSession:didInvalidateWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSession_didInvalidateWithError(
            &self,
            session: &NFCVASReaderSession,
            error: &NSError,
        );

        /// Parameter `session`: The session object used for tag detection.
        ///
        /// Parameter `responses`: Array of
        ///
        /// ```text
        ///  NFCVASResponse @link/ objects.  The order of the response objects follows the
        ///                   sequence of GET VAS DATA sent by the reader session.
        ///
        ///  @discussion      Gets called when the reader completes the requested VAS transaction.  Polling
        ///                   is automatically restarted once the detected tag is removed from the reader's read range.
        ///  
        ///
        /// ```
        #[unsafe(method(readerSession:didReceiveVASResponses:))]
        #[unsafe(method_family = none)]
        unsafe fn readerSession_didReceiveVASResponses(
            &self,
            session: &NFCVASReaderSession,
            responses: &NSArray<NFCVASResponse>,
        );
    }
);

extern_class!(
    /// Reader session for processing Value Added Service (VAS) tags.  This session requires the "com.apple.developer.nfc.readersession.formats"
    /// entitlement in your process.  In addition your application's Info.plist must contain a non-empty usage description string.
    ///
    /// ```text
    ///  NFCReaderErrorSecurityViolation @link/ will be returned from @link [NFCVASReaderSessionDelegate readerSession:didInvalidateWithError:] @link/
    ///              if the required entitlement is missing when session is started.
    ///
    ///  NOTE:
    ///  Only one NFCReaderSession can be active at any time in the system. Subsequent opened sessions will get queued up and processed by the system in FIFO order.
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcvasreadersession?language=objc)
    #[unsafe(super(NFCReaderSession, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCVASReaderSession;
);

extern_conformance!(
    unsafe impl NFCReaderSessionProtocol for NFCVASReaderSession {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCVASReaderSession {}
);

impl NFCVASReaderSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Parameter `commandConfigurations`: NSArray of NFCVASCommandConfiguration objects.  Each NFCVASCommandConfiguration defines one GET VAS DATA command send to
        /// a compatible tag when discovered.  The order of elements in the array defines the order of the command execution.
        ///
        /// Parameter `delegate`: The session will hold a weak ARC reference to this
        ///
        /// ```text
        ///  NFCVASReaderSessionDelegate @link/ object.
        ///  @param queue     A dispatch queue where NFCVASReaderSessionDelegate delegate callbacks will be dispatched to.  A <i>nil</i> value will
        ///                   cause the creation of a serial dispatch queue internally for the session.  The session object will retain the provided dispatch queue.
        ///
        ///  @return          A new NFCVASReaderSession instance.
        ///
        ///  @discussion      A VAS reader session will automatically scan and detect tag that is compatible with the VAS protocol.  The session will advertise as a
        ///                   VAS App Only terminal.  A modal system UI will present once -beginSession is called to inform the start of the session; the UI sheet
        ///                   is automatically dismissed when the session is invalidated either by the user or by calling -invalidateSession.  The alertMessage property shall be set
        ///                   prior to -beginSession to display a message on the action sheet UI for the tag scanning operation.
        ///
        ///                   The reader session has the following properties:
        ///                   + An opened session has a 60 seconds time limit restriction after -beginSession is called; -readerSession:didInvalidateWithError: will return
        ///                   NFCReaderSessionInvalidationErrorSessionTimeout error when the time limit is reached.
        ///                   + Only 1 active reader session is allowed in the system; -readerSession:didInvalidateWithError: will return NFCReaderSessionInvalidationErrorSystemIsBusy
        ///                   when a new reader session is initiated by -beginSession when there is an active reader session.
        ///                   + -readerSession:didInvalidateWithError: will return NFCReaderSessionInvalidationErrorUserCanceled when user clicks on the done button on the UI.
        ///                   + -readerSession:didInvalidateWithError: will return NFCReaderSessionInvalidationErrorSessionTerminatedUnexpectedly when the client application enters
        ///                   the background state.
        ///                   + -readerSession:didInvalidateWithError: will return NFCReaderErrorUnsupportedFeature when 1) reader mode feature is not available on the hardware,
        ///                   2) client application does not have the required entitlement.
        ///  
        ///
        /// ```
        #[unsafe(method(initWithVASCommandConfigurations:delegate:queue:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithVASCommandConfigurations_delegate_queue(
            this: Allocated<Self>,
            command_configurations: &NSArray<NFCVASCommandConfiguration>,
            delegate: &ProtocolObject<dyn NFCVASReaderSessionDelegate>,
            queue: Option<&DispatchQueue>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCVASReaderSession {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Reader session for processing NFC payment tags supporting the
    ///
    /// ```text
    ///  NFCTagTypeISO7816Compatible @link/ type.
    ///               @link [NFCTagReaderSessionDelegate readerSession:didDetectTags:] @link/ will return a @link NFCISO7816Tag @link /. object.
    ///               This session requires the "com.apple.developer.nfc.readersession.formats" entitlement in your process.
    ///               In addition your application's Info.plist must contain a non-empty usage description string.  @link NFCReaderErrorSecurityViolation @link/ will be
    ///               returned from @link [NFCTagReaderSessionDelegate tagReaderSession:didInvalidateWithError:] @link/ if the required entitlement is missing when session is started.
    ///
    ///               When the reader discovers a compatible ISO7816 tag it automatically performs a SELECT command (by DF name) using the values provided in
    ///               "com.apple.developer.nfc.readersession.iso7816.select-identifiers" in the specified array order.  The tag is
    ///               returned from the [NFCTagReaderSessionDelegate readerSession:didDetectTags:] call on the first successful SELECT command.
    ///               The initialSelectedAID property returns the application identifier of the selected application.  Tag will not be returned
    ///               to the NFCTagReaderSessionDelegate if no application described in "com.apple.developer.nfc.readersession.iso7816.select-identifiers"
    ///               is found.
    ///
    ///  NOTE:
    ///  - Only one NFCReaderSession can be active at any time in the system. Subsequent opened sessions will get queued up and processed by the system in FIFO order.
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corenfc/nfcpaymenttagreadersession?language=objc)
    #[unsafe(super(NFCTagReaderSession, NFCReaderSession, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NFCPaymentTagReaderSession;
);

extern_conformance!(
    unsafe impl NFCReaderSessionProtocol for NFCPaymentTagReaderSession {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NFCPaymentTagReaderSession {}
);

impl NFCPaymentTagReaderSession {
    extern_methods!(
        #[cfg(feature = "dispatch2")]
        /// Parameter `delegate`: The session will hold a weak ARC reference to this
        ///
        /// ```text
        ///  NFCTagReaderSessionDelegate @link/ object.
        ///  @param queue         A dispatch queue where NFCTagReaderSessionDelegate delegate callbacks will be dispatched to.  A <i>nil</i> value will
        ///                       cause the creation of a serial dispatch queue internally for the session.  The session object will retain the provided dispatch queue.
        ///
        ///  @return              A new NFCPaymentTagReaderSession instance.
        ///
        ///  NOTE:
        ///  The super class `-initWithPollingOption:delegate:queue:` initializer would only accept NFCPollingOption.NFCPollingISO14443; all other options will be ignored.
        ///  
        ///
        /// ```
        #[unsafe(method(initWithDelegate:queue:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDelegate_queue(
            this: Allocated<Self>,
            delegate: &ProtocolObject<dyn NFCTagReaderSessionDelegate>,
            queue: Option<&DispatchQueue>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NFCTagReaderSession`.
impl NFCPaymentTagReaderSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Parameter `pollingOption`: Configures the RF polling of the reader session; multiple options can be OR'ed together.  This option affects the possible NFC tag type discover.
        ///
        /// Parameter `delegate`: The session will hold a weak ARC reference to this
        ///
        /// ```text
        ///  NFCTagReaderSessionDelegate @link/ object.
        ///  @param queue         A dispatch queue where NFCTagReaderSessionDelegate delegate callbacks will be dispatched to.  A <i>nil</i> value will
        ///                       cause the creation of a serial dispatch queue internally for the session.  The session object will retain the provided dispatch queue.
        ///
        ///  @return              A new NFCTagReaderSession instance.
        ///  
        ///
        /// ```
        #[unsafe(method(initWithPollingOption:delegate:queue:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPollingOption_delegate_queue(
            this: Allocated<Self>,
            polling_option: NFCPollingOption,
            delegate: &ProtocolObject<dyn NFCTagReaderSessionDelegate>,
            queue: Option<&DispatchQueue>,
        ) -> Retained<Self>;
    );
}

/// Methods declared on superclass `NSObject`.
impl NFCPaymentTagReaderSession {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
