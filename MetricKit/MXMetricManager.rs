//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// The task identifier to track launch measurements.
/// Describes the general purpose of a specific launch task.
// NS_TYPED_EXTENSIBLE_ENUM
pub type MXLaunchTaskID = NSString;

extern_class!(
    /// The shared object that registers you to receive metrics, creates logs for custom metrics, and gives access to past reports.
    ///
    /// ## Overview
    ///
    /// The `MXMetricManager` shared object manages your subscription for receiving on-device daily metrics.
    ///
    /// MetricKit starts accumulating reports for your app after calling [`sharedManager`](https://developer.apple.com/documentation/metrickit/mxmetricmanager/shared) for the first time. To receive the reports, call [`addSubscriber:`](https://developer.apple.com/documentation/metrickit/mxmetricmanager/add(_:)) with an object that adopts the [`MXMetricManagerSubscriber`](https://developer.apple.com/documentation/metrickit/mxmetricmanagersubscriber) protocol. The system then delivers metric reports at most once per day, and diagnostic reports immediately in iOS 15 and later and macOS 12 and later. The reports contain the metrics from the past 24 hours and any previously undelivered daily reports. To pause receiving reports, call [`removeSubscriber:`](https://developer.apple.com/documentation/metrickit/mxmetricmanager/remove(_:)).
    ///
    /// The calls to add a subscriber and for receiving reports are safe to use in performance-sensitive code, such as app launch.
    ///
    /// The snippet below shows a simple class for using MetricKit.
    ///
    /// ```swift
    /// class AppMetrics: NSObject, MXMetricManagerSubscriber {
    ///     func receiveReports() {
    ///        let shared = MXMetricManager.shared
    ///        shared.add(self)
    ///     }
    ///
    ///     func pauseReports() {
    ///        let shared = MXMetricManager.shared
    ///        shared.remove(self)
    ///     }
    ///
    ///     // Receive daily metrics.
    ///     func didReceive(_ payloads: [MXMetricPayload]) {
    ///        // Process metrics.
    ///     }
    ///
    ///     // Receive diagnostics immediately when available.
    ///     func didReceive(_ payloads: [MXDiagnosticPayload]) {
    ///        // Process diagnostics.
    ///     }
    /// }
    ///
    /// ```
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  MetricKit delivers daily metric reports from iOS 13 or later, and macOS 26 or later.
    ///
    ///
    ///
    /// </div>
    ///
    /// An instance of this class can be used to retrieve periodic, aggregated power and performance metrics.
    ///
    /// To receive metrics, clients must acquire a reference to the shared instance of the metric manager and add an eligible MXMetricManagerSubscriber.
    ///
    /// Metrics are not guaranteed to be delivered, but can be expected atleast once per day when conditions permit.
    ///
    /// Subscribers to the metric manager can remove themselves using removeSubscriber:subscriber if they no longer wish to receive metrics.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MXMetricManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MXMetricManager {}
);

impl MXMetricManager {
    extern_methods!(
        #[cfg(feature = "MXMetricPayload")]
        /// A list of past metric payloads received.
        #[unsafe(method(pastPayloads))]
        #[unsafe(method_family = none)]
        pub unsafe fn pastPayloads(&self) -> Retained<NSArray<MXMetricPayload>>;

        #[cfg(feature = "MXDiagnosticPayload")]
        /// A list of past diagnostic payloads received.
        #[unsafe(method(pastDiagnosticPayloads))]
        #[unsafe(method_family = none)]
        pub unsafe fn pastDiagnosticPayloads(&self) -> Retained<NSArray<MXDiagnosticPayload>>;

        /// Singleton instance of MXMetricManager.
        #[unsafe(method(sharedManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedManager() -> Retained<MXMetricManager>;

        /// Adds a subscriber to the metric manager.
        ///
        /// Parameter `subscriber`: An object that conforms to the MXMetricManagerSubscriber protocol.
        ///
        /// Subscribers can receive metric payloads by conforming to the MXMetricManagerSubscriber protocol.
        #[unsafe(method(addSubscriber:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addSubscriber(
            &self,
            subscriber: &ProtocolObject<dyn MXMetricManagerSubscriber>,
        );

        /// Removes a subscriber from the metric manager.
        ///
        /// Parameter `subscriber`: An object that conforms to the MXMetricManagerSubscriber protocol.
        ///
        /// The subscriber indicated, if previously registered, will no longer receive metric payloads.
        #[unsafe(method(removeSubscriber:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeSubscriber(
            &self,
            subscriber: &ProtocolObject<dyn MXMetricManagerSubscriber>,
        );

        /// Start measuring an extended launch task with the given task id.
        ///
        /// This method tracks extra setup tasks required to make the application perceived as fully launched, such as loading up content from the disk or refreshing data from the network, rendering images, etc.
        ///
        /// The first task needs to start before or during
        /// `UISceneDelegate.scene(_:restoreInteractionStateWith:)`or before
        /// `UISceneDelegate.sceneDidBecomeActive(_:)`is called on the first scene to connect. For example, at the time
        /// `UIApplicationDelegate.application(_:didFinishLaunchingWithOptions:)`is called. Other tasks need to start before the last current task is finished, otherwise the extended launch measurement will end.
        ///
        /// The maximum number of tasks is 16.
        ///
        /// This method needs to be called on the main thread.
        ///
        /// Parameter `taskID`: The task identifier. Must be an unique nonnull custom string.
        ///
        /// Parameter `error`: If an error occurs, this will contain a valid
        /// `NSError`object on exit.
        ///
        /// Returns: Returns
        /// `YES`if the measurement started successfully and
        /// `NO`otherwise.
        #[unsafe(method(extendLaunchMeasurementForTaskID:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn extendLaunchMeasurementForTaskID_error(
            task_id: &MXLaunchTaskID,
        ) -> Result<(), Retained<NSError>>;

        /// Signal the end of an extended launch task previously started with
        /// `extendLaunchMeasurementForTaskID:error:`.
        ///
        /// This method needs to be called on the main thread.
        ///
        /// Parameter `taskID`: The task identifier. Must match the task identifier passed to
        /// `extendLaunchMeasurementForTaskID:error:`.
        ///
        /// Parameter `error`: If an error occurs, this will contain a valid
        /// `NSError`object on exit.
        ///
        /// Returns: Returns
        /// `YES`if the measurement for the task finished successfully and
        /// `NO`otherwise.
        #[unsafe(method(finishExtendedLaunchMeasurementForTaskID:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn finishExtendedLaunchMeasurementForTaskID_error(
            task_id: &MXLaunchTaskID,
        ) -> Result<(), Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MXMetricManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A protocol defining a method for receiving a daily metrics report.
    /// A protocol that allows the conforming object to receive metric payloads from the metric manager.
    ///
    /// In order to receive metric payloads, atleast one object must conform to this protocol and be subscribed   to the metric manager.
    ///
    /// Objects which conform to this protocol can be passed to addSubscriber:subscriber and removeSubscriber:subscriber to manage their subscription state.
    pub unsafe trait MXMetricManagerSubscriber: NSObjectProtocol {
        #[cfg(feature = "MXMetricPayload")]
        /// This method is invoked when a new MXMetricPayload has been received.
        ///
        /// Parameter `payloads`: An NSArray of MXMetricPayload objects. This array of payloads contains data from previous usage sessions.
        ///
        /// You can expect for this method to be invoked atleast once per day when the app is running and subscribers are available.
        ///
        /// If no subscribers are available, this method will not be invoked.
        ///
        /// Atleast one subscriber must be available to receive metrics.
        ///
        /// This method is invoked on a background queue.
        #[optional]
        #[unsafe(method(didReceiveMetricPayloads:))]
        #[unsafe(method_family = none)]
        unsafe fn didReceiveMetricPayloads(&self, payloads: &NSArray<MXMetricPayload>);

        #[cfg(feature = "MXDiagnosticPayload")]
        /// This method is invoked when a new MXDiagnosticPayload has been received.
        ///
        /// Parameter `payloads`: An NSArray of MXDiagnosticPayload objects. This array of payloads contains diagnostics from previous usage sessions.
        ///
        /// You can expect for this method to be invoked atleast once per day when the app is running and subscribers are available.
        ///
        /// If no subscribers are available, this method will not be invoked.
        ///
        /// Atleast one subscriber must be available to receive diagnostics.
        ///
        /// This method is invoked on a background queue.
        #[optional]
        #[unsafe(method(didReceiveDiagnosticPayloads:))]
        #[unsafe(method_family = none)]
        unsafe fn didReceiveDiagnosticPayloads(&self, payloads: &NSArray<MXDiagnosticPayload>);
    }
);
