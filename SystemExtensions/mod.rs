// This file has been automatically generated by `objc2`'s `header-translator`.
// DO NOT EDIT

#![allow(unused_imports)]
#![allow(deprecated)]
#![allow(non_snake_case)]
#![allow(non_camel_case_types)]
#![allow(non_upper_case_globals)]
#![allow(missing_docs)]
#![allow(clippy::too_many_arguments)]
#![allow(clippy::type_complexity)]
#![allow(clippy::upper_case_acronyms)]
#![allow(clippy::identity_op)]
#![allow(clippy::missing_safety_doc)]
#![allow(clippy::doc_lazy_continuation)]
#![allow(rustdoc::broken_intra_doc_links)]
#![allow(rustdoc::bare_urls)]
#![allow(rustdoc::invalid_html_tags)]

#[link(name = "SystemExtensions", kind = "framework")]
extern "C" {}

use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// The error domain identifying system extension errors.
    pub static OSSystemExtensionErrorDomain: &'static NSErrorDomain;
}

extern "C" {
    /// A message that tells the user why the app is trying to install a driver extension bundle.
    ///
    /// ## Discussion
    ///
    /// This key is required for all DriverKit extensions and must be in the extension’s `Info.plist` file. Failure to include this key results in an error at activation time. For system extensions that are not DriverKit extensions, use [`NSSystemExtensionUsageDescriptionKey`](https://developer.apple.com/documentation/systemextensions/nssystemextensionusagedescriptionkey) instead.
    ///
    ///
    /// A property of a Driver Extension bundle containing a message that tells
    /// the user why the app is requesting to install it.
    ///
    ///
    /// The 'OSBundleUsageDescription' key is required in your Driver
    /// Extension if your app uses APIs that install them.
    pub static OSBundleUsageDescriptionKey: &'static NSString;
}

extern "C" {
    /// A message that tells the user why the app is trying to install a system extension bundle.
    ///
    /// ## Discussion
    ///
    /// This key is required for all system extensions except DriverKit extensions, and must be in the extension’s `Info.plist` file. Failure to include this key results in an error at activation time. For DriverKit extensions, use [`OSBundleUsageDescriptionKey`](https://developer.apple.com/documentation/systemextensions/osbundleusagedescriptionkey) instead.
    ///
    ///
    /// A property of a System Extension bundle containing a message that tells
    /// the user why the app is requesting to install it.
    ///
    ///
    /// The 'NSSystemExtensionUsageDescription' key is required in your
    /// System Extension if your app uses APIs that install them.
    pub static NSSystemExtensionUsageDescriptionKey: &'static NSString;
}

extern "C" {
    /// An optional property of a System Extension bundle naming the bundle
    /// identifier of a kernel extension (kext) with similar purpose and capabilities.
    ///
    ///
    /// The 'OSRelatedKernelExtension' key is optional. If one is present
    /// and the related kernel extension has the same Team ID and is approved by the
    /// system policy, this System Extension is also approved.
    pub static OSRelatedKernelExtensionKey: &'static NSString;
}

/// Error codes for system extensions.
// NS_ERROR_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OSSystemExtensionErrorCode(pub NSInteger);
impl OSSystemExtensionErrorCode {
    /// An error code that indicates an unknown error occurred.
    #[doc(alias = "OSSystemExtensionErrorUnknown")]
    pub const Unknown: Self = Self(1);
    /// An error code that indicates the system extension lacks a required entitlement.
    ///
    /// ## Discussion
    ///
    /// The app must have the [`System Extension Entitlement`](https://developer.apple.com/documentation/bundleresources/entitlements/com.apple.developer.system-extension.install) to activate or deactivate system extensions.
    ///
    ///
    #[doc(alias = "OSSystemExtensionErrorMissingEntitlement")]
    pub const MissingEntitlement: Self = Self(2);
    /// An error code that indicates the extension’s parent app isn’t in a valid location for activation.
    ///
    /// ## Discussion
    ///
    /// The expected location of a driver extension is in the `Contents/Library/SystemExtensions` directory of a macOS app. The app itself must be in one of the system’s `Applications` directories.
    ///
    ///
    #[doc(alias = "OSSystemExtensionErrorUnsupportedParentBundleLocation")]
    pub const UnsupportedParentBundleLocation: Self = Self(3);
    /// An error code that indicates the manager can’t find the system extension.
    #[doc(alias = "OSSystemExtensionErrorExtensionNotFound")]
    pub const ExtensionNotFound: Self = Self(4);
    /// An error code that indicates the extension identifier is missing.
    ///
    /// ## Discussion
    ///
    /// Make sure that the value in the `Info.plist` file of your DriverKit extension matches the identifier string you passed to the [`activationRequestForExtension:queue:`](https://developer.apple.com/documentation/systemextensions/ossystemextensionrequest/activationrequest(forextensionwithidentifier:queue:)) method.
    ///
    ///
    #[doc(alias = "OSSystemExtensionErrorExtensionMissingIdentifier")]
    pub const ExtensionMissingIdentifier: Self = Self(5);
    /// An error code that indicates the extension identifier duplicates an existing identifier.
    #[doc(alias = "OSSystemExtensionErrorDuplicateExtensionIdentifer")]
    pub const DuplicateExtensionIdentifer: Self = Self(6);
    /// An error code that indicates the extension manager can’t recognize the extension’s category identifier.
    #[doc(alias = "OSSystemExtensionErrorUnknownExtensionCategory")]
    pub const UnknownExtensionCategory: Self = Self(7);
    /// An error code that indicates the extension’s signature is invalid.
    #[doc(alias = "OSSystemExtensionErrorCodeSignatureInvalid")]
    pub const CodeSignatureInvalid: Self = Self(8);
    /// An error code that indicates the manager can’t validate the extension.
    #[doc(alias = "OSSystemExtensionErrorValidationFailed")]
    pub const ValidationFailed: Self = Self(9);
    /// An error code that indicates the system policy prohibits activating the system extension.
    #[doc(alias = "OSSystemExtensionErrorForbiddenBySystemPolicy")]
    pub const ForbiddenBySystemPolicy: Self = Self(10);
    /// An error code that indicates the system extension manager request was canceled.
    #[doc(alias = "OSSystemExtensionErrorRequestCanceled")]
    pub const RequestCanceled: Self = Self(11);
    /// An error code that indicates the system extension request failed because the system already has a pending request for the same identifier.
    #[doc(alias = "OSSystemExtensionErrorRequestSuperseded")]
    pub const RequestSuperseded: Self = Self(12);
    /// An error code that indicates the system was unable to obtain the proper authorization.
    #[doc(alias = "OSSystemExtensionErrorAuthorizationRequired")]
    pub const AuthorizationRequired: Self = Self(13);
}

unsafe impl Encode for OSSystemExtensionErrorCode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for OSSystemExtensionErrorCode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Actions for describing how the extension manager should resolve a version conflict.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OSSystemExtensionReplacementAction(pub NSInteger);
impl OSSystemExtensionReplacementAction {
    /// An action that tells the manager to cancel replacement of a system extension.
    /// Returned by the delegate when it determines that replacing an existing
    /// System Extension should not proceed.
    #[doc(alias = "OSSystemExtensionReplacementActionCancel")]
    pub const Cancel: Self = Self(0);
    /// An action that tells the manager to replace an existing system extension.
    /// Returned by the delegate when it determines that replacing an existing
    /// System Extension is desired.
    #[doc(alias = "OSSystemExtensionReplacementActionReplace")]
    pub const Replace: Self = Self(1);
}

unsafe impl Encode for OSSystemExtensionReplacementAction {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for OSSystemExtensionReplacementAction {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The result of a completed request, possibly including additional information about the extension’s state.
/// Describes additional result feedback after completion of a system extension request
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OSSystemExtensionRequestResult(pub NSInteger);
impl OSSystemExtensionRequestResult {
    /// The request completed successfully.
    /// The request was successfully completed.
    #[doc(alias = "OSSystemExtensionRequestCompleted")]
    pub const Completed: Self = Self(0);
    /// The request requires a restart to complete successfully.
    /// The request will be successfully completed after a reboot.
    #[doc(alias = "OSSystemExtensionRequestWillCompleteAfterReboot")]
    pub const WillCompleteAfterReboot: Self = Self(1);
}

unsafe impl Encode for OSSystemExtensionRequestResult {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for OSSystemExtensionRequestResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A request to activate or deactivate a system extension.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSSystemExtensionRequest;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSSystemExtensionRequest {}
);

impl OSSystemExtensionRequest {
    extern_methods!(
        #[cfg(feature = "dispatch2")]
        /// Creates a request to activate a System Extension.
        ///
        ///
        /// This method creates a new request to activate a System Extension.
        /// Extensions are bundles discovered from the `Contents/Library/SystemExtensions`
        /// directory of the main application bundle.
        ///
        ///
        /// Parameter `identifier`: The bundle identifier of the target extension.
        ///
        ///
        /// Parameter `queue`: The dispatch queue to use when calling delegate methods.
        ///
        ///
        /// Returns: A new extension request.
        ///
        ///
        /// Note: It is expected that an application create and submit an activation
        /// request whenever an extension should be active. Upon submitting an activation
        /// request for an inactive extension, user approval may be required and the
        /// request will not succeed until approval is given.
        ///
        /// If the extension is already active then the request will succeed in short
        /// order without significant delay or user interaction. Activating an new version
        /// of an already active extension will prompt the delegate to resolve the conflict
        /// before proceeding.
        ///
        /// An activation request can be successful but also indicate that a reboot is
        /// required in order for the extension to become active. This can occur when
        /// replacing an existing extension that required a reboot in order to deactivate.
        /// The most recently activated extension will then become active when the system
        /// is next rebooted.
        ///
        /// # Safety
        ///
        /// `queue` possibly has additional threading requirements.
        #[unsafe(method(activationRequestForExtension:queue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn activationRequestForExtension_queue(
            identifier: &NSString,
            queue: &DispatchQueue,
        ) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Creates a request to deactivate a System Extension.
        ///
        ///
        /// This method creates a new request to deactivate a System Extension.
        /// Extensions are discovered from the `Contents/Library/SystemExtensions`
        /// directory of the main application bundle.
        ///
        ///
        /// Parameter `identifier`: The bundle identifier of the target extension.
        ///
        ///
        /// Parameter `queue`: The dispatch queue to use when calling delegate methods.
        ///
        ///
        /// Note: It is possible for an extension to require a reboot before it is fully
        /// deactivated. If a request succeeds and indicates a reboot is required, the
        /// extension may still appear to be operational until that time.
        ///
        /// # Safety
        ///
        /// `queue` possibly has additional threading requirements.
        #[unsafe(method(deactivationRequestForExtension:queue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deactivationRequestForExtension_queue(
            identifier: &NSString,
            queue: &DispatchQueue,
        ) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Creates a request to get information about System Extensions.
        ///
        ///
        /// This method creates a new request to retrieve the properties
        /// of any System Extensions matching the given identifier.
        ///
        ///
        /// Parameter `identifier`: The bundle identifier of the target extension(s).
        ///
        ///
        /// Parameter `queue`: The dispatch queue to use when calling delegate methods.
        ///
        /// # Safety
        ///
        /// `queue` possibly has additional threading requirements.
        #[unsafe(method(propertiesRequestForExtension:queue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn propertiesRequestForExtension_queue(
            identifier: &NSString,
            queue: &DispatchQueue,
        ) -> Retained<Self>;

        /// A delegate to receive updates about the progress of a request
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn OSSystemExtensionRequestDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn OSSystemExtensionRequestDelegate>>,
        );

        /// The bundle identifier of the target extension
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSSystemExtensionRequest {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// Properties that identify a specific version of a system extension.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSSystemExtensionProperties;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSSystemExtensionProperties {}
);

impl OSSystemExtensionProperties {
    extern_methods!(
        /// The file URL locating an indicating the extension bundle these properties
        /// were retreived from.
        #[unsafe(method(URL))]
        #[unsafe(method_family = none)]
        pub unsafe fn URL(&self) -> Retained<NSURL>;

        /// The bundle identifier of the extension (CFBundleIdentifier)
        #[unsafe(method(bundleIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundleIdentifier(&self) -> Retained<NSString>;

        /// The bundle version of the extension (CFBundleVersion)
        #[unsafe(method(bundleVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundleVersion(&self) -> Retained<NSString>;

        /// The bundle short version string of the extension (CFBundleShortVersionString)
        #[unsafe(method(bundleShortVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundleShortVersion(&self) -> Retained<NSString>;

        /// Returns the enabled state of the extension
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Returns whether an extension is waiting for user approval
        #[unsafe(method(isAwaitingUserApproval))]
        #[unsafe(method_family = none)]
        pub unsafe fn isAwaitingUserApproval(&self) -> bool;

        /// Returns if an extension is being uninstalled
        #[unsafe(method(isUninstalling))]
        #[unsafe(method_family = none)]
        pub unsafe fn isUninstalling(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSSystemExtensionProperties {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A type that receives updates about the progress of a request.
    pub unsafe trait OSSystemExtensionRequestDelegate: NSObjectProtocol {
        /// Called when the target extension bundle identifier is already activated.
        ///
        ///
        /// The delegate will receive this callback when an activation request
        /// encounters an existing extension with the same team and bundle identifiers but
        /// with different version identifiers. The delegate must make a decision on
        /// whether or not to replace the existing extension.
        ///
        ///
        /// Parameter `request`: The request that encountered the conflict
        ///
        ///
        /// Parameter `existing`: The NSBundle of the existing extension
        ///
        ///
        /// Parameter `ext`: The NSBundle of the extension matching the bundle identifier of the request
        ///
        ///
        /// Returns: A replacement action indicating the desired outcome of the conflict
        ///
        ///
        /// Note: This method is invoked if the `CFBundleVersion` or `CFBundleShortVersionString`
        /// identifiers of the target and existing extension differ.
        ///
        /// If the local system has System Extension developer mode enabled, this callback
        /// will always fire when an existing extension is found, regardless of version
        /// identifiers.
        ///
        /// Returning OSSystemExtensionReplacementActionAbortRequest will trigger a callback
        /// to `request:didFailWithError:` with the OSSystemExtensionErrorRequestCanceled
        /// error code.
        #[unsafe(method(request:actionForReplacingExtension:withExtension:))]
        #[unsafe(method_family = none)]
        unsafe fn request_actionForReplacingExtension_withExtension(
            &self,
            request: &OSSystemExtensionRequest,
            existing: &OSSystemExtensionProperties,
            ext: &OSSystemExtensionProperties,
        ) -> OSSystemExtensionReplacementAction;

        /// Called when the target extension requires user approval to be activated.
        ///
        ///
        /// Activating an extension may require explicit user approval in order
        /// to proceed. For example, this can occur when the user has never previously
        /// approved this extension. If approval is necessary, this callback will be
        /// triggered and the activation request will remain pending until user approves,
        /// or until the application exits.
        #[unsafe(method(requestNeedsUserApproval:))]
        #[unsafe(method_family = none)]
        unsafe fn requestNeedsUserApproval(&self, request: &OSSystemExtensionRequest);

        /// Called when the target extension request has completed.
        ///
        ///
        /// Successful results can come with additional information regarding
        /// the manner in which they were completed. See the OSSystemExtensionRequestResult
        /// documentation for more information.
        ///
        ///
        /// Parameter `result`: Additional result information from the completed request.
        ///
        ///
        /// Note: If the request completes with the `OSSystemExtensionRequestWillCompleteAfterReboot`
        /// result, then the extension will not be active until after the next reboot. Upon
        /// reboot, a given extension will be in the state dictated by the most recently
        /// processed request.
        #[unsafe(method(request:didFinishWithResult:))]
        #[unsafe(method_family = none)]
        unsafe fn request_didFinishWithResult(
            &self,
            request: &OSSystemExtensionRequest,
            result: OSSystemExtensionRequestResult,
        );

        /// Called when the target extension request failed.
        #[unsafe(method(request:didFailWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn request_didFailWithError(
            &self,
            request: &OSSystemExtensionRequest,
            error: &NSError,
        );

        /// Called request for properties has completed.
        ///
        ///
        /// Parameter `properties`: Returns an array of OSSystemExtensionProperties matching the
        /// requested bundle identifier.
        #[optional]
        #[unsafe(method(request:foundProperties:))]
        #[unsafe(method_family = none)]
        unsafe fn request_foundProperties(
            &self,
            request: &OSSystemExtensionRequest,
            properties: &NSArray<OSSystemExtensionProperties>,
        );
    }
);

extern_class!(
    /// A type that facilitates activation and deactivation of system extensions.
    ///
    /// ## Overview
    ///
    /// Create an instance of [`OSSystemExtensionRequest`](https://developer.apple.com/documentation/systemextensions/ossystemextensionrequest) with the class methods on that type, and submit it to the shared instance of the extension manager with [`submitRequest:`](https://developer.apple.com/documentation/systemextensions/ossystemextensionmanager/submitrequest(_:)). Set the [`delegate`](https://developer.apple.com/documentation/systemextensions/ossystemextensionrequest/delegate) on the request to receive the result of the activation or deactivation. The delegate also receives notifications if the user needs to authorize the extension or if a version conflict occurs.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSSystemExtensionManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OSSystemExtensionManager {}
);

impl OSSystemExtensionManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new(&self) -> Retained<Self>;

        #[unsafe(method(sharedManager))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedManager() -> Retained<OSSystemExtensionManager>;

        /// Submits a System Extension request to the manager.
        ///
        ///
        /// Parameter `request`: The request to process.
        #[unsafe(method(submitRequest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn submitRequest(&self, request: &OSSystemExtensionRequest);
    );
}

/// Methods declared on superclass `NSObject`.
impl OSSystemExtensionManager {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new_class() -> Retained<Self>;
    );
}

extern_class!(
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSSystemExtensionInfo;
);

unsafe impl Send for OSSystemExtensionInfo {}

unsafe impl Sync for OSSystemExtensionInfo {}

extern_conformance!(
    unsafe impl NSObjectProtocol for OSSystemExtensionInfo {}
);

impl OSSystemExtensionInfo {
    extern_methods!(
        /// The bundle identifier of the extension (CFBundleIdentifier)
        #[unsafe(method(bundleIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundleIdentifier(&self) -> Retained<NSString>;

        /// The bundle version of the extension (CFBundleVersion)
        #[unsafe(method(bundleVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundleVersion(&self) -> Retained<NSString>;

        /// The bundle short version string of the extension (CFBundleShortVersionString)
        #[unsafe(method(bundleShortVersion))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundleShortVersion(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSSystemExtensionInfo {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    pub unsafe trait OSSystemExtensionsWorkspaceObserver: NSObjectProtocol {
        /// This delegate method will be called when a system extension has been validated and allowed by the user to run.
        #[optional]
        #[unsafe(method(systemExtensionWillBecomeEnabled:))]
        #[unsafe(method_family = none)]
        unsafe fn systemExtensionWillBecomeEnabled(
            &self,
            system_extension_info: &OSSystemExtensionInfo,
        );

        /// This delegate method will be called when the user disables an already enabled system extension, or when the system extension is first installed and is in the disabled state.
        #[optional]
        #[unsafe(method(systemExtensionWillBecomeDisabled:))]
        #[unsafe(method_family = none)]
        unsafe fn systemExtensionWillBecomeDisabled(
            &self,
            system_extension_info: &OSSystemExtensionInfo,
        );

        /// This delegate method will be called when a system extension is deactivated and is about to get uninstalled. The extension may still be running until the system is rebooted.
        #[optional]
        #[unsafe(method(systemExtensionWillBecomeInactive:))]
        #[unsafe(method_family = none)]
        unsafe fn systemExtensionWillBecomeInactive(
            &self,
            system_extension_info: &OSSystemExtensionInfo,
        );
    }
);

extern_class!(
    ///
    /// ## Overview
    ///
    /// <div class="warning">
    ///
    /// ### Note
    /// Using the workspace API requires the system extension entitlement
    ///
    ///
    ///
    /// </div>
    ///
    /// Note: Using the workspace API requires the system extension entitlement
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OSSystemExtensionsWorkspace;
);

unsafe impl Send for OSSystemExtensionsWorkspace {}

unsafe impl Sync for OSSystemExtensionsWorkspace {}

extern_conformance!(
    unsafe impl NSObjectProtocol for OSSystemExtensionsWorkspace {}
);

impl OSSystemExtensionsWorkspace {
    extern_methods!(
        #[unsafe(method(sharedWorkspace))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedWorkspace() -> Retained<OSSystemExtensionsWorkspace>;

        /// Start observing changes to System Extension(s) which are enabled or ready to be enabled.
        #[unsafe(method(addObserver:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn addObserver_error(
            &self,
            observer: &ProtocolObject<dyn OSSystemExtensionsWorkspaceObserver>,
        ) -> Result<(), Retained<NSError>>;

        /// Stop observing changes to System Extension(s).
        #[unsafe(method(removeObserver:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeObserver(
            &self,
            observer: &ProtocolObject<dyn OSSystemExtensionsWorkspaceObserver>,
        );

        /// Get information about system extension(s) in an app with a bundle identifier
        ///
        ///
        /// Parameter `bundleID`: BundleIdentifier of the application containing the system extension(s)
        ///
        /// Parameter `out_error`: Error parameter to be populated with relevant error information
        ///
        ///
        /// Returns: A set of system extension property objects on success, nil otherwise.
        #[unsafe(method(systemExtensionsForApplicationWithBundleID:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn systemExtensionsForApplicationWithBundleID_error(
            &self,
            bundle_id: &NSString,
        ) -> Result<Retained<NSSet<OSSystemExtensionProperties>>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl OSSystemExtensionsWorkspace {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
