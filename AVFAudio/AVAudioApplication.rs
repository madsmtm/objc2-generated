//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// These are the values returned by recordPermission.
///
/// The user has not yet been asked for permission.
///
/// The user has been asked and has denied permission.
///
/// The user has been asked and has granted permission.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfaudio/avaudioapplicationrecordpermission?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVAudioApplicationRecordPermission(pub NSInteger);
impl AVAudioApplicationRecordPermission {
    #[doc(alias = "AVAudioApplicationRecordPermissionUndetermined")]
    pub const Undetermined: Self = Self(0x756e6474);
    #[doc(alias = "AVAudioApplicationRecordPermissionDenied")]
    pub const Denied: Self = Self(0x64656e79);
    #[doc(alias = "AVAudioApplicationRecordPermissionGranted")]
    pub const Granted: Self = Self(0x67726e74);
}

unsafe impl Encode for AVAudioApplicationRecordPermission {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVAudioApplicationRecordPermission {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// These are the values returned by microphoneInjectionPermission.
///
/// The user has disabled this service for all apps.
///
/// The user has not yet been asked for permission.
///
/// The user has been asked and has denied permission.
///
/// The user has been asked and has granted permission.
///
/// Introduced: ios(18.2) visionos(2.2)
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfaudio/avaudioapplicationmicrophoneinjectionpermission?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVAudioApplicationMicrophoneInjectionPermission(pub NSInteger);
impl AVAudioApplicationMicrophoneInjectionPermission {
    #[doc(alias = "AVAudioApplicationMicrophoneInjectionPermissionServiceDisabled")]
    pub const ServiceDisabled: Self = Self(0x73726473);
    #[doc(alias = "AVAudioApplicationMicrophoneInjectionPermissionUndetermined")]
    pub const Undetermined: Self = Self(0x756e6474);
    #[doc(alias = "AVAudioApplicationMicrophoneInjectionPermissionDenied")]
    pub const Denied: Self = Self(0x64656e79);
    #[doc(alias = "AVAudioApplicationMicrophoneInjectionPermissionGranted")]
    pub const Granted: Self = Self(0x67726e74);
}

unsafe impl Encode for AVAudioApplicationMicrophoneInjectionPermission {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for AVAudioApplicationMicrophoneInjectionPermission {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// Notification sent to registered listeners when the application's input is muted
    /// or unmuted.
    ///
    /// Check the notification's userInfo dictionary for the mute state `AVAudioApplicationMuteStateKey`
    /// which will have a boolean value 0 for unmuted or value 1 for muted.
    ///
    /// Note: this notification will only be dispatched for state changes when there is an active record session (i.e. record or playAndRecord category).
    /// Setting the `inputMuted` state while the record session is not active is allowed and will be stored, but it will not trigger a notification for the
    /// state change. When the record session subsequently goes active, the `inputMuted` state will be applied, and this notification will be dispatched
    /// with the latest input muted state.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfaudio/avaudioapplicationinputmutestatechangenotification?language=objc)
    pub static AVAudioApplicationInputMuteStateChangeNotification: &'static NSNotificationName;
}

extern "C" {
    /// Keys for AVAudioApplicationInputMuteStateChangeNotification
    /// Value is NSNumber type with boolean value 0 for unmuted or value 1 for muted (samples zeroed out)
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfaudio/avaudioapplicationmutestatekey?language=objc)
    pub static AVAudioApplicationMuteStateKey: &'static NSString;
}

extern_class!(
    /// Class containing methods that relate to an application bundle's audio (i.e. a collection of one or more AVAudioSession instances)
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfaudio/avaudioapplication?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVAudioApplication;
);

unsafe impl Send for AVAudioApplication {}

unsafe impl Sync for AVAudioApplication {}

extern_conformance!(
    unsafe impl NSObjectProtocol for AVAudioApplication {}
);

impl AVAudioApplication {
    extern_methods!(
        /// Returns the singleton instance
        #[unsafe(method(sharedInstance))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedInstance() -> Retained<AVAudioApplication>;

        /// See: `sharedInstance`
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Set the muted/unmuted state of the application's audio input. When set true, inputs
        /// (microphone etc.) of all audio clients relating to this application will have their samples zeroed out.
        ///
        /// Note: - this is per-application input muting and doesn't affect the hardware mute state.
        #[unsafe(method(setInputMuted:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInputMuted_error(&self, muted: bool) -> Result<(), Retained<NSError>>;

        /// Get the input muted state - return value is boolean 0 for unmuted or value 1 for muted (input samples zeroed out)
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(isInputMuted))]
        #[unsafe(method_family = none)]
        pub unsafe fn isInputMuted(&self) -> bool;

        #[cfg(feature = "block2")]
        /// Provide a block that implements your app's input (microphone) muting logic (macOS only). The block will be called
        /// whenever the input mute state changes, either due to changing the `AVAudioApplication.inputMute` property on
        /// this API, or due to a Bluetooth audio accessory gesture (certain AirPods / Beats headphones) changing the mute state.
        ///
        ///
        /// Parameter `inputMuteHandler`: block that will be called upon every input mute state change. If the boolean `inputShouldBeMuted`
        /// is true, your block should mute all input/microphone samples until the next time the handler is called. Your block should return
        /// a value of YES if successful, or in exceptional cases return a NO value if the mute action was unsuccesful.
        /// Since the input mute handling logic should happen a single place, subsequent calls to this method will overwrite any previously
        /// registered block with the one provided. A nil value may be provided to cancel the block being called, e.g. at end of call lifecycle.
        ///
        ///
        /// Note: This is available on macOS only - for all other platforms input muting will be handled internally. It is recommended only to
        /// perform your input muting logic within this block, and to perform your UI updates for input mute state changes within the handler
        /// for AVAudioApplicationInputMuteStateChangeNotification. This handler should be set by the process doing the call's audio I/O.
        #[unsafe(method(setInputMuteStateChangeHandler:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInputMuteStateChangeHandler_error(
            &self,
            input_mute_handler: Option<&block2::DynBlock<dyn Fn(Bool) -> Bool>>,
        ) -> Result<(), Retained<NSError>>;

        /// Returns an enum indicating whether the user has granted or denied permission to record, or has
        /// not been asked
        #[unsafe(method(recordPermission))]
        #[unsafe(method_family = none)]
        pub unsafe fn recordPermission(&self) -> AVAudioApplicationRecordPermission;

        #[cfg(feature = "block2")]
        /// Checks to see if calling process has permission to record audio.
        ///
        /// The 'response' block will be called immediately if permission has already been granted or
        /// denied.  Otherwise, it presents a dialog to notify the user and allow them to choose, and calls
        /// the block once the UI has been dismissed.  'granted' indicates whether permission has been
        /// granted. Note that the block may be called in a different thread context.
        #[unsafe(method(requestRecordPermissionWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestRecordPermissionWithCompletionHandler(
            response: &block2::DynBlock<dyn Fn(Bool)>,
        );

        /// Returns an enum indicating whether the user has granted or denied permission to inject audio into input,
        /// or has not been asked
        #[unsafe(method(microphoneInjectionPermission))]
        #[unsafe(method_family = none)]
        pub unsafe fn microphoneInjectionPermission(
            &self,
        ) -> AVAudioApplicationMicrophoneInjectionPermission;

        #[cfg(feature = "block2")]
        /// Checks to see if calling process has permission to inject audio to input stream.
        ///
        /// The 'response' block will be called immediately if permission has already been granted or
        /// denied or if the service is disabled by the user.  Otherwise, it presents a dialog to notify the
        /// user and allow them to choose, and calls the block once the UI has been dismissed.
        /// 'granted' indicates whether permission has been granted. Note that the block may be
        /// called in a different thread context.
        #[unsafe(method(requestMicrophoneInjectionPermissionWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestMicrophoneInjectionPermissionWithCompletionHandler(
            response: &block2::DynBlock<dyn Fn(AVAudioApplicationMicrophoneInjectionPermission)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl AVAudioApplication {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
