//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-audio-types")]
use objc2_core_audio_types::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;

use crate::*;

/// A format other than one of the common ones below.
///
/// Native-endian floats (this is the standard format).
///
/// Native-endian doubles.
///
/// Signed 16-bit native-endian integers.
///
/// Signed 32-bit native-endian integers.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/avfaudio/avaudiocommonformat?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct AVAudioCommonFormat(pub NSUInteger);
impl AVAudioCommonFormat {
    #[doc(alias = "AVAudioOtherFormat")]
    pub const OtherFormat: Self = Self(0);
    #[doc(alias = "AVAudioPCMFormatFloat32")]
    pub const PCMFormatFloat32: Self = Self(1);
    #[doc(alias = "AVAudioPCMFormatFloat64")]
    pub const PCMFormatFloat64: Self = Self(2);
    #[doc(alias = "AVAudioPCMFormatInt16")]
    pub const PCMFormatInt16: Self = Self(3);
    #[doc(alias = "AVAudioPCMFormatInt32")]
    pub const PCMFormatInt32: Self = Self(4);
}

unsafe impl Encode for AVAudioCommonFormat {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for AVAudioCommonFormat {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A representation of an audio format.
    ///
    /// AVAudioFormat wraps a Core Audio AudioStreamBasicDescription struct, with convenience
    /// initializers and accessors for common formats, including Core Audio's standard deinterleaved
    /// 32-bit floating point.
    ///
    /// Instances of this class are immutable.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/avfaudio/avaudioformat?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct AVAudioFormat;
);

unsafe impl Send for AVAudioFormat {}

unsafe impl Sync for AVAudioFormat {}

extern_conformance!(
    unsafe impl NSCoding for AVAudioFormat {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for AVAudioFormat {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for AVAudioFormat {}
);

impl AVAudioFormat {
    extern_methods!(
        #[cfg(feature = "objc2-core-audio-types")]
        /// Initialize from an AudioStreamBasicDescription.
        ///
        /// Parameter `asbd`: the AudioStreamBasicDescription
        ///
        /// If the format specifies more than 2 channels, this method fails (returns nil).
        ///
        /// # Safety
        ///
        /// `asbd` must be a valid pointer.
        #[unsafe(method(initWithStreamDescription:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithStreamDescription(
            this: Allocated<Self>,
            asbd: NonNull<AudioStreamBasicDescription>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "AVAudioChannelLayout", feature = "objc2-core-audio-types"))]
        /// Initialize from an AudioStreamBasicDescription and optional channel layout.
        ///
        /// Parameter `asbd`: the AudioStreamBasicDescription
        ///
        /// Parameter `layout`: the channel layout. Can be nil only if asbd specifies 1 or 2 channels.
        ///
        /// If the format specifies more than 2 channels, this method fails (returns nil) unless layout
        /// is non-nil.
        ///
        /// # Safety
        ///
        /// `asbd` must be a valid pointer.
        #[unsafe(method(initWithStreamDescription:channelLayout:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithStreamDescription_channelLayout(
            this: Allocated<Self>,
            asbd: NonNull<AudioStreamBasicDescription>,
            layout: Option<&AVAudioChannelLayout>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "AVAudioTypes")]
        /// Initialize to deinterleaved float with the specified sample rate and channel count.
        ///
        /// Parameter `sampleRate`: the sample rate
        ///
        /// Parameter `channels`: the channel count
        ///
        /// If the format specifies more than 2 channels, this method fails (returns nil).
        #[unsafe(method(initStandardFormatWithSampleRate:channels:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initStandardFormatWithSampleRate_channels(
            this: Allocated<Self>,
            sample_rate: c_double,
            channels: AVAudioChannelCount,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "AVAudioChannelLayout")]
        /// Initialize to deinterleaved float with the specified sample rate and channel layout.
        ///
        /// Parameter `sampleRate`: the sample rate
        ///
        /// Parameter `layout`: the channel layout. must not be nil.
        #[unsafe(method(initStandardFormatWithSampleRate:channelLayout:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initStandardFormatWithSampleRate_channelLayout(
            this: Allocated<Self>,
            sample_rate: c_double,
            layout: &AVAudioChannelLayout,
        ) -> Retained<Self>;

        #[cfg(feature = "AVAudioTypes")]
        /// Initialize to float with the specified sample rate, channel count and interleavedness.
        ///
        /// Parameter `format`: the common format type
        ///
        /// Parameter `sampleRate`: the sample rate
        ///
        /// Parameter `channels`: the channel count
        ///
        /// Parameter `interleaved`: true if interleaved
        ///
        /// If the format specifies more than 2 channels, this method fails (returns nil).
        #[unsafe(method(initWithCommonFormat:sampleRate:channels:interleaved:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCommonFormat_sampleRate_channels_interleaved(
            this: Allocated<Self>,
            format: AVAudioCommonFormat,
            sample_rate: c_double,
            channels: AVAudioChannelCount,
            interleaved: bool,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "AVAudioChannelLayout")]
        /// Initialize to float with the specified sample rate, channel layout and interleavedness.
        ///
        /// Parameter `format`: the common format type
        ///
        /// Parameter `sampleRate`: the sample rate
        ///
        /// Parameter `interleaved`: true if interleaved
        ///
        /// Parameter `layout`: the channel layout. must not be nil.
        #[unsafe(method(initWithCommonFormat:sampleRate:interleaved:channelLayout:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCommonFormat_sampleRate_interleaved_channelLayout(
            this: Allocated<Self>,
            format: AVAudioCommonFormat,
            sample_rate: c_double,
            interleaved: bool,
            layout: &AVAudioChannelLayout,
        ) -> Retained<Self>;

        /// Initialize using a settings dictionary.
        ///
        /// See AVAudioSettings.h. Note that many settings dictionary elements pertain to encoder
        /// settings, not the basic format, and will be ignored.
        ///
        /// Returns nil if a format cannot be constructed with the provided settings, e.g. when:
        /// - AVNumberOfChannelsKey specifies more than 2 channels, but AVChannelLayoutKey hasn't
        /// been specified or the layout does not match
        /// - AVLinearPCMBitDepthKey for linear PCM format specifies less than 8 or greater
        /// than 32 bits
        /// - values for the keys are not of the expected types
        ///
        /// # Safety
        ///
        /// `settings` generic should be of the correct type.
        #[unsafe(method(initWithSettings:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSettings(
            this: Allocated<Self>,
            settings: &NSDictionary<NSString, AnyObject>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "objc2-core-media")]
        /// initialize from a CMAudioFormatDescriptionRef.
        ///
        /// Parameter `formatDescription`: the CMAudioFormatDescriptionRef.
        ///
        /// If formatDescription is invalid, this method fails (returns nil).
        #[unsafe(method(initWithCMAudioFormatDescription:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithCMAudioFormatDescription(
            this: Allocated<Self>,
            format_description: &CMAudioFormatDescription,
        ) -> Retained<Self>;

        /// Determine whether another format is functionally equivalent.
        ///
        /// Parameter `object`: the format to compare against
        ///
        /// For PCM, interleavedness is ignored for mono. Differences in the AudioStreamBasicDescription
        /// alignment and packedness are ignored when they are not significant (e.g. with 1 channel, 2
        /// bytes per frame and 16 bits per channel, neither alignment, the format is implicitly packed
        /// and can be interpreted as either high- or low-aligned.)
        /// For AVAudioChannelLayout, a layout with standard mono/stereo tag is considered to be
        /// equivalent to a nil layout. Otherwise, the layouts are compared for equality.
        ///
        /// # Safety
        ///
        /// `object` should be of the correct type.
        #[unsafe(method(isEqual:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEqual(&self, object: &AnyObject) -> bool;

        /// Describes whether the format is deinterleaved native-endian float.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(isStandard))]
        #[unsafe(method_family = none)]
        pub unsafe fn isStandard(&self) -> bool;

        /// An `AVAudioCommonFormat` identifying the format
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(commonFormat))]
        #[unsafe(method_family = none)]
        pub unsafe fn commonFormat(&self) -> AVAudioCommonFormat;

        #[cfg(feature = "AVAudioTypes")]
        /// The number of channels of audio data.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(channelCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn channelCount(&self) -> AVAudioChannelCount;

        /// A sampling rate in Hertz.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(sampleRate))]
        #[unsafe(method_family = none)]
        pub unsafe fn sampleRate(&self) -> c_double;

        /// Describes whether the samples are interleaved.
        ///
        /// For non-PCM formats, the value is undefined.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(isInterleaved))]
        #[unsafe(method_family = none)]
        pub unsafe fn isInterleaved(&self) -> bool;

        #[cfg(feature = "objc2-core-audio-types")]
        /// Returns the AudioStreamBasicDescription, for use with lower-level audio API's.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(streamDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn streamDescription(&self) -> NonNull<AudioStreamBasicDescription>;

        #[cfg(feature = "AVAudioChannelLayout")]
        /// The underlying AVAudioChannelLayout, if any.
        ///
        /// Only formats with more than 2 channels are required to have channel layouts.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(channelLayout))]
        #[unsafe(method_family = none)]
        pub unsafe fn channelLayout(&self) -> Option<Retained<AVAudioChannelLayout>>;

        /// The underlying magic cookie, if any.
        ///
        /// A magic cookie contains metadata associated with encoders and decoders.
        /// Encoders produce a magic cookie, and some decoders require a magic cookie to decode properly.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(magicCookie))]
        #[unsafe(method_family = none)]
        pub unsafe fn magicCookie(&self) -> Option<Retained<NSData>>;

        /// Setter for [`magicCookie`][Self::magicCookie].
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(setMagicCookie:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMagicCookie(&self, magic_cookie: Option<&NSData>);

        /// Returns the format represented as a dictionary with keys from AVAudioSettings.h.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(settings))]
        #[unsafe(method_family = none)]
        pub unsafe fn settings(&self) -> Retained<NSDictionary<NSString, AnyObject>>;

        #[cfg(feature = "objc2-core-media")]
        /// Converts to a CMAudioFormatDescriptionRef, for use with Core Media API's.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(formatDescription))]
        #[unsafe(method_family = none)]
        pub unsafe fn formatDescription(&self) -> Retained<CMAudioFormatDescription>;
    );
}

/// Methods declared on superclass `NSObject`.
impl AVAudioFormat {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
