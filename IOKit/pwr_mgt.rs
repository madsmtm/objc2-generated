//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

pub const kAppleClamshellStateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AppleClamshellState\0") };
pub const kAppleClamshellCausesSleepKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AppleClamshellCausesSleep\0") };
pub const kIOPMSleepWakeUUIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"SleepWakeUUID\0") };
pub const kIOPMBootSessionUUIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BootSessionUUID\0") };
pub const kIOPMDeepSleepEnabledKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Standby Enabled\0") };
pub const kIOPMDeepSleepDelayKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Standby Delay\0") };
pub const kIOPMDeepSleepDelayHighKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"High Standby Delay\0") };
pub const kIOPMStandbyBatteryThresholdKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Standby Battery Threshold\0") };
pub const kIOPMDestroyFVKeyOnStandbyKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DestroyFVKeyOnStandby\0") };
pub const kIOPMResetPowerStateOnWakeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOPMResetPowerStateOnWake\0") };
pub const kIOPMAssertionsDriverKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DriverPMAssertions\0") };
pub const kIOPMAssertionsDriverDetailedKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DriverPMAssertionsDetailed\0") };
pub const kIOPMDriverAssertionIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ID\0") };
pub const kIOPMDriverAssertionCreatedTimeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CreatedTime\0") };
pub const kIOPMDriverAssertionModifiedTimeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ModifiedTime\0") };
pub const kIOPMDriverAssertionOwnerStringKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Owner\0") };
pub const kIOPMDriverAssertionOwnerServiceKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ServicePtr\0") };
pub const kIOPMDriverAssertionRegistryEntryIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"RegistryEntryID\0") };
pub const kIOPMDriverAssertionLevelKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Level\0") };
pub const kIOPMDriverAssertionAssertedKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Assertions\0") };
pub const kIOPMMessageClamshellStateChange: c_uint =
    iokit_family_msg!(sub_iokit_powermanagement, 0x100);
pub const kIOPMMessageFeatureChange: c_uint = iokit_family_msg!(sub_iokit_powermanagement, 0x110);
pub const kIOPMMessageInternalBatteryFullyDischarged: c_uint =
    iokit_family_msg!(sub_iokit_powermanagement, 0x120);
pub const kIOPMMessageSystemPowerEventOccurred: c_uint =
    iokit_family_msg!(sub_iokit_powermanagement, 0x130);
pub const kIOPMMessageSleepWakeUUIDChange: c_uint =
    iokit_family_msg!(sub_iokit_powermanagement, 0x140);
///
/// ## Discussion
///
/// kIOPMMessageDriverAssertionsChanged Sent when kernel PM driver assertions have changed.
///
///
pub const kIOPMMessageDriverAssertionsChanged: c_uint =
    iokit_family_msg!(sub_iokit_powermanagement, 0x150);
///
/// ## Discussion
///
/// kIOPMMessageDarkWakeThermalEmergency Sent when machine becomes unsustainably warm in DarkWake. Kernel PM might choose to put the machine back to sleep right after.
///
///
pub const kIOPMMessageDarkWakeThermalEmergency: c_uint =
    iokit_family_msg!(sub_iokit_powermanagement, 0x160);
pub const kIOPMPSExternalConnectedKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ExternalConnected\0") };
pub const kIOPMPSExternalChargeCapableKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ExternalChargeCapable\0") };
pub const kIOPMPSBatteryInstalledKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BatteryInstalled\0") };
pub const kIOPMPSIsChargingKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IsCharging\0") };
pub const kIOPMFullyChargedKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"FullyCharged\0") };
pub const kIOPMPSAtWarnLevelKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AtWarnLevel\0") };
pub const kIOPMPSAtCriticalLevelKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AtCriticalLevel\0") };
pub const kIOPMPSCurrentCapacityKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CurrentCapacity\0") };
pub const kIOPMPSMaxCapacityKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MaxCapacity\0") };
pub const kIOPMPSDesignCapacityKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DesignCapacity\0") };
pub const kIOPMPSTimeRemainingKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"TimeRemaining\0") };
pub const kIOPMPSAmperageKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Amperage\0") };
pub const kIOPMPSVoltageKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Voltage\0") };
pub const kIOPMPSCycleCountKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CycleCount\0") };
pub const kIOPMPSMaxErrKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"MaxErr\0") };
pub const kIOPMPSAdapterInfoKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AdapterInfo\0") };
pub const kIOPMPSLocationKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Location\0") };
pub const kIOPMPSErrorConditionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ErrorCondition\0") };
pub const kIOPMPSManufacturerKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Manufacturer\0") };
pub const kIOPMPSManufactureDateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ManufactureDate\0") };
pub const kIOPMPSModelKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Model\0") };
pub const kIOPMPSSerialKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Serial\0") };
pub const kIOPMDeviceNameKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DeviceName\0") };
pub const kIOPMPSLegacyBatteryInfoKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"LegacyBatteryInfo\0") };
pub const kIOPMPSBatteryHealthKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BatteryHealth\0") };
pub const kIOPMPSHealthConfidenceKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HealthConfidence\0") };
pub const kIOPMPSCapacityEstimatedKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CapacityEstimated\0") };
pub const kIOPMPSBatteryChargeStatusKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ChargeStatus\0") };
pub const kIOPMPSBatteryTemperatureKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Temperature\0") };
pub const kIOPMPSAdapterDetailsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AdapterDetails\0") };
pub const kIOPMPSChargerConfigurationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ChargerConfiguration\0") };
pub const kIOPMBatteryChargeStatusTooHot: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HighTemperature\0") };
pub const kIOPMBatteryChargeStatusTooCold: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"LowTemperature\0") };
pub const kIOPMBatteryChargeStatusTooHotOrCold: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HighOrLowTemperature\0") };
pub const kIOPMBatteryChargeStatusGradient: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BatteryTemperatureGradient\0") };
pub const kIOPMPSAdapterDetailsIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AdapterID\0") };
pub const kIOPMPSAdapterDetailsWattsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Watts\0") };
pub const kIOPMPSAdapterDetailsRevisionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AdapterRevision\0") };
pub const kIOPMPSAdapterDetailsSerialNumberKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"SerialNumber\0") };
pub const kIOPMPSAdapterDetailsFamilyKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"FamilyCode\0") };
pub const kIOPMPSAdapterDetailsAmperageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Current\0") };
pub const kIOPMPSAdapterDetailsDescriptionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Description\0") };
pub const kIOPMPSAdapterDetailsPMUConfigurationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PMUConfiguration\0") };
pub const kIOPMPSAdapterDetailsVoltage: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AdapterVoltage\0") };
pub const kIOPMPSAdapterDetailsSourceIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Source\0") };
pub const kIOPMPSAdapterDetailsErrorFlagsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ErrorFlags\0") };
pub const kIOPMPSAdapterDetailsSharedSourceKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"SharedSource\0") };
pub const kIOPMPSAdapterDetailsCloakedKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CloakedSource\0") };
pub const kIOPMPSInvalidWakeSecondsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BatteryInvalidWakeSeconds\0") };
pub const kIOPMPSPostChargeWaitSecondsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PostChargeWaitSeconds\0") };
pub const kIOPMPSPostDishargeWaitSecondsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PostDischargeWaitSeconds\0") };
pub const kIOPMGraphicsPowerLimitsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Graphics_Power_Limits\0") };
pub const kIOPMGraphicsPowerLimitPerformanceKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Graphics_Power_Performance\0") };
pub const kIOPMCPUPowerLimitsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CPU_Power_Limits\0") };
pub const kIOPMCPUPowerLimitProcessorSpeedKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CPU_Speed_Limit\0") };
pub const kIOPMCPUPowerLimitProcessorCountKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CPU_Available_CPUs\0") };
pub const kIOPMCPUPowerLimitSchedulerTimeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CPU_Scheduler_Limit\0") };
pub const kIOPMThermalLevelWarningKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Thermal_Level_Warning\0") };
pub const kIOPMThermalWarningLevelNormal: c_uint = kIOPMThermalLevelNormal;
pub const kIOPMThermalWarningLevelDanger: c_uint = kIOPMThermalLevelWarning;
pub const kIOPMThermalWarningLevelCrisis: c_uint = kIOPMThermalLevelCritical;
pub const kIOPMSettingWakeOnRingKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Wake On Modem Ring\0") };
pub const kIOPMSettingRestartOnPowerLossKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Automatic Restart On Power Loss\0") };
pub const kIOPMSettingWakeOnACChangeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Wake On AC Change\0") };
pub const kIOPMSettingSleepOnPowerButtonKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Sleep On Power Button\0") };
pub const kIOPMSettingWakeOnClamshellKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Wake On Clamshell Open\0") };
pub const kIOPMSettingReduceBrightnessKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ReduceBrightness\0") };
pub const kIOPMSettingDisplaySleepUsesDimKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Display Sleep Uses Dim\0") };
pub const kIOPMSettingTimeZoneOffsetKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"TimeZoneOffsetSeconds\0") };
pub const kIOPMSettingMobileMotionModuleKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MobileMotionModule\0") };
pub const kIOPMSettingGraphicsSwitchKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"GPUSwitch\0") };
pub const kIOPMSettingProModeControl: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ProModeControl\0") };
pub const kIOPMSettingProModeDefer: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ProModeDefer\0") };
pub const kIOPMSettingAutoWakeSecondsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"wake\0") };
pub const kIOPMSettingAutoWakeCalendarKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"WakeByCalendarDate\0") };
pub const kIOPMSettingAutoPowerSecondsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"poweron\0") };
pub const kIOPMSettingAutoPowerCalendarKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PowerByCalendarDate\0") };
pub const kIOPMSettingDebugWakeRelativeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"WakeRelativeToSleep\0") };
pub const kIOPMSettingDebugPowerRelativeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PowerRelativeToShutdown\0") };
pub const kIOPMSettingMaintenanceWakeCalendarKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MaintenanceWakeCalendarDate\0") };
pub const kMaxType: c_uint = kPMLastAggressivenessType - 1;
pub const kIOREMSleepEnabledKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"REMSleepEnabled\0") };
pub const kIOBatteryInfoKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOBatteryInfo\0") };
pub const kIOBatteryCurrentChargeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Current\0") };
pub const kIOBatteryCapacityKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Capacity\0") };
pub const kIOBatteryFlagsKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Flags\0") };
pub const kIOBatteryVoltageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Voltage\0") };
pub const kIOBatteryAmperageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Amperage\0") };
pub const kIOBatteryCycleCountKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Cycle Count\0") };
pub const kIOPMMessageBatteryStatusHasChanged: c_uint = iokit_family_msg!(sub_iokit_pmu, 0x100);
pub const kIOPMUMessageLegacyAutoWake: c_uint = iokit_family_msg!(sub_iokit_pmu, 0x200);
pub const kIOPMUMessageLegacyAutoPower: c_uint = iokit_family_msg!(sub_iokit_pmu, 0x210);
/// Value for scheduled wake from sleep.
pub const kIOPMAutoWake: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"wake\0") };
/// Value for scheduled power on from off state.
pub const kIOPMAutoPowerOn: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"poweron\0") };
/// Value for scheduled wake from sleep, or power on. The system will either wake OR power on, whichever is necessary.
pub const kIOPMAutoWakeOrPowerOn: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"wakepoweron\0") };
/// Value for scheduled sleep.
pub const kIOPMAutoSleep: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"sleep\0") };
/// Value for scheduled shutdown.
pub const kIOPMAutoShutdown: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"shutdown\0") };
/// Value for scheduled restart.
pub const kIOPMAutoRestart: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"restart\0") };
/// Key for the time of the scheduled power event. Value is a CFDateRef.
pub const kIOPMPowerEventTimeKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"time\0") };
/// Key for the CFBundleIdentifier of the app that scheduled the power event. Value is a CFStringRef.
pub const kIOPMPowerEventAppNameKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"scheduledby\0") };
pub const kIOPMPowerEventAppPIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"appPID\0") };
/// Key for the type of power event. Value is a CFStringRef, with the c-string value of one of the "kIOPMAuto" strings.
pub const kIOPMPowerEventTypeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"eventtype\0") };
pub const kPMSetAggressiveness: c_uint = 0;
pub const kPMGetAggressiveness: c_uint = 1;
pub const kPMSleepSystem: c_uint = 2;
pub const kPMAllowPowerChange: c_uint = 3;
pub const kPMCancelPowerChange: c_uint = 4;
pub const kPMShutdownSystem: c_uint = 5;
pub const kPMRestartSystem: c_uint = 6;
pub const kPMSleepSystemOptions: c_uint = 7;
pub const kPMSetMaintenanceWakeCalendar: c_uint = 8;
pub const kPMSetUserAssertionLevels: c_uint = 9;
pub const kPMActivityTickle: c_uint = 10;
pub const kPMGetSystemSleepType: c_uint = 11;
pub const kPMSetClamshellSleepState: c_uint = 12;
pub const kPMSleepWakeWatchdogEnable: c_uint = 13;
pub const kPMSleepWakeDebugTrig: c_uint = 14;
pub const kPMSetDisplayPowerOn: c_uint = 15;
pub const kPMSetDisplayState: c_uint = 16;
pub const kPMRequestIdleSleepRevert: c_uint = 17;
pub const kPMSetLDMHibernationDisable: c_uint = 18;
pub const kNumPMMethods: c_uint = 19;
/// The notification by this name fires when system "SystemLoadAdvisory" status changes.
///
/// ## Discussion
///
/// Pass this string as an argument to register via notify(3). You can query SystemLoadAdvisory state via notify_get_state() when this notification fires - this is more efficient than calling IOGetSystemLoadAdvisory(), and returns an identical combined SystemLoadAdvisory value.
///
///
pub const kIOSystemLoadAdvisoryNotifyName: &CStr = unsafe {
    CStr::from_bytes_with_nul_unchecked(b"com.apple.system.powermanagement.SystemLoadAdvisory\0")
};
/// Key to register for BSD style notifications on CPU power or thermal change.
pub const kIOPMCPUPowerNotificationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"com.apple.system.power.CPU\0") };
/// Key to register for BSD style notifications on system thermal warnings.
pub const kIOPMThermalWarningNotificationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"com.apple.system.power.thermal_warning\0") };
pub const kIOPMMaxPowerStates: c_uint = 10;
pub const IOPMMaxPowerStates: c_uint = kIOPMMaxPowerStates;

/// Bits are used in defining capabilityFlags, inputPowerRequirements, and outputPowerCharacter in the IOPMPowerState structure.
///
/// ## Discussion
///
/// These bits may be bitwise-OR'd together in the IOPMPowerState capabilityFlags field, the outputPowerCharacter field, and/or the inputPowerRequirement field.
///
/// The comments clearly mark whether each flag should be used in the capabilityFlags field, outputPowerCharacter field, and inputPowerRequirement field, or all three.
///
/// The value of capabilityFlags, inputPowerRequirement or outputPowerCharacter may be 0. Most drivers implement their 'OFF' state, used when asleep, by defininf each of the 3 fields as 0.
///
/// The bits listed below are only the most common bits used to define a device's power states. Your device's IO family may require that your device specify other input or output power flags to interact properly. Consult family-specific documentation to determine if your IOPower plane parents or children require other power flags; they probably don't.
///
///
/// Bits are used in defining capabilityFlags, inputPowerRequirements, and outputPowerCharacter in the IOPMPowerState structure.
///
/// These bits may be bitwise-OR'd together in the IOPMPowerState capabilityFlags field, the outputPowerCharacter field, and/or the inputPowerRequirement field.
///
/// The comments clearly mark whether each flag should be used in the capabilityFlags field, outputPowerCharacter field, and inputPowerRequirement field, or all three.
///
/// The value of capabilityFlags, inputPowerRequirement or outputPowerCharacter may be 0. Most drivers implement their 'OFF' state, used when asleep, by defininf each of the 3 fields as 0.
///
/// The bits listed below are only the most common bits used to define a device's power states. Your device's IO family may require that your device specify other input or output power flags to interact properly. Consult family-specific documentation to determine if your IOPower plane parents or children require other power flags; they probably don't.
///
///
///
///
/// Indicates device is in a low power state. May be bitwis-OR'd together
/// with kIOPMDeviceUsable flag, to indicate the device is still usable.
///
/// A device with a capability of kIOPMLowPower may:
/// Require either 0 or kIOPMPowerOn from its power parent
/// Offer either kIOPMLowPower, kIOPMPowerOn, or 0 (no power at all)
/// to its power plane children.
///
/// Useful only as a Capability, although USB drivers should consult USB family documentation for other valid circumstances to use the kIOPMLowPower bit.
///
///
/// In the capability field of a power state, disallows idle system sleep while the device is in that state.
///
/// For example, displays and disks set this capability for their ON power state; since the system may not idle sleep while the display (and thus keyboard or mouse) or the disk is active.
///
/// Useful only as a Capability.
///
///
/// Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
///
///
/// Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
///
///
/// Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
///
///
/// Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
///
///
/// Indicates the initial power state for the device. If
/// <code>
/// initialPowerStateForDomainState()
/// </code>
/// returns a power state with this flag set in the capability field, then the initial power change is performed without calling the driver's
/// <code>
/// setPowerState()
/// </code>
/// .
///
///
/// An indication that the power flags represent the state of the root power
/// domain. This bit must not be set in the IOPMPowerState structure.
/// Power Management may pass this bit to initialPowerStateForDomainState()
/// to map from a global system state to the desired device state.
pub type IOPMPowerFlags = c_ulong;

///
/// ## Discussion
///
/// Indicates the device is on, requires power, and provides power. Useful as a: Capability, InputPowerRequirement, OutputPowerCharacter
///
///
pub const kIOPMPowerOn: c_uint = 0x00000002;
///
/// ## Discussion
///
/// Indicates the device is usable in this state. Useful only as a Capability
///
///
pub const kIOPMDeviceUsable: c_uint = 0x00008000;
///
/// ## Discussion
///
/// Indicates device is in a low power state. May be bitwis-OR'd together with kIOPMDeviceUsable flag, to indicate the device is still usable.
///
/// A device with a capability of kIOPMLowPower may: Require either 0 or kIOPMPowerOn from its power parent Offer either kIOPMLowPower, kIOPMPowerOn, or 0 (no power at all) to its power plane children.
///
/// Useful only as a Capability, although USB drivers should consult USB family documentation for other valid circumstances to use the kIOPMLowPower bit.
///
///
pub const kIOPMLowPower: c_uint = 0x00010000;
///
/// ## Discussion
///
/// In the capability field of a power state, disallows idle system sleep while the device is in that state.
///
/// For example, displays and disks set this capability for their ON power state; since the system may not idle sleep while the display (and thus keyboard or mouse) or the disk is active.
///
/// Useful only as a Capability.
///
///
pub const kIOPMPreventIdleSleep: c_uint = 0x00000040;
///
/// ## Discussion
///
/// Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
///
///
pub const kIOPMSleepCapability: c_uint = 0x00000004;
///
/// ## Discussion
///
/// Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
///
///
pub const kIOPMRestartCapability: c_uint = 0x00000080;
///
/// ## Discussion
///
/// Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
///
///
pub const kIOPMSleep: c_uint = 0x00000001;
///
/// ## Discussion
///
/// Used only by certain IOKit Families (USB). Not defined or used by generic Power Management. Read your family documentation to see if you should define a powerstate using these capabilities.
///
///
pub const kIOPMRestart: c_uint = 0x00000080;
///
/// ## Discussion
///
/// Indicates the initial power state for the device. If `initialPowerStateForDomainState()` returns a power state with this flag set in the capability field, then the initial power change is performed without calling the driver's `setPowerState()`.
///
///
pub const kIOPMInitialDeviceState: c_uint = 0x00000100;
///
/// ## Discussion
///
/// An indication that the power flags represent the state of the root power domain. This bit must not be set in the IOPMPowerState structure. Power Management may pass this bit to initialPowerStateForDomainState() or powerStateForDomainState() to map from a global system state to the desired device state.
///
///
pub const kIOPMRootDomainState: c_uint = 0x00000200;

pub const kIOPMClockNormal: c_uint = 0x0004;
pub const kIOPMClockRunning: c_uint = 0x0008;
pub const kIOPMPreventSystemSleep: c_uint = 0x0010;
pub const kIOPMDoze: c_uint = 0x0400;
pub const kIOPMChildClamp: c_uint = 0x0080;
pub const kIOPMChildClamp2: c_uint = 0x0200;
pub const kIOPMNotPowerManaged: c_uint = 0x0800;

pub const kIOPMMaxPerformance: c_uint = 0x4000;
pub const kIOPMPassThrough: c_uint = 0x0100;
pub const kIOPMAuxPowerOn: c_uint = 0x0020;
pub const kIOPMNotAttainable: c_uint = 0x0001;
pub const kIOPMContextRetained: c_uint = 0x2000;
pub const kIOPMConfigRetained: c_uint = 0x1000;
pub const kIOPMStaticPowerValid: c_uint = 0x0800;
pub const kIOPMSoftSleep: c_uint = 0x0400;
pub const kIOPMCapabilitiesMask: c_uint = kIOPMPowerOn
    | kIOPMDeviceUsable
    | kIOPMMaxPerformance
    | kIOPMContextRetained
    | kIOPMConfigRetained
    | kIOPMSleepCapability
    | kIOPMRestartCapability;

pub const IOPMNotAttainable: c_uint = kIOPMNotAttainable;
pub const IOPMPowerOn: c_uint = kIOPMPowerOn;
pub const IOPMClockNormal: c_uint = kIOPMClockNormal;
pub const IOPMClockRunning: c_uint = kIOPMClockRunning;
pub const IOPMAuxPowerOn: c_uint = kIOPMAuxPowerOn;
pub const IOPMDeviceUsable: c_uint = kIOPMDeviceUsable;
pub const IOPMMaxPerformance: c_uint = kIOPMMaxPerformance;
pub const IOPMContextRetained: c_uint = kIOPMContextRetained;
pub const IOPMConfigRetained: c_uint = kIOPMConfigRetained;
pub const IOPMNotPowerManaged: c_uint = kIOPMNotPowerManaged;
pub const IOPMSoftSleep: c_uint = kIOPMSoftSleep;

pub const kIOPMNextHigherState: c_uint = 1;
pub const kIOPMHighestState: c_uint = 2;
pub const kIOPMNextLowerState: c_uint = 3;
pub const kIOPMLowestState: c_uint = 4;

pub const IOPMNextHigherState: c_uint = kIOPMNextHigherState;
pub const IOPMHighestState: c_uint = kIOPMHighestState;
pub const IOPMNextLowerState: c_uint = kIOPMNextLowerState;
pub const IOPMLowestState: c_uint = kIOPMLowestState;

pub const kIOPMBroadcastAggressiveness: c_uint = 1;
pub const kIOPMUnidleDevice: c_uint = 2;

pub const kIOPMUnknown: c_uint = 0xFFFF;

/// kIOPMDriverAssertionCPUBit
/// When set, PM kernel will prefer to leave the CPU and core hardware
/// running in "Dark Wake" state, instead of sleeping.
pub const kIOPMDriverAssertionCPUBit: c_uint = 0x01;
/// kIOPMDriverAssertionPreventSystemIdleSleepBit
/// When set, the system should not idle sleep. This does not prevent
/// demand sleep.
pub const kIOPMDriverAssertionPreventSystemIdleSleepBit: c_uint = 0x02;
/// kIOPMDriverAssertionUSBExternalDeviceBit
/// When set, driver is informing PM that an external USB device is attached.
pub const kIOPMDriverAssertionUSBExternalDeviceBit: c_uint = 0x04;
/// kIOPMDriverAssertionBluetoothHIDDevicePairedBit
/// When set, driver is informing PM that a Bluetooth HID device is paired.
pub const kIOPMDriverAssertionBluetoothHIDDevicePairedBit: c_uint = 0x08;
/// kIOPMDriverAssertionExternalMediaMountedBit
/// When set, driver is informing PM that an external media is mounted.
pub const kIOPMDriverAssertionExternalMediaMountedBit: c_uint = 0x10;
/// kIOPMDriverAssertionReservedBit5
/// Reserved for Thunderbolt.
pub const kIOPMDriverAssertionReservedBit5: c_uint = 0x20;
/// kIOPMDriverAssertionPreventDisplaySleepBit
/// When set, the display should remain powered on while the system's awake.
pub const kIOPMDriverAssertionPreventDisplaySleepBit: c_uint = 0x40;
/// kIOPMDriverAssertionReservedBit7
/// Reserved for storage family.
pub const kIOPMDriverAssertionReservedBit7: c_uint = 0x80;
/// kIOPMDriverAssertionMagicPacketWakeEnabledBit
/// When set, driver is informing PM that magic packet wake is enabled.
pub const kIOPMDriverAssertionMagicPacketWakeEnabledBit: c_uint = 0x100;
/// kIOPMDriverAssertionNetworkKeepAliveActiveBit
/// When set, driver is informing PM that it is holding the network
/// interface up to do TCPKeepAlive
pub const kIOPMDriverAssertionNetworkKeepAliveActiveBit: c_uint = 0x200;
/// kIOPMDriverAssertionForceWakeupBit
/// When set, the system will immediately wake up the CPU after going to sleep.
pub const kIOPMDriverAssertionForceWakeupBit: c_uint = 0x400;
/// kIOPMDriverAssertionForceFullWakeupBit
/// When set, the system will immediately do a full wakeup after going to sleep.
pub const kIOPMDriverAssertionForceFullWakeupBit: c_uint = 0x800;

pub const kClamshellStateBit: c_uint = 1 << 0;
pub const kClamshellSleepBit: c_uint = 1 << 1;

pub const kInflowForciblyEnabledBit: c_uint = 1 << 0;

pub const kIOPMSleepNow: c_uint = 1 << 0;
pub const kIOPMAllowSleep: c_uint = 1 << 1;
pub const kIOPMPreventSleep: c_uint = 1 << 2;
pub const kIOPMPowerButton: c_uint = 1 << 3;
pub const kIOPMClamshellClosed: c_uint = 1 << 4;
pub const kIOPMPowerEmergency: c_uint = 1 << 5;
pub const kIOPMDisableClamshell: c_uint = 1 << 6;
pub const kIOPMEnableClamshell: c_uint = 1 << 7;
pub const kIOPMProcessorSpeedChange: c_uint = 1 << 8;
pub const kIOPMOverTemp: c_uint = 1 << 9;
pub const kIOPMClamshellOpened: c_uint = 1 << 10;
pub const kIOPMDWOverTemp: c_uint = 1 << 11;
pub const kIOPMPowerButtonUp: c_uint = 1 << 12;
pub const kIOPMProModeEngaged: c_uint = 1 << 13;
pub const kIOPMProModeDisengaged: c_uint = 1 << 14;

pub const kIOPMNoErr: c_uint = 0;
pub const kIOPMAckImplied: c_uint = 0;
pub const kIOPMWillAckLater: c_uint = 1;
pub const kIOPMBadSpecification: c_uint = 4;
pub const kIOPMNoSuchState: c_uint = 5;
pub const kIOPMCannotRaisePower: c_uint = 6;
pub const kIOPMParameterError: c_uint = 7;
pub const kIOPMNotYetInitialized: c_uint = 8;
pub const IOPMNoErr: c_uint = kIOPMNoErr;
pub const IOPMAckImplied: c_uint = kIOPMAckImplied;
pub const IOPMWillAckLater: c_uint = kIOPMWillAckLater;
pub const IOPMBadSpecification: c_uint = kIOPMBadSpecification;
pub const IOPMNoSuchState: c_uint = kIOPMNoSuchState;
pub const IOPMCannotRaisePower: c_uint = kIOPMCannotRaisePower;
pub const IOPMParameterError: c_uint = kIOPMParameterError;
pub const IOPMNotYetInitialized: c_uint = kIOPMNotYetInitialized;

pub const kIOPMPSLocationLeft: c_uint = 1001;
pub const kIOPMPSLocationRight: c_uint = 1002;

pub const kIOPMUndefinedValue: c_uint = 0;
pub const kIOPMPoorValue: c_uint = 1;
pub const kIOPMFairValue: c_uint = 2;
pub const kIOPMGoodValue: c_uint = 3;

pub const kIOPSFamilyCodeDisconnected: c_int = 0;
pub const kIOPSFamilyCodeFirewire: c_int = iokit_family_err!(sub_iokit_firewire, 0);
pub const kIOPSFamilyCodeUSBHost: c_int = iokit_family_err!(sub_iokit_usb, 0);
pub const kIOPSFamilyCodeUSBHostSuspended: c_int = iokit_family_err!(sub_iokit_usb, 1);
pub const kIOPSFamilyCodeUSBDevice: c_int = iokit_family_err!(sub_iokit_usb, 2);
pub const kIOPSFamilyCodeUSBAdapter: c_int = iokit_family_err!(sub_iokit_usb, 3);
pub const kIOPSFamilyCodeUSBChargingPortDedicated: c_int = iokit_family_err!(sub_iokit_usb, 4);
pub const kIOPSFamilyCodeUSBChargingPortDownstream: c_int = iokit_family_err!(sub_iokit_usb, 5);
pub const kIOPSFamilyCodeUSBChargingPort: c_int = iokit_family_err!(sub_iokit_usb, 6);
pub const kIOPSFamilyCodeUSBUnknown: c_int = iokit_family_err!(sub_iokit_usb, 7);
pub const kIOPSFamilyCodeUSBCBrick: c_int = iokit_family_err!(sub_iokit_usb, 8);
pub const kIOPSFamilyCodeUSBCTypeC: c_int = iokit_family_err!(sub_iokit_usb, 9);
pub const kIOPSFamilyCodeUSBCPD: c_int = iokit_family_err!(sub_iokit_usb, 10);
pub const kIOPSFamilyCodeAC: c_int = iokit_family_err!(sub_iokit_pmu, 0);
pub const kIOPSFamilyCodeExternal: c_int = iokit_family_err!(sub_iokit_pmu, 1);
pub const kIOPSFamilyCodeExternal2: c_int = iokit_family_err!(sub_iokit_pmu, 2);
pub const kIOPSFamilyCodeExternal3: c_int = iokit_family_err!(sub_iokit_pmu, 3);
pub const kIOPSFamilyCodeExternal4: c_int = iokit_family_err!(sub_iokit_pmu, 4);
pub const kIOPSFamilyCodeExternal5: c_int = iokit_family_err!(sub_iokit_pmu, 5);
pub const kIOPSFamilyCodeExternal6: c_int = iokit_family_err!(sub_iokit_pmu, 6);
pub const kIOPSFamilyCodeExternal7: c_int = iokit_family_err!(sub_iokit_pmu, 7);
pub const kIOPSFamilyCodeExternal8: c_int = iokit_family_err!(sub_iokit_pmu, 8);
pub const kIOPSFamilyCodeUnsupportedRegion: c_int = iokit_family_err!(sub_iokit_pmu, 9);

pub const kIOPSAdapterErrorFlagNoErrors: c_uint = 0;
pub const kIOPSAdapterErrorFlagInsufficientAvailablePower: c_uint = 1 << 1;
pub const kIOPSAdapterErrorFlagForeignObjectDetected: c_uint = 1 << 2;
pub const kIOPSAdapterErrorFlagDeviceNeedsToBeRepositioned: c_uint = 1 << 3;

pub const kIOPMThermalLevelNormal: c_uint = 0;
pub const kIOPMThermalLevelDanger: c_uint = 5;
pub const kIOPMThermalLevelCritical: c_uint = 10;
pub const kIOPMThermalLevelWarning: c_uint = 100;
pub const kIOPMThermalLevelTrap: c_uint = 110;
pub const kIOPMThermalLevelUnknown: c_uint = 255;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOPMCalendarStruct {
    pub year: u32,
    pub month: u8,
    pub day: u8,
    pub hour: u8,
    pub minute: u8,
    pub second: u8,
    pub selector: u8,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOPMCalendarStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOPMCalendarStruct",
        &[
            <u32>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOPMCalendarStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kPMGeneralAggressiveness: c_uint = 0;
pub const kPMMinutesToDim: c_uint = 1;
pub const kPMMinutesToSpinDown: c_uint = 2;
pub const kPMMinutesToSleep: c_uint = 3;
pub const kPMEthernetWakeOnLANSettings: c_uint = 4;
pub const kPMSetProcessorSpeed: c_uint = 5;
pub const kPMPowerSource: c_uint = 6;
pub const kPMMotionSensor: c_uint = 7;
pub const kPMLastAggressivenessType: c_uint = 8;

pub const kIOPMInternalPower: c_uint = 1;
pub const kIOPMExternalPower: c_uint = 2;

pub const kIOBatteryInstalled: c_uint = 1 << 2;
pub const kIOBatteryCharge: c_uint = 1 << 1;
pub const kIOBatteryChargerConnect: c_uint = 1 << 0;

pub const kIOPMACInstalled: c_uint = kIOBatteryChargerConnect;
pub const kIOPMBatteryCharging: c_uint = kIOBatteryCharge;
pub const kIOPMBatteryInstalled: c_uint = kIOBatteryInstalled;
pub const kIOPMUPSInstalled: c_uint = 1 << 3;
pub const kIOPMBatteryAtWarn: c_uint = 1 << 4;
pub const kIOPMBatteryDepleted: c_uint = 1 << 5;
pub const kIOPMACnoChargeCapability: c_uint = 1 << 6;
pub const kIOPMRawLowBattery: c_uint = 1 << 7;
pub const kIOPMForceLowSpeed: c_uint = 1 << 8;
pub const kIOPMClosedClamshell: c_uint = 1 << 9;
pub const kIOPMClamshellStateOnWake: c_uint = 1 << 10;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOPowerStateChangeNotification {
    pub powerRef: *mut c_void,
    pub returnValue: c_ulong,
    pub stateNumber: c_ulong,
    pub stateFlags: IOPMPowerFlags,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOPowerStateChangeNotification {
    const ENCODING: Encoding = Encoding::Struct(
        "IOPowerStateChangeNotification",
        &[
            <*mut c_void>::ENCODING,
            Encoding::C_ULONG,
            Encoding::C_ULONG,
            <IOPMPowerFlags>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOPowerStateChangeNotification {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type sleepWakeNote = IOPowerStateChangeNotification;

/// A structure describing a system capability change.
///
/// ## Discussion
///
/// A system capability change is a system level transition from a set of system capabilities to a new set of system capabilities. Power management sends a `kIOMessageSystemCapabilityChange` message and provides this structure as the message data (by reference) to `gIOPriorityPowerStateInterest` clients when system capability changes.
///
///
/// A structure describing a system capability change.
///
/// A system capability change is a system level transition from a set
/// of system capabilities to a new set of system capabilities. Power management
/// sends a
/// <code>
/// kIOMessageSystemCapabilityChange
/// </code>
/// message and provides
/// this structure as the message data (by reference) to
/// <code>
/// gIOPriorityPowerStateInterest
/// </code>
/// clients when system capability
/// changes.
/// Field: notifyRef An identifier for this message notification. Clients with pending
/// I/O can signal completion by calling
/// <code>
/// allowPowerChange()
/// </code>
/// with this
/// value as the argument. Clients that are able to process the notification
/// synchronously should ignore this field.
/// Field: maxWaitForReply A return value to the caller indicating the maximum time in
/// microseconds to wait for the
/// <code>
/// allowPowerChange()
/// </code>
/// call. The default
/// value is zero, which indicates the client processing has finished, and power
/// management should not wait for an
/// <code>
/// allowPowerChange()
/// </code>
/// call.
/// Field: changeFlags Flags will be set to indicate whether the notification precedes
/// the capability change (
/// <code>
/// kIOPMSystemCapabilityWillChange
/// </code>
/// ), or after
/// the capability change has occurred (
/// <code>
/// kIOPMSystemCapabilityDidChange
/// </code>
/// ).
/// Field: __reserved1 Set to zero.
/// Field: fromCapabilities The system capabilities at the start of the transition.
/// Field: toCapabilities The system capabilities at the end of the transition.
/// Field: __reserved2 Set to zero.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOPMSystemCapabilityChangeParameters {
    pub notifyRef: u32,
    pub maxWaitForReply: u32,
    pub changeFlags: u32,
    pub(crate) __reserved1: u32,
    pub fromCapabilities: u32,
    pub toCapabilities: u32,
    pub(crate) __reserved2: [u32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOPMSystemCapabilityChangeParameters {
    const ENCODING: Encoding = Encoding::Struct(
        "IOPMSystemCapabilityChangeParameters",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOPMSystemCapabilityChangeParameters {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Discussion
///
/// Indicates the system capability will change.
///
///
pub const kIOPMSystemCapabilityWillChange: c_uint = 0x01;
///
/// ## Discussion
///
/// Indicates the system capability has changed.
///
///
pub const kIOPMSystemCapabilityDidChange: c_uint = 0x02;

pub const kIOPMSystemCapabilityCPU: c_uint = 0x01;
pub const kIOPMSystemCapabilityGraphics: c_uint = 0x02;
pub const kIOPMSystemCapabilityAudio: c_uint = 0x04;
pub const kIOPMSystemCapabilityNetwork: c_uint = 0x08;
pub const kIOPMSystemCapabilityAOT: c_uint = 0x10;

/// Finds the Root Power Domain IOService.
///
/// Parameters:
/// - master_device_port: Pass in `MACH_PORT_NULL` for the primary device port.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns a [`io_connect_t`](https://developer.apple.com/documentation/iokit/io_connect_t) handle on the root domain. Must be released with IOServiceClose() when done.
///
///
/// Finds the Root Power Domain IOService.
///
/// Parameter `master_device_port`: Just pass in MACH_PORT_NULL for master device port.
///
/// Returns: Returns a io_connect_t handle on the root domain. Must be released with IOServiceClose() when done.
#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOPMFindPowerManagement(
    master_device_port: libc::mach_port_t,
) -> io_connect_t {
    extern "C-unwind" {
        fn IOPMFindPowerManagement(master_device_port: libc::mach_port_t) -> io_connect_t;
    }
    unsafe { IOPMFindPowerManagement(master_device_port) }
}

/// Sets one of the aggressiveness factors in IOKit Power Management.
///
/// Parameters:
/// - fb: Representation of the Root Power Domain from IOPMFindPowerManagement.
///
/// - type: Specifies which aggressiveness factor is being set.
///
/// - aggressiveness: New value of the aggressiveness factor.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns kIOReturnSuccess or an error condition if request failed.
///
///
/// Sets one of the aggressiveness factors in IOKit Power Management.
///
/// Parameter `fb`: Representation of the Root Power Domain from IOPMFindPowerManagement.
///
/// Parameter `type`: Specifies which aggressiveness factor is being set.
///
/// Parameter `aggressiveness`: New value of the aggressiveness factor.
///
/// Returns: Returns kIOReturnSuccess or an error condition if request failed.
#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOPMSetAggressiveness(
    fb: io_connect_t,
    r#type: c_ulong,
    aggressiveness: c_ulong,
) -> IOReturn {
    extern "C-unwind" {
        fn IOPMSetAggressiveness(
            fb: io_connect_t,
            r#type: c_ulong,
            aggressiveness: c_ulong,
        ) -> IOReturn;
    }
    unsafe { IOPMSetAggressiveness(fb, r#type, aggressiveness) }
}

extern "C-unwind" {
    /// Retrieves the current value of one of the aggressiveness factors in IOKit Power Management.
    ///
    /// Parameters:
    /// - fb: Representation of the Root Power Domain from IOPMFindPowerManagement.
    ///
    /// - type: Specifies which aggressiveness factor is being retrieved.
    ///
    /// - aggressiveness: Points to where to store the retrieved value of the aggressiveness factor.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess or an error condition if request failed.
    ///
    ///
    /// Retrieves the current value of one of the aggressiveness factors in IOKit Power Management.
    ///
    /// Parameter `fb`: Representation of the Root Power Domain from IOPMFindPowerManagement.
    ///
    /// Parameter `type`: Specifies which aggressiveness factor is being retrieved.
    ///
    /// Parameter `aggressiveness`: Points to where to store the retrieved value of the aggressiveness factor.
    ///
    /// Returns: Returns kIOReturnSuccess or an error condition if request failed.
    ///
    /// # Safety
    ///
    /// `aggressiveness` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IOPMGetAggressiveness(
        fb: io_connect_t,
        r#type: c_ulong,
        aggressiveness: *mut c_ulong,
    ) -> IOReturn;
}

/// Tells whether the system supports full sleep, or just doze
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns true if the system supports sleep, false if some hardware prevents full sleep.
///
///
/// Tells whether the system supports full sleep, or just doze
///
/// Returns: Returns true if the system supports sleep, false if some hardware prevents full sleep.
#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOPMSleepEnabled() -> bool {
    extern "C-unwind" {
        fn IOPMSleepEnabled() -> libc::boolean_t;
    }
    let ret = unsafe { IOPMSleepEnabled() };
    ret != 0
}

/// Request that the system initiate sleep.
///
/// Parameters:
/// - fb: Port used to communicate to the kernel, from IOPMFindPowerManagement.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns kIOReturnSuccess or an error condition if request failed.
///
///
///
/// ## Discussion
///
/// For security purposes, caller must be root or the console user.
///
///
/// Request that the system initiate sleep.
///
/// For security purposes, caller must be root or the console user.
///
/// Parameter `fb`: Port used to communicate to the kernel,  from IOPMFindPowerManagement.
///
/// Returns: Returns kIOReturnSuccess or an error condition if request failed.
#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOPMSleepSystem(fb: io_connect_t) -> IOReturn {
    extern "C-unwind" {
        fn IOPMSleepSystem(fb: io_connect_t) -> IOReturn;
    }
    unsafe { IOPMSleepSystem(fb) }
}

extern "C-unwind" {
    /// Request raw battery data from the system.
    ///
    /// Parameters:
    /// - masterPort: The primary port obtained from [`IOMasterPort`](https://developer.apple.com/documentation/iokit/1514652-iomasterport). Pass `MACH_PORT_NULL`.
    ///
    /// - info: A CFArray of CFDictionaries containing raw battery data.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess or an error condition if request failed.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// WARNING! IOPMCoyBatteryInfo is unsupported on ALL Intel CPU based systems. For PPC CPU based systems, it remains not recommended. For almost all purposes, developers should use the richer IOPowerSources API (with change notifications) instead of using IOPMCopyBatteryInfo. Keys to decipher IOPMCopyBatteryInfo's return CFArray exist in IOPM.h.
    ///
    ///
    /// Request battery data from the system.
    ///
    /// This API is supported, but not recommended. Developers should prefer to use
    /// the IOPowerSources API. IOPowerSources provides more battery data, and notifications
    /// when battery state changes)
    ///
    /// Parameter `masterPort`: The master port obtained from IOMasterPort(). Just pass MACH_PORT_NULL.
    ///
    /// Parameter `info`: A CFArray of CFDictionaries containing raw battery data. Use these keys, defined in IOPM.h
    /// to read from the dictionary:
    /// <pre>
    /// <code>
    ///
    /// ```text
    ///  kIOBatteryInfoKey
    /// ```
    ///
    /// </code>
    /// <code>
    ///
    /// ```text
    ///  kIOBatteryCurrentChargeKey
    /// ```
    ///
    /// </code>
    /// <code>
    ///
    /// ```text
    ///  kIOBatteryCapacityKey
    /// ```
    ///
    /// </code>
    /// <code>
    ///
    /// ```text
    ///  kIOBatteryFlagsKey
    /// ```
    ///
    /// </code>
    /// <code>
    ///
    /// ```text
    ///  kIOBatteryVoltageKey
    /// ```
    ///
    /// </code>
    /// <code>
    ///
    /// ```text
    ///  kIOBatteryAmperageKey
    /// ```
    ///
    /// </code>
    /// <code>
    ///
    /// ```text
    ///  kIOBatteryCycleCountKey
    /// ```
    ///
    /// </code>
    /// </pre>
    ///
    /// Returns: Returns kIOReturnSuccess or an error condition if request failed.
    ///
    /// # Safety
    ///
    /// `info` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IOPMCopyBatteryInfo(
        master_port: libc::mach_port_t,
        info: *mut *const CFArray,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Connects the caller to an IOService for the purpose of receiving power state change notifications for the device controlled by the IOService.
    ///
    /// Parameters:
    /// - refcon: Data returned on power state change notifications and not used by the kernel.
    ///
    /// - theDriver: Representation of the IOService, probably from IOServiceGetMatchingService.
    ///
    /// - thePortRef: Pointer to a port on which the caller will receive power state change notifications. The port is allocated by the calling application.
    ///
    /// - callback: A c-function which is called during the notification.
    ///
    /// - notifier: Pointer to a notifier which caller must keep and pass to subsequent call to IODeregisterApp.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a io_connect_t session for the IOService or MACH_PORT_NULL if request failed. Caller must close return value via IOServiceClose() after calling IODeregisterApp on the notifier argument.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// IORegisterApp requires that the IOService of interest implement an IOUserClient. In addition, that IOUserClient must implement the allowPowerChange and cancelPowerChange methods defined in IOPMLibDefs.h. If you're interested in receiving power state notifications from a device without an IOUserClient, try using IOServiceAddInterestNotification with interest type gIOGeneralInterest instead.
    ///
    ///
    /// DEPRECATED - An obsolete method for interacting with driver power state changes.
    ///
    /// This function is obsolete and deprecated. To receive notifications of driver power state changes,
    /// Please use IOServiceAddInterestNotification with interest type gIOGeneralInterest instead.
    ///
    /// # Safety
    ///
    /// - `refcon` must be a valid pointer.
    /// - `the_port_ref` must be a valid pointer.
    /// - `callback` must be implemented correctly.
    /// - `notifier` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IORegisterApp(
        refcon: *mut c_void,
        the_driver: io_service_t,
        the_port_ref: *mut IONotificationPortRef,
        callback: IOServiceInterestCallback,
        notifier: *mut io_object_t,
    ) -> io_connect_t;
}

extern "C-unwind" {
    /// Connects the caller to the Root Power Domain IOService for the purpose of receiving sleep & wake notifications for the system. Does not provide system shutdown and restart notifications.
    ///
    /// Parameters:
    /// - refcon: Caller may provide data to receive s an argument to 'callback' on power state changes.
    ///
    /// - thePortRef: On return, thePortRef is a pointer to an IONotificationPortRef, which will deliver the power notifications. The port is allocated by this function and must be later released by the caller (after calling [`IODeregisterForSystemPower`](https://developer.apple.com/documentation/iokit/1557132-ioderegisterforsystempower)). The caller should also enable IONotificationPortRef by calling [`IONotificationPortGetRunLoopSource`](https://developer.apple.com/documentation/iokit/1514599-ionotificationportgetrunloopsour), or [`IONotificationPortGetMachPort`](https://developer.apple.com/documentation/iokit/1514875-ionotificationportgetmachport), or [`IONotificationPortSetDispatchQueue`](https://developer.apple.com/documentation/iokit/1514596-ionotificationportsetdispatchque).
    ///
    /// - callback: A c-function which is called during the notification.
    ///
    /// - notifier: On success, returns a pointer to a unique notifier which caller must keep and pass to a subsequent call to IODeregisterForSystemPower.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a io_connect_t session for the IOPMrootDomain or MACH_PORT_NULL if request failed. Caller must close return value via IOServiceClose() after calling IODeregisterForSystemPower on the notifier argument.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Provides sleep/wake notifications to applications. Requires that applications acknowledge some, but not all notifications. Register for sleep/wake notifications will deliver these messages over the sleep/wake lifecycle:
    ///
    /// - kIOMessageSystemWillSleep is delivered at the point the system is initiating a non-abortable sleep. Callers MUST acknowledge this event by calling [`IOAllowPowerChange`](https://developer.apple.com/documentation/iokit/1557064-ioallowpowerchange). If a caller does not acknowledge the sleep notification, the sleep will continue anyway after a 30 second timeout (resulting in bad user experience). Delivered before any hardware is powered off.
    ///
    /// - kIOMessageSystemWillPowerOn is delivered at early wakeup time, before most hardware has been powered on. Be aware that any attempts to access disk, network, the display, etc. may result in errors or blocking your process until those resources become available. Caller must NOT acknowledge kIOMessageSystemWillPowerOn; the caller must simply return from its handler.
    ///
    /// - kIOMessageSystemHasPoweredOn is delivered at wakeup completion time, after all device drivers and hardware have handled the wakeup event. Expect this event 1-5 or more seconds after initiating system wakeup. Caller must NOT acknowledge kIOMessageSystemHasPoweredOn; the caller must simply return from its handler.
    ///
    /// - kIOMessageCanSystemSleep indicates the system is pondering an idle sleep, but gives apps the chance to veto that sleep attempt. Caller must acknowledge kIOMessageCanSystemSleep by calling [`IOAllowPowerChange`](https://developer.apple.com/documentation/iokit/1557064-ioallowpowerchange) or [`IOCancelPowerChange`](https://developer.apple.com/documentation/iokit/1557115-iocancelpowerchange). Calling IOAllowPowerChange will not veto the sleep; any app that calls IOCancelPowerChange will veto the idle sleep. A kIOMessageCanSystemSleep notification will be followed up to 30 seconds later by a kIOMessageSystemWillSleep message. or a kIOMessageSystemWillNotSleep message.
    ///
    /// - kIOMessageSystemWillNotSleep is delivered when some app client has vetoed an idle sleep request. kIOMessageSystemWillNotSleep may follow a kIOMessageCanSystemSleep notification, but will not otherwise be sent. Caller must NOT acknowledge kIOMessageSystemWillNotSleep; the caller must simply return from its handler.
    ///
    /// To deregister for sleep/wake notifications, the caller must make two calls, in this order: - Call IODeregisterForSystemPower with the 'notifier' argument returned here. - Then call IONotificationPortDestroy passing the 'thePortRef' argument returned here.
    ///
    ///
    /// Connects the caller to the Root Power Domain IOService for the purpose of receiving sleep
    /// &
    /// wake notifications for the system.
    /// Does not provide system shutdown and restart notifications.
    ///
    /// Provides sleep/wake notifications to applications. Requires that applications acknowledge
    /// some, but not all notifications. Register for sleep/wake notifications will deliver these messages
    /// over the sleep/wake lifecycle:
    /// <ul>
    /// <li>
    /// kIOMessageSystemWillSleep is delivered at the point the system is initiating a
    /// non-abortable sleep.
    /// Callers MUST acknowledge this event by calling
    ///
    /// ```text
    ///  IOAllowPowerChange
    /// ```
    ///
    /// .
    /// If a caller does not acknowledge the sleep notification, the sleep will continue anyway after
    /// a 30 second timeout (resulting in bad user experience).
    /// Delivered before any hardware is powered off.
    ///
    /// <li>
    /// kIOMessageSystemWillPowerOn is delivered at early wakeup time, before most hardware has been
    /// powered on. Be aware that any attempts to access disk, network, the display, etc. may result
    /// in errors or blocking your process until those resources become available.
    /// Caller must NOT acknowledge kIOMessageSystemWillPowerOn; the caller must simply return from its handler.
    ///
    /// <li>
    /// kIOMessageSystemHasPoweredOn is delivered at wakeup completion time, after all device drivers and
    /// hardware have handled the wakeup event. Expect this event 1-5 or more seconds after initiating
    /// system wakeup.
    /// Caller must NOT acknowledge kIOMessageSystemHasPoweredOn; the caller must simply return from its handler.
    ///
    /// <li>
    /// kIOMessageCanSystemSleep indicates the system is pondering an idle sleep, but gives apps the
    /// chance to veto that sleep attempt.
    /// Caller must acknowledge kIOMessageCanSystemSleep by calling
    ///
    /// ```text
    ///  IOAllowPowerChange
    /// ```
    ///
    /// or
    ///
    /// ```text
    ///  IOCancelPowerChange
    /// ```
    ///
    /// . Calling IOAllowPowerChange will not veto the sleep; any
    /// app that calls IOCancelPowerChange will veto the idle sleep. A kIOMessageCanSystemSleep
    /// notification will be followed up to 30 seconds later by a kIOMessageSystemWillSleep message.
    /// or a kIOMessageSystemWillNotSleep message.
    ///
    /// <li>
    /// kIOMessageSystemWillNotSleep is delivered when some app client has vetoed an idle sleep
    /// request. kIOMessageSystemWillNotSleep may follow a kIOMessageCanSystemSleep notification,
    /// but will not otherwise be sent.
    /// Caller must NOT acknowledge kIOMessageSystemWillNotSleep; the caller must simply return from its handler.
    /// </ul>
    /// To deregister for sleep/wake notifications, the caller must make two calls, in this order:
    /// <ol>
    /// <li>
    /// Call IODeregisterForSystemPower with the 'notifier' argument returned here.
    /// <li>
    /// Then call IONotificationPortDestroy passing the 'thePortRef' argument
    /// returned here.
    /// </ol>
    ///
    /// Parameter `refcon`: Caller may provide data to receive as an argument to 'callback' on power state changes.
    ///
    /// Parameter `thePortRef`: On return, thePortRef is a pointer to an IONotificationPortRef, which will deliver the power notifications.
    /// The port is allocated by this function and must be later released by the caller (after calling
    /// <code>
    ///
    /// ```text
    ///  IODeregisterForSystemPower
    /// ```
    ///
    /// </code>
    /// ).
    /// The caller should also enable IONotificationPortRef by calling
    /// <code>
    ///
    /// ```text
    ///  IONotificationPortGetRunLoopSource
    /// ```
    ///
    /// </code>
    /// , or
    /// <code>
    ///
    /// ```text
    ///  IONotificationPortGetMachPort
    /// ```
    ///
    /// </code>
    /// , or
    /// <code>
    ///
    /// ```text
    ///  IONotificationPortSetDispatchQueue
    /// ```
    ///
    /// </code>
    /// .
    ///
    /// Parameter `callback`: A c-function which is called during the notification.
    ///
    /// Parameter `notifier`: On success, returns a pointer to a unique notifier which caller must keep and pass to a subsequent call to IODeregisterForSystemPower.
    ///
    /// Returns: Returns a io_connect_t session for the IOPMrootDomain or IO_OBJECT_NULL if request failed.
    /// Caller must close return value via IOServiceClose() after calling IODeregisterForSystemPower on the notifier argument.
    ///
    /// # Safety
    ///
    /// - `refcon` must be a valid pointer.
    /// - `the_port_ref` must be a valid pointer.
    /// - `callback` must be implemented correctly.
    /// - `notifier` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IORegisterForSystemPower(
        refcon: *mut c_void,
        the_port_ref: *mut IONotificationPortRef,
        callback: IOServiceInterestCallback,
        notifier: *mut io_object_t,
    ) -> io_connect_t;
}

extern "C-unwind" {
    /// Disconnects the caller from an IOService after receiving power state change notifications from the IOService. (Caller must also release IORegisterApp's return io_connect_t and returned IONotificationPortRef for complete clean-up).
    ///
    /// Parameters:
    /// - notifier: An object from IORegisterApp.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess or an error condition if request failed.
    ///
    ///
    /// Disconnects the caller from an IOService after receiving power state change notifications from the IOService. (Caller must also release IORegisterApp's return io_connect_t and returned IONotificationPortRef for complete clean-up).
    ///
    /// Parameter `notifier`: An object from IORegisterApp.
    ///
    /// Returns: Returns kIOReturnSuccess or an error condition if request failed.
    ///
    /// # Safety
    ///
    /// `notifier` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IODeregisterApp(notifier: *mut io_object_t) -> IOReturn;
}

extern "C-unwind" {
    /// Disconnects the caller from the Root Power Domain IOService after receiving system power state change notifications. (Caller must also destroy the IONotificationPortRef returned from IORegisterForSystemPower.)
    ///
    /// Parameters:
    /// - notifier: The object returned from IORegisterForSystemPower.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess or an error condition if request failed.
    ///
    ///
    /// Disconnects the caller from the Root Power Domain IOService after receiving system power state change notifications. (Caller must also destroy the IONotificationPortRef returned from IORegisterForSystemPower.)
    ///
    /// Parameter `notifier`: The object returned from IORegisterForSystemPower.
    ///
    /// Returns: Returns kIOReturnSuccess or an error condition if request failed.
    ///
    /// # Safety
    ///
    /// `notifier` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IODeregisterForSystemPower(notifier: *mut io_object_t) -> IOReturn;
}

/// The caller acknowledges notification of a power state change on a device it has registered for notifications for via IORegisterForSystemPower or IORegisterApp.
///
/// Parameters:
/// - kernelPort: Port used to communicate to the kernel, from IORegisterApp or IORegisterForSystemPower.
///
/// - notificationID: A copy of the notification ID which came as part of the power state change notification being acknowledged.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns kIOReturnSuccess or an error condition if request failed.
///
///
///
/// ## Discussion
///
/// Must be used when handling kIOMessageCanSystemSleep and kIOMessageSystemWillSleep messages from IOPMrootDomain system power. The caller should not call IOAllowPowerChange in response to any messages except for these two.
///
///
/// The caller acknowledges notification of a power state change on a device it has registered for notifications for via IORegisterForSystemPower or IORegisterApp.
///
/// Must be used when handling kIOMessageCanSystemSleep and kIOMessageSystemWillSleep messages from IOPMrootDomain system power. The caller should not call IOAllowPowerChange in response to any messages
/// except for these two.
///
/// Parameter `kernelPort`: Port used to communicate to the kernel,  from IORegisterApp or IORegisterForSystemPower.
///
/// Parameter `notificationID`: A copy of the notification ID which came as part of the power state change notification being acknowledged.
///
/// Returns: Returns kIOReturnSuccess or an error condition if request failed.
#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOAllowPowerChange(
    kernel_port: io_connect_t,
    notification_id: isize,
) -> IOReturn {
    extern "C-unwind" {
        fn IOAllowPowerChange(kernel_port: io_connect_t, notification_id: isize) -> IOReturn;
    }
    unsafe { IOAllowPowerChange(kernel_port, notification_id) }
}

/// The caller denies an idle system sleep power state change.
///
/// Parameters:
/// - kernelPort: Port used to communicate to the kernel, from IORegisterApp or IORegisterForSystemPower.
///
/// - notificationID: A copy of the notification ID which came as part of the power state change notification being acknowledged.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns kIOReturnSuccess or an error condition if request failed.
///
///
///
/// ## Discussion
///
/// Should only called in response to kIOMessageCanSystemSleep messages from IOPMrootDomain. IOCancelPowerChange has no meaning for responding to kIOMessageSystemWillSleep (which is non-abortable) or any other messages.
///
/// When an app responds to a kIOMessageCanSystemSleep message by calling IOCancelPowerChange, the app vetoes the idle sleep request. The system will stay awake. The idle timer will elapse again after a period of inactivity, and the system will send out the same kIOMessageCanSystemSleep message, and interested applications will respond gain.
///
///
/// The caller denies an idle system sleep power state change.
///
/// Should only called in response to kIOMessageCanSystemSleep messages from IOPMrootDomain. IOCancelPowerChange has no meaning for responding to kIOMessageSystemWillSleep (which is non-abortable) or any other messages.
///
/// When an app responds to a kIOMessageCanSystemSleep message by calling IOCancelPowerChange, the app
/// vetoes the idle sleep request. The system will stay awake.
/// The idle timer will elapse again after a period of inactivity, and the system will
/// send out the same kIOMessageCanSystemSleep message, and interested applications will respond gain.
///
///
/// Parameter `kernelPort`: Port used to communicate to the kernel,  from IORegisterApp or IORegisterForSystemPower.
///
/// Parameter `notificationID`: A copy of the notification ID which came as part of the power state change notification being acknowledged.
///
/// Returns: Returns kIOReturnSuccess or an error condition if request failed.
#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOCancelPowerChange(
    kernel_port: io_connect_t,
    notification_id: isize,
) -> IOReturn {
    extern "C-unwind" {
        fn IOCancelPowerChange(kernel_port: io_connect_t, notification_id: isize) -> IOReturn;
    }
    unsafe { IOCancelPowerChange(kernel_port, notification_id) }
}

extern "C-unwind" {
    /// Schedule the machine to wake from sleep, power on, go to sleep, or shutdown.
    ///
    /// Parameters:
    /// - time_to_wake: Date and time that the system will power on/off.
    ///
    /// - my_id: A CFStringRef identifying the calling app by CFBundleIdentifier. May be NULL.
    ///
    /// - type: The type of power on you desire, either wake from sleep or power on. Choose from: CFSTR(kIOPMAutoWake) == wake machine, CFSTR(kIOPMAutoPowerOn) == power on machine, CFSTR(kIOPMAutoWakeOrPowerOn) == wake or power on, CFSTR(kIOPMAutoSleep) == sleep machine, CFSTR(kIOPMAutoShutdown) == power off machine, CFSTR(kIOPMAutoRestart) == restart the machine.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// kIOReturnSuccess on success, otherwise on failure
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This event will be added to the system's queue of power events and stored persistently on disk. The sleep and shutdown events present a graphical warning and allow a console user to cancel the event. Must be called as root.
    ///
    ///
    /// Schedule the machine to wake from sleep, power on, go to sleep, or shutdown.
    ///
    /// This event will be added to the system's queue of power events and stored persistently on disk. The sleep and shutdown events present a graphical warning and allow a console user to cancel the event. Must be called as root.
    ///
    /// Parameter `time_to_wake`: Date and time that the system will power on/off.
    ///
    /// Parameter `my_id`: A CFStringRef identifying the calling app by CFBundleIdentifier. May be NULL.
    ///
    /// Parameter `type`: The type of power on you desire, either wake from sleep or power on. Choose from:
    /// <ul>
    /// <li>
    /// CFSTR(
    /// <code>
    /// kIOPMAutoWake
    /// </code>
    /// ) == wake machine,
    /// <li>
    /// CFSTR(
    /// <code>
    /// kIOPMAutoPowerOn
    /// </code>
    /// ) == power on machine,
    /// <li>
    /// CFSTR(
    /// <code>
    /// kIOPMAutoWakeOrPowerOn
    /// </code>
    /// ) == wake or power on,
    /// <li>
    /// CFSTR(
    /// <code>
    /// kIOPMAutoSleep
    /// </code>
    /// ) == sleep machine,
    /// <li>
    /// CFSTR(
    /// <code>
    /// kIOPMAutoShutdown
    /// </code>
    /// ) == power off machine,
    /// <li>
    /// CFSTR(
    /// <code>
    /// kIOPMAutoRestart
    /// </code>
    /// ) == restart the machine.
    /// </ul>
    ///
    /// Returns: kIOReturnSuccess on success, otherwise on failure
    ///
    /// # Safety
    ///
    /// - `time_to_wake` might not allow `None`.
    /// - `my_id` might not allow `None`.
    /// - `type` might not allow `None`.
    pub fn IOPMSchedulePowerEvent(
        time_to_wake: Option<&CFDate>,
        my_id: Option<&CFString>,
        r#type: Option<&CFString>,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Cancel a previously scheduled power event.
    ///
    /// Parameters:
    /// - time_to_wake: Cancel entry with this date and time.
    ///
    /// - my_id: Cancel entry with this name.
    ///
    /// - type: Type to cancel
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// kIOReturnSuccess on success, otherwise on failure
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Arguments mirror those to IOPMSchedulePowerEvent. All arguments must match the original arguments from when the power on was scheduled. Must be called as root.
    ///
    ///
    /// Cancel a previously scheduled power event.
    ///
    /// Arguments mirror those to IOPMSchedulePowerEvent. All arguments must match the original arguments from when the power on was scheduled. Must be called as root.
    ///
    /// Parameter `time_to_wake`: Cancel entry with this date and time.
    ///
    /// Parameter `my_id`: Cancel entry with this name.
    ///
    /// Parameter `type`: Type to cancel
    ///
    /// Returns: kIOReturnSuccess on success, otherwise on failure
    ///
    /// # Safety
    ///
    /// - `time_to_wake` might not allow `None`.
    /// - `my_id` might not allow `None`.
    /// - `type` might not allow `None`.
    pub fn IOPMCancelScheduledPowerEvent(
        time_to_wake: Option<&CFDate>,
        my_id: Option<&CFString>,
        r#type: Option<&CFString>,
    ) -> IOReturn;
}

/// List all scheduled system power events
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// A CFArray of CFDictionaries of power events. The CFArray must be released by the caller. NULL if there are no scheduled events.
///
///
///
/// ## Discussion
///
/// Returns a CFArray of CFDictionaries of power events. Each CFDictionary contains keys for CFSTR(kIOPMPowerEventTimeKey), CFSTR(kIOPMPowerEventAppNameKey), and CFSTR(kIOPMPowerEventTypeKey).
///
///
/// List all scheduled system power events
///
/// Returns a CFArray of CFDictionaries of power events. Each CFDictionary  contains keys for CFSTR(kIOPMPowerEventTimeKey), CFSTR(kIOPMPowerEventAppNameKey), and CFSTR(kIOPMPowerEventTypeKey).
///
/// Returns: A CFArray of CFDictionaries of power events. The CFArray must be released by the caller. NULL if there are no scheduled events.
#[inline]
pub extern "C-unwind" fn IOPMCopyScheduledPowerEvents() -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn IOPMCopyScheduledPowerEvents() -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { IOPMCopyScheduledPowerEvents() };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Type for AssertionID arguments to [`IOPMAssertionCreateWithProperties`](https://developer.apple.com/documentation/iokit/1557082-iopmassertioncreatewithpropertie) and [`IOPMAssertionRelease`](https://developer.apple.com/documentation/iokit/1557090-iopmassertionrelease)
/// Type for AssertionID arguments to
/// <code>
///
/// ```text
///  IOPMAssertionCreateWithProperties
/// ```
///
/// </code>
/// and
/// <code>
///
/// ```text
///  IOPMAssertionRelease
/// ```
///
/// </code>
pub type IOPMAssertionID = u32;

///
/// ## Discussion
///
/// This value represents a non-initialized assertion ID.
///
///
pub const kIOPMNullAssertionID: c_uint = 0;

/// Type for AssertionLevel argument to IOPMAssertionCreate
///
/// ## Discussion
///
/// Possible values for `IOPMAssertionLevel` are [`kIOPMAssertionLevelOff`](https://developer.apple.com/documentation/iokit/1557096-assertion/kiopmassertionleveloff) and [`kIOPMAssertionLevelOn`](https://developer.apple.com/documentation/iokit/1557096-assertion/kiopmassertionlevelon)
///
///
/// Type for AssertionLevel argument to IOPMAssertionCreate
///
///
/// Possible values for
/// <code>
/// IOPMAssertionLevel
/// </code>
/// are
/// <code>
///
/// ```text
///  kIOPMAssertionLevelOff
/// ```
///
/// </code>
/// and
/// <code>
///
/// ```text
///  kIOPMAssertionLevelOn
/// ```
///
/// </code>
pub type IOPMAssertionLevel = u32;

/// Level for a disabled assertion, passed as an argument to IOPMAssertionCreate.
pub const kIOPMAssertionLevelOff: c_uint = 0;
/// Level for an enabled assertion, passed as an argument to IOPMAssertionCreate.
pub const kIOPMAssertionLevelOn: c_uint = 255;

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOPMUserActiveType(pub c_uint);
impl IOPMUserActiveType {
    #[doc(alias = "kIOPMUserActiveLocal")]
    pub const Local: Self = Self(0);
    #[doc(alias = "kIOPMUserActiveRemote")]
    pub const Remote: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOPMUserActiveType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOPMUserActiveType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    ///
    /// Parameters:
    /// - AssertionType: An assertion type constant. Caller must specify this argument.
    ///
    /// - Name: A CFString value to correspond to key [`kIOPMAssertionNameKey`](https://developer.apple.com/documentation/iokit/kiopmassertionnamekey). Caller must specify this argument.
    ///
    /// - Details: A CFString value to correspond to key [`kIOPMAssertionDetailsKey`](https://developer.apple.com/documentation/iokit/kiopmassertiondetailskey). Caller my pass NULL, but it helps power users and administrators identify the reasons for this assertion.
    ///
    /// - HumanReadableReason: A CFString value to correspond to key [`kIOPMAssertionHumanReadableReasonKey`](https://developer.apple.com/documentation/iokit/kiopmassertionhumanreadablereasonkey). Caller may pass NULL, but if it's specified macOS may display it to users to describe the active assertions on their system.
    ///
    /// - LocalizationBundlePath: A CFString value to correspond to key [`kIOPMAssertionLocalizationBundlePathKey`](https://developer.apple.com/documentation/iokit/kiopmassertionlocalizationbundlepathkey). This bundle path should include a localization for the string `HumanReadableReason` Caller may pass NULL, but this argument is required if caller specifies `HumanReadableReason`
    ///
    /// - Timeout: Specifies a timeout for this assertion. Pass 0 for no timeout.
    ///
    /// - TimeoutAction: Specifies a timeout action. Caller my pass NULL. If a timeout is specified but a TimeoutAction is not, the default timeout action is `kIOPMAssertionTimeoutActionTurnOff`
    ///
    /// - AssertionID: (Output) On successful return, contains a unique reference to a PM assertion.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// kIOReturnSuccess, or another IOKit return code on error.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Creates an IOPMAssertion. This is the preferred API to call to create an assertion. It allows the caller to specify the Name, Details, and HumanReadableReason at creation time. There are other keys that can further describe an assertion, but most developers don't need to use them. Use IOPMAssertionSetProperties or [`IOPMAssertionCreateWithProperties`](https://developer.apple.com/documentation/iokit/1557082-iopmassertioncreatewithpropertie) if you need to specify properties that aren't available here.
    ///
    ///
    /// The preferred API to create a power assertion.
    ///
    /// Creates an IOPMAssertion. This is the preferred API to call to create an assertion.
    /// It allows the caller to specify the Name, Details, and HumanReadableReason at creation time.
    /// There are other keys that can further describe an assertion, but most developers don't need
    /// to use them. Use
    /// <code>
    ///
    /// ```text
    ///  IOPMAssertionSetProperty
    /// ```
    ///
    /// </code>
    /// or
    /// <code>
    ///
    /// ```text
    ///  IOPMAssertionCreateWithProperties
    /// ```
    ///
    /// </code>
    /// if you need to specify properties
    /// that aren't available here.
    ///
    ///
    /// Parameter `AssertionType`: An assertion type constant.
    /// Caller must specify this argument.
    ///
    ///
    /// Parameter `Name`: A CFString value to correspond to key
    /// <code>
    ///
    /// ```text
    ///  kIOPMAssertionNameKey
    /// ```
    ///
    /// </code>
    /// .
    /// Caller must specify this argument.
    ///
    ///
    /// Parameter `Details`: A CFString value to correspond to key
    /// <code>
    ///
    /// ```text
    ///  kIOPMAssertionDetailsKey
    /// ```
    ///
    /// </code>
    /// .
    /// Caller may pass NULL, but it helps power users and administrators identify the
    /// reasons for this assertion.
    ///
    ///
    /// Parameter `HumanReadableReason`: A CFString value to correspond to key
    /// <code>
    ///
    /// ```text
    ///  kIOPMAssertionHumanReadableReasonKey
    /// ```
    ///
    /// </code>
    /// .
    /// Caller may pass NULL, but if it's specified OS X may display it to users
    /// to describe the active assertions on their system.
    ///
    ///
    /// Parameter `LocalizationBundlePath`: A CFString value to correspond to key
    /// <code>
    ///
    /// ```text
    ///  kIOPMAssertionLocalizationBundlePathKey
    /// ```
    ///
    /// </code>
    /// .
    /// This bundle path should include a localization for the string
    /// <code>
    /// HumanReadableReason
    /// </code>
    /// Caller may pass NULL, but this argument is required if caller specifies
    /// <code>
    /// HumanReadableReason
    /// </code>
    ///
    ///
    /// Parameter `Timeout`: Specifies a timeout for this assertion. Pass 0 for no timeout.
    ///
    ///
    /// Parameter `TimeoutAction`: Specifies a timeout action. Caller my pass NULL. If a timeout is specified but a TimeoutAction is not,
    /// the default timeout action is
    /// <code>
    /// kIOPMAssertionTimeoutActionTurnOff
    /// </code>
    ///
    ///
    /// Parameter `AssertionID`: (Output) On successful return, contains a unique reference to a PM assertion.
    ///
    ///
    /// Returns: kIOReturnSuccess, or another IOKit return code on error.
    ///
    /// # Safety
    ///
    /// - `assertion_type` might not allow `None`.
    /// - `name` might not allow `None`.
    /// - `details` might not allow `None`.
    /// - `human_readable_reason` might not allow `None`.
    /// - `localization_bundle_path` might not allow `None`.
    /// - `timeout_action` might not allow `None`.
    /// - `assertion_id` must be a valid pointer.
    pub fn IOPMAssertionCreateWithDescription(
        assertion_type: Option<&CFString>,
        name: Option<&CFString>,
        details: Option<&CFString>,
        human_readable_reason: Option<&CFString>,
        localization_bundle_path: Option<&CFString>,
        timeout: CFTimeInterval,
        timeout_action: Option<&CFString>,
        assertion_id: *mut IOPMAssertionID,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Creates an IOPMAssertion with more flexibility than [`IOPMAssertionCreateWithDescription`](https://developer.apple.com/documentation/iokit/1557078-iopmassertioncreatewithdescripti).
    ///
    /// Parameters:
    /// - AssertionProperties: Dictionary providing the properties of the assertion that need to be created.
    ///
    /// - AssertionID: (Output) On successful return, contains a unique reference to a PM assertion.
    ///
    ///
    /// ## Discussion
    ///
    /// Create a new PM assertion - the caller must specify the type of assertion, initial level, and its properties as [`IOPMAssertionDictionaryKeys`](https://developer.apple.com/documentation/iokit/iopmlib_h/iopmassertiondictionarykeys) keys in the `AssertionProperties` dictionary. The following keys are recommend and/or required to be specified in the AssertionProperties dictionary argument.
    ///
    /// - REQUIRED: `kIOPMAssertionTypeKey` define the assertion type.
    ///
    /// - REQUIRED: `kIOPMAssertionValueKey` define an inital value.
    ///
    /// - REQUIRED: `kIOPMAssertionNameKey` Caller must describe the name for the activity that requires the change in behavior provided by the assertion.
    ///
    /// - OPTIONAL: `kIOPMAssertionDetailsKey` Caller may describe context-specific data about the assertion.
    ///
    /// - OPTIONAL: `kIOPMAssertionHumanReadableReasonKey` Caller may describe the reason for creating the assertion in a localizable CFString. This should be a human readable phrase that describes the actions the calling process is taking while the assertion is held, like "Downloading TV episodes", or "Compiling Projects"
    ///
    /// - OPTIONAL: `kIOPMAssertionLocalizationBundlePathKey` Caller may provide its bundle's path, where macOS can localize for GUI display the CFString specified by [`kIOPMAssertionHumanReadableReasonKey`](https://developer.apple.com/documentation/iokit/kiopmassertionhumanreadablereasonkey).
    ///
    /// - OPTIONAL: `kIOPMAssertionPlugInIDKey` if the caller is a plugin with a different identity than the process it's loaded in.
    ///
    /// - OPTIONAL: `kIOPMAssertionFrameworkIDKey` if the caller is a framework acting on behalf of a process.
    ///
    /// - OPTIONAL: The caller may specify a timeout.
    ///
    ///
    /// Creates an IOPMAssertion with more flexibility than
    /// <code>
    ///
    /// ```text
    ///  IOPMAssertionCreateWithDescription
    /// ```
    ///
    /// </code>
    /// .
    ///
    /// Parameter `AssertionProperties`: Dictionary providing the properties of the assertion that need to be created.
    ///
    /// Parameter `AssertionID`: (Output) On successful return, contains a unique reference to a PM assertion.
    ///
    ///
    /// Create a new PM assertion - the caller must specify the type of assertion, initial level, and its
    /// properties as
    ///
    /// ```text
    ///  IOPMAssertionDictionaryKeys
    /// ```
    ///
    /// keys in the
    /// <code>
    /// AssertionProperties
    /// </code>
    /// dictionary.
    /// The following keys are recommend and/or required to be specified in the AssertionProperties
    /// dictionary argument.
    /// <ul>
    /// <li>
    /// REQUIRED:
    /// <code>
    /// kIOPMAssertionTypeKey
    /// </code>
    /// define the assertion type.
    ///
    /// <li>
    /// REQUIRED:
    /// <code>
    /// kIOPMAssertionNameKey
    /// </code>
    /// Caller must describe the name for the activity that
    /// requires the change in behavior provided by the assertion.
    ///
    /// <li>
    /// OPTIONAL:
    /// <code>
    /// kIOPMAssertionLevelKey
    /// </code>
    /// define an inital value. If not set, assertion is
    /// turned on after creation.
    ///
    /// <li>
    /// OPTIONAL:
    /// <code>
    /// kIOPMAssertionDetailsKey
    /// </code>
    /// Caller may describe context-specific data about the
    /// assertion.
    ///
    /// <li>
    /// OPTIONAL:
    /// <code>
    /// kIOPMAssertionHumanReadableReasonKey
    /// </code>
    /// Caller may describe the reason for creating the assertion
    /// in a localizable CFString. This should be a human readable phrase that describes the actions the
    /// calling process is taking while the assertion is held, like "Downloading TV episodes", or "Compiling Projects"
    ///
    /// <li>
    /// OPTIONAL:
    /// <code>
    /// kIOPMAssertionLocalizationBundlePathKey
    /// </code>
    /// Caller may provide its bundle's path, where OS X
    /// can localize for GUI display the CFString specified by
    /// <code>
    ///
    /// ```text
    ///  kIOPMAssertionHumanReadableReasonKey
    /// ```
    ///
    /// </code>
    /// .
    ///
    /// <li>
    /// OPTIONAL:
    /// <code>
    /// kIOPMAssertionPlugInIDKey
    /// </code>
    /// if the caller is a plugin with a different identity than the process
    /// it's loaded in.
    ///
    /// <li>
    /// OPTIONAL:
    /// <code>
    /// kIOPMAssertionFrameworkIDKey
    /// </code>
    /// if the caller is a framework acting on behalf of a process.
    ///
    /// <li>
    /// OPTIONAL:
    /// <code>
    /// kIOPMAssertionTimeoutKey
    /// </code>
    /// The caller may specify a timeout.
    /// </ul>
    ///
    /// # Safety
    ///
    /// - `assertion_properties` generic must be of the correct type.
    /// - `assertion_properties` generic must be of the correct type.
    /// - `assertion_properties` might not allow `None`.
    /// - `assertion_id` must be a valid pointer.
    pub fn IOPMAssertionCreateWithProperties(
        assertion_properties: Option<&CFDictionary>,
        assertion_id: *mut IOPMAssertionID,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Declares that the user is active on the system. This causes the display to power on and postpone display sleep up to the user's display sleep Energy Saver settings. If you prefer to hold the display awake for a longer period and you know how long you'd like to hold it, consider taking assertion [`kIOPMAssertionTypePreventUserIdleDisplaySleep`](https://developer.apple.com/documentation/iokit/kiopmassertiontypepreventuseridledisplaysleep) using [`IOPMAssertionCreateWithDescription`](https://developer.apple.com/documentation/iokit/1557078-iopmassertioncreatewithdescripti) API instead.
    ///
    /// Parameters:
    /// - AssertionName: A string that describes the name of the caller and the activity being handled by this assertion (e.g. "Mail Compacting Mailboxes"). Name may be no longer than 128 characters.
    ///
    /// - userType: This parameter specifies if the active user is located locally in front of the system or connected to the system over the network. Various components of the system are maintained at different power levels depending on user location.
    ///
    /// - AssertionID: On Success, unique id will be returned in this parameter. Caller may call this function again with the unique id retured previously to report continous user activity. The unique id returned by this function may change on each call depending on how frequently this function call is repeated and the current display sleep timer value. If you make this call more than once, track the returned value for assertionID, and pass it in as an argument on each call.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess on success, any other return indicates PM could not successfully activate the specified assertion.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// No special privileges are necessary to make this call - any process may call this API. Caller must specify an AssertionName - NULL is not a valid input.
    ///
    ///
    /// Declares that the user is active on the system.
    ///
    ///
    /// This causes the display to power on and postpone display sleep,
    /// up to the user's display sleep Energy Saver settings.
    ///
    /// If you need to hold the display awake for a longer period and you know
    /// how long you'd like to hold it, consider taking assertion
    /// <code>
    ///
    /// ```text
    ///  kIOPMAssertPreventUserIdleDisplaySleep
    /// ```
    ///
    /// </code>
    /// using
    /// <code>
    ///
    /// ```text
    ///  IOPMAssertionCreateWithDescription
    /// ```
    ///
    /// </code>
    /// API instead.
    ///
    /// No special privileges are necessary to make this call - any process may
    /// call this API. Caller must specify an AssertionName - NULL is not
    /// a valid input.
    ///
    ///
    /// Parameter `AssertionName`: A string that describes the name of the caller and the activity being
    /// handled by this assertion (e.g. "Mail Compacting Mailboxes"). Name may be no longer
    /// than 128 characters.
    ///
    ///
    /// Parameter `userType`: This parameter specifies if the active user is located locally in front of the
    /// system or connected to the system over the network. Various components of the system
    /// are maintained at different power levels depending on user location.
    ///
    ///
    /// Parameter `AssertionID`: On Success, unique id will be returned in this parameter. Caller
    /// may call this function again with the unique id retured previously to report continous
    /// user activity. The unique id returned by this function may change on each call depending
    /// on how frequently this function call is repeated and the current display sleep timer value.
    /// If you make this call more than once, track the returned value for
    /// assertionID, and pass it in as an argument on each call.
    ///
    ///
    /// Returns: Returns kIOReturnSuccess on success, any other return indicates
    /// PM could not successfully activate the specified assertion.
    ///
    /// # Safety
    ///
    /// - `assertion_name` might not allow `None`.
    /// - `assertion_id` must be a valid pointer.
    pub fn IOPMAssertionDeclareUserActivity(
        assertion_name: Option<&CFString>,
        user_type: IOPMUserActiveType,
        assertion_id: *mut IOPMAssertionID,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// A convenience function for handling remote network clients; this is a wrapper for
    /// holding
    /// <code>
    ///
    /// ```text
    ///  kIOPMAssertNetworkClientActive
    /// ```
    ///
    /// </code>
    ///
    ///
    /// Call this whenever you detect activity from your remote network clients.
    /// This call generates an IPC call, and may block.
    ///
    /// On the first invocation, this will populate parameter
    /// <code>
    /// AssertionID
    /// </code>
    /// with a new assertion ID.
    /// You should pass in this returned assertion ID on every access.
    ///
    /// When system is on AC power, every call to
    /// <code>
    /// IOPMDeclareNetworkClientActivity
    /// </code>
    /// prevents system from idle sleeping and from demand sleeping for the duration of
    /// system sleep timer. When system is on Battery power, every call to
    /// <code>
    /// IOPMDeclareNetworkClientActivity
    /// </code>
    /// prevents system from idle sleeping for the
    /// duration of system sleep timer.
    ///
    /// Assertion created by this interface is valid only for the duration of system sleep timer
    /// from the last call. IOKit will disable
    /// <code>
    /// AssertionID
    /// </code>
    /// after that duration.
    ///
    /// If you detect that your remote client is no longer active, please immediately call
    /// <code>
    ///
    /// ```text
    ///  IOPMAssertionRelease
    /// ```
    ///
    /// </code>
    /// . Do not wait for the timeout.
    ///
    /// If your process can detect when remote clients are active and idle, you can skip
    /// this API and directly create
    /// <code>
    ///
    /// ```text
    ///  kIOPMAssertNetworkClientActive
    /// ```
    ///
    /// </code>
    /// yourself.
    ///
    /// If your remote clients require access to the framebuffer or the GPU, then this
    /// isn't the appropriate call for you. Please see
    /// <code>
    ///
    /// ```text
    ///  IOPMAssertionDeclareUserActivity
    /// ```
    ///
    /// </code>
    /// and pass in argument
    /// <code>
    ///
    /// ```text
    ///  kIOPMUserActiveRemote
    /// ```
    ///
    /// </code>
    /// .
    ///
    ///
    /// Parameter `AssertionName`: A string that describes the name of the caller and the activity being
    /// handled by this assertion (e.g. "Serving a podcast"). The name must be less than
    /// 128 characters.
    /// *
    ///
    /// Parameter `AssertionID`: On Success, unique id will be returned in this parameter. Caller
    /// may call this function again with the unique id retured previously to report additional
    /// user activity. The unique id returned by this function may change on each call depending
    /// on how frequently this function call is repeated and the current system sleep timer value.
    /// If you make this call more than once, track the returned value for
    /// assertionID, and pass it in as an argument on each call.
    ///
    ///
    /// Returns: Returns kIOReturnSuccess on success, any other return indicates
    /// PM could not successfully activate the specified assertion.
    ///
    /// # Safety
    ///
    /// - `assertion_name` might not allow `None`.
    /// - `assertion_id` must be a valid pointer.
    pub fn IOPMDeclareNetworkClientActivity(
        assertion_name: Option<&CFString>,
        assertion_id: *mut IOPMAssertionID,
    ) -> IOReturn;
}

/// Increments the assertion's retain count.
///
/// Parameters:
/// - theAssertion: The assertion ID to retain.
///
///
/// ## Discussion
///
/// Increments the retain count according to CoreFoundation style retain/release semantics. Retain count can be inspected in the assertion's info dictionary at key [`kIOPMAssertionRetainCountKey`](https://developer.apple.com/documentation/iokit/kiopmassertionretaincountkey)
///
///
/// Increments the assertion's retain count.
///
/// Increments the retain count according to CoreFoundation style retain/release semantics.
/// Retain count can be inspected in the assertion's info dictionary at
/// key
/// <code>
///
/// ```text
///  kIOPMAssertionRetainCountKey
/// ```
///
/// </code>
///
/// Parameter `theAssertion`: The assertion ID to retain.
#[inline]
pub extern "C-unwind" fn IOPMAssertionRetain(the_assertion: IOPMAssertionID) {
    extern "C-unwind" {
        fn IOPMAssertionRetain(the_assertion: IOPMAssertionID);
    }
    unsafe { IOPMAssertionRetain(the_assertion) }
}

/// Decrements the assertion's retain count.
///
/// Parameters:
/// - AssertionID: The assertion_id, returned from IOPMAssertionCreate, to cancel.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns kIOReturnSuccess on success.
///
///
///
/// ## Discussion
///
/// If the retain count becomes zero, then this also frees and deactivates the assertion referred to by `assertionID`
///
/// Calls to [`IOPMAssertionCreate`](https://developer.apple.com/documentation/iokit/1557118-iopmassertioncreate) and [`IOPMAssertionRelease`](https://developer.apple.com/documentation/iokit/1557090-iopmassertionrelease) must each be paired with calls to IOPMAssertionRelease.
///
///
/// Decrements the assertion's retain count.
///
///
/// If the retain count becomes zero, then this also frees and deactivates
/// the assertion referred to by
/// <code>
/// assertionID
/// </code>
///
/// Calls to
/// <code>
///
/// ```text
///  IOPMAssertionCreate
/// ```
///
/// </code>
/// and
/// <code>
///
/// ```text
///  IOPMAssertionRetain
/// ```
///
/// </code>
/// must each be paired with calls to IOPMAssertionRelease.
///
///
/// Parameter `AssertionID`: The assertion_id, returned from IOPMAssertionCreate, to cancel.
///
///
/// Returns: Returns kIOReturnSuccess on success.
#[inline]
pub extern "C-unwind" fn IOPMAssertionRelease(assertion_id: IOPMAssertionID) -> IOReturn {
    extern "C-unwind" {
        fn IOPMAssertionRelease(assertion_id: IOPMAssertionID) -> IOReturn;
    }
    unsafe { IOPMAssertionRelease(assertion_id) }
}

/// Copies details about an `IOPMAssertion`
///
/// Parameters:
/// - theAssertion: The assertion ID to copy info about.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// A dictionary describing the assertion with keys specified in See [`IOPMAssertionDictionaryKeys`](https://developer.apple.com/documentation/iokit/iopmlib_h/iopmassertiondictionarykeys). It's the caller's responsibility to release this dictionary.
///
///
///
/// ## Discussion
///
/// Returns a dictionary describing an IOPMAssertion's specifications and current state.
///
///
/// Copies details about an
/// <code>
/// IOPMAssertion
/// </code>
/// .
///
/// Returns a dictionary describing an IOPMAssertion's specifications and current state.
///
/// Parameter `theAssertion`: The assertion ID to copy info about.
///
/// Returns: A dictionary describing the assertion with keys specified in See
///
/// ```text
///  IOPMAssertionDictionaryKeys
/// ```
///
/// .
/// It's the caller's responsibility to release this dictionary.
#[inline]
pub extern "C-unwind" fn IOPMAssertionCopyProperties(
    the_assertion: IOPMAssertionID,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn IOPMAssertionCopyProperties(
            the_assertion: IOPMAssertionID,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { IOPMAssertionCopyProperties(the_assertion) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Sets a property in the assertion.
    ///
    /// Parameters:
    /// - theAssertion: The [`IOPMAssertionID`](https://developer.apple.com/documentation/iokit/iopmassertionid) of the assertion to modify.
    ///
    /// - theProperty: The CFString key, from [`IOPMAssertionDictionaryKeys`](https://developer.apple.com/documentation/iokit/iopmlib_h/iopmassertiondictionarykeys) to modify.
    ///
    /// - theValue: The property to set. It must be a CFNumber or CFString, as specified by the property key named in whichProperty.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnNotPriviliged if the caller doesn't have permission to modify this assertion. Returns kIOReturnNotFound if PM can't locate this assertion. Returns kIOReturnError upon an unidentified error. Returns kIOReturnSuccess otherwise.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Only the process that created an assertion may change its properties.
    ///
    ///
    /// Sets a property in the assertion.
    ///
    /// Only the process that created an assertion may change its properties.
    ///
    /// Parameter `theAssertion`: The
    /// <code>
    ///
    /// ```text
    ///  IOPMAssertionID
    /// ```
    ///
    /// </code>
    /// of the assertion to modify.
    ///
    /// Parameter `theProperty`: The CFString key, from
    /// <code>
    ///
    /// ```text
    ///  IOPMAssertionDictionaryKeys
    /// ```
    ///
    /// </code>
    /// to modify.
    ///
    /// Parameter `theValue`: The property to set. The value must match the CF type expected for the specified key.
    ///
    /// Returns: Returns
    /// <code>
    ///
    /// ```text
    ///  kIOReturnNotPriviliged
    /// ```
    ///
    /// </code>
    /// if the caller doesn't
    /// have permission to modify this assertion.
    /// Returns
    /// <code>
    ///
    /// ```text
    ///  kIOReturnNotFound
    /// ```
    ///
    /// </code>
    /// if PM can't locate this assertion.
    /// Returns
    /// <code>
    ///
    /// ```text
    ///  kIOReturnError
    /// ```
    ///
    /// </code>
    /// upon an unidentified error.
    /// Returns
    /// <code>
    ///
    /// ```text
    ///  kIOReturnSuccess
    /// ```
    ///
    /// </code>
    /// otherwise.
    ///
    /// # Safety
    ///
    /// - `the_property` might not allow `None`.
    /// - `the_value` should be of the correct type.
    /// - `the_value` might not allow `None`.
    pub fn IOPMAssertionSetProperty(
        the_assertion: IOPMAssertionID,
        the_property: Option<&CFString>,
        the_value: Option<&CFType>,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Returns a dictionary listing all assertions, grouped by their owning process.
    ///
    /// Parameters:
    /// - AssertionsByPID: On success, this returns a dictionary of assertions per process. At the top level, keys to the CFDictionary are pids stored as CFNumbers (kCFNumberIntType). The value associated with each CFNumber pid is a CFArray of active assertions. Each entry in the CFArray is an assertion represented as a CFDictionary. See the keys kIOPMAssertionTypeKey and kIOPMAssertionLevelKey. Caller must CFRelease() this dictionary when done.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess on success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Notes: One process may have multiple assertions. Several processes may have asserted the same assertion to different levels.
    ///
    ///
    /// Returns a dictionary listing all assertions, grouped by their owning process.
    ///
    ///
    /// Notes: One process may have multiple assertions. Several processes may
    /// have asserted the same assertion to different levels.
    ///
    ///
    /// Parameter `AssertionsByPID`: On success, this returns a dictionary of assertions per process.
    /// At the top level, keys to the CFDictionary are pids stored as CFNumbers (kCFNumberIntType).
    /// The value associated with each CFNumber pid is a CFArray of active assertions.
    /// Each entry in the CFArray is an assertion represented as a CFDictionary. See the keys
    /// kIOPMAssertionTypeKey and kIOPMAssertionLevelKey.
    /// Caller must CFRelease() this dictionary when done.
    ///
    ///
    /// Returns: Returns kIOReturnSuccess on success.
    ///
    /// # Safety
    ///
    /// `assertions_by_pid` must be a valid pointer.
    pub fn IOPMCopyAssertionsByProcess(assertions_by_pid: *mut *const CFDictionary) -> IOReturn;
}

extern "C-unwind" {
    /// Returns a list of available assertions and their system-wide levels.
    ///
    /// Parameters:
    /// - AssertionsStatus: On success, this returns a CFDictionary of all assertions currently available. The keys in the dictionary are the assertion types, and the value of each is a CFNumber that represents the aggregate level for that assertion. Caller must CFRelease() this dictionary when done.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess on success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The system-wide level is the maximum of all individual assertions' levels.
    ///
    ///
    /// Returns a list of available assertions and their system-wide levels.
    ///
    ///
    /// The system-wide level is the maximum of all individual assertions' levels.
    ///
    ///
    /// Parameter `AssertionsStatus`: On success, this returns a CFDictionary of all assertions currently available.
    /// The keys in the dictionary are the assertion types, and the value of each is a CFNumber that
    /// represents the aggregate level for that assertion.  Caller must CFRelease() this dictionary when done.
    ///
    ///
    /// Returns: Returns      kIOReturnSuccess on success.
    ///
    /// # Safety
    ///
    /// `assertions_status` must be a valid pointer.
    pub fn IOPMCopyAssertionsStatus(assertions_status: *mut *const CFDictionary) -> IOReturn;
}

extern "C-unwind" {
    /// Dynamically requests a system behavior from the power management system.
    ///
    /// Parameters:
    /// - AssertionType: The CFString assertion type to request from the PM system.
    ///
    /// - AssertionLevel: Pass kIOPMAssertionLevelOn or kIOPMAssertionLevelOff.
    ///
    /// - AssertionID: On success, a unique id will be returned in this parameter.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess on success, any other return indicates PM could not successfully activate the specified assertion.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// No special privileges necessary to make this call - any process may activate a power assertion.
    ///
    ///
    /// This is a deprecated call to create a power assertion.
    ///
    ///
    /// ```text
    ///  IOPMAssertionCreateWithProperties
    /// ```
    ///
    /// </code>
    /// .
    /// Please use that version of this API instead.
    ///
    ///
    /// No special privileges necessary to make this call - any process may
    /// activate a power assertion.
    ///
    ///
    /// Parameter `AssertionType`: The CFString assertion type to request from the PM system.
    ///
    /// Parameter `AssertionLevel`: Pass kIOPMAssertionLevelOn or kIOPMAssertionLevelOff.
    ///
    /// Parameter `AssertionID`: On success, a unique id will be returned in this parameter.
    ///
    ///
    /// Returns: Returns kIOReturnSuccess on success, any other return indicates
    /// PM could not successfully activate the specified assertion.
    ///
    /// # Safety
    ///
    /// - `assertion_type` might not allow `None`.
    /// - `assertion_id` must be a valid pointer.
    #[deprecated]
    pub fn IOPMAssertionCreate(
        assertion_type: Option<&CFString>,
        assertion_level: IOPMAssertionLevel,
        assertion_id: *mut IOPMAssertionID,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Dynamically requests a system behavior from the power management system.
    ///
    /// Parameters:
    /// - AssertionType: The CFString assertion type to request from the PM system.
    ///
    /// - AssertionLevel: Pass kIOPMAssertionLevelOn or kIOPMAssertionLevelOff.
    ///
    /// - AssertionName: A string that describes the name of the caller and the activity being handled by this assertion (e.g. "Mail Compacting Mailboxes"). Name may be no longer than 128 characters.
    ///
    /// - AssertionID: On success, a unique id will be returned in this parameter.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess on success, any other return indicates PM could not successfully activate the specified assertion.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// No special privileges are necessary to make this call - any process may activate a power assertion. Caller must specify an AssertionName - NULL is not a valid input.
    ///
    ///
    /// The simplest API to create a power assertion.
    ///
    ///
    /// No special privileges are necessary to make this call - any process may
    /// activate a power assertion. Caller must specify an AssertionName - NULL is not
    /// a valid input.
    ///
    ///
    /// Parameter `AssertionType`: The CFString assertion type to request from the PM system.
    ///
    /// Parameter `AssertionLevel`: Pass kIOPMAssertionLevelOn or kIOPMAssertionLevelOff.
    ///
    /// Parameter `AssertionName`: A string that describes the name of the caller and the activity being
    /// handled by this assertion (e.g. "Mail Compacting Mailboxes"). Name may be no longer
    /// than 128 characters.
    ///
    ///
    /// Parameter `AssertionID`: On success, a unique id will be returned in this parameter.
    ///
    ///
    /// Returns: Returns kIOReturnSuccess on success, any other return indicates
    /// PM could not successfully activate the specified assertion.
    ///
    /// # Safety
    ///
    /// - `assertion_type` might not allow `None`.
    /// - `assertion_name` might not allow `None`.
    /// - `assertion_id` must be a valid pointer.
    pub fn IOPMAssertionCreateWithName(
        assertion_type: Option<&CFString>,
        assertion_level: IOPMAssertionLevel,
        assertion_name: Option<&CFString>,
        assertion_id: *mut IOPMAssertionID,
    ) -> IOReturn;
}

/// Return type for IOGetSystemLoadAdvisory
///
/// ## Discussion
///
/// Value is one of kIOSystemLoadAdvisoryLevelGreat, kIOSystemLoadAdvisoryLevelOK, or kIOSystemLoadAdvisoryLevelBad.
///
///
/// Return type for IOGetSystemLoadAdvisory
///
/// Value is one of kIOSystemLoadAdvisoryLevelGreat, kIOSystemLoadAdvisoryLevelOK,
/// or kIOSystemLoadAdvisoryLevelBad.
pub type IOSystemLoadAdvisoryLevel = c_int;

pub const kIOSystemLoadAdvisoryLevelBad: c_uint = 1;
pub const kIOSystemLoadAdvisoryLevelOK: c_uint = 2;
pub const kIOSystemLoadAdvisoryLevelGreat: c_uint = 3;

/// Returns a hint about whether now would be a good time to perform time-insensitive work.
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// IOSystemLoadAdvisoryLevel - one of: kIOSystemLoadAdvisoryLevelGreat - A Good time to perform time-insensitive work. kIOSystemLoadAdvisoryLevelOK - An OK time to perform time-insensitive work. kIOSystemLoadAdvisoryLevelBad - A Bad time to perform time-insensitive work.
///
///
///
/// ## Discussion
///
/// Based on user and system load, IOGetSystemLoadAdvisory determines "better" and "worse" times to run optional or time-insensitive CPU or disk work.
///
/// Applications may use this result to avoid degrading the user experience. If it is a "Bad" or "OK" time to perform work, applications should slow down and perform work less aggressively.
///
/// There is no guarantee that the system will ever be in "Great" condition to perform work - all essential work must still be performed even in "Bad", or "OK" times. Completely optional work, such as updating caches, may be postponed indefinitely.
///
/// Note: You may more efficiently read the SystemLoadAdvisory level using notify_get_state() instead of IOGetSystemLoadAdvisory. The results are identical. notify_get_state() requires that you pass the token argument received by registering for SystemLoadAdvisory notifications.
///
///
/// Returns a hint about whether now would be a good time to perform time-insensitive
/// work.
///
/// Based on user and system load, IOGetSystemLoadAdvisory determines "better" and "worse"
/// times to run optional or time-insensitive CPU or disk work.
///
/// Applications may use this result to avoid degrading the user experience. If it is a
/// "Bad" or "OK" time to perform work, applications should slow down and perform work
/// less aggressively.
///
/// There is no guarantee that the system will ever be in "Great" condition to perform work -
/// all essential work must still be performed even in "Bad", or "OK" times.
/// Completely optional work, such as updating caches, may be postponed indefinitely.
///
/// Note: You may more efficiently read the SystemLoadAdvisory level using notify_get_state() instead
/// of IOGetSystemLoadAdvisory. The results are identical. notify_get_state() requires that you
/// pass the token argument received by registering for SystemLoadAdvisory notifications.
///
///
/// Returns: IOSystemLoadAdvisoryLevel - one of:
/// <ul>
/// <li>
/// kIOSystemLoadAdvisoryLevelGreat - A Good time to perform time-insensitive work.
/// <li>
/// kIOSystemLoadAdvisoryLevelOK - An OK time to perform time-insensitive work.
/// <li>
/// kIOSystemLoadAdvisoryLevelBad - A Bad time to perform time-insensitive work.
/// </ul>
#[inline]
pub extern "C-unwind" fn IOGetSystemLoadAdvisory() -> IOSystemLoadAdvisoryLevel {
    extern "C-unwind" {
        fn IOGetSystemLoadAdvisory() -> IOSystemLoadAdvisoryLevel;
    }
    unsafe { IOGetSystemLoadAdvisory() }
}

/// Indicates how user activity, battery level, and thermal level each contribute to the overall "SystemLoadAdvisory" level. In the future, this combined level may represent new levels as well.
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// Returns a CFDictionaryRef, or NULL on error. Caller must release the returned dictionary.
///
///
///
/// ## Discussion
///
/// See dictionary keys defined above.
///
///
/// Indicates how user activity, battery level, and thermal level each
/// contribute to the overall "SystemLoadAdvisory" level. In the future,
/// this combined level may represent new levels as well.
///
/// See dictionary keys defined above.
///
/// Returns: Returns a CFDictionaryRef, or NULL on error. Caller must release the
/// returned dictionary.
#[inline]
pub extern "C-unwind" fn IOCopySystemLoadAdvisoryDetailed() -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn IOCopySystemLoadAdvisoryDetailed() -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { IOCopySystemLoadAdvisoryDetailed() };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Copy status of all current CPU power levels.
    ///
    /// Parameters:
    /// - cpuPowerStatus: Upon success, a pointer to a dictionary defining CPU power; otherwise NULL. Pointer will be populated with a newly created dictionary upon successful return. Caller must release dictionary.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// kIOReturnSuccess, or other error report. Returns kIOReturnNotFound if CPU PowerStatus has not been published.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The returned dictionary may define some of these keys, as defined in IOPM.h: - kIOPMCPUPowerLimitProcessorSpeedKey - kIOPMCPUPowerLimitProcessorCountKey - kIOPMCPUPowerLimitSchedulerTimeKey
    ///
    ///
    /// Copy status of all current CPU power levels.
    ///
    /// The returned dictionary may define some of these keys,
    /// as defined in IOPM.h:
    /// <ul>
    /// <li>
    /// kIOPMCPUPowerLimitProcessorSpeedKey
    /// <li>
    /// kIOPMCPUPowerLimitProcessorCountKey
    /// <li>
    /// kIOPMCPUPowerLimitSchedulerTimeKey
    /// </ul>
    ///
    /// Parameter `cpuPowerStatus`: Upon success, a pointer to a dictionary defining CPU power;
    /// otherwise NULL. Pointer will be populated with a newly created dictionary
    /// upon successful return. Caller must release dictionary.
    ///
    /// Returns: kIOReturnSuccess, or other error report. Returns kIOReturnNotFound if
    /// CPU PowerStatus has not been published.
    ///
    /// # Safety
    ///
    /// `cpu_power_status` must be a valid pointer.
    pub fn IOPMCopyCPUPowerStatus(cpu_power_status: *mut *const CFDictionary) -> IOReturn;
}

extern "C-unwind" {
    /// Get thermal warning level of the system.
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// kIOReturnSuccess, or other error report. Returns kIOReturnNotFound if thermal warning level has not been published.
    ///
    ///
    /// Get thermal warning level of the system.
    ///
    /// Returns: An integer pointer declaring the power warning level of the system.
    /// The value of the integer is one of (defined in IOPM.h):
    /// <ul>
    /// <li>
    /// kIOPMThermalWarningLevelNormal
    /// <li>
    /// kIOPMThermalWarningLevelDanger
    /// <li>
    /// kIOPMThermalWarningLevelCrisis
    /// </ul>
    /// Upon success the thermal level value will be found at the
    /// pointer argument.
    ///
    /// Returns: kIOReturnSuccess, or other error report. Returns kIOReturnNotFound if
    /// thermal warning level has not been published.
    ///
    /// # Safety
    ///
    /// `thermal_level` must be a valid pointer.
    pub fn IOPMGetThermalWarningLevel(thermal_level: *mut u32) -> IOReturn;
}
