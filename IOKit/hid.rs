//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

pub const kIOHIDPointerAccelerationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerAcceleration\0") };
pub const kIOHIDTrackpadScrollAccelerationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDTrackpadScrollAcceleration\0") };
pub const kIOHIDTrackpadAccelerationType: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDTrackpadAcceleration\0") };
pub const kIOHIDPointerAccelerationTypeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerAccelerationType\0") };
pub const kIOHIDMouseScrollAccelerationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDMouseScrollAcceleration\0") };
pub const kIOHIDMouseAccelerationTypeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDMouseAcceleration\0") };
pub const kIOHIDScrollAccelerationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollAcceleration\0") };
pub const kIOHIDScrollAccelerationTypeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollAccelerationType\0") };
pub const kIOHIDDigitizerTipThresholdKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DigitizerTipThreshold\0") };
pub const kIOHIDSurfaceDimensionsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"SurfaceDimensions\0") };
pub const kIOHIDWidthKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Width\0") };
pub const kIOHIDHeightKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Height\0") };
pub const kIOHIDEventDriverHandlesReport: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHIDEventDriverHandlesReport\0") };
pub const kIOHIDServiceAccelerationProperties: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHIDSetAcceleration\0") };
pub const kIOHIDPointerAccelerationMultiplierKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerAccelerationMultiplier\0") };
pub const kHIDPointerReportRateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerReportRate\0") };
pub const kIOHIDScrollReportRateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollReportRate\0") };
pub const kHIDAccelParametricCurvesKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelCurves\0") };
pub const kHIDScrollAccelParametricCurvesKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollAccelCurves\0") };
pub const kIOHIDScrollResolutionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollResolution\0") };
pub const kIOHIDDropAccelPropertyEventsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DropAccelPropertyEvents\0") };
pub const kIOHIDScrollResolutionXKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollResolutionX\0") };
pub const kIOHIDScrollResolutionYKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollResolutionY\0") };
pub const kIOHIDScrollResolutionZKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollResolutionZ\0") };
pub const kIOHIDUseLinearScalingMouseAccelerationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDUseLinearScalingMouseAcceleration\0") };
pub const kIOHIDPointerAccelerationSupportKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDSupportsPointerAcceleration\0") };
pub const kIOHIDScrollAccelerationSupportKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDSupportsScrollAcceleration\0") };
pub const kIOHIDEventServiceSensorControlOptionsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDDefaultSensorControlOptions\0") };
pub const kIOHIDMouseAccelerationType: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDMouseAcceleration\0") };
pub const kIOHIDPointerButtonMode: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerButtonMode\0") };
pub const kIOHIDPointerButtonModeKey: &CStr = kIOHIDPointerButtonMode;
pub const kIOHIDUserKeyUsageMapKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"UserKeyMapping\0") };
pub const kIOHIDKeyboardCapsLockDelayOverride: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CapsLockDelayOverride\0") };
pub const kIOHIDKeyboardCapsLockDelayOverrideKey: &CStr = kIOHIDKeyboardCapsLockDelayOverride;
pub const kIOHIDServiceEjectDelayKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"EjectDelay\0") };
pub const kIOHIDServiceLockKeyDelayKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"LockKeyDelay\0") };
pub const kIOHIDServiceInitialKeyRepeatDelayKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDInitialKeyRepeat\0") };
pub const kIOHIDServiceKeyRepeatDelayKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyRepeat\0") };
pub const kIOHIDIdleTimeMicrosecondsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDIdleTimeMicroseconds\0") };
pub const kIOHIDServiceCapsLockStateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDCapsLockState\0") };
pub const kIOHIDDeviceDefaultAsyncRequestTimeout: c_uint = 1000;
pub const kIOHIDDeviceMinAsyncRequestTimeout: c_uint = 50;
pub const kIOHIDDeviceMaxAsyncRequestTimeout: c_uint = 1200000;
/// A key for specifying the transport mechanism of the device.
///
/// ## Discussion
///
/// Keys that represent properties of a particular device. Can be added to your matching dictionary when refining searches for HID devices.
///
///
///
///
pub const kIOHIDTransportKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Transport\0") };
/// A key for specifying the vendor ID of the device.
///
/// ## Discussion
///
/// The value of this key is the numerical ID that the USB-IF assigned to the manufacturer.
///
///
///
///
pub const kIOHIDVendorIDKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"VendorID\0") };
/// A key for specifying the product identifier of the device.
///
/// ## Discussion
///
/// The value of this key is the numerical ID that the manufacturer assigned to the device.
///
///
///
///
pub const kIOHIDProductIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ProductID\0") };
/// A key for specifying the version number of the device.
///
/// ## Discussion
///
/// The value of this key is a number representing the device's version information.
///
///
///
///
pub const kIOHIDVersionNumberKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"VersionNumber\0") };
/// A key that specifies the manufacturer of the device.
///
/// ## Discussion
///
/// The value of this key is a string that contains the manufacturer's name.
///
///
///
///
pub const kIOHIDManufacturerKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Manufacturer\0") };
/// A key that describes the product.
///
/// ## Discussion
///
/// The value of this key is a string that describes the product.
///
///
///
///
pub const kIOHIDProductKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Product\0") };
/// A key that specifies the device's serial number.
///
/// ## Discussion
///
/// The value of this key is a string that contains the serial number of the device.
///
///
///
///
pub const kIOHIDSerialNumberKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"SerialNumber\0") };
/// A key that specifies the country code or region of the device.
///
/// ## Discussion
///
/// The value of this key is a number that identifies the country or region code stored in the device.
///
///
///
///
pub const kIOHIDCountryCodeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CountryCode\0") };
/// A key that specifies the location ID of the device.
///
/// ## Discussion
///
/// The value of this key is a number that contains the location identifier.
///
///
///
///
pub const kIOHIDLocationIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"LocationID\0") };
/// A key that contains the top-level usages of the device.
///
/// ## Discussion
///
/// The value of this key is an array of dictionaries. The keys and values of each dictionary are the usage pages and usages for which to match your driver. Use this key when the device supports multiple behaviors and you want to match your driver against more than one of these behaviors.
///
///
///
///
///
///
///
///
pub const kIOHIDDeviceUsagePairsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DeviceUsagePairs\0") };
/// A key that specifies a usage type of the device.
///
/// ## Discussion
///
/// The value of this key is the number for a HID usage type.
///
///
///
///
///
///
///
///
pub const kIOHIDDeviceUsageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DeviceUsage\0") };
/// A key that specifies a usage page of the device.
///
/// ## Discussion
///
/// The value of this key is the number for a HID usage page.
///
///
///
///
///
///
///
///
pub const kIOHIDDeviceUsagePageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DeviceUsagePage\0") };
/// A key that specifies the primary usage type of the device.
///
/// ## Discussion
///
/// The value of this key is the number for a HID usage type.
///
/// [`kIOHIDPrimaryUsageKey`](https://developer.apple.com/documentation/iokit/kiohidprimaryusagekey) and [`kIOHIDPrimaryUsagePageKey`](https://developer.apple.com/documentation/iokit/kiohidprimaryusagepagekey) are not always rich enough to describe a device’s capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. To support this more complicated scenario, use the following keys instead:
///
/// - [`kIOHIDDeviceUsageKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagekey)
///
/// - [`kIOHIDDeviceUsagePageKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagepagekey)
///
/// - [`kIOHIDDeviceUsagePairsKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagepairskey)
///
/// To match on only one criterion, add [`kIOHIDDeviceUsageKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagekey) and [`kIOHIDDeviceUsagePageKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagepagekey) to the matching dictionary. To match on multiple criteria, add [`kIOHIDDeviceUsagePairsKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagepairskey) to the matching dictionary.
///
///
///
///
///
///
///
///
pub const kIOHIDPrimaryUsageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PrimaryUsage\0") };
/// A key that specifies the primary usage page of the device.
///
/// ## Discussion
///
/// The value of this key is the number for a HID usage page.
///
/// [`kIOHIDPrimaryUsageKey`](https://developer.apple.com/documentation/iokit/kiohidprimaryusagekey) and [`kIOHIDPrimaryUsagePageKey`](https://developer.apple.com/documentation/iokit/kiohidprimaryusagepagekey) are not always rich enough to describe a device’s capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. To support this more complicated scenario, use the following keys instead:
///
/// - [`kIOHIDDeviceUsageKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagekey)
///
/// - [`kIOHIDDeviceUsagePageKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagepagekey)
///
/// - [`kIOHIDDeviceUsagePairsKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagepairskey)
///
/// To match on only one criterion, add [`kIOHIDDeviceUsageKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagekey) and [`kIOHIDDeviceUsagePageKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagepagekey) to the matching dictionary. To match on multiple criteria, add [`kIOHIDDeviceUsagePairsKey`](https://developer.apple.com/documentation/iokit/kiohiddeviceusagepairskey) to the matching dictionary.
///
///
///
///
///
///
pub const kIOHIDPrimaryUsagePageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PrimaryUsagePage\0") };
/// Keys that represent properties of a paticular device.
///
/// ## Discussion
///
/// Keys that represent properties of a paticular device. Can be added to your matching dictionary when refining searches for HID devices.
///
/// **Please note:**
///
/// kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer rich enough to describe a device's capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. The previous behavior was to only describe the keyboard behavior with the primary usage and usage page. Needless to say, this would sometimes cause a program interested in mice to skip this device when matching.
///
/// Thus we have added 3 additional keys:
///
/// - kIOHIDDeviceUsageKey
///
/// - kIOHIDDeviceUsagePageKey
///
/// - kIOHIDDeviceUsagePairsKey
///
/// kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey. These usage pairs describe all application type collections (behaviors) defined by the device.
///
/// An application intersted in only matching on one criteria would only add the kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary. If it is interested in a device that has multiple behaviors, the application would instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his matching dictionary.
///
///
pub const kIOHIDMaxInputReportSizeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MaxInputReportSize\0") };
/// Keys that represent properties of a paticular device.
///
/// ## Discussion
///
/// Keys that represent properties of a paticular device. Can be added to your matching dictionary when refining searches for HID devices.
///
/// **Please note:**
///
/// kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer rich enough to describe a device's capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. The previous behavior was to only describe the keyboard behavior with the primary usage and usage page. Needless to say, this would sometimes cause a program interested in mice to skip this device when matching.
///
/// Thus we have added 3 additional keys:
///
/// - kIOHIDDeviceUsageKey
///
/// - kIOHIDDeviceUsagePageKey
///
/// - kIOHIDDeviceUsagePairsKey
///
/// kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey. These usage pairs describe all application type collections (behaviors) defined by the device.
///
/// An application intersted in only matching on one criteria would only add the kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary. If it is interested in a device that has multiple behaviors, the application would instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his matching dictionary.
///
///
pub const kIOHIDMaxOutputReportSizeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MaxOutputReportSize\0") };
/// Keys that represent properties of a paticular device.
///
/// ## Discussion
///
/// Keys that represent properties of a paticular device. Can be added to your matching dictionary when refining searches for HID devices.
///
/// **Please note:**
///
/// kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer rich enough to describe a device's capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. The previous behavior was to only describe the keyboard behavior with the primary usage and usage page. Needless to say, this would sometimes cause a program interested in mice to skip this device when matching.
///
/// Thus we have added 3 additional keys:
///
/// - kIOHIDDeviceUsageKey
///
/// - kIOHIDDeviceUsagePageKey
///
/// - kIOHIDDeviceUsagePairsKey
///
/// kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey. These usage pairs describe all application type collections (behaviors) defined by the device.
///
/// An application intersted in only matching on one criteria would only add the kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary. If it is interested in a device that has multiple behaviors, the application would instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his matching dictionary.
///
///
pub const kIOHIDMaxFeatureReportSizeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MaxFeatureReportSize\0") };
/// Keys that represent properties of a paticular device.
///
/// ## Discussion
///
/// Keys that represent properties of a paticular device. Can be added to your matching dictionary when refining searches for HID devices.
///
/// **Please note:**
///
/// kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer rich enough to describe a device's capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. The previous behavior was to only describe the keyboard behavior with the primary usage and usage page. Needless to say, this would sometimes cause a program interested in mice to skip this device when matching.
///
/// Thus we have added 3 additional keys:
///
/// - kIOHIDDeviceUsageKey
///
/// - kIOHIDDeviceUsagePageKey
///
/// - kIOHIDDeviceUsagePairsKey
///
/// kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey. These usage pairs describe all application type collections (behaviors) defined by the device.
///
/// An application intersted in only matching on one criteria would only add the kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary. If it is interested in a device that has multiple behaviors, the application would instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his matching dictionary.
///
///
pub const kIOHIDReportIntervalKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ReportInterval\0") };
pub const kIOHIDBatchIntervalKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BatchInterval\0") };
pub const kIOHIDRequestTimeoutKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"RequestTimeout\0") };
/// Keys that represent properties of a paticular device.
///
/// ## Discussion
///
/// Keys that represent properties of a paticular device. Can be added to your matching dictionary when refining searches for HID devices.
///
/// **Please note:**
///
/// kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer rich enough to describe a device's capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. The previous behavior was to only describe the keyboard behavior with the primary usage and usage page. Needless to say, this would sometimes cause a program interested in mice to skip this device when matching.
///
/// Thus we have added 3 additional keys:
///
/// - kIOHIDDeviceUsageKey
///
/// - kIOHIDDeviceUsagePageKey
///
/// - kIOHIDDeviceUsagePairsKey
///
/// kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey. These usage pairs describe all application type collections (behaviors) defined by the device.
///
/// An application intersted in only matching on one criteria would only add the kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary. If it is interested in a device that has multiple behaviors, the application would instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his matching dictionary.
///
///
pub const kIOHIDReportDescriptorKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ReportDescriptor\0") };
pub const kIOHIDBuiltInKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Built-In\0") };
pub const kIOHIDPhysicalDeviceUniqueIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PhysicalDeviceUniqueID\0") };
pub const kIOHIDDeviceAccessEntitlementKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDDeviceAccessEntitlement\0") };
pub const kIOHIDDeviceKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHIDDevice\0") };
/// Keys that represent properties of a paticular device.
///
/// ## Discussion
///
/// Keys that represent properties of a paticular device. Can be added to your matching dictionary when refining searches for HID devices.
///
/// **Please note:**
///
/// kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer rich enough to describe a device's capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. The previous behavior was to only describe the keyboard behavior with the primary usage and usage page. Needless to say, this would sometimes cause a program interested in mice to skip this device when matching.
///
/// Thus we have added 3 additional keys:
///
/// - kIOHIDDeviceUsageKey
///
/// - kIOHIDDeviceUsagePageKey
///
/// - kIOHIDDeviceUsagePairsKey
///
/// kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey. These usage pairs describe all application type collections (behaviors) defined by the device.
///
/// An application intersted in only matching on one criteria would only add the kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary. If it is interested in a device that has multiple behaviors, the application would instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his matching dictionary.
///
///
pub const kIOHIDVendorIDSourceKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"VendorIDSource\0") };
/// Keys that represent properties of a paticular device.
///
/// ## Discussion
///
/// Keys that represent properties of a paticular device. Can be added to your matching dictionary when refining searches for HID devices.
///
/// **Please note:**
///
/// kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer rich enough to describe a device's capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. The previous behavior was to only describe the keyboard behavior with the primary usage and usage page. Needless to say, this would sometimes cause a program interested in mice to skip this device when matching.
///
/// Thus we have added 3 additional keys:
///
/// - kIOHIDDeviceUsageKey
///
/// - kIOHIDDeviceUsagePageKey
///
/// - kIOHIDDeviceUsagePairsKey
///
/// kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey. These usage pairs describe all application type collections (behaviors) defined by the device.
///
/// An application intersted in only matching on one criteria would only add the kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary. If it is interested in a device that has multiple behaviors, the application would instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his matching dictionary.
///
///
pub const kIOHIDStandardTypeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"StandardType\0") };
pub const kIOHIDSampleIntervalKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"SampleInterval\0") };
/// Keys that represent properties of a paticular device.
///
/// ## Discussion
///
/// Keys that represent properties of a paticular device. Can be added to your matching dictionary when refining searches for HID devices.
///
/// **Please note:**
///
/// kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer rich enough to describe a device's capabilities. Take, for example, a device that describes both a keyboard and a mouse in the same descriptor. The previous behavior was to only describe the keyboard behavior with the primary usage and usage page. Needless to say, this would sometimes cause a program interested in mice to skip this device when matching.
///
/// Thus we have added 3 additional keys:
///
/// - kIOHIDDeviceUsageKey
///
/// - kIOHIDDeviceUsagePageKey
///
/// - kIOHIDDeviceUsagePairsKey
///
/// kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey. These usage pairs describe all application type collections (behaviors) defined by the device.
///
/// An application intersted in only matching on one criteria would only add the kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary. If it is interested in a device that has multiple behaviors, the application would instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his matching dictionary.
///
///
pub const kIOHIDResetKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Reset\0") };
pub const kIOHIDKeyboardLanguageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"KeyboardLanguage\0") };
pub const kIOHIDAltHandlerIdKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"alt_handler_id\0") };
pub const kIOHIDDisplayIntegratedKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayIntegrated\0") };
pub const kIOHIDProductIDMaskKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ProductIDMask\0") };
pub const kIOHIDProductIDArrayKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ProductIDArray\0") };
pub const kIOHIDPowerOnDelayNSKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPowerOnDelayNS\0") };
pub const kIOHIDCategoryKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Category\0") };
pub const kIOHIDMaxResponseLatencyKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MaxResponseLatency\0") };
pub const kIOHIDUniqueIDKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"UniqueID\0") };
pub const kIOHIDModelNumberKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ModelNumber\0") };
pub const kIOHIDTransportUSBValue: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"USB\0") };
pub const kIOHIDTransportBluetoothValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Bluetooth\0") };
pub const kIOHIDTransportBluetoothLowEnergyValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BluetoothLowEnergy\0") };
pub const kIOHIDTransportAIDBValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AID\0") };
pub const kIOHIDTransportI2CValue: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"I2C\0") };
pub const kIOHIDTransportSPIValue: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"SPI\0") };
pub const kIOHIDTransportSerialValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Serial\0") };
pub const kIOHIDTransportIAPValue: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"iAP\0") };
pub const kIOHIDTransportAirPlayValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AirPlay\0") };
pub const kIOHIDTransportSPUValue: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"SPU\0") };
pub const kIOHIDTransportBTAACPValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BT-AACP\0") };
pub const kIOHIDTransportFIFOValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"FIFO\0") };
pub const kIOHIDTransportVirtualValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Virtual\0") };
pub const kIOHIDTransportInductiveInBandValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Inductive In-Band\0") };
pub const kIOHIDCategoryAutomotiveValue: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Automotive\0") };
/// Keys that represents an element property.
///
/// ## Discussion
///
/// Property for a HID Device or element dictionary. Elements can be heirarchical, so they can contain other elements.
///
///
pub const kIOHIDElementKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Elements\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementCookieKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ElementCookie\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementTypeKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Type\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementCollectionTypeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CollectionType\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementUsageKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Usage\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementUsagePageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"UsagePage\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementMinKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Min\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementMaxKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Max\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementScaledMinKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ScaledMin\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementScaledMaxKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ScaledMax\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementSizeKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Size\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementReportSizeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ReportSize\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementReportCountKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ReportCount\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementReportIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ReportID\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementIsArrayKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IsArray\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementIsRelativeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IsRelative\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementIsWrappingKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IsWrapping\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementIsNonLinearKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IsNonLinear\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementHasPreferredStateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HasPreferredState\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementHasNullStateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HasNullState\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementFlagsKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Flags\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementUnitKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Unit\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementUnitExponentKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"UnitExponent\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementNameKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Name\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementValueLocationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ValueLocation\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementDuplicateIndexKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DuplicateIndex\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementParentCollectionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ParentCollection\0") };
pub const kIOHIDElementVariableSizeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"VariableSize\0") };
/// Keys that represent properties of a particular elements.
///
/// ## Discussion
///
/// These keys can also be added to a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementVendorSpecificKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"VendorSpecific\0") };
/// Keys used for matching particular elements.
///
/// ## Discussion
///
/// These keys should only be used with a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementCookieMinKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ElementCookieMin\0") };
/// Keys used for matching particular elements.
///
/// ## Discussion
///
/// These keys should only be used with a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementCookieMaxKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ElementCookieMax\0") };
/// Keys used for matching particular elements.
///
/// ## Discussion
///
/// These keys should only be used with a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementUsageMinKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"UsageMin\0") };
/// Keys used for matching particular elements.
///
/// ## Discussion
///
/// These keys should only be used with a matching dictionary when searching for elements via copyMatchingElements.
///
///
pub const kIOHIDElementUsageMaxKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"UsageMax\0") };
/// The minimum bounds for a calibrated value.
pub const kIOHIDElementCalibrationMinKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CalibrationMin\0") };
/// The maximum bounds for a calibrated value.
pub const kIOHIDElementCalibrationMaxKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CalibrationMax\0") };
/// The mininum tolerance to be used when calibrating a logical element value.
///
/// ## Discussion
///
/// The saturation property is used to allow for slight differences in the minimum and maximum value returned by an element.
///
///
pub const kIOHIDElementCalibrationSaturationMinKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CalibrationSaturationMin\0") };
/// The maximum tolerance to be used when calibrating a logical element value.
///
/// ## Discussion
///
/// The saturation property is used to allow for slight differences in the minimum and maximum value returned by an element.
///
///
pub const kIOHIDElementCalibrationSaturationMaxKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CalibrationSaturationMax\0") };
/// The minimum bounds near the midpoint of a logical value in which the value is ignored.
///
/// ## Discussion
///
/// The dead zone property is used to allow for slight differences in the idle value returned by an element.
///
///
pub const kIOHIDElementCalibrationDeadZoneMinKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CalibrationDeadZoneMin\0") };
/// The maximum bounds near the midpoint of a logical value in which the value is ignored.
///
/// ## Discussion
///
/// The dead zone property is used to allow for slight differences in the idle value returned by an element.
///
///
pub const kIOHIDElementCalibrationDeadZoneMaxKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CalibrationDeadZoneMax\0") };
/// The scale or level of detail returned in a calibrated element value.
///
/// ## Discussion
///
/// Values are rounded off such that if granularity=0.1, values after calibration are 0, 0.1, 0.2, 0.3, etc.
///
///
pub const kIOHIDElementCalibrationGranularityKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CalibrationGranularity\0") };
pub const kIOHIDKeyboardSupportsEscKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardSupportsEscKey\0") };
pub const kIOHIDKeyboardSupportsDoNotDisturbKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardSupportsDoNotDisturbKey\0") };
pub const kIOHIDDigitizerGestureCharacterStateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DigitizerCharacterGestureState\0") };
pub const kIOHIDSystemButtonPressedDuringDarkBoot: c_uint =
    iokit_family_msg!(sub_iokit_hidsystem, 7);
pub const kIOHIDKeyboardCapsLockDelay: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CapsLockDelay\0") };
pub const kIOHIDKeyboardEjectDelay: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"EjectDelay\0") };
pub const kFnFunctionUsageMapKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"FnFunctionUsageMap\0") };
pub const kFnKeyboardUsageMapKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"FnKeyboardUsageMap\0") };
pub const kNumLockKeyboardUsageMapKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"NumLockKeyboardUsageMap\0") };
pub const kKeyboardUsageMapKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"KeyboardUsageMap\0") };
pub const kIOHIDDeviceOpenedByEventSystemKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DeviceOpenedByEventSystem\0") };
pub const kIOHIDDeviceSuspendKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHIDDeviceSuspend\0") };
pub const kIOHIDMaxReportBufferCountKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MaxReportBufferCount\0") };
pub const kIOHIDReportBufferEntrySizeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ReportBufferEntrySize\0") };
pub const kIOHIDSensorPropertyReportIntervalKey: &CStr = kIOHIDReportIntervalKey;
pub const kIOHIDSensorPropertySampleIntervalKey: &CStr = kIOHIDSampleIntervalKey;
pub const kIOHIDSensorPropertyBatchIntervalKey: &CStr = kIOHIDBatchIntervalKey;
pub const kIOHIDSensorPropertyReportLatencyKey: &CStr = kIOHIDSensorPropertyBatchIntervalKey;
pub const kIOHIDSensorPropertyMaxFIFOEventsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"MaxFIFOEvents\0") };
pub const kIOHIDDigitizerSurfaceSwitchKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DigitizerSurfaceSwitch\0") };
pub const kIOHIDKeyboardLayoutValueKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardLayoutValue\0") };
pub const kIOHIDPointerAccelerationAlgorithmKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerAccelerationAlgorithm\0") };
pub const kIOHIDScrollAccelerationAlgorithmKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollAccelerationAlgorithm\0") };
pub const kIOHIDPointerAccelerationMinimumKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerAccelerationMinimum\0") };
pub const kIOHIDPrimaryTrackpadCanBeDisabledKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PrimaryTrackpadCanBeDisabled\0") };
pub const kIOHIDKeyboardFunctionKeyCountKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardFunctionKeyCount\0") };
/// Describes different type of HID reports.
///
/// ## Overview
///
/// Used by the IOHIDFamily to identify the type of report being processed.
///
///
/// Describes different type of HID reports.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOHIDReportType(pub c_uint);
impl IOHIDReportType {
    ///
    /// ## Discussion
    ///
    /// Input report.
    ///
    ///
    #[doc(alias = "kIOHIDReportTypeInput")]
    pub const Input: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// Output report.
    ///
    ///
    #[doc(alias = "kIOHIDReportTypeOutput")]
    pub const Output: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// Feature report.
    ///
    ///
    #[doc(alias = "kIOHIDReportTypeFeature")]
    pub const Feature: Self = Self(2);
    #[doc(alias = "kIOHIDReportTypeCount")]
    pub const Count: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDReportType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDReportType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Commit direction passed in to the commit() function of an IOHIDElement.
///
/// Field: kIOHIDElementCommitDirectionIn
/// Passing in kIOHIDElementCommitDirectionIn will issue a getReport call to the
/// device, and the element  will be updated with the value retrieved by the
/// device. The value can be accessed via the getValue() or getDataValue()
/// functions.
///
/// Field: kIOHIDElementCommitDirectionOut
/// Passing in kIOHIDElementCommitDirectionOut will issue a setReport call to the
/// device. Before issuing this call, the desired value should be set on the
/// element with the setValue() or setDataValue() functions.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOHIDElementCommitDirection(pub c_uint);
impl IOHIDElementCommitDirection {
    #[doc(alias = "kIOHIDElementCommitDirectionIn")]
    pub const In: Self = Self(0);
    #[doc(alias = "kIOHIDElementCommitDirectionOut")]
    pub const Out: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDElementCommitDirection {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDElementCommitDirection {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Abstract data type used as a unique identifier for an element.
/// Abstract data type used as a unique identifier for an element.
pub type IOHIDElementCookie = u32;

/// Describes different types of HID elements.
///
/// ## Overview
///
/// Used by the IOHIDFamily to identify the type of element processed. Represented by the key kIOHIDElementTypeKey in the dictionary describing the element.
///
///
/// Describes different types of HID elements.
///
///
/// Used by the IOHIDFamily to identify the type of element processed.
/// Represented by the key kIOHIDElementTypeKey in the dictionary describing the
/// element.
///
/// Field: kIOHIDElementTypeInput_Misc
/// Misc input data field or varying size.
///
/// Field: kIOHIDElementTypeInput_Button
/// One bit input data field.
///
/// Field: kIOHIDElementTypeInput_Axis
/// Input data field used to represent an axis.
///
/// Field: kIOHIDElementTypeInput_ScanCodes
/// Input data field used to represent a scan code or usage selector.
///
/// Field: kIOHIDElementTypeInput_NULL
/// Input data field used to represent the end of an input report when receiving
/// input elements.
///
/// Field: kIOHIDElementTypeOutput
/// Used to represent an output data field in a report.
///
/// Field: kIOHIDElementTypeFeature
/// Describes input and output elements not intended for consumption by the end
/// user.
///
/// Field: kIOHIDElementTypeCollection
/// Element used to identify a relationship between two or more elements.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDElementType(pub c_uint);
impl IOHIDElementType {
    ///
    /// ## Discussion
    ///
    /// Misc input data field or varying size.
    ///
    ///
    #[doc(alias = "kIOHIDElementTypeInput_Misc")]
    pub const Input_Misc: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// One bit input data field.
    ///
    ///
    #[doc(alias = "kIOHIDElementTypeInput_Button")]
    pub const Input_Button: Self = Self(2);
    ///
    /// ## Discussion
    ///
    /// Input data field used to represent an axis.
    ///
    ///
    #[doc(alias = "kIOHIDElementTypeInput_Axis")]
    pub const Input_Axis: Self = Self(3);
    ///
    /// ## Discussion
    ///
    /// Input data field used to represent a scan code or usage selector.
    ///
    ///
    #[doc(alias = "kIOHIDElementTypeInput_ScanCodes")]
    pub const Input_ScanCodes: Self = Self(4);
    #[doc(alias = "kIOHIDElementTypeInput_NULL")]
    pub const Input_NULL: Self = Self(5);
    ///
    /// ## Discussion
    ///
    /// Used to represent an output data field in a report.
    ///
    ///
    #[doc(alias = "kIOHIDElementTypeOutput")]
    pub const Output: Self = Self(129);
    ///
    /// ## Discussion
    ///
    /// Describes input and output elements not intended for consumption by the end user.
    ///
    ///
    #[doc(alias = "kIOHIDElementTypeFeature")]
    pub const Feature: Self = Self(257);
    ///
    /// ## Discussion
    ///
    /// Element used to identify a relationship between two or more elements.
    ///
    ///
    #[doc(alias = "kIOHIDElementTypeCollection")]
    pub const Collection: Self = Self(513);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDElementType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDElementType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kIOHIDElementFlagsConstantMask: c_uint = 0x0001;
pub const kIOHIDElementFlagsVariableMask: c_uint = 0x0002;
pub const kIOHIDElementFlagsRelativeMask: c_uint = 0x0004;
pub const kIOHIDElementFlagsWrapMask: c_uint = 0x0008;
pub const kIOHIDElementFlagsNonLinearMask: c_uint = 0x0010;
pub const kIOHIDElementFlagsNoPreferredMask: c_uint = 0x0020;
pub const kIOHIDElementFlagsNullStateMask: c_uint = 0x0040;
pub const kIOHIDElementFlagsVolativeMask: c_uint = 0x0080;
pub const kIOHIDElementFlagsBufferedByteMask: c_uint = 0x0100;

pub type IOHIDElementFlags = u32;

/// Describes different types of HID collections.
///
/// ## Overview
///
/// Collections identify a relationship between two or more elements.
///
///
/// Describes different types of HID collections.
///
///
/// Collections identify a relationship between two or more elements.
///
/// Field: kIOHIDElementCollectionTypePhysical
/// Used for a set of data items that represent data points collected at one
/// geometric point.
///
/// Field: kIOHIDElementCollectionTypeApplication
/// Identifies item groups serving different purposes in a single device.
///
/// Field: kIOHIDElementCollectionTypeLogical
/// Used when a set of data items form a composite data structure.
///
/// Field: kIOHIDElementCollectionTypeReport
/// Wraps all the fields in a report.
///
/// Field: kIOHIDElementCollectionTypeNamedArray
/// Contains an array of selector usages.
///
/// Field: kIOHIDElementCollectionTypeUsageSwitch
/// Modifies the meaning of the usage it contains.
///
/// Field: kIOHIDElementCollectionTypeUsageModifier
/// Modifies the meaning of the usage attached to the encompassing collection.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOHIDElementCollectionType(pub c_uint);
impl IOHIDElementCollectionType {
    ///
    /// ## Discussion
    ///
    /// Used for a set of data items that represent data points collected at one geometric point.
    ///
    ///
    #[doc(alias = "kIOHIDElementCollectionTypePhysical")]
    pub const Physical: Self = Self(0x00);
    ///
    /// ## Discussion
    ///
    /// Identifies item groups serving different purposes in a single device.
    ///
    ///
    #[doc(alias = "kIOHIDElementCollectionTypeApplication")]
    pub const Application: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// Used when a set of data items form a composite data structure.
    ///
    ///
    #[doc(alias = "kIOHIDElementCollectionTypeLogical")]
    pub const Logical: Self = Self(2);
    ///
    /// ## Discussion
    ///
    /// Wraps all the fields in a report.
    ///
    ///
    #[doc(alias = "kIOHIDElementCollectionTypeReport")]
    pub const Report: Self = Self(3);
    ///
    /// ## Discussion
    ///
    /// Contains an array of selector usages.
    ///
    ///
    #[doc(alias = "kIOHIDElementCollectionTypeNamedArray")]
    pub const NamedArray: Self = Self(4);
    ///
    /// ## Discussion
    ///
    /// Modifies the meaning of the usage it contains.
    ///
    ///
    #[doc(alias = "kIOHIDElementCollectionTypeUsageSwitch")]
    pub const UsageSwitch: Self = Self(5);
    ///
    /// ## Discussion
    ///
    /// Modifies the meaning of the usage attached to the encompassing collection.
    ///
    ///
    #[doc(alias = "kIOHIDElementCollectionTypeUsageModifier")]
    pub const UsageModifier: Self = Self(6);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDElementCollectionType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDElementCollectionType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Discussion
///
/// Type for value that is scaled with respect to the calibration properties.
///
///
pub const kIOHIDValueScaleTypeCalibrated: c_uint = 0;
///
/// ## Discussion
///
/// Type for value that is scaled with respect to the physical min and physical max of the element.
///
///
pub const kIOHIDValueScaleTypePhysical: c_uint = 1;
pub const kIOHIDValueScaleTypeExponent: c_uint = 2;

/// Describes different types of scaling that can be performed on element values.
pub type IOHIDValueScaleType = u32;

pub const kIOHIDValueOptionsFlagRelativeSimple: c_uint = 1 << 0;
pub const kIOHIDValueOptionsFlagPrevious: c_uint = 1 << 1;
pub const kIOHIDValueOptionsUpdateElementValues: c_uint = 1 << 2;

/// Describes options for gathering element values.
pub type IOHIDValueOptions = u32;

/// Function called when set/get report completes
///
///
/// Parameter `target`: The target specified in the IOHIDCompletion struct.
///
///
/// Parameter `parameter`: The parameter specified in the IOHIDCompletion struct.
///
///
/// Parameter `status`: Completion status
pub type IOHIDCompletionAction =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *mut c_void, IOReturn, u32)>;

/// Struct specifying action to perform when set/get report completes.
///
///
/// The target to pass to the action function.
///
///
/// The function to call.
///
///
/// The parameter to pass to the action function.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDCompletion {
    pub target: *mut c_void,
    pub action: IOHIDCompletionAction,
    pub parameter: *mut c_void,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDCompletion {
    const ENCODING: Encoding = Encoding::Struct(
        "IOHIDCompletion",
        &[
            <*mut c_void>::ENCODING,
            <IOHIDCompletionAction>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDCompletion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Discussion
///
/// Tells method that the report passed was not interrupt driven.
///
///
pub const kIOHIDReportOptionNotInterrupt: c_uint = 0x100;
pub const kIOHIDReportOptionVariableSize: c_uint = 0x200;

/// Type of the report command for DriverKit driver
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct HIDReportCommandType(pub c_uint);
impl HIDReportCommandType {
    #[doc(alias = "kIOHIDReportCommandSetReport")]
    pub const IOHIDReportCommandSetReport: Self = Self(0);
    #[doc(alias = "kIOHIDReportCommandGetReport")]
    pub const IOHIDReportCommandGetReport: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for HIDReportCommandType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for HIDReportCommandType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Discussion
///
/// Default option.
///
///
pub const kIOHIDOptionsTypeNone: c_uint = 0x00;
///
/// ## Discussion
///
/// Used to open exclusive communication with the device. This will prevent the system and other clients from receiving events from the device.
///
///
pub const kIOHIDOptionsTypeSeizeDevice: c_uint = 0x01;
pub const kIOHIDOptionsTypeMaskPrivate: c_uint = 0xff0000;

/// Options for opening a device via IOHIDLib.
pub type IOHIDOptionsType = u32;

///
/// ## Discussion
///
/// Default option.
///
///
pub const kIOHIDQueueOptionsTypeNone: c_uint = 0x00;
///
/// ## Discussion
///
/// Force the IOHIDQueue to enqueue all events, relative or absolute, regardless of change.
///
///
pub const kIOHIDQueueOptionsTypeEnqueueAll: c_uint = 0x01;

/// Options for creating a queue via IOHIDLib.
pub type IOHIDQueueOptionsType = u32;

///
/// ## Discussion
///
/// ANSI.
///
///
pub const kIOHIDStandardTypeANSI: c_uint = 0x0;
///
/// ## Discussion
///
/// ISO.
///
///
pub const kIOHIDStandardTypeISO: c_uint = 0x1;
///
/// ## Discussion
///
/// JIS.
///
///
pub const kIOHIDStandardTypeJIS: c_uint = 0x2;
pub const kIOHIDStandardTypeUnspecified: c_uint = 0xFFFFFFFF;

/// Type to define what industrial standard the device is referencing.
pub type IOHIDStandardType = u32;

pub const kIOHIDKeyboardPhysicalLayoutTypeUnknown: c_uint = 0x0;
pub const kIOHIDKeyboardPhysicalLayoutType101: c_uint = 0x1;
pub const kIOHIDKeyboardPhysicalLayoutType103: c_uint = 0x2;
pub const kIOHIDKeyboardPhysicalLayoutType102: c_uint = 0x3;
pub const kIOHIDKeyboardPhysicalLayoutType104: c_uint = 0x4;
pub const kIOHIDKeyboardPhysicalLayoutType106: c_uint = 0x5;
pub const kIOHIDKeyboardPhysicalLayoutTypeVendor: c_uint = 0x6;

pub type IOHIDKeyboardPhysicalLayoutType = u32;

pub const kIOHIDAccelerationAlgorithmTypeTable: c_uint = 0;
pub const kIOHIDAccelerationAlgorithmTypeParametric: c_uint = 1;
pub const kIOHIDAccelerationAlgorithmTypeDefault: c_uint = 2;

pub type IOHIDAccelerationAlgorithmType = u8;

/// This is the type of a reference to the IOHIDDevice.
#[doc(alias = "IOHIDDeviceRef")]
#[repr(C)]
pub struct IOHIDDevice {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl IOHIDDevice {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__IOHIDDevice"> for IOHIDDevice {}
);

/// This is the type of a reference to the IOHIDElement.
#[doc(alias = "IOHIDElementRef")]
#[repr(C)]
pub struct IOHIDElement {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl IOHIDElement {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__IOHIDElement"> for IOHIDElement {}
);

/// This is the type of a reference to the IOHIDValue.
#[doc(alias = "IOHIDValueRef")]
#[repr(C)]
pub struct IOHIDValue {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl IOHIDValue {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__IOHIDValue"> for IOHIDValue {}
);

/// Direction for an IOHIDDeviceTransactionInterface.
/// Direction for an IOHIDDeviceTransactionInterface.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOHIDTransactionDirectionType(pub u32);
impl IOHIDTransactionDirectionType {
    ///
    /// ## Discussion
    ///
    /// Transaction direction used for requesting element values from a device.
    ///
    ///
    #[doc(alias = "kIOHIDTransactionDirectionTypeInput")]
    pub const Input: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// Transaction direction used for dispatching element values to a device.
    ///
    ///
    #[doc(alias = "kIOHIDTransactionDirectionTypeOutput")]
    pub const Output: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDTransactionDirectionType {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDTransactionDirectionType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Discussion
///
/// Option to set the default element value to be used with an IOHIDDeviceTransactionInterface of direction kIOHIDTransactionDirectionTypeOutput.
///
///
/// Options to be used in conjuntion with an IOHIDDeviceTransactionInterface.
///
/// IOHIDDeviceTransactionInterface of direction kIOHIDTransactionDirectionTypeOutput.
pub static kIOHIDTransactionOptionDefaultOutputValue: IOOptionBits = 0x0001;

///
/// Parameters:
/// - context: void * pointer to your data, often a pointer to an object.
///
/// - result: Completion result of desired operation.
///
/// - refcon: void * pointer to more data.
///
/// - sender: Interface instance sending the completion routine.
///
///
/// ## Discussion
///
/// Type and arguments of callout C function that is used when a completion routine is called.
///
///
/// Type and arguments of callout C function that is used when a completion routine is called.
///
/// Parameter `context`: void * pointer to your data, often a pointer to an object.
///
/// Parameter `result`: Completion result of desired operation.
///
/// Parameter `sender`: Interface instance sending the completion routine.
pub type IOHIDCallback = Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn, *mut c_void)>;

///
/// Parameters:
/// - context: void * pointer to your data, often a pointer to an object.
///
/// - result: Completion result of desired operation.
///
/// - refcon: void * pointer to more data.
///
/// - sender: Interface instance sending the completion routine.
///
/// - type: The type of the report that was completed.
///
/// - reportID: The ID of the report that was completed.
///
/// - report: Pointer to the buffer containing the contents of the report.
///
/// - reportLength: Size of the buffer received upon completion.
///
///
/// ## Discussion
///
/// Type and arguments of callout C function that is used when a HID report completion routine is called.
///
///
/// Type and arguments of callout C function that is used when a HID report completion routine is called.
///
/// Parameter `context`: void * pointer to your data, often a pointer to an object.
///
/// Parameter `result`: Completion result of desired operation.
///
/// Parameter `sender`: Interface instance sending the completion routine.
///
/// Parameter `type`: The type of the report that was completed.
///
/// Parameter `reportID`: The ID of the report that was completed.
///
/// Parameter `report`: Pointer to the buffer containing the contents of the report.
///
/// Parameter `reportLength`: Size of the buffer received upon completion.
pub type IOHIDReportCallback = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        IOReturn,
        *mut c_void,
        IOHIDReportType,
        u32,
        NonNull<u8>,
        CFIndex,
    ),
>;

/// Type and arguments of callout C function that is used when a HID report completion routine is called.
///
/// Parameter `context`: void * pointer to your data, often a pointer to an object.
///
/// Parameter `result`: Completion result of desired operation.
///
/// Parameter `sender`: Interface instance sending the completion routine.
///
/// Parameter `type`: The type of the report that was completed.
///
/// Parameter `reportID`: The ID of the report that was completed.
///
/// Parameter `report`: Pointer to the buffer containing the contents of the report.
///
/// Parameter `reportLength`: Size of the buffer received upon completion.
///
/// Parameter `timeStamp`: The time at which the report arrived.
pub type IOHIDReportWithTimeStampCallback = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        IOReturn,
        *mut c_void,
        IOHIDReportType,
        u32,
        NonNull<u8>,
        CFIndex,
        u64,
    ),
>;

///
/// Parameters:
/// - context: void * pointer to more data.
///
/// - result: Completion result of desired operation.
///
/// - sender: Interface instance sending the completion routine.
///
/// - value: IOHIDValueRef containing the returned element value.
///
///
/// ## Discussion
///
/// Type and arguments of callout C function that is used when an element value completion routine is called.
///
///
/// Type and arguments of callout C function that is used when an element value completion routine is called.
///
/// Parameter `context`: void * pointer to more data.
///
/// Parameter `result`: Completion result of desired operation.
///
/// Parameter `sender`: Interface instance sending the completion routine.
///
/// Parameter `value`: IOHIDValueRef containing the returned element value.
pub type IOHIDValueCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn, *mut c_void, NonNull<IOHIDValue>)>;

///
/// Parameters:
/// - context: void * pointer to more data.
///
/// - result: Completion result of desired operation.
///
/// - sender: Interface instance sending the completion routine.
///
/// - multiple: CFDictionaryRef containing the returned element key value pairs.
///
///
/// ## Discussion
///
/// Type and arguments of callout C function that is used when an element value completion routine is called.
///
///
/// Type and arguments of callout C function that is used when an element value completion routine is called.
///
/// Parameter `context`: void * pointer to more data.
///
/// Parameter `result`: Completion result of desired operation.
///
/// Parameter `sender`: Interface instance sending the completion routine.
///
/// Parameter `multiple`: CFDictionaryRef containing the returned element key value pairs.
pub type IOHIDValueMultipleCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn, *mut c_void, NonNull<CFDictionary>)>;

///
/// Parameters:
/// - context: void * pointer to more data.
///
/// - result: Completion result of desired operation.
///
/// - device: IOHIDDeviceRef containing the sending device.
///
///
/// ## Discussion
///
/// Type and arguments of callout C function that is used when a device routine is called.
///
///
/// Type and arguments of callout C function that is used when a device routine is called.
///
/// Parameter `context`: void * pointer to more data.
///
/// Parameter `result`: Completion result of desired operation.
///
/// Parameter `device`: IOHIDDeviceRef containing the sending device.
pub type IOHIDDeviceCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn, *mut c_void, NonNull<IOHIDDevice>)>;

/// This is the type of a reference to the IOHIDQueue.
#[doc(alias = "IOHIDQueueRef")]
#[repr(C)]
pub struct IOHIDQueue {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl IOHIDQueue {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__IOHIDQueue"> for IOHIDQueue {}
);

unsafe impl ConcreteType for IOHIDQueue {
    /// Returns the type identifier of all IOHIDQueue instances.
    /// Returns the type identifier of all IOHIDQueue instances.
    #[doc(alias = "IOHIDQueueGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOHIDQueueGetTypeID() -> CFTypeID;
        }
        unsafe { IOHIDQueueGetTypeID() }
    }
}

impl IOHIDQueue {
    /// Creates an IOHIDQueue object for the specified device.
    ///
    /// Parameters:
    /// - allocator: Allocator to be used during creation.
    ///
    /// - device: IOHIDDevice object
    ///
    /// - depth: The number of values that can be handled by the queue.
    ///
    /// - options: Reserved for future use.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a new IOHIDQueueRef.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Take care in specifying an appropriate depth to prevent dropping events.
    ///
    ///
    /// Creates an IOHIDQueue object for the specified device.
    ///
    /// Take care in specifying an appropriate depth to prevent dropping
    /// events.
    ///
    /// Parameter `allocator`: Allocator to be used during creation.
    ///
    /// Parameter `device`: IOHIDDevice object
    ///
    /// Parameter `depth`: The number of values that can be handled by the queue.
    ///
    /// Parameter `options`: Reserved for future use.
    ///
    /// Returns: Returns a new IOHIDQueueRef.
    #[doc(alias = "IOHIDQueueCreate")]
    #[inline]
    pub fn new(
        allocator: Option<&CFAllocator>,
        device: &IOHIDDevice,
        depth: CFIndex,
        options: IOOptionBits,
    ) -> Option<CFRetained<IOHIDQueue>> {
        extern "C-unwind" {
            fn IOHIDQueueCreate(
                allocator: Option<&CFAllocator>,
                device: &IOHIDDevice,
                depth: CFIndex,
                options: IOOptionBits,
            ) -> Option<NonNull<IOHIDQueue>>;
        }
        let ret = unsafe { IOHIDQueueCreate(allocator, device, depth, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Obtain the device associated with the queue.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue to be queried.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the a reference to the device.
    ///
    ///
    /// Obtain the device associated with the queue.
    ///
    /// Parameter `queue`: IOHIDQueue to be queried.
    ///
    /// Returns: Returns the a reference to the device.
    #[doc(alias = "IOHIDQueueGetDevice")]
    #[inline]
    pub fn device(&self) -> CFRetained<IOHIDDevice> {
        extern "C-unwind" {
            fn IOHIDQueueGetDevice(queue: &IOHIDQueue) -> Option<NonNull<IOHIDDevice>>;
        }
        let ret = unsafe { IOHIDQueueGetDevice(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Obtain the depth of the queue.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue to be queried.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the queue depth.
    ///
    ///
    /// Obtain the depth of the queue.
    ///
    /// Parameter `queue`: IOHIDQueue to be queried.
    ///
    /// Returns: Returns the queue depth.
    #[doc(alias = "IOHIDQueueGetDepth")]
    #[inline]
    pub fn depth(&self) -> CFIndex {
        extern "C-unwind" {
            fn IOHIDQueueGetDepth(queue: &IOHIDQueue) -> CFIndex;
        }
        unsafe { IOHIDQueueGetDepth(self) }
    }

    /// Sets the depth of the queue. @disussion Set the appropriate depth value based on the number of elements contained in a queue.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be modified.
    ///
    /// - depth: The new queue depth.
    ///
    /// Sets the depth of the queue.
    ///
    /// Set the appropriate depth value based on the number of elements
    /// contained in a queue.
    ///
    /// Parameter `queue`: IOHIDQueue object to be modified.
    ///
    /// Parameter `depth`: The new queue depth.
    #[doc(alias = "IOHIDQueueSetDepth")]
    #[inline]
    pub fn set_depth(&self, depth: CFIndex) {
        extern "C-unwind" {
            fn IOHIDQueueSetDepth(queue: &IOHIDQueue, depth: CFIndex);
        }
        unsafe { IOHIDQueueSetDepth(self, depth) }
    }

    /// Adds an element to the queue
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be modified.
    ///
    /// - element: Element to be added to the queue.
    ///
    /// Adds an element to the queue
    ///
    /// Parameter `queue`: IOHIDQueue object to be modified.
    ///
    /// Parameter `element`: Element to be added to the queue.
    #[doc(alias = "IOHIDQueueAddElement")]
    #[inline]
    pub fn add_element(&self, element: &IOHIDElement) {
        extern "C-unwind" {
            fn IOHIDQueueAddElement(queue: &IOHIDQueue, element: &IOHIDElement);
        }
        unsafe { IOHIDQueueAddElement(self, element) }
    }

    /// Removes an element from the queue
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be modified.
    ///
    /// - element: Element to be removed from the queue.
    ///
    /// Removes an element from the queue
    ///
    /// Parameter `queue`: IOHIDQueue object to be modified.
    ///
    /// Parameter `element`: Element to be removed from the queue.
    #[doc(alias = "IOHIDQueueRemoveElement")]
    #[inline]
    pub fn remove_element(&self, element: &IOHIDElement) {
        extern "C-unwind" {
            fn IOHIDQueueRemoveElement(queue: &IOHIDQueue, element: &IOHIDElement);
        }
        unsafe { IOHIDQueueRemoveElement(self, element) }
    }

    /// Queries the queue to determine if elemement has been added.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be queried.
    ///
    /// - element: Element to be queried.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns true or false depending if element is present.
    ///
    ///
    /// Queries the queue to determine if elemement has been added.
    ///
    /// Parameter `queue`: IOHIDQueue object to be queried.
    ///
    /// Parameter `element`: Element to be queried.
    ///
    /// Returns: Returns true or false depending if element is present.
    #[doc(alias = "IOHIDQueueContainsElement")]
    #[inline]
    pub fn contains_element(&self, element: &IOHIDElement) -> bool {
        extern "C-unwind" {
            fn IOHIDQueueContainsElement(queue: &IOHIDQueue, element: &IOHIDElement) -> Boolean;
        }
        let ret = unsafe { IOHIDQueueContainsElement(self, element) };
        ret != 0
    }

    /// Starts element value delivery to the queue.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be started.
    ///
    /// Starts element value delivery to the queue.
    ///
    /// When a dispatch queue is assocaited with the IOHIDQueue
    /// via IOHIDQueueSetDispatchQueue, the queue does not need
    /// to be explicity started, this will be done during activation
    /// when IOHIDQueueActivate is called.
    ///
    /// Parameter `queue`: IOHIDQueue object to be started.
    #[doc(alias = "IOHIDQueueStart")]
    #[inline]
    pub fn start(&self) {
        extern "C-unwind" {
            fn IOHIDQueueStart(queue: &IOHIDQueue);
        }
        unsafe { IOHIDQueueStart(self) }
    }

    /// Stops element value delivery to the queue.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be stopped.
    ///
    /// Stops element value delivery to the queue.
    ///
    /// When a dispatch queue is assocaited with the IOHIDQueue
    /// via IOHIDQueueSetDispatchQueue, the queue does not need
    /// to be explicity stopped, this will be done during cancellation
    /// when IOHIDQueueCancel is called.
    ///
    /// Parameter `queue`: IOHIDQueue object to be stopped.
    #[doc(alias = "IOHIDQueueStop")]
    #[inline]
    pub fn stop(&self) {
        extern "C-unwind" {
            fn IOHIDQueueStop(queue: &IOHIDQueue);
        }
        unsafe { IOHIDQueueStop(self) }
    }

    /// Schedules queue with run loop.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be modified.
    ///
    /// - runLoop: RunLoop to be used when scheduling any asynchronous activity.
    ///
    /// - runLoopMode: Run loop mode to be used when scheduling any asynchronous activity.
    ///
    ///
    /// ## Discussion
    ///
    /// Formally associates queue with client's run loop. Scheduling this queue with the run loop is necessary before making use of any asynchronous APIs.
    ///
    ///
    /// Schedules queue with run loop.
    ///
    /// Formally associates queue with client's run loop. Scheduling
    /// this queue with the run loop is necessary before making
    /// use of any asynchronous APIs.
    ///
    /// Parameter `queue`: IOHIDQueue object to be modified.
    ///
    /// Parameter `runLoop`: RunLoop to be used when scheduling any asynchronous
    /// activity.
    ///
    /// Parameter `runLoopMode`: Run loop mode to be used when scheduling any
    /// asynchronous activity.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "IOHIDQueueScheduleWithRunLoop")]
    #[inline]
    pub unsafe fn schedule_with_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn IOHIDQueueScheduleWithRunLoop(
                queue: &IOHIDQueue,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { IOHIDQueueScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Unschedules queue with run loop.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be modified.
    ///
    /// - runLoop: RunLoop to be used when scheduling any asynchronous activity.
    ///
    /// - runLoopMode: Run loop mode to be used when scheduling any asynchronous activity.
    ///
    ///
    /// ## Discussion
    ///
    /// Formally disassociates queue with client's run loop.
    ///
    ///
    /// Unschedules queue with run loop.
    ///
    /// Formally disassociates queue with client's run loop.
    ///
    /// Parameter `queue`: IOHIDQueue object to be modified.
    ///
    /// Parameter `runLoop`: RunLoop to be used when scheduling any asynchronous
    /// activity.
    ///
    /// Parameter `runLoopMode`: Run loop mode to be used when scheduling any
    /// asynchronous activity.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "IOHIDQueueUnscheduleFromRunLoop")]
    #[inline]
    pub unsafe fn unschedule_from_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn IOHIDQueueUnscheduleFromRunLoop(
                queue: &IOHIDQueue,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { IOHIDQueueUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Sets the dispatch queue to be associated with the IOHIDQueue.
    /// This is necessary in order to receive asynchronous events from the kernel.
    ///
    ///
    /// An IOHIDQueue should not be associated with both a runloop and
    /// dispatch queue. A call to IOHIDQueueSetDispatchQueue should only be made once.
    ///
    /// After a dispatch queue is set, the IOHIDQueue must make a call to activate
    /// via IOHIDQueueActivate and cancel via IOHIDQueueCancel. All calls to "Register"
    /// functions should be done before activation and not after cancellation.
    ///
    ///
    /// Parameter `queue`: Reference to an IOHIDQueue
    ///
    ///
    /// Parameter `dispatchQueue`: The dispatch queue to which the event handler block will be submitted.
    ///
    /// # Safety
    ///
    /// `dispatch_queue` possibly has additional threading requirements.
    #[doc(alias = "IOHIDQueueSetDispatchQueue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_dispatch_queue(&self, dispatch_queue: &DispatchQueue) {
        extern "C-unwind" {
            fn IOHIDQueueSetDispatchQueue(queue: &IOHIDQueue, dispatch_queue: &DispatchQueue);
        }
        unsafe { IOHIDQueueSetDispatchQueue(self, dispatch_queue) }
    }

    /// Sets a cancellation handler for the dispatch queue associated with
    /// IOHIDQueueSetDispatchQueue.
    ///
    ///
    /// The cancellation handler (if specified) will be will be submitted to the
    /// queue's dispatch queue in response to a call to IOHIDQueueCancel after all
    /// the events have been handled.
    ///
    /// IOHIDQueueSetCancelHandler should not be used when scheduling with
    /// a run loop.
    ///
    /// The IOHIDQueueRef should only be released after the queue has been
    /// cancelled, and the cancel handler has been called. This is to ensure all
    /// asynchronous objects are released. For example:
    ///
    /// dispatch_block_t cancelHandler = dispatch_block_create(0, ^{
    /// CFRelease(queue);
    /// });
    /// IOHIDQueueSetCancelHandler(queue, cancelHandler);
    /// IOHIDQueueActivate(queue);
    /// IOHIDQueueCancel(queue);
    ///
    ///
    /// Parameter `queue`: Reference to an IOHIDQueue.
    ///
    ///
    /// Parameter `handler`: The cancellation handler block to be associated with the dispatch queue.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer.
    #[doc(alias = "IOHIDQueueSetCancelHandler")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_cancel_handler(&self, handler: dispatch_block_t) {
        extern "C-unwind" {
            fn IOHIDQueueSetCancelHandler(queue: &IOHIDQueue, handler: dispatch_block_t);
        }
        unsafe { IOHIDQueueSetCancelHandler(self, handler) }
    }

    /// Activates the IOHIDQueue object.
    ///
    ///
    /// An IOHIDQueue object associated with a dispatch queue is created
    /// in an inactive state. The object must be activated in order to
    /// receive asynchronous events from the kernel.
    ///
    /// A dispatch queue must be set via IOHIDQueueSetDispatchQueue before
    /// activation.
    ///
    /// An activated queue must be cancelled via IOHIDQueueCancel. All calls
    /// to "Register" functions should be done before activation
    /// and not after cancellation.
    ///
    /// Calling IOHIDQueueActivate on an active IOHIDQueue has no effect.
    ///
    ///
    /// Parameter `queue`: Reference to an IOHIDQueue
    #[doc(alias = "IOHIDQueueActivate")]
    #[inline]
    pub fn activate(&self) {
        extern "C-unwind" {
            fn IOHIDQueueActivate(queue: &IOHIDQueue);
        }
        unsafe { IOHIDQueueActivate(self) }
    }

    /// Cancels the IOHIDQueue preventing any further invocation
    /// of its event handler block.
    ///
    ///
    /// Cancelling prevents any further invocation of the event handler block for
    /// the specified dispatch queue, but does not interrupt an event handler
    /// block that is already in progress.
    ///
    /// Explicit cancellation of the IOHIDQueue is required, no implicit
    /// cancellation takes place.
    ///
    /// Calling IOHIDQueueCancel on an already cancelled queue has no effect.
    ///
    /// The IOHIDQueueRef should only be released after the queue has been
    /// cancelled, and the cancel handler has been called. This is to ensure all
    /// asynchronous objects are released. For example:
    ///
    /// dispatch_block_t cancelHandler = dispatch_block_create(0, ^{
    /// CFRelease(queue);
    /// });
    /// IOHIDQueueSetCancelHandler(queue, cancelHandler);
    /// IOHIDQueueActivate(queue);
    /// IOHIDQueueCancel(queue);
    ///
    ///
    /// Parameter `queue`: Reference to an IOHIDQueue
    #[doc(alias = "IOHIDQueueCancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn IOHIDQueueCancel(queue: &IOHIDQueue);
        }
        unsafe { IOHIDQueueCancel(self) }
    }

    /// Sets callback to be used when the queue transitions to non-empty.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be modified.
    ///
    /// - callback: Callback of type IOHIDCallback to be used when data is placed on the queue.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// ## Discussion
    ///
    /// In order to make use of asynchronous behavior, the queue needs to be scheduled with the run loop.
    ///
    ///
    /// Sets callback to be used when the queue transitions to non-empty.
    ///
    /// In order to make use of asynchronous behavior, the queue needs
    /// to be scheduled with the run loop or dispatch queue.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `queue`: IOHIDQueue object to be modified.
    ///
    /// Parameter `callback`: Callback of type IOHIDCallback to be used when data is
    /// placed on the queue.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDQueueRegisterValueAvailableCallback")]
    #[inline]
    pub unsafe fn register_value_available_callback(
        &self,
        callback: IOHIDCallback,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn IOHIDQueueRegisterValueAvailableCallback(
                queue: &IOHIDQueue,
                callback: IOHIDCallback,
                context: *mut c_void,
            );
        }
        unsafe { IOHIDQueueRegisterValueAvailableCallback(self, callback, context) }
    }

    /// Dequeues a retained copy of an element value from the head of an IOHIDQueue.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be queried.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns valid IOHIDValueRef if data is available.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Because the value is a retained copy, it is up to the caller to release the value using CFRelease. Use with setValueCallback to avoid polling the queue for data.
    ///
    ///
    /// Dequeues a retained copy of an element value from the head of an
    /// IOHIDQueue.
    ///
    /// Because the value is a retained copy, it is up to the caller to
    /// release the value using CFRelease. Use with setValueCallback to
    /// avoid polling the queue for data.
    ///
    /// Parameter `queue`: IOHIDQueue object to be queried.
    ///
    /// Returns: Returns valid IOHIDValueRef if data is available.
    #[doc(alias = "IOHIDQueueCopyNextValue")]
    #[inline]
    pub fn next_value(&self) -> Option<CFRetained<IOHIDValue>> {
        extern "C-unwind" {
            fn IOHIDQueueCopyNextValue(queue: &IOHIDQueue) -> Option<NonNull<IOHIDValue>>;
        }
        let ret = unsafe { IOHIDQueueCopyNextValue(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Dequeues a retained copy of an element value from the head of an IOHIDQueue. This method will block until either a value is available or it times out.
    ///
    /// Parameters:
    /// - queue: IOHIDQueue object to be queried.
    ///
    /// - timeout: Timeout before aborting an attempt to dequeue a value from the head of a queue.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns valid IOHIDValueRef if data is available.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Because the value is a retained copy, it is up to the caller to release the value using CFRelease. Use with setValueCallback to avoid polling the queue for data.
    ///
    ///
    /// Dequeues a retained copy of an element value from the head of an
    /// IOHIDQueue.  This method will block until either a value is
    /// available or it times out.
    ///
    /// Because the value is a retained copy, it is up to the caller to
    /// release the value using CFRelease. Use with setValueCallback to
    /// avoid polling the queue for data.
    ///
    /// Parameter `queue`: IOHIDQueue object to be queried.
    ///
    /// Parameter `timeout`: Timeout before aborting an attempt to dequeue a value
    /// from the head of a queue.
    ///
    /// Returns: Returns valid IOHIDValueRef if data is available.
    #[doc(alias = "IOHIDQueueCopyNextValueWithTimeout")]
    #[inline]
    pub fn next_value_with_timeout(
        &self,
        timeout: CFTimeInterval,
    ) -> Option<CFRetained<IOHIDValue>> {
        extern "C-unwind" {
            fn IOHIDQueueCopyNextValueWithTimeout(
                queue: &IOHIDQueue,
                timeout: CFTimeInterval,
            ) -> Option<NonNull<IOHIDValue>>;
        }
        let ret = unsafe { IOHIDQueueCopyNextValueWithTimeout(self, timeout) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

unsafe impl ConcreteType for IOHIDDevice {
    /// Returns the type identifier of all IOHIDDevice instances.
    /// Returns the type identifier of all IOHIDDevice instances.
    #[doc(alias = "IOHIDDeviceGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOHIDDeviceGetTypeID() -> CFTypeID;
        }
        unsafe { IOHIDDeviceGetTypeID() }
    }
}

impl IOHIDDevice {
    /// Creates an element from an io_service_t.
    ///
    /// Parameters:
    /// - allocator: Allocator to be used during creation.
    ///
    /// - io_service_t: Reference to service object in the kernel.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a new IOHIDDeviceRef.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The io_service_t passed in this method must reference an object in the kernel of type IOHIDDevice.
    ///
    ///
    /// Creates an element from an io_service_t.
    ///
    /// The io_service_t passed in this method must reference an object
    /// in the kernel of type IOHIDDevice.
    ///
    /// Parameter `allocator`: Allocator to be used during creation.
    ///
    /// Parameter `service`: Reference to service object in the kernel.
    ///
    /// Returns: Returns a new IOHIDDeviceRef.
    #[doc(alias = "IOHIDDeviceCreate")]
    #[cfg(feature = "libc")]
    #[inline]
    pub fn new(
        allocator: Option<&CFAllocator>,
        service: io_service_t,
    ) -> Option<CFRetained<IOHIDDevice>> {
        extern "C-unwind" {
            fn IOHIDDeviceCreate(
                allocator: Option<&CFAllocator>,
                service: io_service_t,
            ) -> Option<NonNull<IOHIDDevice>>;
        }
        let ret = unsafe { IOHIDDeviceCreate(allocator, service) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the io_service_t for an IOHIDDevice, if it has one.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the io_service_t if the IOHIDDevice has one, or MACH_PORT_NULL if it does not.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the IOHIDDevice references an object in the kernel, this is used to get the io_service_t for that object.
    ///
    ///
    /// Returns the io_service_t for an IOHIDDevice, if it has one.
    ///
    /// If the IOHIDDevice references an object in the kernel, this is
    /// used to get the io_service_t for that object.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Returns: Returns the io_service_t if the IOHIDDevice has one, or
    /// MACH_PORT_NULL if it does not.
    #[doc(alias = "IOHIDDeviceGetService")]
    #[cfg(feature = "libc")]
    #[inline]
    pub fn service(&self) -> io_service_t {
        extern "C-unwind" {
            fn IOHIDDeviceGetService(device: &IOHIDDevice) -> io_service_t;
        }
        unsafe { IOHIDDeviceGetService(self) }
    }

    /// Opens a HID device for communication.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - options: Option bits to be sent down to the device.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Before the client can issue commands that change the state of the device, it must have succeeded in opening the device. This establishes a link between the client's task and the actual device. To establish an exclusive link use the kIOHIDOptionsTypeSeizeDevice option.
    ///
    ///
    /// Opens a HID device for communication.
    ///
    /// Before the client can issue commands that change the state of
    /// the device, it must have succeeded in opening the device. This
    /// establishes a link between the client's task and the actual
    /// device.  To establish an exclusive link use the
    /// kIOHIDOptionsTypeSeizeDevice option.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `options`: Option bits to be sent down to the device.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    #[doc(alias = "IOHIDDeviceOpen")]
    #[inline]
    pub fn open(&self, options: IOOptionBits) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceOpen(device: &IOHIDDevice, options: IOOptionBits) -> IOReturn;
        }
        unsafe { IOHIDDeviceOpen(self, options) }
    }

    /// Closes communication with a HID device.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - options: Option bits to be sent down to the device.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This closes a link between the client's task and the actual device.
    ///
    ///
    /// Closes communication with a HID device.
    ///
    /// This closes a link between the client's task and the actual
    /// device.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `options`: Option bits to be sent down to the device.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    #[doc(alias = "IOHIDDeviceClose")]
    #[inline]
    pub fn close(&self, options: IOOptionBits) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceClose(device: &IOHIDDevice, options: IOOptionBits) -> IOReturn;
        }
        unsafe { IOHIDDeviceClose(self, options) }
    }

    /// Convenience function that scans the Application Collection elements to see if it conforms to the provided usagePage and usage.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - usagePage: Device usage page
    ///
    /// - usage: Device usage
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if device conforms to provided usage.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Examples of Application Collection usages pairs are:
    ///
    /// usagePage = kHIDPage_GenericDesktop
    ///
    /// usage = kHIDUsage_GD_Mouse
    ///
    /// **or**
    ///
    /// usagePage = kHIDPage_GenericDesktop
    ///
    /// usage = kHIDUsage_GD_Keyboard
    ///
    ///
    /// Convenience function that scans the Application Collection
    /// elements to see if it conforms to the provided usagePage
    /// and usage.
    ///
    /// Examples of Application Collection usages pairs are:
    /// <br>
    /// usagePage = kHIDPage_GenericDesktop
    /// <br>
    /// usage = kHIDUsage_GD_Mouse
    /// <br>
    /// <b>
    /// or
    /// </b>
    /// <br>
    /// usagePage = kHIDPage_GenericDesktop
    /// <br>
    /// usage = kHIDUsage_GD_Keyboard
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `usagePage`: Device usage page
    ///
    /// Parameter `usage`: Device usage
    ///
    /// Returns: Returns TRUE if device conforms to provided usage.
    #[doc(alias = "IOHIDDeviceConformsTo")]
    #[inline]
    pub fn conforms_to(&self, usage_page: u32, usage: u32) -> bool {
        extern "C-unwind" {
            fn IOHIDDeviceConformsTo(device: &IOHIDDevice, usage_page: u32, usage: u32) -> Boolean;
        }
        let ret = unsafe { IOHIDDeviceConformsTo(self, usage_page, usage) };
        ret != 0
    }

    /// Obtains a property from an IOHIDDevice.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - key: CFStringRef containing key to be used when querying the device.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns CFTypeRef containing the property.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Property keys are prefixed by kIOHIDDevice and declared in <IOKit/hid/IOHIDKeys.h>.
    ///
    ///
    /// Obtains a property from an IOHIDDevice.
    ///
    /// Property keys are prefixed by kIOHIDDevice and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `key`: CFStringRef containing key to be used when querying the
    /// device.
    ///
    /// Returns: Returns CFTypeRef containing the property.
    #[doc(alias = "IOHIDDeviceGetProperty")]
    #[inline]
    pub fn property(&self, key: &CFString) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn IOHIDDeviceGetProperty(
                device: &IOHIDDevice,
                key: &CFString,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { IOHIDDeviceGetProperty(self, key) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Sets a property for an IOHIDDevice.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - key: CFStringRef containing key to be used when modifiying the device property.
    ///
    /// - property: CFTypeRef containg the property to be set.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Property keys are prefixed by kIOHIDDevice and declared in <IOKit/hid/IOHIDKeys.h>.
    ///
    ///
    /// Sets a property for an IOHIDDevice.
    ///
    /// Property keys are prefixed by kIOHIDDevice and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `key`: CFStringRef containing key to be used when modifiying the
    /// device property.
    ///
    /// Parameter `property`: CFTypeRef containg the property to be set.
    ///
    /// Returns: Returns TRUE if successful.
    ///
    /// # Safety
    ///
    /// `property` should be of the correct type.
    #[doc(alias = "IOHIDDeviceSetProperty")]
    #[inline]
    pub unsafe fn set_property(&self, key: &CFString, property: &CFType) -> bool {
        extern "C-unwind" {
            fn IOHIDDeviceSetProperty(
                device: &IOHIDDevice,
                key: &CFString,
                property: &CFType,
            ) -> Boolean;
        }
        let ret = unsafe { IOHIDDeviceSetProperty(self, key, property) };
        ret != 0
    }

    /// Obtains HID elements that match the criteria contained in the matching dictionary.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - matching: CFDictionaryRef containg element matching criteria.
    ///
    /// - options: Reserved for future use.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns CFArrayRef containing multiple IOHIDElement object.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in <IOKit/hid/IOHIDKeys.h>. Passing a NULL dictionary will result in all device elements being returned.
    ///
    ///
    /// Obtains HID elements that match the criteria contained in the
    /// matching dictionary.
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>. Passing a NULL dictionary will result
    /// in all device elements being returned.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `matching`: CFDictionaryRef containg element matching criteria.
    ///
    /// Parameter `options`: Reserved for future use.
    ///
    /// Returns: Returns CFArrayRef containing multiple IOHIDElement object.
    ///
    /// # Safety
    ///
    /// - `matching` generic must be of the correct type.
    /// - `matching` generic must be of the correct type.
    #[doc(alias = "IOHIDDeviceCopyMatchingElements")]
    #[inline]
    pub unsafe fn matching_elements(
        &self,
        matching: Option<&CFDictionary>,
        options: IOOptionBits,
    ) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn IOHIDDeviceCopyMatchingElements(
                device: &IOHIDDevice,
                matching: Option<&CFDictionary>,
                options: IOOptionBits,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { IOHIDDeviceCopyMatchingElements(self, matching, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Schedules HID device with run loop.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - runLoop: RunLoop to be used when scheduling any asynchronous activity.
    ///
    /// - runLoopMode: Run loop mode to be used when scheduling any asynchronous activity.
    ///
    ///
    /// ## Discussion
    ///
    /// Formally associates device with client's run loop. Scheduling this device with the run loop is necessary before making use of any asynchronous APIs.
    ///
    ///
    /// Schedules HID device with run loop.
    ///
    /// Formally associates device with client's run loop. Scheduling
    /// this device with the run loop is necessary before making use of
    /// any asynchronous APIs.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `runLoop`: RunLoop to be used when scheduling any asynchronous
    /// activity.
    ///
    /// Parameter `runLoopMode`: Run loop mode to be used when scheduling any
    /// asynchronous activity.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "IOHIDDeviceScheduleWithRunLoop")]
    #[inline]
    pub unsafe fn schedule_with_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn IOHIDDeviceScheduleWithRunLoop(
                device: &IOHIDDevice,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { IOHIDDeviceScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Unschedules HID device with run loop.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - runLoop: RunLoop to be used when unscheduling any asynchronous activity.
    ///
    /// - runLoopMode: Run loop mode to be used when unscheduling any asynchronous activity.
    ///
    ///
    /// ## Discussion
    ///
    /// Formally disassociates device with client's run loop.
    ///
    ///
    /// Unschedules HID device with run loop.
    ///
    /// Formally disassociates device with client's run loop.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `runLoop`: RunLoop to be used when unscheduling any asynchronous
    /// activity.
    ///
    /// Parameter `runLoopMode`: Run loop mode to be used when unscheduling any
    /// asynchronous activity.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "IOHIDDeviceUnscheduleFromRunLoop")]
    #[inline]
    pub unsafe fn unschedule_from_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn IOHIDDeviceUnscheduleFromRunLoop(
                device: &IOHIDDevice,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { IOHIDDeviceUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Sets the dispatch queue to be associated with the IOHIDDevice.
    /// This is necessary in order to receive asynchronous events from the kernel.
    ///
    /// An IOHIDDevice should not be associated with both a runloop and
    /// dispatch queue. A call to IOHIDDeviceSetDispatchQueue should only be made once.
    /// After a dispatch queue is set, the IOHIDDevice must make a call to activate
    /// via IOHIDDeviceActivate and cancel via IOHIDDeviceCancel. All calls to "Register"
    /// functions should be done before activation and not after cancellation.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice
    ///
    /// Parameter `queue`: The dispatch queue to which the event handler block will be submitted.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "IOHIDDeviceSetDispatchQueue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_dispatch_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn IOHIDDeviceSetDispatchQueue(device: &IOHIDDevice, queue: &DispatchQueue);
        }
        unsafe { IOHIDDeviceSetDispatchQueue(self, queue) }
    }

    /// Sets a cancellation handler for the dispatch queue associated with
    /// IOHIDDeviceSetDispatchQueue.
    ///
    /// The cancellation handler (if specified) will be will be submitted to the
    /// device's dispatch queue in response to a call to IOHIDDeviceCancel after
    /// all the events have been handled.
    /// IOHIDDeviceSetCancelHandler should not be used when scheduling with
    /// a run loop.
    /// The IOHIDDeviceRef should only be released after the device has been
    /// cancelled, and the cancel handler has been called. This is to ensure all
    /// asynchronous objects are released. For example:
    /// dispatch_block_t cancelHandler = dispatch_block_create(0, ^{
    /// CFRelease(device);
    /// });
    /// IOHIDDeviceSetCancelHandler(device, cancelHandler);
    /// IOHIDDeviceActivate(device);
    /// IOHIDDeviceCancel(device);
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `handler`: The cancellation handler block to be associated with the dispatch queue.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer.
    #[doc(alias = "IOHIDDeviceSetCancelHandler")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_cancel_handler(&self, handler: dispatch_block_t) {
        extern "C-unwind" {
            fn IOHIDDeviceSetCancelHandler(device: &IOHIDDevice, handler: dispatch_block_t);
        }
        unsafe { IOHIDDeviceSetCancelHandler(self, handler) }
    }

    /// Activates the IOHIDDevice object.
    ///
    /// An IOHIDDevice object associated with a dispatch queue is created
    /// in an inactive state. The object must be activated in order to
    /// receive asynchronous events from the kernel.
    /// A dispatch queue must be set via IOHIDDeviceSetDispatchQueue before
    /// activation.
    /// An activated device must be cancelled via IOHIDDeviceCancel. All calls
    /// to "Register" functions should be done before activation
    /// and not after cancellation.
    /// Calling IOHIDDeviceActivate on an active IOHIDDevice has no effect.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice
    #[doc(alias = "IOHIDDeviceActivate")]
    #[inline]
    pub fn activate(&self) {
        extern "C-unwind" {
            fn IOHIDDeviceActivate(device: &IOHIDDevice);
        }
        unsafe { IOHIDDeviceActivate(self) }
    }

    /// Cancels the IOHIDDevice preventing any further invocation
    /// of its event handler block.
    ///
    /// Cancelling prevents any further invocation of the event handler block for
    /// the specified dispatch queue, but does not interrupt an event handler
    /// block that is already in progress.
    /// Explicit cancellation of the IOHIDDevice is required, no implicit
    /// cancellation takes place.
    /// Calling IOHIDDeviceCancel on an already cancelled queue has no effect.
    /// The IOHIDDeviceRef should only be released after the device has been
    /// cancelled, and the cancel handler has been called. This is to ensure all
    /// asynchronous objects are released. For example:
    /// dispatch_block_t cancelHandler = dispatch_block_create(0, ^{
    /// CFRelease(device);
    /// });
    /// IOHIDDeviceSetCancelHandler(device, cancelHandler);
    /// IOHIDDeviceActivate(device);
    /// IOHIDDeviceCancel(device);
    ///
    /// Parameter `device`: Reference to an IOHIDDevice
    #[doc(alias = "IOHIDDeviceCancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn IOHIDDeviceCancel(device: &IOHIDDevice);
        }
        unsafe { IOHIDDeviceCancel(self) }
    }

    /// Registers a callback to be used when a IOHIDDevice is removed.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - callback: Pointer to a callback method of type IOHIDCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// ## Discussion
    ///
    /// In most cases this occurs when a device is unplugged.
    ///
    ///
    /// Registers a callback to be used when a IOHIDDevice is removed.
    ///
    /// In most cases this occurs when a device is unplugged.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `callback`: Pointer to a callback method of type IOHIDCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceRegisterRemovalCallback")]
    #[inline]
    pub unsafe fn register_removal_callback(&self, callback: IOHIDCallback, context: *mut c_void) {
        extern "C-unwind" {
            fn IOHIDDeviceRegisterRemovalCallback(
                device: &IOHIDDevice,
                callback: IOHIDCallback,
                context: *mut c_void,
            );
        }
        unsafe { IOHIDDeviceRegisterRemovalCallback(self, callback, context) }
    }

    /// Registers a callback to be used when an input value is issued by the device.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - callback: Pointer to a callback method of type IOHIDValueCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// ## Discussion
    ///
    /// An input element refers to any element of type kIOHIDElementTypeInput and is usually issued by interrupt driven reports. If more specific element values are desired, you can specify matching criteria via IOHIDDeviceSetInputValueMatching and IOHIDDeviceSetInputValueMatchingMultiple.
    ///
    ///
    /// Registers a callback to be used when an input value is issued by
    /// the device.
    ///
    /// An input element refers to any element of type
    /// kIOHIDElementTypeInput and is usually issued by interrupt driven
    /// reports. If more specific element values are desired, you can
    /// specify matching criteria via IOHIDDeviceSetInputValueMatching
    /// and IOHIDDeviceSetInputValueMatchingMultiple.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `callback`: Pointer to a callback method of type IOHIDValueCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceRegisterInputValueCallback")]
    #[inline]
    pub unsafe fn register_input_value_callback(
        &self,
        callback: IOHIDValueCallback,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn IOHIDDeviceRegisterInputValueCallback(
                device: &IOHIDDevice,
                callback: IOHIDValueCallback,
                context: *mut c_void,
            );
        }
        unsafe { IOHIDDeviceRegisterInputValueCallback(self, callback, context) }
    }

    /// Registers a callback to be used when an input report is issued by the device.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - report: Pointer to preallocated buffer in which to copy inbound report data.
    ///
    /// - reportLength: Length of preallocated buffer.
    ///
    /// - callback: Pointer to a callback method of type IOHIDReportCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// ## Discussion
    ///
    /// An input report is an interrupt driver report issued by the device.
    ///
    ///
    /// Registers a callback to be used when an input report is issued
    /// by the device.
    ///
    /// An input report is an interrupt driver report issued by the
    /// device.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `report`: Pointer to preallocated buffer in which to copy inbound
    /// report data.
    ///
    /// Parameter `reportLength`: Length of preallocated buffer.
    ///
    /// Parameter `callback`: Pointer to a callback method of type
    /// IOHIDReportCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `report` must be a valid pointer.
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceRegisterInputReportCallback")]
    #[inline]
    pub unsafe fn register_input_report_callback(
        &self,
        report: NonNull<u8>,
        report_length: CFIndex,
        callback: IOHIDReportCallback,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn IOHIDDeviceRegisterInputReportCallback(
                device: &IOHIDDevice,
                report: NonNull<u8>,
                report_length: CFIndex,
                callback: IOHIDReportCallback,
                context: *mut c_void,
            );
        }
        unsafe {
            IOHIDDeviceRegisterInputReportCallback(self, report, report_length, callback, context)
        }
    }

    /// Registers a timestamped callback to be used when an input report is issued
    /// by the device.
    ///
    /// An input report is an interrupt driver report issued by the
    /// device.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `report`: Pointer to preallocated buffer in which to copy inbound
    /// report data.
    ///
    /// Parameter `reportLength`: Length of preallocated buffer.
    ///
    /// Parameter `callback`: Pointer to a callback method of type
    /// IOHIDReportWithTimeStampCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `report` must be a valid pointer.
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceRegisterInputReportWithTimeStampCallback")]
    #[inline]
    pub unsafe fn register_input_report_with_time_stamp_callback(
        &self,
        report: NonNull<u8>,
        report_length: CFIndex,
        callback: IOHIDReportWithTimeStampCallback,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn IOHIDDeviceRegisterInputReportWithTimeStampCallback(
                device: &IOHIDDevice,
                report: NonNull<u8>,
                report_length: CFIndex,
                callback: IOHIDReportWithTimeStampCallback,
                context: *mut c_void,
            );
        }
        unsafe {
            IOHIDDeviceRegisterInputReportWithTimeStampCallback(
                self,
                report,
                report_length,
                callback,
                context,
            )
        }
    }

    /// Sets matching criteria for input values received via IOHIDDeviceRegisterInputValueCallback.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDDevice.
    ///
    /// - matching: CFDictionaryRef containg device matching criteria.
    ///
    ///
    /// ## Discussion
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in <IOKit/hid/IOHIDKeys.h>. Passing a NULL dictionary will result in all devices being enumerated. Any subsequent calls will cause the hid manager to release previously matched input elements and restart the matching process using the revised criteria. If interested in multiple, specific device elements, please defer to using IOHIDDeviceSetInputValueMatchingMultiple.
    ///
    ///
    /// Sets matching criteria for input values received via
    /// IOHIDDeviceRegisterInputValueCallback.
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>. Passing a NULL dictionary will result
    /// in all devices being enumerated. Any subsequent calls will cause
    /// the hid manager to release previously matched input elements and
    /// restart the matching process using the revised criteria. If
    /// interested in multiple, specific device elements, please defer to
    /// using IOHIDDeviceSetInputValueMatchingMultiple.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `matching`: CFDictionaryRef containg device matching criteria.
    ///
    /// # Safety
    ///
    /// - `matching` generic must be of the correct type.
    /// - `matching` generic must be of the correct type.
    #[doc(alias = "IOHIDDeviceSetInputValueMatching")]
    #[inline]
    pub unsafe fn set_input_value_matching(&self, matching: Option<&CFDictionary>) {
        extern "C-unwind" {
            fn IOHIDDeviceSetInputValueMatching(
                device: &IOHIDDevice,
                matching: Option<&CFDictionary>,
            );
        }
        unsafe { IOHIDDeviceSetInputValueMatching(self, matching) }
    }

    /// Sets multiple matching criteria for input values received via IOHIDDeviceRegisterInputValueCallback.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDDevice.
    ///
    /// - multiple: CFArrayRef containing multiple CFDictionaryRef objects containg input element matching criteria.
    ///
    ///
    /// ## Discussion
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in <IOKit/hid/IOHIDKeys.h>. This method is useful if interested in multiple, specific elements .
    ///
    ///
    /// Sets multiple matching criteria for input values received via
    /// IOHIDDeviceRegisterInputValueCallback.
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>. This method is useful if interested
    /// in multiple, specific elements.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `multiple`: CFArrayRef containing multiple CFDictionaryRef objects
    /// containg input element matching criteria.
    ///
    /// # Safety
    ///
    /// `multiple` generic must be of the correct type.
    #[doc(alias = "IOHIDDeviceSetInputValueMatchingMultiple")]
    #[inline]
    pub unsafe fn set_input_value_matching_multiple(&self, multiple: Option<&CFArray>) {
        extern "C-unwind" {
            fn IOHIDDeviceSetInputValueMatchingMultiple(
                device: &IOHIDDevice,
                multiple: Option<&CFArray>,
            );
        }
        unsafe { IOHIDDeviceSetInputValueMatchingMultiple(self, multiple) }
    }

    /// Sets a value for an element.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - element: IOHIDElementRef whose value is to be modified.
    ///
    /// - value: IOHIDValueRef containing value to be set.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves synchronously and will block until the report has been issued to the device. It is only relevent for either output or feature type elements. If setting values for multiple elements you may want to consider using IOHIDDeviceSetValueMultiple or IOHIDTransaction.
    ///
    ///
    /// Sets a value for an element.
    ///
    /// This method behaves synchronously and will block until the
    /// report has been issued to the device. It is only relevent for
    /// either output or feature type elements. If setting values for
    /// multiple elements you may want to consider using
    /// IOHIDDeviceSetValueMultiple or IOHIDTransaction.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `element`: IOHIDElementRef whose value is to be modified.
    ///
    /// Parameter `value`: IOHIDValueRef containing value to be set.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    #[doc(alias = "IOHIDDeviceSetValue")]
    #[inline]
    pub fn set_value(&self, element: &IOHIDElement, value: &IOHIDValue) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceSetValue(
                device: &IOHIDDevice,
                element: &IOHIDElement,
                value: &IOHIDValue,
            ) -> IOReturn;
        }
        unsafe { IOHIDDeviceSetValue(self, element, value) }
    }

    /// Sets multiple values for multiple elements.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - muliple: CFDictionaryRef where key is IOHIDElementRef and value is IOHIDValueRef.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves synchronously and will block until the report has been issued to the device. It is only relevent for either output or feature type elements.
    ///
    ///
    /// Sets multiple values for multiple elements.
    ///
    /// This method behaves synchronously and will block until the
    /// report has been issued to the device. It is only relevent for
    /// either output or feature type elements.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `multiple`: CFDictionaryRef where key is IOHIDElementRef and
    /// value is IOHIDValueRef.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// - `multiple` generic must be of the correct type.
    /// - `multiple` generic must be of the correct type.
    #[doc(alias = "IOHIDDeviceSetValueMultiple")]
    #[inline]
    pub unsafe fn set_value_multiple(&self, multiple: &CFDictionary) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceSetValueMultiple(
                device: &IOHIDDevice,
                multiple: &CFDictionary,
            ) -> IOReturn;
        }
        unsafe { IOHIDDeviceSetValueMultiple(self, multiple) }
    }

    /// Sets a value for an element and returns status via a completion callback.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - element: IOHIDElementRef whose value is to be modified.
    ///
    /// - value: IOHIDValueRef containing value to be set.
    ///
    /// - timeout: CFTimeInterval containing the timeout.
    ///
    /// - callback: Pointer to a callback method of type IOHIDValueCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves asynchronously and will invoke the callback once the report has been issued to the device. It is only relevent for either output or feature type elements. If setting values for multiple elements you may want to consider using IOHIDDeviceSetValueWithCallback or IOHIDTransaction.
    ///
    ///
    /// Sets a value for an element.
    ///
    /// This method currently only behaves synchronously and will not
    /// invoke the callback. It is only relevent for either output or
    /// feature type elements. If setting values for multiple elements
    /// you may want to consider using
    /// IOHIDDeviceSetValueMultipleWithCallback or IOHIDTransaction.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `element`: IOHIDElementRef whose value is to be modified.
    ///
    /// Parameter `value`: IOHIDValueRef containing value to be set.
    ///
    /// Parameter `timeout`: Currently unused.
    ///
    /// Parameter `callback`: Currently unused.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceSetValueWithCallback")]
    #[inline]
    pub unsafe fn set_value_with_callback(
        &self,
        element: &IOHIDElement,
        value: &IOHIDValue,
        timeout: CFTimeInterval,
        callback: IOHIDValueCallback,
        context: *mut c_void,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceSetValueWithCallback(
                device: &IOHIDDevice,
                element: &IOHIDElement,
                value: &IOHIDValue,
                timeout: CFTimeInterval,
                callback: IOHIDValueCallback,
                context: *mut c_void,
            ) -> IOReturn;
        }
        unsafe { IOHIDDeviceSetValueWithCallback(self, element, value, timeout, callback, context) }
    }

    /// Sets multiple values for multiple elements and returns status via a completion callback.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - muliple: CFDictionaryRef where key is IOHIDElementRef and value is IOHIDValueRef.
    ///
    /// - timeout: CFTimeInterval containing the timeout.
    ///
    /// - callback: Pointer to a callback method of type IOHIDValueMultipleCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves asynchronously and will invoke the callback once the report has been issued to the device. It is only relevent for either output or feature type elements.
    ///
    ///
    /// Sets multiple values for multiple elements and returns status
    /// via a completion callback.
    ///
    /// This method behaves asynchronously and will invoke the callback
    /// once the report has been issued to the device. It is only
    /// relevent for either output or feature type elements.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `multiple`: CFDictionaryRef where key is IOHIDElementRef and
    /// value is IOHIDValueRef.
    ///
    /// Parameter `timeout`: CFTimeInterval containing the timeout in milliseconds.
    ///
    /// Parameter `callback`: Pointer to a callback method of type
    /// IOHIDValueMultipleCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// - `multiple` generic must be of the correct type.
    /// - `multiple` generic must be of the correct type.
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceSetValueMultipleWithCallback")]
    #[inline]
    pub unsafe fn set_value_multiple_with_callback(
        &self,
        multiple: &CFDictionary,
        timeout: CFTimeInterval,
        callback: IOHIDValueMultipleCallback,
        context: *mut c_void,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceSetValueMultipleWithCallback(
                device: &IOHIDDevice,
                multiple: &CFDictionary,
                timeout: CFTimeInterval,
                callback: IOHIDValueMultipleCallback,
                context: *mut c_void,
            ) -> IOReturn;
        }
        unsafe {
            IOHIDDeviceSetValueMultipleWithCallback(self, multiple, timeout, callback, context)
        }
    }

    /// Gets a value for an element.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - element: IOHIDElementRef whose value is to be obtained.
    ///
    /// - pValue: Pointer to IOHIDValueRef to be obtained.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves synchronously and return back immediately for input type element. If requesting a value for a feature element, this will block until the report has been issued to the device. If obtaining values for multiple elements you may want to consider using IOHIDDeviceCopyValueMultiple or IOHIDTransaction.
    ///
    ///
    /// Gets a value for an element.
    ///
    /// This method behaves synchronously and returns immediately
    /// for input type elements. If requesting a value for a feature
    /// element, this will block until the report has been issued to the
    /// device. If obtaining values for multiple elements you may want
    /// to consider using IOHIDDeviceCopyValueMultiple or IOHIDTransaction.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `element`: IOHIDElementRef whose value is to be obtained.
    ///
    /// Parameter `pValue`: Pointer to IOHIDValueRef to be obtained.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// `p_value` must be a valid pointer.
    #[doc(alias = "IOHIDDeviceGetValue")]
    #[inline]
    pub unsafe fn value(
        &self,
        element: &IOHIDElement,
        p_value: NonNull<NonNull<IOHIDValue>>,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceGetValue(
                device: &IOHIDDevice,
                element: &IOHIDElement,
                p_value: NonNull<NonNull<IOHIDValue>>,
            ) -> IOReturn;
        }
        unsafe { IOHIDDeviceGetValue(self, element, p_value) }
    }
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDDeviceGetValueOptions(pub u32);
impl IOHIDDeviceGetValueOptions {
    #[doc(alias = "kIOHIDDeviceGetValueWithUpdate")]
    pub const WithUpdate: Self = Self(0x00020000);
    #[doc(alias = "kIOHIDDeviceGetValueWithoutUpdate")]
    pub const WithoutUpdate: Self = Self(0x00040000);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDDeviceGetValueOptions {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDDeviceGetValueOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl IOHIDDevice {
    /// Gets a value for an element.
    ///
    /// This method behaves synchronously and returns immediately
    /// for input type elements. If requesting a value for a feature
    /// element, this will block until the report has been issued to the
    /// device. If obtaining values for multiple elements you may want
    /// to consider using IOHIDDeviceCopyValueMultiple or IOHIDTransaction.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `element`: IOHIDElementRef whose value is to be obtained.
    ///
    /// Parameter `pValue`: Pointer to IOHIDValueRef to be obtained.
    ///
    /// Parameter `options`: (see IOHIDDeviceGetValueOptions).
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// `p_value` must be a valid pointer.
    #[doc(alias = "IOHIDDeviceGetValueWithOptions")]
    #[inline]
    pub unsafe fn value_with_options(
        &self,
        element: &IOHIDElement,
        p_value: NonNull<NonNull<IOHIDValue>>,
        options: u32,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceGetValueWithOptions(
                device: &IOHIDDevice,
                element: &IOHIDElement,
                p_value: NonNull<NonNull<IOHIDValue>>,
                options: u32,
            ) -> IOReturn;
        }
        unsafe { IOHIDDeviceGetValueWithOptions(self, element, p_value, options) }
    }

    /// Copies a values for multiple elements.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - elements: CFArrayRef containing multiple IOHIDElementRefs whose values are to be obtained.
    ///
    /// - pMultiple: Pointer to CFDictionaryRef where the keys are the provided elements and the values are the requested values.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves synchronously and return back immediately for input type element. If requesting a value for a feature element, this will block until the report has been issued to the device.
    ///
    ///
    /// Copies a values for multiple elements.
    ///
    /// This method behaves synchronously and returns immediately
    /// for input type elements. If requesting a value for a feature
    /// element, this will block until the report has been issued to the
    /// device.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `elements`: CFArrayRef containing multiple IOHIDElementRefs whose
    /// values are to be obtained.
    ///
    /// Parameter `pMultiple`: Pointer to CFDictionaryRef where the keys are the
    /// provided elements and the values are the requested values.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// - `elements` generic must be of the correct type.
    /// - `p_multiple` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceCopyValueMultiple")]
    #[inline]
    pub unsafe fn copy_value_multiple(
        &self,
        elements: &CFArray,
        p_multiple: *mut *const CFDictionary,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceCopyValueMultiple(
                device: &IOHIDDevice,
                elements: &CFArray,
                p_multiple: *mut *const CFDictionary,
            ) -> IOReturn;
        }
        unsafe { IOHIDDeviceCopyValueMultiple(self, elements, p_multiple) }
    }

    /// Gets a value for an element and returns status via a completion callback.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - element: IOHIDElementRef whose value is to be obtained.
    ///
    /// - pValue: Pointer to IOHIDValueRef to be passedback.
    ///
    /// - timeout: CFTimeInterval containing the timeout.
    ///
    /// - callback: Pointer to a callback method of type IOHIDValueCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves asynchronusly and is only relevent for either output or feature type elements. If obtaining values for multiple elements you may want to consider using IOHIDDeviceCopyValueMultipleWithCallback or IOHIDTransaction.
    ///
    ///
    /// Gets a value for an element.
    ///
    /// This method currently only behaves synchronously and will not
    /// invoke the callback. It is only relevent for either output or
    /// feature type elements. If setting values for multiple elements
    /// you may want to consider using
    /// IOHIDDeviceCopyValueMultipleWithCallback or IOHIDTransaction.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `element`: IOHIDElementRef whose value is to be obtained.
    ///
    /// Parameter `pValue`: Pointer to IOHIDValueRef to be passedback.
    ///
    /// Parameter `timeout`: Currently unused.
    ///
    /// Parameter `callback`: Currently unused.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// - `p_value` must be a valid pointer.
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceGetValueWithCallback")]
    #[inline]
    pub unsafe fn value_with_callback(
        &self,
        element: &IOHIDElement,
        p_value: NonNull<NonNull<IOHIDValue>>,
        timeout: CFTimeInterval,
        callback: IOHIDValueCallback,
        context: *mut c_void,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceGetValueWithCallback(
                device: &IOHIDDevice,
                element: &IOHIDElement,
                p_value: NonNull<NonNull<IOHIDValue>>,
                timeout: CFTimeInterval,
                callback: IOHIDValueCallback,
                context: *mut c_void,
            ) -> IOReturn;
        }
        unsafe {
            IOHIDDeviceGetValueWithCallback(self, element, p_value, timeout, callback, context)
        }
    }

    /// Copies a values for multiple elements and returns status via a completion callback.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - elements: CFArrayRef containing multiple IOHIDElementRefs whose values are to be obtained.
    ///
    /// - pMultiple: Pointer to CFDictionaryRef where the keys are the provided elements and the values are the requested values.
    ///
    /// - timeout: CFTimeInterval containing the timeout.
    ///
    /// - callback: Pointer to a callback method of type IOHIDValueMultipleCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves asynchronusly and is only relevent for either output or feature type elements.
    ///
    ///
    /// Copies a values for multiple elements and returns status via a
    /// completion callback.
    ///
    /// This method behaves asynchronusly and is only relevent for
    /// either output or feature type elements.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `elements`: CFArrayRef containing multiple IOHIDElementRefs whose
    /// values are to be obtained.
    ///
    /// Parameter `pMultiple`: Pointer to CFDictionaryRef where the keys are the
    /// provided elements and the values are the requested values.
    ///
    /// Parameter `timeout`: CFTimeInterval containing the timeout in milliseconds.
    ///
    /// Parameter `callback`: Pointer to a callback method of type
    /// IOHIDValueMultipleCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// - `elements` generic must be of the correct type.
    /// - `p_multiple` must be a valid pointer or null.
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceCopyValueMultipleWithCallback")]
    #[inline]
    pub unsafe fn copy_value_multiple_with_callback(
        &self,
        elements: &CFArray,
        p_multiple: *mut *const CFDictionary,
        timeout: CFTimeInterval,
        callback: IOHIDValueMultipleCallback,
        context: *mut c_void,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceCopyValueMultipleWithCallback(
                device: &IOHIDDevice,
                elements: &CFArray,
                p_multiple: *mut *const CFDictionary,
                timeout: CFTimeInterval,
                callback: IOHIDValueMultipleCallback,
                context: *mut c_void,
            ) -> IOReturn;
        }
        unsafe {
            IOHIDDeviceCopyValueMultipleWithCallback(
                self, elements, p_multiple, timeout, callback, context,
            )
        }
    }

    /// Sends a report to the device.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - reportType: Type of report being sent.
    ///
    /// - reportID: ID of the report being sent. If the device supports multiple reports, this should also be set in the first byte of the report.
    ///
    /// - report: The report bytes to be sent to the device.
    ///
    /// - reportLength: The length of the report to be sent to the device.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves synchronously and will block until the report has been issued to the device. It is only relevent for either output or feature type reports.
    ///
    ///
    /// Sends a report to the device.
    ///
    /// This method behaves synchronously and will block until the
    /// report has been issued to the device. It is only relevent for
    /// either output or feature type reports.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `reportType`: Type of report being sent.
    ///
    /// Parameter `reportID`: ID of the report being sent.  If the device supports
    /// multiple reports, this should also be set in the first byte of
    /// the report.
    ///
    /// Parameter `report`: The report bytes to be sent to the device.
    ///
    /// Parameter `reportLength`: The length of the report to be sent to the device.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    #[doc(alias = "IOHIDDeviceSetReport")]
    #[inline]
    pub unsafe fn set_report(
        &self,
        report_type: IOHIDReportType,
        report_id: CFIndex,
        report: NonNull<u8>,
        report_length: CFIndex,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceSetReport(
                device: &IOHIDDevice,
                report_type: IOHIDReportType,
                report_id: CFIndex,
                report: NonNull<u8>,
                report_length: CFIndex,
            ) -> IOReturn;
        }
        unsafe { IOHIDDeviceSetReport(self, report_type, report_id, report, report_length) }
    }

    /// Sends a report to the device.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - reportType: Type of report being sent.
    ///
    /// - reportID: ID of the report being sent. If the device supports multiple reports, this should also be set in the first byte of the report.
    ///
    /// - report: The report bytes to be sent to the device.
    ///
    /// - reportLength: The length of the report to be sent to the device.
    ///
    /// - timeout: CFTimeInterval containing the timeout.
    ///
    /// - callback: Pointer to a callback method of type IOHIDReportCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves asynchronously and will block until the report has been issued to the device. It is only relevent for either output or feature type reports.
    ///
    ///
    /// Sends a report to the device.
    ///
    /// This method behaves asynchronously. It is only relevent for
    /// either output or feature type reports.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `reportType`: Type of report being sent.
    ///
    /// Parameter `reportID`: ID of the report being sent. If the device supports
    /// multiple reports, this should also be set in the first byte of
    /// the report.
    ///
    /// Parameter `report`: The report bytes to be sent to the device.
    ///
    /// Parameter `reportLength`: The length of the report to be sent to the device.
    ///
    /// Parameter `timeout`: CFTimeInterval containing the timeout in milliseconds.
    ///
    /// Parameter `callback`: Pointer to a callback method of type
    /// IOHIDReportCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// - `report` must be a valid pointer.
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDDeviceSetReportWithCallback")]
    #[inline]
    pub unsafe fn set_report_with_callback(
        &self,
        report_type: IOHIDReportType,
        report_id: CFIndex,
        report: NonNull<u8>,
        report_length: CFIndex,
        timeout: CFTimeInterval,
        callback: IOHIDReportCallback,
        context: *mut c_void,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceSetReportWithCallback(
                device: &IOHIDDevice,
                report_type: IOHIDReportType,
                report_id: CFIndex,
                report: NonNull<u8>,
                report_length: CFIndex,
                timeout: CFTimeInterval,
                callback: IOHIDReportCallback,
                context: *mut c_void,
            ) -> IOReturn;
        }
        unsafe {
            IOHIDDeviceSetReportWithCallback(
                self,
                report_type,
                report_id,
                report,
                report_length,
                timeout,
                callback,
                context,
            )
        }
    }

    /// Obtains a report from the device.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - reportType: Type of report being requested.
    ///
    /// - reportID: ID of the report being requested.
    ///
    /// - report: Pointer to preallocated buffer in which to copy inbound report data.
    ///
    /// - pReportLength: Pointer to length of preallocated buffer. This value will be modified to refect the length of the returned report.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves synchronously and will block until the report has been received from the device. This is only intended for feature reports because of sporadic devicesupport for polling input reports. Please defer to using IOHIDDeviceRegisterInputReportCallback for obtaining input reports.
    ///
    ///
    /// Obtains a report from the device.
    ///
    /// This method behaves synchronously and will block until the
    /// report has been received from the device. It is only relevent for
    /// either output or feature type reports. Please defer to using
    /// IOHIDDeviceRegisterInputReportCallback for obtaining input
    /// reports.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `reportType`: Type of report being requested.
    ///
    /// Parameter `reportID`: ID of the report being requested.
    ///
    /// Parameter `report`: Pointer to preallocated buffer in which to copy inbound
    /// report data.
    ///
    /// Parameter `pReportLength`: Pointer to length of preallocated buffer.  This
    /// value will be modified to refect the length of the returned
    /// report.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// - `report` must be a valid pointer.
    /// - `p_report_length` must be a valid pointer.
    #[doc(alias = "IOHIDDeviceGetReport")]
    #[inline]
    pub unsafe fn report(
        &self,
        report_type: IOHIDReportType,
        report_id: CFIndex,
        report: NonNull<u8>,
        p_report_length: NonNull<CFIndex>,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceGetReport(
                device: &IOHIDDevice,
                report_type: IOHIDReportType,
                report_id: CFIndex,
                report: NonNull<u8>,
                p_report_length: NonNull<CFIndex>,
            ) -> IOReturn;
        }
        unsafe { IOHIDDeviceGetReport(self, report_type, report_id, report, p_report_length) }
    }

    /// Obtains a report from the device.
    ///
    /// Parameters:
    /// - device: Reference to an IOHIDDevice.
    ///
    /// - reportType: Type of report being requested.
    ///
    /// - reportID: ID of the report being requested.
    ///
    /// - report: Pointer to preallocated buffer in which to copy inbound report data.
    ///
    /// - pReportLength: Pointer to length of preallocated buffer.
    ///
    /// Pointer to length of preallocated buffer. This value will be modified to refect the length of the returned report.
    ///
    /// - callback: Pointer to a callback method of type IOHIDReportCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method behaves asynchronously and will block until the report has been received from the device. This is only intended for feature reports because of sporadic devicesupport for polling input reports. Please defer to using IOHIDDeviceRegisterInputReportCallback for obtaining input reports.
    ///
    ///
    /// Obtains a report from the device.
    ///
    /// This method behaves asynchronously. It is only relevent for
    /// either output or feature type reports. Please defer to using
    /// IOHIDDeviceRegisterInputReportCallback for obtaining input
    /// reports.
    ///
    /// Parameter `device`: Reference to an IOHIDDevice.
    ///
    /// Parameter `reportType`: Type of report being requested.
    ///
    /// Parameter `reportID`: ID of the report being requested.
    ///
    /// Parameter `report`: Pointer to preallocated buffer in which to copy inbound
    /// report data.
    ///
    /// Parameter `pReportLength`: Pointer to length of preallocated buffer. This
    /// value will be modified to refect the length of the returned
    /// report.
    ///
    /// Parameter `timeout`: CFTimeInterval containing the timeout in milliseconds.
    ///
    /// Parameter `callback`: Pointer to a callback method of type
    /// IOHIDReportCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    ///
    /// # Safety
    ///
    /// - `report` must be a valid pointer.
    /// - `p_report_length` must be a valid pointer.
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer.
    #[doc(alias = "IOHIDDeviceGetReportWithCallback")]
    #[inline]
    pub unsafe fn report_with_callback(
        &self,
        report_type: IOHIDReportType,
        report_id: CFIndex,
        report: NonNull<u8>,
        p_report_length: NonNull<CFIndex>,
        timeout: CFTimeInterval,
        callback: IOHIDReportCallback,
        context: NonNull<c_void>,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDDeviceGetReportWithCallback(
                device: &IOHIDDevice,
                report_type: IOHIDReportType,
                report_id: CFIndex,
                report: NonNull<u8>,
                p_report_length: NonNull<CFIndex>,
                timeout: CFTimeInterval,
                callback: IOHIDReportCallback,
                context: NonNull<c_void>,
            ) -> IOReturn;
        }
        unsafe {
            IOHIDDeviceGetReportWithCallback(
                self,
                report_type,
                report_id,
                report,
                p_report_length,
                timeout,
                callback,
                context,
            )
        }
    }
}

unsafe impl ConcreteType for IOHIDElement {
    /// Returns the type identifier of all IOHIDElement instances.
    /// Returns the type identifier of all IOHIDElement instances.
    #[doc(alias = "IOHIDElementGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOHIDElementGetTypeID() -> CFTypeID;
        }
        unsafe { IOHIDElementGetTypeID() }
    }
}

impl IOHIDElement {
    /// Creates an element from a dictionary.
    ///
    /// Parameters:
    /// - allocator: Allocator to be used during creation.
    ///
    /// - dictionary: dictionary containing values in which to create element.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a new IOHIDElementRef.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The dictionary should contain keys defined in IOHIDKeys.h and start with kIOHIDElement. This call is meant be used by a IOHIDDeviceDeviceInterface object.
    ///
    ///
    /// Creates an element from a dictionary.
    ///
    /// The dictionary should contain keys defined in IOHIDKeys.h and start with kIOHIDElement.  This call is meant be used by a IOHIDDeviceDeviceInterface object.
    ///
    /// Parameter `allocator`: Allocator to be used during creation.
    ///
    /// Parameter `dictionary`: dictionary containing values in which to create element.
    ///
    /// Returns: Returns a new IOHIDElementRef.
    ///
    /// # Safety
    ///
    /// - `dictionary` generic must be of the correct type.
    /// - `dictionary` generic must be of the correct type.
    #[doc(alias = "IOHIDElementCreateWithDictionary")]
    #[inline]
    pub unsafe fn with_dictionary(
        allocator: Option<&CFAllocator>,
        dictionary: &CFDictionary,
    ) -> CFRetained<IOHIDElement> {
        extern "C-unwind" {
            fn IOHIDElementCreateWithDictionary(
                allocator: Option<&CFAllocator>,
                dictionary: &CFDictionary,
            ) -> Option<NonNull<IOHIDElement>>;
        }
        let ret = unsafe { IOHIDElementCreateWithDictionary(allocator, dictionary) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Obtain the device associated with the element.
    ///
    /// Parameters:
    /// - element: IOHIDElement to be queried.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the a reference to the device.
    ///
    ///
    /// Obtain the device associated with the element.
    ///
    /// Parameter `element`: IOHIDElement to be queried.
    ///
    /// Returns: Returns the a reference to the device.
    #[doc(alias = "IOHIDElementGetDevice")]
    #[inline]
    pub fn device(&self) -> CFRetained<IOHIDDevice> {
        extern "C-unwind" {
            fn IOHIDElementGetDevice(element: &IOHIDElement) -> Option<NonNull<IOHIDDevice>>;
        }
        let ret = unsafe { IOHIDElementGetDevice(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Returns the parent for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns an IOHIDElementRef referencing the parent element.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The parent element can be an element of type kIOHIDElementTypeCollection.
    ///
    ///
    /// Returns the parent for the element.
    ///
    /// The parent element can be an element of type kIOHIDElementTypeCollection.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns an IOHIDElementRef referencing the parent element.
    #[doc(alias = "IOHIDElementGetParent")]
    #[inline]
    pub fn parent(&self) -> Option<CFRetained<IOHIDElement>> {
        extern "C-unwind" {
            fn IOHIDElementGetParent(element: &IOHIDElement) -> Option<NonNull<IOHIDElement>>;
        }
        let ret = unsafe { IOHIDElementGetParent(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the children for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns an CFArrayRef containing element objects of type IOHIDElementRef.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// An element of type kIOHIDElementTypeCollection usually contains children.
    ///
    ///
    /// Returns the children for the element.
    ///
    /// An element of type kIOHIDElementTypeCollection usually contains children.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns an CFArrayRef containing element objects of type IOHIDElementRef.
    #[doc(alias = "IOHIDElementGetChildren")]
    #[inline]
    pub fn children(&self) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn IOHIDElementGetChildren(element: &IOHIDElement) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { IOHIDElementGetChildren(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Establish a relationship between one or more elements.
    ///
    /// Parameters:
    /// - element: The element to be modified. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// - toAttach: The element to be attached. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// ## Discussion
    ///
    /// This is useful for grouping HID elements with related functionality.
    ///
    ///
    /// Establish a relationship between one or more elements.
    ///
    /// This is useful for grouping HID elements with related functionality.
    ///
    /// Parameter `element`: The element to be modified. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Parameter `toAttach`: The element to be attached. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    #[doc(alias = "IOHIDElementAttach")]
    #[inline]
    pub fn attach(&self, to_attach: &IOHIDElement) {
        extern "C-unwind" {
            fn IOHIDElementAttach(element: &IOHIDElement, to_attach: &IOHIDElement);
        }
        unsafe { IOHIDElementAttach(self, to_attach) }
    }

    /// Remove a relationship between one or more elements.
    ///
    /// Parameters:
    /// - element: The element to be modified. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// - toDetach: The element to be detached. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// ## Discussion
    ///
    /// This is useful for grouping HID elements with related functionality.
    ///
    ///
    /// Remove a relationship between one or more elements.
    ///
    /// This is useful for grouping HID elements with related functionality.
    ///
    /// Parameter `element`: The element to be modified. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Parameter `toDetach`: The element to be detached. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    #[doc(alias = "IOHIDElementDetach")]
    #[inline]
    pub fn detach(&self, to_detach: &IOHIDElement) {
        extern "C-unwind" {
            fn IOHIDElementDetach(element: &IOHIDElement, to_detach: &IOHIDElement);
        }
        unsafe { IOHIDElementDetach(self, to_detach) }
    }

    /// Obtain attached elements.
    ///
    /// Parameters:
    /// - element: The element to be modified. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a copy of the current attached elements.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Attached elements are those that have been grouped via IOHIDElementAttach.
    ///
    ///
    /// Obtain attached elements.
    ///
    /// Attached elements are those that have been grouped via IOHIDElementAttach.
    ///
    /// Parameter `element`: The element to be modified. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns a copy of the current attached elements.
    #[doc(alias = "IOHIDElementCopyAttached")]
    #[inline]
    pub fn attached(&self) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn IOHIDElementCopyAttached(element: &IOHIDElement) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { IOHIDElementCopyAttached(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves the cookie for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the IOHIDElementCookie for the element.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The IOHIDElementCookie represent a unique identifier for an element within a device.
    ///
    ///
    /// Retrieves the cookie for the element.
    ///
    /// The IOHIDElementCookie represent a unique identifier for an element within a device.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the IOHIDElementCookie for the element.
    #[doc(alias = "IOHIDElementGetCookie")]
    #[inline]
    pub fn cookie(&self) -> IOHIDElementCookie {
        extern "C-unwind" {
            fn IOHIDElementGetCookie(element: &IOHIDElement) -> IOHIDElementCookie;
        }
        unsafe { IOHIDElementGetCookie(self) }
    }

    /// Retrieves the type for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the IOHIDElementType for the element.
    ///
    ///
    /// Retrieves the type for the element.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the IOHIDElementType for the element.
    #[doc(alias = "IOHIDElementGetType")]
    #[inline]
    pub fn r#type(&self) -> IOHIDElementType {
        extern "C-unwind" {
            fn IOHIDElementGetType(element: &IOHIDElement) -> IOHIDElementType;
        }
        unsafe { IOHIDElementGetType(self) }
    }

    /// Retrieves the collection type for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the IOHIDElementCollectionType for the element.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The value returned by this method only makes sense if the element type is kIOHIDElementTypeCollection.
    ///
    ///
    /// Retrieves the collection type for the element.
    ///
    /// The value returned by this method only makes sense if the element type is kIOHIDElementTypeCollection.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the IOHIDElementCollectionType for the element.
    #[doc(alias = "IOHIDElementGetCollectionType")]
    #[inline]
    pub fn collection_type(&self) -> IOHIDElementCollectionType {
        extern "C-unwind" {
            fn IOHIDElementGetCollectionType(element: &IOHIDElement) -> IOHIDElementCollectionType;
        }
        unsafe { IOHIDElementGetCollectionType(self) }
    }

    /// Retrieves the usage page for an element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the usage page for the element.
    ///
    ///
    /// Retrieves the usage page for an element.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the usage page for the element.
    #[doc(alias = "IOHIDElementGetUsagePage")]
    #[inline]
    pub fn usage_page(&self) -> u32 {
        extern "C-unwind" {
            fn IOHIDElementGetUsagePage(element: &IOHIDElement) -> u32;
        }
        unsafe { IOHIDElementGetUsagePage(self) }
    }

    /// Retrieves the usage for an element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the usage for the element.
    ///
    ///
    /// Retrieves the usage for an element.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the usage for the element.
    #[doc(alias = "IOHIDElementGetUsage")]
    #[inline]
    pub fn usage(&self) -> u32 {
        extern "C-unwind" {
            fn IOHIDElementGetUsage(element: &IOHIDElement) -> u32;
        }
        unsafe { IOHIDElementGetUsage(self) }
    }

    /// Returns the virtual property for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the TRUE if virtual or FALSE if not.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Indicates whether the element is a virtual element.
    ///
    ///
    /// Returns the virtual property for the element.
    ///
    /// Indicates whether the element is a virtual element.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the TRUE if virtual or FALSE if not.
    #[doc(alias = "IOHIDElementIsVirtual")]
    #[inline]
    pub fn is_virtual(&self) -> bool {
        extern "C-unwind" {
            fn IOHIDElementIsVirtual(element: &IOHIDElement) -> Boolean;
        }
        let ret = unsafe { IOHIDElementIsVirtual(self) };
        ret != 0
    }

    /// Returns the relative property for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if relative or FALSE if absolute.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Indicates whether the data is relative (indicating the change in value from the last report) or absolute (based on a fixed origin).
    ///
    ///
    /// Returns the relative property for the element.
    ///
    /// Indicates whether the data is relative (indicating the change in value from the last report) or absolute
    /// (based on a fixed origin).
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns TRUE if relative or FALSE if absolute.
    #[doc(alias = "IOHIDElementIsRelative")]
    #[inline]
    pub fn is_relative(&self) -> bool {
        extern "C-unwind" {
            fn IOHIDElementIsRelative(element: &IOHIDElement) -> Boolean;
        }
        let ret = unsafe { IOHIDElementIsRelative(self) };
        ret != 0
    }

    /// Returns the wrap property for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if wrapping or FALSE if non-wrapping.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Wrap indicates whether the data "rolls over" when reaching either the extreme high or low value.
    ///
    ///
    /// Returns the wrap property for the element.
    ///
    /// Wrap indicates whether the data "rolls over" when reaching either the extreme high or low value.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns TRUE if wrapping or FALSE if non-wrapping.
    #[doc(alias = "IOHIDElementIsWrapping")]
    #[inline]
    pub fn is_wrapping(&self) -> bool {
        extern "C-unwind" {
            fn IOHIDElementIsWrapping(element: &IOHIDElement) -> Boolean;
        }
        let ret = unsafe { IOHIDElementIsWrapping(self) };
        ret != 0
    }

    /// Returns the array property for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if array or FALSE if variable.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Indicates whether the element represents variable or array data values. Variable values represent data from a physical control. An array returns an index in each field that corresponds to the pressed button (like keyboard scan codes).
    ///
    /// **Note:** The HID Manager will represent most elements as "variable" including the possible usages of an array. Array indices will remain as "array" elements with a usage of 0xffffffff.
    ///
    ///
    /// Returns the array property for the element.
    ///
    /// Indicates whether the element represents variable or array data values. Variable values represent data from a
    /// physical control.  An array returns an index in each field that corresponds to the pressed button
    /// (like keyboard scan codes).
    /// <br>
    /// <b>
    /// Note:
    /// </b>
    /// The HID Manager will represent most elements as "variable" including the possible usages of an array.
    /// Array indices will remain as "array" elements with a usage of 0xffffffff.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns TRUE if array or FALSE if variable.
    #[doc(alias = "IOHIDElementIsArray")]
    #[inline]
    pub fn is_array(&self) -> bool {
        extern "C-unwind" {
            fn IOHIDElementIsArray(element: &IOHIDElement) -> Boolean;
        }
        let ret = unsafe { IOHIDElementIsArray(self) };
        ret != 0
    }

    /// Returns the linear property for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if non linear or FALSE if linear.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Indicates whether the value for the element has been processed in some way, and no longer represents a linear relationship between what is measured and the value that is reported.
    ///
    ///
    /// Returns the linear property for the element.
    ///
    /// Indicates whether the value for the element has been processed in some way, and no longer represents a linear
    /// relationship between what is measured and the value that is reported.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns TRUE if non linear or FALSE if linear.
    #[doc(alias = "IOHIDElementIsNonLinear")]
    #[inline]
    pub fn is_non_linear(&self) -> bool {
        extern "C-unwind" {
            fn IOHIDElementIsNonLinear(element: &IOHIDElement) -> Boolean;
        }
        let ret = unsafe { IOHIDElementIsNonLinear(self) };
        ret != 0
    }

    /// Returns the preferred state property for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if preferred state or FALSE if no preferred state.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Indicates whether the element has a preferred state to which it will return when the user is not physically interacting with the control.
    ///
    ///
    /// Returns the preferred state property for the element.
    ///
    /// Indicates whether the element has a preferred state to which it will return when the user is not physically
    /// interacting with the control.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns TRUE if preferred state or FALSE if no preferred state.
    #[doc(alias = "IOHIDElementHasPreferredState")]
    #[inline]
    pub fn has_preferred_state(&self) -> bool {
        extern "C-unwind" {
            fn IOHIDElementHasPreferredState(element: &IOHIDElement) -> Boolean;
        }
        let ret = unsafe { IOHIDElementHasPreferredState(self) };
        ret != 0
    }

    /// Returns the null state property for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if null state or FALSE if no null state.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Indicates whether the element has a state in which it is not sending meaningful data.
    ///
    ///
    /// Returns the null state property for the element.
    ///
    /// Indicates whether the element has a state in which it is not sending meaningful data.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns TRUE if null state or FALSE if no null state.
    #[doc(alias = "IOHIDElementHasNullState")]
    #[inline]
    pub fn has_null_state(&self) -> bool {
        extern "C-unwind" {
            fn IOHIDElementHasNullState(element: &IOHIDElement) -> Boolean;
        }
        let ret = unsafe { IOHIDElementHasNullState(self) };
        ret != 0
    }

    /// Returns the name for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns CFStringRef containing the element name.
    ///
    ///
    /// Returns the name for the element.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns CFStringRef containing the element name.
    #[doc(alias = "IOHIDElementGetName")]
    #[inline]
    pub fn name(&self) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn IOHIDElementGetName(element: &IOHIDElement) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { IOHIDElementGetName(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Returns the report ID for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the report ID.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The report ID represents what report this particular element belongs to.
    ///
    ///
    /// Returns the report ID for the element.
    ///
    /// The report ID represents what report this particular element belongs to.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the report ID.
    #[doc(alias = "IOHIDElementGetReportID")]
    #[inline]
    pub fn report_id(&self) -> u32 {
        extern "C-unwind" {
            fn IOHIDElementGetReportID(element: &IOHIDElement) -> u32;
        }
        unsafe { IOHIDElementGetReportID(self) }
    }

    /// Returns the report size in bits for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the report size.
    ///
    ///
    /// Returns the report size in bits for the element.
    ///
    /// If the element is an array type the total number of bit in the element is equal to
    /// IOHIDElementGetReportSize(element) * IOHIDElementGetReportCount(element). Otherwise this size is the
    /// total number of bits in the element.
    ///
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the report size.
    #[doc(alias = "IOHIDElementGetReportSize")]
    #[inline]
    pub fn report_size(&self) -> u32 {
        extern "C-unwind" {
            fn IOHIDElementGetReportSize(element: &IOHIDElement) -> u32;
        }
        unsafe { IOHIDElementGetReportSize(self) }
    }

    /// Returns the report count for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the report count.
    ///
    ///
    /// Returns the report count for the element.
    ///
    /// If the IOHIDElementGetReportCount(element) is greater than one and the element does not represent an
    /// array then the element represents a repeated set of usages, the size of each usage in the element is
    /// IOHIDElementGetReportSize(element) / IOHIDElementGetReportCount(element).
    ///
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the report count.
    #[doc(alias = "IOHIDElementGetReportCount")]
    #[inline]
    pub fn report_count(&self) -> u32 {
        extern "C-unwind" {
            fn IOHIDElementGetReportCount(element: &IOHIDElement) -> u32;
        }
        unsafe { IOHIDElementGetReportCount(self) }
    }

    /// Returns the unit property for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the unit.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The unit property is described in more detail in Section 6.2.2.7 of the "Device Class Definition for Human Interface Devices(HID)" Specification, Version 1.11.
    ///
    ///
    /// Returns the unit property for the element.
    ///
    /// The unit property is described in more detail in Section 6.2.2.7 of the
    /// "Device Class Definition for Human Interface Devices(HID)" Specification, Version 1.11.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the unit.
    #[doc(alias = "IOHIDElementGetUnit")]
    #[inline]
    pub fn unit(&self) -> u32 {
        extern "C-unwind" {
            fn IOHIDElementGetUnit(element: &IOHIDElement) -> u32;
        }
        unsafe { IOHIDElementGetUnit(self) }
    }

    /// Returns the unit exponenet in base 10 for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the unit exponent.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The unit exponent property is described in more detail in Section 6.2.2.7 of the "Device Class Definition for Human Interface Devices(HID)" Specification, Version 1.11.
    ///
    ///
    /// Returns the code associated with the unit exponent as outlined in the HID spec
    ///
    /// The unit exponent property is described in more detail in Section 6.2.2.7 of the
    /// "Device Class Definition for Human Interface Devices(HID)" Specification, Version 1.11.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the unit exponent.
    #[doc(alias = "IOHIDElementGetUnitExponent")]
    #[inline]
    pub fn unit_exponent(&self) -> u32 {
        extern "C-unwind" {
            fn IOHIDElementGetUnitExponent(element: &IOHIDElement) -> u32;
        }
        unsafe { IOHIDElementGetUnitExponent(self) }
    }

    /// Returns the minimum value possible for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the logical minimum.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This corresponds to the logical minimun, which indicates the lower bounds of a variable element.
    ///
    ///
    /// Returns the minimum value possible for the element.
    ///
    /// This corresponds to the logical minimun, which indicates the lower bounds of a variable element.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the logical minimum.
    #[doc(alias = "IOHIDElementGetLogicalMin")]
    #[inline]
    pub fn logical_min(&self) -> CFIndex {
        extern "C-unwind" {
            fn IOHIDElementGetLogicalMin(element: &IOHIDElement) -> CFIndex;
        }
        unsafe { IOHIDElementGetLogicalMin(self) }
    }

    /// Returns the maximum value possible for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the logical maximum.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This corresponds to the logical maximum, which indicates the upper bounds of a variable element.
    ///
    ///
    /// Returns the maximum value possible for the element.
    ///
    /// This corresponds to the logical maximum, which indicates the upper bounds of a variable element.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the logical maximum.
    #[doc(alias = "IOHIDElementGetLogicalMax")]
    #[inline]
    pub fn logical_max(&self) -> CFIndex {
        extern "C-unwind" {
            fn IOHIDElementGetLogicalMax(element: &IOHIDElement) -> CFIndex;
        }
        unsafe { IOHIDElementGetLogicalMax(self) }
    }

    /// Returns the scaled minimum value possible for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the physical minimum.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Minimum value for the physical extent of a variable element. This represents the value for the logical minimum with units applied to it.
    ///
    ///
    /// Returns the scaled minimum value possible for the element.
    ///
    /// Minimum value for the physical extent of a variable element. This represents the value for the logical minimum with units applied to it.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the physical minimum.
    #[doc(alias = "IOHIDElementGetPhysicalMin")]
    #[inline]
    pub fn physical_min(&self) -> CFIndex {
        extern "C-unwind" {
            fn IOHIDElementGetPhysicalMin(element: &IOHIDElement) -> CFIndex;
        }
        unsafe { IOHIDElementGetPhysicalMin(self) }
    }

    /// Returns the scaled maximum value possible for the element.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the physical maximum.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Maximum value for the physical extent of a variable element. This represents the value for the logical maximum with units applied to it.
    ///
    ///
    /// Returns the scaled maximum value possible for the element.
    ///
    /// Maximum value for the physical extent of a variable element.  This represents the value for the logical maximum with units applied to it.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Returns: Returns the physical maximum.
    #[doc(alias = "IOHIDElementGetPhysicalMax")]
    #[inline]
    pub fn physical_max(&self) -> CFIndex {
        extern "C-unwind" {
            fn IOHIDElementGetPhysicalMax(element: &IOHIDElement) -> CFIndex;
        }
        unsafe { IOHIDElementGetPhysicalMax(self) }
    }

    /// Returns the an element property.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// - key: The key to be used when querying the element.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the property.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Property keys are prefixed by kIOHIDElement and declared in IOHIDKeys.h.
    ///
    ///
    /// Returns the an element property.
    ///
    /// Property keys are prefixed by kIOHIDElement and declared in IOHIDKeys.h.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Parameter `key`: The key to be used when querying the element.
    ///
    /// Returns: Returns the property.
    #[doc(alias = "IOHIDElementGetProperty")]
    #[inline]
    pub fn property(&self, key: &CFString) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn IOHIDElementGetProperty(
                element: &IOHIDElement,
                key: &CFString,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { IOHIDElementGetProperty(self, key) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Sets an element property.
    ///
    /// Parameters:
    /// - element: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// - key: The key to be used when querying the element.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method can be used to set arbitrary element properties, such as application specific references.
    ///
    ///
    /// Sets an element property.
    ///
    /// This method can be used to set arbitrary element properties, such as application specific references.
    ///
    /// Parameter `element`: The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    ///
    /// Parameter `key`: The key to be used when querying the element.
    ///
    /// Returns: Returns TRUE if successful.
    ///
    /// # Safety
    ///
    /// `property` should be of the correct type.
    #[doc(alias = "IOHIDElementSetProperty")]
    #[inline]
    pub unsafe fn set_property(&self, key: &CFString, property: &CFType) -> bool {
        extern "C-unwind" {
            fn IOHIDElementSetProperty(
                element: &IOHIDElement,
                key: &CFString,
                property: &CFType,
            ) -> Boolean;
        }
        let ret = unsafe { IOHIDElementSetProperty(self, key, property) };
        ret != 0
    }
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDEventStruct {
    pub r#type: IOHIDElementType,
    pub elementCookie: IOHIDElementCookie,
    pub value: i32,
    pub timestamp: AbsoluteTime,
    pub longValueSize: u32,
    pub longValue: *mut c_void,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDEventStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOHIDEventStruct",
        &[
            <IOHIDElementType>::ENCODING,
            <IOHIDElementCookie>::ENCODING,
            <i32>::ENCODING,
            <AbsoluteTime>::ENCODING,
            <u32>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDEventStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// Parameters:
/// - target: void * pointer to your data, often a pointer to an object.
///
/// - result: Completion result of desired operation.
///
/// - refcon: void * pointer to more data.
///
/// - sender: Interface instance sending the completion routine.
///
///
/// ## Discussion
///
/// Type and arguments of callout C function that is used when a completion routine is called, see IOHIDLib.h:setRemovalCallback().
///
///
/// Type and arguments of callout C function that is used when a
/// completion routine is called, see
/// IOHIDLib.h:setRemovalCallback().
///
/// Parameter `target`: void * pointer to your data, often a pointer to an object.
///
/// Parameter `result`: Completion result of desired operation.
///
/// Parameter `refcon`: void * pointer to more data.
///
/// Parameter `sender`: Interface instance sending the completion routine.
pub type IOHIDCallbackFunction =
    Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn, *mut c_void, *mut c_void)>;

///
/// Parameters:
/// - target: void * pointer to your data, often a pointer to an object.
///
/// - result: Completion result of desired operation.
///
/// - refcon: void * pointer to more data.
///
/// - sender: Interface instance sending the completion routine.
///
/// - elementCookie: Element within interface instance sending completion.
///
///
/// ## Discussion
///
/// Type and arguments of callout C function that is used when a completion routine is called, see IOHIDLib.h:setElementValue().
///
///
/// Type and arguments of callout C function that is used when a
/// completion routine is called, see IOHIDLib.h:setElementValue().
///
/// Parameter `target`: void * pointer to your data, often a pointer to an object.
///
/// Parameter `result`: Completion result of desired operation.
///
/// Parameter `refcon`: void * pointer to more data.
///
/// Parameter `sender`: Interface instance sending the completion routine.
///
/// Parameter `elementCookie`: Element within interface instance sending completion.
pub type IOHIDElementCallbackFunction = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        IOReturn,
        *mut c_void,
        *mut c_void,
        IOHIDElementCookie,
    ),
>;

///
/// Parameters:
/// - target: void * pointer to your data, often a pointer to an object.
///
/// - result: Completion result of desired operation.
///
/// - refcon: void * pointer to more data.
///
/// - sender: Interface instance sending the completion routine.
///
/// - bufferSize: Size of the buffer received upon completion.
///
///
/// ## Discussion
///
/// Type and arguments of callout C function that is used when a completion routine is called, see IOHIDLib.h:setReport().
///
///
/// Type and arguments of callout C function that is used when a
/// completion routine is called, see IOHIDLib.h:setReport().
///
/// Parameter `target`: void * pointer to your data, often a pointer to an object.
///
/// Parameter `result`: Completion result of desired operation.
///
/// Parameter `refcon`: void * pointer to more data.
///
/// Parameter `sender`: Interface instance sending the completion routine.
///
/// Parameter `bufferSize`: Size of the buffer received upon completion.
pub type IOHIDReportCallbackFunction =
    Option<unsafe extern "C-unwind" fn(*mut c_void, IOReturn, *mut c_void, *mut c_void, u32)>;

/// CFPlugin object subclass which provides the primary interface to HID devices.
#[cfg(feature = "libc")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDDeviceInterface {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub createAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut *mut CFRunLoopSource) -> IOReturn>,
    pub getAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut CFRunLoopSource>,
    pub createAsyncPort:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut libc::mach_port_t) -> IOReturn>,
    pub getAsyncPort: Option<unsafe extern "C-unwind" fn(*mut c_void) -> libc::mach_port_t>,
    pub open: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub close: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub setRemovalCallback: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub getElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
        ) -> IOReturn,
    >,
    pub setElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
            u32,
            IOHIDElementCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub queryElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
            u32,
            IOHIDElementCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub startAllQueues: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub stopAllQueues: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub allocQueue:
        Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut *mut IOHIDQueueInterface>,
    pub allocOutputTransaction: Option<
        unsafe extern "C-unwind" fn(*mut c_void) -> *mut *mut IOHIDOutputTransactionInterface,
    >,
    pub setReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *mut c_void,
            u32,
            u32,
            IOHIDReportCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub getReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *mut c_void,
            *mut u32,
            u32,
            IOHIDReportCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOHIDDeviceInterface {
    const ENCODING: Encoding = Encoding::Struct("IOHIDDeviceInterface", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *mut CFRunLoopSource,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut CFRunLoopSource>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut libc::mach_port_t,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> libc::mach_port_t>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,u32,IOHIDElementCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,u32,IOHIDElementCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut *mut IOHIDQueueInterface>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut *mut IOHIDOutputTransactionInterface>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*mut c_void,u32,u32,IOHIDReportCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*mut c_void,*mut u32,u32,IOHIDReportCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOHIDDeviceInterface {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// CFPlugin object subclass which provides the primary interface to HID devices. This class is a subclass of IOHIDDeviceInterface.
#[cfg(feature = "libc")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDDeviceInterface121 {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub createAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut *mut CFRunLoopSource) -> IOReturn>,
    pub getAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut CFRunLoopSource>,
    pub createAsyncPort:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut libc::mach_port_t) -> IOReturn>,
    pub getAsyncPort: Option<unsafe extern "C-unwind" fn(*mut c_void) -> libc::mach_port_t>,
    pub open: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub close: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub setRemovalCallback: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub getElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
        ) -> IOReturn,
    >,
    pub setElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
            u32,
            IOHIDElementCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub queryElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
            u32,
            IOHIDElementCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub startAllQueues: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub stopAllQueues: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub allocQueue:
        Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut *mut IOHIDQueueInterface>,
    pub allocOutputTransaction: Option<
        unsafe extern "C-unwind" fn(*mut c_void) -> *mut *mut IOHIDOutputTransactionInterface,
    >,
    pub setReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *mut c_void,
            u32,
            u32,
            IOHIDReportCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub getReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *mut c_void,
            *mut u32,
            u32,
            IOHIDReportCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOHIDDeviceInterface121 {
    const ENCODING: Encoding = Encoding::Struct("IOHIDDeviceInterface121", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *mut CFRunLoopSource,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut CFRunLoopSource>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut libc::mach_port_t,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> libc::mach_port_t>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,u32,IOHIDElementCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,u32,IOHIDElementCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut *mut IOHIDQueueInterface>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut *mut IOHIDOutputTransactionInterface>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*mut c_void,u32,u32,IOHIDReportCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*mut c_void,*mut u32,u32,IOHIDReportCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOHIDDeviceInterface121 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// CFPlugin object subclass which provides the primary interface to HID devices. This class is a subclass of IOHIDDeviceInterface121.
#[cfg(feature = "libc")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDDeviceInterface122 {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub createAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut *mut CFRunLoopSource) -> IOReturn>,
    pub getAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut CFRunLoopSource>,
    pub createAsyncPort:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut libc::mach_port_t) -> IOReturn>,
    pub getAsyncPort: Option<unsafe extern "C-unwind" fn(*mut c_void) -> libc::mach_port_t>,
    pub open: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub close: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub setRemovalCallback: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub getElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
        ) -> IOReturn,
    >,
    pub setElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
            u32,
            IOHIDElementCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub queryElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
            u32,
            IOHIDElementCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub startAllQueues: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub stopAllQueues: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub allocQueue:
        Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut *mut IOHIDQueueInterface>,
    pub allocOutputTransaction: Option<
        unsafe extern "C-unwind" fn(*mut c_void) -> *mut *mut IOHIDOutputTransactionInterface,
    >,
    pub setReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *mut c_void,
            u32,
            u32,
            IOHIDReportCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub getReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *mut c_void,
            *mut u32,
            u32,
            IOHIDReportCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub copyMatchingElements: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *const CFDictionary,
            *mut *const CFArray,
        ) -> IOReturn,
    >,
    pub setInterruptReportHandlerCallback: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut c_void,
            u32,
            IOHIDReportCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOHIDDeviceInterface122 {
    const ENCODING: Encoding = Encoding::Struct("IOHIDDeviceInterface122", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *mut CFRunLoopSource,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut CFRunLoopSource>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut libc::mach_port_t,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> libc::mach_port_t>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,u32,IOHIDElementCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,u32,IOHIDElementCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut *mut IOHIDQueueInterface>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut *mut IOHIDOutputTransactionInterface>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*mut c_void,u32,u32,IOHIDReportCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*mut c_void,*mut u32,u32,IOHIDReportCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFDictionary,*mut *const CFArray,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut c_void,u32,IOHIDReportCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOHIDDeviceInterface122 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// CFPlugin object subclass which provides an interface for input queues from HID devices. Created by an IOHIDDeviceInterface object.
#[cfg(feature = "libc")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDQueueInterface {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub createAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut *mut CFRunLoopSource) -> IOReturn>,
    pub getAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut CFRunLoopSource>,
    pub createAsyncPort:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut libc::mach_port_t) -> IOReturn>,
    pub getAsyncPort: Option<unsafe extern "C-unwind" fn(*mut c_void) -> libc::mach_port_t>,
    pub create: Option<unsafe extern "C-unwind" fn(*mut c_void, u32, u32) -> IOReturn>,
    pub dispose: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub addElement:
        Option<unsafe extern "C-unwind" fn(*mut c_void, IOHIDElementCookie, u32) -> IOReturn>,
    pub removeElement:
        Option<unsafe extern "C-unwind" fn(*mut c_void, IOHIDElementCookie) -> IOReturn>,
    pub hasElement: Option<unsafe extern "C-unwind" fn(*mut c_void, IOHIDElementCookie) -> Boolean>,
    pub start: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub stop: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub getNextEvent: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDEventStruct,
            AbsoluteTime,
            u32,
        ) -> IOReturn,
    >,
    pub setEventCallout: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub getEventCallout: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDCallbackFunction,
            *mut *mut c_void,
            *mut *mut c_void,
        ) -> IOReturn,
    >,
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOHIDQueueInterface {
    const ENCODING: Encoding = Encoding::Struct("IOHIDQueueInterface", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *mut CFRunLoopSource,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut CFRunLoopSource>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut libc::mach_port_t,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> libc::mach_port_t>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,u32,u32,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,u32,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,) -> Boolean>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDEventStruct,AbsoluteTime,u32,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDCallbackFunction,*mut *mut c_void,*mut *mut c_void,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOHIDQueueInterface {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// CFPlugin object subclass which privides interface for output transactions to HID devices. Created by a IOHIDDeviceInterface object.
#[cfg(feature = "libc")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDOutputTransactionInterface {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub createAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut *mut CFRunLoopSource) -> IOReturn>,
    pub getAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void) -> *mut CFRunLoopSource>,
    pub createAsyncPort:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut libc::mach_port_t) -> IOReturn>,
    pub getAsyncPort: Option<unsafe extern "C-unwind" fn(*mut c_void) -> libc::mach_port_t>,
    pub create: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub dispose: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub addElement:
        Option<unsafe extern "C-unwind" fn(*mut c_void, IOHIDElementCookie) -> IOReturn>,
    pub removeElement:
        Option<unsafe extern "C-unwind" fn(*mut c_void, IOHIDElementCookie) -> IOReturn>,
    pub hasElement: Option<unsafe extern "C-unwind" fn(*mut c_void, IOHIDElementCookie) -> Boolean>,
    pub setElementDefault: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
        ) -> IOReturn,
    >,
    pub getElementDefault: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
        ) -> IOReturn,
    >,
    pub setElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
        ) -> IOReturn,
    >,
    pub getElementValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDElementCookie,
            *mut IOHIDEventStruct,
        ) -> IOReturn,
    >,
    pub commit: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            u32,
            IOHIDCallbackFunction,
            *mut c_void,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub clear: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOHIDOutputTransactionInterface {
    const ENCODING: Encoding = Encoding::Struct("IOHIDOutputTransactionInterface", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *mut CFRunLoopSource,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> *mut CFRunLoopSource>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut libc::mach_port_t,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> libc::mach_port_t>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,) -> Boolean>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDElementCookie,*mut IOHIDEventStruct,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,u32,IOHIDCallbackFunction,*mut c_void,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOHIDOutputTransactionInterface {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Various options that can be supplied to IOHIDManager functions.
/// Various options that can be supplied to IOHIDManager functions.
///
/// explicit enough.
///
/// supplied to
///
/// ```text
///  IOHIDManagerCreate
/// ```
///
/// to create and/or use a
/// persistent properties store.
///
/// to
///
/// ```text
///  IOHIDManagerCreate when you wish to overwrite the
///             persistent properties store without loading it first.
///  @const     kIOHIDManagerOptionDoNotSaveProperties This constant can be supplied
///             to @link IOHIDManagerCreate
/// ```
///
/// when you want to use the
/// persistent property store but do not want to add to it.
///
/// manager will act independently from calls to the manager.
/// This allows for devices to be scheduled on separate queues, and
/// their lifetime can persist after the manager is gone.
///
/// The following calls will not be propagated to the devices:
/// IOHIDManagerOpen, IOHIDManagerClose, IOHIDManagerScheduleWithRunLoop,
/// IOHIDManagerUnscheduleFromRunLoop, IOHIDManagerSetDispatchQueue,
/// IOHIDManagerSetCancelHandler, IOHIDManagerActivate, IOHIDManagerCancel,
/// IOHIDManagerRegisterInputReportCallback,
/// IOHIDManagerRegisterInputReportWithTimeStampCallback,
/// IOHIDManagerRegisterInputValueCallback, IOHIDManagerSetInputValueMatching,
/// IOHIDManagerSetInputValueMatchingMultiple,
///
/// This also means that the manager will not be able to receive input
/// reports or input values, since the devices may or may not be scheduled.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOHIDManagerOptions(pub u32);
bitflags::bitflags! {
    impl IOHIDManagerOptions: u32 {
///
/// ## Discussion
///
/// For those times when supplying 0 just isn't explicit enough.
///
///
        #[doc(alias = "kIOHIDManagerOptionNone")]
        const None = 0x0;
///
/// ## Discussion
///
/// This constant can be supplied to [`IOHIDManagerCreate`](https://developer.apple.com/documentation/iokit/1438383-iohidmanagercreate) to create and/or use a persistent properties store.
///
///
        #[doc(alias = "kIOHIDManagerOptionUsePersistentProperties")]
        const UsePersistentProperties = 0x1;
///
/// ## Discussion
///
/// This constant can be supplied to [`IOHIDManagerCreate`](https://developer.apple.com/documentation/iokit/1438383-iohidmanagercreate)
///
///
        #[doc(alias = "kIOHIDManagerOptionDoNotLoadProperties")]
        const DoNotLoadProperties = 0x2;
        #[doc(alias = "kIOHIDManagerOptionDoNotSaveProperties")]
        const DoNotSaveProperties = 0x4;
        #[doc(alias = "kIOHIDManagerOptionIndependentDevices")]
        const IndependentDevices = 0x8;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDManagerOptions {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDManagerOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This is the type of a reference to the IOHIDManager.
#[doc(alias = "IOHIDManagerRef")]
#[repr(C)]
pub struct IOHIDManager {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl IOHIDManager {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__IOHIDManager"> for IOHIDManager {}
);

unsafe impl ConcreteType for IOHIDManager {
    /// Returns the type identifier of all IOHIDManager instances.
    /// Returns the type identifier of all IOHIDManager instances.
    #[doc(alias = "IOHIDManagerGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOHIDManagerGetTypeID() -> CFTypeID;
        }
        unsafe { IOHIDManagerGetTypeID() }
    }
}

impl IOHIDManager {
    /// Creates an IOHIDManager object.
    ///
    /// Parameters:
    /// - allocator: Allocator to be used during creation.
    ///
    /// - options: Supply [`kIOHIDManagerOptionUsePersistentProperties`](https://developer.apple.com/documentation/iokit/1645245-anonymous/kiohidmanageroptionusepersistentproperties) to load properties from the default persistent property store. Otherwise supply [`kIOHIDManagerOptionNone`](https://developer.apple.com/documentation/iokit/1645245-anonymous/kiohidmanageroptionnone) (or 0).
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a new IOHIDManagerRef.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The IOHIDManager object is meant as a global management system for communicating with HID devices.
    ///
    ///
    /// Creates an IOHIDManager object.
    ///
    /// The IOHIDManager object is meant as a global management system
    /// for communicating with HID devices.
    ///
    /// Parameter `allocator`: Allocator to be used during creation.
    ///
    /// Parameter `options`: Supply
    ///
    /// ```text
    ///  kIOHIDManagerOptionUsePersistentProperties
    /// ```
    ///
    /// to load
    /// properties from the default persistent property store. Otherwise supply
    ///
    /// ```text
    ///  kIOHIDManagerOptionNone
    /// ```
    ///
    /// (or 0).
    ///
    /// Returns: Returns a new IOHIDManagerRef.
    #[doc(alias = "IOHIDManagerCreate")]
    #[inline]
    pub fn new(allocator: Option<&CFAllocator>, options: IOOptionBits) -> CFRetained<IOHIDManager> {
        extern "C-unwind" {
            fn IOHIDManagerCreate(
                allocator: Option<&CFAllocator>,
                options: IOOptionBits,
            ) -> Option<NonNull<IOHIDManager>>;
        }
        let ret = unsafe { IOHIDManagerCreate(allocator, options) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Opens the IOHIDManager.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - options: Option bits to be sent down to the manager and device.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This will open both current and future devices that are enumerated. To establish an exclusive link use the kIOHIDOptionsTypeSeizeDevice option.
    ///
    ///
    /// Opens the IOHIDManager.
    ///
    /// This will open both current and future devices that are
    /// enumerated. To establish an exclusive link use the
    /// kIOHIDOptionsTypeSeizeDevice option.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `options`: Option bits to be sent down to the manager and device.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    #[doc(alias = "IOHIDManagerOpen")]
    #[inline]
    pub fn open(&self, options: IOOptionBits) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDManagerOpen(manager: &IOHIDManager, options: IOOptionBits) -> IOReturn;
        }
        unsafe { IOHIDManagerOpen(self, options) }
    }

    /// Closes the IOHIDManager.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - options: Option bits to be sent down to the manager and device.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This will also close all devices that are currently enumerated.
    ///
    ///
    /// Closes the IOHIDManager.
    ///
    /// This will also close all devices that are currently enumerated.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `options`: Option bits to be sent down to the manager and device.
    ///
    /// Returns: Returns kIOReturnSuccess if successful.
    #[doc(alias = "IOHIDManagerClose")]
    #[inline]
    pub fn close(&self, options: IOOptionBits) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDManagerClose(manager: &IOHIDManager, options: IOOptionBits) -> IOReturn;
        }
        unsafe { IOHIDManagerClose(self, options) }
    }

    /// Obtains a property of an IOHIDManager.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - key: CFStringRef containing key to be used when querying the manager.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns CFTypeRef containing the property.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Property keys are prefixed by kIOHIDDevice and declared in <IOKit/hid/IOHIDKeys.h>.
    ///
    ///
    /// Obtains a property of an IOHIDManager.
    ///
    /// Property keys are prefixed by kIOHIDDevice and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `key`: CFStringRef containing key to be used when querying the
    /// manager.
    ///
    /// Returns: Returns CFTypeRef containing the property.
    #[doc(alias = "IOHIDManagerGetProperty")]
    #[inline]
    pub fn property(&self, key: &CFString) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn IOHIDManagerGetProperty(
                manager: &IOHIDManager,
                key: &CFString,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { IOHIDManagerGetProperty(self, key) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Sets a property for an IOHIDManager.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - key: CFStringRef containing key to be used when modifiying the device property.
    ///
    /// - value: CFTypeRef containing the property value to be set.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns TRUE if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Property keys are prefixed by kIOHIDDevice and kIOHIDManager and declared in <IOKit/hid/IOHIDKeys.h>. This method will propagate any relevent properties to current and future devices that are enumerated.
    ///
    ///
    /// Sets a property for an IOHIDManager.
    ///
    /// Property keys are prefixed by kIOHIDDevice and kIOHIDManager and
    /// declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>. This method will propagate
    /// any relevent properties to current and future devices that are
    /// enumerated.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `key`: CFStringRef containing key to be used when modifiying the
    /// device property.
    ///
    /// Parameter `value`: CFTypeRef containing the property value to be set.
    ///
    /// Returns: Returns TRUE if successful.
    ///
    /// # Safety
    ///
    /// `value` should be of the correct type.
    #[doc(alias = "IOHIDManagerSetProperty")]
    #[inline]
    pub unsafe fn set_property(&self, key: &CFString, value: &CFType) -> bool {
        extern "C-unwind" {
            fn IOHIDManagerSetProperty(
                manager: &IOHIDManager,
                key: &CFString,
                value: &CFType,
            ) -> Boolean;
        }
        let ret = unsafe { IOHIDManagerSetProperty(self, key, value) };
        ret != 0
    }

    /// Schedules HID manager with run loop.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - runLoop: RunLoop to be used when scheduling any asynchronous activity.
    ///
    /// - runLoopMode: Run loop mode to be used when scheduling any asynchronous activity.
    ///
    ///
    /// ## Discussion
    ///
    /// Formally associates manager with client's run loop. Scheduling this device with the run loop is necessary before making use of any asynchronous APIs. This will propagate to current and future devices that are enumerated.
    ///
    ///
    /// Schedules HID manager with run loop.
    ///
    /// Formally associates manager with client's run loop. Scheduling
    /// this device with the run loop is necessary before making use of
    /// any asynchronous APIs.  This will propagate to current and
    /// future devices that are enumerated.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `runLoop`: RunLoop to be used when scheduling any asynchronous
    /// activity.
    ///
    /// Parameter `runLoopMode`: Run loop mode to be used when scheduling any
    /// asynchronous activity.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "IOHIDManagerScheduleWithRunLoop")]
    #[inline]
    pub unsafe fn schedule_with_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn IOHIDManagerScheduleWithRunLoop(
                manager: &IOHIDManager,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { IOHIDManagerScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Unschedules HID manager with run loop.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - runLoop: RunLoop to be used when unscheduling any asynchronous activity.
    ///
    /// - runLoopMode: Run loop mode to be used when unscheduling any asynchronous activity.
    ///
    ///
    /// ## Discussion
    ///
    /// Formally disassociates device with client's run loop. This will propagate to current devices that are enumerated.
    ///
    ///
    /// Unschedules HID manager with run loop.
    ///
    /// Formally disassociates device with client's run loop. This will
    /// propagate to current devices that are enumerated.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `runLoop`: RunLoop to be used when unscheduling any asynchronous
    /// activity.
    ///
    /// Parameter `runLoopMode`: Run loop mode to be used when unscheduling any
    /// asynchronous activity.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "IOHIDManagerUnscheduleFromRunLoop")]
    #[inline]
    pub unsafe fn unschedule_from_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn IOHIDManagerUnscheduleFromRunLoop(
                manager: &IOHIDManager,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { IOHIDManagerUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Sets the dispatch queue to be associated with the IOHIDManager.
    /// This is necessary in order to receive asynchronous events from the kernel.
    ///
    ///
    /// An IOHIDManager should not be associated with both a runloop and
    /// dispatch queue. A call to IOHIDManagerSetDispatchQueue should only be made once.
    ///
    /// After a dispatch queue is set, the IOHIDManager must make a call to activate
    /// via IOHIDManagerActivate and cancel via IOHIDManagerCancel. All calls to "Register"
    /// functions should be done before activation and not after cancellation.
    ///
    ///
    /// Parameter `manager`: Reference to an IOHIDManager
    ///
    ///
    /// Parameter `queue`: The dispatch queue to which the event handler block will be submitted.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "IOHIDManagerSetDispatchQueue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_dispatch_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn IOHIDManagerSetDispatchQueue(manager: &IOHIDManager, queue: &DispatchQueue);
        }
        unsafe { IOHIDManagerSetDispatchQueue(self, queue) }
    }

    /// Sets a cancellation handler for the dispatch queue associated with
    /// IOHIDManagerSetDispatchQueue.
    ///
    ///
    /// The cancellation handler (if specified) will be will be submitted to the
    /// manager's dispatch queue in response to a call to IOHIDManagerCancel after
    /// all the events have been handled.
    ///
    /// IOHIDManagerSetCancelHandler should not be used when scheduling with
    /// a run loop.
    ///
    /// The IOHIDManagerRef should only be released after the manager has been
    /// cancelled, and the cancel handler has been called. This is to ensure all
    /// asynchronous objects are released. For example:
    ///
    /// dispatch_block_t cancelHandler = dispatch_block_create(0, ^{
    /// CFRelease(manager);
    /// });
    /// IOHIDManagerSetCancelHandler(manager, cancelHandler);
    /// IOHIDManagerActivate(manager);
    /// IOHIDManageCancel(manager);
    ///
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    ///
    /// Parameter `handler`: The cancellation handler block to be associated with the dispatch queue.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer.
    #[doc(alias = "IOHIDManagerSetCancelHandler")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_cancel_handler(&self, handler: dispatch_block_t) {
        extern "C-unwind" {
            fn IOHIDManagerSetCancelHandler(manager: &IOHIDManager, handler: dispatch_block_t);
        }
        unsafe { IOHIDManagerSetCancelHandler(self, handler) }
    }

    /// Activates the IOHIDManager object.
    ///
    ///
    /// An IOHIDManager object associated with a dispatch queue is created
    /// in an inactive state. The object must be activated in order to
    /// receive asynchronous events from the kernel.
    ///
    /// A dispatch queue must be set via IOHIDManagerSetDispatchQueue before
    /// activation.
    ///
    /// An activated manager must be cancelled via IOHIDManagerCancel. All calls
    /// to "Register" functions should be done before activation
    /// and not after cancellation.
    ///
    /// Calling IOHIDManagerActivate on an active IOHIDManager has no effect.
    ///
    ///
    /// Parameter `manager`: Reference to an IOHIDManager
    #[doc(alias = "IOHIDManagerActivate")]
    #[inline]
    pub fn activate(&self) {
        extern "C-unwind" {
            fn IOHIDManagerActivate(manager: &IOHIDManager);
        }
        unsafe { IOHIDManagerActivate(self) }
    }

    /// Cancels the IOHIDManager preventing any further invocation
    /// of its event handler block.
    ///
    ///
    /// Cancelling prevents any further invocation of the event handler block for
    /// the specified dispatch queue, but does not interrupt an event handler
    /// block that is already in progress.
    ///
    /// Explicit cancellation of the IOHIDManager is required, no implicit
    /// cancellation takes place.
    ///
    /// Calling IOHIDManagerCancel on an already cancelled queue has no effect.
    ///
    /// The IOHIDManagerRef should only be released after the manager has been
    /// cancelled, and the cancel handler has been called. This is to ensure all
    /// asynchronous objects are released. For example:
    ///
    /// dispatch_block_t cancelHandler = dispatch_block_create(0, ^{
    /// CFRelease(manager);
    /// });
    /// IOHIDManagerSetCancelHandler(manager, cancelHandler);
    /// IOHIDManagerActivate(manager);
    /// IOHIDManageCancel(manager);
    ///
    ///
    /// Parameter `manager`: Reference to an IOHIDManager
    #[doc(alias = "IOHIDManagerCancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn IOHIDManagerCancel(manager: &IOHIDManager);
        }
        unsafe { IOHIDManagerCancel(self) }
    }

    /// Sets matching criteria for device enumeration.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - matching: CFDictionaryRef containg device matching criteria.
    ///
    ///
    /// ## Discussion
    ///
    /// Matching keys are prefixed by kIOHIDDevice and declared in <IOKit/hid/IOHIDKeys.h>. Passing a NULL dictionary will result in all devices being enumerated. Any subsequent calls will cause the hid manager to release previously enumerated devices and restart the enuerate process using the revised criteria. If interested in multiple, specific device classes, please defer to using IOHIDManagerSetDeviceMatchingMultiple.
    ///
    ///
    /// Sets matching criteria for device enumeration.
    ///
    /// Matching keys are prefixed by kIOHIDDevice and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>.  Passing a NULL dictionary will result
    /// in all devices being enumerated. Any subsequent calls will cause
    /// the hid manager to release previously enumerated devices and
    /// restart the enuerate process using the revised criteria.  If
    /// interested in multiple, specific device classes, please defer to
    /// using IOHIDManagerSetDeviceMatchingMultiple.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `matching`: CFDictionaryRef containg device matching criteria.
    ///
    /// # Safety
    ///
    /// - `matching` generic must be of the correct type.
    /// - `matching` generic must be of the correct type.
    #[doc(alias = "IOHIDManagerSetDeviceMatching")]
    #[inline]
    pub unsafe fn set_device_matching(&self, matching: Option<&CFDictionary>) {
        extern "C-unwind" {
            fn IOHIDManagerSetDeviceMatching(
                manager: &IOHIDManager,
                matching: Option<&CFDictionary>,
            );
        }
        unsafe { IOHIDManagerSetDeviceMatching(self, matching) }
    }

    /// Sets multiple matching criteria for device enumeration.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - multiple: CFArrayRef containing multiple CFDictionaryRef objects containg device matching criteria.
    ///
    ///
    /// ## Discussion
    ///
    /// Matching keys are prefixed by kIOHIDDevice and declared in <IOKit/hid/IOHIDKeys.h>. This method is useful if interested in multiple, specific device classes.
    ///
    ///
    /// Sets multiple matching criteria for device enumeration.
    ///
    /// Matching keys are prefixed by kIOHIDDevice and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>.  This method is useful if interested
    /// in multiple, specific device classes.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `multiple`: CFArrayRef containing multiple CFDictionaryRef objects
    /// containg device matching criteria.
    ///
    /// # Safety
    ///
    /// `multiple` generic must be of the correct type.
    #[doc(alias = "IOHIDManagerSetDeviceMatchingMultiple")]
    #[inline]
    pub unsafe fn set_device_matching_multiple(&self, multiple: Option<&CFArray>) {
        extern "C-unwind" {
            fn IOHIDManagerSetDeviceMatchingMultiple(
                manager: &IOHIDManager,
                multiple: Option<&CFArray>,
            );
        }
        unsafe { IOHIDManagerSetDeviceMatchingMultiple(self, multiple) }
    }

    /// Obtains currently enumerated devices.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// CFSetRef containing IOHIDDeviceRefs.
    ///
    ///
    /// Obtains currently enumerated devices.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Returns: CFSetRef containing IOHIDDeviceRefs.
    #[doc(alias = "IOHIDManagerCopyDevices")]
    #[inline]
    pub fn devices(&self) -> Option<CFRetained<CFSet>> {
        extern "C-unwind" {
            fn IOHIDManagerCopyDevices(manager: &IOHIDManager) -> Option<NonNull<CFSet>>;
        }
        let ret = unsafe { IOHIDManagerCopyDevices(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Registers a callback to be used a device is enumerated.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManagerRef.
    ///
    /// - callback: Pointer to a callback method of type IOHIDDeviceCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// ## Discussion
    ///
    /// Only device matching the set criteria will be enumerated.
    ///
    ///
    /// Registers a callback to be used a device is enumerated.
    ///
    /// Only device matching the set criteria will be enumerated.
    /// If a dispatch queue is set, this call must occur before activation.
    /// Devices provided in the callback will be scheduled with the same
    /// runloop/dispatch queue as the IOHIDManagerRef, and should not be
    /// rescheduled.
    ///
    /// Parameter `manager`: Reference to an IOHIDManagerRef.
    ///
    /// Parameter `callback`: Pointer to a callback method of type
    /// IOHIDDeviceCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDManagerRegisterDeviceMatchingCallback")]
    #[inline]
    pub unsafe fn register_device_matching_callback(
        &self,
        callback: IOHIDDeviceCallback,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn IOHIDManagerRegisterDeviceMatchingCallback(
                manager: &IOHIDManager,
                callback: IOHIDDeviceCallback,
                context: *mut c_void,
            );
        }
        unsafe { IOHIDManagerRegisterDeviceMatchingCallback(self, callback, context) }
    }

    /// Registers a callback to be used when any enumerated device is removed.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManagerRef.
    ///
    /// - callback: Pointer to a callback method of type IOHIDDeviceCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// ## Discussion
    ///
    /// In most cases this occurs when a device is unplugged.
    ///
    ///
    /// Registers a callback to be used when any enumerated device is
    /// removed.
    ///
    /// In most cases this occurs when a device is unplugged.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `manager`: Reference to an IOHIDManagerRef.
    ///
    /// Parameter `callback`: Pointer to a callback method of type
    /// IOHIDDeviceCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDManagerRegisterDeviceRemovalCallback")]
    #[inline]
    pub unsafe fn register_device_removal_callback(
        &self,
        callback: IOHIDDeviceCallback,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn IOHIDManagerRegisterDeviceRemovalCallback(
                manager: &IOHIDManager,
                callback: IOHIDDeviceCallback,
                context: *mut c_void,
            );
        }
        unsafe { IOHIDManagerRegisterDeviceRemovalCallback(self, callback, context) }
    }

    /// Registers a callback to be used when an input report is issued by any enumerated device.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManagerRef.
    ///
    /// - callback: Pointer to a callback method of type IOHIDReportCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// ## Discussion
    ///
    /// An input report is an interrupt driver report issued by a device.
    ///
    ///
    /// Registers a callback to be used when an input report is issued by
    /// any enumerated device.
    ///
    /// An input report is an interrupt driver report issued by a device.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `manager`: Reference to an IOHIDManagerRef.
    ///
    /// Parameter `callback`: Pointer to a callback method of type IOHIDReportCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDManagerRegisterInputReportCallback")]
    #[inline]
    pub unsafe fn register_input_report_callback(
        &self,
        callback: IOHIDReportCallback,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn IOHIDManagerRegisterInputReportCallback(
                manager: &IOHIDManager,
                callback: IOHIDReportCallback,
                context: *mut c_void,
            );
        }
        unsafe { IOHIDManagerRegisterInputReportCallback(self, callback, context) }
    }

    /// Registers a callback to be used when an input report is issued by
    /// any enumerated device.
    ///
    /// An input report is an interrupt driver report issued by a device.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `manager`: Reference to an IOHIDManagerRef.
    ///
    /// Parameter `callback`: Pointer to a callback method of type
    /// IOHIDReportWithTimeStampCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDManagerRegisterInputReportWithTimeStampCallback")]
    #[inline]
    pub unsafe fn register_input_report_with_time_stamp_callback(
        &self,
        callback: IOHIDReportWithTimeStampCallback,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn IOHIDManagerRegisterInputReportWithTimeStampCallback(
                manager: &IOHIDManager,
                callback: IOHIDReportWithTimeStampCallback,
                context: *mut c_void,
            );
        }
        unsafe { IOHIDManagerRegisterInputReportWithTimeStampCallback(self, callback, context) }
    }

    /// Registers a callback to be used when an input value is issued by any enumerated device.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManagerRef.
    ///
    /// - callback: Pointer to a callback method of type IOHIDValueCallback.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// ## Discussion
    ///
    /// An input element refers to any element of type kIOHIDElementTypeInput and is usually issued by interrupt driven reports.
    ///
    ///
    /// Registers a callback to be used when an input value is issued by
    /// any enumerated device.
    ///
    /// An input element refers to any element of type
    /// kIOHIDElementTypeInput and is usually issued by interrupt driven
    /// reports.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `manager`: Reference to an IOHIDManagerRef.
    ///
    /// Parameter `callback`: Pointer to a callback method of type IOHIDValueCallback.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDManagerRegisterInputValueCallback")]
    #[inline]
    pub unsafe fn register_input_value_callback(
        &self,
        callback: IOHIDValueCallback,
        context: *mut c_void,
    ) {
        extern "C-unwind" {
            fn IOHIDManagerRegisterInputValueCallback(
                manager: &IOHIDManager,
                callback: IOHIDValueCallback,
                context: *mut c_void,
            );
        }
        unsafe { IOHIDManagerRegisterInputValueCallback(self, callback, context) }
    }

    /// Sets matching criteria for input values received via IOHIDManagerRegisterInputValueCallback.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - matching: CFDictionaryRef containg device matching criteria.
    ///
    ///
    /// ## Discussion
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in <IOKit/hid/IOHIDKeys.h>. Passing a NULL dictionary will result in all devices being enumerated. Any subsequent calls will cause the hid manager to release previously matched input elements and restart the matching process using the revised criteria. If interested in multiple, specific device elements, please defer to using IOHIDManagerSetInputValueMatchingMultiple.
    ///
    ///
    /// Sets matching criteria for input values received via
    /// IOHIDManagerRegisterInputValueCallback.
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>.  Passing a NULL dictionary will result
    /// in all devices being enumerated. Any subsequent calls will cause
    /// the hid manager to release previously matched input elements and
    /// restart the matching process using the revised criteria.  If
    /// interested in multiple, specific device elements, please defer to
    /// using IOHIDManagerSetInputValueMatchingMultiple.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `matching`: CFDictionaryRef containg device matching criteria.
    ///
    /// # Safety
    ///
    /// - `matching` generic must be of the correct type.
    /// - `matching` generic must be of the correct type.
    #[doc(alias = "IOHIDManagerSetInputValueMatching")]
    #[inline]
    pub unsafe fn set_input_value_matching(&self, matching: Option<&CFDictionary>) {
        extern "C-unwind" {
            fn IOHIDManagerSetInputValueMatching(
                manager: &IOHIDManager,
                matching: Option<&CFDictionary>,
            );
        }
        unsafe { IOHIDManagerSetInputValueMatching(self, matching) }
    }

    /// Sets multiple matching criteria for input values received via IOHIDManagerRegisterInputValueCallback.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - multiple: CFArrayRef containing multiple CFDictionaryRef objects containing input element matching criteria.
    ///
    ///
    /// ## Discussion
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in <IOKit/hid/IOHIDKeys.h>. This method is useful if interested in multiple, specific elements .
    ///
    ///
    /// Sets multiple matching criteria for input values received via
    /// IOHIDManagerRegisterInputValueCallback.
    ///
    /// Matching keys are prefixed by kIOHIDElement and declared in
    /// <IOKit
    /// /hid/IOHIDKeys.h>.  This method is useful if interested
    /// in multiple, specific elements.
    /// If a dispatch queue is set, this call must occur before activation.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `multiple`: CFArrayRef containing multiple CFDictionaryRef objects
    /// containing input element matching criteria.
    ///
    /// # Safety
    ///
    /// `multiple` generic must be of the correct type.
    #[doc(alias = "IOHIDManagerSetInputValueMatchingMultiple")]
    #[inline]
    pub unsafe fn set_input_value_matching_multiple(&self, multiple: Option<&CFArray>) {
        extern "C-unwind" {
            fn IOHIDManagerSetInputValueMatchingMultiple(
                manager: &IOHIDManager,
                multiple: Option<&CFArray>,
            );
        }
        unsafe { IOHIDManagerSetInputValueMatchingMultiple(self, multiple) }
    }

    /// Used to write out the current properties to a specific domain.
    ///
    /// Parameters:
    /// - manager: Reference to an IOHIDManager.
    ///
    /// - applicationID: Reference to a CFPreferences applicationID.
    ///
    /// - userName: Reference to a CFPreferences userName.
    ///
    /// - hostName: Reference to a CFPreferences hostName.
    ///
    /// - options: Reserved for future use.
    ///
    ///
    /// ## Discussion
    ///
    /// Using this function will cause the persistent properties to be saved out replacing any properties that already existed in the specified domain. All arguments must be non-NULL except options.
    ///
    ///
    /// Used to write out the current properties to a specific domain.
    ///
    /// Using this function will cause the persistent properties to be saved out
    /// replacing any properties that already existed in the specified domain. All arguments
    /// must be non-NULL except options.
    ///
    /// Parameter `manager`: Reference to an IOHIDManager.
    ///
    /// Parameter `applicationID`: Reference to a CFPreferences applicationID.
    ///
    /// Parameter `userName`: Reference to a CFPreferences userName.
    ///
    /// Parameter `hostName`: Reference to a CFPreferences hostName.
    ///
    /// Parameter `options`: Reserved for future use.
    #[doc(alias = "IOHIDManagerSaveToPropertyDomain")]
    #[inline]
    pub fn save_to_property_domain(
        &self,
        application_id: &CFString,
        user_name: &CFString,
        host_name: &CFString,
        options: IOOptionBits,
    ) {
        extern "C-unwind" {
            fn IOHIDManagerSaveToPropertyDomain(
                manager: &IOHIDManager,
                application_id: &CFString,
                user_name: &CFString,
                host_name: &CFString,
                options: IOOptionBits,
            );
        }
        unsafe {
            IOHIDManagerSaveToPropertyDomain(self, application_id, user_name, host_name, options)
        }
    }
}

pub const kHIDPage_Undefined: c_uint = 0x00;
pub const kHIDPage_GenericDesktop: c_uint = 0x01;
pub const kHIDPage_Simulation: c_uint = 0x02;
pub const kHIDPage_VR: c_uint = 0x03;
pub const kHIDPage_Sport: c_uint = 0x04;
pub const kHIDPage_Game: c_uint = 0x05;
pub const kHIDPage_GenericDeviceControls: c_uint = 0x06;
pub const kHIDPage_KeyboardOrKeypad: c_uint = 0x07;
pub const kHIDPage_LEDs: c_uint = 0x08;
pub const kHIDPage_Button: c_uint = 0x09;
pub const kHIDPage_Ordinal: c_uint = 0x0A;
pub const kHIDPage_Telephony: c_uint = 0x0B;
pub const kHIDPage_Consumer: c_uint = 0x0C;
pub const kHIDPage_Digitizer: c_uint = 0x0D;
pub const kHIDPage_Haptics: c_uint = 0x0E;
pub const kHIDPage_PID: c_uint = 0x0F;
pub const kHIDPage_Unicode: c_uint = 0x10;
pub const kHIDPage_AlphanumericDisplay: c_uint = 0x14;
pub const kHIDPage_Sensor: c_uint = 0x20;
pub const kHIDPage_BrailleDisplay: c_uint = 0x41;
pub const kHIDPage_Monitor: c_uint = 0x80;
pub const kHIDPage_MonitorEnumerated: c_uint = 0x81;
pub const kHIDPage_MonitorVirtual: c_uint = 0x82;
pub const kHIDPage_MonitorReserved: c_uint = 0x83;
pub const kHIDPage_PowerDevice: c_uint = 0x84;
pub const kHIDPage_BatterySystem: c_uint = 0x85;
pub const kHIDPage_PowerReserved: c_uint = 0x86;
pub const kHIDPage_PowerReserved2: c_uint = 0x87;
pub const kHIDPage_BarCodeScanner: c_uint = 0x8C;
pub const kHIDPage_WeighingDevice: c_uint = 0x8D;
pub const kHIDPage_Scale: c_uint = 0x8D;
pub const kHIDPage_MagneticStripeReader: c_uint = 0x8E;
pub const kHIDPage_CameraControl: c_uint = 0x90;
pub const kHIDPage_Arcade: c_uint = 0x91;
pub const kHIDPage_FIDO: c_uint = 0xF1D0;
pub const kHIDPage_VendorDefinedStart: c_uint = 0xFF00;

pub const kHIDUsage_Undefined: c_uint = 0x00;

pub const kHIDUsage_GD_Pointer: c_uint = 0x01;
pub const kHIDUsage_GD_Mouse: c_uint = 0x02;
pub const kHIDUsage_GD_Joystick: c_uint = 0x04;
pub const kHIDUsage_GD_GamePad: c_uint = 0x05;
pub const kHIDUsage_GD_Keyboard: c_uint = 0x06;
pub const kHIDUsage_GD_Keypad: c_uint = 0x07;
pub const kHIDUsage_GD_MultiAxisController: c_uint = 0x08;
pub const kHIDUsage_GD_TabletPCSystemControls: c_uint = 0x09;
pub const kHIDUsage_GD_AssistiveControl: c_uint = 0x0A;
pub const kHIDUsage_GD_SystemMultiAxisController: c_uint = 0x0E;
pub const kHIDUsage_GD_SpatialController: c_uint = 0x0F;
pub const kHIDUsage_GD_AssistiveControlCompatible: c_uint = 0x10;
pub const kHIDUsage_GD_X: c_uint = 0x30;
pub const kHIDUsage_GD_Y: c_uint = 0x31;
pub const kHIDUsage_GD_Z: c_uint = 0x32;
pub const kHIDUsage_GD_Rx: c_uint = 0x33;
pub const kHIDUsage_GD_Ry: c_uint = 0x34;
pub const kHIDUsage_GD_Rz: c_uint = 0x35;
pub const kHIDUsage_GD_Slider: c_uint = 0x36;
pub const kHIDUsage_GD_Dial: c_uint = 0x37;
pub const kHIDUsage_GD_Wheel: c_uint = 0x38;
pub const kHIDUsage_GD_Hatswitch: c_uint = 0x39;
pub const kHIDUsage_GD_CountedBuffer: c_uint = 0x3A;
pub const kHIDUsage_GD_ByteCount: c_uint = 0x3B;
pub const kHIDUsage_GD_MotionWakeup: c_uint = 0x3C;
pub const kHIDUsage_GD_Start: c_uint = 0x3D;
pub const kHIDUsage_GD_Select: c_uint = 0x3E;
pub const kHIDUsage_GD_Vx: c_uint = 0x40;
pub const kHIDUsage_GD_Vy: c_uint = 0x41;
pub const kHIDUsage_GD_Vz: c_uint = 0x42;
pub const kHIDUsage_GD_Vbrx: c_uint = 0x43;
pub const kHIDUsage_GD_Vbry: c_uint = 0x44;
pub const kHIDUsage_GD_Vbrz: c_uint = 0x45;
pub const kHIDUsage_GD_Vno: c_uint = 0x46;
pub const kHIDUsage_GD_FeatureNotification: c_uint = 0x47;
pub const kHIDUsage_GD_ResolutionMultiplier: c_uint = 0x48;
pub const kHIDUsage_GD_Qx: c_uint = 0x49;
pub const kHIDUsage_GD_Qy: c_uint = 0x4A;
pub const kHIDUsage_GD_Qz: c_uint = 0x4B;
pub const kHIDUsage_GD_Qw: c_uint = 0x4C;
pub const kHIDUsage_GD_SystemControl: c_uint = 0x80;
pub const kHIDUsage_GD_SystemPowerDown: c_uint = 0x81;
pub const kHIDUsage_GD_SystemSleep: c_uint = 0x82;
pub const kHIDUsage_GD_SystemWakeUp: c_uint = 0x83;
pub const kHIDUsage_GD_SystemContextMenu: c_uint = 0x84;
pub const kHIDUsage_GD_SystemMainMenu: c_uint = 0x85;
pub const kHIDUsage_GD_SystemAppMenu: c_uint = 0x86;
pub const kHIDUsage_GD_SystemMenuHelp: c_uint = 0x87;
pub const kHIDUsage_GD_SystemMenuExit: c_uint = 0x88;
pub const kHIDUsage_GD_SystemMenuSelect: c_uint = 0x89;
pub const kHIDUsage_GD_SystemMenu: c_uint = kHIDUsage_GD_SystemMenuSelect;
pub const kHIDUsage_GD_SystemMenuRight: c_uint = 0x8A;
pub const kHIDUsage_GD_SystemMenuLeft: c_uint = 0x8B;
pub const kHIDUsage_GD_SystemMenuUp: c_uint = 0x8C;
pub const kHIDUsage_GD_SystemMenuDown: c_uint = 0x8D;
pub const kHIDUsage_GD_SystemColdRestart: c_uint = 0x8E;
pub const kHIDUsage_GD_SystemWarmRestart: c_uint = 0x8F;
pub const kHIDUsage_GD_DPadUp: c_uint = 0x90;
pub const kHIDUsage_GD_DPadDown: c_uint = 0x91;
pub const kHIDUsage_GD_DPadRight: c_uint = 0x92;
pub const kHIDUsage_GD_DPadLeft: c_uint = 0x93;
pub const kHIDUsage_GD_IndexTrigger: c_uint = 0x94;
pub const kHIDUsage_GD_PalmTrigger: c_uint = 0x95;
pub const kHIDUsage_GD_Thumbstick: c_uint = 0x96;
pub const kHIDUsage_GD_SFShift: c_uint = 0x97;
pub const kHIDUsage_GD_SFShiftLock: c_uint = 0x98;
pub const kHIDUsage_GD_SFShiftLockIndicator: c_uint = 0x99;
pub const kHIDUsage_GD_SystemDismissNotification: c_uint = 0x9A;
pub const kHIDUsage_GD_DoNotDisturb: c_uint = 0x9B;
pub const kHIDUsage_GD_SystemDock: c_uint = 0xA0;
pub const kHIDUsage_GD_SystemUndock: c_uint = 0xA1;
pub const kHIDUsage_GD_SystemSetup: c_uint = 0xA2;
pub const kHIDUsage_GD_SystemBreak: c_uint = 0xA3;
pub const kHIDUsage_GD_SystemDebuggerBreak: c_uint = 0xA4;
pub const kHIDUsage_GD_ApplicationBreak: c_uint = 0xA5;
pub const kHIDUsage_GD_ApplicationDebuggerBreak: c_uint = 0xA6;
pub const kHIDUsage_GD_SystemSpeakerMute: c_uint = 0xA7;
pub const kHIDUsage_GD_SystemHibernate: c_uint = 0xA8;
pub const kHIDUsage_GD_SystemMicrophoneMute: c_uint = 0xA9;
pub const kHIDUsage_GD_SystemDisplayInvert: c_uint = 0xB0;
pub const kHIDUsage_GD_SystemDisplayInternal: c_uint = 0xB1;
pub const kHIDUsage_GD_SystemDisplayExternal: c_uint = 0xB2;
pub const kHIDUsage_GD_SystemDisplayBoth: c_uint = 0xB3;
pub const kHIDUsage_GD_SystemDisplayDual: c_uint = 0xB4;
pub const kHIDUsage_GD_SystemDisplayToggleMode: c_uint = 0xB5;
pub const kHIDUsage_GD_SystemDisplaySwap: c_uint = 0xB6;
pub const kHIDUsage_GD_SystemDisplayToggleLCDAutoscale: c_uint = 0xB7;
pub const kHIDUsage_GD_SensorZone: c_uint = 0xC0;
pub const kHIDUsage_GD_RPM: c_uint = 0xC1;
pub const kHIDUsage_GD_CoolantLevel: c_uint = 0xC2;
pub const kHIDUsage_GD_CoolantCriticalLevel: c_uint = 0xC3;
pub const kHIDUsage_GD_CoolantPump: c_uint = 0xC4;
pub const kHIDUsage_GD_ChassisEnclosure: c_uint = 0xC5;
pub const kHIDUsage_GD_WirelessRadioButton: c_uint = 0xC6;
pub const kHIDUsage_GD_WirelessRadioLED: c_uint = 0xC7;
pub const kHIDUsage_GD_WirelessRadioSliderSwitch: c_uint = 0xC8;
pub const kHIDUsage_GD_SystemDisplayRotationLockButton: c_uint = 0xC9;
pub const kHIDUsage_GD_SystemDisplayRotationLockSliderSwitch: c_uint = 0xCA;
pub const kHIDUsage_GD_ControlEnable: c_uint = 0xCB;
pub const kHIDUsage_GD_DockableDeviceUniqueID: c_uint = 0xD0;
pub const kHIDUsage_GD_DockableDeviceVendorID: c_uint = 0xD1;
pub const kHIDUsage_GD_DockableDevicePrimaryUsagePage: c_uint = 0xD2;
pub const kHIDUsage_GD_DockableDevicePrimaryUsageID: c_uint = 0xD3;
pub const kHIDUsage_GD_DockableDeviceDockingState: c_uint = 0xD4;
pub const kHIDUsage_GD_DockableDeviceDisplayOcclusion: c_uint = 0xD5;
pub const kHIDUsage_GD_DockableDeviceObjectType: c_uint = 0xD6;
pub const kHIDUsage_GD_CallActiveLED: c_uint = 0xE0;
pub const kHIDUsage_GD_CallMuteToggle: c_uint = 0xE1;
pub const kHIDUsage_GD_CallMuteLED: c_uint = 0xE2;
pub const kHIDUsage_GD_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_Sim_FlightSimulationDevice: c_uint = 0x01;
pub const kHIDUsage_Sim_AutomobileSimulationDevice: c_uint = 0x02;
pub const kHIDUsage_Sim_TankSimulationDevice: c_uint = 0x03;
pub const kHIDUsage_Sim_SpaceshipSimulationDevice: c_uint = 0x04;
pub const kHIDUsage_Sim_SubmarineSimulationDevice: c_uint = 0x05;
pub const kHIDUsage_Sim_SailingSimulationDevice: c_uint = 0x06;
pub const kHIDUsage_Sim_MotorcycleSimulationDevice: c_uint = 0x07;
pub const kHIDUsage_Sim_SportsSimulationDevice: c_uint = 0x08;
pub const kHIDUsage_Sim_AirplaneSimulationDevice: c_uint = 0x09;
pub const kHIDUsage_Sim_HelicopterSimulationDevice: c_uint = 0x0A;
pub const kHIDUsage_Sim_MagicCarpetSimulationDevice: c_uint = 0x0B;
pub const kHIDUsage_Sim_BicycleSimulationDevice: c_uint = 0x0C;
pub const kHIDUsage_Sim_FlightControlStick: c_uint = 0x20;
pub const kHIDUsage_Sim_FlightStick: c_uint = 0x21;
pub const kHIDUsage_Sim_CyclicControl: c_uint = 0x22;
pub const kHIDUsage_Sim_CyclicTrim: c_uint = 0x23;
pub const kHIDUsage_Sim_FlightYoke: c_uint = 0x24;
pub const kHIDUsage_Sim_TrackControl: c_uint = 0x25;
pub const kHIDUsage_Sim_Aileron: c_uint = 0xB0;
pub const kHIDUsage_Sim_AileronTrim: c_uint = 0xB1;
pub const kHIDUsage_Sim_AntiTorqueControl: c_uint = 0xB2;
pub const kHIDUsage_Sim_AutopilotEnable: c_uint = 0xB3;
pub const kHIDUsage_Sim_ChaffRelease: c_uint = 0xB4;
pub const kHIDUsage_Sim_CollectiveControl: c_uint = 0xB5;
pub const kHIDUsage_Sim_DiveBrake: c_uint = 0xB6;
pub const kHIDUsage_Sim_ElectronicCountermeasures: c_uint = 0xB7;
pub const kHIDUsage_Sim_Elevator: c_uint = 0xB8;
pub const kHIDUsage_Sim_ElevatorTrim: c_uint = 0xB9;
pub const kHIDUsage_Sim_Rudder: c_uint = 0xBA;
pub const kHIDUsage_Sim_Throttle: c_uint = 0xBB;
pub const kHIDUsage_Sim_FlightCommunications: c_uint = 0xBC;
pub const kHIDUsage_Sim_FlareRelease: c_uint = 0xBD;
pub const kHIDUsage_Sim_LandingGear: c_uint = 0xBE;
pub const kHIDUsage_Sim_ToeBrake: c_uint = 0xBF;
pub const kHIDUsage_Sim_Trigger: c_uint = 0xC0;
pub const kHIDUsage_Sim_WeaponsArm: c_uint = 0xC1;
pub const kHIDUsage_Sim_Weapons: c_uint = 0xC2;
pub const kHIDUsage_Sim_WingFlaps: c_uint = 0xC3;
pub const kHIDUsage_Sim_Accelerator: c_uint = 0xC4;
pub const kHIDUsage_Sim_Brake: c_uint = 0xC5;
pub const kHIDUsage_Sim_Clutch: c_uint = 0xC6;
pub const kHIDUsage_Sim_Shifter: c_uint = 0xC7;
pub const kHIDUsage_Sim_Steering: c_uint = 0xC8;
pub const kHIDUsage_Sim_TurretDirection: c_uint = 0xC9;
pub const kHIDUsage_Sim_BarrelElevation: c_uint = 0xCA;
pub const kHIDUsage_Sim_DivePlane: c_uint = 0xCB;
pub const kHIDUsage_Sim_Ballast: c_uint = 0xCC;
pub const kHIDUsage_Sim_BicycleCrank: c_uint = 0xCD;
pub const kHIDUsage_Sim_HandleBars: c_uint = 0xCE;
pub const kHIDUsage_Sim_FrontBrake: c_uint = 0xCF;
pub const kHIDUsage_Sim_RearBrake: c_uint = 0xD0;
pub const kHIDUsage_Sim_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_VR_Belt: c_uint = 0x01;
pub const kHIDUsage_VR_BodySuit: c_uint = 0x02;
pub const kHIDUsage_VR_Flexor: c_uint = 0x03;
pub const kHIDUsage_VR_Glove: c_uint = 0x04;
pub const kHIDUsage_VR_HeadTracker: c_uint = 0x05;
pub const kHIDUsage_VR_HeadMountedDisplay: c_uint = 0x06;
pub const kHIDUsage_VR_HandTracker: c_uint = 0x07;
pub const kHIDUsage_VR_Oculometer: c_uint = 0x08;
pub const kHIDUsage_VR_Vest: c_uint = 0x09;
pub const kHIDUsage_VR_AnimatronicDevice: c_uint = 0x0A;
pub const kHIDUsage_VR_StereoEnable: c_uint = 0x20;
pub const kHIDUsage_VR_DisplayEnable: c_uint = 0x21;
pub const kHIDUsage_VR_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_Sprt_BaseballBat: c_uint = 0x01;
pub const kHIDUsage_Sprt_GolfClub: c_uint = 0x02;
pub const kHIDUsage_Sprt_RowingMachine: c_uint = 0x03;
pub const kHIDUsage_Sprt_Treadmill: c_uint = 0x04;
pub const kHIDUsage_Sprt_Oar: c_uint = 0x30;
pub const kHIDUsage_Sprt_Slope: c_uint = 0x31;
pub const kHIDUsage_Sprt_Rate: c_uint = 0x32;
pub const kHIDUsage_Sprt_StickSpeed: c_uint = 0x33;
pub const kHIDUsage_Sprt_StickFaceAngle: c_uint = 0x34;
pub const kHIDUsage_Sprt_StickHeelOrToe: c_uint = 0x35;
pub const kHIDUsage_Sprt_StickFollowThrough: c_uint = 0x36;
pub const kHIDUsage_Sprt_StickTempo: c_uint = 0x37;
pub const kHIDUsage_Sprt_StickType: c_uint = 0x38;
pub const kHIDUsage_Sprt_StickHeight: c_uint = 0x39;
pub const kHIDUsage_Sprt_Putter: c_uint = 0x50;
pub const kHIDUsage_Sprt_1Iron: c_uint = 0x51;
pub const kHIDUsage_Sprt_2Iron: c_uint = 0x52;
pub const kHIDUsage_Sprt_3Iron: c_uint = 0x53;
pub const kHIDUsage_Sprt_4Iron: c_uint = 0x54;
pub const kHIDUsage_Sprt_5Iron: c_uint = 0x55;
pub const kHIDUsage_Sprt_6Iron: c_uint = 0x56;
pub const kHIDUsage_Sprt_7Iron: c_uint = 0x57;
pub const kHIDUsage_Sprt_8Iron: c_uint = 0x58;
pub const kHIDUsage_Sprt_9Iron: c_uint = 0x59;
pub const kHIDUsage_Sprt_10Iron: c_uint = 0x5A;
pub const kHIDUsage_Sprt_11Iron: c_uint = 0x5B;
pub const kHIDUsage_Sprt_SandWedge: c_uint = 0x5C;
pub const kHIDUsage_Sprt_LoftWedge: c_uint = 0x5D;
pub const kHIDUsage_Sprt_PowerWedge: c_uint = 0x5E;
pub const kHIDUsage_Sprt_1Wood: c_uint = 0x5F;
pub const kHIDUsage_Sprt_3Wood: c_uint = 0x60;
pub const kHIDUsage_Sprt_5Wood: c_uint = 0x61;
pub const kHIDUsage_Sprt_7Wood: c_uint = 0x62;
pub const kHIDUsage_Sprt_9Wood: c_uint = 0x63;
pub const kHIDUsage_Sprt_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_Game_3DGameController: c_uint = 0x01;
pub const kHIDUsage_Game_PinballDevice: c_uint = 0x02;
pub const kHIDUsage_Game_GunDevice: c_uint = 0x03;
pub const kHIDUsage_Game_PointofView: c_uint = 0x20;
pub const kHIDUsage_Game_TurnRightOrLeft: c_uint = 0x21;
pub const kHIDUsage_Game_PitchUpOrDown: c_uint = 0x22;
pub const kHIDUsage_Game_RollRightOrLeft: c_uint = 0x23;
pub const kHIDUsage_Game_MoveRightOrLeft: c_uint = 0x24;
pub const kHIDUsage_Game_MoveForwardOrBackward: c_uint = 0x25;
pub const kHIDUsage_Game_MoveUpOrDown: c_uint = 0x26;
pub const kHIDUsage_Game_LeanRightOrLeft: c_uint = 0x27;
pub const kHIDUsage_Game_LeanForwardOrBackward: c_uint = 0x28;
pub const kHIDUsage_Game_HeightOfPOV: c_uint = 0x29;
pub const kHIDUsage_Game_Flipper: c_uint = 0x2A;
pub const kHIDUsage_Game_SecondaryFlipper: c_uint = 0x2B;
pub const kHIDUsage_Game_Bump: c_uint = 0x2C;
pub const kHIDUsage_Game_NewGame: c_uint = 0x2D;
pub const kHIDUsage_Game_ShootBall: c_uint = 0x2E;
pub const kHIDUsage_Game_Player: c_uint = 0x2F;
pub const kHIDUsage_Game_GunBolt: c_uint = 0x30;
pub const kHIDUsage_Game_GunClip: c_uint = 0x31;
pub const kHIDUsage_Game_Gun: c_uint = 0x32;
pub const kHIDUsage_Game_GunSingleShot: c_uint = 0x33;
pub const kHIDUsage_Game_GunBurst: c_uint = 0x34;
pub const kHIDUsage_Game_GunAutomatic: c_uint = 0x35;
pub const kHIDUsage_Game_GunSafety: c_uint = 0x36;
pub const kHIDUsage_Game_GamepadFireOrJump: c_uint = 0x37;
pub const kHIDUsage_Game_GamepadTrigger: c_uint = 0x39;
pub const kHIDUsage_Game_GamepadFormFitting_Compatibility: c_uint = 0x39;
pub const kHIDUsage_Game_GamepadFormFitting: c_uint = 0x3A;
pub const kHIDUsage_Game_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_GenDevControls_BackgroundControls: c_uint = 0x01;
pub const kHIDUsage_GenDevControls_BatteryStrength: c_uint = 0x20;

pub const kHIDUsage_KeyboardErrorRollOver: c_uint = 0x01;
pub const kHIDUsage_KeyboardPOSTFail: c_uint = 0x02;
pub const kHIDUsage_KeyboardErrorUndefined: c_uint = 0x03;
pub const kHIDUsage_KeyboardA: c_uint = 0x04;
pub const kHIDUsage_KeyboardB: c_uint = 0x05;
pub const kHIDUsage_KeyboardC: c_uint = 0x06;
pub const kHIDUsage_KeyboardD: c_uint = 0x07;
pub const kHIDUsage_KeyboardE: c_uint = 0x08;
pub const kHIDUsage_KeyboardF: c_uint = 0x09;
pub const kHIDUsage_KeyboardG: c_uint = 0x0A;
pub const kHIDUsage_KeyboardH: c_uint = 0x0B;
pub const kHIDUsage_KeyboardI: c_uint = 0x0C;
pub const kHIDUsage_KeyboardJ: c_uint = 0x0D;
pub const kHIDUsage_KeyboardK: c_uint = 0x0E;
pub const kHIDUsage_KeyboardL: c_uint = 0x0F;
pub const kHIDUsage_KeyboardM: c_uint = 0x10;
pub const kHIDUsage_KeyboardN: c_uint = 0x11;
pub const kHIDUsage_KeyboardO: c_uint = 0x12;
pub const kHIDUsage_KeyboardP: c_uint = 0x13;
pub const kHIDUsage_KeyboardQ: c_uint = 0x14;
pub const kHIDUsage_KeyboardR: c_uint = 0x15;
pub const kHIDUsage_KeyboardS: c_uint = 0x16;
pub const kHIDUsage_KeyboardT: c_uint = 0x17;
pub const kHIDUsage_KeyboardU: c_uint = 0x18;
pub const kHIDUsage_KeyboardV: c_uint = 0x19;
pub const kHIDUsage_KeyboardW: c_uint = 0x1A;
pub const kHIDUsage_KeyboardX: c_uint = 0x1B;
pub const kHIDUsage_KeyboardY: c_uint = 0x1C;
pub const kHIDUsage_KeyboardZ: c_uint = 0x1D;
pub const kHIDUsage_Keyboard1: c_uint = 0x1E;
pub const kHIDUsage_Keyboard2: c_uint = 0x1F;
pub const kHIDUsage_Keyboard3: c_uint = 0x20;
pub const kHIDUsage_Keyboard4: c_uint = 0x21;
pub const kHIDUsage_Keyboard5: c_uint = 0x22;
pub const kHIDUsage_Keyboard6: c_uint = 0x23;
pub const kHIDUsage_Keyboard7: c_uint = 0x24;
pub const kHIDUsage_Keyboard8: c_uint = 0x25;
pub const kHIDUsage_Keyboard9: c_uint = 0x26;
pub const kHIDUsage_Keyboard0: c_uint = 0x27;
pub const kHIDUsage_KeyboardReturnOrEnter: c_uint = 0x28;
pub const kHIDUsage_KeyboardEscape: c_uint = 0x29;
pub const kHIDUsage_KeyboardDeleteOrBackspace: c_uint = 0x2A;
pub const kHIDUsage_KeyboardTab: c_uint = 0x2B;
pub const kHIDUsage_KeyboardSpacebar: c_uint = 0x2C;
pub const kHIDUsage_KeyboardHyphen: c_uint = 0x2D;
pub const kHIDUsage_KeyboardEqualSign: c_uint = 0x2E;
pub const kHIDUsage_KeyboardOpenBracket: c_uint = 0x2F;
pub const kHIDUsage_KeyboardCloseBracket: c_uint = 0x30;
pub const kHIDUsage_KeyboardBackslash: c_uint = 0x31;
pub const kHIDUsage_KeyboardNonUSPound: c_uint = 0x32;
pub const kHIDUsage_KeyboardSemicolon: c_uint = 0x33;
pub const kHIDUsage_KeyboardQuote: c_uint = 0x34;
pub const kHIDUsage_KeyboardGraveAccentAndTilde: c_uint = 0x35;
pub const kHIDUsage_KeyboardComma: c_uint = 0x36;
pub const kHIDUsage_KeyboardPeriod: c_uint = 0x37;
pub const kHIDUsage_KeyboardSlash: c_uint = 0x38;
pub const kHIDUsage_KeyboardCapsLock: c_uint = 0x39;
pub const kHIDUsage_KeyboardF1: c_uint = 0x3A;
pub const kHIDUsage_KeyboardF2: c_uint = 0x3B;
pub const kHIDUsage_KeyboardF3: c_uint = 0x3C;
pub const kHIDUsage_KeyboardF4: c_uint = 0x3D;
pub const kHIDUsage_KeyboardF5: c_uint = 0x3E;
pub const kHIDUsage_KeyboardF6: c_uint = 0x3F;
pub const kHIDUsage_KeyboardF7: c_uint = 0x40;
pub const kHIDUsage_KeyboardF8: c_uint = 0x41;
pub const kHIDUsage_KeyboardF9: c_uint = 0x42;
pub const kHIDUsage_KeyboardF10: c_uint = 0x43;
pub const kHIDUsage_KeyboardF11: c_uint = 0x44;
pub const kHIDUsage_KeyboardF12: c_uint = 0x45;
pub const kHIDUsage_KeyboardPrintScreen: c_uint = 0x46;
pub const kHIDUsage_KeyboardScrollLock: c_uint = 0x47;
pub const kHIDUsage_KeyboardPause: c_uint = 0x48;
pub const kHIDUsage_KeyboardInsert: c_uint = 0x49;
pub const kHIDUsage_KeyboardHome: c_uint = 0x4A;
pub const kHIDUsage_KeyboardPageUp: c_uint = 0x4B;
pub const kHIDUsage_KeyboardDeleteForward: c_uint = 0x4C;
pub const kHIDUsage_KeyboardEnd: c_uint = 0x4D;
pub const kHIDUsage_KeyboardPageDown: c_uint = 0x4E;
pub const kHIDUsage_KeyboardRightArrow: c_uint = 0x4F;
pub const kHIDUsage_KeyboardLeftArrow: c_uint = 0x50;
pub const kHIDUsage_KeyboardDownArrow: c_uint = 0x51;
pub const kHIDUsage_KeyboardUpArrow: c_uint = 0x52;
pub const kHIDUsage_KeypadNumLock: c_uint = 0x53;
pub const kHIDUsage_KeypadSlash: c_uint = 0x54;
pub const kHIDUsage_KeypadAsterisk: c_uint = 0x55;
pub const kHIDUsage_KeypadHyphen: c_uint = 0x56;
pub const kHIDUsage_KeypadPlus: c_uint = 0x57;
pub const kHIDUsage_KeypadEnter: c_uint = 0x58;
pub const kHIDUsage_Keypad1: c_uint = 0x59;
pub const kHIDUsage_Keypad2: c_uint = 0x5A;
pub const kHIDUsage_Keypad3: c_uint = 0x5B;
pub const kHIDUsage_Keypad4: c_uint = 0x5C;
pub const kHIDUsage_Keypad5: c_uint = 0x5D;
pub const kHIDUsage_Keypad6: c_uint = 0x5E;
pub const kHIDUsage_Keypad7: c_uint = 0x5F;
pub const kHIDUsage_Keypad8: c_uint = 0x60;
pub const kHIDUsage_Keypad9: c_uint = 0x61;
pub const kHIDUsage_Keypad0: c_uint = 0x62;
pub const kHIDUsage_KeypadPeriod: c_uint = 0x63;
pub const kHIDUsage_KeyboardNonUSBackslash: c_uint = 0x64;
pub const kHIDUsage_KeyboardApplication: c_uint = 0x65;
pub const kHIDUsage_KeyboardPower: c_uint = 0x66;
pub const kHIDUsage_KeypadEqualSign: c_uint = 0x67;
pub const kHIDUsage_KeyboardF13: c_uint = 0x68;
pub const kHIDUsage_KeyboardF14: c_uint = 0x69;
pub const kHIDUsage_KeyboardF15: c_uint = 0x6A;
pub const kHIDUsage_KeyboardF16: c_uint = 0x6B;
pub const kHIDUsage_KeyboardF17: c_uint = 0x6C;
pub const kHIDUsage_KeyboardF18: c_uint = 0x6D;
pub const kHIDUsage_KeyboardF19: c_uint = 0x6E;
pub const kHIDUsage_KeyboardF20: c_uint = 0x6F;
pub const kHIDUsage_KeyboardF21: c_uint = 0x70;
pub const kHIDUsage_KeyboardF22: c_uint = 0x71;
pub const kHIDUsage_KeyboardF23: c_uint = 0x72;
pub const kHIDUsage_KeyboardF24: c_uint = 0x73;
pub const kHIDUsage_KeyboardExecute: c_uint = 0x74;
pub const kHIDUsage_KeyboardHelp: c_uint = 0x75;
pub const kHIDUsage_KeyboardMenu: c_uint = 0x76;
pub const kHIDUsage_KeyboardSelect: c_uint = 0x77;
pub const kHIDUsage_KeyboardStop: c_uint = 0x78;
pub const kHIDUsage_KeyboardAgain: c_uint = 0x79;
pub const kHIDUsage_KeyboardUndo: c_uint = 0x7A;
pub const kHIDUsage_KeyboardCut: c_uint = 0x7B;
pub const kHIDUsage_KeyboardCopy: c_uint = 0x7C;
pub const kHIDUsage_KeyboardPaste: c_uint = 0x7D;
pub const kHIDUsage_KeyboardFind: c_uint = 0x7E;
pub const kHIDUsage_KeyboardMute: c_uint = 0x7F;
pub const kHIDUsage_KeyboardVolumeUp: c_uint = 0x80;
pub const kHIDUsage_KeyboardVolumeDown: c_uint = 0x81;
pub const kHIDUsage_KeyboardLockingCapsLock: c_uint = 0x82;
pub const kHIDUsage_KeyboardLockingNumLock: c_uint = 0x83;
pub const kHIDUsage_KeyboardLockingScrollLock: c_uint = 0x84;
pub const kHIDUsage_KeypadComma: c_uint = 0x85;
pub const kHIDUsage_KeypadEqualSignAS400: c_uint = 0x86;
pub const kHIDUsage_KeyboardInternational1: c_uint = 0x87;
pub const kHIDUsage_KeyboardInternational2: c_uint = 0x88;
pub const kHIDUsage_KeyboardInternational3: c_uint = 0x89;
pub const kHIDUsage_KeyboardInternational4: c_uint = 0x8A;
pub const kHIDUsage_KeyboardInternational5: c_uint = 0x8B;
pub const kHIDUsage_KeyboardInternational6: c_uint = 0x8C;
pub const kHIDUsage_KeyboardInternational7: c_uint = 0x8D;
pub const kHIDUsage_KeyboardInternational8: c_uint = 0x8E;
pub const kHIDUsage_KeyboardInternational9: c_uint = 0x8F;
pub const kHIDUsage_KeyboardLANG1: c_uint = 0x90;
pub const kHIDUsage_KeyboardLANG2: c_uint = 0x91;
pub const kHIDUsage_KeyboardLANG3: c_uint = 0x92;
pub const kHIDUsage_KeyboardLANG4: c_uint = 0x93;
pub const kHIDUsage_KeyboardLANG5: c_uint = 0x94;
pub const kHIDUsage_KeyboardLANG6: c_uint = 0x95;
pub const kHIDUsage_KeyboardLANG7: c_uint = 0x96;
pub const kHIDUsage_KeyboardLANG8: c_uint = 0x97;
pub const kHIDUsage_KeyboardLANG9: c_uint = 0x98;
pub const kHIDUsage_KeyboardAlternateErase: c_uint = 0x99;
pub const kHIDUsage_KeyboardSysReqOrAttention: c_uint = 0x9A;
pub const kHIDUsage_KeyboardCancel: c_uint = 0x9B;
pub const kHIDUsage_KeyboardClear: c_uint = 0x9C;
pub const kHIDUsage_KeyboardPrior: c_uint = 0x9D;
pub const kHIDUsage_KeyboardReturn: c_uint = 0x9E;
pub const kHIDUsage_KeyboardSeparator: c_uint = 0x9F;
pub const kHIDUsage_KeyboardOut: c_uint = 0xA0;
pub const kHIDUsage_KeyboardOper: c_uint = 0xA1;
pub const kHIDUsage_KeyboardClearOrAgain: c_uint = 0xA2;
pub const kHIDUsage_KeyboardCrSelOrProps: c_uint = 0xA3;
pub const kHIDUsage_KeyboardExSel: c_uint = 0xA4;
pub const kHIDUsage_KeyboardLeftControl: c_uint = 0xE0;
pub const kHIDUsage_KeyboardLeftShift: c_uint = 0xE1;
pub const kHIDUsage_KeyboardLeftAlt: c_uint = 0xE2;
pub const kHIDUsage_KeyboardLeftGUI: c_uint = 0xE3;
pub const kHIDUsage_KeyboardRightControl: c_uint = 0xE4;
pub const kHIDUsage_KeyboardRightShift: c_uint = 0xE5;
pub const kHIDUsage_KeyboardRightAlt: c_uint = 0xE6;
pub const kHIDUsage_KeyboardRightGUI: c_uint = 0xE7;
pub const kHIDUsage_Keyboard_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_LED_NumLock: c_uint = 0x01;
pub const kHIDUsage_LED_CapsLock: c_uint = 0x02;
pub const kHIDUsage_LED_ScrollLock: c_uint = 0x03;
pub const kHIDUsage_LED_Compose: c_uint = 0x04;
pub const kHIDUsage_LED_Kana: c_uint = 0x05;
pub const kHIDUsage_LED_Power: c_uint = 0x06;
pub const kHIDUsage_LED_Shift: c_uint = 0x07;
pub const kHIDUsage_LED_DoNotDisturb: c_uint = 0x08;
pub const kHIDUsage_LED_Mute: c_uint = 0x09;
pub const kHIDUsage_LED_ToneEnable: c_uint = 0x0A;
pub const kHIDUsage_LED_HighCutFilter: c_uint = 0x0B;
pub const kHIDUsage_LED_LowCutFilter: c_uint = 0x0C;
pub const kHIDUsage_LED_EqualizerEnable: c_uint = 0x0D;
pub const kHIDUsage_LED_SoundFieldOn: c_uint = 0x0E;
pub const kHIDUsage_LED_SurroundOn: c_uint = 0x0F;
pub const kHIDUsage_LED_Repeat: c_uint = 0x10;
pub const kHIDUsage_LED_Stereo: c_uint = 0x11;
pub const kHIDUsage_LED_SamplingRateDetect: c_uint = 0x12;
pub const kHIDUsage_LED_Spinning: c_uint = 0x13;
pub const kHIDUsage_LED_CAV: c_uint = 0x14;
pub const kHIDUsage_LED_CLV: c_uint = 0x15;
pub const kHIDUsage_LED_RecordingFormatDetect: c_uint = 0x16;
pub const kHIDUsage_LED_OffHook: c_uint = 0x17;
pub const kHIDUsage_LED_Ring: c_uint = 0x18;
pub const kHIDUsage_LED_MessageWaiting: c_uint = 0x19;
pub const kHIDUsage_LED_DataMode: c_uint = 0x1A;
pub const kHIDUsage_LED_BatteryOperation: c_uint = 0x1B;
pub const kHIDUsage_LED_BatteryOK: c_uint = 0x1C;
pub const kHIDUsage_LED_BatteryLow: c_uint = 0x1D;
pub const kHIDUsage_LED_Speaker: c_uint = 0x1E;
pub const kHIDUsage_LED_HeadSet: c_uint = 0x1F;
pub const kHIDUsage_LED_Hold: c_uint = 0x20;
pub const kHIDUsage_LED_Microphone: c_uint = 0x21;
pub const kHIDUsage_LED_Coverage: c_uint = 0x22;
pub const kHIDUsage_LED_NightMode: c_uint = 0x23;
pub const kHIDUsage_LED_SendCalls: c_uint = 0x24;
pub const kHIDUsage_LED_CallPickup: c_uint = 0x25;
pub const kHIDUsage_LED_Conference: c_uint = 0x26;
pub const kHIDUsage_LED_StandBy: c_uint = 0x27;
pub const kHIDUsage_LED_CameraOn: c_uint = 0x28;
pub const kHIDUsage_LED_CameraOff: c_uint = 0x29;
pub const kHIDUsage_LED_OnLine: c_uint = 0x2A;
pub const kHIDUsage_LED_OffLine: c_uint = 0x2B;
pub const kHIDUsage_LED_Busy: c_uint = 0x2C;
pub const kHIDUsage_LED_Ready: c_uint = 0x2D;
pub const kHIDUsage_LED_PaperOut: c_uint = 0x2E;
pub const kHIDUsage_LED_PaperJam: c_uint = 0x2F;
pub const kHIDUsage_LED_Remote: c_uint = 0x30;
pub const kHIDUsage_LED_Forward: c_uint = 0x31;
pub const kHIDUsage_LED_Reverse: c_uint = 0x32;
pub const kHIDUsage_LED_Stop: c_uint = 0x33;
pub const kHIDUsage_LED_Rewind: c_uint = 0x34;
pub const kHIDUsage_LED_FastForward: c_uint = 0x35;
pub const kHIDUsage_LED_Play: c_uint = 0x36;
pub const kHIDUsage_LED_Pause: c_uint = 0x37;
pub const kHIDUsage_LED_Record: c_uint = 0x38;
pub const kHIDUsage_LED_Error: c_uint = 0x39;
pub const kHIDUsage_LED_Usage: c_uint = 0x3A;
pub const kHIDUsage_LED_UsageInUseIndicator: c_uint = 0x3B;
pub const kHIDUsage_LED_UsageMultiModeIndicator: c_uint = 0x3C;
pub const kHIDUsage_LED_IndicatorOn: c_uint = 0x3D;
pub const kHIDUsage_LED_IndicatorFlash: c_uint = 0x3E;
pub const kHIDUsage_LED_IndicatorSlowBlink: c_uint = 0x3F;
pub const kHIDUsage_LED_IndicatorFastBlink: c_uint = 0x40;
pub const kHIDUsage_LED_IndicatorOff: c_uint = 0x41;
pub const kHIDUsage_LED_FlashOnTime: c_uint = 0x42;
pub const kHIDUsage_LED_SlowBlinkOnTime: c_uint = 0x43;
pub const kHIDUsage_LED_SlowBlinkOffTime: c_uint = 0x44;
pub const kHIDUsage_LED_FastBlinkOnTime: c_uint = 0x45;
pub const kHIDUsage_LED_FastBlinkOffTime: c_uint = 0x46;
pub const kHIDUsage_LED_UsageIndicatorColor: c_uint = 0x47;
pub const kHIDUsage_LED_IndicatorRed: c_uint = 0x48;
pub const kHIDUsage_LED_IndicatorGreen: c_uint = 0x49;
pub const kHIDUsage_LED_IndicatorAmber: c_uint = 0x4A;
pub const kHIDUsage_LED_GenericIndicator: c_uint = 0x4B;
pub const kHIDUsage_LED_SystemSuspend: c_uint = 0x4C;
pub const kHIDUsage_LED_ExternalPowerConnected: c_uint = 0x4D;
pub const kHIDUsage_LED_IndicatorBlue: c_uint = 0x4E;
pub const kHIDUsage_LED_IndicatorOrange: c_uint = 0x4F;
pub const kHIDUsage_LED_GoodStatus: c_uint = 0x50;
pub const kHIDUsage_LED_WarningStatus: c_uint = 0x51;
pub const kHIDUsage_LED_RGB_LED: c_uint = 0x52;
pub const kHIDUsage_LED_RedLEDChannel: c_uint = 0x53;
pub const kHIDUsage_LED_BlueLEDChannel: c_uint = 0x54;
pub const kHIDUsage_LED_GreenLEDChannel: c_uint = 0x55;
pub const kHIDUsage_LED_LEDIntensity: c_uint = 0x56;
pub const kHIDUsage_LED_SystemMicrophoneMute: c_uint = 0x57;
pub const kHIDUsage_LED_PlayerIndicator: c_uint = 0x4E;
pub const kHIDUsage_LED_Player1: c_uint = 0x4F;
pub const kHIDUsage_LED_Player2: c_uint = 0x50;
pub const kHIDUsage_LED_Player3: c_uint = 0x51;
pub const kHIDUsage_LED_Player4: c_uint = 0x52;
pub const kHIDUsage_LED_Player5: c_uint = 0x53;
pub const kHIDUsage_LED_Player6: c_uint = 0x54;
pub const kHIDUsage_LED_Player7: c_uint = 0x55;
pub const kHIDUsage_LED_Player8: c_uint = 0x56;
pub const kHIDUsage_LED_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_Button_1: c_uint = 0x01;
pub const kHIDUsage_Button_2: c_uint = 0x02;
pub const kHIDUsage_Button_3: c_uint = 0x03;
pub const kHIDUsage_Button_4: c_uint = 0x04;
pub const kHIDUsage_Button_5: c_uint = 0x05;
pub const kHIDUsage_Button_6: c_uint = 0x06;
pub const kHIDUsage_Button_7: c_uint = 0x07;
pub const kHIDUsage_Button_8: c_uint = 0x08;
pub const kHIDUsage_Button_9: c_uint = 0x09;
pub const kHIDUsage_Button_10: c_uint = 0x0a;
pub const kHIDUsage_Button_11: c_uint = 0x0b;
pub const kHIDUsage_Button_12: c_uint = 0x0c;
pub const kHIDUsage_Button_13: c_uint = 0x0d;
pub const kHIDUsage_Button_14: c_uint = 0x0e;
pub const kHIDUsage_Button_15: c_uint = 0x0f;
pub const kHIDUsage_Button_16: c_uint = 0x10;
pub const kHIDUsage_Button_17: c_uint = 0x11;
pub const kHIDUsage_Button_18: c_uint = 0x12;
pub const kHIDUsage_Button_19: c_uint = 0x13;
pub const kHIDUsage_Button_20: c_uint = 0x14;
pub const kHIDUsage_Button_21: c_uint = 0x15;
pub const kHIDUsage_Button_22: c_uint = 0x16;
pub const kHIDUsage_Button_23: c_uint = 0x17;
pub const kHIDUsage_Button_24: c_uint = 0x18;
pub const kHIDUsage_Button_25: c_uint = 0x19;
pub const kHIDUsage_Button_26: c_uint = 0x1a;
pub const kHIDUsage_Button_27: c_uint = 0x1b;
pub const kHIDUsage_Button_28: c_uint = 0x1c;
pub const kHIDUsage_Button_29: c_uint = 0x1d;
pub const kHIDUsage_Button_30: c_uint = 0x1e;
pub const kHIDUsage_Button_31: c_uint = 0x1f;
pub const kHIDUsage_Button_32: c_uint = 0x20;
pub const kHIDUsage_Button_33: c_uint = 0x21;
pub const kHIDUsage_Button_34: c_uint = 0x22;
pub const kHIDUsage_Button_35: c_uint = 0x23;
pub const kHIDUsage_Button_36: c_uint = 0x24;
pub const kHIDUsage_Button_37: c_uint = 0x25;
pub const kHIDUsage_Button_38: c_uint = 0x26;
pub const kHIDUsage_Button_39: c_uint = 0x27;
pub const kHIDUsage_Button_40: c_uint = 0x28;
pub const kHIDUsage_Button_41: c_uint = 0x29;
pub const kHIDUsage_Button_42: c_uint = 0x2a;
pub const kHIDUsage_Button_43: c_uint = 0x2b;
pub const kHIDUsage_Button_44: c_uint = 0x2c;
pub const kHIDUsage_Button_45: c_uint = 0x2d;
pub const kHIDUsage_Button_46: c_uint = 0x2e;
pub const kHIDUsage_Button_47: c_uint = 0x2f;
pub const kHIDUsage_Button_48: c_uint = 0x30;
pub const kHIDUsage_Button_49: c_uint = 0x31;
pub const kHIDUsage_Button_50: c_uint = 0x32;
pub const kHIDUsage_Button_51: c_uint = 0x33;
pub const kHIDUsage_Button_52: c_uint = 0x34;
pub const kHIDUsage_Button_53: c_uint = 0x35;
pub const kHIDUsage_Button_54: c_uint = 0x36;
pub const kHIDUsage_Button_55: c_uint = 0x37;
pub const kHIDUsage_Button_56: c_uint = 0x38;
pub const kHIDUsage_Button_57: c_uint = 0x39;
pub const kHIDUsage_Button_58: c_uint = 0x3a;
pub const kHIDUsage_Button_59: c_uint = 0x3b;
pub const kHIDUsage_Button_60: c_uint = 0x3c;
pub const kHIDUsage_Button_61: c_uint = 0x3d;
pub const kHIDUsage_Button_62: c_uint = 0x3e;
pub const kHIDUsage_Button_63: c_uint = 0x3f;
pub const kHIDUsage_Button_64: c_uint = 0x40;
pub const kHIDUsage_Button_65: c_uint = 0x41;
pub const kHIDUsage_Button_66: c_uint = 0x42;
pub const kHIDUsage_Button_67: c_uint = 0x43;
pub const kHIDUsage_Button_68: c_uint = 0x44;
pub const kHIDUsage_Button_69: c_uint = 0x45;
pub const kHIDUsage_Button_70: c_uint = 0x46;
pub const kHIDUsage_Button_71: c_uint = 0x47;
pub const kHIDUsage_Button_72: c_uint = 0x48;
pub const kHIDUsage_Button_73: c_uint = 0x49;
pub const kHIDUsage_Button_74: c_uint = 0x4a;
pub const kHIDUsage_Button_75: c_uint = 0x4b;
pub const kHIDUsage_Button_76: c_uint = 0x4c;
pub const kHIDUsage_Button_77: c_uint = 0x4d;
pub const kHIDUsage_Button_78: c_uint = 0x4e;
pub const kHIDUsage_Button_79: c_uint = 0x4f;
pub const kHIDUsage_Button_80: c_uint = 0x50;
pub const kHIDUsage_Button_81: c_uint = 0x51;
pub const kHIDUsage_Button_82: c_uint = 0x52;
pub const kHIDUsage_Button_83: c_uint = 0x53;
pub const kHIDUsage_Button_84: c_uint = 0x54;
pub const kHIDUsage_Button_85: c_uint = 0x55;
pub const kHIDUsage_Button_86: c_uint = 0x56;
pub const kHIDUsage_Button_87: c_uint = 0x57;
pub const kHIDUsage_Button_88: c_uint = 0x58;
pub const kHIDUsage_Button_89: c_uint = 0x59;
pub const kHIDUsage_Button_90: c_uint = 0x5a;
pub const kHIDUsage_Button_91: c_uint = 0x5b;
pub const kHIDUsage_Button_92: c_uint = 0x5c;
pub const kHIDUsage_Button_93: c_uint = 0x5d;
pub const kHIDUsage_Button_94: c_uint = 0x5e;
pub const kHIDUsage_Button_95: c_uint = 0x5f;
pub const kHIDUsage_Button_96: c_uint = 0x60;
pub const kHIDUsage_Button_97: c_uint = 0x61;
pub const kHIDUsage_Button_98: c_uint = 0x62;
pub const kHIDUsage_Button_99: c_uint = 0x63;
pub const kHIDUsage_Button_100: c_uint = 0x64;
pub const kHIDUsage_Button_101: c_uint = 0x65;
pub const kHIDUsage_Button_102: c_uint = 0x66;
pub const kHIDUsage_Button_103: c_uint = 0x67;
pub const kHIDUsage_Button_104: c_uint = 0x68;
pub const kHIDUsage_Button_105: c_uint = 0x69;
pub const kHIDUsage_Button_106: c_uint = 0x6a;
pub const kHIDUsage_Button_107: c_uint = 0x6b;
pub const kHIDUsage_Button_108: c_uint = 0x6c;
pub const kHIDUsage_Button_109: c_uint = 0x6d;
pub const kHIDUsage_Button_110: c_uint = 0x6e;
pub const kHIDUsage_Button_111: c_uint = 0x6f;
pub const kHIDUsage_Button_112: c_uint = 0x70;
pub const kHIDUsage_Button_113: c_uint = 0x71;
pub const kHIDUsage_Button_114: c_uint = 0x72;
pub const kHIDUsage_Button_115: c_uint = 0x73;
pub const kHIDUsage_Button_116: c_uint = 0x74;
pub const kHIDUsage_Button_117: c_uint = 0x75;
pub const kHIDUsage_Button_118: c_uint = 0x76;
pub const kHIDUsage_Button_119: c_uint = 0x77;
pub const kHIDUsage_Button_120: c_uint = 0x78;
pub const kHIDUsage_Button_121: c_uint = 0x79;
pub const kHIDUsage_Button_122: c_uint = 0x7a;
pub const kHIDUsage_Button_123: c_uint = 0x7b;
pub const kHIDUsage_Button_124: c_uint = 0x7c;
pub const kHIDUsage_Button_125: c_uint = 0x7d;
pub const kHIDUsage_Button_126: c_uint = 0x7e;
pub const kHIDUsage_Button_127: c_uint = 0x7f;
pub const kHIDUsage_Button_128: c_uint = 0x80;
pub const kHIDUsage_Button_129: c_uint = 0x81;
pub const kHIDUsage_Button_130: c_uint = 0x82;
pub const kHIDUsage_Button_131: c_uint = 0x83;
pub const kHIDUsage_Button_132: c_uint = 0x84;
pub const kHIDUsage_Button_133: c_uint = 0x85;
pub const kHIDUsage_Button_134: c_uint = 0x86;
pub const kHIDUsage_Button_135: c_uint = 0x87;
pub const kHIDUsage_Button_136: c_uint = 0x88;
pub const kHIDUsage_Button_137: c_uint = 0x89;
pub const kHIDUsage_Button_138: c_uint = 0x8a;
pub const kHIDUsage_Button_139: c_uint = 0x8b;
pub const kHIDUsage_Button_140: c_uint = 0x8c;
pub const kHIDUsage_Button_141: c_uint = 0x8d;
pub const kHIDUsage_Button_142: c_uint = 0x8e;
pub const kHIDUsage_Button_143: c_uint = 0x8f;
pub const kHIDUsage_Button_144: c_uint = 0x90;
pub const kHIDUsage_Button_145: c_uint = 0x91;
pub const kHIDUsage_Button_146: c_uint = 0x92;
pub const kHIDUsage_Button_147: c_uint = 0x93;
pub const kHIDUsage_Button_148: c_uint = 0x94;
pub const kHIDUsage_Button_149: c_uint = 0x95;
pub const kHIDUsage_Button_150: c_uint = 0x96;
pub const kHIDUsage_Button_151: c_uint = 0x97;
pub const kHIDUsage_Button_152: c_uint = 0x98;
pub const kHIDUsage_Button_153: c_uint = 0x99;
pub const kHIDUsage_Button_154: c_uint = 0x9a;
pub const kHIDUsage_Button_155: c_uint = 0x9b;
pub const kHIDUsage_Button_156: c_uint = 0x9c;
pub const kHIDUsage_Button_157: c_uint = 0x9d;
pub const kHIDUsage_Button_158: c_uint = 0x9e;
pub const kHIDUsage_Button_159: c_uint = 0x9f;
pub const kHIDUsage_Button_160: c_uint = 0xa0;
pub const kHIDUsage_Button_161: c_uint = 0xa1;
pub const kHIDUsage_Button_162: c_uint = 0xa2;
pub const kHIDUsage_Button_163: c_uint = 0xa3;
pub const kHIDUsage_Button_164: c_uint = 0xa4;
pub const kHIDUsage_Button_165: c_uint = 0xa5;
pub const kHIDUsage_Button_166: c_uint = 0xa6;
pub const kHIDUsage_Button_167: c_uint = 0xa7;
pub const kHIDUsage_Button_168: c_uint = 0xa8;
pub const kHIDUsage_Button_169: c_uint = 0xa9;
pub const kHIDUsage_Button_170: c_uint = 0xaa;
pub const kHIDUsage_Button_171: c_uint = 0xab;
pub const kHIDUsage_Button_172: c_uint = 0xac;
pub const kHIDUsage_Button_173: c_uint = 0xad;
pub const kHIDUsage_Button_174: c_uint = 0xae;
pub const kHIDUsage_Button_175: c_uint = 0xaf;
pub const kHIDUsage_Button_176: c_uint = 0xb0;
pub const kHIDUsage_Button_177: c_uint = 0xb1;
pub const kHIDUsage_Button_178: c_uint = 0xb2;
pub const kHIDUsage_Button_179: c_uint = 0xb3;
pub const kHIDUsage_Button_180: c_uint = 0xb4;
pub const kHIDUsage_Button_181: c_uint = 0xb5;
pub const kHIDUsage_Button_182: c_uint = 0xb6;
pub const kHIDUsage_Button_183: c_uint = 0xb7;
pub const kHIDUsage_Button_184: c_uint = 0xb8;
pub const kHIDUsage_Button_185: c_uint = 0xb9;
pub const kHIDUsage_Button_186: c_uint = 0xba;
pub const kHIDUsage_Button_187: c_uint = 0xbb;
pub const kHIDUsage_Button_188: c_uint = 0xbc;
pub const kHIDUsage_Button_189: c_uint = 0xbd;
pub const kHIDUsage_Button_190: c_uint = 0xbe;
pub const kHIDUsage_Button_191: c_uint = 0xbf;
pub const kHIDUsage_Button_192: c_uint = 0xc0;
pub const kHIDUsage_Button_193: c_uint = 0xc1;
pub const kHIDUsage_Button_194: c_uint = 0xc2;
pub const kHIDUsage_Button_195: c_uint = 0xc3;
pub const kHIDUsage_Button_196: c_uint = 0xc4;
pub const kHIDUsage_Button_197: c_uint = 0xc5;
pub const kHIDUsage_Button_198: c_uint = 0xc6;
pub const kHIDUsage_Button_199: c_uint = 0xc7;
pub const kHIDUsage_Button_200: c_uint = 0xc8;
pub const kHIDUsage_Button_201: c_uint = 0xc9;
pub const kHIDUsage_Button_202: c_uint = 0xca;
pub const kHIDUsage_Button_203: c_uint = 0xcb;
pub const kHIDUsage_Button_204: c_uint = 0xcc;
pub const kHIDUsage_Button_205: c_uint = 0xcd;
pub const kHIDUsage_Button_206: c_uint = 0xce;
pub const kHIDUsage_Button_207: c_uint = 0xcf;
pub const kHIDUsage_Button_208: c_uint = 0xd0;
pub const kHIDUsage_Button_209: c_uint = 0xd1;
pub const kHIDUsage_Button_210: c_uint = 0xd2;
pub const kHIDUsage_Button_211: c_uint = 0xd3;
pub const kHIDUsage_Button_212: c_uint = 0xd4;
pub const kHIDUsage_Button_213: c_uint = 0xd5;
pub const kHIDUsage_Button_214: c_uint = 0xd6;
pub const kHIDUsage_Button_215: c_uint = 0xd7;
pub const kHIDUsage_Button_216: c_uint = 0xd8;
pub const kHIDUsage_Button_217: c_uint = 0xd9;
pub const kHIDUsage_Button_218: c_uint = 0xda;
pub const kHIDUsage_Button_219: c_uint = 0xdb;
pub const kHIDUsage_Button_220: c_uint = 0xdc;
pub const kHIDUsage_Button_221: c_uint = 0xdd;
pub const kHIDUsage_Button_222: c_uint = 0xde;
pub const kHIDUsage_Button_223: c_uint = 0xdf;
pub const kHIDUsage_Button_224: c_uint = 0xe0;
pub const kHIDUsage_Button_225: c_uint = 0xe1;
pub const kHIDUsage_Button_226: c_uint = 0xe2;
pub const kHIDUsage_Button_227: c_uint = 0xe3;
pub const kHIDUsage_Button_228: c_uint = 0xe4;
pub const kHIDUsage_Button_229: c_uint = 0xe5;
pub const kHIDUsage_Button_230: c_uint = 0xe6;
pub const kHIDUsage_Button_231: c_uint = 0xe7;
pub const kHIDUsage_Button_232: c_uint = 0xe8;
pub const kHIDUsage_Button_233: c_uint = 0xe9;
pub const kHIDUsage_Button_234: c_uint = 0xea;
pub const kHIDUsage_Button_235: c_uint = 0xeb;
pub const kHIDUsage_Button_236: c_uint = 0xec;
pub const kHIDUsage_Button_237: c_uint = 0xed;
pub const kHIDUsage_Button_238: c_uint = 0xee;
pub const kHIDUsage_Button_239: c_uint = 0xef;
pub const kHIDUsage_Button_240: c_uint = 0xf0;
pub const kHIDUsage_Button_241: c_uint = 0xf1;
pub const kHIDUsage_Button_242: c_uint = 0xf2;
pub const kHIDUsage_Button_243: c_uint = 0xf3;
pub const kHIDUsage_Button_244: c_uint = 0xf4;
pub const kHIDUsage_Button_245: c_uint = 0xf5;
pub const kHIDUsage_Button_246: c_uint = 0xf6;
pub const kHIDUsage_Button_247: c_uint = 0xf7;
pub const kHIDUsage_Button_248: c_uint = 0xf8;
pub const kHIDUsage_Button_249: c_uint = 0xf9;
pub const kHIDUsage_Button_250: c_uint = 0xfa;
pub const kHIDUsage_Button_251: c_uint = 0xfb;
pub const kHIDUsage_Button_252: c_uint = 0xfc;
pub const kHIDUsage_Button_253: c_uint = 0xfd;
pub const kHIDUsage_Button_254: c_uint = 0xfe;
pub const kHIDUsage_Button_255: c_uint = 0xff;
pub const kHIDUsage_Button_65535: c_uint = 0xFFFF;

pub const kHIDUsage_Ord_Instance1: c_uint = 0x01;
pub const kHIDUsage_Ord_Instance2: c_uint = 0x02;
pub const kHIDUsage_Ord_Instance3: c_uint = 0x03;
pub const kHIDUsage_Ord_Instance4: c_uint = 0x04;
pub const kHIDUsage_Ord_Instance65535: c_uint = 0xFFFF;

pub const kHIDUsage_Tfon_Phone: c_uint = 0x01;
pub const kHIDUsage_Tfon_AnsweringMachine: c_uint = 0x02;
pub const kHIDUsage_Tfon_MessageControls: c_uint = 0x03;
pub const kHIDUsage_Tfon_Handset: c_uint = 0x04;
pub const kHIDUsage_Tfon_Headset: c_uint = 0x05;
pub const kHIDUsage_Tfon_TelephonyKeyPad: c_uint = 0x06;
pub const kHIDUsage_Tfon_ProgrammableButton: c_uint = 0x07;
pub const kHIDUsage_Tfon_HookSwitch: c_uint = 0x20;
pub const kHIDUsage_Tfon_Flash: c_uint = 0x21;
pub const kHIDUsage_Tfon_Feature: c_uint = 0x22;
pub const kHIDUsage_Tfon_Hold: c_uint = 0x23;
pub const kHIDUsage_Tfon_Redial: c_uint = 0x24;
pub const kHIDUsage_Tfon_Transfer: c_uint = 0x25;
pub const kHIDUsage_Tfon_Drop: c_uint = 0x26;
pub const kHIDUsage_Tfon_Park: c_uint = 0x27;
pub const kHIDUsage_Tfon_ForwardCalls: c_uint = 0x28;
pub const kHIDUsage_Tfon_AlternateFunction: c_uint = 0x29;
pub const kHIDUsage_Tfon_Line: c_uint = 0x2A;
pub const kHIDUsage_Tfon_SpeakerPhone: c_uint = 0x2B;
pub const kHIDUsage_Tfon_Conference: c_uint = 0x2C;
pub const kHIDUsage_Tfon_RingEnable: c_uint = 0x2D;
pub const kHIDUsage_Tfon_Ring: c_uint = 0x2E;
pub const kHIDUsage_Tfon_PhoneMute: c_uint = 0x2F;
pub const kHIDUsage_Tfon_CallerID: c_uint = 0x30;
pub const kHIDUsage_Tfon_SpeedDial: c_uint = 0x50;
pub const kHIDUsage_Tfon_StoreNumber: c_uint = 0x51;
pub const kHIDUsage_Tfon_RecallNumber: c_uint = 0x52;
pub const kHIDUsage_Tfon_PhoneDirectory: c_uint = 0x53;
pub const kHIDUsage_Tfon_VoiceMail: c_uint = 0x70;
pub const kHIDUsage_Tfon_ScreenCalls: c_uint = 0x71;
pub const kHIDUsage_Tfon_DoNotDisturb: c_uint = 0x72;
pub const kHIDUsage_Tfon_Message: c_uint = 0x73;
pub const kHIDUsage_Tfon_AnswerOnOrOff: c_uint = 0x74;
pub const kHIDUsage_Tfon_InsideDialTone: c_uint = 0x90;
pub const kHIDUsage_Tfon_OutsideDialTone: c_uint = 0x91;
pub const kHIDUsage_Tfon_InsideRingTone: c_uint = 0x92;
pub const kHIDUsage_Tfon_OutsideRingTone: c_uint = 0x93;
pub const kHIDUsage_Tfon_PriorityRingTone: c_uint = 0x94;
pub const kHIDUsage_Tfon_InsideRingback: c_uint = 0x95;
pub const kHIDUsage_Tfon_PriorityRingback: c_uint = 0x96;
pub const kHIDUsage_Tfon_LineBusyTone: c_uint = 0x97;
pub const kHIDUsage_Tfon_ReorderTone: c_uint = 0x98;
pub const kHIDUsage_Tfon_CallWaitingTone: c_uint = 0x99;
pub const kHIDUsage_Tfon_ConfirmationTone1: c_uint = 0x9A;
pub const kHIDUsage_Tfon_ConfirmationTone2: c_uint = 0x9B;
pub const kHIDUsage_Tfon_TonesOff: c_uint = 0x9C;
pub const kHIDUsage_Tfon_OutsideRingback: c_uint = 0x9D;
pub const kHIDUsage_Tfon_PhoneKey0: c_uint = 0xB0;
pub const kHIDUsage_Tfon_PhoneKey1: c_uint = 0xB1;
pub const kHIDUsage_Tfon_PhoneKey2: c_uint = 0xB2;
pub const kHIDUsage_Tfon_PhoneKey3: c_uint = 0xB3;
pub const kHIDUsage_Tfon_PhoneKey4: c_uint = 0xB4;
pub const kHIDUsage_Tfon_PhoneKey5: c_uint = 0xB5;
pub const kHIDUsage_Tfon_PhoneKey6: c_uint = 0xB6;
pub const kHIDUsage_Tfon_PhoneKey7: c_uint = 0xB7;
pub const kHIDUsage_Tfon_PhoneKey8: c_uint = 0xB8;
pub const kHIDUsage_Tfon_PhoneKey9: c_uint = 0xB9;
pub const kHIDUsage_Tfon_PhoneKeyStar: c_uint = 0xBA;
pub const kHIDUsage_Tfon_PhoneKeyPound: c_uint = 0xBB;
pub const kHIDUsage_Tfon_PhoneKeyA: c_uint = 0xBC;
pub const kHIDUsage_Tfon_PhoneKeyB: c_uint = 0xBD;
pub const kHIDUsage_Tfon_PhoneKeyC: c_uint = 0xBE;
pub const kHIDUsage_Tfon_PhoneKeyD: c_uint = 0xBF;
pub const kHIDUsage_TFon_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_Csmr_ConsumerControl: c_uint = 0x01;
pub const kHIDUsage_Csmr_NumericKeyPad: c_uint = 0x02;
pub const kHIDUsage_Csmr_ProgrammableButtons: c_uint = 0x03;
pub const kHIDUsage_Csmr_Microphone: c_uint = 0x04;
pub const kHIDUsage_Csmr_Headphone: c_uint = 0x05;
pub const kHIDUsage_Csmr_GraphicEqualizer: c_uint = 0x06;
pub const kHIDUsage_Csmr_Plus10: c_uint = 0x20;
pub const kHIDUsage_Csmr_Plus100: c_uint = 0x21;
pub const kHIDUsage_Csmr_AMOrPM: c_uint = 0x22;
pub const kHIDUsage_Csmr_Power: c_uint = 0x30;
pub const kHIDUsage_Csmr_Reset: c_uint = 0x31;
pub const kHIDUsage_Csmr_Sleep: c_uint = 0x32;
pub const kHIDUsage_Csmr_SleepAfter: c_uint = 0x33;
pub const kHIDUsage_Csmr_SleepMode: c_uint = 0x34;
pub const kHIDUsage_Csmr_Illumination: c_uint = 0x35;
pub const kHIDUsage_Csmr_FunctionButtons: c_uint = 0x36;
pub const kHIDUsage_Csmr_Menu: c_uint = 0x40;
pub const kHIDUsage_Csmr_MenuPick: c_uint = 0x41;
pub const kHIDUsage_Csmr_MenuUp: c_uint = 0x42;
pub const kHIDUsage_Csmr_MenuDown: c_uint = 0x43;
pub const kHIDUsage_Csmr_MenuLeft: c_uint = 0x44;
pub const kHIDUsage_Csmr_MenuRight: c_uint = 0x45;
pub const kHIDUsage_Csmr_MenuEscape: c_uint = 0x46;
pub const kHIDUsage_Csmr_MenuValueIncrease: c_uint = 0x47;
pub const kHIDUsage_Csmr_MenuValueDecrease: c_uint = 0x48;
pub const kHIDUsage_Csmr_DataOnScreen: c_uint = 0x60;
pub const kHIDUsage_Csmr_ClosedCaption: c_uint = 0x61;
pub const kHIDUsage_Csmr_ClosedCaptionSelect: c_uint = 0x62;
pub const kHIDUsage_Csmr_VCROrTV: c_uint = 0x63;
pub const kHIDUsage_Csmr_BroadcastMode: c_uint = 0x64;
pub const kHIDUsage_Csmr_Snapshot: c_uint = 0x65;
pub const kHIDUsage_Csmr_Still: c_uint = 0x66;
pub const kHIDUsage_Csmr_PictureInPictureToggle: c_uint = 0x67;
pub const kHIDUsage_Csmr_PictureInPictureSwap: c_uint = 0x68;
pub const kHIDUsage_Csmr_RedMenuButton: c_uint = 0x69;
pub const kHIDUsage_Csmr_GreenMenuButton: c_uint = 0x6A;
pub const kHIDUsage_Csmr_BlueMenuButton: c_uint = 0x6B;
pub const kHIDUsage_Csmr_YellowMenuButton: c_uint = 0x6C;
pub const kHIDUsage_Csmr_Aspect: c_uint = 0x6D;
pub const kHIDUsage_Csmr_3DModeSelect: c_uint = 0x6E;
pub const kHIDUsage_Csmr_DisplayBrightnessIncrement: c_uint = 0x6F;
pub const kHIDUsage_Csmr_DisplayBrightnessDecrement: c_uint = 0x70;
pub const kHIDUsage_Csmr_DisplayBrightness: c_uint = 0x71;
pub const kHIDUsage_Csmr_DisplayBacklightToggle: c_uint = 0x72;
pub const kHIDUsage_Csmr_DisplayBrightnessMinimum: c_uint = 0x73;
pub const kHIDUsage_Csmr_DisplayBrightnessMaximum: c_uint = 0x74;
pub const kHIDUsage_Csmr_DisplayBrightnessSetAutoBrightness: c_uint = 0x75;
pub const kHIDUsage_Csmr_KeyboardBrightnessIncrement: c_uint = 0x79;
pub const kHIDUsage_Csmr_KeyboardBrightnessDecrement: c_uint = 0x7A;
pub const kHIDUsage_Csmr_Selection: c_uint = 0x80;
pub const kHIDUsage_Csmr_Assign: c_uint = 0x81;
pub const kHIDUsage_Csmr_ModeStep: c_uint = 0x82;
pub const kHIDUsage_Csmr_RecallLast: c_uint = 0x83;
pub const kHIDUsage_Csmr_EnterChannel: c_uint = 0x84;
pub const kHIDUsage_Csmr_OrderMovie: c_uint = 0x85;
pub const kHIDUsage_Csmr_Channel: c_uint = 0x86;
pub const kHIDUsage_Csmr_MediaSelection: c_uint = 0x87;
pub const kHIDUsage_Csmr_MediaSelectComputer: c_uint = 0x88;
pub const kHIDUsage_Csmr_MediaSelectTV: c_uint = 0x89;
pub const kHIDUsage_Csmr_MediaSelectWWW: c_uint = 0x8A;
pub const kHIDUsage_Csmr_MediaSelectDVD: c_uint = 0x8B;
pub const kHIDUsage_Csmr_MediaSelectTelephone: c_uint = 0x8C;
pub const kHIDUsage_Csmr_MediaSelectProgramGuide: c_uint = 0x8D;
pub const kHIDUsage_Csmr_MediaSelectVideoPhone: c_uint = 0x8E;
pub const kHIDUsage_Csmr_MediaSelectGames: c_uint = 0x8F;
pub const kHIDUsage_Csmr_MediaSelectMessages: c_uint = 0x90;
pub const kHIDUsage_Csmr_MediaSelectCD: c_uint = 0x91;
pub const kHIDUsage_Csmr_MediaSelectVCR: c_uint = 0x92;
pub const kHIDUsage_Csmr_MediaSelectTuner: c_uint = 0x93;
pub const kHIDUsage_Csmr_Quit: c_uint = 0x94;
pub const kHIDUsage_Csmr_Help: c_uint = 0x95;
pub const kHIDUsage_Csmr_MediaSelectTape: c_uint = 0x96;
pub const kHIDUsage_Csmr_MediaSelectCable: c_uint = 0x97;
pub const kHIDUsage_Csmr_MediaSelectSatellite: c_uint = 0x98;
pub const kHIDUsage_Csmr_MediaSelectSecurity: c_uint = 0x99;
pub const kHIDUsage_Csmr_MediaSelectHome: c_uint = 0x9A;
pub const kHIDUsage_Csmr_MediaSelectCall: c_uint = 0x9B;
pub const kHIDUsage_Csmr_ChannelIncrement: c_uint = 0x9C;
pub const kHIDUsage_Csmr_ChannelDecrement: c_uint = 0x9D;
pub const kHIDUsage_Csmr_Media: c_uint = 0x9E;
pub const kHIDUsage_Csmr_VCRPlus: c_uint = 0xA0;
pub const kHIDUsage_Csmr_Once: c_uint = 0xA1;
pub const kHIDUsage_Csmr_Daily: c_uint = 0xA2;
pub const kHIDUsage_Csmr_Weekly: c_uint = 0xA3;
pub const kHIDUsage_Csmr_Monthly: c_uint = 0xA4;
pub const kHIDUsage_Csmr_Play: c_uint = 0xB0;
pub const kHIDUsage_Csmr_Pause: c_uint = 0xB1;
pub const kHIDUsage_Csmr_Record: c_uint = 0xB2;
pub const kHIDUsage_Csmr_FastForward: c_uint = 0xB3;
pub const kHIDUsage_Csmr_Rewind: c_uint = 0xB4;
pub const kHIDUsage_Csmr_ScanNextTrack: c_uint = 0xB5;
pub const kHIDUsage_Csmr_ScanPreviousTrack: c_uint = 0xB6;
pub const kHIDUsage_Csmr_Stop: c_uint = 0xB7;
pub const kHIDUsage_Csmr_Eject: c_uint = 0xB8;
pub const kHIDUsage_Csmr_RandomPlay: c_uint = 0xB9;
pub const kHIDUsage_Csmr_SelectDisc: c_uint = 0xBA;
pub const kHIDUsage_Csmr_EnterDisc: c_uint = 0xBB;
pub const kHIDUsage_Csmr_Repeat: c_uint = 0xBC;
pub const kHIDUsage_Csmr_Tracking: c_uint = 0xBD;
pub const kHIDUsage_Csmr_TrackNormal: c_uint = 0xBE;
pub const kHIDUsage_Csmr_SlowTracking: c_uint = 0xBF;
pub const kHIDUsage_Csmr_FrameForward: c_uint = 0xC0;
pub const kHIDUsage_Csmr_FrameBack: c_uint = 0xC1;
pub const kHIDUsage_Csmr_Mark: c_uint = 0xC2;
pub const kHIDUsage_Csmr_ClearMark: c_uint = 0xC3;
pub const kHIDUsage_Csmr_RepeatFromMark: c_uint = 0xC4;
pub const kHIDUsage_Csmr_ReturnToMark: c_uint = 0xC5;
pub const kHIDUsage_Csmr_SearchMarkForward: c_uint = 0xC6;
pub const kHIDUsage_Csmr_SearchMarkBackwards: c_uint = 0xC7;
pub const kHIDUsage_Csmr_CounterReset: c_uint = 0xC8;
pub const kHIDUsage_Csmr_ShowCounter: c_uint = 0xC9;
pub const kHIDUsage_Csmr_TrackingIncrement: c_uint = 0xCA;
pub const kHIDUsage_Csmr_TrackingDecrement: c_uint = 0xCB;
pub const kHIDUsage_Csmr_StopOrEject: c_uint = 0xCC;
pub const kHIDUsage_Csmr_PlayOrPause: c_uint = 0xCD;
pub const kHIDUsage_Csmr_PlayOrSkip: c_uint = 0xCE;
pub const kHIDUsage_Csmr_VoiceCommand: c_uint = 0xCF;
pub const kHIDUsage_Csmr_Volume: c_uint = 0xE0;
pub const kHIDUsage_Csmr_Balance: c_uint = 0xE1;
pub const kHIDUsage_Csmr_Mute: c_uint = 0xE2;
pub const kHIDUsage_Csmr_Bass: c_uint = 0xE3;
pub const kHIDUsage_Csmr_Treble: c_uint = 0xE4;
pub const kHIDUsage_Csmr_BassBoost: c_uint = 0xE5;
pub const kHIDUsage_Csmr_SurroundMode: c_uint = 0xE6;
pub const kHIDUsage_Csmr_Loudness: c_uint = 0xE7;
pub const kHIDUsage_Csmr_MPX: c_uint = 0xE8;
pub const kHIDUsage_Csmr_VolumeIncrement: c_uint = 0xE9;
pub const kHIDUsage_Csmr_VolumeDecrement: c_uint = 0xEA;
pub const kHIDUsage_Csmr_Speed: c_uint = 0xF0;
pub const kHIDUsage_Csmr_PlaybackSpeed: c_uint = 0xF1;
pub const kHIDUsage_Csmr_StandardPlay: c_uint = 0xF2;
pub const kHIDUsage_Csmr_LongPlay: c_uint = 0xF3;
pub const kHIDUsage_Csmr_ExtendedPlay: c_uint = 0xF4;
pub const kHIDUsage_Csmr_Slow: c_uint = 0xF5;
pub const kHIDUsage_Csmr_FanEnable: c_uint = 0x100;
pub const kHIDUsage_Csmr_FanSpeed: c_uint = 0x101;
pub const kHIDUsage_Csmr_LightEnable: c_uint = 0x102;
pub const kHIDUsage_Csmr_LightIlluminationLevel: c_uint = 0x103;
pub const kHIDUsage_Csmr_ClimateControlEnable: c_uint = 0x104;
pub const kHIDUsage_Csmr_RoomTemperature: c_uint = 0x105;
pub const kHIDUsage_Csmr_SecurityEnable: c_uint = 0x106;
pub const kHIDUsage_Csmr_FireAlarm: c_uint = 0x107;
pub const kHIDUsage_Csmr_PoliceAlarm: c_uint = 0x108;
pub const kHIDUsage_Csmr_Proximity: c_uint = 0x109;
pub const kHIDUsage_Csmr_Motion: c_uint = 0x10A;
pub const kHIDUsage_Csmr_DuressAlarm: c_uint = 0x10B;
pub const kHIDUsage_Csmr_HoldupAlarm: c_uint = 0x10C;
pub const kHIDUsage_Csmr_MedicalAlarm: c_uint = 0x10D;
pub const kHIDUsage_Csmr_BalanceRight: c_uint = 0x150;
pub const kHIDUsage_Csmr_BalanceLeft: c_uint = 0x151;
pub const kHIDUsage_Csmr_BassIncrement: c_uint = 0x152;
pub const kHIDUsage_Csmr_BassDecrement: c_uint = 0x153;
pub const kHIDUsage_Csmr_TrebleIncrement: c_uint = 0x154;
pub const kHIDUsage_Csmr_TrebleDecrement: c_uint = 0x155;
pub const kHIDUsage_Csmr_SpeakerSystem: c_uint = 0x160;
pub const kHIDUsage_Csmr_ChannelLeft: c_uint = 0x161;
pub const kHIDUsage_Csmr_ChannelRight: c_uint = 0x162;
pub const kHIDUsage_Csmr_ChannelCenter: c_uint = 0x163;
pub const kHIDUsage_Csmr_ChannelFront: c_uint = 0x164;
pub const kHIDUsage_Csmr_ChannelCenterFront: c_uint = 0x165;
pub const kHIDUsage_Csmr_ChannelSide: c_uint = 0x166;
pub const kHIDUsage_Csmr_ChannelSurround: c_uint = 0x167;
pub const kHIDUsage_Csmr_ChannelLowFrequencyEnhancement: c_uint = 0x168;
pub const kHIDUsage_Csmr_ChannelTop: c_uint = 0x169;
pub const kHIDUsage_Csmr_ChannelUnknown: c_uint = 0x16A;
pub const kHIDUsage_Csmr_SubChannel: c_uint = 0x170;
pub const kHIDUsage_Csmr_SubChannelIncrement: c_uint = 0x171;
pub const kHIDUsage_Csmr_SubChannelDecrement: c_uint = 0x172;
pub const kHIDUsage_Csmr_AlternateAudioIncrement: c_uint = 0x173;
pub const kHIDUsage_Csmr_AlternateAudioDecrement: c_uint = 0x174;
pub const kHIDUsage_Csmr_ApplicationLaunchButtons: c_uint = 0x180;
pub const kHIDUsage_Csmr_ALLaunchButtonConfigurationTool: c_uint = 0x181;
pub const kHIDUsage_Csmr_ALProgrammableButtonConfiguration: c_uint = 0x182;
pub const kHIDUsage_Csmr_ALConsumerControlConfiguration: c_uint = 0x183;
pub const kHIDUsage_Csmr_ALWordProcessor: c_uint = 0x184;
pub const kHIDUsage_Csmr_ALTextEditor: c_uint = 0x185;
pub const kHIDUsage_Csmr_ALSpreadsheet: c_uint = 0x186;
pub const kHIDUsage_Csmr_ALGraphicsEditor: c_uint = 0x187;
pub const kHIDUsage_Csmr_ALPresentationApp: c_uint = 0x188;
pub const kHIDUsage_Csmr_ALDatabaseApp: c_uint = 0x189;
pub const kHIDUsage_Csmr_ALEmailReader: c_uint = 0x18A;
pub const kHIDUsage_Csmr_ALNewsreader: c_uint = 0x18B;
pub const kHIDUsage_Csmr_ALVoicemail: c_uint = 0x18C;
pub const kHIDUsage_Csmr_ALContactsOrAddressBook: c_uint = 0x18D;
pub const kHIDUsage_Csmr_ALCalendarOrSchedule: c_uint = 0x18E;
pub const kHIDUsage_Csmr_ALTaskOrProjectManager: c_uint = 0x18F;
pub const kHIDUsage_Csmr_ALLogOrJournalOrTimecard: c_uint = 0x190;
pub const kHIDUsage_Csmr_ALCheckbookOrFinance: c_uint = 0x191;
pub const kHIDUsage_Csmr_ALCalculator: c_uint = 0x192;
pub const kHIDUsage_Csmr_ALAOrVCaptureOrPlayback: c_uint = 0x193;
pub const kHIDUsage_Csmr_ALLocalMachineBrowser: c_uint = 0x194;
pub const kHIDUsage_Csmr_ALLANOrWANBrowser: c_uint = 0x195;
pub const kHIDUsage_Csmr_ALInternetBrowser: c_uint = 0x196;
pub const kHIDUsage_Csmr_ALRemoteNetworkingOrISPConnect: c_uint = 0x197;
pub const kHIDUsage_Csmr_ALNetworkConference: c_uint = 0x198;
pub const kHIDUsage_Csmr_ALNetworkChat: c_uint = 0x199;
pub const kHIDUsage_Csmr_ALTelephonyOrDialer: c_uint = 0x19A;
pub const kHIDUsage_Csmr_ALLogon: c_uint = 0x19B;
pub const kHIDUsage_Csmr_ALLogoff: c_uint = 0x19C;
pub const kHIDUsage_Csmr_ALLogonOrLogoff: c_uint = 0x19D;
pub const kHIDUsage_Csmr_ALTerminalLockOrScreensaver: c_uint = 0x19E;
pub const kHIDUsage_Csmr_ALControlPanel: c_uint = 0x19F;
pub const kHIDUsage_Csmr_ALCommandLineProcessorOrRun: c_uint = 0x1A0;
pub const kHIDUsage_Csmr_ALProcessOrTaskManager: c_uint = 0x1A1;
pub const kHIDUsage_Csmr_AL: c_uint = 0x1A2;
pub const kHIDUsage_Csmr_ALNextTaskOrApplication: c_uint = 0x1A3;
pub const kHIDUsage_Csmr_ALPreviousTaskOrApplication: c_uint = 0x1A4;
pub const kHIDUsage_Csmr_ALPreemptiveHaltTaskOrApplication: c_uint = 0x1A5;
pub const kHIDUsage_Csmr_ALIntegratedHelpCenter: c_uint = 0x1A6;
pub const kHIDUsage_Csmr_ALDocuments: c_uint = 0x1A7;
pub const kHIDUsage_Csmr_ALThesaurus: c_uint = 0x1A8;
pub const kHIDUsage_Csmr_ALDictionary: c_uint = 0x1A9;
pub const kHIDUsage_Csmr_ALDesktop: c_uint = 0x1AA;
pub const kHIDUsage_Csmr_ALSpellCheck: c_uint = 0x1AB;
pub const kHIDUsage_Csmr_ALGrammerCheck: c_uint = 0x1AC;
pub const kHIDUsage_Csmr_ALWirelessStatus: c_uint = 0x1AD;
pub const kHIDUsage_Csmr_ALKeyboardLayout: c_uint = 0x1AE;
pub const kHIDUsage_Csmr_ALVirusProtection: c_uint = 0x1AF;
pub const kHIDUsage_Csmr_ALEncryption: c_uint = 0x1B0;
pub const kHIDUsage_Csmr_ALScreenSaver: c_uint = 0x1B1;
pub const kHIDUsage_Csmr_ALAlarms: c_uint = 0x1B2;
pub const kHIDUsage_Csmr_ALClock: c_uint = 0x1B3;
pub const kHIDUsage_Csmr_ALFileBrowser: c_uint = 0x1B4;
pub const kHIDUsage_Csmr_ALPowerStatus: c_uint = 0x1B5;
pub const kHIDUsage_Csmr_ALImageBrowser: c_uint = 0x1B6;
pub const kHIDUsage_Csmr_ALAudioBrowser: c_uint = 0x1B7;
pub const kHIDUsage_Csmr_ALMovieBrowser: c_uint = 0x1B8;
pub const kHIDUsage_Csmr_ALDigitalRightsManager: c_uint = 0x1B9;
pub const kHIDUsage_Csmr_ALDigitalWallet: c_uint = 0x1BA;
pub const kHIDUsage_Csmr_ALInstantMessaging: c_uint = 0x1BC;
pub const kHIDUsage_Csmr_ALOEMFeatureBrowser: c_uint = 0x1BD;
pub const kHIDUsage_Csmr_ALOEMHelp: c_uint = 0x1BE;
pub const kHIDUsage_Csmr_ALOnlineCommunity: c_uint = 0x1BF;
pub const kHIDUsage_Csmr_ALEntertainmentContentBrowser: c_uint = 0x1C0;
pub const kHIDUsage_Csmr_ALOnlineShoppingBrowswer: c_uint = 0x1C1;
pub const kHIDUsage_Csmr_ALSmartCardInformationOrHelp: c_uint = 0x1C2;
pub const kHIDUsage_Csmr_ALMarketMonitorOrFinanceBrowser: c_uint = 0x1C3;
pub const kHIDUsage_Csmr_ALCustomizedCorporateNewsBrowser: c_uint = 0x1C4;
pub const kHIDUsage_Csmr_ALOnlineActivityBrowswer: c_uint = 0x1C5;
pub const kHIDUsage_Csmr_ALResearchOrSearchBrowswer: c_uint = 0x1C6;
pub const kHIDUsage_Csmr_ALAudioPlayer: c_uint = 0x1C7;
pub const kHIDUsage_Csmr_ALMessageStatus: c_uint = 0x1C8;
pub const kHIDUsage_Csmr_ALContactSync: c_uint = 0x1C9;
pub const kHIDUsage_Csmr_ALNavigation: c_uint = 0x1CA;
pub const kHIDUsage_Csmr_ALContextawareDesktopAssistant: c_uint = 0x1CB;
pub const kHIDUsage_Csmr_GenericGUIApplicationControls: c_uint = 0x200;
pub const kHIDUsage_Csmr_ACNew: c_uint = 0x201;
pub const kHIDUsage_Csmr_ACOpen: c_uint = 0x202;
pub const kHIDUsage_Csmr_ACClose: c_uint = 0x203;
pub const kHIDUsage_Csmr_ACExit: c_uint = 0x204;
pub const kHIDUsage_Csmr_ACMaximize: c_uint = 0x205;
pub const kHIDUsage_Csmr_ACMinimize: c_uint = 0x206;
pub const kHIDUsage_Csmr_ACSave: c_uint = 0x207;
pub const kHIDUsage_Csmr_ACPrint: c_uint = 0x208;
pub const kHIDUsage_Csmr_ACProperties: c_uint = 0x209;
pub const kHIDUsage_Csmr_ACUndo: c_uint = 0x21A;
pub const kHIDUsage_Csmr_ACCopy: c_uint = 0x21B;
pub const kHIDUsage_Csmr_ACCut: c_uint = 0x21C;
pub const kHIDUsage_Csmr_ACPaste: c_uint = 0x21D;
pub const kHIDUsage_Csmr_AC: c_uint = 0x21E;
pub const kHIDUsage_Csmr_ACFind: c_uint = 0x21F;
pub const kHIDUsage_Csmr_ACFindandReplace: c_uint = 0x220;
pub const kHIDUsage_Csmr_ACSearch: c_uint = 0x221;
pub const kHIDUsage_Csmr_ACGoTo: c_uint = 0x222;
pub const kHIDUsage_Csmr_ACHome: c_uint = 0x223;
pub const kHIDUsage_Csmr_ACBack: c_uint = 0x224;
pub const kHIDUsage_Csmr_ACForward: c_uint = 0x225;
pub const kHIDUsage_Csmr_ACStop: c_uint = 0x226;
pub const kHIDUsage_Csmr_ACRefresh: c_uint = 0x227;
pub const kHIDUsage_Csmr_ACPreviousLink: c_uint = 0x228;
pub const kHIDUsage_Csmr_ACNextLink: c_uint = 0x229;
pub const kHIDUsage_Csmr_ACBookmarks: c_uint = 0x22A;
pub const kHIDUsage_Csmr_ACHistory: c_uint = 0x22B;
pub const kHIDUsage_Csmr_ACSubscriptions: c_uint = 0x22C;
pub const kHIDUsage_Csmr_ACZoomIn: c_uint = 0x22D;
pub const kHIDUsage_Csmr_ACZoomOut: c_uint = 0x22E;
pub const kHIDUsage_Csmr_ACZoom: c_uint = 0x22F;
pub const kHIDUsage_Csmr_ACFullScreenView: c_uint = 0x230;
pub const kHIDUsage_Csmr_ACNormalView: c_uint = 0x231;
pub const kHIDUsage_Csmr_ACViewToggle: c_uint = 0x232;
pub const kHIDUsage_Csmr_ACScrollUp: c_uint = 0x233;
pub const kHIDUsage_Csmr_ACScrollDown: c_uint = 0x234;
pub const kHIDUsage_Csmr_ACScroll: c_uint = 0x235;
pub const kHIDUsage_Csmr_ACPanLeft: c_uint = 0x236;
pub const kHIDUsage_Csmr_ACPanRight: c_uint = 0x237;
pub const kHIDUsage_Csmr_ACPan: c_uint = 0x238;
pub const kHIDUsage_Csmr_ACNewWindow: c_uint = 0x239;
pub const kHIDUsage_Csmr_ACTileHorizontally: c_uint = 0x23A;
pub const kHIDUsage_Csmr_ACTileVertically: c_uint = 0x23B;
pub const kHIDUsage_Csmr_ACFormat: c_uint = 0x23C;
pub const kHIDUsage_Csmr_ACEdit: c_uint = 0x23D;
pub const kHIDUsage_Csmr_ACBold: c_uint = 0x23E;
pub const kHIDUsage_Csmr_ACItalics: c_uint = 0x23F;
pub const kHIDUsage_Csmr_ACUnderline: c_uint = 0x240;
pub const kHIDUsage_Csmr_ACStrikethrough: c_uint = 0x241;
pub const kHIDUsage_Csmr_ACSubscript: c_uint = 0x242;
pub const kHIDUsage_Csmr_ACSuperscript: c_uint = 0x243;
pub const kHIDUsage_Csmr_ACAllCaps: c_uint = 0x244;
pub const kHIDUsage_Csmr_ACRotate: c_uint = 0x245;
pub const kHIDUsage_Csmr_ACResize: c_uint = 0x246;
pub const kHIDUsage_Csmr_ACFlipHorizontal: c_uint = 0x247;
pub const kHIDUsage_Csmr_ACFlipVertical: c_uint = 0x248;
pub const kHIDUsage_Csmr_ACMirrorHorizontal: c_uint = 0x249;
pub const kHIDUsage_Csmr_ACMirrorVertical: c_uint = 0x24A;
pub const kHIDUsage_Csmr_ACFontSelect: c_uint = 0x24B;
pub const kHIDUsage_Csmr_ACFontColor: c_uint = 0x24C;
pub const kHIDUsage_Csmr_ACFontSize: c_uint = 0x24D;
pub const kHIDUsage_Csmr_ACJustifyLeft: c_uint = 0x24E;
pub const kHIDUsage_Csmr_ACJustifyCenterH: c_uint = 0x24F;
pub const kHIDUsage_Csmr_ACJustifyRight: c_uint = 0x250;
pub const kHIDUsage_Csmr_ACJustifyBlockH: c_uint = 0x251;
pub const kHIDUsage_Csmr_ACJustifyTop: c_uint = 0x252;
pub const kHIDUsage_Csmr_ACJustifyCenterV: c_uint = 0x253;
pub const kHIDUsage_Csmr_ACJustifyBottom: c_uint = 0x254;
pub const kHIDUsage_Csmr_ACJustifyBlockV: c_uint = 0x255;
pub const kHIDUsage_Csmr_ACIndentyDecrease: c_uint = 0x256;
pub const kHIDUsage_Csmr_ACIndentyIncrease: c_uint = 0x257;
pub const kHIDUsage_Csmr_ACNumberedList: c_uint = 0x258;
pub const kHIDUsage_Csmr_ACRestartNumbering: c_uint = 0x259;
pub const kHIDUsage_Csmr_ACBulletedList: c_uint = 0x25A;
pub const kHIDUsage_Csmr_ACPromote: c_uint = 0x25B;
pub const kHIDUsage_Csmr_ACDemote: c_uint = 0x25C;
pub const kHIDUsage_Csmr_ACYes: c_uint = 0x25D;
pub const kHIDUsage_Csmr_ACNo: c_uint = 0x25E;
pub const kHIDUsage_Csmr_ACCancel: c_uint = 0x25F;
pub const kHIDUsage_Csmr_ACCatalog: c_uint = 0x260;
pub const kHIDUsage_Csmr_ACBuyOrCheckout: c_uint = 0x261;
pub const kHIDUsage_Csmr_ACAddToCart: c_uint = 0x262;
pub const kHIDUsage_Csmr_ACExpand: c_uint = 0x263;
pub const kHIDUsage_Csmr_ACExpandAll: c_uint = 0x264;
pub const kHIDUsage_Csmr_ACCollapse: c_uint = 0x265;
pub const kHIDUsage_Csmr_ACCollapseAll: c_uint = 0x266;
pub const kHIDUsage_Csmr_ACPrintPreview: c_uint = 0x267;
pub const kHIDUsage_Csmr_ACPasteSpecial: c_uint = 0x268;
pub const kHIDUsage_Csmr_ACInsertMode: c_uint = 0x269;
pub const kHIDUsage_Csmr_ACDelete: c_uint = 0x26A;
pub const kHIDUsage_Csmr_ACLock: c_uint = 0x26B;
pub const kHIDUsage_Csmr_ACUnlock: c_uint = 0x26C;
pub const kHIDUsage_Csmr_ACProtect: c_uint = 0x26D;
pub const kHIDUsage_Csmr_ACUnprotect: c_uint = 0x26E;
pub const kHIDUsage_Csmr_ACAttachComment: c_uint = 0x26F;
pub const kHIDUsage_Csmr_ACDetachComment: c_uint = 0x270;
pub const kHIDUsage_Csmr_ACViewComment: c_uint = 0x271;
pub const kHIDUsage_Csmr_ACSelectWord: c_uint = 0x272;
pub const kHIDUsage_Csmr_ACSelectSentence: c_uint = 0x273;
pub const kHIDUsage_Csmr_ACSelectParagraph: c_uint = 0x274;
pub const kHIDUsage_Csmr_ACSelectColumn: c_uint = 0x275;
pub const kHIDUsage_Csmr_ACSelectRow: c_uint = 0x276;
pub const kHIDUsage_Csmr_ACSelectTable: c_uint = 0x277;
pub const kHIDUsage_Csmr_ACSelectObject: c_uint = 0x278;
pub const kHIDUsage_Csmr_ACRedoOrRepeat: c_uint = 0x279;
pub const kHIDUsage_Csmr_ACSort: c_uint = 0x27A;
pub const kHIDUsage_Csmr_ACSortAscending: c_uint = 0x27B;
pub const kHIDUsage_Csmr_ACSortDescending: c_uint = 0x27C;
pub const kHIDUsage_Csmr_ACFilter: c_uint = 0x27D;
pub const kHIDUsage_Csmr_ACSetClock: c_uint = 0x27E;
pub const kHIDUsage_Csmr_ACViewClock: c_uint = 0x27F;
pub const kHIDUsage_Csmr_ACSelectTimeZone: c_uint = 0x280;
pub const kHIDUsage_Csmr_ACEditTimeZones: c_uint = 0x281;
pub const kHIDUsage_Csmr_ACSetAlarm: c_uint = 0x282;
pub const kHIDUsage_Csmr_ACClearAlarm: c_uint = 0x283;
pub const kHIDUsage_Csmr_ACSnoozeAlarm: c_uint = 0x284;
pub const kHIDUsage_Csmr_ACResetAlarm: c_uint = 0x285;
pub const kHIDUsage_Csmr_ACSynchronize: c_uint = 0x286;
pub const kHIDUsage_Csmr_ACSendOrReceive: c_uint = 0x287;
pub const kHIDUsage_Csmr_ACSendTo: c_uint = 0x288;
pub const kHIDUsage_Csmr_ACReply: c_uint = 0x289;
pub const kHIDUsage_Csmr_ACReplyAll: c_uint = 0x28A;
pub const kHIDUsage_Csmr_ACForwardMessage: c_uint = 0x28B;
pub const kHIDUsage_Csmr_ACSend: c_uint = 0x28C;
pub const kHIDUsage_Csmr_ACAttachFile: c_uint = 0x28D;
pub const kHIDUsage_Csmr_ACUpload: c_uint = 0x28E;
pub const kHIDUsage_Csmr_ACDownload: c_uint = 0x28F;
pub const kHIDUsage_Csmr_ACSetBorders: c_uint = 0x290;
pub const kHIDUsage_Csmr_ACInsertRow: c_uint = 0x291;
pub const kHIDUsage_Csmr_ACInsertColumn: c_uint = 0x292;
pub const kHIDUsage_Csmr_ACInsertFile: c_uint = 0x293;
pub const kHIDUsage_Csmr_ACInsertPicture: c_uint = 0x294;
pub const kHIDUsage_Csmr_ACInsertObject: c_uint = 0x295;
pub const kHIDUsage_Csmr_ACInsertSymbol: c_uint = 0x296;
pub const kHIDUsage_Csmr_ACSaveAndClose: c_uint = 0x297;
pub const kHIDUsage_Csmr_ACRename: c_uint = 0x298;
pub const kHIDUsage_Csmr_ACMerge: c_uint = 0x299;
pub const kHIDUsage_Csmr_ACSplit: c_uint = 0x29A;
pub const kHIDUsage_Csmr_ACDistributeH: c_uint = 0x29B;
pub const kHIDUsage_Csmr_ACDistributeV: c_uint = 0x29C;
pub const kHIDUsage_Csmr_ACKeyboardLayoutSelect: c_uint = 0x29D;
pub const kHIDUsage_Csmr_ACNavigationGuidance: c_uint = 0x29E;
pub const kHIDUsage_Csmr_ACDesktopShowAllWindows: c_uint = 0x29F;
pub const kHIDUsage_Csmr_ACSoftKeyLeft: c_uint = 0x2A0;
pub const kHIDUsage_Csmr_ACSoftKeyRight: c_uint = 0x2A1;
pub const kHIDUsage_Csmr_ACDesktopShowAllApplications: c_uint = 0x2A2;
pub const kHIDUsage_Csmr_ACIdleKeepAlive: c_uint = 0x2B0;
pub const kHIDUsage_Csmr_ExtendedKeyboardAttributesCollection: c_uint = 0x2C0;
pub const kHIDUsage_Csmr_KeyboardFormFactor: c_uint = 0x2C1;
pub const kHIDUsage_Csmr_KeyboardKeyType: c_uint = 0x2C2;
pub const kHIDUsage_Csmr_KeyboardPhysicalLayout: c_uint = 0x2C3;
pub const kHIDUsage_Csmr_VendorSpecificKeyboardPhysicalLayout: c_uint = 0x2C4;
pub const kHIDUsage_Csmr_KeyboardIETFLanguageTagIndex: c_uint = 0x2C5;
pub const kHIDUsage_Csmr_ImplementedKeyboardInputAssistControls: c_uint = 0x2C6;
pub const kHIDUsage_Csmr_KeyboardInputAssistPrevious: c_uint = 0x2C7;
pub const kHIDUsage_Csmr_KeyboardInputAssistNext: c_uint = 0x2C8;
pub const kHIDUsage_Csmr_KeyboardInputAssistPreviousGroup: c_uint = 0x2C9;
pub const kHIDUsage_Csmr_KeyboardInputAssistNextGroup: c_uint = 0x2CA;
pub const kHIDUsage_Csmr_KeyboardInputAssistAccept: c_uint = 0x2CB;
pub const kHIDUsage_Csmr_KeyboardInputAssistCancel: c_uint = 0x2CC;
pub const kHIDUsage_Csmr_ContactEdited: c_uint = 0x500;
pub const kHIDUsage_Csmr_ContactAdded: c_uint = 0x501;
pub const kHIDUsage_Csmr_ContactRecordActive: c_uint = 0x502;
pub const kHIDUsage_Csmr_ContactIndex: c_uint = 0x503;
pub const kHIDUsage_Csmr_ContactNickname: c_uint = 0x504;
pub const kHIDUsage_Csmr_ContactFirstName: c_uint = 0x505;
pub const kHIDUsage_Csmr_ContactLastName: c_uint = 0x506;
pub const kHIDUsage_Csmr_ContactFullName: c_uint = 0x507;
pub const kHIDUsage_Csmr_ContactPhoneNumberPersonal: c_uint = 0x508;
pub const kHIDUsage_Csmr_ContactPhoneNumberBusiness: c_uint = 0x509;
pub const kHIDUsage_Csmr_ContactPhoneNumberMobile: c_uint = 0x50A;
pub const kHIDUsage_Csmr_ContactPhoneNumberPager: c_uint = 0x50B;
pub const kHIDUsage_Csmr_ContactPhoneNumberFax: c_uint = 0x50C;
pub const kHIDUsage_Csmr_ContactPhoneNumberOther: c_uint = 0x50D;
pub const kHIDUsage_Csmr_ContactEmailPersonal: c_uint = 0x50E;
pub const kHIDUsage_Csmr_ContactEmailBusiness: c_uint = 0x50F;
pub const kHIDUsage_Csmr_ContactEmailOther: c_uint = 0x510;
pub const kHIDUsage_Csmr_ContactEmailMain: c_uint = 0x511;
pub const kHIDUsage_Csmr_ContactSpeedDialNumber: c_uint = 0x512;
pub const kHIDUsage_Csmr_ContactStatusFlag: c_uint = 0x513;
pub const kHIDUsage_Csmr_ContactMisc: c_uint = 0x514;
pub const kHIDUsage_Csmr_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_Dig_Digitizer: c_uint = 0x01;
pub const kHIDUsage_Dig_Pen: c_uint = 0x02;
pub const kHIDUsage_Dig_LightPen: c_uint = 0x03;
pub const kHIDUsage_Dig_TouchScreen: c_uint = 0x04;
pub const kHIDUsage_Dig_TouchPad: c_uint = 0x05;
pub const kHIDUsage_Dig_WhiteBoard: c_uint = 0x06;
pub const kHIDUsage_Dig_CoordinateMeasuringMachine: c_uint = 0x07;
pub const kHIDUsage_Dig_3DDigitizer: c_uint = 0x08;
pub const kHIDUsage_Dig_StereoPlotter: c_uint = 0x09;
pub const kHIDUsage_Dig_ArticulatedArm: c_uint = 0x0A;
pub const kHIDUsage_Dig_Armature: c_uint = 0x0B;
pub const kHIDUsage_Dig_MultiplePointDigitizer: c_uint = 0x0C;
pub const kHIDUsage_Dig_FreeSpaceWand: c_uint = 0x0D;
pub const kHIDUsage_Dig_DeviceConfiguration: c_uint = 0x0E;
pub const kHIDUsage_Dig_CapacitiveHeatMapDigitizer: c_uint = 0x0F;
pub const kHIDUsage_Dig_Stylus: c_uint = 0x20;
pub const kHIDUsage_Dig_Puck: c_uint = 0x21;
pub const kHIDUsage_Dig_Finger: c_uint = 0x22;
pub const kHIDUsage_Dig_DeviceSettings: c_uint = 0x23;
pub const kHIDUsage_Dig_GestureCharacter: c_uint = 0x24;
pub const kHIDUsage_Dig_TipPressure: c_uint = 0x30;
pub const kHIDUsage_Dig_BarrelPressure: c_uint = 0x31;
pub const kHIDUsage_Dig_InRange: c_uint = 0x32;
pub const kHIDUsage_Dig_Touch: c_uint = 0x33;
pub const kHIDUsage_Dig_Untouch: c_uint = 0x34;
pub const kHIDUsage_Dig_Tap: c_uint = 0x35;
pub const kHIDUsage_Dig_Quality: c_uint = 0x36;
pub const kHIDUsage_Dig_DataValid: c_uint = 0x37;
pub const kHIDUsage_Dig_TransducerIndex: c_uint = 0x38;
pub const kHIDUsage_Dig_TabletFunctionKeys: c_uint = 0x39;
pub const kHIDUsage_Dig_ProgramChangeKeys: c_uint = 0x3A;
pub const kHIDUsage_Dig_BatteryStrength: c_uint = 0x3B;
pub const kHIDUsage_Dig_Invert: c_uint = 0x3C;
pub const kHIDUsage_Dig_XTilt: c_uint = 0x3D;
pub const kHIDUsage_Dig_YTilt: c_uint = 0x3E;
pub const kHIDUsage_Dig_Azimuth: c_uint = 0x3F;
pub const kHIDUsage_Dig_Altitude: c_uint = 0x40;
pub const kHIDUsage_Dig_Twist: c_uint = 0x41;
pub const kHIDUsage_Dig_TipSwitch: c_uint = 0x42;
pub const kHIDUsage_Dig_SecondaryTipSwitch: c_uint = 0x43;
pub const kHIDUsage_Dig_BarrelSwitch: c_uint = 0x44;
pub const kHIDUsage_Dig_Eraser: c_uint = 0x45;
pub const kHIDUsage_Dig_TabletPick: c_uint = 0x46;
pub const kHIDUsage_Dig_TouchValid: c_uint = 0x47;
pub const kHIDUsage_Dig_Width: c_uint = 0x48;
pub const kHIDUsage_Dig_Height: c_uint = 0x49;
pub const kHIDUsage_Dig_ContactIdentifier: c_uint = 0x51;
pub const kHIDUsage_Dig_DeviceMode: c_uint = 0x52;
pub const kHIDUsage_Dig_DeviceIdentifier: c_uint = 0x53;
pub const kHIDUsage_Dig_ContactCount: c_uint = 0x54;
pub const kHIDUsage_Dig_ContactCountMaximum: c_uint = 0x55;
pub const kHIDUsage_Dig_RelativeScanTime: c_uint = 0x56;
pub const kHIDUsage_Dig_SurfaceSwitch: c_uint = 0x57;
pub const kHIDUsage_Dig_GestureCharacterEnable: c_uint = 0x60;
pub const kHIDUsage_Dig_GestureCharacterQuality: c_uint = 0x61;
pub const kHIDUsage_Dig_GestureCharacterDataLength: c_uint = 0x62;
pub const kHIDUsage_Dig_GestureCharacterData: c_uint = 0x63;
pub const kHIDUsage_Dig_GestureCharacterEncoding: c_uint = 0x64;
pub const kHIDUsage_Dig_GestureCharacterEncodingUTF8: c_uint = 0x65;
pub const kHIDUsage_Dig_GestureCharacterEncodingUTF16LE: c_uint = 0x66;
pub const kHIDUsage_Dig_GestureCharacterEncodingUTF16BE: c_uint = 0x67;
pub const kHIDUsage_Dig_GestureCharacterEncodingUTF32LE: c_uint = 0x68;
pub const kHIDUsage_Dig_GestureCharacterEncodingUTF32BE: c_uint = 0x69;
pub const kHIDUsage_Dig_CapacitiveHeatMapProtocolVendorID: c_uint = 0x6A;
pub const kHIDUsage_Dig_CapacitiveHeatMapProtocolVersion: c_uint = 0x6B;
pub const kHIDUsage_Dig_CapacitiveHeatMapFrameData: c_uint = 0x6C;
pub const kHIDUsage_Dig_ReportRate: c_uint = 0xA1;
pub const kHIDUsage_Dig_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_Haptics_SimpleHapticController: c_uint = 0x0001;
pub const kHIDUsage_Haptics_WaveformList: c_uint = 0x0010;
pub const kHIDUsage_Haptics_DurationList: c_uint = 0x0011;
pub const kHIDUsage_Haptics_AutoTrigger: c_uint = 0x0020;
pub const kHIDUsage_Haptics_ManualTrigger: c_uint = 0x0021;
pub const kHIDUsage_Haptics_AutoTriggerAssociatedControl: c_uint = 0x0022;
pub const kHIDUsage_Haptics_Intensity: c_uint = 0x0023;
pub const kHIDUsage_Haptics_RepeatCount: c_uint = 0x0024;
pub const kHIDUsage_Haptics_RetriggerPeriod: c_uint = 0x0025;
pub const kHIDUsage_Haptics_WaveformVendorPage: c_uint = 0x0026;
pub const kHIDUsage_Haptics_WaveformVendorID: c_uint = 0x0027;
pub const kHIDUsage_Haptics_WaveformCutoffTime: c_uint = 0x0028;
pub const kHIDUsage_Haptics_WaveformNone: c_uint = 0x1001;
pub const kHIDUsage_Haptics_WaveformStop: c_uint = 0x1002;
pub const kHIDUsage_Haptics_WaveformClick: c_uint = 0x1003;
pub const kHIDUsage_Haptics_WaveformBuzzContinuous: c_uint = 0x1004;
pub const kHIDUsage_Haptics_WaveformRumbleContinuous: c_uint = 0x1005;
pub const kHIDUsage_Haptics_WaveformPress: c_uint = 0x1006;
pub const kHIDUsage_Haptics_WaveformRelease: c_uint = 0x1007;
pub const kHIDUsage_Haptics_VendorWaveformFirst: c_uint = 0x2001;
pub const kHIDUsage_Haptics_VendorWaveformLast: c_uint = 0x2FFF;

pub const kHIDUsage_PID_PhysicalInterfaceDevice: c_uint = 0x01;
pub const kHIDUsage_PID_Normal: c_uint = 0x20;
pub const kHIDUsage_PID_SetEffectReport: c_uint = 0x21;
pub const kHIDUsage_PID_EffectBlockIndex: c_uint = 0x22;
pub const kHIDUsage_PID_ParamBlockOffset: c_uint = 0x23;
pub const kHIDUsage_PID_ROM_Flag: c_uint = 0x24;
pub const kHIDUsage_PID_EffectType: c_uint = 0x25;
pub const kHIDUsage_PID_ET_ConstantForce: c_uint = 0x26;
pub const kHIDUsage_PID_ET_Ramp: c_uint = 0x27;
pub const kHIDUsage_PID_ET_CustomForceData: c_uint = 0x28;
pub const kHIDUsage_PID_ET_Square: c_uint = 0x30;
pub const kHIDUsage_PID_ET_Sine: c_uint = 0x31;
pub const kHIDUsage_PID_ET_Triangle: c_uint = 0x32;
pub const kHIDUsage_PID_ET_SawtoothUp: c_uint = 0x33;
pub const kHIDUsage_PID_ET_SawtoothDown: c_uint = 0x34;
pub const kHIDUsage_PID_ET_Spring: c_uint = 0x40;
pub const kHIDUsage_PID_ET_Damper: c_uint = 0x41;
pub const kHIDUsage_PID_ET_Inertia: c_uint = 0x42;
pub const kHIDUsage_PID_ET_Friction: c_uint = 0x43;
pub const kHIDUsage_PID_Duration: c_uint = 0x50;
pub const kHIDUsage_PID_SamplePeriod: c_uint = 0x51;
pub const kHIDUsage_PID_Gain: c_uint = 0x52;
pub const kHIDUsage_PID_TriggerButton: c_uint = 0x53;
pub const kHIDUsage_PID_TriggerRepeatInterval: c_uint = 0x54;
pub const kHIDUsage_PID_AxesEnable: c_uint = 0x55;
pub const kHIDUsage_PID_DirectionEnable: c_uint = 0x56;
pub const kHIDUsage_PID_Direction: c_uint = 0x57;
pub const kHIDUsage_PID_TypeSpecificBlockOffset: c_uint = 0x58;
pub const kHIDUsage_PID_BlockType: c_uint = 0x59;
pub const kHIDUsage_PID_SetEnvelopeReport: c_uint = 0x5A;
pub const kHIDUsage_PID_AttackLevel: c_uint = 0x5B;
pub const kHIDUsage_PID_AttackTime: c_uint = 0x5C;
pub const kHIDUsage_PID_FadeLevel: c_uint = 0x5D;
pub const kHIDUsage_PID_FadeTime: c_uint = 0x5E;
pub const kHIDUsage_PID_SetConditionReport: c_uint = 0x5F;
pub const kHIDUsage_PID_CP_Offset: c_uint = 0x60;
pub const kHIDUsage_PID_PositiveCoefficient: c_uint = 0x61;
pub const kHIDUsage_PID_NegativeCoefficient: c_uint = 0x62;
pub const kHIDUsage_PID_PositiveSaturation: c_uint = 0x63;
pub const kHIDUsage_PID_NegativeSaturation: c_uint = 0x64;
pub const kHIDUsage_PID_DeadBand: c_uint = 0x65;
pub const kHIDUsage_PID_DownloadForceSample: c_uint = 0x66;
pub const kHIDUsage_PID_IsochCustomForceEnable: c_uint = 0x67;
pub const kHIDUsage_PID_CustomForceDataReport: c_uint = 0x68;
pub const kHIDUsage_PID_CustomForceData: c_uint = 0x69;
pub const kHIDUsage_PID_CustomForceVendorDefinedData: c_uint = 0x6A;
pub const kHIDUsage_PID_SetCustomForceReport: c_uint = 0x6B;
pub const kHIDUsage_PID_CustomForceDataOffset: c_uint = 0x6C;
pub const kHIDUsage_PID_SampleCount: c_uint = 0x6D;
pub const kHIDUsage_PID_SetPeriodicReport: c_uint = 0x6E;
pub const kHIDUsage_PID_Offset: c_uint = 0x6F;
pub const kHIDUsage_PID_Magnitude: c_uint = 0x70;
pub const kHIDUsage_PID_Phase: c_uint = 0x71;
pub const kHIDUsage_PID_Period: c_uint = 0x72;
pub const kHIDUsage_PID_SetConstantForceReport: c_uint = 0x73;
pub const kHIDUsage_PID_SetRampForceReport: c_uint = 0x74;
pub const kHIDUsage_PID_RampStart: c_uint = 0x75;
pub const kHIDUsage_PID_RampEnd: c_uint = 0x76;
pub const kHIDUsage_PID_EffectOperationReport: c_uint = 0x77;
pub const kHIDUsage_PID_EffectOperation: c_uint = 0x78;
pub const kHIDUsage_PID_OpEffectStart: c_uint = 0x79;
pub const kHIDUsage_PID_OpEffectStartSolo: c_uint = 0x7A;
pub const kHIDUsage_PID_OpEffectStop: c_uint = 0x7B;
pub const kHIDUsage_PID_LoopCount: c_uint = 0x7C;
pub const kHIDUsage_PID_DeviceGainReport: c_uint = 0x7D;
pub const kHIDUsage_PID_DeviceGain: c_uint = 0x7E;
pub const kHIDUsage_PID_PoolReport: c_uint = 0x7F;
pub const kHIDUsage_PID_RAM_PoolSize: c_uint = 0x80;
pub const kHIDUsage_PID_ROM_PoolSize: c_uint = 0x81;
pub const kHIDUsage_PID_ROM_EffectBlockCount: c_uint = 0x82;
pub const kHIDUsage_PID_SimultaneousEffectsMax: c_uint = 0x83;
pub const kHIDUsage_PID_PoolAlignment: c_uint = 0x84;
pub const kHIDUsage_PID_PoolMoveReport: c_uint = 0x85;
pub const kHIDUsage_PID_MoveSource: c_uint = 0x86;
pub const kHIDUsage_PID_MoveDestination: c_uint = 0x87;
pub const kHIDUsage_PID_MoveLength: c_uint = 0x88;
pub const kHIDUsage_PID_BlockLoadReport: c_uint = 0x89;
pub const kHIDUsage_PID_BlockLoadStatus: c_uint = 0x8B;
pub const kHIDUsage_PID_BlockLoadSuccess: c_uint = 0x8C;
pub const kHIDUsage_PID_BlockLoadFull: c_uint = 0x8D;
pub const kHIDUsage_PID_BlockLoadError: c_uint = 0x8E;
pub const kHIDUsage_PID_BlockHandle: c_uint = 0x8F;
pub const kHIDUsage_PID_BlockFreeReport: c_uint = 0x90;
pub const kHIDUsage_PID_TypeSpecificBlockHandle: c_uint = 0x91;
pub const kHIDUsage_PID_StateReport: c_uint = 0x92;
pub const kHIDUsage_PID_EffectPlaying: c_uint = 0x94;
pub const kHIDUsage_PID_DeviceControlReport: c_uint = 0x95;
pub const kHIDUsage_PID_DeviceControl: c_uint = 0x96;
pub const kHIDUsage_PID_DC_EnableActuators: c_uint = 0x97;
pub const kHIDUsage_PID_DC_DisableActuators: c_uint = 0x98;
pub const kHIDUsage_PID_DC_StopAllEffects: c_uint = 0x99;
pub const kHIDUsage_PID_DC_DeviceReset: c_uint = 0x9A;
pub const kHIDUsage_PID_DC_DevicePause: c_uint = 0x9B;
pub const kHIDUsage_PID_DC_DeviceContinue: c_uint = 0x9C;
pub const kHIDUsage_PID_DevicePaused: c_uint = 0x9F;
pub const kHIDUsage_PID_ActuatorsEnabled: c_uint = 0xA0;
pub const kHIDUsage_PID_SafetySwitch: c_uint = 0xA4;
pub const kHIDUsage_PID_ActuatorOverrideSwitch: c_uint = 0xA5;
pub const kHIDUsage_PID_ActuatorPower: c_uint = 0xA6;
pub const kHIDUsage_PID_StartDelay: c_uint = 0xA7;
pub const kHIDUsage_PID_ParameterBlockSize: c_uint = 0xA8;
pub const kHIDUsage_PID_DeviceManagedPool: c_uint = 0xA9;
pub const kHIDUsage_PID_SharedParameterBlocks: c_uint = 0xAA;
pub const kHIDUsage_PID_CreateNewEffectReport: c_uint = 0xAB;
pub const kHIDUsage_PID_RAM_PoolAvailable: c_uint = 0xAC;
pub const kHIDUsage_PID_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_AD_AlphanumericDisplay: c_uint = 0x01;
pub const kHIDUsage_AD_DisplayAttributesReport: c_uint = 0x20;
pub const kHIDUsage_AD_ASCIICharacterSet: c_uint = 0x21;
pub const kHIDUsage_AD_DataReadBack: c_uint = 0x22;
pub const kHIDUsage_AD_FontReadBack: c_uint = 0x23;
pub const kHIDUsage_AD_DisplayControlReport: c_uint = 0x24;
pub const kHIDUsage_AD_ClearDisplay: c_uint = 0x25;
pub const kHIDUsage_AD_DisplayEnable: c_uint = 0x26;
pub const kHIDUsage_AD_ScreenSaverDelay: c_uint = 0x27;
pub const kHIDUsage_AD_ScreenSaverEnable: c_uint = 0x28;
pub const kHIDUsage_AD_VerticalScroll: c_uint = 0x29;
pub const kHIDUsage_AD_HorizontalScroll: c_uint = 0x2A;
pub const kHIDUsage_AD_CharacterReport: c_uint = 0x2B;
pub const kHIDUsage_AD_DisplayData: c_uint = 0x2C;
pub const kHIDUsage_AD_DisplayStatus: c_uint = 0x2D;
pub const kHIDUsage_AD_StatNotReady: c_uint = 0x2E;
pub const kHIDUsage_AD_StatReady: c_uint = 0x2F;
pub const kHIDUsage_AD_ErrNotaloadablecharacter: c_uint = 0x30;
pub const kHIDUsage_AD_ErrFontdatacannotberead: c_uint = 0x31;
pub const kHIDUsage_AD_CursorPositionReport: c_uint = 0x32;
pub const kHIDUsage_AD_Row: c_uint = 0x33;
pub const kHIDUsage_AD_Column: c_uint = 0x34;
pub const kHIDUsage_AD_Rows: c_uint = 0x35;
pub const kHIDUsage_AD_Columns: c_uint = 0x36;
pub const kHIDUsage_AD_CursorPixelPositioning: c_uint = 0x37;
pub const kHIDUsage_AD_CursorMode: c_uint = 0x38;
pub const kHIDUsage_AD_CursorEnable: c_uint = 0x39;
pub const kHIDUsage_AD_CursorBlink: c_uint = 0x3A;
pub const kHIDUsage_AD_FontReport: c_uint = 0x3B;
pub const kHIDUsage_AD_FontData: c_uint = 0x3C;
pub const kHIDUsage_AD_CharacterWidth: c_uint = 0x3D;
pub const kHIDUsage_AD_CharacterHeight: c_uint = 0x3E;
pub const kHIDUsage_AD_CharacterSpacingHorizontal: c_uint = 0x3F;
pub const kHIDUsage_AD_CharacterSpacingVertical: c_uint = 0x40;
pub const kHIDUsage_AD_UnicodeCharacterSet: c_uint = 0x41;
pub const kHIDUsage_AD_Reserved: c_uint = 0xFFFF;

pub const kHIDUsage_Snsr_Undefined: c_uint = 0x00;
pub const kHIDUsage_Snsr_Sensor: c_uint = 0x01;
pub const kHIDUsage_Snsr_Biometric: c_uint = 0x10;
pub const kHIDUsage_Snsr_Biometric_HumanPresence: c_uint = 0x11;
pub const kHIDUsage_Snsr_Biometric_HumanProximity: c_uint = 0x12;
pub const kHIDUsage_Snsr_Biometric_HumanTouch: c_uint = 0x13;
pub const kHIDUsage_Snsr_Biometric_HeartRate: c_uint = 0x16;
pub const kHIDUsage_Snsr_Electrical: c_uint = 0x20;
pub const kHIDUsage_Snsr_Electrical_Capacitance: c_uint = 0x21;
pub const kHIDUsage_Snsr_Electrical_Current: c_uint = 0x22;
pub const kHIDUsage_Snsr_Electrical_Power: c_uint = 0x23;
pub const kHIDUsage_Snsr_Electrical_Inductance: c_uint = 0x24;
pub const kHIDUsage_Snsr_Electrical_Resistance: c_uint = 0x25;
pub const kHIDUsage_Snsr_Electrical_Voltage: c_uint = 0x26;
pub const kHIDUsage_Snsr_Electrical_Potentiometer: c_uint = 0x27;
pub const kHIDUsage_Snsr_Electrical_Frequency: c_uint = 0x28;
pub const kHIDUsage_Snsr_Electrical_Period: c_uint = 0x29;
pub const kHIDUsage_Snsr_Environmental: c_uint = 0x30;
pub const kHIDUsage_Snsr_Environmental_AtmosphericPressure: c_uint = 0x31;
pub const kHIDUsage_Snsr_Environmental_Humidity: c_uint = 0x32;
pub const kHIDUsage_Snsr_Environmental_Temperature: c_uint = 0x33;
pub const kHIDUsage_Snsr_Environmental_WindDirection: c_uint = 0x34;
pub const kHIDUsage_Snsr_Environmental_WindSpeed: c_uint = 0x35;
pub const kHIDUsage_Snsr_Light: c_uint = 0x40;
pub const kHIDUsage_Snsr_Light_AmbientLight: c_uint = 0x41;
pub const kHIDUsage_Snsr_Light_ConsumerInfrared: c_uint = 0x42;
pub const kHIDUsage_Snsr_Location: c_uint = 0x50;
pub const kHIDUsage_Snsr_Location_Broadcast: c_uint = 0x51;
pub const kHIDUsage_Snsr_Location_DeadReckoning: c_uint = 0x52;
pub const kHIDUsage_Snsr_Location_GPS: c_uint = 0x53;
pub const kHIDUsage_Snsr_Location_Lookup: c_uint = 0x54;
pub const kHIDUsage_Snsr_Location_Other: c_uint = 0x55;
pub const kHIDUsage_Snsr_Location_Static: c_uint = 0x56;
pub const kHIDUsage_Snsr_Location_Triangulation: c_uint = 0x57;
pub const kHIDUsage_Snsr_Mechanical: c_uint = 0x60;
pub const kHIDUsage_Snsr_Mechanical_BooleanSwitch: c_uint = 0x61;
pub const kHIDUsage_Snsr_Mechanical_BooleanSwitchArray: c_uint = 0x62;
pub const kHIDUsage_Snsr_Mechanical_MultivalueSwitch: c_uint = 0x63;
pub const kHIDUsage_Snsr_Mechanical_Force: c_uint = 0x64;
pub const kHIDUsage_Snsr_Mechanical_Pressure: c_uint = 0x65;
pub const kHIDUsage_Snsr_Mechanical_Strain: c_uint = 0x66;
pub const kHIDUsage_Snsr_Mechanical_Weight: c_uint = 0x67;
pub const kHIDUsage_Snsr_Mechanical_HapticVibrator: c_uint = 0x68;
pub const kHIDUsage_Snsr_Mechanical_HallEffectSwitch: c_uint = 0x69;
pub const kHIDUsage_Snsr_Motion: c_uint = 0x70;
pub const kHIDUsage_Snsr_Motion_Accelerometer1D: c_uint = 0x71;
pub const kHIDUsage_Snsr_Motion_Accelerometer2D: c_uint = 0x72;
pub const kHIDUsage_Snsr_Motion_Accelerometer3D: c_uint = 0x73;
pub const kHIDUsage_Snsr_Motion_Gyrometer1D: c_uint = 0x74;
pub const kHIDUsage_Snsr_Motion_Gyrometer2D: c_uint = 0x75;
pub const kHIDUsage_Snsr_Motion_Gyrometer3D: c_uint = 0x76;
pub const kHIDUsage_Snsr_Motion_MotionDetector: c_uint = 0x77;
pub const kHIDUsage_Snsr_Motion_Speedometer: c_uint = 0x78;
pub const kHIDUsage_Snsr_Motion_Accelerometer: c_uint = 0x79;
pub const kHIDUsage_Snsr_Motion_Gyrometer: c_uint = 0x7A;
pub const kHIDUsage_Snsr_Motion_GravityVector: c_uint = 0x7B;
pub const kHIDUsage_Snsr_Motion_LinearAccelerometer: c_uint = 0x7C;
pub const kHIDUsage_Snsr_Orientation: c_uint = 0x80;
pub const kHIDUsage_Snsr_Orientation_Compass1D: c_uint = 0x81;
pub const kHIDUsage_Snsr_Orientation_Compass2D: c_uint = 0x82;
pub const kHIDUsage_Snsr_Orientation_Compass3D: c_uint = 0x83;
pub const kHIDUsage_Snsr_Orientation_Inclinometer1D: c_uint = 0x84;
pub const kHIDUsage_Snsr_Orientation_Inclinometer2D: c_uint = 0x85;
pub const kHIDUsage_Snsr_Orientation_Inclinometer3D: c_uint = 0x86;
pub const kHIDUsage_Snsr_Orientation_Distance1D: c_uint = 0x87;
pub const kHIDUsage_Snsr_Orientation_Distance2D: c_uint = 0x88;
pub const kHIDUsage_Snsr_Orientation_Distance3D: c_uint = 0x89;
pub const kHIDUsage_Snsr_Orientation_DeviceOrientation: c_uint = 0x8A;
pub const kHIDUsage_Snsr_Orientation_CompassD: c_uint = 0x8B;
pub const kHIDUsage_Snsr_Orientation_InclinometerD: c_uint = 0x8C;
pub const kHIDUsage_Snsr_Orientation_DistanceD: c_uint = 0x8D;
pub const kHIDUsage_Snsr_Scanner: c_uint = 0x90;
pub const kHIDUsage_Snsr_Scanner_Barcode: c_uint = 0x91;
pub const kHIDUsage_Snsr_Scanner_RFID: c_uint = 0x92;
pub const kHIDUsage_Snsr_Scanner_NFC: c_uint = 0x93;
pub const kHIDUsage_Snsr_Time: c_uint = 0xA0;
pub const kHIDUsage_Snsr_Time_AlarmTimer: c_uint = 0xA1;
pub const kHIDUsage_Snsr_Time_RealTimeClock: c_uint = 0xA2;
pub const kHIDUsage_Snsr_Other: c_uint = 0xE0;
pub const kHIDUsage_Snsr_Other_Custom: c_uint = 0xE1;
pub const kHIDUsage_Snsr_Other_Generic: c_uint = 0xE2;
pub const kHIDUsage_Snsr_Other_GenericEnumerator: c_uint = 0xE3;
pub const kHIDUsage_Snsr_Modifier_None: c_uint = 0x0;
pub const kHIDUsage_Snsr_Modifier_ChangeSensitivityAbsolute: c_uint = 0x1;
pub const kHIDUsage_Snsr_Modifier_Max: c_uint = 0x2;
pub const kHIDUsage_Snsr_Modifier_Min: c_uint = 0x3;
pub const kHIDUsage_Snsr_Modifier_Accuracy: c_uint = 0x4;
pub const kHIDUsage_Snsr_Modifier_Resolution: c_uint = 0x5;
pub const kHIDUsage_Snsr_Modifier_ThresholdHigh: c_uint = 0x6;
pub const kHIDUsage_Snsr_Modifier_ThresholdLow: c_uint = 0x7;
pub const kHIDUsage_Snsr_Modifier_CalibrationOffset: c_uint = 0x8;
pub const kHIDUsage_Snsr_Modifier_CalibrationMultiplier: c_uint = 0x9;
pub const kHIDUsage_Snsr_Modifier_ReportInterval: c_uint = 0xA;
pub const kHIDUsage_Snsr_Modifier_FrequencyMax: c_uint = 0xB;
pub const kHIDUsage_Snsr_Modifier_PeriodMax: c_uint = 0xC;
pub const kHIDUsage_Snsr_Modifier_ChangeSensitivityPercentRange: c_uint = 0xD;
pub const kHIDUsage_Snsr_Modifier_ChangeSensitivityPercentRelative: c_uint = 0xE;
pub const kHIDUsage_Snsr_Modifier_VendorDefined: c_uint = 0xF;
pub const kHIDUsage_Snsr_Event: c_uint = 0x0200;
pub const kHIDUsage_Snsr_Event_SensorState: c_uint = 0x0201;
pub const kHIDUsage_Snsr_Event_SensorEvent: c_uint = 0x0202;
pub const kHIDUsage_Snsr_Event_SensorState_Undefined: c_uint = 0x0800;
pub const kHIDUsage_Snsr_Event_SensorState_Ready: c_uint = 0x0801;
pub const kHIDUsage_Snsr_Event_SensorState_NotAvailable: c_uint = 0x0802;
pub const kHIDUsage_Snsr_Event_SensorState_NoData: c_uint = 0x0803;
pub const kHIDUsage_Snsr_Event_SensorState_Initializing: c_uint = 0x0804;
pub const kHIDUsage_Snsr_Event_SensorState_AccessDenied: c_uint = 0x0805;
pub const kHIDUsage_Snsr_Event_SensorState_Error: c_uint = 0x0806;
pub const kHIDUsage_Snsr_Event_SensorEvent_Unknown: c_uint = 0x0810;
pub const kHIDUsage_Snsr_Event_SensorEvent_StateChanged: c_uint = 0x0811;
pub const kHIDUsage_Snsr_Event_SensorEvent_PropertyChanged: c_uint = 0x0812;
pub const kHIDUsage_Snsr_Event_SensorEvent_DataUpdated: c_uint = 0x0813;
pub const kHIDUsage_Snsr_Event_SensorEvent_PollResponse: c_uint = 0x0814;
pub const kHIDUsage_Snsr_Event_SensorEvent_ChangeSensitivity: c_uint = 0x0815;
pub const kHIDUsage_Snsr_Event_SensorEvent_RangeMaxReached: c_uint = 0x0816;
pub const kHIDUsage_Snsr_Event_SensorEvent_RangeMinReached: c_uint = 0x0817;
pub const kHIDUsage_Snsr_Event_SensorEvent_HighThresholdCrossUp: c_uint = 0x0818;
pub const kHIDUsage_Snsr_Event_SensorEvent_HighThresholdCrossDown: c_uint = 0x0819;
pub const kHIDUsage_Snsr_Event_SensorEvent_LowThresholdCrossUp: c_uint = 0x081A;
pub const kHIDUsage_Snsr_Event_SensorEvent_LowThresholdCrossDown: c_uint = 0x081B;
pub const kHIDUsage_Snsr_Event_SensorEvent_ZeroThresholdCrossUp: c_uint = 0x081C;
pub const kHIDUsage_Snsr_Event_SensorEvent_ZeroThresholdCrossDown: c_uint = 0x081D;
pub const kHIDUsage_Snsr_Event_SensorEvent_PeriodExceeded: c_uint = 0x081E;
pub const kHIDUsage_Snsr_Event_SensorEvent_FrequencyExceeded: c_uint = 0x081F;
pub const kHIDUsage_Snsr_Event_SensorEvent_ComplexTrigger: c_uint = 0x0820;
pub const kHIDUsage_Snsr_Property: c_uint = 0x0300;
pub const kHIDUsage_Snsr_Property_FriendlyName: c_uint = 0x0301;
pub const kHIDUsage_Snsr_Property_PersistentUniqueID: c_uint = 0x0302;
pub const kHIDUsage_Snsr_Property_SensorStatus: c_uint = 0x0303;
pub const kHIDUsage_Snsr_Property_MinimumReportInterval: c_uint = 0x0304;
pub const kHIDUsage_Snsr_Property_Manufacturer: c_uint = 0x0305;
pub const kHIDUsage_Snsr_Property_Model: c_uint = 0x0306;
pub const kHIDUsage_Snsr_Property_SerialNumber: c_uint = 0x0307;
pub const kHIDUsage_Snsr_Property_Description: c_uint = 0x0308;
pub const kHIDUsage_Snsr_Property_ConnectionType: c_uint = 0x0309;
pub const kHIDUsage_Snsr_Property_DevicePath: c_uint = 0x030A;
pub const kHIDUsage_Snsr_Property_HardwareRevision: c_uint = 0x030B;
pub const kHIDUsage_Snsr_Property_FirmwareVersion: c_uint = 0x030C;
pub const kHIDUsage_Snsr_Property_ReleaseData: c_uint = 0x030D;
pub const kHIDUsage_Snsr_Property_ReportInterval: c_uint = 0x030E;
pub const kHIDUsage_Snsr_Property_ChangeSensitivityAbsolute: c_uint = 0x030F;
pub const kHIDUsage_Snsr_Property_ChangeSensitivityPercentRange: c_uint = 0x0310;
pub const kHIDUsage_Snsr_Property_ChangeSensitivityPercentRelative: c_uint = 0x0311;
pub const kHIDUsage_Snsr_Property_Accuracy: c_uint = 0x0312;
pub const kHIDUsage_Snsr_Property_Resolution: c_uint = 0x0313;
pub const kHIDUsage_Snsr_Property_Maximum: c_uint = 0x0314;
pub const kHIDUsage_Snsr_Property_Minimum: c_uint = 0x0315;
pub const kHIDUsage_Snsr_Property_ReportingState: c_uint = 0x0316;
pub const kHIDUsage_Snsr_Property_SamplingRate: c_uint = 0x0317;
pub const kHIDUsage_Snsr_Property_ResponseCurve: c_uint = 0x0318;
pub const kHIDUsage_Snsr_Property_PowerState: c_uint = 0x0319;
pub const kHIDUsage_Snsr_Property_MaxFIFOEvents: c_uint = 0x031A;
pub const kHIDUsage_Snsr_Property_ReportLatency: c_uint = 0x031B;
pub const kHIDUsage_Snsr_Property_ConnectionType_Integrated: c_uint = 0x0830;
pub const kHIDUsage_Snsr_Property_ConnectionType_Attached: c_uint = 0x0831;
pub const kHIDUsage_Snsr_Property_ConnectionType_External: c_uint = 0x0832;
pub const kHIDUsage_Snsr_Property_ReportingState_NoEvents: c_uint = 0x0840;
pub const kHIDUsage_Snsr_Property_ReportingState_AllEvents: c_uint = 0x0841;
pub const kHIDUsage_Snsr_Property_ReportingState_ThresholdEvents: c_uint = 0x0842;
pub const kHIDUsage_Snsr_Property_ReportingState_WakeNoEvents: c_uint = 0x0843;
pub const kHIDUsage_Snsr_Property_ReportingState_WakeAllEvents: c_uint = 0x0844;
pub const kHIDUsage_Snsr_Property_ReportingState_WakeThresholdEvents: c_uint = 0x0845;
pub const kHIDUsage_Snsr_Property_PowerState_Undefined: c_uint = 0x0850;
pub const kHIDUsage_Snsr_Property_PowerState_D0_FullPower: c_uint = 0x0851;
pub const kHIDUsage_Snsr_Property_PowerState_D1_LowPower: c_uint = 0x0852;
pub const kHIDUsage_Snsr_Property_PowerState_D2_Standby: c_uint = 0x0853;
pub const kHIDUsage_Snsr_Property_PowerState_D3_Sleep: c_uint = 0x0854;
pub const kHIDUsage_Snsr_Property_PowerState_D4_PowerOff: c_uint = 0x0855;
pub const kHIDUsage_Snsr_Light_Illuminance: c_uint = 0x04D1;
pub const kHIDUsage_Snsr_Data_Location: c_uint = 0x0400;
pub const kHIDUsage_Snsr_Data_Location_Reserved: c_uint = 0x0401;
pub const kHIDUsage_Snsr_Data_Location_AltitudeAntennaSeaLevel: c_uint = 0x0402;
pub const kHIDUsage_Snsr_Data_Location_DifferentialReferenceStationID: c_uint = 0x0403;
pub const kHIDUsage_Snsr_Data_Location_AltitudeEllipsoidError: c_uint = 0x0404;
pub const kHIDUsage_Snsr_Data_Location_AltitudeEllipsoid: c_uint = 0x0405;
pub const kHIDUsage_Snsr_Data_Location_AltitudeSeaLevelError: c_uint = 0x0406;
pub const kHIDUsage_Snsr_Data_Location_AltitudeSeaLevel: c_uint = 0x0407;
pub const kHIDUsage_Snsr_Data_Location_DifferentialGPSDataAge: c_uint = 0x0408;
pub const kHIDUsage_Snsr_Data_Location_ErrorRadius: c_uint = 0x0409;
pub const kHIDUsage_Snsr_Data_Location_FixQuality: c_uint = 0x040A;
pub const kHIDUsage_Snsr_Data_Location_FixQualityNoFix: c_uint = 0x0870;
pub const kHIDUsage_Snsr_Data_Location_FixQualityGPS: c_uint = 0x0871;
pub const kHIDUsage_Snsr_Data_Location_FixQualityDGPS: c_uint = 0x0872;
pub const kHIDUsage_Snsr_Data_Location_FixType: c_uint = 0x040B;
pub const kHIDUsage_Snsr_Data_Location_FixTypeNoFix: c_uint = 0x0880;
pub const kHIDUsage_Snsr_Data_Location_FixTypeGPSSPSMode: c_uint = 0x0881;
pub const kHIDUsage_Snsr_Data_Location_FixTypeDGPSSPSMode: c_uint = 0x0882;
pub const kHIDUsage_Snsr_Data_Location_FixTypeGPSPPSMode: c_uint = 0x0883;
pub const kHIDUsage_Snsr_Data_Location_FixTypeRealTimeKinematic: c_uint = 0x0884;
pub const kHIDUsage_Snsr_Data_Location_FixTypeFloatRTK: c_uint = 0x0885;
pub const kHIDUsage_Snsr_Data_Location_FixTypeEstimated: c_uint = 0x0886;
pub const kHIDUsage_Snsr_Data_Location_FixTypeManualInputMode: c_uint = 0x0887;
pub const kHIDUsage_Snsr_Data_Location_FixTypeSimulatorMode: c_uint = 0x0888;
pub const kHIDUsage_Snsr_Data_Location_GeoidalSeparation: c_uint = 0x040C;
pub const kHIDUsage_Snsr_Data_Location_GPSOperationMode: c_uint = 0x040D;
pub const kHIDUsage_Snsr_Data_Location_GPSOperationModeManual: c_uint = 0x0890;
pub const kHIDUsage_Snsr_Data_Location_GPSOperationModeAutomatic: c_uint = 0x0891;
pub const kHIDUsage_Snsr_Data_Location_GPSSelectionMode: c_uint = 0x040E;
pub const kHIDUsage_Snsr_Data_Location_GPSSelectionModeAutonomous: c_uint = 0x08A0;
pub const kHIDUsage_Snsr_Data_Location_GPSSelectionModeDGPS: c_uint = 0x08A1;
pub const kHIDUsage_Snsr_Data_Location_GPSSelectionModeEstimated: c_uint = 0x08A2;
pub const kHIDUsage_Snsr_Data_Location_GPSSelectionModeManualInput: c_uint = 0x08A3;
pub const kHIDUsage_Snsr_Data_Location_GPSSelectionModeSimulator: c_uint = 0x08A4;
pub const kHIDUsage_Snsr_Data_Location_GPSSelectionModeDataNotValid: c_uint = 0x08A5;
pub const kHIDUsage_Snsr_Data_Location_GPSStatus: c_uint = 0x040F;
pub const kHIDUsage_Snsr_Data_Location_GPSStatusDataValid: c_uint = 0x08B0;
pub const kHIDUsage_Snsr_Data_Location_GPSStatusDataNotValid: c_uint = 0x08B1;
pub const kHIDUsage_Snsr_Data_Location_PositionDilutionOfPrecision: c_uint = 0x0410;
pub const kHIDUsage_Snsr_Data_Location_HorizontalDilutionOfPrecision: c_uint = 0x0411;
pub const kHIDUsage_Snsr_Data_Location_VerticalDilutionOfPrecision: c_uint = 0x0412;
pub const kHIDUsage_Snsr_Data_Location_Latitude: c_uint = 0x0413;
pub const kHIDUsage_Snsr_Data_Location_Longitude: c_uint = 0x0414;
pub const kHIDUsage_Snsr_Data_Location_TrueHeading: c_uint = 0x0415;
pub const kHIDUsage_Snsr_Data_Location_MagneticHeading: c_uint = 0x0416;
pub const kHIDUsage_Snsr_Data_Location_MagneticVariation: c_uint = 0x0417;
pub const kHIDUsage_Snsr_Data_Location_Speed: c_uint = 0x0418;
pub const kHIDUsage_Snsr_Data_Location_SatellitesInView: c_uint = 0x0419;
pub const kHIDUsage_Snsr_Data_Location_SatellitesInViewAzimuth: c_uint = 0x041A;
pub const kHIDUsage_Snsr_Data_Location_SatellitesInViewElevation: c_uint = 0x041B;
pub const kHIDUsage_Snsr_Data_Location_SatellitesInViewIDs: c_uint = 0x041C;
pub const kHIDUsage_Snsr_Data_Location_SatellitesInViewPRNs: c_uint = 0x041D;
pub const kHIDUsage_Snsr_Data_Location_SatellitesInViewSNRatios: c_uint = 0x041E;
pub const kHIDUsage_Snsr_Data_Location_SatellitesUsedCount: c_uint = 0x041F;
pub const kHIDUsage_Snsr_Data_Location_SatellitesUsedPRNs: c_uint = 0x0420;
pub const kHIDUsage_Snsr_Data_Location_NMEASentence: c_uint = 0x0421;
pub const kHIDUsage_Snsr_Data_Location_AddressLine1: c_uint = 0x0422;
pub const kHIDUsage_Snsr_Data_Location_AddressLine2: c_uint = 0x0423;
pub const kHIDUsage_Snsr_Data_Location_City: c_uint = 0x0424;
pub const kHIDUsage_Snsr_Data_Location_StateOrProvince: c_uint = 0x0425;
pub const kHIDUsage_Snsr_Data_Location_CountryOrRegion: c_uint = 0x0426;
pub const kHIDUsage_Snsr_Data_Location_PostalCode: c_uint = 0x0427;
pub const kHIDUsage_Snsr_Property_Location: c_uint = 0x042A;
pub const kHIDUsage_Snsr_Property_Location_DesiredAccuracy: c_uint = 0x042B;
pub const kHIDUsage_Snsr_Property_Location_AccuracyDefault: c_uint = 0x0860;
pub const kHIDUsage_Snsr_Property_Location_AccuracyHigh: c_uint = 0x0861;
pub const kHIDUsage_Snsr_Property_Location_AccuracyMedium: c_uint = 0x0862;
pub const kHIDUsage_Snsr_Property_Location_AccuracyLow: c_uint = 0x0863;
pub const kHIDUsage_Snsr_Data_Environmental: c_uint = 0x0430;
pub const kHIDUsage_Snsr_Data_Environmental_AtmosphericPressure: c_uint = 0x0431;
pub const kHIDUsage_Snsr_Data_Environmental_Reserved: c_uint = 0x0432;
pub const kHIDUsage_Snsr_Data_Environmental_RelativeHumidity: c_uint = 0x0433;
pub const kHIDUsage_Snsr_Data_Environmental_Temperature: c_uint = 0x0434;
pub const kHIDUsage_Snsr_Data_Environmental_WindDirection: c_uint = 0x0435;
pub const kHIDUsage_Snsr_Data_Environmental_WindSpeed: c_uint = 0x0436;
pub const kHIDUsage_Snsr_Property_Environmental: c_uint = 0x0440;
pub const kHIDUsage_Snsr_Property_Environmental_ReferencePressure: c_uint = 0x0441;
pub const kHIDUsage_Snsr_Data_Motion: c_uint = 0x0450;
pub const kHIDUsage_Snsr_Data_Motion_State: c_uint = 0x0451;
pub const kHIDUsage_Snsr_Data_Motion_Acceleration: c_uint = 0x0452;
pub const kHIDUsage_Snsr_Data_Motion_AccelerationAxisX: c_uint = 0x0453;
pub const kHIDUsage_Snsr_Data_Motion_AccelerationAxisY: c_uint = 0x0454;
pub const kHIDUsage_Snsr_Data_Motion_AccelerationAxisZ: c_uint = 0x0455;
pub const kHIDUsage_Snsr_Data_Motion_AngularVelocity: c_uint = 0x0456;
pub const kHIDUsage_Snsr_Data_Motion_AngularVelocityXAxis: c_uint = 0x0457;
pub const kHIDUsage_Snsr_Data_Motion_AngularVelocityYAxis: c_uint = 0x0458;
pub const kHIDUsage_Snsr_Data_Motion_AngularVelocityZAxis: c_uint = 0x0459;
pub const kHIDUsage_Snsr_Data_Motion_AngularPosition: c_uint = 0x045A;
pub const kHIDUsage_Snsr_Data_Motion_AngularPositionXAxis: c_uint = 0x045B;
pub const kHIDUsage_Snsr_Data_Motion_AngularPositionYAxis: c_uint = 0x045C;
pub const kHIDUsage_Snsr_Data_Motion_AngularPositionZAxis: c_uint = 0x045D;
pub const kHIDUsage_Snsr_Data_Motion_Speed: c_uint = 0x045E;
pub const kHIDUsage_Snsr_Data_Motion_Intensity: c_uint = 0x045F;
pub const kHIDUsage_Snsr_Data_Orientation: c_uint = 0x0470;
pub const kHIDUsage_Snsr_Data_Orientation_Heading: c_uint = 0x0471;
pub const kHIDUsage_Snsr_Data_Orientation_HeadingXAxis: c_uint = 0x0472;
pub const kHIDUsage_Snsr_Data_Orientation_HeadingYAxis: c_uint = 0x0473;
pub const kHIDUsage_Snsr_Data_Orientation_HeadingZAxis: c_uint = 0x0474;
pub const kHIDUsage_Snsr_Data_Orientation_HeadingCompensatedMagneticNorth: c_uint = 0x0475;
pub const kHIDUsage_Snsr_Data_Orientation_HeadingCompensatedTrueNorth: c_uint = 0x0476;
pub const kHIDUsage_Snsr_Data_Orientation_HeadingMagneticNorth: c_uint = 0x0477;
pub const kHIDUsage_Snsr_Data_Orientation_HeadingTrueNorth: c_uint = 0x0478;
pub const kHIDUsage_Snsr_Data_Orientation_Distance: c_uint = 0x0479;
pub const kHIDUsage_Snsr_Data_Orientation_DistanceXAxis: c_uint = 0x047A;
pub const kHIDUsage_Snsr_Data_Orientation_DistanceYAxis: c_uint = 0x047B;
pub const kHIDUsage_Snsr_Data_Orientation_DistanceZAxis: c_uint = 0x047C;
pub const kHIDUsage_Snsr_Data_Orientation_DistanceOutOfRange: c_uint = 0x047D;
pub const kHIDUsage_Snsr_Data_Orientation_Tilt: c_uint = 0x047E;
pub const kHIDUsage_Snsr_Data_Orientation_TiltXAxis: c_uint = 0x047F;
pub const kHIDUsage_Snsr_Data_Orientation_TiltYAxis: c_uint = 0x0480;
pub const kHIDUsage_Snsr_Data_Orientation_TiltZAxis: c_uint = 0x0481;
pub const kHIDUsage_Snsr_Data_Orientation_RotationMatrix: c_uint = 0x0482;
pub const kHIDUsage_Snsr_Data_Orientation_Quaternion: c_uint = 0x0483;
pub const kHIDUsage_Snsr_Data_Orientation_MagneticFlux: c_uint = 0x0484;
pub const kHIDUsage_Snsr_Data_Orientation_MagneticFluxXAxis: c_uint = 0x0485;
pub const kHIDUsage_Snsr_Data_Orientation_MagneticFluxYAxis: c_uint = 0x0486;
pub const kHIDUsage_Snsr_Data_Orientation_MagneticFluxZAxis: c_uint = 0x0487;
pub const kHIDUsage_Snsr_Data_Mechanical: c_uint = 0x0490;
pub const kHIDUsage_Snsr_Data_Mechanical_BooleanSwitchState: c_uint = 0x0491;
pub const kHIDUsage_Snsr_Data_Mechanical_BooleanSwitchArrayStates: c_uint = 0x0492;
pub const kHIDUsage_Snsr_Data_Mechanical_MultivalueSwitchValue: c_uint = 0x0493;
pub const kHIDUsage_Snsr_Data_Mechanical_Force: c_uint = 0x0494;
pub const kHIDUsage_Snsr_Data_Mechanical_AbsolutePressure: c_uint = 0x0495;
pub const kHIDUsage_Snsr_Data_Mechanical_GaugePressure: c_uint = 0x0496;
pub const kHIDUsage_Snsr_Data_Mechanical_Strain: c_uint = 0x0497;
pub const kHIDUsage_Snsr_Data_Mechanical_Weight: c_uint = 0x0498;
pub const kHIDUsage_Snsr_Property_Mechanical: c_uint = 0x04A0;
pub const kHIDUsage_Snsr_Property_Mechanical_VibrationState: c_uint = 0x04A1;
pub const kHIDUsage_Snsr_Property_Mechanical_ForwardVibrationSpeed: c_uint = 0x04A2;
pub const kHIDUsage_Snsr_Property_Mechanical_BackwardVibrationSpeed: c_uint = 0x04A3;
pub const kHIDUsage_Snsr_Data_Biometric: c_uint = 0x04B0;
pub const kHIDUsage_Snsr_Data_Biometric_HumanPresence: c_uint = 0x04B1;
pub const kHIDUsage_Snsr_Data_Biometric_HumanProximityRange: c_uint = 0x04B2;
pub const kHIDUsage_Snsr_Data_Biometric_HumanProximityOutOfRange: c_uint = 0x04B3;
pub const kHIDUsage_Snsr_Data_Biometric_HumanTouchState: c_uint = 0x04B4;
pub const kHIDUsage_Snsr_Data_Biometric_HeartRate: c_uint = 0x04B8;
pub const kHIDUsage_Snsr_Data_Light: c_uint = 0x04D0;
pub const kHIDUsage_Snsr_Data_Light_Illuminance: c_uint = 0x04D1;
pub const kHIDUsage_Snsr_Data_Light_ColorTemperature: c_uint = 0x04D2;
pub const kHIDUsage_Snsr_Data_Light_Chromaticity: c_uint = 0x04D3;
pub const kHIDUsage_Snsr_Data_Light_ChromaticityX: c_uint = 0x04D4;
pub const kHIDUsage_Snsr_Data_Light_ChromaticityY: c_uint = 0x04D5;
pub const kHIDUsage_Snsr_Data_Light_ConsumerIRSentenceReceive: c_uint = 0x04D6;
pub const kHIDUsage_Snsr_Property_Light: c_uint = 0x04E0;
pub const kHIDUsage_Snsr_Property_Light_ConsumerIRSentenceSend: c_uint = 0x04E1;
pub const kHIDUsage_Snsr_Data_Scanner: c_uint = 0x04F0;
pub const kHIDUsage_Snsr_Data_Scanner_RFIDTag40Bit: c_uint = 0x04F1;
pub const kHIDUsage_Snsr_Data_Scanner_NFCSentenceReceive: c_uint = 0x04F2;
pub const kHIDUsage_Snsr_Property_Scanner: c_uint = 0x04F8;
pub const kHIDUsage_Snsr_Property_Scanner_NFCSentenceSend: c_uint = 0x0F49;
pub const kHIDUsage_Snsr_Data_Electrical: c_uint = 0x0500;
pub const kHIDUsage_Snsr_Data_Electrical_Capacitance: c_uint = 0x0501;
pub const kHIDUsage_Snsr_Data_Electrical_Current: c_uint = 0x0502;
pub const kHIDUsage_Snsr_Data_Electrical_ElectricalPower: c_uint = 0x0503;
pub const kHIDUsage_Snsr_Data_Electrical_Inductance: c_uint = 0x0504;
pub const kHIDUsage_Snsr_Data_Electrical_Resistance: c_uint = 0x0505;
pub const kHIDUsage_Snsr_Data_Electrical_Voltage: c_uint = 0x0506;
pub const kHIDUsage_Snsr_Data_Electrical_Frequency: c_uint = 0x0507;
pub const kHIDUsage_Snsr_Data_Electrical_Period: c_uint = 0x0508;
pub const kHIDUsage_Snsr_Data_Electrical_PercentOfRange: c_uint = 0x0509;
pub const kHIDUsage_Snsr_Data_Time: c_uint = 0x0520;
pub const kHIDUsage_Snsr_Data_Time_Year: c_uint = 0x0521;
pub const kHIDUsage_Snsr_Data_Time_Month: c_uint = 0x0522;
pub const kHIDUsage_Snsr_Data_Time_Day: c_uint = 0x0523;
pub const kHIDUsage_Snsr_Data_Time_DayOfWeek: c_uint = 0x0524;
pub const kHIDUsage_Snsr_Data_Time_DayOfWeekSunday: c_uint = 0x08C0;
pub const kHIDUsage_Snsr_Data_Time_DayOfWeekMonday: c_uint = 0x08C1;
pub const kHIDUsage_Snsr_Data_Time_DayOfWeekTuesday: c_uint = 0x08C2;
pub const kHIDUsage_Snsr_Data_Time_DayOfWeekWednesday: c_uint = 0x08C3;
pub const kHIDUsage_Snsr_Data_Time_DayOfWeekThursday: c_uint = 0x08C4;
pub const kHIDUsage_Snsr_Data_Time_DayOfWeekFriday: c_uint = 0x08C5;
pub const kHIDUsage_Snsr_Data_Time_DayOfWeekSaturday: c_uint = 0x08C6;
pub const kHIDUsage_Snsr_Data_Time_Hour: c_uint = 0x0525;
pub const kHIDUsage_Snsr_Data_Time_Minute: c_uint = 0x0526;
pub const kHIDUsage_Snsr_Data_Time_Second: c_uint = 0x0527;
pub const kHIDUsage_Snsr_Data_Time_Millisecond: c_uint = 0x0528;
pub const kHIDUsage_Snsr_Data_Time_Timestamp: c_uint = 0x0529;
pub const kHIDUsage_Snsr_Data_Time_JulianDayOfYear: c_uint = 0x052A;
pub const kHIDUsage_Snsr_Property_Time: c_uint = 0x0530;
pub const kHIDUsage_Snsr_Property_Time_TimeZoneOffsetFromUTC: c_uint = 0x0531;
pub const kHIDUsage_Snsr_Property_Time_TimeZoneName: c_uint = 0x0532;
pub const kHIDUsage_Snsr_Property_Time_DaylightSavingsTimeObserved: c_uint = 0x0533;
pub const kHIDUsage_Snsr_Property_Time_TimeTrimAdjustment: c_uint = 0x0534;
pub const kHIDUsage_Snsr_Property_Time_ArmAlarm: c_uint = 0x0535;
pub const kHIDUsage_Snsr_Data_Custom: c_uint = 0x0540;
pub const kHIDUsage_Snsr_Data_Custom_Usage: c_uint = 0x0541;
pub const kHIDUsage_Snsr_Data_Custom_BooleanArray: c_uint = 0x0542;
pub const kHIDUsage_Snsr_Data_Custom_Value: c_uint = 0x0543;
pub const kHIDUsage_Snsr_Data_Custom_Value1: c_uint = 0x0544;
pub const kHIDUsage_Snsr_Data_Custom_Value2: c_uint = 0x0545;
pub const kHIDUsage_Snsr_Data_Custom_Value3: c_uint = 0x0546;
pub const kHIDUsage_Snsr_Data_Custom_Value4: c_uint = 0x0547;
pub const kHIDUsage_Snsr_Data_Custom_Value5: c_uint = 0x0548;
pub const kHIDUsage_Snsr_Data_Custom_Value6: c_uint = 0x0549;

pub const kHIDUsage_BD_Undefined: c_uint = 0x00;
pub const kHIDUsage_BD_BrailleDisplay: c_uint = 0x01;
pub const kHIDUsage_BD_BrailleRow: c_uint = 0x02;
pub const kHIDUsage_BD_8DotBrailleCell: c_uint = 0x03;
pub const kHIDUsage_BD_6DotBrailleCell: c_uint = 0x04;
pub const kHIDUsage_BD_NumberOfBrailleCells: c_uint = 0x05;
pub const kHIDUsage_BD_ScreenReaderControl: c_uint = 0x06;
pub const kHIDUsage_BD_ScreenReaderIdentifier: c_uint = 0x07;
pub const kHIDUsage_BD_RouterSet1: c_uint = 0xFA;
pub const kHIDUsage_BD_RouterSet2: c_uint = 0xFB;
pub const kHIDUsage_BD_RouterSet3: c_uint = 0xFC;
pub const kHIDUsage_BD_RouterKey: c_uint = 0x100;
pub const kHIDUsage_BD_RowRouterKey: c_uint = 0x101;
pub const kHIDUsage_BD_BrailleButtons: c_uint = 0x200;
pub const kHIDUsage_BD_BrailleKeyboardDot1: c_uint = 0x201;
pub const kHIDUsage_BD_BrailleKeyboardDot2: c_uint = 0x202;
pub const kHIDUsage_BD_BrailleKeyboardDot3: c_uint = 0x203;
pub const kHIDUsage_BD_BrailleKeyboardDot4: c_uint = 0x204;
pub const kHIDUsage_BD_BrailleKeyboardDot5: c_uint = 0x205;
pub const kHIDUsage_BD_BrailleKeyboardDot6: c_uint = 0x206;
pub const kHIDUsage_BD_BrailleKeyboardDot7: c_uint = 0x207;
pub const kHIDUsage_BD_BrailleKeyboardDot8: c_uint = 0x208;
pub const kHIDUsage_BD_BrailleKeyboardSpace: c_uint = 0x209;
pub const kHIDUsage_BD_BrailleKeyboardLeftSpace: c_uint = 0x20A;
pub const kHIDUsage_BD_BrailleKeyboardRightSpace: c_uint = 0x20B;
pub const kHIDUsage_BD_BrailleFaceControls: c_uint = 0x20C;
pub const kHIDUsage_BD_BrailleLeftControls: c_uint = 0x20D;
pub const kHIDUsage_BD_BrailleRightControls: c_uint = 0x20E;
pub const kHIDUsage_BD_BrailleTopControls: c_uint = 0x20F;
pub const kHIDUsage_BD_BrailleJoystickCenter: c_uint = 0x210;
pub const kHIDUsage_BD_BrailleJoystickUp: c_uint = 0x211;
pub const kHIDUsage_BD_BrailleJoystickDown: c_uint = 0x212;
pub const kHIDUsage_BD_BrailleJoystickLeft: c_uint = 0x213;
pub const kHIDUsage_BD_BrailleJoystickRight: c_uint = 0x214;
pub const kHIDUsage_BD_BrailleDPadCenter: c_uint = 0x215;
pub const kHIDUsage_BD_BrailleDPadUp: c_uint = 0x216;
pub const kHIDUsage_BD_BrailleDPadDown: c_uint = 0x217;
pub const kHIDUsage_BD_BrailleDPadLeft: c_uint = 0x218;
pub const kHIDUsage_BD_BrailleDPadRight: c_uint = 0x219;
pub const kHIDUsage_BD_BraillePanLeft: c_uint = 0x21A;
pub const kHIDUsage_BD_BraillePanRight: c_uint = 0x21B;
pub const kHIDUsage_BD_BrailleRockerUp: c_uint = 0x21C;
pub const kHIDUsage_BD_BrailleRockerDown: c_uint = 0x21D;
pub const kHIDUsage_BD_BrailleRockerPress: c_uint = 0x21E;

pub const kHIDUsage_PD_Undefined: c_uint = 0x00;
pub const kHIDUsage_PD_iName: c_uint = 0x01;
pub const kHIDUsage_PD_PresentStatus: c_uint = 0x02;
pub const kHIDUsage_PD_ChangedStatus: c_uint = 0x03;
pub const kHIDUsage_PD_UPS: c_uint = 0x04;
pub const kHIDUsage_PD_PowerSupply: c_uint = 0x05;
pub const kHIDUsage_PD_PeripheralDevice: c_uint = 0x06;
pub const kHIDUsage_PD_BatterySystem: c_uint = 0x10;
pub const kHIDUsage_PD_BatterySystemID: c_uint = 0x11;
pub const kHIDUsage_PD_Battery: c_uint = 0x12;
pub const kHIDUsage_PD_BatteryID: c_uint = 0x13;
pub const kHIDUsage_PD_Charger: c_uint = 0x14;
pub const kHIDUsage_PD_ChargerID: c_uint = 0x15;
pub const kHIDUsage_PD_PowerConverter: c_uint = 0x16;
pub const kHIDUsage_PD_PowerConverterID: c_uint = 0x17;
pub const kHIDUsage_PD_OutletSystem: c_uint = 0x18;
pub const kHIDUsage_PD_OutletSystemID: c_uint = 0x19;
pub const kHIDUsage_PD_Input: c_uint = 0x1A;
pub const kHIDUsage_PD_InputID: c_uint = 0x1B;
pub const kHIDUsage_PD_Output: c_uint = 0x1C;
pub const kHIDUsage_PD_OutputID: c_uint = 0x1D;
pub const kHIDUsage_PD_Flow: c_uint = 0x1E;
pub const kHIDUsage_PD_FlowID: c_uint = 0x1F;
pub const kHIDUsage_PD_Outlet: c_uint = 0x20;
pub const kHIDUsage_PD_OutletID: c_uint = 0x21;
pub const kHIDUsage_PD_Gang: c_uint = 0x22;
pub const kHIDUsage_PD_GangID: c_uint = 0x23;
pub const kHIDUsage_PD_PowerSummary: c_uint = 0x24;
pub const kHIDUsage_PD_PowerSummaryID: c_uint = 0x25;
pub const kHIDUsage_PD_Voltage: c_uint = 0x30;
pub const kHIDUsage_PD_Current: c_uint = 0x31;
pub const kHIDUsage_PD_Frequency: c_uint = 0x32;
pub const kHIDUsage_PD_ApparentPower: c_uint = 0x33;
pub const kHIDUsage_PD_ActivePower: c_uint = 0x34;
pub const kHIDUsage_PD_PercentLoad: c_uint = 0x35;
pub const kHIDUsage_PD_Temperature: c_uint = 0x36;
pub const kHIDUsage_PD_Humidity: c_uint = 0x37;
pub const kHIDUsage_PD_BadCount: c_uint = 0x38;
pub const kHIDUsage_PD_ConfigVoltage: c_uint = 0x40;
pub const kHIDUsage_PD_ConfigCurrent: c_uint = 0x41;
pub const kHIDUsage_PD_ConfigFrequency: c_uint = 0x42;
pub const kHIDUsage_PD_ConfigApparentPower: c_uint = 0x43;
pub const kHIDUsage_PD_ConfigActivePower: c_uint = 0x44;
pub const kHIDUsage_PD_ConfigPercentLoad: c_uint = 0x45;
pub const kHIDUsage_PD_ConfigTemperature: c_uint = 0x46;
pub const kHIDUsage_PD_ConfigHumidity: c_uint = 0x47;
pub const kHIDUsage_PD_SwitchOnControl: c_uint = 0x50;
pub const kHIDUsage_PD_SwitchOffControl: c_uint = 0x51;
pub const kHIDUsage_PD_ToggleControl: c_uint = 0x52;
pub const kHIDUsage_PD_LowVoltageTransfer: c_uint = 0x53;
pub const kHIDUsage_PD_HighVoltageTransfer: c_uint = 0x54;
pub const kHIDUsage_PD_DelayBeforeReboot: c_uint = 0x55;
pub const kHIDUsage_PD_DelayBeforeStartup: c_uint = 0x56;
pub const kHIDUsage_PD_DelayBeforeShutdown: c_uint = 0x57;
pub const kHIDUsage_PD_Test: c_uint = 0x58;
pub const kHIDUsage_PD_ModuleReset: c_uint = 0x59;
pub const kHIDUsage_PD_AudibleAlarmControl: c_uint = 0x5A;
pub const kHIDUsage_PD_Present: c_uint = 0x60;
pub const kHIDUsage_PD_Good: c_uint = 0x61;
pub const kHIDUsage_PD_InternalFailure: c_uint = 0x62;
pub const kHIDUsage_PD_VoltageOutOfRange: c_uint = 0x63;
pub const kHIDUsage_PD_FrequencyOutOfRange: c_uint = 0x64;
pub const kHIDUsage_PD_Overload: c_uint = 0x65;
pub const kHIDUsage_PD_OverCharged: c_uint = 0x66;
pub const kHIDUsage_PD_OverTemperature: c_uint = 0x67;
pub const kHIDUsage_PD_ShutdownRequested: c_uint = 0x68;
pub const kHIDUsage_PD_ShutdownImminent: c_uint = 0x69;
pub const kHIDUsage_PD_SwitchOnOff: c_uint = 0x6B;
pub const kHIDUsage_PD_Switchable: c_uint = 0x6C;
pub const kHIDUsage_PD_Used: c_uint = 0x6D;
pub const kHIDUsage_PD_Boost: c_uint = 0x6E;
pub const kHIDUsage_PD_Buck: c_uint = 0x6F;
pub const kHIDUsage_PD_Initialized: c_uint = 0x70;
pub const kHIDUsage_PD_Tested: c_uint = 0x71;
pub const kHIDUsage_PD_AwaitingPower: c_uint = 0x72;
pub const kHIDUsage_PD_CommunicationLost: c_uint = 0x73;
pub const kHIDUsage_PD_iManufacturer: c_uint = 0xFD;
pub const kHIDUsage_PD_iProduct: c_uint = 0xFE;
pub const kHIDUsage_PD_iserialNumber: c_uint = 0xFF;

pub const kHIDUsage_BS_Undefined: c_uint = 0x00;
pub const kHIDUsage_BS_SMBBatteryMode: c_uint = 0x01;
pub const kHIDUsage_BS_SMBBatteryStatus: c_uint = 0x02;
pub const kHIDUsage_BS_SMBAlarmWarning: c_uint = 0x03;
pub const kHIDUsage_BS_SMBChargerMode: c_uint = 0x04;
pub const kHIDUsage_BS_SMBChargerStatus: c_uint = 0x05;
pub const kHIDUsage_BS_SMBChargerSpecInfo: c_uint = 0x06;
pub const kHIDUsage_BS_SMBSelectorState: c_uint = 0x07;
pub const kHIDUsage_BS_SMBSelectorPresets: c_uint = 0x08;
pub const kHIDUsage_BS_SMBSelectorInfo: c_uint = 0x09;
pub const kHIDUsage_BS_OptionalMfgFunction1: c_uint = 0x10;
pub const kHIDUsage_BS_OptionalMfgFunction2: c_uint = 0x11;
pub const kHIDUsage_BS_OptionalMfgFunction3: c_uint = 0x12;
pub const kHIDUsage_BS_OptionalMfgFunction4: c_uint = 0x13;
pub const kHIDUsage_BS_OptionalMfgFunction5: c_uint = 0x14;
pub const kHIDUsage_BS_ConnectionToSMBus: c_uint = 0x15;
pub const kHIDUsage_BS_OutputConnection: c_uint = 0x16;
pub const kHIDUsage_BS_ChargerConnection: c_uint = 0x17;
pub const kHIDUsage_BS_BatteryInsertion: c_uint = 0x18;
pub const kHIDUsage_BS_Usenext: c_uint = 0x19;
pub const kHIDUsage_BS_OKToUse: c_uint = 0x1A;
pub const kHIDUsage_BS_BatterySupported: c_uint = 0x1B;
pub const kHIDUsage_BS_SelectorRevision: c_uint = 0x1C;
pub const kHIDUsage_BS_ChargingIndicator: c_uint = 0x1D;
pub const kHIDUsage_BS_ManufacturerAccess: c_uint = 0x28;
pub const kHIDUsage_BS_RemainingCapacityLimit: c_uint = 0x29;
pub const kHIDUsage_BS_RemainingTimeLimit: c_uint = 0x2A;
pub const kHIDUsage_BS_AtRate: c_uint = 0x2B;
pub const kHIDUsage_BS_CapacityMode: c_uint = 0x2C;
pub const kHIDUsage_BS_BroadcastToCharger: c_uint = 0x2D;
pub const kHIDUsage_BS_PrimaryBattery: c_uint = 0x2E;
pub const kHIDUsage_BS_ChargeController: c_uint = 0x2F;
pub const kHIDUsage_BS_TerminateCharge: c_uint = 0x40;
pub const kHIDUsage_BS_TerminateDischarge: c_uint = 0x41;
pub const kHIDUsage_BS_BelowRemainingCapacityLimit: c_uint = 0x42;
pub const kHIDUsage_BS_RemainingTimeLimitExpired: c_uint = 0x43;
pub const kHIDUsage_BS_Charging: c_uint = 0x44;
pub const kHIDUsage_BS_Discharging: c_uint = 0x45;
pub const kHIDUsage_BS_FullyCharged: c_uint = 0x46;
pub const kHIDUsage_BS_FullyDischarged: c_uint = 0x47;
pub const kHIDUsage_BS_ConditioningFlag: c_uint = 0x48;
pub const kHIDUsage_BS_AtRateOK: c_uint = 0x49;
pub const kHIDUsage_BS_SMBErrorCode: c_uint = 0x4A;
pub const kHIDUsage_BS_NeedReplacement: c_uint = 0x4B;
pub const kHIDUsage_BS_AtRateTimeToFull: c_uint = 0x60;
pub const kHIDUsage_BS_AtRateTimeToEmpty: c_uint = 0x61;
pub const kHIDUsage_BS_AverageCurrent: c_uint = 0x62;
pub const kHIDUsage_BS_Maxerror: c_uint = 0x63;
pub const kHIDUsage_BS_RelativeStateOfCharge: c_uint = 0x64;
pub const kHIDUsage_BS_AbsoluteStateOfCharge: c_uint = 0x65;
pub const kHIDUsage_BS_RemainingCapacity: c_uint = 0x66;
pub const kHIDUsage_BS_FullChargeCapacity: c_uint = 0x67;
pub const kHIDUsage_BS_RunTimeToEmpty: c_uint = 0x68;
pub const kHIDUsage_BS_AverageTimeToEmpty: c_uint = 0x69;
pub const kHIDUsage_BS_AverageTimeToFull: c_uint = 0x6A;
pub const kHIDUsage_BS_CycleCount: c_uint = 0x6B;
pub const kHIDUsage_BS_BattPackModelLevel: c_uint = 0x80;
pub const kHIDUsage_BS_InternalChargeController: c_uint = 0x81;
pub const kHIDUsage_BS_PrimaryBatterySupport: c_uint = 0x82;
pub const kHIDUsage_BS_DesignCapacity: c_uint = 0x83;
pub const kHIDUsage_BS_SpecificationInfo: c_uint = 0x84;
pub const kHIDUsage_BS_ManufacturerDate: c_uint = 0x85;
pub const kHIDUsage_BS_SerialNumber: c_uint = 0x86;
pub const kHIDUsage_BS_iManufacturerName: c_uint = 0x87;
pub const kHIDUsage_BS_iDevicename: c_uint = 0x88;
pub const kHIDUsage_BS_iDeviceChemistry: c_uint = 0x89;
pub const kHIDUsage_BS_ManufacturerData: c_uint = 0x8A;
pub const kHIDUsage_BS_Rechargable: c_uint = 0x8B;
pub const kHIDUsage_BS_WarningCapacityLimit: c_uint = 0x8C;
pub const kHIDUsage_BS_CapacityGranularity1: c_uint = 0x8D;
pub const kHIDUsage_BS_CapacityGranularity2: c_uint = 0x8E;
pub const kHIDUsage_BS_iOEMInformation: c_uint = 0x8F;
pub const kHIDUsage_BS_InhibitCharge: c_uint = 0xC0;
pub const kHIDUsage_BS_EnablePolling: c_uint = 0xC1;
pub const kHIDUsage_BS_ResetToZero: c_uint = 0xC2;
pub const kHIDUsage_BS_ACPresent: c_uint = 0xD0;
pub const kHIDUsage_BS_BatteryPresent: c_uint = 0xD1;
pub const kHIDUsage_BS_PowerFail: c_uint = 0xD2;
pub const kHIDUsage_BS_AlarmInhibited: c_uint = 0xD3;
pub const kHIDUsage_BS_ThermistorUnderRange: c_uint = 0xD4;
pub const kHIDUsage_BS_ThermistorHot: c_uint = 0xD5;
pub const kHIDUsage_BS_ThermistorCold: c_uint = 0xD6;
pub const kHIDUsage_BS_ThermistorOverRange: c_uint = 0xD7;
pub const kHIDUsage_BS_VoltageOutOfRange: c_uint = 0xD8;
pub const kHIDUsage_BS_CurrentOutOfRange: c_uint = 0xD9;
pub const kHIDUsage_BS_CurrentNotRegulated: c_uint = 0xDA;
pub const kHIDUsage_BS_VoltageNotRegulated: c_uint = 0xDB;
pub const kHIDUsage_BS_MasterMode: c_uint = 0xDC;
pub const kHIDUsage_BS_ChargerSelectorSupport: c_uint = 0xF0;
pub const kHIDUsage_BS_ChargerSpec: c_uint = 0xF1;
pub const kHIDUsage_BS_Level2: c_uint = 0xF2;
pub const kHIDUsage_BS_Level3: c_uint = 0xF3;

pub const kHIDUsage_BCS_Undefined: c_uint = 0x00;
pub const kHIDUsage_BCS_BadgeReader: c_uint = 0x01;
pub const kHIDUsage_BCS_BarCodeScanner: c_uint = 0x02;
pub const kHIDUsage_BCS_DumbBarCodeScanner: c_uint = 0x03;
pub const kHIDUsage_BCS_CordlessScannerBase: c_uint = 0x04;
pub const kHIDUsage_BCS_BarCodeScannerCradle: c_uint = 0x05;
pub const kHIDUsage_BCS_AttributeReport: c_uint = 0x10;
pub const kHIDUsage_BCS_SettingsReport: c_uint = 0x11;
pub const kHIDUsage_BCS_ScannedDataReport: c_uint = 0x12;
pub const kHIDUsage_BCS_RawScannedDataReport: c_uint = 0x13;
pub const kHIDUsage_BCS_TriggerReport: c_uint = 0x14;
pub const kHIDUsage_BCS_StatusReport: c_uint = 0x15;
pub const kHIDUsage_BCS_UPC_EANControlReport: c_uint = 0x16;
pub const kHIDUsage_BCS_EAN2_3LabelControlReport: c_uint = 0x17;
pub const kHIDUsage_BCS_Code39ControlReport: c_uint = 0x18;
pub const kHIDUsage_BCS_Interleaved2of5ControlReport: c_uint = 0x19;
pub const kHIDUsage_BCS_Standard2of5ControlReport: c_uint = 0x1A;
pub const kHIDUsage_BCS_MSIPlesseyControlReport: c_uint = 0x1B;
pub const kHIDUsage_BCS_CodabarControlReport: c_uint = 0x1C;
pub const kHIDUsage_BCS_Code128ControlReport: c_uint = 0x1D;
pub const kHIDUsage_BCS_Misc1DControlReport: c_uint = 0x1E;
pub const kHIDUsage_BCS_2DControlReport: c_uint = 0x1F;
pub const kHIDUsage_BCS_Aiming_PointerMide: c_uint = 0x30;
pub const kHIDUsage_BCS_BarCodePresentSensor: c_uint = 0x31;
pub const kHIDUsage_BCS_Class1ALaser: c_uint = 0x32;
pub const kHIDUsage_BCS_Class2Laser: c_uint = 0x33;
pub const kHIDUsage_BCS_HeaterPresent: c_uint = 0x34;
pub const kHIDUsage_BCS_ContactScanner: c_uint = 0x35;
pub const kHIDUsage_BCS_ElectronicArticleSurveillanceNotification: c_uint = 0x36;
pub const kHIDUsage_BCS_ConstantElectronicArticleSurveillance: c_uint = 0x37;
pub const kHIDUsage_BCS_ErrorIndication: c_uint = 0x38;
pub const kHIDUsage_BCS_FixedBeeper: c_uint = 0x39;
pub const kHIDUsage_BCS_GoodDecodeIndication: c_uint = 0x3A;
pub const kHIDUsage_BCS_HandsFreeScanning: c_uint = 0x3B;
pub const kHIDUsage_BCS_IntrinsicallySafe: c_uint = 0x3C;
pub const kHIDUsage_BCS_KlasseEinsLaser: c_uint = 0x3D;
pub const kHIDUsage_BCS_LongRangeScanner: c_uint = 0x3E;
pub const kHIDUsage_BCS_MirrorSpeedControl: c_uint = 0x3F;
pub const kHIDUsage_BCS_NotOnFileIndication: c_uint = 0x40;
pub const kHIDUsage_BCS_ProgrammableBeeper: c_uint = 0x41;
pub const kHIDUsage_BCS_Triggerless: c_uint = 0x42;
pub const kHIDUsage_BCS_Wand: c_uint = 0x43;
pub const kHIDUsage_BCS_WaterResistant: c_uint = 0x44;
pub const kHIDUsage_BCS_MultiRangeScanner: c_uint = 0x45;
pub const kHIDUsage_BCS_ProximitySensor: c_uint = 0x46;
pub const kHIDUsage_BCS_FragmentDecoding: c_uint = 0x4D;
pub const kHIDUsage_BCS_ScannerReadConfidence: c_uint = 0x4E;
pub const kHIDUsage_BCS_DataPrefix: c_uint = 0x4F;
pub const kHIDUsage_BCS_PrefixAIMI: c_uint = 0x50;
pub const kHIDUsage_BCS_PrefixNone: c_uint = 0x51;
pub const kHIDUsage_BCS_PrefixProprietary: c_uint = 0x52;
pub const kHIDUsage_BCS_ActiveTime: c_uint = 0x55;
pub const kHIDUsage_BCS_AimingLaserPattern: c_uint = 0x56;
pub const kHIDUsage_BCS_BarCodePresent: c_uint = 0x57;
pub const kHIDUsage_BCS_BeeperState: c_uint = 0x58;
pub const kHIDUsage_BCS_LaserOnTime: c_uint = 0x59;
pub const kHIDUsage_BCS_LaserState: c_uint = 0x5A;
pub const kHIDUsage_BCS_LockoutTime: c_uint = 0x5B;
pub const kHIDUsage_BCS_MotorState: c_uint = 0x5C;
pub const kHIDUsage_BCS_MotorTimeout: c_uint = 0x5D;
pub const kHIDUsage_BCS_PowerOnResetScanner: c_uint = 0x5E;
pub const kHIDUsage_BCS_PreventReadOfBarcodes: c_uint = 0x5F;
pub const kHIDUsage_BCS_InitiateBarcodeRead: c_uint = 0x60;
pub const kHIDUsage_BCS_TriggerState: c_uint = 0x61;
pub const kHIDUsage_BCS_TriggerMode: c_uint = 0x62;
pub const kHIDUsage_BCS_TriggerModeBlinkingLaserOn: c_uint = 0x63;
pub const kHIDUsage_BCS_TriggerModeContinuousLaserOn: c_uint = 0x64;
pub const kHIDUsage_BCS_TriggerModeLaserOnWhilePulled: c_uint = 0x65;
pub const kHIDUsage_BCS_TriggerModeLaserStaysOnAfterTriggerRelease: c_uint = 0x66;
pub const kHIDUsage_BCS_CommitParametersToNVM: c_uint = 0x6D;
pub const kHIDUsage_BCS_ParameterScanning: c_uint = 0x6E;
pub const kHIDUsage_BCS_ParametersChanged: c_uint = 0x6F;
pub const kHIDUsage_BCS_SetParameterDefaultValues: c_uint = 0x70;
pub const kHIDUsage_BCS_ScannerInCradle: c_uint = 0x75;
pub const kHIDUsage_BCS_ScannerInRange: c_uint = 0x76;
pub const kHIDUsage_BCS_AimDuration: c_uint = 0x7A;
pub const kHIDUsage_BCS_GoodReadLampDuration: c_uint = 0x7B;
pub const kHIDUsage_BCS_GoodReadLampIntensity: c_uint = 0x7C;
pub const kHIDUsage_BCS_GoodReadLED: c_uint = 0x7D;
pub const kHIDUsage_BCS_GoodReadToneFrequency: c_uint = 0x7E;
pub const kHIDUsage_BCS_GoodReadToneLength: c_uint = 0x7F;
pub const kHIDUsage_BCS_GoodReadToneVolume: c_uint = 0x80;
pub const kHIDUsage_BCS_NoReadMessage: c_uint = 0x82;
pub const kHIDUsage_BCS_NotOnFileVolume: c_uint = 0x83;
pub const kHIDUsage_BCS_PowerupBeep: c_uint = 0x84;
pub const kHIDUsage_BCS_SoundErrorBeep: c_uint = 0x85;
pub const kHIDUsage_BCS_SoundGoodReadBeep: c_uint = 0x86;
pub const kHIDUsage_BCS_SoundNotOnFileBeep: c_uint = 0x87;
pub const kHIDUsage_BCS_GoodReadWhenToWrite: c_uint = 0x88;
pub const kHIDUsage_BCS_GRWTIAfterDecode: c_uint = 0x89;
pub const kHIDUsage_BCS_GRWTIBeep_LampAfterTransmit: c_uint = 0x8A;
pub const kHIDUsage_BCS_GRWTINoBeep_LampUseAtAll: c_uint = 0x8B;
pub const kHIDUsage_BCS_BooklandEAN: c_uint = 0x91;
pub const kHIDUsage_BCS_ConvertEAN8To13Type: c_uint = 0x92;
pub const kHIDUsage_BCS_ConvertUPCAToEAN_13: c_uint = 0x93;
pub const kHIDUsage_BCS_ConvertUPC_EToA: c_uint = 0x94;
pub const kHIDUsage_BCS_EAN_13: c_uint = 0x95;
pub const kHIDUsage_BCS_EAN_8: c_uint = 0x96;
pub const kHIDUsage_BCS_EAN_99_128_Mandatory: c_uint = 0x97;
pub const kHIDUsage_BCS_EAN_99_P5_128_Optional: c_uint = 0x98;
pub const kHIDUsage_BCS_UPC_EAN: c_uint = 0x9A;
pub const kHIDUsage_BCS_UPC_EANCouponCode: c_uint = 0x9B;
pub const kHIDUsage_BCS_UPC_EANPeriodicals: c_uint = 0x9C;
pub const kHIDUsage_BCS_UPC_A: c_uint = 0x9D;
pub const kHIDUsage_BCS_UPC_AWith128Mandatory: c_uint = 0x9E;
pub const kHIDUsage_BCS_UPC_AWith128Optical: c_uint = 0x9F;
pub const kHIDUsage_BCS_UPC_AWithP5Optional: c_uint = 0xA0;
pub const kHIDUsage_BCS_UPC_E: c_uint = 0xA1;
pub const kHIDUsage_BCS_UPC_E1: c_uint = 0xA2;
pub const kHIDUsage_BCS_Periodical: c_uint = 0xA9;
pub const kHIDUsage_BCS_PeriodicalAutoDiscriminatePlus2: c_uint = 0xAA;
pub const kHIDUsage_BCS_PeriodicalOnlyDecodeWithPlus2: c_uint = 0xAB;
pub const kHIDUsage_BCS_PeriodicalIgnorePlus2: c_uint = 0xAC;
pub const kHIDUsage_BCS_PeriodicalAutoDiscriminatePlus5: c_uint = 0xAD;
pub const kHIDUsage_BCS_PeriodicalOnlyDecodeWithPlus5: c_uint = 0xAE;
pub const kHIDUsage_BCS_PeriodicalIgnorePlus5: c_uint = 0xAF;
pub const kHIDUsage_BCS_Check: c_uint = 0xB0;
pub const kHIDUsage_BCS_CheckDisablePrice: c_uint = 0xB1;
pub const kHIDUsage_BCS_CheckEnable4DigitPrice: c_uint = 0xB2;
pub const kHIDUsage_BCS_CheckEnable5DigitPrice: c_uint = 0xB3;
pub const kHIDUsage_BCS_CheckEnableEuropean4DigitPrice: c_uint = 0xB4;
pub const kHIDUsage_BCS_CheckEnableEuropean5DigitPrice: c_uint = 0xB5;
pub const kHIDUsage_BCS_EANTwoLabel: c_uint = 0xB7;
pub const kHIDUsage_BCS_EANThreeLabel: c_uint = 0xB8;
pub const kHIDUsage_BCS_EAN8FlagDigit1: c_uint = 0xB9;
pub const kHIDUsage_BCS_EAN8FlagDigit2: c_uint = 0xBA;
pub const kHIDUsage_BCS_EAN8FlagDigit3: c_uint = 0xBB;
pub const kHIDUsage_BCS_EAN13FlagDigit1: c_uint = 0xBC;
pub const kHIDUsage_BCS_EAN13FlagDigit2: c_uint = 0xBD;
pub const kHIDUsage_BCS_EAN13FlagDigit3: c_uint = 0xBE;
pub const kHIDUsage_BCS_AddEAN2_3LabelDefinition: c_uint = 0xBF;
pub const kHIDUsage_BCS_ClearAllEAN2_3LabelDefinitions: c_uint = 0xC0;
pub const kHIDUsage_BCS_Codabar: c_uint = 0xC3;
pub const kHIDUsage_BCS_Code128: c_uint = 0xC4;
pub const kHIDUsage_BCS_Code39: c_uint = 0xC7;
pub const kHIDUsage_BCS_Code93: c_uint = 0xC8;
pub const kHIDUsage_BCS_FullASCIIConversion: c_uint = 0xC9;
pub const kHIDUsage_BCS_Interleaved2of5: c_uint = 0xCA;
pub const kHIDUsage_BCS_ItalianPharmacyCode: c_uint = 0xCB;
pub const kHIDUsage_BCS_MSI_Plessey: c_uint = 0xCC;
pub const kHIDUsage_BCS_Standard2of5IATA: c_uint = 0xCD;
pub const kHIDUsage_BCS_Standard2of5: c_uint = 0xCE;
pub const kHIDUsage_BCS_TransmitStart_Stop: c_uint = 0xD3;
pub const kHIDUsage_BCS_TriOptic: c_uint = 0xD4;
pub const kHIDUsage_BCS_UCC_EAN_128: c_uint = 0xD5;
pub const kHIDUsage_BCS_CheckDigit: c_uint = 0xD6;
pub const kHIDUsage_BCS_CheckDigitDisable: c_uint = 0xD7;
pub const kHIDUsage_BCS_CheckDigitEnableInterleaved2of5OPCC: c_uint = 0xD8;
pub const kHIDUsage_BCS_CheckDigitEnableInterleaved2of5USS: c_uint = 0xD9;
pub const kHIDUsage_BCS_CheckDigitEnableStandard2of5OPCC: c_uint = 0xDA;
pub const kHIDUsage_BCS_CheckDigitEnableStandard2of5USS: c_uint = 0xDB;
pub const kHIDUsage_BCS_CheckDigitEnableOneMSIPlessey: c_uint = 0xDC;
pub const kHIDUsage_BCS_CheckDigitEnableTwoMSIPlessey: c_uint = 0xDD;
pub const kHIDUsage_BCS_CheckDigitCodabarEnable: c_uint = 0xDE;
pub const kHIDUsage_BCS_CheckDigitCode99Enable: c_uint = 0xDF;
pub const kHIDUsage_BCS_TransmitCheckDigit: c_uint = 0xF0;
pub const kHIDUsage_BCS_DisableCheckDigitTransmit: c_uint = 0xF1;
pub const kHIDUsage_BCS_EnableCheckDigitTransmit: c_uint = 0xF2;
pub const kHIDUsage_BCS_SymbologyIdentifier1: c_uint = 0xFB;
pub const kHIDUsage_BCS_SymbologyIdentifier2: c_uint = 0xFC;
pub const kHIDUsage_BCS_SymbologyIdentifier3: c_uint = 0xFD;
pub const kHIDUsage_BCS_DecodedData: c_uint = 0xFE;
pub const kHIDUsage_BCS_DecodeDataContinued: c_uint = 0xFF;
pub const kHIDUsage_BCS_BarSpaceData: c_uint = 0x100;
pub const kHIDUsage_BCS_ScannerDataAccuracy: c_uint = 0x101;
pub const kHIDUsage_BCS_RawDataPolarity: c_uint = 0x102;
pub const kHIDUsage_BCS_PolarityInvertedBarCode: c_uint = 0x103;
pub const kHIDUsage_BCS_PolarityNormalBarCode: c_uint = 0x104;
pub const kHIDUsage_BCS_MinimumLengthToDecode: c_uint = 0x106;
pub const kHIDUsage_BCS_MaximumLengthToDecode: c_uint = 0x107;
pub const kHIDUsage_BCS_FirstDiscreteLengthToDecode: c_uint = 0x108;
pub const kHIDUsage_BCS_SecondDiscreteLengthToDecode: c_uint = 0x109;
pub const kHIDUsage_BCS_DataLengthMethod: c_uint = 0x10A;
pub const kHIDUsage_BCS_DLMethodReadAny: c_uint = 0x10B;
pub const kHIDUsage_BCS_DLMethodCheckInRange: c_uint = 0x10C;
pub const kHIDUsage_BCS_DLMethodCheckForDiscrete: c_uint = 0x10D;
pub const kHIDUsage_BCS_AztecCode: c_uint = 0x110;
pub const kHIDUsage_BCS_BC412: c_uint = 0x111;
pub const kHIDUsage_BCS_ChannelCode: c_uint = 0x112;
pub const kHIDUsage_BCS_Code16: c_uint = 0x113;
pub const kHIDUsage_BCS_Code32: c_uint = 0x114;
pub const kHIDUsage_BCS_Code49: c_uint = 0x115;
pub const kHIDUsage_BCS_CodeOne: c_uint = 0x116;
pub const kHIDUsage_BCS_Colorcode: c_uint = 0x117;
pub const kHIDUsage_BCS_DataMatrix: c_uint = 0x118;
pub const kHIDUsage_BCS_MaxiCode: c_uint = 0x119;
pub const kHIDUsage_BCS_MicroPDF: c_uint = 0x11A;
pub const kHIDUsage_BCS_PDF_417: c_uint = 0x11B;
pub const kHIDUsage_BCS_PosiCode: c_uint = 0x11C;
pub const kHIDUsage_BCS_QRCode: c_uint = 0x11D;
pub const kHIDUsage_BCS_SuperCode: c_uint = 0x11E;
pub const kHIDUsage_BCS_UltraCode: c_uint = 0x11F;
pub const kHIDUsage_BCS_USB_5_SlugCode: c_uint = 0x120;
pub const kHIDUsage_BCS_VeriCode: c_uint = 0x121;

pub const kHIDUsage_WD_Undefined: c_uint = 0x00;
pub const kHIDUsage_WD_WeighingDevice: c_uint = 0x01;
pub const kHIDUsage_WD_ScaleScaleDevice: c_uint = 0x20;
pub const kHIDUsage_WD_ScaleScaleClassIMetricCL: c_uint = 0x21;
pub const kHIDUsage_WD_ScaleScaleClassIMetric: c_uint = 0x22;
pub const kHIDUsage_WD_ScaleScaleClassIIMetric: c_uint = 0x23;
pub const kHIDUsage_WD_ScaleScaleClassIIIMetric: c_uint = 0x24;
pub const kHIDUsage_WD_ScaleScaleClassIIILMetric: c_uint = 0x25;
pub const kHIDUsage_WD_ScaleScaleClassIVMetric: c_uint = 0x26;
pub const kHIDUsage_WD_ScaleScaleClassIIIEnglish: c_uint = 0x27;
pub const kHIDUsage_WD_ScaleScaleClassIIILEnglish: c_uint = 0x28;
pub const kHIDUsage_WD_ScaleScaleClassIVEnglish: c_uint = 0x29;
pub const kHIDUsage_WD_ScaleScaleClassGeneric: c_uint = 0x2A;
pub const kHIDUsage_WD_ScaleAtrributeReport: c_uint = 0x30;
pub const kHIDUsage_WD_ScaleControlReport: c_uint = 0x31;
pub const kHIDUsage_WD_ScaleDataReport: c_uint = 0x32;
pub const kHIDUsage_WD_ScaleStatusReport: c_uint = 0x33;
pub const kHIDUsage_WD_ScaleWeightLimitReport: c_uint = 0x34;
pub const kHIDUsage_WD_ScaleStatisticsReport: c_uint = 0x35;
pub const kHIDUsage_WD_DataWeight: c_uint = 0x40;
pub const kHIDUsage_WD_DataScaling: c_uint = 0x41;
pub const kHIDUsage_WD_WeightUnit: c_uint = 0x50;
pub const kHIDUsage_WD_WeightUnitMilligram: c_uint = 0x51;
pub const kHIDUsage_WD_WeightUnitGram: c_uint = 0x52;
pub const kHIDUsage_WD_WeightUnitKilogram: c_uint = 0x53;
pub const kHIDUsage_WD_WeightUnitCarats: c_uint = 0x54;
pub const kHIDUsage_WD_WeightUnitTaels: c_uint = 0x55;
pub const kHIDUsage_WD_WeightUnitGrains: c_uint = 0x56;
pub const kHIDUsage_WD_WeightUnitPennyweights: c_uint = 0x57;
pub const kHIDUsage_WD_WeightUnitMetricTon: c_uint = 0x58;
pub const kHIDUsage_WD_WeightUnitAvoirTon: c_uint = 0x59;
pub const kHIDUsage_WD_WeightUnitTroyOunce: c_uint = 0x5A;
pub const kHIDUsage_WD_WeightUnitOunce: c_uint = 0x5B;
pub const kHIDUsage_WD_WeightUnitPound: c_uint = 0x5C;
pub const kHIDUsage_WD_CalibrationCount: c_uint = 0x60;
pub const kHIDUsage_WD_RezeroCount: c_uint = 0x61;
pub const kHIDUsage_WD_ScaleStatus: c_uint = 0x70;
pub const kHIDUsage_WD_ScaleStatusFault: c_uint = 0x71;
pub const kHIDUsage_WD_ScaleStatusStableAtZero: c_uint = 0x72;
pub const kHIDUsage_WD_ScaleStatusInMotion: c_uint = 0x73;
pub const kHIDUsage_WD_ScaleStatusWeightStable: c_uint = 0x74;
pub const kHIDUsage_WD_ScaleStatusUnderZero: c_uint = 0x75;
pub const kHIDUsage_WD_ScaleStatusOverWeightLimit: c_uint = 0x76;
pub const kHIDUsage_WD_ScaleStatusRequiresCalibration: c_uint = 0x77;
pub const kHIDUsage_WD_ScaleStatusRequiresRezeroing: c_uint = 0x78;
pub const kHIDUsage_WD_ZeroScale: c_uint = 0x80;
pub const kHIDUsage_WD_EnforcedZeroReturn: c_uint = 0x81;

pub const kHIDUsage_MSR_Undefined: c_uint = 0x00;
pub const kHIDUsage_MSR_DeviceReadOnly: c_uint = 0x01;
pub const kHIDUsage_MSR_Track1Length: c_uint = 0x11;
pub const kHIDUsage_MSR_Track2Length: c_uint = 0x12;
pub const kHIDUsage_MSR_Track3Length: c_uint = 0x13;
pub const kHIDUsage_MSR_TrackJISLength: c_uint = 0x14;
pub const kHIDUsage_MSR_TrackData: c_uint = 0x20;
pub const kHIDUsage_MSR_Track1Data: c_uint = 0x21;
pub const kHIDUsage_MSR_Track2Data: c_uint = 0x22;
pub const kHIDUsage_MSR_Track3Data: c_uint = 0x23;
pub const kHIDUsage_MSR_TrackJISData: c_uint = 0x24;

pub const kHIDUsage_CC_Undefined: c_uint = 0x00;
pub const kHIDUsage_CC_Autofocus: c_uint = 0x20;
pub const kHIDUsage_CC_Shutter: c_uint = 0x21;

pub const kHIDUsage_FIDO_Undefined: c_uint = 0x00;
pub const kHIDUsage_FIDO_U2FDevice: c_uint = 0x01;
pub const kHIDUsage_FIDO_InputData: c_uint = 0x20;
pub const kHIDUsage_FIDO_OutputData: c_uint = 0x21;

unsafe impl ConcreteType for IOHIDValue {
    /// Returns the type identifier of all IOHIDValue instances.
    /// Returns the type identifier of all IOHIDValue instances.
    #[doc(alias = "IOHIDValueGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOHIDValueGetTypeID() -> CFTypeID;
        }
        unsafe { IOHIDValueGetTypeID() }
    }
}

impl IOHIDValue {
    /// Creates a new element value using an integer value.
    ///
    /// Parameters:
    /// - allocator: The CFAllocator which should be used to allocate memory for the value. This parameter may be NULL in which case the current default CFAllocator is used. If this reference is not a valid CFAllocator, the behavior is undefined.
    ///
    /// - element: IOHIDElementRef associated with this value.
    ///
    /// - timeStamp: OS absolute time timestamp for this value.
    ///
    /// - value: Integer value to be copied to this object.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a reference to a new IOHIDValueRef.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// IOHIDValueGetTimeStamp should represent OS AbsoluteTime, not CFAbsoluteTime. To obtain the OS AbsoluteTime, please reference the APIs declared in <mach/mach_time.h>
    ///
    ///
    /// Creates a new element value using an integer value.
    ///
    /// IOHIDValueGetTimeStamp should represent OS AbsoluteTime, not CFAbsoluteTime.
    /// To obtain the OS AbsoluteTime, please reference the APIs declared in
    /// <mach
    /// /mach_time.h>
    ///
    /// Parameter `allocator`: The CFAllocator which should be used to allocate memory for the value.  This
    /// parameter may be NULL in which case the current default CFAllocator is used. If this
    /// reference is not a valid CFAllocator, the behavior is undefined.
    ///
    /// Parameter `element`: IOHIDElementRef associated with this value.
    ///
    /// Parameter `timeStamp`: OS absolute time timestamp for this value.
    ///
    /// Parameter `value`: Integer value to be copied to this object.
    ///
    /// Returns: Returns a reference to a new IOHIDValueRef.
    #[doc(alias = "IOHIDValueCreateWithIntegerValue")]
    #[inline]
    pub fn with_integer_value(
        allocator: Option<&CFAllocator>,
        element: &IOHIDElement,
        time_stamp: u64,
        value: CFIndex,
    ) -> CFRetained<IOHIDValue> {
        extern "C-unwind" {
            fn IOHIDValueCreateWithIntegerValue(
                allocator: Option<&CFAllocator>,
                element: &IOHIDElement,
                time_stamp: u64,
                value: CFIndex,
            ) -> Option<NonNull<IOHIDValue>>;
        }
        let ret =
            unsafe { IOHIDValueCreateWithIntegerValue(allocator, element, time_stamp, value) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a new element value using byte data.
    ///
    /// Parameters:
    /// - allocator: The CFAllocator which should be used to allocate memory for the value. This parameter may be NULL in which case the current default CFAllocator is used. If this reference is not a valid CFAllocator, the behavior is undefined.
    ///
    /// - element: IOHIDElementRef associated with this value.
    ///
    /// - timeStamp: OS absolute time timestamp for this value.
    ///
    /// - bytes: Pointer to a buffer of uint8_t to be copied to this object.
    ///
    /// - length: Number of bytes in the passed buffer.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a reference to a new IOHIDValueRef.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// IOHIDValueGetTimeStamp should represent OS AbsoluteTime, not CFAbsoluteTime. To obtain the OS AbsoluteTime, please reference the APIs declared in <mach/mach_time.h>
    ///
    ///
    /// Creates a new element value using byte data.
    ///
    /// IOHIDValueGetTimeStamp should represent OS AbsoluteTime, not CFAbsoluteTime.
    /// To obtain the OS AbsoluteTime, please reference the APIs declared in
    /// <mach
    /// /mach_time.h>
    ///
    /// Parameter `allocator`: The CFAllocator which should be used to allocate memory for the value.  This
    /// parameter may be NULL in which case the current default CFAllocator is used. If this
    /// reference is not a valid CFAllocator, the behavior is undefined.
    ///
    /// Parameter `element`: IOHIDElementRef associated with this value.
    ///
    /// Parameter `timeStamp`: OS absolute time timestamp for this value.
    ///
    /// Parameter `bytes`: Pointer to a buffer of uint8_t to be copied to this object.
    ///
    /// Parameter `length`: Number of bytes in the passed buffer.
    ///
    /// Returns: Returns a reference to a new IOHIDValueRef.
    ///
    /// # Safety
    ///
    /// `bytes` must be a valid pointer.
    #[doc(alias = "IOHIDValueCreateWithBytes")]
    #[inline]
    pub unsafe fn with_bytes(
        allocator: Option<&CFAllocator>,
        element: &IOHIDElement,
        time_stamp: u64,
        bytes: NonNull<u8>,
        length: CFIndex,
    ) -> Option<CFRetained<IOHIDValue>> {
        extern "C-unwind" {
            fn IOHIDValueCreateWithBytes(
                allocator: Option<&CFAllocator>,
                element: &IOHIDElement,
                time_stamp: u64,
                bytes: NonNull<u8>,
                length: CFIndex,
            ) -> Option<NonNull<IOHIDValue>>;
        }
        let ret =
            unsafe { IOHIDValueCreateWithBytes(allocator, element, time_stamp, bytes, length) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a new element value using byte data without performing a copy.
    ///
    /// Parameters:
    /// - allocator: The CFAllocator which should be used to allocate memory for the value. This parameter may be NULL in which case the current default CFAllocator is used. If this reference is not a valid CFAllocator, the behavior is undefined.
    ///
    /// - element: IOHIDElementRef associated with this value.
    ///
    /// - timeStamp: OS absolute time timestamp for this value.
    ///
    /// - bytes: Pointer to a buffer of uint8_t to be referenced by this object.
    ///
    /// - length: Number of bytes in the passed buffer.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a reference to a new IOHIDValueRef.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The timestamp value passed should represent OS AbsoluteTime, not CFAbsoluteTime. To obtain the OS AbsoluteTime, please reference the APIs declared in <mach/mach_time.h>
    ///
    ///
    /// Creates a new element value using byte data without performing a copy.
    ///
    /// The timestamp value passed should represent OS AbsoluteTime, not CFAbsoluteTime.
    /// To obtain the OS AbsoluteTime, please reference the APIs declared in
    /// <mach
    /// /mach_time.h>
    ///
    /// Parameter `allocator`: The CFAllocator which should be used to allocate memory for the value.  This
    /// parameter may be NULL in which case the current default CFAllocator is used. If this
    /// reference is not a valid CFAllocator, the behavior is undefined.
    ///
    /// Parameter `element`: IOHIDElementRef associated with this value.
    ///
    /// Parameter `timeStamp`: OS absolute time timestamp for this value.
    ///
    /// Parameter `bytes`: Pointer to a buffer of uint8_t to be referenced by this object.
    ///
    /// Parameter `length`: Number of bytes in the passed buffer.
    ///
    /// Returns: Returns a reference to a new IOHIDValueRef.
    ///
    /// # Safety
    ///
    /// `bytes` must be a valid pointer.
    #[doc(alias = "IOHIDValueCreateWithBytesNoCopy")]
    #[inline]
    pub unsafe fn with_bytes_no_copy(
        allocator: Option<&CFAllocator>,
        element: &IOHIDElement,
        time_stamp: u64,
        bytes: NonNull<u8>,
        length: CFIndex,
    ) -> Option<CFRetained<IOHIDValue>> {
        extern "C-unwind" {
            fn IOHIDValueCreateWithBytesNoCopy(
                allocator: Option<&CFAllocator>,
                element: &IOHIDElement,
                time_stamp: u64,
                bytes: NonNull<u8>,
                length: CFIndex,
            ) -> Option<NonNull<IOHIDValue>>;
        }
        let ret = unsafe {
            IOHIDValueCreateWithBytesNoCopy(allocator, element, time_stamp, bytes, length)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the element value associated with this IOHIDValueRef.
    ///
    /// Parameters:
    /// - value: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a IOHIDElementRef referenced by this value.
    ///
    ///
    /// Returns the element value associated with this IOHIDValueRef.
    ///
    /// Parameter `value`: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    /// Returns: Returns a IOHIDElementRef referenced by this value.
    #[doc(alias = "IOHIDValueGetElement")]
    #[inline]
    pub fn element(&self) -> CFRetained<IOHIDElement> {
        extern "C-unwind" {
            fn IOHIDValueGetElement(value: &IOHIDValue) -> Option<NonNull<IOHIDElement>>;
        }
        let ret = unsafe { IOHIDValueGetElement(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Returns the timestamp value contained in this IOHIDValueRef.
    ///
    /// Parameters:
    /// - value: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a uint64_t representing the timestamp of this value.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The timestamp value returned represents OS AbsoluteTime, not CFAbsoluteTime.
    ///
    ///
    /// Returns the timestamp value contained in this IOHIDValueRef.
    ///
    /// The timestamp value returned represents OS AbsoluteTime, not CFAbsoluteTime.
    ///
    /// Parameter `value`: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    /// Returns: Returns a uint64_t representing the timestamp of this value.
    #[doc(alias = "IOHIDValueGetTimeStamp")]
    #[inline]
    pub fn time_stamp(&self) -> u64 {
        extern "C-unwind" {
            fn IOHIDValueGetTimeStamp(value: &IOHIDValue) -> u64;
        }
        unsafe { IOHIDValueGetTimeStamp(self) }
    }

    /// Returns the size, in bytes, of the value contained in this IOHIDValueRef.
    ///
    /// Parameters:
    /// - value: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns length of the value.
    ///
    ///
    /// Returns the size, in bytes, of the value contained in this IOHIDValueRef.
    ///
    /// Parameter `value`: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    /// Returns: Returns length of the value.
    #[doc(alias = "IOHIDValueGetLength")]
    #[inline]
    pub fn length(&self) -> CFIndex {
        extern "C-unwind" {
            fn IOHIDValueGetLength(value: &IOHIDValue) -> CFIndex;
        }
        unsafe { IOHIDValueGetLength(self) }
    }

    /// Returns a byte pointer to the value contained in this IOHIDValueRef.
    ///
    /// Parameters:
    /// - value: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a pointer to the value.
    ///
    ///
    /// Returns a byte pointer to the value contained in this IOHIDValueRef.
    ///
    /// Parameter `value`: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    /// Returns: Returns a pointer to the value.
    #[doc(alias = "IOHIDValueGetBytePtr")]
    #[inline]
    pub fn byte_ptr(&self) -> NonNull<u8> {
        extern "C-unwind" {
            fn IOHIDValueGetBytePtr(value: &IOHIDValue) -> Option<NonNull<u8>>;
        }
        let ret = unsafe { IOHIDValueGetBytePtr(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns an integer representaion of the value contained in this IOHIDValueRef.
    ///
    /// Parameters:
    /// - value: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns an integer representation of the value.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The value is based on the logical element value contained in the report returned by the device.
    ///
    ///
    /// Returns an integer representaion of the value contained in this IOHIDValueRef.
    ///
    /// The value is based on the logical element value contained in the report returned by the device.
    ///
    /// Parameter `value`: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    /// Returns: Returns an integer representation of the value.
    #[doc(alias = "IOHIDValueGetIntegerValue")]
    #[inline]
    pub fn integer_value(&self) -> CFIndex {
        extern "C-unwind" {
            fn IOHIDValueGetIntegerValue(value: &IOHIDValue) -> CFIndex;
        }
        unsafe { IOHIDValueGetIntegerValue(self) }
    }

    /// Returns an scaled representaion of the value contained in this IOHIDValueRef based on the scale type.
    ///
    /// Parameters:
    /// - value: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    /// - type: The type of scaling to be performed.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns an scaled floating point representation of the value.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The scaled value is based on the range described by the scale type's min and max, such that:
    ///
    /// scaledValue = ((value - min) * (scaledMax - scaledMin) / (max - min)) + scaledMin
    ///
    /// **Note:**
    ///
    /// There are currently two types of scaling that can be applied:
    ///
    /// - **kIOHIDValueScaleTypePhysical**: Scales element value using the physical bounds of the device such that **scaledMin = physicalMin** and **scaledMax = physicalMax**.
    ///
    /// - **kIOHIDValueScaleTypeCalibrated**: Scales element value such that **scaledMin = -1** and **scaledMax = 1**. This value will also take into account the calibration properties associated with this element.
    ///
    ///
    /// Returns an scaled representaion of the value contained in this IOHIDValueRef based on the scale type.
    ///
    /// The scaled value is based on the range described by the scale type's min and max, such that:
    /// <br>
    /// scaledValue = ((value - min) * (scaledMax - scaledMin) / (max - min)) + scaledMin
    /// <br>
    /// <b>
    /// Note:
    /// </b>
    /// <br>
    /// There are currently two types of scaling that can be applied:
    /// <ul>
    /// <li>
    /// <b>
    /// kIOHIDValueScaleTypePhysical
    /// </b>
    /// : Scales element value using the physical bounds of the device such that
    /// <b>
    /// scaledMin = physicalMin
    /// </b>
    /// and
    /// <b>
    /// scaledMax = physicalMax
    /// </b>
    /// .
    /// <li>
    /// <b>
    /// kIOHIDValueScaleTypeCalibrated
    /// </b>
    /// : Scales element value such that
    /// <b>
    /// scaledMin = -1
    /// </b>
    /// and
    /// <b>
    /// scaledMax = 1
    /// </b>
    /// .  This value will also take into account the calibration properties associated with this element.
    /// </ul>
    ///
    /// Parameter `value`: The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    ///
    /// Parameter `type`: The type of scaling to be performed.
    ///
    /// Returns: Returns an scaled floating point representation of the value.
    #[doc(alias = "IOHIDValueGetScaledValue")]
    #[inline]
    pub fn scaled_value(&self, r#type: IOHIDValueScaleType) -> c_double {
        extern "C-unwind" {
            fn IOHIDValueGetScaledValue(
                value: &IOHIDValue,
                r#type: IOHIDValueScaleType,
            ) -> c_double;
        }
        unsafe { IOHIDValueGetScaledValue(self, r#type) }
    }
}

/// Various options that can be supplied to IOHIDTransaction functions.
///
/// explicit enough.
///
/// IOHIDDeviceRef being passed in. The expectation is that transaction will only exist during
/// the lifetime of the IOHIDDeviceRef object.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOHIDTransactionOptions(pub u32);
bitflags::bitflags! {
    impl IOHIDTransactionOptions: u32 {
        #[doc(alias = "kIOHIDTransactionOptionsNone")]
        const None = 0x0;
        #[doc(alias = "kIOHIDTransactionOptionsWeakDevice")]
        const WeakDevice = 0x1;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDTransactionOptions {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDTransactionOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// This is the type of a reference to the IOHIDTransaction.
#[doc(alias = "IOHIDTransactionRef")]
#[repr(C)]
pub struct IOHIDTransaction {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl IOHIDTransaction {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__IOHIDTransaction"> for IOHIDTransaction {}
);

unsafe impl ConcreteType for IOHIDTransaction {
    /// Returns the type identifier of all IOHIDTransaction instances.
    /// Returns the type identifier of all IOHIDTransaction instances.
    #[doc(alias = "IOHIDTransactionGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOHIDTransactionGetTypeID() -> CFTypeID;
        }
        unsafe { IOHIDTransactionGetTypeID() }
    }
}

impl IOHIDTransaction {
    /// Creates an IOHIDTransaction object for the specified device.
    ///
    /// Parameters:
    /// - allocator: Allocator to be used during creation.
    ///
    /// - device: IOHIDDevice object
    ///
    /// - direction: The direction, either in or out, for the transaction.
    ///
    /// - options: Reserved for future use.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns a new IOHIDTransactionRef.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// IOHIDTransaction objects can be used to either send or receive multiple element values. As such the direction used should represent they type of objects added to the transaction.
    ///
    ///
    /// Creates an IOHIDTransaction object for the specified device.
    ///
    /// IOHIDTransaction objects can be used to either send or receive
    /// multiple element values.  As such the direction used should
    /// represent they type of objects added to the transaction.
    ///
    /// Parameter `allocator`: Allocator to be used during creation.
    ///
    /// Parameter `device`: IOHIDDevice object
    ///
    /// Parameter `direction`: The direction, either in or out, for the transaction.
    ///
    /// Parameter `options`: Reserved for future use.
    ///
    /// Returns: Returns a new IOHIDTransactionRef.
    #[doc(alias = "IOHIDTransactionCreate")]
    #[inline]
    pub fn new(
        allocator: Option<&CFAllocator>,
        device: &IOHIDDevice,
        direction: IOHIDTransactionDirectionType,
        options: IOOptionBits,
    ) -> Option<CFRetained<IOHIDTransaction>> {
        extern "C-unwind" {
            fn IOHIDTransactionCreate(
                allocator: Option<&CFAllocator>,
                device: &IOHIDDevice,
                direction: IOHIDTransactionDirectionType,
                options: IOOptionBits,
            ) -> Option<NonNull<IOHIDTransaction>>;
        }
        let ret = unsafe { IOHIDTransactionCreate(allocator, device, direction, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Obtain the device associated with the transaction.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction to be queried.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the a reference to the device.
    ///
    ///
    /// Obtain the device associated with the transaction.
    ///
    /// Parameter `transaction`: IOHIDTransaction to be queried.
    ///
    /// Returns: Returns the a reference to the device.
    #[doc(alias = "IOHIDTransactionGetDevice")]
    #[inline]
    pub fn device(&self) -> CFRetained<IOHIDDevice> {
        extern "C-unwind" {
            fn IOHIDTransactionGetDevice(
                transaction: &IOHIDTransaction,
            ) -> Option<NonNull<IOHIDDevice>>;
        }
        let ret = unsafe { IOHIDTransactionGetDevice(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Obtain the direction of the transaction.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction to be queried.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns the transaction direction.
    ///
    ///
    /// Obtain the direction of the transaction.
    ///
    /// Parameter `transaction`: IOHIDTransaction to be queried.
    ///
    /// Returns: Returns the transaction direction.
    #[doc(alias = "IOHIDTransactionGetDirection")]
    #[inline]
    pub fn direction(&self) -> IOHIDTransactionDirectionType {
        extern "C-unwind" {
            fn IOHIDTransactionGetDirection(
                transaction: &IOHIDTransaction,
            ) -> IOHIDTransactionDirectionType;
        }
        unsafe { IOHIDTransactionGetDirection(self) }
    }

    /// Sets the direction of the transaction @disussion This method is useful for manipulating bi-direction (feature) elements such that you can set or get element values without creating an additional transaction object.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be modified.
    ///
    /// - direction: The new transaction direction.
    ///
    /// Sets the direction of the transaction
    ///
    /// This method is useful for manipulating bi-direction (feature)
    /// elements such that you can set or get element values without
    /// creating an additional transaction object.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be modified.
    ///
    /// Parameter `direction`: The new transaction direction.
    #[doc(alias = "IOHIDTransactionSetDirection")]
    #[inline]
    pub fn set_direction(&self, direction: IOHIDTransactionDirectionType) {
        extern "C-unwind" {
            fn IOHIDTransactionSetDirection(
                transaction: &IOHIDTransaction,
                direction: IOHIDTransactionDirectionType,
            );
        }
        unsafe { IOHIDTransactionSetDirection(self, direction) }
    }

    /// Adds an element to the transaction @disussion To minimize device traffic it is important to add elements that share a common report type and report id.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be modified.
    ///
    /// - element: Element to be added to the transaction.
    ///
    /// Adds an element to the transaction
    ///
    /// To minimize device traffic it is important to add elements that
    /// share a common report type and report id.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be modified.
    ///
    /// Parameter `element`: Element to be added to the transaction.
    #[doc(alias = "IOHIDTransactionAddElement")]
    #[inline]
    pub fn add_element(&self, element: &IOHIDElement) {
        extern "C-unwind" {
            fn IOHIDTransactionAddElement(transaction: &IOHIDTransaction, element: &IOHIDElement);
        }
        unsafe { IOHIDTransactionAddElement(self, element) }
    }

    /// Removes an element to the transaction
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be modified.
    ///
    /// - element: Element to be removed to the transaction.
    ///
    /// Removes an element to the transaction
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be modified.
    ///
    /// Parameter `element`: Element to be removed to the transaction.
    #[doc(alias = "IOHIDTransactionRemoveElement")]
    #[inline]
    pub fn remove_element(&self, element: &IOHIDElement) {
        extern "C-unwind" {
            fn IOHIDTransactionRemoveElement(
                transaction: &IOHIDTransaction,
                element: &IOHIDElement,
            );
        }
        unsafe { IOHIDTransactionRemoveElement(self, element) }
    }

    /// Queries the transaction to determine if elemement has been added.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be queried.
    ///
    /// - element: Element to be queried.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns true or false depending if element is present.
    ///
    ///
    /// Queries the transaction to determine if elemement has been added.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be queried.
    ///
    /// Parameter `element`: Element to be queried.
    ///
    /// Returns: Returns true or false depending if element is present.
    #[doc(alias = "IOHIDTransactionContainsElement")]
    #[inline]
    pub fn contains_element(&self, element: &IOHIDElement) -> bool {
        extern "C-unwind" {
            fn IOHIDTransactionContainsElement(
                transaction: &IOHIDTransaction,
                element: &IOHIDElement,
            ) -> Boolean;
        }
        let ret = unsafe { IOHIDTransactionContainsElement(self, element) };
        ret != 0
    }

    /// Schedules transaction with run loop.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be modified.
    ///
    /// - runLoop: RunLoop to be used when scheduling any asynchronous activity.
    ///
    /// - runLoopMode: Run loop mode to be used when scheduling any asynchronous activity.
    ///
    ///
    /// ## Discussion
    ///
    /// Formally associates transaction with client's run loop. Scheduling this transaction with the run loop is necessary before making use of any asynchronous APIs.
    ///
    ///
    /// Schedules transaction with run loop.
    ///
    /// Formally associates transaction with client's run loop.
    /// Scheduling this transaction with the run loop is necessary
    /// before making use of any asynchronous APIs.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be modified.
    ///
    /// Parameter `runLoop`: RunLoop to be used when scheduling any asynchronous
    /// activity.
    ///
    /// Parameter `runLoopMode`: Run loop mode to be used when scheduling any
    /// asynchronous activity.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "IOHIDTransactionScheduleWithRunLoop")]
    #[inline]
    pub unsafe fn schedule_with_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn IOHIDTransactionScheduleWithRunLoop(
                transaction: &IOHIDTransaction,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { IOHIDTransactionScheduleWithRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Unschedules transaction with run loop.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be modified.
    ///
    /// - runLoop: RunLoop to be used when scheduling any asynchronous activity.
    ///
    /// - runLoopMode: Run loop mode to be used when scheduling any asynchronous activity.
    ///
    ///
    /// ## Discussion
    ///
    /// Formally disassociates transaction with client's run loop.
    ///
    ///
    /// Unschedules transaction with run loop.
    ///
    /// Formally disassociates transaction with client's run loop.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be modified.
    ///
    /// Parameter `runLoop`: RunLoop to be used when scheduling any asynchronous
    /// activity.
    ///
    /// Parameter `runLoopMode`: Run loop mode to be used when scheduling any
    /// asynchronous activity.
    ///
    /// # Safety
    ///
    /// `run_loop` possibly has additional threading requirements.
    #[doc(alias = "IOHIDTransactionUnscheduleFromRunLoop")]
    #[inline]
    pub unsafe fn unschedule_from_run_loop(&self, run_loop: &CFRunLoop, run_loop_mode: &CFString) {
        extern "C-unwind" {
            fn IOHIDTransactionUnscheduleFromRunLoop(
                transaction: &IOHIDTransaction,
                run_loop: &CFRunLoop,
                run_loop_mode: &CFString,
            );
        }
        unsafe { IOHIDTransactionUnscheduleFromRunLoop(self, run_loop, run_loop_mode) }
    }

    /// Sets the value for a transaction element.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be modified.
    ///
    /// - element: Element to be modified after a commit.
    ///
    /// - value: Value to be set for the given element.
    ///
    /// - options: See IOHIDTransactionOption.
    ///
    ///
    /// ## Discussion
    ///
    /// The value set is pended until the transaction is committed and is only used if the transaction direction is kIOHIDTransactionDirectionTypeOutput. Use the kIOHIDTransactionOptionDefaultOutputValue option to set the default element value.
    ///
    ///
    /// Sets the value for a transaction element.
    ///
    /// The value set is pended until the transaction is committed and
    /// is only used if the transaction direction is
    /// kIOHIDTransactionDirectionTypeOutput.  Use the
    /// kIOHIDTransactionOptionDefaultOutputValue option to set the
    /// default element value.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be modified.
    ///
    /// Parameter `element`: Element to be modified after a commit.
    ///
    /// Parameter `value`: Value to be set for the given element.
    ///
    /// Parameter `options`: See IOHIDTransactionOption.
    #[doc(alias = "IOHIDTransactionSetValue")]
    #[inline]
    pub fn set_value(&self, element: &IOHIDElement, value: &IOHIDValue, options: IOOptionBits) {
        extern "C-unwind" {
            fn IOHIDTransactionSetValue(
                transaction: &IOHIDTransaction,
                element: &IOHIDElement,
                value: &IOHIDValue,
                options: IOOptionBits,
            );
        }
        unsafe { IOHIDTransactionSetValue(self, element, value, options) }
    }

    /// Obtains the value for a transaction element.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be queried.
    ///
    /// - element: Element to be queried.
    ///
    /// - options: See IOHIDTransactionOption.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns IOHIDValueRef for the given element.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the transaction direction is kIOHIDTransactionDirectionTypeInput the value represents what was obtained from the device from the transaction. Otherwise, if the transaction direction is kIOHIDTransactionDirectionTypeOutput the value represents the pending value to be sent to the device. Use the kIOHIDTransactionOptionDefaultOutputValue option to get the default element value.
    ///
    ///
    /// Obtains the value for a transaction element.
    ///
    /// If the transaction direction is
    /// kIOHIDTransactionDirectionTypeInput the value represents what
    /// was obtained from the device from the transaction.  Otherwise,
    /// if the transaction direction is
    /// kIOHIDTransactionDirectionTypeOutput the value represents the
    /// pending value to be sent to the device.  Use the
    /// kIOHIDTransactionOptionDefaultOutputValue option to get the
    /// default element value.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be queried.
    ///
    /// Parameter `element`: Element to be queried.
    ///
    /// Parameter `options`: See IOHIDTransactionOption.
    ///
    /// Returns: Returns IOHIDValueRef for the given element.
    #[doc(alias = "IOHIDTransactionGetValue")]
    #[inline]
    pub fn value(
        &self,
        element: &IOHIDElement,
        options: IOOptionBits,
    ) -> Option<CFRetained<IOHIDValue>> {
        extern "C-unwind" {
            fn IOHIDTransactionGetValue(
                transaction: &IOHIDTransaction,
                element: &IOHIDElement,
                options: IOOptionBits,
            ) -> Option<NonNull<IOHIDValue>>;
        }
        let ret = unsafe { IOHIDTransactionGetValue(self, element, options) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Synchronously commits element transaction to the device.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be modified.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In regards to kIOHIDTransactionDirectionTypeOutput direction, default element values will be used if element values are not set. If neither are set, that element will be omitted from the commit. After a transaction is committed, transaction element values will be cleared and default values preserved.
    ///
    ///
    /// Synchronously commits element transaction to the device.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be modified.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if
    /// unsuccessful.
    #[doc(alias = "IOHIDTransactionCommit")]
    #[inline]
    pub fn commit(&self) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDTransactionCommit(transaction: &IOHIDTransaction) -> IOReturn;
        }
        unsafe { IOHIDTransactionCommit(self) }
    }

    /// Commits element transaction to the device.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be modified.
    ///
    /// - timeout: Timeout for issuing the transaction.
    ///
    /// - callback: Callback of type IOHIDCallback to be used when transaction has been completed. If null, this method will behave synchronously.
    ///
    /// - context: Pointer to data to be passed to the callback.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// In regards to kIOHIDTransactionDirectionTypeOutput direction, default element values will be used if element values are not set. If neither are set, that element will be omitted from the commit. After a transaction is committed, transaction element values will be cleared and default values preserved.
    ///
    /// **Note:** It is possible for elements from different reports to be present in a given transaction causing a commit to transcend multiple reports. Keep this in mind when setting a appropriate timeout.
    ///
    ///
    /// Asynchronously commits element transaction to the device.
    ///
    /// It is possible for elements from different reports
    /// to be present in a given transaction causing a commit to
    /// transcend multiple reports. Keep this in mind when setting a
    /// appropriate timeout.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be modified.
    ///
    /// Parameter `timeout`: Timeout in milliseconds for the transaction.
    ///
    /// Parameter `callback`: Callback of type IOHIDCallback to be used when
    /// transaction has been completed.  If null, this method will
    /// behave synchronously.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if
    /// unsuccessful.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `context` must be a valid pointer or null.
    #[doc(alias = "IOHIDTransactionCommitWithCallback")]
    #[inline]
    pub unsafe fn commit_with_callback(
        &self,
        timeout: CFTimeInterval,
        callback: IOHIDCallback,
        context: *mut c_void,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDTransactionCommitWithCallback(
                transaction: &IOHIDTransaction,
                timeout: CFTimeInterval,
                callback: IOHIDCallback,
                context: *mut c_void,
            ) -> IOReturn;
        }
        unsafe { IOHIDTransactionCommitWithCallback(self, timeout, callback, context) }
    }

    /// Clears element transaction values.
    ///
    /// Parameters:
    /// - transaction: IOHIDTransaction object to be modified.
    ///
    ///
    /// ## Discussion
    ///
    /// In regards to kIOHIDTransactionDirectionTypeOutput direction, default element values will be preserved.
    ///
    ///
    /// Clears element transaction values.
    ///
    /// In regards to kIOHIDTransactionDirectionTypeOutput direction,
    /// default element values will be preserved.
    ///
    /// Parameter `transaction`: IOHIDTransaction object to be modified.
    #[doc(alias = "IOHIDTransactionClear")]
    #[inline]
    pub fn clear(&self) {
        extern "C-unwind" {
            fn IOHIDTransactionClear(transaction: &IOHIDTransaction);
        }
        unsafe { IOHIDTransactionClear(self) }
    }
}

/// The object you use to access HID devices from user space, returned by version 1.5 of the IOHIDFamily.
///
/// ## Overview
///
/// The functions listed here will work with any version of the IOHIDDeviceDeviceInterface.
///
/// **Note:** Please note that methods declared in this interface follow the copy/get/set conventions.
///
///
/// The object you use to access HID devices from user space, returned by version 1.5 of the IOHIDFamily.
///
/// The functions listed here will work with any version of the IOHIDDeviceDeviceInterface.
///
/// <b>
/// Note:
/// </b>
/// Please note that methods declared in this interface follow the copy/get/set conventions.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDDeviceDeviceInterface {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub open: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub close: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub getProperty: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *const CFString, *mut *const CFType) -> IOReturn,
    >,
    pub setProperty: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *const CFString, *const CFType) -> IOReturn,
    >,
    pub getAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut *const CFType) -> IOReturn>,
    pub copyMatchingElements: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *const CFDictionary,
            *mut *const CFArray,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub setValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDElement,
            *mut IOHIDValue,
            u32,
            IOHIDValueCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub getValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDElement,
            *mut *mut IOHIDValue,
            u32,
            IOHIDValueCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub setInputReportCallback: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut u8,
            CFIndex,
            IOHIDReportCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub setReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *const u8,
            CFIndex,
            u32,
            IOHIDReportCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub getReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *mut u8,
            *mut CFIndex,
            u32,
            IOHIDReportCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDDeviceDeviceInterface {
    const ENCODING: Encoding = Encoding::Struct("IOHIDDeviceDeviceInterface", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFString,*mut *const CFType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFString,*const CFType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *const CFType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFDictionary,*mut *const CFArray,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,*mut IOHIDValue,u32,IOHIDValueCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,*mut *mut IOHIDValue,u32,IOHIDValueCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut u8,CFIndex,IOHIDReportCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*const u8,CFIndex,u32,IOHIDReportCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*mut u8,*mut CFIndex,u32,IOHIDReportCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDDeviceDeviceInterface {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The object you use to access HID devices from user space, returned by version 2.1 of the IOHIDFamily.
///
/// The functions listed here include all of the functions from the IOHIDDeviceDeviceInterface.
///
/// <b>
/// Note:
/// </b>
/// Please note that methods declared in this interface follow the copy/get/set conventions.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDDeviceTimeStampedDeviceInterface {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub open: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub close: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub getProperty: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *const CFString, *mut *const CFType) -> IOReturn,
    >,
    pub setProperty: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *const CFString, *const CFType) -> IOReturn,
    >,
    pub getAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut *const CFType) -> IOReturn>,
    pub copyMatchingElements: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *const CFDictionary,
            *mut *const CFArray,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub setValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDElement,
            *mut IOHIDValue,
            u32,
            IOHIDValueCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub getValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDElement,
            *mut *mut IOHIDValue,
            u32,
            IOHIDValueCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub setInputReportCallback: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut u8,
            CFIndex,
            IOHIDReportCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub setReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *const u8,
            CFIndex,
            u32,
            IOHIDReportCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub getReport: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDReportType,
            u32,
            *mut u8,
            *mut CFIndex,
            u32,
            IOHIDReportCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    pub setInputReportWithTimeStampCallback: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut u8,
            CFIndex,
            IOHIDReportWithTimeStampCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDDeviceTimeStampedDeviceInterface {
    const ENCODING: Encoding = Encoding::Struct("IOHIDDeviceTimeStampedDeviceInterface", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFString,*mut *const CFType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFString,*const CFType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *const CFType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFDictionary,*mut *const CFArray,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,*mut IOHIDValue,u32,IOHIDValueCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,*mut *mut IOHIDValue,u32,IOHIDValueCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut u8,CFIndex,IOHIDReportCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*const u8,CFIndex,u32,IOHIDReportCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDReportType,u32,*mut u8,*mut CFIndex,u32,IOHIDReportCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut u8,CFIndex,IOHIDReportWithTimeStampCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDDeviceTimeStampedDeviceInterface {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The object you use to access a HID queue from user space, returned by version 1.5 of the IOHIDFamily.
///
/// ## Overview
///
/// The functions listed here will work with any version of the IOHIDDeviceQueueInterface. This behavior is useful when you need to keep track of all values of an input element, rather than just the most recent one.
///
/// **Note:**Absolute element values (based on a fixed origin) will only be placed on a queue if there is a change in value.
///
///
/// The object you use to access a HID queue from user space, returned by version 1.5 of the IOHIDFamily.
///
/// The functions listed here will work with any version of the IOHIDDeviceQueueInterface.  This behavior is useful when you
/// need to keep track of all values of an input element, rather than just the most recent one.
/// <br>
/// <b>
/// Note:
/// </b>
/// Absolute element values (based on a fixed origin) will only be placed on a queue if there is a change in value.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDDeviceQueueInterface {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    /// Obtains the event source for this IOHIDDeviceQueueInterface instance.
    ///
    /// The returned event source can be of type CFRunLoopSourceRef or CFRunLoopTimerRef.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceQueueInterface.
    ///
    /// Parameter `pSource`: Pointer to a CFType to return the run loop event source.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub getAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut *const CFType) -> IOReturn>,
    /// Sets the depth for this IOHIDDeviceQueueInterface instance.
    ///
    /// Regardless of element value size, queue will guarantee n=depth elements will be serviced.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `depth`: The maximum number of elements in the queue before the oldest elements in the queue begin to be lost.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub setDepth: Option<unsafe extern "C-unwind" fn(*mut c_void, u32, IOOptionBits) -> IOReturn>,
    /// Obtains the queue depth for this IOHIDDeviceQueueInterface instance.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceQueueInterface.
    ///
    /// Parameter `pDepth`: Pointer to a uint32_t to obtain the number of elements that can be serviced by the queue.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub getDepth: Option<unsafe extern "C-unwind" fn(*mut c_void, *mut u32) -> IOReturn>,
    /// Adds an element to this IOHIDDeviceQueueInterface instance.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceQueueInterface.
    ///
    /// Parameter `element`: IOHIDElementRef referencing the element to be added to the queue.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub addElement: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *mut IOHIDElement, IOOptionBits) -> IOReturn,
    >,
    /// Removes an element from this IOHIDDeviceQueueInterface instance.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceQueueInterface.
    ///
    /// Parameter `element`: IOHIDElementRef referencing the element to be removed from the queue.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub removeElement: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *mut IOHIDElement, IOOptionBits) -> IOReturn,
    >,
    /// Determines whether an element has been added to this IOHIDDeviceQueueInterface instance.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceQueueInterface.
    ///
    /// Parameter `element`: IOHIDElementRef referencing the element to be be found in the queue.
    ///
    /// Parameter `pValue`: Pointer to a Boolean to return whether or not the element was found in the queue.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub containsElement: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDElement,
            *mut Boolean,
            IOOptionBits,
        ) -> IOReturn,
    >,
    /// Starts element value delivery to the queue.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceQueueInterface.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub start: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    /// Stops element value delivery to the queue.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceQueueInterface.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub stop: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    /// Sets callback to be used when the queue transitions to non-empty.
    ///
    /// In order to make use of asynchronous behavior, the event source obtained using getAsyncEventSource
    /// must be added to a run loop.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceQueueInterface.
    ///
    /// Parameter `callback`: Callback of type IOHIDCallback to be used when data is placed on the queue.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub setValueAvailableCallback:
        Option<unsafe extern "C-unwind" fn(*mut c_void, IOHIDCallback, *mut c_void) -> IOReturn>,
    /// Dequeues a retained copy of an element value from the head of an IOHIDDeviceQueueInterface.
    ///
    /// Because the value is a retained copy, it is up to the caller to release the value using CFRelease.
    /// Use with setValueCallback to avoid polling the queue for data.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceQueueInterface.
    ///
    /// Parameter `pValue`: Pointer to a IOHIDValueRef to return the value at the head of the queue.
    ///
    /// Parameter `timeout`: Timeout in milliseconds before aborting an attempt to dequeue a value from the head of a queue.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful, kIOReturnUnderrun if data is unavailble, or a kern_return_t if unsuccessful.
    pub copyNextValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut *mut IOHIDValue,
            u32,
            IOOptionBits,
        ) -> IOReturn,
    >,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDDeviceQueueInterface {
    const ENCODING: Encoding = Encoding::Struct("IOHIDDeviceQueueInterface", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *const CFType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,u32,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut u32,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,*mut Boolean,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDCallback,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *mut IOHIDValue,u32,IOOptionBits,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDDeviceQueueInterface {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The object you use to access a HID transaction from user space, returned by version 1.5 of the IOHIDFamily.
///
/// ## Overview
///
/// The functions listed here will work with any version of the IOHIDDeviceTransactionInterface. This functionality is useful when either setting or getting the values for multiple parsed elements.
///
///
/// The object you use to access a HID transaction from user space, returned by version 1.5 of the IOHIDFamily.
///
/// The functions listed here will work with any version of the IOHIDDeviceTransactionInterface. This functionality
/// is useful when either setting or getting the values for multiple parsed elements.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHIDDeviceTransactionInterface {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    /// Obtains the event source for this IOHIDDeviceTransactionInterface instance.
    ///
    /// The returned event source can be of type CFRunLoopSourceRef or CFRunLoopTimerRef.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `pSource`: Pointer to a CFType to return the run loop event source.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub getAsyncEventSource:
        Option<unsafe extern "C-unwind" fn(*mut c_void, *mut *const CFType) -> IOReturn>,
    /// Sets the direction for this IOHIDDeviceTransactionInterface instance.
    ///
    /// Direction constants are declared in IOHIDTransactionDirectionType.  Changing directions
    /// is useful when dealing with elements of type kIOHIDElementTypeFeature as you use the
    /// transaction to both set and get element values.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `direction`: Transaction direction of type IOHIDTransactionDirectionType.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub setDirection: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOHIDTransactionDirectionType,
            IOOptionBits,
        ) -> IOReturn,
    >,
    /// Obtains the direction for this IOHIDDeviceTransactionInterface instance.
    ///
    /// Direction constants are declared in IOHIDTransactionDirectionType.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `pDirection`: Pointer to a IOHIDTransactionDirectionType to obtain transaction direction.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub getDirection: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *mut IOHIDTransactionDirectionType) -> IOReturn,
    >,
    /// Adds an element to this IOHIDDeviceTransactionInterface instance.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `element`: IOHIDElementRef referencing the element to be added to the transaction.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub addElement: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *mut IOHIDElement, IOOptionBits) -> IOReturn,
    >,
    /// Removes an element from this IOHIDDeviceTransactionInterface instance.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `element`: IOHIDElementRef referencing the element to be removed from the transaction.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub removeElement: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *mut IOHIDElement, IOOptionBits) -> IOReturn,
    >,
    /// Checks whether an element has been added to this IOHIDDeviceTransactionInterface instance.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `element`: IOHIDElementRef referencing the element to be be found in the transaction.
    ///
    /// Parameter `pValue`: Pointer to a Boolean to return whether or not the element was found in the transaction.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub containsElement: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDElement,
            *mut Boolean,
            IOOptionBits,
        ) -> IOReturn,
    >,
    /// Sets the transaction value for an element in this IOHIDDeviceTransactionInterface instance.
    ///
    /// This method is intended for use with transaction of direction kIOHIDTransactionDirectionTypeOutput.
    /// Use the kIOHIDTransactionOptionDefaultOutputValue option to set the default element value.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `element`: IOHIDElementRef referencing the element of interest.
    ///
    /// Parameter `value`: IOHIDValueRef referencing element value to be used in the transaction.
    ///
    /// Parameter `options`: See IOHIDTransactionOption.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub setValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDElement,
            *mut IOHIDValue,
            IOOptionBits,
        ) -> IOReturn,
    >,
    /// Obtains the transaction value for an element in this IOHIDDeviceTransactionInterface instance.
    ///
    /// Use the kIOHIDTransactionOptionDefaultOutputValue option to get the default element value.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `element`: IOHIDElementRef referencing the element of interest.
    ///
    /// Parameter `pValue`: Pointer to an IOHIDValueRef to return the element value of the transaction.
    ///
    /// Parameter `options`: See IOHIDTransactionOption.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub getValue: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *mut IOHIDElement,
            *mut *mut IOHIDValue,
            IOOptionBits,
        ) -> IOReturn,
    >,
    /// Commits element transaction to an IOHIDDevice in this IOHIDDeviceTransactionInterface instance.
    ///
    /// In regards to kIOHIDTransactionDirectionTypeOutput direction, default element values will be used if
    /// element values are not set.  If neither are set, that element will be omitted from the commit. After
    /// a transaction is committed, transaction element values will be cleared and default values preserved.
    /// <br>
    /// <b>
    /// Note:
    /// </b>
    /// It is possible for elements from different reports to be present in a given transaction
    /// causing a commit to transcend multiple reports. Keep this in mind when setting a timeout.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `timeout`: Timeout in milliseconds for issuing the transaction.
    ///
    /// Parameter `callback`: Callback of type IOHIDCallback to be used when transaction has been completed.  If null,
    /// this method will behave synchronously.
    ///
    /// Parameter `context`: Pointer to data to be passed to the callback.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub commit: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            u32,
            IOHIDCallback,
            *mut c_void,
            IOOptionBits,
        ) -> IOReturn,
    >,
    /// Clears element transaction values for an IOHIDDeviceTransactionInterface.
    ///
    /// In regards to kIOHIDTransactionDirectionTypeOutput direction, default element values will be preserved.
    ///
    /// Parameter `self`: Pointer to the IOHIDDeviceTransactionInterface.
    ///
    /// Parameter `options`: Reserved for future use. Ignored in current implementation. Set to zero.
    ///
    /// Returns: Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    pub clear: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDDeviceTransactionInterface {
    const ENCODING: Encoding = Encoding::Struct("IOHIDDeviceTransactionInterface", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut *const CFType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOHIDTransactionDirectionType,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDTransactionDirectionType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,*mut Boolean,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,*mut IOHIDValue,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*mut IOHIDElement,*mut *mut IOHIDValue,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,u32,IOHIDCallback,*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
    ]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDDeviceTransactionInterface {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Keyboard event options passed in to dispatchKeyboardEvent function in
/// IOHIDEventService.
///
/// Field: kIOHIDKeyboardEventOptionsNoKeyRepeat
/// Default behavior for keyboard events is to repeat keys if the key has been
/// held down for a certain amount of time defined in system preferences. Pass
/// in this option to not apply key repeat logic to this event.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDKeyboardEventOptions(pub c_uint);
impl IOHIDKeyboardEventOptions {
    #[doc(alias = "kIOHIDKeyboardEventOptionsNoKeyRepeat")]
    pub const NoKeyRepeat: Self = Self(1 << 8);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDKeyboardEventOptions {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDKeyboardEventOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Pointer event options passed in to dispatch(Relative/Absolute)PointerEvent
/// function in IOHIDEventService.
///
/// Field: kIOHIDPointerEventOptionsNoAcceleration
/// Pointer events are subject to an acceleration algorithm. Pass in this option
/// if you do not wish to have acceleration logic applied to the pointer event.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDPointerEventOptions(pub c_uint);
impl IOHIDPointerEventOptions {
    #[doc(alias = "kIOHIDPointerEventOptionsNoAcceleration")]
    pub const NoAcceleration: Self = Self(1 << 8);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDPointerEventOptions {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDPointerEventOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Scroll event options passed in to dispatchScrollEvent function in
/// IOHIDEventService.
///
/// Field: kIOHIDScrollEventOptionsNoAcceleration
/// Scroll events are subject to an acceleration algorithm. Pass in this option
/// if you do not wish to have acceleration logic applied to the scroll event.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDScrollEventOptions(pub c_uint);
impl IOHIDScrollEventOptions {
    #[doc(alias = "kIOHIDScrollEventOptionsNoAcceleration")]
    pub const NoAcceleration: Self = Self(1 << 8);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDScrollEventOptions {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDScrollEventOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// List of control options  for sensor controls in HID event system
///
/// Options define behavior of HID event system for handling kIOHIDServiceReportIntervalKey & kIOHIDServiceBatchIntervalKey and associated event dispatch to kIOHIDEventSystemClientTypeRateControlled clients
///
///
/// List of control options  for sensor controls in HID event system
///
/// Options define behavior of HID event system for handling kIOHIDServiceReportIntervalKey
/// &
/// kIOHIDServiceBatchIntervalKey and associated event dispatch to kIOHIDEventSystemClientTypeRateControlled clients
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDServiceSensorControlOptions(pub u32);
impl IOHIDServiceSensorControlOptions {
    #[doc(alias = "kIOHIDServiceSensorControlDecimation")]
    pub const Decimation: Self = Self(0x1 << 0);
    #[doc(alias = "kIOHIDServiceSensorControlAggregation")]
    pub const Aggregation: Self = Self(0x1 << 1);
    #[doc(alias = "kIOHIDServiceSensorControlDispatchControl")]
    pub const DispatchControl: Self = Self(0x1 << 2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDServiceSensorControlOptions {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDServiceSensorControlOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[deprecated = "renamed to `IOHIDQueue::new`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueCreate(
    allocator: Option<&CFAllocator>,
    device: &IOHIDDevice,
    depth: CFIndex,
    options: IOOptionBits,
) -> Option<CFRetained<IOHIDQueue>> {
    extern "C-unwind" {
        fn IOHIDQueueCreate(
            allocator: Option<&CFAllocator>,
            device: &IOHIDDevice,
            depth: CFIndex,
            options: IOOptionBits,
        ) -> Option<NonNull<IOHIDQueue>>;
    }
    let ret = unsafe { IOHIDQueueCreate(allocator, device, depth, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDQueue::device`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueGetDevice(queue: &IOHIDQueue) -> CFRetained<IOHIDDevice> {
    extern "C-unwind" {
        fn IOHIDQueueGetDevice(queue: &IOHIDQueue) -> Option<NonNull<IOHIDDevice>>;
    }
    let ret = unsafe { IOHIDQueueGetDevice(queue) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

#[deprecated = "renamed to `IOHIDQueue::depth`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueGetDepth(queue: &IOHIDQueue) -> CFIndex {
    extern "C-unwind" {
        fn IOHIDQueueGetDepth(queue: &IOHIDQueue) -> CFIndex;
    }
    unsafe { IOHIDQueueGetDepth(queue) }
}

#[deprecated = "renamed to `IOHIDQueue::set_depth`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueSetDepth(queue: &IOHIDQueue, depth: CFIndex) {
    extern "C-unwind" {
        fn IOHIDQueueSetDepth(queue: &IOHIDQueue, depth: CFIndex);
    }
    unsafe { IOHIDQueueSetDepth(queue, depth) }
}

#[deprecated = "renamed to `IOHIDQueue::add_element`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueAddElement(queue: &IOHIDQueue, element: &IOHIDElement) {
    extern "C-unwind" {
        fn IOHIDQueueAddElement(queue: &IOHIDQueue, element: &IOHIDElement);
    }
    unsafe { IOHIDQueueAddElement(queue, element) }
}

#[deprecated = "renamed to `IOHIDQueue::remove_element`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueRemoveElement(queue: &IOHIDQueue, element: &IOHIDElement) {
    extern "C-unwind" {
        fn IOHIDQueueRemoveElement(queue: &IOHIDQueue, element: &IOHIDElement);
    }
    unsafe { IOHIDQueueRemoveElement(queue, element) }
}

#[deprecated = "renamed to `IOHIDQueue::contains_element`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueContainsElement(
    queue: &IOHIDQueue,
    element: &IOHIDElement,
) -> bool {
    extern "C-unwind" {
        fn IOHIDQueueContainsElement(queue: &IOHIDQueue, element: &IOHIDElement) -> Boolean;
    }
    let ret = unsafe { IOHIDQueueContainsElement(queue, element) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDQueue::start`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueStart(queue: &IOHIDQueue) {
    extern "C-unwind" {
        fn IOHIDQueueStart(queue: &IOHIDQueue);
    }
    unsafe { IOHIDQueueStart(queue) }
}

#[deprecated = "renamed to `IOHIDQueue::stop`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueStop(queue: &IOHIDQueue) {
    extern "C-unwind" {
        fn IOHIDQueueStop(queue: &IOHIDQueue);
    }
    unsafe { IOHIDQueueStop(queue) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDQueue::schedule_with_run_loop`"]
    pub fn IOHIDQueueScheduleWithRunLoop(
        queue: &IOHIDQueue,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDQueue::unschedule_from_run_loop`"]
    pub fn IOHIDQueueUnscheduleFromRunLoop(
        queue: &IOHIDQueue,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `IOHIDQueue::set_dispatch_queue`"]
    pub fn IOHIDQueueSetDispatchQueue(queue: &IOHIDQueue, dispatch_queue: &DispatchQueue);
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `IOHIDQueue::set_cancel_handler`"]
    pub fn IOHIDQueueSetCancelHandler(queue: &IOHIDQueue, handler: dispatch_block_t);
}

#[deprecated = "renamed to `IOHIDQueue::activate`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueActivate(queue: &IOHIDQueue) {
    extern "C-unwind" {
        fn IOHIDQueueActivate(queue: &IOHIDQueue);
    }
    unsafe { IOHIDQueueActivate(queue) }
}

#[deprecated = "renamed to `IOHIDQueue::cancel`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueCancel(queue: &IOHIDQueue) {
    extern "C-unwind" {
        fn IOHIDQueueCancel(queue: &IOHIDQueue);
    }
    unsafe { IOHIDQueueCancel(queue) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDQueue::register_value_available_callback`"]
    pub fn IOHIDQueueRegisterValueAvailableCallback(
        queue: &IOHIDQueue,
        callback: IOHIDCallback,
        context: *mut c_void,
    );
}

#[deprecated = "renamed to `IOHIDQueue::next_value`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueCopyNextValue(
    queue: &IOHIDQueue,
) -> Option<CFRetained<IOHIDValue>> {
    extern "C-unwind" {
        fn IOHIDQueueCopyNextValue(queue: &IOHIDQueue) -> Option<NonNull<IOHIDValue>>;
    }
    let ret = unsafe { IOHIDQueueCopyNextValue(queue) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDQueue::next_value_with_timeout`"]
#[inline]
pub extern "C-unwind" fn IOHIDQueueCopyNextValueWithTimeout(
    queue: &IOHIDQueue,
    timeout: CFTimeInterval,
) -> Option<CFRetained<IOHIDValue>> {
    extern "C-unwind" {
        fn IOHIDQueueCopyNextValueWithTimeout(
            queue: &IOHIDQueue,
            timeout: CFTimeInterval,
        ) -> Option<NonNull<IOHIDValue>>;
    }
    let ret = unsafe { IOHIDQueueCopyNextValueWithTimeout(queue, timeout) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `IOHIDDevice::new`"]
#[inline]
pub extern "C-unwind" fn IOHIDDeviceCreate(
    allocator: Option<&CFAllocator>,
    service: io_service_t,
) -> Option<CFRetained<IOHIDDevice>> {
    extern "C-unwind" {
        fn IOHIDDeviceCreate(
            allocator: Option<&CFAllocator>,
            service: io_service_t,
        ) -> Option<NonNull<IOHIDDevice>>;
    }
    let ret = unsafe { IOHIDDeviceCreate(allocator, service) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `IOHIDDevice::service`"]
#[inline]
pub extern "C-unwind" fn IOHIDDeviceGetService(device: &IOHIDDevice) -> io_service_t {
    extern "C-unwind" {
        fn IOHIDDeviceGetService(device: &IOHIDDevice) -> io_service_t;
    }
    unsafe { IOHIDDeviceGetService(device) }
}

#[deprecated = "renamed to `IOHIDDevice::open`"]
#[inline]
pub extern "C-unwind" fn IOHIDDeviceOpen(device: &IOHIDDevice, options: IOOptionBits) -> IOReturn {
    extern "C-unwind" {
        fn IOHIDDeviceOpen(device: &IOHIDDevice, options: IOOptionBits) -> IOReturn;
    }
    unsafe { IOHIDDeviceOpen(device, options) }
}

#[deprecated = "renamed to `IOHIDDevice::close`"]
#[inline]
pub extern "C-unwind" fn IOHIDDeviceClose(device: &IOHIDDevice, options: IOOptionBits) -> IOReturn {
    extern "C-unwind" {
        fn IOHIDDeviceClose(device: &IOHIDDevice, options: IOOptionBits) -> IOReturn;
    }
    unsafe { IOHIDDeviceClose(device, options) }
}

#[deprecated = "renamed to `IOHIDDevice::conforms_to`"]
#[inline]
pub extern "C-unwind" fn IOHIDDeviceConformsTo(
    device: &IOHIDDevice,
    usage_page: u32,
    usage: u32,
) -> bool {
    extern "C-unwind" {
        fn IOHIDDeviceConformsTo(device: &IOHIDDevice, usage_page: u32, usage: u32) -> Boolean;
    }
    let ret = unsafe { IOHIDDeviceConformsTo(device, usage_page, usage) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDDevice::property`"]
#[inline]
pub extern "C-unwind" fn IOHIDDeviceGetProperty(
    device: &IOHIDDevice,
    key: &CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOHIDDeviceGetProperty(device: &IOHIDDevice, key: &CFString) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOHIDDeviceGetProperty(device, key) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `IOHIDDevice::set_property`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDDeviceSetProperty(
    device: &IOHIDDevice,
    key: &CFString,
    property: &CFType,
) -> bool {
    extern "C-unwind" {
        fn IOHIDDeviceSetProperty(
            device: &IOHIDDevice,
            key: &CFString,
            property: &CFType,
        ) -> Boolean;
    }
    let ret = unsafe { IOHIDDeviceSetProperty(device, key, property) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDDevice::matching_elements`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDDeviceCopyMatchingElements(
    device: &IOHIDDevice,
    matching: Option<&CFDictionary>,
    options: IOOptionBits,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn IOHIDDeviceCopyMatchingElements(
            device: &IOHIDDevice,
            matching: Option<&CFDictionary>,
            options: IOOptionBits,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { IOHIDDeviceCopyMatchingElements(device, matching, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::schedule_with_run_loop`"]
    pub fn IOHIDDeviceScheduleWithRunLoop(
        device: &IOHIDDevice,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::unschedule_from_run_loop`"]
    pub fn IOHIDDeviceUnscheduleFromRunLoop(
        device: &IOHIDDevice,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `IOHIDDevice::set_dispatch_queue`"]
    pub fn IOHIDDeviceSetDispatchQueue(device: &IOHIDDevice, queue: &DispatchQueue);
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `IOHIDDevice::set_cancel_handler`"]
    pub fn IOHIDDeviceSetCancelHandler(device: &IOHIDDevice, handler: dispatch_block_t);
}

#[deprecated = "renamed to `IOHIDDevice::activate`"]
#[inline]
pub extern "C-unwind" fn IOHIDDeviceActivate(device: &IOHIDDevice) {
    extern "C-unwind" {
        fn IOHIDDeviceActivate(device: &IOHIDDevice);
    }
    unsafe { IOHIDDeviceActivate(device) }
}

#[deprecated = "renamed to `IOHIDDevice::cancel`"]
#[inline]
pub extern "C-unwind" fn IOHIDDeviceCancel(device: &IOHIDDevice) {
    extern "C-unwind" {
        fn IOHIDDeviceCancel(device: &IOHIDDevice);
    }
    unsafe { IOHIDDeviceCancel(device) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::register_removal_callback`"]
    pub fn IOHIDDeviceRegisterRemovalCallback(
        device: &IOHIDDevice,
        callback: IOHIDCallback,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::register_input_value_callback`"]
    pub fn IOHIDDeviceRegisterInputValueCallback(
        device: &IOHIDDevice,
        callback: IOHIDValueCallback,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::register_input_report_callback`"]
    pub fn IOHIDDeviceRegisterInputReportCallback(
        device: &IOHIDDevice,
        report: NonNull<u8>,
        report_length: CFIndex,
        callback: IOHIDReportCallback,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::register_input_report_with_time_stamp_callback`"]
    pub fn IOHIDDeviceRegisterInputReportWithTimeStampCallback(
        device: &IOHIDDevice,
        report: NonNull<u8>,
        report_length: CFIndex,
        callback: IOHIDReportWithTimeStampCallback,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::set_input_value_matching`"]
    pub fn IOHIDDeviceSetInputValueMatching(device: &IOHIDDevice, matching: Option<&CFDictionary>);
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::set_input_value_matching_multiple`"]
    pub fn IOHIDDeviceSetInputValueMatchingMultiple(
        device: &IOHIDDevice,
        multiple: Option<&CFArray>,
    );
}

#[deprecated = "renamed to `IOHIDDevice::set_value`"]
#[inline]
pub extern "C-unwind" fn IOHIDDeviceSetValue(
    device: &IOHIDDevice,
    element: &IOHIDElement,
    value: &IOHIDValue,
) -> IOReturn {
    extern "C-unwind" {
        fn IOHIDDeviceSetValue(
            device: &IOHIDDevice,
            element: &IOHIDElement,
            value: &IOHIDValue,
        ) -> IOReturn;
    }
    unsafe { IOHIDDeviceSetValue(device, element, value) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::set_value_multiple`"]
    pub fn IOHIDDeviceSetValueMultiple(device: &IOHIDDevice, multiple: &CFDictionary) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::set_value_with_callback`"]
    pub fn IOHIDDeviceSetValueWithCallback(
        device: &IOHIDDevice,
        element: &IOHIDElement,
        value: &IOHIDValue,
        timeout: CFTimeInterval,
        callback: IOHIDValueCallback,
        context: *mut c_void,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::set_value_multiple_with_callback`"]
    pub fn IOHIDDeviceSetValueMultipleWithCallback(
        device: &IOHIDDevice,
        multiple: &CFDictionary,
        timeout: CFTimeInterval,
        callback: IOHIDValueMultipleCallback,
        context: *mut c_void,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::value`"]
    pub fn IOHIDDeviceGetValue(
        device: &IOHIDDevice,
        element: &IOHIDElement,
        p_value: NonNull<NonNull<IOHIDValue>>,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::value_with_options`"]
    pub fn IOHIDDeviceGetValueWithOptions(
        device: &IOHIDDevice,
        element: &IOHIDElement,
        p_value: NonNull<NonNull<IOHIDValue>>,
        options: u32,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::copy_value_multiple`"]
    pub fn IOHIDDeviceCopyValueMultiple(
        device: &IOHIDDevice,
        elements: &CFArray,
        p_multiple: *mut *const CFDictionary,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::value_with_callback`"]
    pub fn IOHIDDeviceGetValueWithCallback(
        device: &IOHIDDevice,
        element: &IOHIDElement,
        p_value: NonNull<NonNull<IOHIDValue>>,
        timeout: CFTimeInterval,
        callback: IOHIDValueCallback,
        context: *mut c_void,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::copy_value_multiple_with_callback`"]
    pub fn IOHIDDeviceCopyValueMultipleWithCallback(
        device: &IOHIDDevice,
        elements: &CFArray,
        p_multiple: *mut *const CFDictionary,
        timeout: CFTimeInterval,
        callback: IOHIDValueMultipleCallback,
        context: *mut c_void,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::set_report`"]
    pub fn IOHIDDeviceSetReport(
        device: &IOHIDDevice,
        report_type: IOHIDReportType,
        report_id: CFIndex,
        report: NonNull<u8>,
        report_length: CFIndex,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::set_report_with_callback`"]
    pub fn IOHIDDeviceSetReportWithCallback(
        device: &IOHIDDevice,
        report_type: IOHIDReportType,
        report_id: CFIndex,
        report: NonNull<u8>,
        report_length: CFIndex,
        timeout: CFTimeInterval,
        callback: IOHIDReportCallback,
        context: *mut c_void,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::report`"]
    pub fn IOHIDDeviceGetReport(
        device: &IOHIDDevice,
        report_type: IOHIDReportType,
        report_id: CFIndex,
        report: NonNull<u8>,
        p_report_length: NonNull<CFIndex>,
    ) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDDevice::report_with_callback`"]
    pub fn IOHIDDeviceGetReportWithCallback(
        device: &IOHIDDevice,
        report_type: IOHIDReportType,
        report_id: CFIndex,
        report: NonNull<u8>,
        p_report_length: NonNull<CFIndex>,
        timeout: CFTimeInterval,
        callback: IOHIDReportCallback,
        context: NonNull<c_void>,
    ) -> IOReturn;
}

#[deprecated = "renamed to `IOHIDElement::with_dictionary`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDElementCreateWithDictionary(
    allocator: Option<&CFAllocator>,
    dictionary: &CFDictionary,
) -> CFRetained<IOHIDElement> {
    extern "C-unwind" {
        fn IOHIDElementCreateWithDictionary(
            allocator: Option<&CFAllocator>,
            dictionary: &CFDictionary,
        ) -> Option<NonNull<IOHIDElement>>;
    }
    let ret = unsafe { IOHIDElementCreateWithDictionary(allocator, dictionary) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `IOHIDElement::device`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetDevice(element: &IOHIDElement) -> CFRetained<IOHIDDevice> {
    extern "C-unwind" {
        fn IOHIDElementGetDevice(element: &IOHIDElement) -> Option<NonNull<IOHIDDevice>>;
    }
    let ret = unsafe { IOHIDElementGetDevice(element) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

#[deprecated = "renamed to `IOHIDElement::parent`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetParent(
    element: &IOHIDElement,
) -> Option<CFRetained<IOHIDElement>> {
    extern "C-unwind" {
        fn IOHIDElementGetParent(element: &IOHIDElement) -> Option<NonNull<IOHIDElement>>;
    }
    let ret = unsafe { IOHIDElementGetParent(element) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `IOHIDElement::children`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetChildren(
    element: &IOHIDElement,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn IOHIDElementGetChildren(element: &IOHIDElement) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { IOHIDElementGetChildren(element) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `IOHIDElement::attach`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementAttach(element: &IOHIDElement, to_attach: &IOHIDElement) {
    extern "C-unwind" {
        fn IOHIDElementAttach(element: &IOHIDElement, to_attach: &IOHIDElement);
    }
    unsafe { IOHIDElementAttach(element, to_attach) }
}

#[deprecated = "renamed to `IOHIDElement::detach`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementDetach(element: &IOHIDElement, to_detach: &IOHIDElement) {
    extern "C-unwind" {
        fn IOHIDElementDetach(element: &IOHIDElement, to_detach: &IOHIDElement);
    }
    unsafe { IOHIDElementDetach(element, to_detach) }
}

#[deprecated = "renamed to `IOHIDElement::attached`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementCopyAttached(
    element: &IOHIDElement,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn IOHIDElementCopyAttached(element: &IOHIDElement) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { IOHIDElementCopyAttached(element) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDElement::cookie`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetCookie(element: &IOHIDElement) -> IOHIDElementCookie {
    extern "C-unwind" {
        fn IOHIDElementGetCookie(element: &IOHIDElement) -> IOHIDElementCookie;
    }
    unsafe { IOHIDElementGetCookie(element) }
}

#[deprecated = "renamed to `IOHIDElement::type`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetType(element: &IOHIDElement) -> IOHIDElementType {
    extern "C-unwind" {
        fn IOHIDElementGetType(element: &IOHIDElement) -> IOHIDElementType;
    }
    unsafe { IOHIDElementGetType(element) }
}

#[deprecated = "renamed to `IOHIDElement::collection_type`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetCollectionType(
    element: &IOHIDElement,
) -> IOHIDElementCollectionType {
    extern "C-unwind" {
        fn IOHIDElementGetCollectionType(element: &IOHIDElement) -> IOHIDElementCollectionType;
    }
    unsafe { IOHIDElementGetCollectionType(element) }
}

#[deprecated = "renamed to `IOHIDElement::usage_page`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetUsagePage(element: &IOHIDElement) -> u32 {
    extern "C-unwind" {
        fn IOHIDElementGetUsagePage(element: &IOHIDElement) -> u32;
    }
    unsafe { IOHIDElementGetUsagePage(element) }
}

#[deprecated = "renamed to `IOHIDElement::usage`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetUsage(element: &IOHIDElement) -> u32 {
    extern "C-unwind" {
        fn IOHIDElementGetUsage(element: &IOHIDElement) -> u32;
    }
    unsafe { IOHIDElementGetUsage(element) }
}

#[deprecated = "renamed to `IOHIDElement::is_virtual`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementIsVirtual(element: &IOHIDElement) -> bool {
    extern "C-unwind" {
        fn IOHIDElementIsVirtual(element: &IOHIDElement) -> Boolean;
    }
    let ret = unsafe { IOHIDElementIsVirtual(element) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDElement::is_relative`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementIsRelative(element: &IOHIDElement) -> bool {
    extern "C-unwind" {
        fn IOHIDElementIsRelative(element: &IOHIDElement) -> Boolean;
    }
    let ret = unsafe { IOHIDElementIsRelative(element) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDElement::is_wrapping`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementIsWrapping(element: &IOHIDElement) -> bool {
    extern "C-unwind" {
        fn IOHIDElementIsWrapping(element: &IOHIDElement) -> Boolean;
    }
    let ret = unsafe { IOHIDElementIsWrapping(element) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDElement::is_array`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementIsArray(element: &IOHIDElement) -> bool {
    extern "C-unwind" {
        fn IOHIDElementIsArray(element: &IOHIDElement) -> Boolean;
    }
    let ret = unsafe { IOHIDElementIsArray(element) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDElement::is_non_linear`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementIsNonLinear(element: &IOHIDElement) -> bool {
    extern "C-unwind" {
        fn IOHIDElementIsNonLinear(element: &IOHIDElement) -> Boolean;
    }
    let ret = unsafe { IOHIDElementIsNonLinear(element) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDElement::has_preferred_state`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementHasPreferredState(element: &IOHIDElement) -> bool {
    extern "C-unwind" {
        fn IOHIDElementHasPreferredState(element: &IOHIDElement) -> Boolean;
    }
    let ret = unsafe { IOHIDElementHasPreferredState(element) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDElement::has_null_state`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementHasNullState(element: &IOHIDElement) -> bool {
    extern "C-unwind" {
        fn IOHIDElementHasNullState(element: &IOHIDElement) -> Boolean;
    }
    let ret = unsafe { IOHIDElementHasNullState(element) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDElement::name`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetName(element: &IOHIDElement) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn IOHIDElementGetName(element: &IOHIDElement) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { IOHIDElementGetName(element) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

#[deprecated = "renamed to `IOHIDElement::report_id`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetReportID(element: &IOHIDElement) -> u32 {
    extern "C-unwind" {
        fn IOHIDElementGetReportID(element: &IOHIDElement) -> u32;
    }
    unsafe { IOHIDElementGetReportID(element) }
}

#[deprecated = "renamed to `IOHIDElement::report_size`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetReportSize(element: &IOHIDElement) -> u32 {
    extern "C-unwind" {
        fn IOHIDElementGetReportSize(element: &IOHIDElement) -> u32;
    }
    unsafe { IOHIDElementGetReportSize(element) }
}

#[deprecated = "renamed to `IOHIDElement::report_count`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetReportCount(element: &IOHIDElement) -> u32 {
    extern "C-unwind" {
        fn IOHIDElementGetReportCount(element: &IOHIDElement) -> u32;
    }
    unsafe { IOHIDElementGetReportCount(element) }
}

#[deprecated = "renamed to `IOHIDElement::unit`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetUnit(element: &IOHIDElement) -> u32 {
    extern "C-unwind" {
        fn IOHIDElementGetUnit(element: &IOHIDElement) -> u32;
    }
    unsafe { IOHIDElementGetUnit(element) }
}

#[deprecated = "renamed to `IOHIDElement::unit_exponent`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetUnitExponent(element: &IOHIDElement) -> u32 {
    extern "C-unwind" {
        fn IOHIDElementGetUnitExponent(element: &IOHIDElement) -> u32;
    }
    unsafe { IOHIDElementGetUnitExponent(element) }
}

#[deprecated = "renamed to `IOHIDElement::logical_min`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetLogicalMin(element: &IOHIDElement) -> CFIndex {
    extern "C-unwind" {
        fn IOHIDElementGetLogicalMin(element: &IOHIDElement) -> CFIndex;
    }
    unsafe { IOHIDElementGetLogicalMin(element) }
}

#[deprecated = "renamed to `IOHIDElement::logical_max`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetLogicalMax(element: &IOHIDElement) -> CFIndex {
    extern "C-unwind" {
        fn IOHIDElementGetLogicalMax(element: &IOHIDElement) -> CFIndex;
    }
    unsafe { IOHIDElementGetLogicalMax(element) }
}

#[deprecated = "renamed to `IOHIDElement::physical_min`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetPhysicalMin(element: &IOHIDElement) -> CFIndex {
    extern "C-unwind" {
        fn IOHIDElementGetPhysicalMin(element: &IOHIDElement) -> CFIndex;
    }
    unsafe { IOHIDElementGetPhysicalMin(element) }
}

#[deprecated = "renamed to `IOHIDElement::physical_max`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetPhysicalMax(element: &IOHIDElement) -> CFIndex {
    extern "C-unwind" {
        fn IOHIDElementGetPhysicalMax(element: &IOHIDElement) -> CFIndex;
    }
    unsafe { IOHIDElementGetPhysicalMax(element) }
}

#[deprecated = "renamed to `IOHIDElement::property`"]
#[inline]
pub extern "C-unwind" fn IOHIDElementGetProperty(
    element: &IOHIDElement,
    key: &CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOHIDElementGetProperty(
            element: &IOHIDElement,
            key: &CFString,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOHIDElementGetProperty(element, key) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `IOHIDElement::set_property`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDElementSetProperty(
    element: &IOHIDElement,
    key: &CFString,
    property: &CFType,
) -> bool {
    extern "C-unwind" {
        fn IOHIDElementSetProperty(
            element: &IOHIDElement,
            key: &CFString,
            property: &CFType,
        ) -> Boolean;
    }
    let ret = unsafe { IOHIDElementSetProperty(element, key, property) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDManager::new`"]
#[inline]
pub extern "C-unwind" fn IOHIDManagerCreate(
    allocator: Option<&CFAllocator>,
    options: IOOptionBits,
) -> CFRetained<IOHIDManager> {
    extern "C-unwind" {
        fn IOHIDManagerCreate(
            allocator: Option<&CFAllocator>,
            options: IOOptionBits,
        ) -> Option<NonNull<IOHIDManager>>;
    }
    let ret = unsafe { IOHIDManagerCreate(allocator, options) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `IOHIDManager::open`"]
#[inline]
pub extern "C-unwind" fn IOHIDManagerOpen(
    manager: &IOHIDManager,
    options: IOOptionBits,
) -> IOReturn {
    extern "C-unwind" {
        fn IOHIDManagerOpen(manager: &IOHIDManager, options: IOOptionBits) -> IOReturn;
    }
    unsafe { IOHIDManagerOpen(manager, options) }
}

#[deprecated = "renamed to `IOHIDManager::close`"]
#[inline]
pub extern "C-unwind" fn IOHIDManagerClose(
    manager: &IOHIDManager,
    options: IOOptionBits,
) -> IOReturn {
    extern "C-unwind" {
        fn IOHIDManagerClose(manager: &IOHIDManager, options: IOOptionBits) -> IOReturn;
    }
    unsafe { IOHIDManagerClose(manager, options) }
}

#[deprecated = "renamed to `IOHIDManager::property`"]
#[inline]
pub extern "C-unwind" fn IOHIDManagerGetProperty(
    manager: &IOHIDManager,
    key: &CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOHIDManagerGetProperty(
            manager: &IOHIDManager,
            key: &CFString,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOHIDManagerGetProperty(manager, key) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `IOHIDManager::set_property`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDManagerSetProperty(
    manager: &IOHIDManager,
    key: &CFString,
    value: &CFType,
) -> bool {
    extern "C-unwind" {
        fn IOHIDManagerSetProperty(
            manager: &IOHIDManager,
            key: &CFString,
            value: &CFType,
        ) -> Boolean;
    }
    let ret = unsafe { IOHIDManagerSetProperty(manager, key, value) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::schedule_with_run_loop`"]
    pub fn IOHIDManagerScheduleWithRunLoop(
        manager: &IOHIDManager,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::unschedule_from_run_loop`"]
    pub fn IOHIDManagerUnscheduleFromRunLoop(
        manager: &IOHIDManager,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `IOHIDManager::set_dispatch_queue`"]
    pub fn IOHIDManagerSetDispatchQueue(manager: &IOHIDManager, queue: &DispatchQueue);
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `IOHIDManager::set_cancel_handler`"]
    pub fn IOHIDManagerSetCancelHandler(manager: &IOHIDManager, handler: dispatch_block_t);
}

#[deprecated = "renamed to `IOHIDManager::activate`"]
#[inline]
pub extern "C-unwind" fn IOHIDManagerActivate(manager: &IOHIDManager) {
    extern "C-unwind" {
        fn IOHIDManagerActivate(manager: &IOHIDManager);
    }
    unsafe { IOHIDManagerActivate(manager) }
}

#[deprecated = "renamed to `IOHIDManager::cancel`"]
#[inline]
pub extern "C-unwind" fn IOHIDManagerCancel(manager: &IOHIDManager) {
    extern "C-unwind" {
        fn IOHIDManagerCancel(manager: &IOHIDManager);
    }
    unsafe { IOHIDManagerCancel(manager) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::set_device_matching`"]
    pub fn IOHIDManagerSetDeviceMatching(manager: &IOHIDManager, matching: Option<&CFDictionary>);
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::set_device_matching_multiple`"]
    pub fn IOHIDManagerSetDeviceMatchingMultiple(
        manager: &IOHIDManager,
        multiple: Option<&CFArray>,
    );
}

#[deprecated = "renamed to `IOHIDManager::devices`"]
#[inline]
pub extern "C-unwind" fn IOHIDManagerCopyDevices(
    manager: &IOHIDManager,
) -> Option<CFRetained<CFSet>> {
    extern "C-unwind" {
        fn IOHIDManagerCopyDevices(manager: &IOHIDManager) -> Option<NonNull<CFSet>>;
    }
    let ret = unsafe { IOHIDManagerCopyDevices(manager) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::register_device_matching_callback`"]
    pub fn IOHIDManagerRegisterDeviceMatchingCallback(
        manager: &IOHIDManager,
        callback: IOHIDDeviceCallback,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::register_device_removal_callback`"]
    pub fn IOHIDManagerRegisterDeviceRemovalCallback(
        manager: &IOHIDManager,
        callback: IOHIDDeviceCallback,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::register_input_report_callback`"]
    pub fn IOHIDManagerRegisterInputReportCallback(
        manager: &IOHIDManager,
        callback: IOHIDReportCallback,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::register_input_report_with_time_stamp_callback`"]
    pub fn IOHIDManagerRegisterInputReportWithTimeStampCallback(
        manager: &IOHIDManager,
        callback: IOHIDReportWithTimeStampCallback,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::register_input_value_callback`"]
    pub fn IOHIDManagerRegisterInputValueCallback(
        manager: &IOHIDManager,
        callback: IOHIDValueCallback,
        context: *mut c_void,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::set_input_value_matching`"]
    pub fn IOHIDManagerSetInputValueMatching(
        manager: &IOHIDManager,
        matching: Option<&CFDictionary>,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDManager::set_input_value_matching_multiple`"]
    pub fn IOHIDManagerSetInputValueMatchingMultiple(
        manager: &IOHIDManager,
        multiple: Option<&CFArray>,
    );
}

#[deprecated = "renamed to `IOHIDManager::save_to_property_domain`"]
#[inline]
pub extern "C-unwind" fn IOHIDManagerSaveToPropertyDomain(
    manager: &IOHIDManager,
    application_id: &CFString,
    user_name: &CFString,
    host_name: &CFString,
    options: IOOptionBits,
) {
    extern "C-unwind" {
        fn IOHIDManagerSaveToPropertyDomain(
            manager: &IOHIDManager,
            application_id: &CFString,
            user_name: &CFString,
            host_name: &CFString,
            options: IOOptionBits,
        );
    }
    unsafe {
        IOHIDManagerSaveToPropertyDomain(manager, application_id, user_name, host_name, options)
    }
}

#[deprecated = "renamed to `IOHIDValue::with_integer_value`"]
#[inline]
pub extern "C-unwind" fn IOHIDValueCreateWithIntegerValue(
    allocator: Option<&CFAllocator>,
    element: &IOHIDElement,
    time_stamp: u64,
    value: CFIndex,
) -> CFRetained<IOHIDValue> {
    extern "C-unwind" {
        fn IOHIDValueCreateWithIntegerValue(
            allocator: Option<&CFAllocator>,
            element: &IOHIDElement,
            time_stamp: u64,
            value: CFIndex,
        ) -> Option<NonNull<IOHIDValue>>;
    }
    let ret = unsafe { IOHIDValueCreateWithIntegerValue(allocator, element, time_stamp, value) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `IOHIDValue::with_bytes`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDValueCreateWithBytes(
    allocator: Option<&CFAllocator>,
    element: &IOHIDElement,
    time_stamp: u64,
    bytes: NonNull<u8>,
    length: CFIndex,
) -> Option<CFRetained<IOHIDValue>> {
    extern "C-unwind" {
        fn IOHIDValueCreateWithBytes(
            allocator: Option<&CFAllocator>,
            element: &IOHIDElement,
            time_stamp: u64,
            bytes: NonNull<u8>,
            length: CFIndex,
        ) -> Option<NonNull<IOHIDValue>>;
    }
    let ret = unsafe { IOHIDValueCreateWithBytes(allocator, element, time_stamp, bytes, length) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDValue::with_bytes_no_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDValueCreateWithBytesNoCopy(
    allocator: Option<&CFAllocator>,
    element: &IOHIDElement,
    time_stamp: u64,
    bytes: NonNull<u8>,
    length: CFIndex,
) -> Option<CFRetained<IOHIDValue>> {
    extern "C-unwind" {
        fn IOHIDValueCreateWithBytesNoCopy(
            allocator: Option<&CFAllocator>,
            element: &IOHIDElement,
            time_stamp: u64,
            bytes: NonNull<u8>,
            length: CFIndex,
        ) -> Option<NonNull<IOHIDValue>>;
    }
    let ret =
        unsafe { IOHIDValueCreateWithBytesNoCopy(allocator, element, time_stamp, bytes, length) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDValue::element`"]
#[inline]
pub extern "C-unwind" fn IOHIDValueGetElement(value: &IOHIDValue) -> CFRetained<IOHIDElement> {
    extern "C-unwind" {
        fn IOHIDValueGetElement(value: &IOHIDValue) -> Option<NonNull<IOHIDElement>>;
    }
    let ret = unsafe { IOHIDValueGetElement(value) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

#[deprecated = "renamed to `IOHIDValue::time_stamp`"]
#[inline]
pub extern "C-unwind" fn IOHIDValueGetTimeStamp(value: &IOHIDValue) -> u64 {
    extern "C-unwind" {
        fn IOHIDValueGetTimeStamp(value: &IOHIDValue) -> u64;
    }
    unsafe { IOHIDValueGetTimeStamp(value) }
}

#[deprecated = "renamed to `IOHIDValue::length`"]
#[inline]
pub extern "C-unwind" fn IOHIDValueGetLength(value: &IOHIDValue) -> CFIndex {
    extern "C-unwind" {
        fn IOHIDValueGetLength(value: &IOHIDValue) -> CFIndex;
    }
    unsafe { IOHIDValueGetLength(value) }
}

#[deprecated = "renamed to `IOHIDValue::byte_ptr`"]
#[inline]
pub extern "C-unwind" fn IOHIDValueGetBytePtr(value: &IOHIDValue) -> NonNull<u8> {
    extern "C-unwind" {
        fn IOHIDValueGetBytePtr(value: &IOHIDValue) -> Option<NonNull<u8>>;
    }
    let ret = unsafe { IOHIDValueGetBytePtr(value) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `IOHIDValue::integer_value`"]
#[inline]
pub extern "C-unwind" fn IOHIDValueGetIntegerValue(value: &IOHIDValue) -> CFIndex {
    extern "C-unwind" {
        fn IOHIDValueGetIntegerValue(value: &IOHIDValue) -> CFIndex;
    }
    unsafe { IOHIDValueGetIntegerValue(value) }
}

#[deprecated = "renamed to `IOHIDValue::scaled_value`"]
#[inline]
pub extern "C-unwind" fn IOHIDValueGetScaledValue(
    value: &IOHIDValue,
    r#type: IOHIDValueScaleType,
) -> c_double {
    extern "C-unwind" {
        fn IOHIDValueGetScaledValue(value: &IOHIDValue, r#type: IOHIDValueScaleType) -> c_double;
    }
    unsafe { IOHIDValueGetScaledValue(value, r#type) }
}

#[deprecated = "renamed to `IOHIDTransaction::new`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionCreate(
    allocator: Option<&CFAllocator>,
    device: &IOHIDDevice,
    direction: IOHIDTransactionDirectionType,
    options: IOOptionBits,
) -> Option<CFRetained<IOHIDTransaction>> {
    extern "C-unwind" {
        fn IOHIDTransactionCreate(
            allocator: Option<&CFAllocator>,
            device: &IOHIDDevice,
            direction: IOHIDTransactionDirectionType,
            options: IOOptionBits,
        ) -> Option<NonNull<IOHIDTransaction>>;
    }
    let ret = unsafe { IOHIDTransactionCreate(allocator, device, direction, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDTransaction::device`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionGetDevice(
    transaction: &IOHIDTransaction,
) -> CFRetained<IOHIDDevice> {
    extern "C-unwind" {
        fn IOHIDTransactionGetDevice(
            transaction: &IOHIDTransaction,
        ) -> Option<NonNull<IOHIDDevice>>;
    }
    let ret = unsafe { IOHIDTransactionGetDevice(transaction) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

#[deprecated = "renamed to `IOHIDTransaction::direction`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionGetDirection(
    transaction: &IOHIDTransaction,
) -> IOHIDTransactionDirectionType {
    extern "C-unwind" {
        fn IOHIDTransactionGetDirection(
            transaction: &IOHIDTransaction,
        ) -> IOHIDTransactionDirectionType;
    }
    unsafe { IOHIDTransactionGetDirection(transaction) }
}

#[deprecated = "renamed to `IOHIDTransaction::set_direction`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionSetDirection(
    transaction: &IOHIDTransaction,
    direction: IOHIDTransactionDirectionType,
) {
    extern "C-unwind" {
        fn IOHIDTransactionSetDirection(
            transaction: &IOHIDTransaction,
            direction: IOHIDTransactionDirectionType,
        );
    }
    unsafe { IOHIDTransactionSetDirection(transaction, direction) }
}

#[deprecated = "renamed to `IOHIDTransaction::add_element`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionAddElement(
    transaction: &IOHIDTransaction,
    element: &IOHIDElement,
) {
    extern "C-unwind" {
        fn IOHIDTransactionAddElement(transaction: &IOHIDTransaction, element: &IOHIDElement);
    }
    unsafe { IOHIDTransactionAddElement(transaction, element) }
}

#[deprecated = "renamed to `IOHIDTransaction::remove_element`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionRemoveElement(
    transaction: &IOHIDTransaction,
    element: &IOHIDElement,
) {
    extern "C-unwind" {
        fn IOHIDTransactionRemoveElement(transaction: &IOHIDTransaction, element: &IOHIDElement);
    }
    unsafe { IOHIDTransactionRemoveElement(transaction, element) }
}

#[deprecated = "renamed to `IOHIDTransaction::contains_element`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionContainsElement(
    transaction: &IOHIDTransaction,
    element: &IOHIDElement,
) -> bool {
    extern "C-unwind" {
        fn IOHIDTransactionContainsElement(
            transaction: &IOHIDTransaction,
            element: &IOHIDElement,
        ) -> Boolean;
    }
    let ret = unsafe { IOHIDTransactionContainsElement(transaction, element) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDTransaction::schedule_with_run_loop`"]
    pub fn IOHIDTransactionScheduleWithRunLoop(
        transaction: &IOHIDTransaction,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDTransaction::unschedule_from_run_loop`"]
    pub fn IOHIDTransactionUnscheduleFromRunLoop(
        transaction: &IOHIDTransaction,
        run_loop: &CFRunLoop,
        run_loop_mode: &CFString,
    );
}

#[deprecated = "renamed to `IOHIDTransaction::set_value`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionSetValue(
    transaction: &IOHIDTransaction,
    element: &IOHIDElement,
    value: &IOHIDValue,
    options: IOOptionBits,
) {
    extern "C-unwind" {
        fn IOHIDTransactionSetValue(
            transaction: &IOHIDTransaction,
            element: &IOHIDElement,
            value: &IOHIDValue,
            options: IOOptionBits,
        );
    }
    unsafe { IOHIDTransactionSetValue(transaction, element, value, options) }
}

#[deprecated = "renamed to `IOHIDTransaction::value`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionGetValue(
    transaction: &IOHIDTransaction,
    element: &IOHIDElement,
    options: IOOptionBits,
) -> Option<CFRetained<IOHIDValue>> {
    extern "C-unwind" {
        fn IOHIDTransactionGetValue(
            transaction: &IOHIDTransaction,
            element: &IOHIDElement,
            options: IOOptionBits,
        ) -> Option<NonNull<IOHIDValue>>;
    }
    let ret = unsafe { IOHIDTransactionGetValue(transaction, element, options) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `IOHIDTransaction::commit`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionCommit(transaction: &IOHIDTransaction) -> IOReturn {
    extern "C-unwind" {
        fn IOHIDTransactionCommit(transaction: &IOHIDTransaction) -> IOReturn;
    }
    unsafe { IOHIDTransactionCommit(transaction) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDTransaction::commit_with_callback`"]
    pub fn IOHIDTransactionCommitWithCallback(
        transaction: &IOHIDTransaction,
        timeout: CFTimeInterval,
        callback: IOHIDCallback,
        context: *mut c_void,
    ) -> IOReturn;
}

#[deprecated = "renamed to `IOHIDTransaction::clear`"]
#[inline]
pub extern "C-unwind" fn IOHIDTransactionClear(transaction: &IOHIDTransaction) {
    extern "C-unwind" {
        fn IOHIDTransactionClear(transaction: &IOHIDTransaction);
    }
    unsafe { IOHIDTransactionClear(transaction) }
}
