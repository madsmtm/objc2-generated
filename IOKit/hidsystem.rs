//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/event_system_version?language=objc)
pub const EVENT_SYSTEM_VERSION: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/knxeventdataversion?language=objc)
pub const kNXEventDataVersion: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/knxeventversion?language=objc)
pub const kNXEventVersion: c_uint = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkindkey?language=objc)
pub const kIOHIDKindKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKind\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidinterfaceidkey?language=objc)
pub const kIOHIDInterfaceIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDInterfaceID\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidsubinterfaceidkey?language=objc)
pub const kIOHIDSubinterfaceIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDSubinterfaceID\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidoriginalsubinterfaceidkey?language=objc)
pub const kIOHIDOriginalSubinterfaceIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDOriginalSubinterfaceID\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidparameterskey?language=objc)
pub const kIOHIDParametersKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDParameters\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidvirtualhidevice?language=objc)
pub const kIOHIDVirtualHIDevice: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDVirtualDevice\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkeyrepeatkey?language=objc)
pub const kIOHIDKeyRepeatKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyRepeat\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidinitialkeyrepeatkey?language=objc)
pub const kIOHIDInitialKeyRepeatKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDInitialKeyRepeat\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkeymappingkey?language=objc)
pub const kIOHIDKeyMappingKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyMapping\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidresetkeyboardkey?language=objc)
pub const kIOHIDResetKeyboardKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDResetKeyboard\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkeyboardmodifiermappingpairskey?language=objc)
pub const kIOHIDKeyboardModifierMappingPairsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardModifierMappingPairs\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkeyboardmodifiermappingsrckey?language=objc)
pub const kIOHIDKeyboardModifierMappingSrcKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardModifierMappingSrc\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkeyboardmodifiermappingdstkey?language=objc)
pub const kIOHIDKeyboardModifierMappingDstKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardModifierMappingDst\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkeyboardcapslockdoeslockkey?language=objc)
pub const kIOHIDKeyboardCapsLockDoesLockKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardCapsLockDoesLock\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkeyboardsupportsf12ejectkey?language=objc)
pub const kIOHIDKeyboardSupportsF12EjectKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardSupportsF12Eject\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkeyboardsupportedmodifierskey?language=objc)
pub const kIOHIDKeyboardSupportedModifiersKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardSupportedModifiers\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidkeyboardglobalmodifierskey?language=objc)
pub const kIOHIDKeyboardGlobalModifiersKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDKeyboardGlobalModifiers\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidserviceglobalmodifiersusagekey?language=objc)
pub const kIOHIDServiceGlobalModifiersUsageKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDServiceGlobalModifiersUsage\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidpointerresolutionkey?language=objc)
pub const kIOHIDPointerResolutionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerResolution\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidresetpointerkey?language=objc)
pub const kIOHIDResetPointerKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDResetPointer\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidpointerconvertabsolutekey?language=objc)
pub const kIOHIDPointerConvertAbsoluteKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerConvertAbsolute\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidpointercontacttomovekey?language=objc)
pub const kIOHIDPointerContactToMoveKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerContactToMove\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidpointerpressuretoclickkey?language=objc)
pub const kIOHIDPointerPressureToClickKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerPressureToClick\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidpointerbuttoncountkey?language=objc)
pub const kIOHIDPointerButtonCountKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerButtonCount\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidpointeraccelerationsettingskey?language=objc)
pub const kIOHIDPointerAccelerationSettingsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerAccelerationSettings\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidpointeraccelerationtablekey?language=objc)
pub const kIOHIDPointerAccelerationTableKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDPointerAccelerationTable\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollresetkey?language=objc)
pub const kIOHIDScrollResetKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollReset\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollaccelerationtablekey?language=objc)
pub const kIOHIDScrollAccelerationTableKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollAccelerationTable\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollaccelerationtablexkey?language=objc)
pub const kIOHIDScrollAccelerationTableXKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollAccelerationTableX\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollaccelerationtableykey?language=objc)
pub const kIOHIDScrollAccelerationTableYKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollAccelerationTableY\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollaccelerationtablezkey?language=objc)
pub const kIOHIDScrollAccelerationTableZKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollAccelerationTableZ\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollmousebuttonkey?language=objc)
pub const kIOHIDScrollMouseButtonKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollMouseButton\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollzoommodifiermaskkey?language=objc)
pub const kIOHIDScrollZoomModifierMaskKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollZoomModifierMask\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidclicktimekey?language=objc)
pub const kIOHIDClickTimeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDClickTime\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidclickspacekey?language=objc)
pub const kIOHIDClickSpaceKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDClickSpace\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidwaitcursorframeintervalkey?language=objc)
pub const kIOHIDWaitCursorFrameIntervalKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDWaitCursorFrameInterval\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidautodimthresholdkey?language=objc)
pub const kIOHIDAutoDimThresholdKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAutoDimThreshold\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidautodimstatekey?language=objc)
pub const kIOHIDAutoDimStateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAutoDimState\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidautodimtimekey?language=objc)
pub const kIOHIDAutoDimTimeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAutoDimTime\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohididletimekey?language=objc)
pub const kIOHIDIdleTimeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDIdleTime\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidbrightnesskey?language=objc)
pub const kIOHIDBrightnessKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDBrightness\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidautodimbrightnesskey?language=objc)
pub const kIOHIDAutoDimBrightnessKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAutoDimBrightness\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidfkeymodekey?language=objc)
pub const kIOHIDFKeyModeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDFKeyMode\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidstickykeysdisabledkey?language=objc)
pub const kIOHIDStickyKeysDisabledKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDStickyKeysDisabled\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidstickykeysonkey?language=objc)
pub const kIOHIDStickyKeysOnKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDStickyKeysOn\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidstickykeysshifttoggleskey?language=objc)
pub const kIOHIDStickyKeysShiftTogglesKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDStickyKeysShiftToggles\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidresetstickykeynotification?language=objc)
pub const kIOHIDResetStickyKeyNotification: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDResetStickyKeyNotification\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidmousekeysoptiontoggleskey?language=objc)
pub const kIOHIDMouseKeysOptionTogglesKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDMouseKeysOptionToggles\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidslowkeysdelaykey?language=objc)
pub const kIOHIDSlowKeysDelayKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDSlowKeysDelay\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidf12ejectdelaykey?language=objc)
pub const kIOHIDF12EjectDelayKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDF12EjectDelay\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidmousekeysonkey?language=objc)
pub const kIOHIDMouseKeysOnKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDMouseKeysOn\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidusekeyswitchkey?language=objc)
pub const kIOHIDUseKeyswitchKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDUseKeyswitch\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohiddisallowremappingofprimaryclickkey?language=objc)
pub const kIOHIDDisallowRemappingOfPrimaryClickKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDDisallowRemappingOfPrimaryClick\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidmousekeysenablesvirtualnumpadkey?language=objc)
pub const kIOHIDMouseKeysEnablesVirtualNumPadKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDMouseKeysEnablesVirtualNumPad\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidresetledskey?language=objc)
pub const kIOHIDResetLEDsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDResetLEDs\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidtrackingaccelparametriccurveskey?language=objc)
pub const kHIDTrackingAccelParametricCurvesKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDTrackingAccelCurves\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidaccelparametriccurvesdebugkey?language=objc)
pub const kHIDAccelParametricCurvesDebugKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelCurvesDebug\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidscrollaccelparametriccurvesdebugkey?language=objc)
pub const kHIDScrollAccelParametricCurvesDebugKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollAccelCurvesDebug\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidaccelgainlinearkey?language=objc)
pub const kHIDAccelGainLinearKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelGainLinear\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidaccelgainparabolickey?language=objc)
pub const kHIDAccelGainParabolicKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelGainParabolic\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidaccelgaincubickey?language=objc)
pub const kHIDAccelGainCubicKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelGainCubic\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidaccelgainquartickey?language=objc)
pub const kHIDAccelGainQuarticKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelGainQuartic\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidacceltangentspeedlinearkey?language=objc)
pub const kHIDAccelTangentSpeedLinearKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelTangentSpeedLinear\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidacceltangentspeedparabolicrootkey?language=objc)
pub const kHIDAccelTangentSpeedParabolicRootKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelTangentSpeedParabolicRoot\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidacceltangentspeedcubicrootkey?language=objc)
pub const kHIDAccelTangentSpeedCubicRootKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelTangentSpeedCubicRoot\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidacceltangentspeedquarticrootkey?language=objc)
pub const kHIDAccelTangentSpeedQuarticRootKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelTangentSpeedQuarticRoot\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/khidaccelindexkey?language=objc)
pub const kHIDAccelIndexKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDAccelIndex\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountmaxtimedeltabetweenkey?language=objc)
pub const kIOHIDScrollCountMaxTimeDeltaBetweenKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountMaxTimeDeltaBetween\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountmaxtimedeltatosustainkey?language=objc)
pub const kIOHIDScrollCountMaxTimeDeltaToSustainKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountMaxTimeDeltaToSustain\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountmindeltatostartkey?language=objc)
pub const kIOHIDScrollCountMinDeltaToStartKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountMinDeltaToStart\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountmindeltatosustainkey?language=objc)
pub const kIOHIDScrollCountMinDeltaToSustainKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountMinDeltaToSustain\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountignoremomentumscrollskey?language=objc)
pub const kIOHIDScrollCountIgnoreMomentumScrollsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountIgnoreMomentumScrolls\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountmousecanresetkey?language=objc)
pub const kIOHIDScrollCountMouseCanResetKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountMouseCanReset\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountmaxkey?language=objc)
pub const kIOHIDScrollCountMaxKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountMax\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountaccelerationfactorkey?language=objc)
pub const kIOHIDScrollCountAccelerationFactorKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountAccelerationFactor\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountzerokey?language=objc)
pub const kIOHIDScrollCountZeroKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountZero\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountbootdefaultkey?language=objc)
pub const kIOHIDScrollCountBootDefaultKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountBootDefault\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidscrollcountresetkey?language=objc)
pub const kIOHIDScrollCountResetKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"HIDScrollCountReset\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidactivityuseridlekey?language=objc)
pub const kIOHIDActivityUserIdleKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHIDActivityUserIdle\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidsystemclass?language=objc)
pub const kIOHIDSystemClass: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHIDSystem\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohikeyboardclass?language=objc)
pub const kIOHIKeyboardClass: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHIKeyboard\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohipointingclass?language=objc)
pub const kIOHIPointingClass: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHIPointing\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidcurrentshmemversion?language=objc)
pub const kIOHIDCurrentShmemVersion: c_uint = 4;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidlastcompatibleshmemversion?language=objc)
pub const kIOHIDLastCompatibleShmemVersion: c_uint = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidmessagerelayserviceinterfaceactive?language=objc)
pub const kIOHIDMessageRelayServiceInterfaceActive: c_uint = iokit_vendor_specific_msg!(2);
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/evsiokeymapping?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct evsioKeymapping {
    pub size: c_int,
    pub mapping: *mut c_char,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for evsioKeymapping {
    const ENCODING: Encoding = Encoding::Struct(
        "evsioKeymapping",
        &[<c_int>::ENCODING, <*mut c_char>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for evsioKeymapping {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxkeymapping?language=objc)
pub type NXKeyMapping = evsioKeymapping;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/evsiomousescaling?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct evsioMouseScaling {
    pub numScaleLevels: c_int,
    pub scaleThresholds: [c_short; 20],
    pub scaleFactors: [c_short; 20],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for evsioMouseScaling {
    const ENCODING: Encoding = Encoding::Struct(
        "evsioMouseScaling",
        &[
            <c_int>::ENCODING,
            <[c_short; 20]>::ENCODING,
            <[c_short; 20]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for evsioMouseScaling {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxmousescaling?language=objc)
pub type NXMouseScaling = evsioMouseScaling;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxmousebutton?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct NXMouseButton(pub c_uint);
impl NXMouseButton {
    #[doc(alias = "NX_OneButton")]
    pub const OneButton: Self = Self(0);
    #[doc(alias = "NX_LeftButton")]
    pub const LeftButton: Self = Self(1);
    #[doc(alias = "NX_RightButton")]
    pub const RightButton: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXMouseButton {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXMouseButton {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iofixedpoint32?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOFixedPoint32 {
    pub x: i32,
    pub y: i32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOFixedPoint32 {
    const ENCODING: Encoding =
        Encoding::Struct("__IOFixedPoint32", &[<i32>::ENCODING, <i32>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOFixedPoint32 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventsysteminfotype?language=objc)
pub type NXEventSystemInfoType = *mut c_int;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventsystemdevice?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXEventSystemDevice {
    pub interface: c_int,
    pub interface_addr: c_int,
    pub dev_type: c_int,
    pub id: c_int,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventSystemDevice {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <c_int>::ENCODING,
            <c_int>::ENCODING,
            <c_int>::ENCODING,
            <c_int>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventSystemDevice {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventsystemdevicelist?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXEventSystemDeviceList {
    pub dev: [NXEventSystemDevice; 16],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventSystemDeviceList {
    const ENCODING: Encoding = Encoding::Struct("?", &[<[NXEventSystemDevice; 16]>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventSystemDeviceList {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/evcmd?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct EvCmd(pub c_uint);
impl EvCmd {
    pub const EVNOP: Self = Self(0);
    pub const EVHIDE: Self = Self(1);
    pub const EVSHOW: Self = Self(2);
    pub const EVMOVE: Self = Self(3);
    pub const EVLEVEL: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for EvCmd {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for EvCmd {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxcoord?language=objc)
pub type NXCoord = c_float;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxpoint?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXPoint {
    pub x: NXCoord,
    pub y: NXCoord,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXPoint {
    const ENCODING: Encoding =
        Encoding::Struct("_NXPoint", &[<NXCoord>::ENCODING, <NXCoord>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXPoint {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxsize?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXSize {
    pub width: NXCoord,
    pub height: NXCoord,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXSize {
    const ENCODING: Encoding =
        Encoding::Struct("_NXSize", &[<NXCoord>::ENCODING, <NXCoord>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXSize {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/_nxtabletpointdata_tilt?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct _NXTabletPointData_tilt {
    pub x: i16,
    pub y: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for _NXTabletPointData_tilt {
    const ENCODING: Encoding = Encoding::Struct("?", &[<i16>::ENCODING, <i16>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for _NXTabletPointData_tilt {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxtabletpointdata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXTabletPointData {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub buttons: u16,
    pub pressure: u16,
    pub tilt: _NXTabletPointData_tilt,
    pub rotation: u16,
    pub tangentialPressure: i16,
    pub deviceID: u16,
    pub vendor1: i16,
    pub vendor2: i16,
    pub vendor3: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXTabletPointData {
    const ENCODING: Encoding = Encoding::Struct(
        "_NXTabletPointData",
        &[
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <_NXTabletPointData_tilt>::ENCODING,
            <u16>::ENCODING,
            <i16>::ENCODING,
            <u16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXTabletPointData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxtabletproximitydata?language=objc)
#[repr(C, packed(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXTabletProximityData {
    pub vendorID: u16,
    pub tabletID: u16,
    pub pointerID: u16,
    pub deviceID: u16,
    pub systemTabletID: u16,
    pub vendorPointerType: u16,
    pub pointerSerialNumber: u32,
    pub uniqueID: u64,
    pub capabilityMask: u32,
    pub pointerType: u8,
    pub enterProximity: u8,
    pub reserved1: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXTabletProximityData {
    const ENCODING: Encoding = Encoding::Struct(
        "_NXTabletProximityData",
        &[
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u32>::ENCODING,
            <u64>::ENCODING,
            <u32>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <i16>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXTabletProximityData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_mouse_tablet?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub union NXEventData_mouse_tablet {
    pub point: NXTabletPointData,
    pub proximity: NXTabletProximityData,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_mouse_tablet {
    const ENCODING: Encoding = Encoding::Union(
        "?",
        &[
            <NXTabletPointData>::ENCODING,
            <NXTabletProximityData>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_mouse_tablet {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_mouse?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub struct NXEventData_mouse {
    pub subx: u8,
    pub suby: u8,
    pub eventNum: i16,
    pub click: i32,
    pub pressure: u8,
    pub buttonNumber: u8,
    pub subType: u8,
    pub reserved2: u8,
    pub reserved3: i32,
    pub tablet: NXEventData_mouse_tablet,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_mouse {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <i16>::ENCODING,
            <i32>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <i32>::ENCODING,
            <NXEventData_mouse_tablet>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_mouse {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_mousemove_tablet?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub union NXEventData_mouseMove_tablet {
    pub point: NXTabletPointData,
    pub proximity: NXTabletProximityData,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_mouseMove_tablet {
    const ENCODING: Encoding = Encoding::Union(
        "?",
        &[
            <NXTabletPointData>::ENCODING,
            <NXTabletProximityData>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_mouseMove_tablet {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_mousemove?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub struct NXEventData_mouseMove {
    pub dx: i32,
    pub dy: i32,
    pub subx: u8,
    pub suby: u8,
    pub subType: u8,
    pub reserved1: u8,
    pub reserved2: i32,
    pub tablet: NXEventData_mouseMove_tablet,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_mouseMove {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <i32>::ENCODING,
            <i32>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <i32>::ENCODING,
            <NXEventData_mouseMove_tablet>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_mouseMove {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_key?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXEventData_key {
    pub origCharSet: u16,
    pub repeat: i16,
    pub charSet: u16,
    pub charCode: u16,
    pub keyCode: u16,
    pub origCharCode: u16,
    pub reserved1: i32,
    pub keyboardType: u32,
    pub reserved2: i32,
    pub reserved3: i32,
    pub reserved4: i32,
    pub reserved5: [i32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_key {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u16>::ENCODING,
            <i16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <i32>::ENCODING,
            <u32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <[i32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_key {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_tracking?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXEventData_tracking {
    pub reserved: i16,
    pub eventNum: i16,
    pub trackingNum: i32,
    pub userData: i32,
    pub reserved1: i32,
    pub reserved2: i32,
    pub reserved3: i32,
    pub reserved4: i32,
    pub reserved5: i32,
    pub reserved6: [i32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_tracking {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <[i32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_tracking {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_scrollwheel?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXEventData_scrollWheel {
    pub deltaAxis1: i16,
    pub deltaAxis2: i16,
    pub deltaAxis3: i16,
    pub reserved1: i16,
    pub fixedDeltaAxis1: i32,
    pub fixedDeltaAxis2: i32,
    pub fixedDeltaAxis3: i32,
    pub pointDeltaAxis1: i32,
    pub pointDeltaAxis2: i32,
    pub pointDeltaAxis3: i32,
    pub reserved8: [i32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_scrollWheel {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <[i32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_scrollWheel {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_compound_misc?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub union NXEventData_compound_misc {
    pub F: [c_float; 11],
    pub L: [i32; 11],
    pub S: [i16; 22],
    pub C: [c_char; 44],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_compound_misc {
    const ENCODING: Encoding = Encoding::Union(
        "?",
        &[
            <[c_float; 11]>::ENCODING,
            <[i32; 11]>::ENCODING,
            <[i16; 22]>::ENCODING,
            <[c_char; 44]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_compound_misc {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_compound?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub struct NXEventData_compound {
    pub reserved: i16,
    pub subType: i16,
    pub misc: NXEventData_compound_misc,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_compound {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <i16>::ENCODING,
            <i16>::ENCODING,
            <NXEventData_compound_misc>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_compound {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_tablet_tilt?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXEventData_tablet_tilt {
    pub x: i16,
    pub y: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_tablet_tilt {
    const ENCODING: Encoding = Encoding::Struct("?", &[<i16>::ENCODING, <i16>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_tablet_tilt {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_tablet?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXEventData_tablet {
    pub x: i32,
    pub y: i32,
    pub z: i32,
    pub buttons: u16,
    pub pressure: u16,
    pub tilt: NXEventData_tablet_tilt,
    pub rotation: u16,
    pub tangentialPressure: i16,
    pub deviceID: u16,
    pub vendor1: i16,
    pub vendor2: i16,
    pub vendor3: i16,
    pub reserved: [i32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_tablet {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <NXEventData_tablet_tilt>::ENCODING,
            <u16>::ENCODING,
            <i16>::ENCODING,
            <u16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
            <[i32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_tablet {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata_proximity?language=objc)
#[repr(C, packed(4))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct NXEventData_proximity {
    pub vendorID: u16,
    pub tabletID: u16,
    pub pointerID: u16,
    pub deviceID: u16,
    pub systemTabletID: u16,
    pub vendorPointerType: u16,
    pub pointerSerialNumber: u32,
    pub uniqueID: u64,
    pub capabilityMask: u32,
    pub pointerType: u8,
    pub enterProximity: u8,
    pub reserved1: i16,
    pub reserved2: [i32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData_proximity {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u32>::ENCODING,
            <u64>::ENCODING,
            <u32>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <i16>::ENCODING,
            <[i32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData_proximity {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventdata?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub union NXEventData {
    pub mouse: NXEventData_mouse,
    pub mouseMove: NXEventData_mouseMove,
    pub key: NXEventData_key,
    pub tracking: NXEventData_tracking,
    pub scrollWheel: NXEventData_scrollWheel,
    pub zoom: NXEventData_scrollWheel,
    pub compound: NXEventData_compound,
    pub tablet: NXEventData_tablet,
    pub proximity: NXEventData_proximity,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEventData {
    const ENCODING: Encoding = Encoding::Union(
        "?",
        &[
            <NXEventData_mouse>::ENCODING,
            <NXEventData_mouseMove>::ENCODING,
            <NXEventData_key>::ENCODING,
            <NXEventData_tracking>::ENCODING,
            <NXEventData_scrollWheel>::ENCODING,
            <NXEventData_scrollWheel>::ENCODING,
            <NXEventData_compound>::ENCODING,
            <NXEventData_tablet>::ENCODING,
            <NXEventData_proximity>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEventData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/_nxevent_location?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct _NXEvent_location {
    pub x: i32,
    pub y: i32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for _NXEvent_location {
    const ENCODING: Encoding = Encoding::Struct("?", &[<i32>::ENCODING, <i32>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for _NXEvent_location {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxevent?language=objc)
#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct NXEvent {
    pub r#type: i32,
    pub location: _NXEvent_location,
    pub time: u64,
    pub flags: i32,
    pub window: u32,
    pub service_id: u64,
    pub ext_pid: i32,
    pub data: NXEventData,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for NXEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "_NXEvent",
        &[
            <i32>::ENCODING,
            <_NXEvent_location>::ENCODING,
            <u64>::ENCODING,
            <i32>::ENCODING,
            <u32>::ENCODING,
            <u64>::ENCODING,
            <i32>::ENCODING,
            <NXEventData>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for NXEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iohidbuttonmodes?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDButtonModes(pub c_uint);
impl IOHIDButtonModes {
    #[doc(alias = "kIOHIDButtonMode_BothLeftClicks")]
    pub const BothLeftClicks: Self = Self(0);
    #[doc(alias = "kIOHIDButtonMode_ReverseLeftRightClicks")]
    pub const ReverseLeftRightClicks: Self = Self(1);
    #[doc(alias = "kIOHIDButtonMode_EnableRightClick")]
    pub const EnableRightClick: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDButtonModes {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDButtonModes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/evsioevsioscsindices?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct evsioEVSIOSCSIndices(pub c_uint);
impl evsioEVSIOSCSIndices {
    pub const EVSIOSCS_X: Self = Self(0);
    pub const EVSIOSCS_Y: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for evsioEVSIOSCSIndices {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for evsioEVSIOSCSIndices {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/evsioevsioccsindices?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct evsioEVSIOCCSIndices(pub c_uint);
impl evsioEVSIOCCSIndices {
    pub const EVSIOCCS_X: Self = Self(0);
    pub const EVSIOCCS_Y: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for evsioEVSIOCCSIndices {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for evsioEVSIOCCSIndices {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidcapslockstate?language=objc)
pub const kIOHIDCapsLockState: c_uint = 0x00000001;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidnumlockstate?language=objc)
pub const kIOHIDNumLockState: c_uint = 0x00000002;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidactivityuseridle?language=objc)
pub const kIOHIDActivityUserIdle: c_uint = 0x00000003;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidactivitydisplayon?language=objc)
pub const kIOHIDActivityDisplayOn: c_uint = 0x00000004;

/// ****************************************************************************
/// SHARED MEMORY OVERVIEW
///
/// PERSPECTIVE
/// The ev driver and PostScript share at least one page of wired memory.
/// This memory contains the low-level event queue which ev deposits events
/// into and PostScript reads events from. Also, this memory contains other
/// important data such as wait cursor state and some general cursor state.
/// This memory is critical for speed.  That is, we avoid having to make
/// system calls for common operations.
///
/// SHARED MEMORY REGIONS
/// There are currently three "regions" or "zones" delineated within this
/// shared memory.  The first zone is the EvOffsets structure. This structure
/// contains two offsets from the beginning of shared memory. The first offset
/// is to the second zone, EvGlobals. The second offset is to the third
/// zone, private shmem for drivers.
///
/// INITIALIZATION OF SHARED MEMORY
/// When the WindowServer starts up, it finds all screens that will be active.
/// It then opens the ev driver and calls the EVIOSSCR ioctl repeatedly for
/// each screen in use. This lets the ev driver set up the evScreen array
/// and fill in each element. This ioctl also returns to PostScript a running
/// total shared memory size with which to allocate. PostScript then allocates
/// a region of memory this size and calls evmmap to "map in" this shared
/// region.  Evmmap initializes and fills in the EvOffsets and EvGlobals.
/// Next the WindowServer calls each screen in turn to register itself with
/// the ev driver in the same sequence as presented to EVIOSSCR.  Each screen
/// driver calls ev_register_screen() which among other things allocates a
/// part of the private shmem (of the third shared memory zone) for the driver.
///
/// DEBUGGING NOTES
/// You can easily display and set this shared memory from kgdb, but usually
/// cannot do so from within PostScript.  Gdb (or some weird interaction
/// between gdb and the os) chokes on this shmem.  So if you read or write
/// this area of memory, copy-on-write will occur and you'll get a completely
/// new page for PostScript.  This will render the shared memory scheme
/// useless and you will have to restart PostScript.  It was my understanding
/// that before, we were able to "read" this area from PS, but not write to
/// it (the idea behind copy-on-WRITE).  However, this seems to be broken
/// in 2.0.  We think this is a kernel bug.
/// ****************************************************************************
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/_evoffsets?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct _evOffsets {
    pub evGlobalsOffset: c_int,
    pub evShmemOffset: c_int,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for _evOffsets {
    const ENCODING: Encoding =
        Encoding::Struct("_evOffsets", &[<c_int>::ENCODING, <c_int>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for _evOffsets {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// ****************************************************************************
/// SHARED MEMORY OVERVIEW
///
/// PERSPECTIVE
/// The ev driver and PostScript share at least one page of wired memory.
/// This memory contains the low-level event queue which ev deposits events
/// into and PostScript reads events from. Also, this memory contains other
/// important data such as wait cursor state and some general cursor state.
/// This memory is critical for speed.  That is, we avoid having to make
/// system calls for common operations.
///
/// SHARED MEMORY REGIONS
/// There are currently three "regions" or "zones" delineated within this
/// shared memory.  The first zone is the EvOffsets structure. This structure
/// contains two offsets from the beginning of shared memory. The first offset
/// is to the second zone, EvGlobals. The second offset is to the third
/// zone, private shmem for drivers.
///
/// INITIALIZATION OF SHARED MEMORY
/// When the WindowServer starts up, it finds all screens that will be active.
/// It then opens the ev driver and calls the EVIOSSCR ioctl repeatedly for
/// each screen in use. This lets the ev driver set up the evScreen array
/// and fill in each element. This ioctl also returns to PostScript a running
/// total shared memory size with which to allocate. PostScript then allocates
/// a region of memory this size and calls evmmap to "map in" this shared
/// region.  Evmmap initializes and fills in the EvOffsets and EvGlobals.
/// Next the WindowServer calls each screen in turn to register itself with
/// the ev driver in the same sequence as presented to EVIOSSCR.  Each screen
/// driver calls ev_register_screen() which among other things allocates a
/// part of the private shmem (of the third shared memory zone) for the driver.
///
/// DEBUGGING NOTES
/// You can easily display and set this shared memory from kgdb, but usually
/// cannot do so from within PostScript.  Gdb (or some weird interaction
/// between gdb and the os) chokes on this shmem.  So if you read or write
/// this area of memory, copy-on-write will occur and you'll get a completely
/// new page for PostScript.  This will render the shared memory scheme
/// useless and you will have to restart PostScript.  It was my understanding
/// that before, we were able to "read" this area from PS, but not write to
/// it (the idea behind copy-on-WRITE).  However, this seems to be broken
/// in 2.0.  We think this is a kernel bug.
/// ****************************************************************************
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/evoffsets?language=objc)
pub type EvOffsets = _evOffsets;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/eviollevent?language=objc)
#[cfg(feature = "graphics")]
#[repr(C)]
#[derive(Clone, Copy)]
pub struct evioLLEvent {
    pub setCursor: c_int,
    pub r#type: c_int,
    pub location: IOGPoint,
    pub data: NXEventData,
    pub setFlags: c_int,
    pub flags: c_int,
}

#[cfg(all(feature = "graphics", feature = "objc2"))]
unsafe impl Encode for evioLLEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "evioLLEvent",
        &[
            <c_int>::ENCODING,
            <c_int>::ENCODING,
            <IOGPoint>::ENCODING,
            <NXEventData>::ENCODING,
            <c_int>::ENCODING,
            <c_int>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "graphics", feature = "objc2"))]
unsafe impl RefEncode for evioLLEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohideventnotification?language=objc)
pub const kIOHIDEventNotification: c_uint = 0;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidserverconnecttype?language=objc)
pub const kIOHIDServerConnectType: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidparamconnecttype?language=objc)
pub const kIOHIDParamConnectType: c_uint = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohideventsystemconnecttype?language=objc)
pub const kIOHIDEventSystemConnectType: c_uint = 3;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidglobalmemory?language=objc)
pub const kIOHIDGlobalMemory: c_uint = 0;

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohideventqueuetypekernel?language=objc)
pub const kIOHIDEventQueueTypeKernel: c_uint = 0;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohideventqueuetypeuser?language=objc)
pub const kIOHIDEventQueueTypeUser: c_uint = 1;

/// kIOHIDOpenedByEventSystem
///
/// option passed to open for IOHIDInterface  if opened by IOHIDEventDriver
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidopenedbyeventsystem?language=objc)
pub const kIOHIDOpenedByEventSystem: c_uint = 0x10000;
/// kIOHIDOpenedByFastPathClient
///
/// option passed to open for IOHIDEventService if opened by fast path client
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidopenedbyfastpathclient?language=objc)
pub const kIOHIDOpenedByFastPathClient: c_uint = 0x20000;

#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOHIDCreateSharedMemory(
    connect: io_connect_t,
    version: c_uint,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDCreateSharedMemory(connect: io_connect_t, version: c_uint) -> libc::kern_return_t;
    }
    unsafe { IOHIDCreateSharedMemory(connect, version) }
}

#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOHIDSetEventsEnable(
    connect: io_connect_t,
    enable: bool,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDSetEventsEnable(
            connect: io_connect_t,
            enable: libc::boolean_t,
        ) -> libc::kern_return_t;
    }
    unsafe { IOHIDSetEventsEnable(connect, enable as _) }
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn IOHIDSetCursorEnable(
    connect: io_connect_t,
    enable: bool,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDSetCursorEnable(
            connect: io_connect_t,
            enable: libc::boolean_t,
        ) -> libc::kern_return_t;
    }
    unsafe { IOHIDSetCursorEnable(connect, enable as _) }
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidsetglobaleventflags?language=objc)
pub const kIOHIDSetGlobalEventFlags: c_uint = 0x00000001;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidsetcursorposition?language=objc)
pub const kIOHIDSetCursorPosition: c_uint = 0x00000002;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidsetrelativecursorposition?language=objc)
pub const kIOHIDSetRelativeCursorPosition: c_uint = 0x00000004;
/// [Apple's documentation](https://developer.apple.com/documentation/iokit/kiohidposthidmanagerevent?language=objc)
pub const kIOHIDPostHIDManagerEvent: c_uint = 0x00000008;

extern "C-unwind" {
    /// # Safety
    ///
    /// `event_data` must be a valid pointer.
    #[cfg(all(feature = "graphics", feature = "libc"))]
    #[deprecated = "Use CGSEventTap for posting HID events, IOHIDUserDevice for simulating HID device, IOPMAssertionDeclareUserActivity for reporting user activity"]
    pub fn IOHIDPostEvent(
        connect: io_connect_t,
        event_type: u32,
        location: IOGPoint,
        event_data: *const NXEventData,
        event_data_version: u32,
        event_flags: IOOptionBits,
        options: IOOptionBits,
    ) -> libc::kern_return_t;
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn IOHIDSetMouseLocation(
    connect: io_connect_t,
    x: c_int,
    y: c_int,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDSetMouseLocation(connect: io_connect_t, x: c_int, y: c_int) -> libc::kern_return_t;
    }
    unsafe { IOHIDSetMouseLocation(connect, x, y) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `event_num` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDGetButtonEventNum(
        connect: io_connect_t,
        button: NXMouseButton,
        event_num: *mut c_int,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `acceleration` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDGetScrollAcceleration(
        handle: io_connect_t,
        acceleration: *mut c_double,
    ) -> libc::kern_return_t;
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn IOHIDSetScrollAcceleration(
    handle: io_connect_t,
    acceleration: c_double,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDSetScrollAcceleration(
            handle: io_connect_t,
            acceleration: c_double,
        ) -> libc::kern_return_t;
    }
    unsafe { IOHIDSetScrollAcceleration(handle, acceleration) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `acceleration` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDGetMouseAcceleration(
        handle: io_connect_t,
        acceleration: *mut c_double,
    ) -> libc::kern_return_t;
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn IOHIDSetMouseAcceleration(
    handle: io_connect_t,
    acceleration: c_double,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDSetMouseAcceleration(
            handle: io_connect_t,
            acceleration: c_double,
        ) -> libc::kern_return_t;
    }
    unsafe { IOHIDSetMouseAcceleration(handle, acceleration) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `mode` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDGetMouseButtonMode(handle: io_connect_t, mode: *mut c_int) -> libc::kern_return_t;
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn IOHIDSetMouseButtonMode(
    handle: io_connect_t,
    mode: c_int,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDSetMouseButtonMode(handle: io_connect_t, mode: c_int) -> libc::kern_return_t;
    }
    unsafe { IOHIDSetMouseButtonMode(handle, mode) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `key` might not allow `None`.
    /// - `acceleration` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDGetAccelerationWithKey(
        handle: io_connect_t,
        key: Option<&CFString>,
        acceleration: *mut c_double,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `key` might not allow `None`.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDSetAccelerationWithKey(
        handle: io_connect_t,
        key: Option<&CFString>,
        acceleration: c_double,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `key` might not allow `None`.
    /// - `bytes` must be a valid pointer.
    /// - `actual_size` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDGetParameter(
        handle: io_connect_t,
        key: Option<&CFString>,
        max_size: IOByteCount,
        bytes: *mut c_void,
        actual_size: *mut IOByteCount,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `key` might not allow `None`.
    /// - `bytes` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDSetParameter(
        handle: io_connect_t,
        key: Option<&CFString>,
        bytes: *const c_void,
        size: IOByteCount,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `key` might not allow `None`.
    /// - `parameter` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IOHIDCopyCFTypeParameter(
        handle: io_connect_t,
        key: Option<&CFString>,
        parameter: *mut *const CFType,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `key` might not allow `None`.
    /// - `parameter` should be of the correct type.
    /// - `parameter` might not allow `None`.
    #[cfg(feature = "libc")]
    pub fn IOHIDSetCFTypeParameter(
        handle: io_connect_t,
        key: Option<&CFString>,
        parameter: Option<&CFType>,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `state` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IOHIDGetStateForSelector(
        handle: io_connect_t,
        selector: c_int,
        state: *mut u32,
    ) -> libc::kern_return_t;
}

#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOHIDSetStateForSelector(
    handle: io_connect_t,
    selector: c_int,
    state: u32,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDSetStateForSelector(
            handle: io_connect_t,
            selector: c_int,
            state: u32,
        ) -> libc::kern_return_t;
    }
    unsafe { IOHIDSetStateForSelector(handle, selector, state) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `state` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IOHIDGetModifierLockState(
        handle: io_connect_t,
        selector: c_int,
        state: *mut bool,
    ) -> libc::kern_return_t;
}

#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IOHIDSetModifierLockState(
    handle: io_connect_t,
    selector: c_int,
    state: bool,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDSetModifierLockState(
            handle: io_connect_t,
            selector: c_int,
            state: bool,
        ) -> libc::kern_return_t;
    }
    unsafe { IOHIDSetModifierLockState(handle, selector, state) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `display_token` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDRegisterVirtualDisplay(
        handle: io_connect_t,
        display_token: *mut u32,
    ) -> libc::kern_return_t;
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn IOHIDUnregisterVirtualDisplay(
    handle: io_connect_t,
    display_token: u32,
) -> libc::kern_return_t {
    extern "C-unwind" {
        fn IOHIDUnregisterVirtualDisplay(
            handle: io_connect_t,
            display_token: u32,
        ) -> libc::kern_return_t;
    }
    unsafe { IOHIDUnregisterVirtualDisplay(handle, display_token) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `bounds` must be a valid pointer.
    #[cfg(all(feature = "graphics", feature = "libc"))]
    #[deprecated]
    pub fn IOHIDSetVirtualDisplayBounds(
        handle: io_connect_t,
        display_token: u32,
        bounds: *const IOGBounds,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `hid_activity_idle` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn IOHIDGetActivityState(
        handle: io_connect_t,
        hid_activity_idle: *mut bool,
    ) -> libc::kern_return_t;
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iohidrequesttype?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDRequestType(pub c_uint);
impl IOHIDRequestType {
    #[doc(alias = "kIOHIDRequestTypePostEvent")]
    pub const PostEvent: Self = Self(0);
    #[doc(alias = "kIOHIDRequestTypeListenEvent")]
    pub const ListenEvent: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDRequestType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDRequestType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iohidaccesstype?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDAccessType(pub c_uint);
impl IOHIDAccessType {
    #[doc(alias = "kIOHIDAccessTypeGranted")]
    pub const Granted: Self = Self(0);
    #[doc(alias = "kIOHIDAccessTypeDenied")]
    pub const Denied: Self = Self(1);
    #[doc(alias = "kIOHIDAccessTypeUnknown")]
    pub const Unknown: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDAccessType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDAccessType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Checks if the process has access to a specific IOHIDRequestType. A process
/// may request access by calling the IOHIDRequestAccess function.
///
///
/// Parameter `requestType`: The request type defined in the IOHIDRequestType enumerator.
///
///
/// Returns: Returns an access type defined in the IOHIDAccessType enumerator.
#[inline]
pub extern "C-unwind" fn IOHIDCheckAccess(request_type: IOHIDRequestType) -> IOHIDAccessType {
    extern "C-unwind" {
        fn IOHIDCheckAccess(request_type: IOHIDRequestType) -> IOHIDAccessType;
    }
    unsafe { IOHIDCheckAccess(request_type) }
}

/// Requests access from the user for a specific IOHIDRequestType.
///
///
/// Processes that wish to post events through the IOHIDPostEvent API, or receive
/// reports through the IOHIDManager/IOHIDDevice API must be granted access first
/// by the user. If you do not call this API, it will be called on your behalf
/// when the API are used.
///
///
/// Parameter `requestType`: The request type defined in the IOHIDRequestType enumerator.
///
///
/// Returns: Returns true if access was granted.
#[inline]
pub extern "C-unwind" fn IOHIDRequestAccess(request_type: IOHIDRequestType) -> bool {
    extern "C-unwind" {
        fn IOHIDRequestAccess(request_type: IOHIDRequestType) -> bool;
    }
    unsafe { IOHIDRequestAccess(request_type) }
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxeventhandle?language=objc)
#[cfg(feature = "libc")]
pub type NXEventHandle = libc::mach_port_t;

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXOpenEventStatus() -> NXEventHandle {
    extern "C-unwind" {
        fn NXOpenEventStatus() -> NXEventHandle;
    }
    unsafe { NXOpenEventStatus() }
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXCloseEventStatus(handle: NXEventHandle) {
    extern "C-unwind" {
        fn NXCloseEventStatus(handle: NXEventHandle);
    }
    unsafe { NXCloseEventStatus(handle) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `flavor` must be a valid pointer.
    /// - `evs_info` must be a valid pointer.
    /// - `evs_info_cnt` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn NXEventSystemInfo(
        handle: NXEventHandle,
        flavor: *mut c_char,
        evs_info: *mut c_int,
        evs_info_cnt: *mut c_uint,
    ) -> NXEventSystemInfoType;
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXSetKeyRepeatInterval(handle: NXEventHandle, seconds: c_double) {
    extern "C-unwind" {
        fn NXSetKeyRepeatInterval(handle: NXEventHandle, seconds: c_double);
    }
    unsafe { NXSetKeyRepeatInterval(handle, seconds) }
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXKeyRepeatInterval(handle: NXEventHandle) -> c_double {
    extern "C-unwind" {
        fn NXKeyRepeatInterval(handle: NXEventHandle) -> c_double;
    }
    unsafe { NXKeyRepeatInterval(handle) }
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXSetKeyRepeatThreshold(handle: NXEventHandle, threshold: c_double) {
    extern "C-unwind" {
        fn NXSetKeyRepeatThreshold(handle: NXEventHandle, threshold: c_double);
    }
    unsafe { NXSetKeyRepeatThreshold(handle, threshold) }
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXKeyRepeatThreshold(handle: NXEventHandle) -> c_double {
    extern "C-unwind" {
        fn NXKeyRepeatThreshold(handle: NXEventHandle) -> c_double;
    }
    unsafe { NXKeyRepeatThreshold(handle) }
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXResetKeyboard(handle: NXEventHandle) {
    extern "C-unwind" {
        fn NXResetKeyboard(handle: NXEventHandle);
    }
    unsafe { NXResetKeyboard(handle) }
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXSetClickTime(handle: NXEventHandle, seconds: c_double) {
    extern "C-unwind" {
        fn NXSetClickTime(handle: NXEventHandle, seconds: c_double);
    }
    unsafe { NXSetClickTime(handle, seconds) }
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXClickTime(handle: NXEventHandle) -> c_double {
    extern "C-unwind" {
        fn NXClickTime(handle: NXEventHandle) -> c_double;
    }
    unsafe { NXClickTime(handle) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `area` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn NXSetClickSpace(handle: NXEventHandle, area: *mut NXSize);
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `area` must be a valid pointer.
    #[cfg(feature = "libc")]
    #[deprecated]
    pub fn NXGetClickSpace(handle: NXEventHandle, area: *mut NXSize);
}

#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub extern "C-unwind" fn NXResetMouse(handle: NXEventHandle) {
    extern "C-unwind" {
        fn NXResetMouse(handle: NXEventHandle);
    }
    unsafe { NXResetMouse(handle) }
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/_nxparsedkeymapping_?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct _NXParsedKeyMapping_ {
    pub shorts: c_short,
    pub keyBits: [c_char; 256],
    pub maxMod: c_int,
    pub modDefs: [*mut c_uchar; 16],
    pub numDefs: c_int,
    pub keyDefs: [*mut c_uchar; 256],
    pub numSeqs: c_int,
    pub seqDefs: [*mut c_uchar; 128],
    pub numSpecialKeys: c_int,
    pub specialKeys: [c_ushort; 24],
    pub mapping: *const c_uchar,
    pub mappingLen: c_int,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for _NXParsedKeyMapping_ {
    const ENCODING: Encoding = Encoding::Struct(
        "_NXParsedKeyMapping_",
        &[
            <c_short>::ENCODING,
            <[c_char; 256]>::ENCODING,
            <c_int>::ENCODING,
            <[*mut c_uchar; 16]>::ENCODING,
            <c_int>::ENCODING,
            <[*mut c_uchar; 256]>::ENCODING,
            <c_int>::ENCODING,
            <[*mut c_uchar; 128]>::ENCODING,
            <c_int>::ENCODING,
            <[c_ushort; 24]>::ENCODING,
            <*const c_uchar>::ENCODING,
            <c_int>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for _NXParsedKeyMapping_ {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/nxparsedkeymapping?language=objc)
pub type NXParsedKeyMapping = _NXParsedKeyMapping_;

/// IOHIDEventSystemClient
///
/// IOHIDEventSystemClient serves as a client that can be used
/// for reading/writing specific properties of the HID event system, as
/// well as getting services of the HID event system. A list of accessible
/// properties can be found in
/// <code>
/// IOKit/hid/IOHIDProperties.h
/// </code>
/// .
///
///
/// See also: IOKit/hidsystem/IOHIDServiceClient.h
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/iohideventsystemclient?language=objc)
#[doc(alias = "IOHIDEventSystemClientRef")]
#[repr(C)]
pub struct IOHIDEventSystemClient {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl IOHIDEventSystemClient {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__IOHIDEventSystemClient"> for IOHIDEventSystemClient {}
);

impl IOHIDEventSystemClient {
    /// Creates a client of the HID event system that has to ability to read/write certain
    /// properties.
    ///
    ///
    /// Certain properties have the ability to be set/read by clients, see
    /// <code>
    /// IOHIDProperties.h
    /// </code>
    /// for a list of these properties.
    ///
    ///
    /// Parameter `allocator`: a custom allocator reference to be used for allocation of the result.
    ///
    ///
    /// Returns: Returns a
    /// <code>
    /// IOHIDEventSystemClientRef
    /// </code>
    /// on success.
    /// Caller should CFRelease the client when they are finished with it, or keep a
    /// reference to the client if multiple properties need to be set/read.
    #[doc(alias = "IOHIDEventSystemClientCreateSimpleClient")]
    #[inline]
    pub fn new_simple_client(
        allocator: Option<&CFAllocator>,
    ) -> CFRetained<IOHIDEventSystemClient> {
        extern "C-unwind" {
            fn IOHIDEventSystemClientCreateSimpleClient(
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<IOHIDEventSystemClient>>;
        }
        let ret = unsafe { IOHIDEventSystemClientCreateSimpleClient(allocator) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Sets a property on the HID event system.
    ///
    ///
    /// Parameter `client`: the HID client that created via
    /// <code>
    /// IOHIDEventSystemClientCreateSimpleClient()
    /// </code>
    /// .
    ///
    ///
    /// Parameter `key`: the property key to set. A list of keys can be found in
    /// <code>
    /// HIDProperties.h
    /// </code>
    /// .
    ///
    ///
    /// Parameter `property`: the value to set the property.
    ///
    ///
    /// Returns: Returns true on success.
    ///
    /// # Safety
    ///
    /// `property` should be of the correct type.
    #[doc(alias = "IOHIDEventSystemClientSetProperty")]
    #[inline]
    pub unsafe fn set_property(&self, key: &CFString, property: &CFType) -> bool {
        extern "C-unwind" {
            fn IOHIDEventSystemClientSetProperty(
                client: &IOHIDEventSystemClient,
                key: &CFString,
                property: &CFType,
            ) -> Boolean;
        }
        let ret = unsafe { IOHIDEventSystemClientSetProperty(self, key, property) };
        ret != 0
    }

    /// Copies a property from the HID event system.
    ///
    ///
    /// Parameter `client`: the HID client created via
    /// <code>
    /// IOHIDEventSystemClientCreateSimpleClient()
    /// </code>
    /// .
    ///
    ///
    /// Parameter `key`: the property key to copy. A list of keys can be found in
    /// <code>
    /// HIDProperties.h
    /// </code>
    /// .
    ///
    ///
    /// Returns: Returns a CFTypeRef of the property to be copied on success, otherwise NULL.
    /// Caller is responsible for calling CFRelease on the property.
    #[doc(alias = "IOHIDEventSystemClientCopyProperty")]
    #[inline]
    pub fn property(&self, key: &CFString) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn IOHIDEventSystemClientCopyProperty(
                client: &IOHIDEventSystemClient,
                key: &CFString,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { IOHIDEventSystemClientCopyProperty(self, key) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

unsafe impl ConcreteType for IOHIDEventSystemClient {
    /// Returns: Returns the CFTypeID of the
    /// <code>
    /// IOHIDEventSystemClient
    /// </code>
    /// class.
    #[doc(alias = "IOHIDEventSystemClientGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOHIDEventSystemClientGetTypeID() -> CFTypeID;
        }
        unsafe { IOHIDEventSystemClientGetTypeID() }
    }
}

impl IOHIDEventSystemClient {
    /// Copies all services available to the client.
    ///
    ///
    /// Useful for seeing services that are available. Clients can further probe
    /// the services with the APIs available in
    /// <code>
    /// IOHIDServiceClient.h
    /// </code>
    /// .
    ///
    ///
    /// Parameter `client`: the HID client that created via
    /// <code>
    /// IOHIDEventSystemClientCreateSimpleClient()
    /// </code>
    /// .
    ///
    ///
    /// Returns: On success, returns a CFArrayRef of
    /// <code>
    /// IOHIDServiceClientRefs
    /// </code>
    /// that are
    /// available to the client. Caller is responsible for releasing the array.
    #[doc(alias = "IOHIDEventSystemClientCopyServices")]
    #[inline]
    pub fn services(&self) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn IOHIDEventSystemClientCopyServices(
                client: &IOHIDEventSystemClient,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { IOHIDEventSystemClientCopyServices(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// IOHIDServiceClient
///
/// IOHIDServiceClient serves as a client to the HID event system
/// services. Users are able to copy/set specific properties (defined in
/// <code>
/// IOKit/hid/IOHIDProperties.h
/// </code>
/// ), and gather more information
/// about the services available in the HID event system.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/iohidserviceclient?language=objc)
#[doc(alias = "IOHIDServiceClientRef")]
#[repr(C)]
pub struct IOHIDServiceClient {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl IOHIDServiceClient {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__IOHIDServiceClient"> for IOHIDServiceClient {}
);

impl IOHIDServiceClient {
    /// Sets a property on the HID service.
    ///
    ///
    /// Parameter `service`: the HID service to set the property on.
    ///
    ///
    /// Parameter `key`: the property key to set. A list of keys can be found in
    /// <code>
    /// HIDProperties.h
    /// </code>
    /// .
    ///
    ///
    /// Parameter `property`: the value to set the property.
    ///
    ///
    /// Returns: Returns true on success.
    ///
    /// # Safety
    ///
    /// `property` should be of the correct type.
    #[doc(alias = "IOHIDServiceClientSetProperty")]
    #[inline]
    pub unsafe fn set_property(&self, key: &CFString, property: &CFType) -> bool {
        extern "C-unwind" {
            fn IOHIDServiceClientSetProperty(
                service: &IOHIDServiceClient,
                key: &CFString,
                property: &CFType,
            ) -> Boolean;
        }
        let ret = unsafe { IOHIDServiceClientSetProperty(self, key, property) };
        ret != 0
    }

    /// Copies a property from the HID service.
    ///
    ///
    /// Parameter `service`: the HID service to copy the property from.
    ///
    ///
    /// Parameter `key`: the property key to copy. A list of keys can be found in
    /// <code>
    /// HIDProperties.h
    /// </code>
    /// .
    ///
    ///
    /// Returns: Returns a CFTypeRef of the property to be copied on success, otherwise NULL.
    /// Caller is responsible for calling CFRelease on the property.
    #[doc(alias = "IOHIDServiceClientCopyProperty")]
    #[inline]
    pub fn property(&self, key: &CFString) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn IOHIDServiceClientCopyProperty(
                service: &IOHIDServiceClient,
                key: &CFString,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { IOHIDServiceClientCopyProperty(self, key) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

unsafe impl ConcreteType for IOHIDServiceClient {
    /// Returns: Returns the CFTypeID of the
    /// <code>
    /// IOHIDServiceClient
    /// </code>
    /// class.
    #[doc(alias = "IOHIDServiceClientGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOHIDServiceClientGetTypeID() -> CFTypeID;
        }
        unsafe { IOHIDServiceClientGetTypeID() }
    }
}

impl IOHIDServiceClient {
    /// Parameter `service`: the HID service to get the registry ID for.
    ///
    ///
    /// Returns: Returns a CFTypeRef containing the registry ID for the service.
    #[doc(alias = "IOHIDServiceClientGetRegistryID")]
    #[inline]
    pub fn registry_id(&self) -> CFRetained<CFType> {
        extern "C-unwind" {
            fn IOHIDServiceClientGetRegistryID(
                service: &IOHIDServiceClient,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { IOHIDServiceClientGetRegistryID(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Determines if a HID service conforms to a specific usage page and usage.
    ///
    ///
    /// Parameter `usagePage`: A usage page defined in
    /// <code>
    /// IOHIDUsageTables.h
    /// </code>
    /// .
    ///
    ///
    /// Parameter `usage`: A usage defined in
    /// <code>
    /// IOHIDUsageTables.h
    /// </code>
    /// .
    ///
    ///
    /// Returns: Returns true if the service conforms to the provided usage page and usage.
    #[doc(alias = "IOHIDServiceClientConformsTo")]
    #[cfg(feature = "libc")]
    #[inline]
    pub fn conforms_to(&self, usage_page: u32, usage: u32) -> bool {
        extern "C-unwind" {
            fn IOHIDServiceClientConformsTo(
                service: &IOHIDServiceClient,
                usage_page: u32,
                usage: u32,
            ) -> libc::boolean_t;
        }
        let ret = unsafe { IOHIDServiceClientConformsTo(self, usage_page, usage) };
        ret != 0
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/iokit/iohiduserdevice?language=objc)
#[doc(alias = "IOHIDUserDeviceRef")]
#[repr(C)]
pub struct IOHIDUserDevice {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl IOHIDUserDevice {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"__IOHIDUserDevice"> for IOHIDUserDevice {}
);

/// The type block used for IOHIDUserDevice set report calls.
///
///
/// Parameter `type`: The report type.
///
///
/// Parameter `reportID`: The report ID.
///
///
/// Parameter `report`: The report bytes.
///
///
/// Parameter `reportLength`: The length of the report being passed in.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/iohiduserdevicesetreportblock?language=objc)
#[cfg(all(feature = "block2", feature = "hid"))]
pub type IOHIDUserDeviceSetReportBlock =
    *mut block2::DynBlock<dyn Fn(IOHIDReportType, u32, NonNull<u8>, CFIndex) -> IOReturn>;

/// The type block used for IOHIDUserDevice get report calls.
///
///
/// Parameter `type`: The report type.
///
///
/// Parameter `reportID`: The report ID.
///
///
/// Parameter `report`: A buffer to be filled in by the implementor with the report.
///
///
/// Parameter `reportLength`: The length of the report buffer being passed in. The implementor of this
/// block may update the reportLength variable to reflect the actual length of
/// the returned report.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/iohiduserdevicegetreportblock?language=objc)
#[cfg(all(feature = "block2", feature = "hid"))]
pub type IOHIDUserDeviceGetReportBlock =
    *mut block2::DynBlock<dyn Fn(IOHIDReportType, u32, NonNull<u8>, NonNull<CFIndex>) -> IOReturn>;

/// Enumerator of IOHIDUserDeviceOptions to be passed in to
/// IOHIDUserDeviceCreateWithOptions.
///
/// Field: IOHIDUserDeviceOptionsCreateOnActivate
/// Specifies that the kernel HID device should not be created until the call
/// to IOHIDUserDeviceActivate. This may be useful for preventing dropped get/set
/// report calls to the user device.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iokit/iohiduserdeviceoptions?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOHIDUserDeviceOptions(pub IOOptionBits);
impl IOHIDUserDeviceOptions {
    #[doc(alias = "IOHIDUserDeviceOptionsCreateOnActivate")]
    pub const CreateOnActivate: Self = Self(1 << 0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHIDUserDeviceOptions {
    const ENCODING: Encoding = IOOptionBits::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHIDUserDeviceOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl ConcreteType for IOHIDUserDevice {
    /// Returns the type identifier of all IOHIDUserDevice instances.
    #[doc(alias = "IOHIDUserDeviceGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOHIDUserDeviceGetTypeID() -> CFTypeID;
        }
        unsafe { IOHIDUserDeviceGetTypeID() }
    }
}

impl IOHIDUserDevice {
    /// Creates a virtual IOHIDDevice in the kernel.
    ///
    ///
    /// The IOHIDUserDeviceRef represents a virtual IOHIDDevice. In order to create
    /// the device, the entitlement "com.apple.developer.hid.virtual.device" is
    /// required to validate the source of the device.
    ///
    ///
    /// Parameter `allocator`: Allocator to be used during creation.
    ///
    ///
    /// Parameter `properties`: Dictionary containing device properties indexed by keys defined in
    /// IOHIDKeys.h. At the bare minimum, the kIOHIDReportDescriptorKey key must be
    /// provided, where the value represents a CFData representation of the device's
    /// report descriptor.
    ///
    ///
    /// Parameter `options`: Options to be used when creating the device.
    ///
    ///
    /// Returns: Returns a IOHIDUserDeviceRef on success.
    ///
    /// # Safety
    ///
    /// `properties` generics must be of the correct type.
    #[doc(alias = "IOHIDUserDeviceCreateWithProperties")]
    #[inline]
    pub unsafe fn with_properties(
        allocator: Option<&CFAllocator>,
        properties: &CFDictionary,
        options: IOOptionBits,
    ) -> Option<CFRetained<IOHIDUserDevice>> {
        extern "C-unwind" {
            fn IOHIDUserDeviceCreateWithProperties(
                allocator: Option<&CFAllocator>,
                properties: &CFDictionary,
                options: IOOptionBits,
            ) -> Option<NonNull<IOHIDUserDevice>>;
        }
        let ret = unsafe { IOHIDUserDeviceCreateWithProperties(allocator, properties, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Registers a block to receive get report requests.
    ///
    ///
    /// The call to IOHIDUserDeviceRegisterGetReportBlock should be made before the
    /// device is activated. The device must be activated in order to receive
    /// get report requests.
    ///
    ///
    /// Parameter `device`: Reference to a IOHIDUserDeviceRef
    ///
    ///
    /// Parameter `block`: The block to be invoked for get report calls.
    ///
    /// # Safety
    ///
    /// `block` must be a valid pointer.
    #[doc(alias = "IOHIDUserDeviceRegisterGetReportBlock")]
    #[cfg(all(feature = "block2", feature = "hid"))]
    #[inline]
    pub unsafe fn register_get_report_block(&self, block: IOHIDUserDeviceGetReportBlock) {
        extern "C-unwind" {
            fn IOHIDUserDeviceRegisterGetReportBlock(
                device: &IOHIDUserDevice,
                block: IOHIDUserDeviceGetReportBlock,
            );
        }
        unsafe { IOHIDUserDeviceRegisterGetReportBlock(self, block) }
    }

    /// Registers a block to receive set report requests.
    ///
    ///
    /// The call to IOHIDUserDeviceRegisterSetReportBlock should be made before the
    /// device is activated. The device must be activated in order to receive set
    /// report requests.
    ///
    ///
    /// Parameter `device`: Reference to a IOHIDUserDeviceRef
    ///
    ///
    /// Parameter `block`: The block to be invoked for set report calls.
    ///
    /// # Safety
    ///
    /// `block` must be a valid pointer.
    #[doc(alias = "IOHIDUserDeviceRegisterSetReportBlock")]
    #[cfg(all(feature = "block2", feature = "hid"))]
    #[inline]
    pub unsafe fn register_set_report_block(&self, block: IOHIDUserDeviceSetReportBlock) {
        extern "C-unwind" {
            fn IOHIDUserDeviceRegisterSetReportBlock(
                device: &IOHIDUserDevice,
                block: IOHIDUserDeviceSetReportBlock,
            );
        }
        unsafe { IOHIDUserDeviceRegisterSetReportBlock(self, block) }
    }

    /// Sets the dispatch queue to be associated with the IOHIDUserDevice.
    /// This is necessary in order to receive asynchronous events from the kernel.
    ///
    ///
    /// A call to IOHIDUserDeviceSetDispatchQueue should only be made once.
    ///
    /// After a dispatch queue is set, the IOHIDUserDevice must make a call to
    /// activate via IOHIDUserDeviceActivate and cancel via IOHIDUserDeviceCancel.
    /// All calls to "Register" functions should be done before activation and not
    /// after cancellation.
    ///
    ///
    /// Parameter `device`: Reference to an IOHIDUserDevice
    ///
    ///
    /// Parameter `queue`: The dispatch queue to which the event handler block will be submitted.
    ///
    /// # Safety
    ///
    /// `queue` possibly has additional threading requirements.
    #[doc(alias = "IOHIDUserDeviceSetDispatchQueue")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_dispatch_queue(&self, queue: &DispatchQueue) {
        extern "C-unwind" {
            fn IOHIDUserDeviceSetDispatchQueue(device: &IOHIDUserDevice, queue: &DispatchQueue);
        }
        unsafe { IOHIDUserDeviceSetDispatchQueue(self, queue) }
    }

    /// Sets a cancellation handler for the dispatch queue associated with
    /// IOHIDUserDeviceScheduleWithDispatchQueue.
    ///
    ///
    /// The cancellation handler (if specified) will be submitted to the device's
    /// dispatch queue in response to a call to to IOHIDUserDeviceCancel
    /// after all the events have been handled.
    ///
    /// The IOHIDUserDeviceRef should only be released after the device has been
    /// cancelled, and the cancel handler has been called. This is to ensure all
    /// asynchronous objects are released. For example:
    ///
    /// dispatch_block_t cancelHandler = dispatch_block_create(0, ^{
    /// CFRelease(device);
    /// });
    /// IOHIDUserDeviceSetCancelHandler(device, cancelHandler);
    /// IOHIDUserDeviceActivate(device);
    /// IOHIDUserDeviceCancel(device);
    ///
    ///
    /// Parameter `device`: Reference to an IOHIDUserDevice.
    ///
    ///
    /// Parameter `handler`: The cancellation handler block to be associated with the dispatch queue.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer.
    #[doc(alias = "IOHIDUserDeviceSetCancelHandler")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_cancel_handler(&self, handler: dispatch_block_t) {
        extern "C-unwind" {
            fn IOHIDUserDeviceSetCancelHandler(device: &IOHIDUserDevice, handler: dispatch_block_t);
        }
        unsafe { IOHIDUserDeviceSetCancelHandler(self, handler) }
    }

    /// Activates the IOHIDUserDevice object.
    ///
    ///
    /// An IOHIDUserDevice object associated with a dispatch queue is created
    /// in an inactive state. The object must be activated in order to
    /// receive asynchronous events from the kernel.
    ///
    /// A dispatch queue must be set via IOHIDUserDeviceSetDispatchQueue before
    /// activation.
    ///
    /// An activated device must be cancelled via IOHIDUserDeviceCancel. All calls
    /// to "Register" functions should be done before activation and not after
    /// cancellation.
    ///
    /// Calling IOHIDUserDeviceActivate on an active IOHIDUserDevice has no effect.
    ///
    ///
    /// Parameter `device`: Reference to an IOHIDUserDevice.
    #[doc(alias = "IOHIDUserDeviceActivate")]
    #[inline]
    pub fn activate(&self) {
        extern "C-unwind" {
            fn IOHIDUserDeviceActivate(device: &IOHIDUserDevice);
        }
        unsafe { IOHIDUserDeviceActivate(self) }
    }

    /// Cancels the IOHIDUserDevice preventing any further invocation of its event
    /// handler block.
    ///
    ///
    /// Cancelling prevents any further invocation of the event handler block for
    /// the specified dispatch queue, but does not interrupt an event handler block
    /// that is already in progress.
    ///
    /// Explicit cancellation of the IOHIDUserDevice is required, no implicit
    /// cancellation takes place.
    ///
    /// Calling IOHIDUserDeviceCancel on an already cancelled queue has no effect.
    ///
    /// The IOHIDUserDeviceRef should only be released after the device has been
    /// cancelled, and the cancel handler has been called. This is to ensure all
    /// asynchronous objects are released. For example:
    ///
    /// dispatch_block_t cancelHandler = dispatch_block_create(0, ^{
    /// CFRelease(device);
    /// });
    /// IOHIDUserDeviceSetCancelHandler(device, cancelHandler);
    /// IOHIDUserDeviceActivate(device);
    /// IOHIDUserDeviceCancel(device);
    ///
    ///
    /// Parameter `device`: Reference to an IOHIDUserDevice
    #[doc(alias = "IOHIDUserDeviceCancel")]
    #[inline]
    pub fn cancel(&self) {
        extern "C-unwind" {
            fn IOHIDUserDeviceCancel(device: &IOHIDUserDevice);
        }
        unsafe { IOHIDUserDeviceCancel(self) }
    }

    /// Obtains a property from the device.
    ///
    ///
    /// Parameter `key`: The property key.
    ///
    ///
    /// Returns: Returns the property on success.
    #[doc(alias = "IOHIDUserDeviceCopyProperty")]
    #[inline]
    pub fn property(&self, key: &CFString) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn IOHIDUserDeviceCopyProperty(
                device: &IOHIDUserDevice,
                key: &CFString,
            ) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { IOHIDUserDeviceCopyProperty(self, key) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Sets a property on the device.
    ///
    ///
    /// Parameter `key`: The property key.
    ///
    ///
    /// Parameter `value`: The value of the property.
    ///
    ///
    /// Returns: Returns true on success.
    ///
    /// # Safety
    ///
    /// `property` should be of the correct type.
    #[doc(alias = "IOHIDUserDeviceSetProperty")]
    #[inline]
    pub unsafe fn set_property(&self, key: &CFString, property: &CFType) -> bool {
        extern "C-unwind" {
            fn IOHIDUserDeviceSetProperty(
                device: &IOHIDUserDevice,
                key: &CFString,
                property: &CFType,
            ) -> Boolean;
        }
        let ret = unsafe { IOHIDUserDeviceSetProperty(self, key, property) };
        ret != 0
    }

    /// Dispatches a report on behalf of the device.
    ///
    ///
    /// Parameter `device`: Reference to a IOHIDUserDeviceRef.
    ///
    ///
    /// Parameter `timestamp`: mach_absolute_time() based timestamp.
    ///
    ///
    /// Parameter `report`: Buffer containing a HID report.
    ///
    ///
    /// Parameter `reportLength`: The report buffer length.
    ///
    ///
    /// Returns: Returns kIOReturnSuccess on success.
    ///
    /// # Safety
    ///
    /// `report` must be a valid pointer.
    #[doc(alias = "IOHIDUserDeviceHandleReportWithTimeStamp")]
    #[inline]
    pub unsafe fn handle_report_with_time_stamp(
        &self,
        timestamp: u64,
        report: NonNull<u8>,
        report_length: CFIndex,
    ) -> IOReturn {
        extern "C-unwind" {
            fn IOHIDUserDeviceHandleReportWithTimeStamp(
                device: &IOHIDUserDevice,
                timestamp: u64,
                report: NonNull<u8>,
                report_length: CFIndex,
            ) -> IOReturn;
        }
        unsafe { IOHIDUserDeviceHandleReportWithTimeStamp(self, timestamp, report, report_length) }
    }
}

#[deprecated = "renamed to `IOHIDEventSystemClient::new_simple_client`"]
#[inline]
pub extern "C-unwind" fn IOHIDEventSystemClientCreateSimpleClient(
    allocator: Option<&CFAllocator>,
) -> CFRetained<IOHIDEventSystemClient> {
    extern "C-unwind" {
        fn IOHIDEventSystemClientCreateSimpleClient(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<IOHIDEventSystemClient>>;
    }
    let ret = unsafe { IOHIDEventSystemClientCreateSimpleClient(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `IOHIDEventSystemClient::set_property`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDEventSystemClientSetProperty(
    client: &IOHIDEventSystemClient,
    key: &CFString,
    property: &CFType,
) -> bool {
    extern "C-unwind" {
        fn IOHIDEventSystemClientSetProperty(
            client: &IOHIDEventSystemClient,
            key: &CFString,
            property: &CFType,
        ) -> Boolean;
    }
    let ret = unsafe { IOHIDEventSystemClientSetProperty(client, key, property) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDEventSystemClient::property`"]
#[inline]
pub extern "C-unwind" fn IOHIDEventSystemClientCopyProperty(
    client: &IOHIDEventSystemClient,
    key: &CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOHIDEventSystemClientCopyProperty(
            client: &IOHIDEventSystemClient,
            key: &CFString,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOHIDEventSystemClientCopyProperty(client, key) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDEventSystemClient::services`"]
#[inline]
pub extern "C-unwind" fn IOHIDEventSystemClientCopyServices(
    client: &IOHIDEventSystemClient,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn IOHIDEventSystemClientCopyServices(
            client: &IOHIDEventSystemClient,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { IOHIDEventSystemClientCopyServices(client) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDServiceClient::set_property`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDServiceClientSetProperty(
    service: &IOHIDServiceClient,
    key: &CFString,
    property: &CFType,
) -> bool {
    extern "C-unwind" {
        fn IOHIDServiceClientSetProperty(
            service: &IOHIDServiceClient,
            key: &CFString,
            property: &CFType,
        ) -> Boolean;
    }
    let ret = unsafe { IOHIDServiceClientSetProperty(service, key, property) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDServiceClient::property`"]
#[inline]
pub extern "C-unwind" fn IOHIDServiceClientCopyProperty(
    service: &IOHIDServiceClient,
    key: &CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOHIDServiceClientCopyProperty(
            service: &IOHIDServiceClient,
            key: &CFString,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOHIDServiceClientCopyProperty(service, key) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDServiceClient::registry_id`"]
#[inline]
pub extern "C-unwind" fn IOHIDServiceClientGetRegistryID(
    service: &IOHIDServiceClient,
) -> CFRetained<CFType> {
    extern "C-unwind" {
        fn IOHIDServiceClientGetRegistryID(service: &IOHIDServiceClient)
            -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOHIDServiceClientGetRegistryID(service) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `IOHIDServiceClient::conforms_to`"]
#[inline]
pub extern "C-unwind" fn IOHIDServiceClientConformsTo(
    service: &IOHIDServiceClient,
    usage_page: u32,
    usage: u32,
) -> bool {
    extern "C-unwind" {
        fn IOHIDServiceClientConformsTo(
            service: &IOHIDServiceClient,
            usage_page: u32,
            usage: u32,
        ) -> libc::boolean_t;
    }
    let ret = unsafe { IOHIDServiceClientConformsTo(service, usage_page, usage) };
    ret != 0
}

#[deprecated = "renamed to `IOHIDUserDevice::with_properties`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDUserDeviceCreateWithProperties(
    allocator: Option<&CFAllocator>,
    properties: &CFDictionary,
    options: IOOptionBits,
) -> Option<CFRetained<IOHIDUserDevice>> {
    extern "C-unwind" {
        fn IOHIDUserDeviceCreateWithProperties(
            allocator: Option<&CFAllocator>,
            properties: &CFDictionary,
            options: IOOptionBits,
        ) -> Option<NonNull<IOHIDUserDevice>>;
    }
    let ret = unsafe { IOHIDUserDeviceCreateWithProperties(allocator, properties, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(all(feature = "block2", feature = "hid"))]
    #[deprecated = "renamed to `IOHIDUserDevice::register_get_report_block`"]
    pub fn IOHIDUserDeviceRegisterGetReportBlock(
        device: &IOHIDUserDevice,
        block: IOHIDUserDeviceGetReportBlock,
    );
}

extern "C-unwind" {
    #[cfg(all(feature = "block2", feature = "hid"))]
    #[deprecated = "renamed to `IOHIDUserDevice::register_set_report_block`"]
    pub fn IOHIDUserDeviceRegisterSetReportBlock(
        device: &IOHIDUserDevice,
        block: IOHIDUserDeviceSetReportBlock,
    );
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `IOHIDUserDevice::set_dispatch_queue`"]
    pub fn IOHIDUserDeviceSetDispatchQueue(device: &IOHIDUserDevice, queue: &DispatchQueue);
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `IOHIDUserDevice::set_cancel_handler`"]
    pub fn IOHIDUserDeviceSetCancelHandler(device: &IOHIDUserDevice, handler: dispatch_block_t);
}

#[deprecated = "renamed to `IOHIDUserDevice::activate`"]
#[inline]
pub extern "C-unwind" fn IOHIDUserDeviceActivate(device: &IOHIDUserDevice) {
    extern "C-unwind" {
        fn IOHIDUserDeviceActivate(device: &IOHIDUserDevice);
    }
    unsafe { IOHIDUserDeviceActivate(device) }
}

#[deprecated = "renamed to `IOHIDUserDevice::cancel`"]
#[inline]
pub extern "C-unwind" fn IOHIDUserDeviceCancel(device: &IOHIDUserDevice) {
    extern "C-unwind" {
        fn IOHIDUserDeviceCancel(device: &IOHIDUserDevice);
    }
    unsafe { IOHIDUserDeviceCancel(device) }
}

#[deprecated = "renamed to `IOHIDUserDevice::property`"]
#[inline]
pub extern "C-unwind" fn IOHIDUserDeviceCopyProperty(
    device: &IOHIDUserDevice,
    key: &CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOHIDUserDeviceCopyProperty(
            device: &IOHIDUserDevice,
            key: &CFString,
        ) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOHIDUserDeviceCopyProperty(device, key) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOHIDUserDevice::set_property`"]
#[inline]
pub unsafe extern "C-unwind" fn IOHIDUserDeviceSetProperty(
    device: &IOHIDUserDevice,
    key: &CFString,
    property: &CFType,
) -> bool {
    extern "C-unwind" {
        fn IOHIDUserDeviceSetProperty(
            device: &IOHIDUserDevice,
            key: &CFString,
            property: &CFType,
        ) -> Boolean;
    }
    let ret = unsafe { IOHIDUserDeviceSetProperty(device, key, property) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOHIDUserDevice::handle_report_with_time_stamp`"]
    pub fn IOHIDUserDeviceHandleReportWithTimeStamp(
        device: &IOHIDUserDevice,
        timestamp: u64,
        report: NonNull<u8>,
        report_length: CFIndex,
    ) -> IOReturn;
}
