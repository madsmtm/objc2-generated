//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// The name of the IONetworkController class.
pub const kIONetworkControllerClass: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IONetworkController\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOVendor property is a property of IONetworkController objects. It has an OSString value that describes the vendor of the network controller.
///
///
pub const kIOVendor: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOVendor\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOModel property is a property of IONetworkController objects. It has an OSString value that describes the model of the network controller.
///
///
pub const kIOModel: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOModel\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIORevision property is a property of IONetworkController objects. It has an OSString value that describes the revision level of the network controller.
///
///
pub const kIORevision: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IORevision\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOFeatures property is a property of IONetworkController objects. It has an OSNumber value that describes generic features defined by IONetworkController that are supported by the network controller.
///
///
pub const kIOFeatures: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFeatures\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOMediumDictionary property is a property of IONetworkController objects. It has an OSDictionary value that is a container for the collection of IONetworkMedium objects that represent the media types supported by the network controller. Each entry in the dictionary is a key/value pair consisting of the medium name, and a dictionary value that contains the properties for that medium entry.
///
///
pub const kIOMediumDictionary: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOMediumDictionary\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIODefaultMedium property is a property of IONetworkController objects. It has an OSString value that describes the name of the default medium. This definition may change or disappear in the future.
///
///
pub const kIODefaultMedium: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODefaultMedium\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOSelectedMedium property is a property of IONetworkController objects. It has an OSSymbol value that describes the name of the current selected medium. This name can be used as a key into the medium dictionary to gather additional information about the selected medium.
///
///
pub const kIOSelectedMedium: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOSelectedMedium\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOActiveMedium property is a property of IONetworkController objects. It has an OSSymbol value that describes the name of the active medium. This is the name of the medium where an active link has been established. This name can be used as a key into the medium dictionary to gather additional information about the active medium.
///
///
pub const kIOActiveMedium: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOActiveMedium\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOLinkSpeed property is a property of IONetworkController objects. It has an OSNumber value that describes the speed of the link established over the active medium in bits per second.
///
///
pub const kIOLinkSpeed: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOLinkSpeed\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOLinkStatus property is a property of IONetworkController objects. It has an OSNumber value that describes the current network link status. See IONetworkMedium for the definition of the link status bits.
///
///
pub const kIOLinkStatus: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOLinkStatus\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOLinkData property is a property of IONetworkController objects. It has an OSData value that contains additional information describing the active link that was established. Its interpretation is not defined.
///
///
pub const kIOLinkData: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOLinkData\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOPacketFilters property is a property of IONetworkController objects. It has an OSDictionary value that describes the entire set of packet filters supported by the controller. Each entry in the dictionary is a key/value pair consisting of the filter group name, and an OSNumber describing the set of supported filters for that group.
///
///
pub const kIOPacketFilters: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOPacketFilters\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOMACAddress property is a property of IONetworkController objects. It has an OSData value that describes the hardware MAC (media access controller) address, or station address, of the network controller.
///
///
pub const kIOMACAddress: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOMACAddress\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOMaxPacketSize property is a property of IONetworkController objects. It has an OSNumber value that describes the maximum packet size supported by the controller.
///
///
pub const kIOMaxPacketSize: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOMaxPacketSize\0") };
/// A property of IONetworkController objects.
///
/// ## Discussion
///
/// The kIOMinPacketSize property is a property of IONetworkController objects. It has an OSNumber value that describes the minimum packet size supported by the controller.
///
///
pub const kIOMinPacketSize: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOMinPacketSize\0") };
/// The name assigned to the standard network filter group.
pub const kIONetworkFilterGroup: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IONetworkFilterGroup\0") };
/// kIOEthernetControllerClass is the name of the IOEthernetController class.
pub const kIOEthernetControllerClass: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOEthernetController\0") };
/// The number of bytes in an Ethernet hardware address.
pub const kIOEthernetAddressSize: c_uint = 6;
/// The maximum size of an Ethernet packet, including the FCS bytes.
pub const kIOEthernetMaxPacketSize: c_uint = 1518;
/// The minimum size of an Ethernet packet, including the FCS bytes.
pub const kIOEthernetMinPacketSize: c_uint = 64;
/// The size in bytes of the 32-bit CRC value appended to the end of each Ethernet frame.
pub const kIOEthernetCRCSize: c_uint = 4;
/// kIOEthernetWakeOnLANFilterGroup describes the name assigned to the Ethernet Wake-On-LAN filter group. This group represents wake filters that are supported by the controller.
pub const kIOEthernetWakeOnLANFilterGroup: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOEthernetWakeOnLANFilterGroup\0") };
/// kIOEthernetDisabledWakeOnLANFilterGroup describes the name assigned to the disabled Ethernet Wake-On-LAN filter group. This group represents wake filters that are currently disabled. Membership in this group is dynamic.
pub const kIOEthernetDisabledWakeOnLANFilterGroup: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOEthernetDisabledWakeOnLANFilterGroup\0") };
///
/// ## Discussion
///
/// The default access types supported by an IONetworkData object. Allow read() and serialize().
///
///
pub const kIONetworkDataBasicAccessTypes: c_uint =
    kIONetworkDataAccessTypeRead | kIONetworkDataAccessTypeSerialize;
/// A property of IONetworkData objects.
///
/// ## Discussion
///
/// The kIONetworkDataBytes property is an OSData that describes the data buffer of an IONetworkData object. This property is present only if kIONetworkDataAccessTypeSerialize access is supported.
///
///
pub const kIONetworkDataBytes: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Data\0") };
/// A property of IONetworkData objects.
///
/// ## Discussion
///
/// The kIONetworkDataAccessTypes property is an OSNumber that describes the supported access types of an IONetworkData object.
///
///
pub const kIONetworkDataAccessTypes: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Access Types\0") };
/// A property of IONetworkData objects.
///
/// ## Discussion
///
/// The kIONetworkDataSize property is an OSNumber that describes the size of the data buffer of an IONetworkData object.
///
///
pub const kIONetworkDataSize: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Size\0") };
pub const kIONetworkStackUserCommandKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IONetworkStackUserCommand\0") };
pub const kIONetworkStackUserCommand: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IONetworkStackUserCommand\0") };
/// The name of the IOEthernetInterface class.
pub const kIOEthernetInterfaceClass: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOEthernetInterface\0") };
/// A property of IOEthernetInterface objects.
///
/// ## Discussion
///
/// The kIOActivePacketFilters property has an OSDictionary value that describes the current set of packet filters that have been successfully activated. Each entry in the dictionary is a key/value pair consisting of the filter group name, and an OSNumber describing the set of active filters for that group. Entries in this dictionary will mirror those in kIORequiredPacketFilters if the controller has reported success for all filter change requests from the IOEthernetInterface object.
///
///
pub const kIOActivePacketFilters: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOActivePacketFilters\0") };
/// A property of IOEthernetInterface objects.
///
/// ## Discussion
///
/// The kIORequiredPacketFilters property has an OSDictionary value that describes the current set of required packet filters. Each entry in the dictionary is a key/value pair consisting of the filter group name, and an OSNumber describing the set of required filters for that group.
///
///
pub const kIORequiredPacketFilters: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IORequiredPacketFilters\0") };
/// A property of IOEthernetInterface objects.
///
/// ## Discussion
///
/// The kIOMulticastAddressList property is an OSData object that describes the list of multicast addresses that are being used by the controller to match against the destination address of an incoming frame.
///
///
pub const kIOMulticastAddressList: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOMulticastAddressList\0") };
pub const kIOMulticastFilterData: &CStr = kIOMulticastAddressList;
/// The name of the IONetworkInterface class.
pub const kIONetworkInterfaceClass: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IONetworkInterface\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIONetworkData property has an OSDictionary value and is a container for the set of IONetworkData objects managed by the interface. Each entry in the dictionary is a key/value pair consisting of the network data name, and an OSDictionary describing the contents of the network data.
///
///
pub const kIONetworkData: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IONetworkData\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOInterfaceType property has an OSNumber value that specifies the type of network interface that this interface represents. The type constants are defined in bsd/net/if_types.h.
///
///
pub const kIOInterfaceType: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOInterfaceType\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOMaxTransferUnit property has an OSNumber value that specifies the maximum transfer unit for the interface in bytes.
///
///
pub const kIOMaxTransferUnit: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOMaxTransferUnit\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOMediaAddressLength property has an OSNumber value that specifies the size of the media address in bytes.
///
///
pub const kIOMediaAddressLength: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOMediaAddressLength\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOMediaHeaderLength property has an OSNumber value that specifies the size of the media header in bytes.
///
///
pub const kIOMediaHeaderLength: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOMediaHeaderLength\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOInterfaceFlags property has an OSNumber value that specifies the current value of the interface flags. The flag constants are defined in bsd/net/if.h.
///
///
pub const kIOInterfaceFlags: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOInterfaceFlags\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOInterfaceExtraFlags property has an OSNumber value that specifies the current value of the interface eflags. The eflag constants are defined in bsd/net/if.h.
///
///
pub const kIOInterfaceExtraFlags: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOInterfaceExtraFlags\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOInterfaceUnit property has an OSNumber value that describes the unit number assigned to the interface object.
///
///
pub const kIOInterfaceUnit: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOInterfaceUnit\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOInterfaceState property has an OSNumber value that describes the current state of the interface object. This property is not exported to BSD via the ifnet structure.
///
///
pub const kIOInterfaceState: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOInterfaceState\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOInterfaceNamePrefix property has an OSString value that describes the string prefix for the BSD name assigned to the interface.
///
///
pub const kIOInterfaceNamePrefix: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOInterfaceNamePrefix\0") };
/// A property of IONetworkInterface objects.
///
/// ## Discussion
///
/// The kIOInterfaceNamePrefix property has an OSBoolean value that describes whether the interface is the primary or the built-in network interface.
///
///
pub const kIOPrimaryInterface: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOPrimaryInterface\0") };
/// kIOBuiltin is a property of IONetworkInterface objects. It has an OSBoolean value.
///
/// ## Discussion
///
/// The kIOBuiltin property describes whether the interface is built-in.
///
///
pub const kIOBuiltin: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOBuiltin\0") };
/// kIOLocation is a property of IONetworkInterface objects. It has an OSString value.
///
/// ## Discussion
///
/// The kIOLocation property describes the physical location of built-in interfaces.
///
///
pub const kIOLocation: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOLocation\0") };
pub const kIONetworkNoBSDAttachKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IONetworkNoBSDAttach\0") };
///
/// ## Discussion
///
/// Defines the name of an IONetworkData that contains an IONetworkStats.
///
///
pub const kIONetworkStatsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IONetworkStatsKey\0") };
///
/// ## Discussion
///
/// Defines the name of an IONetworkData that contains an IOOutputQueueStats.
///
///
pub const kIOOutputQueueStatsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOOutputQueueStatsKey\0") };
///
/// ## Discussion
///
/// Defines the name of an IONetworkData that contains an IOEthernetStats.
///
///
pub const kIOEthernetStatsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOEthernetStatsKey\0") };
/// A property of IONetworkMedium objects.
///
/// ## Discussion
///
/// The kIOMediumType property is an OSNumber object that describes the type of medium that this object represents.
///
///
pub const kIOMediumType: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Type\0") };
/// A property of IONetworkMedium objects.
///
/// ## Discussion
///
/// The kIOMediumFlags property is an OSNumber object that describes a set of attributes assigned to the medium.
///
///
pub const kIOMediumFlags: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Flags\0") };
/// A property of IONetworkMedium objects.
///
/// ## Discussion
///
/// The kIOMediumSpeed property is an OSNumber object that describes the maximum link speed supported by the medium in bits per second.
///
///
pub const kIOMediumSpeed: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Speed\0") };
/// A property of IONetworkMedium objects.
///
/// ## Discussion
///
/// The kIOMediumIndex property is an OSNumber object that describes an index assigned by the owner of the medium object. Its interpretation is driver specific.
///
///
pub const kIOMediumIndex: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Index\0") };
pub const kIONetworkUserClientTypeID: c_uint = 0xff000001;
pub const kIONUCType: c_uint = 0xff000001;
///
/// ## Discussion
///
/// Reception of unicast packets.
///
///
pub const kIOPacketFilterUnicast: c_uint = 0x1;
///
/// ## Discussion
///
/// Reception of broadcast packets.
///
///
pub const kIOPacketFilterBroadcast: c_uint = 0x2;
///
/// ## Discussion
///
/// Reception of multicast packets addressed to a set of multicast addresses.
///
///
pub const kIOPacketFilterMulticast: c_uint = 0x10;
///
/// ## Discussion
///
/// Reception of all multicast packets.
///
///
pub const kIOPacketFilterMulticastAll: c_uint = 0x20;
///
/// ## Discussion
///
/// Reception of all packets.
///
///
pub const kIOPacketFilterPromiscuous: c_uint = 0x100;
///
/// ## Discussion
///
/// Reception of all packets, including bad packets.
///
///
pub const kIOPacketFilterPromiscuousAll: c_uint = 0x200;

///
/// ## Discussion
///
/// Set this bit in the value returned by getFeatures() to disable the automatic wait for "IOBSD" resource by the IONetworkController::start() method.
///
///
pub const kIONetworkFeatureNoBSDWait: c_uint = 0x001;
///
/// ## Discussion
///
/// Set this bit in the value returned by getFeatures() to indicate the controller supports hardware stripping and stuffing of 802.1q vlan tags. If the controller supports this feature it must enable it when initializing so that all received packets delivered to higher layers have the tag stripped. The controller should use setVlanTag() to provide the tag information out of band.
///
///
pub const kIONetworkFeatureHardwareVlan: c_uint = 0x002;
///
/// ## Discussion
///
/// Set this bit in the value returned by getFeatures() to indicate that the controller can support software based vlan by transmitting and receiving packets 4 bytes longer that normal.
///
///
pub const kIONetworkFeatureSoftwareVlan: c_uint = 0x004;
///
/// ## Discussion
///
/// Set this bit if the driver is capable of handling packets coming down from the network stack that reside in virtually, but not in physically contiguous span of the external mbuf clusters. In this case, the data area of a packet in the external mbuf cluster might cross one or more physical pages that are disjoint, depending on the interface MTU and the packet size. Such a use of larger than system page size clusters by the network stack is done for better system efficiency. Drivers that utilize the IOMbufNaturalMemoryCursor with the getPhysicalSegmentsWithCoalesce interfaces and enumerate the list of vectors should set this flag for possible gain in performance during bulk data transfer.
///
///
pub const kIONetworkFeatureMultiPages: c_uint = 0x008;
///
/// ## Discussion
///
/// Set this bit to advertise support for TCP/IPv4 segmentation offload.
///
///
pub const kIONetworkFeatureTSOIPv4: c_uint = 0x010;
///
/// ## Discussion
///
/// Set this bit to advertise support for TCP/IPv6 segmentation offload.
///
///
pub const kIONetworkFeatureTSOIPv6: c_uint = 0x020;
///
/// ## Discussion
///
/// Set this bit to advertise the capability to report per-packet transmit completion status. See `IONetworkInterface::reportTransmitCompletionStatus`.
///
///
pub const kIONetworkFeatureTransmitCompletionStatus: c_uint = 0x040;
pub const kIONetworkFeatureHWTimeStamp: c_uint = 0x080;
pub const kIONetworkFeatureSWTimeStamp: c_uint = 0x100;
pub const kIONetworkFeatureLRO: c_uint = 0x200;

///
/// ## Discussion
///
/// Reception of a Magic Packet.
///
///
pub const kIOEthernetWakeOnMagicPacket: c_uint = 0x00000001;
///
/// ## Discussion
///
/// Reception of a packet which passes through any of the address filtering mechanisms based on its destination Ethernet address. This may include unicast, broadcast, or multicast addresses depending on the current state and setting of the corresponding packet filters.
///
///
pub const kIOEthernetWakeOnPacketAddressMatch: c_uint = 0x00000002;

///
/// ## Discussion
///
/// Read access.
///
///
pub const kIONetworkDataAccessTypeRead: c_uint = 0x01;
///
/// ## Discussion
///
/// Write access.
///
///
pub const kIONetworkDataAccessTypeWrite: c_uint = 0x02;
///
/// ## Discussion
///
/// Reset access.
///
///
pub const kIONetworkDataAccessTypeReset: c_uint = 0x04;
///
/// ## Discussion
///
/// Serialization access.
///
///
pub const kIONetworkDataAccessTypeSerialize: c_uint = 0x08;
pub const kIONetworkDataAccessTypeMask: c_uint = 0xff;

///
/// ## Discussion
///
/// An internal data buffer allocated by the init() method.
///
///
pub const kIONetworkDataBufferTypeInternal: c_uint = 0;
///
/// ## Discussion
///
/// An external (persistent) data buffer.
///
///
pub const kIONetworkDataBufferTypeExternal: c_uint = 1;
///
/// ## Discussion
///
/// No data buffer. The only useful action perfomed by an IONetworkData object with this buffer type is to call the access notification handler.
///
///
pub const kIONetworkDataBufferTypeNone: c_uint = 2;

pub const kIONetworkStackRegisterInterfaceWithUnit: c_uint = 0;
pub const kIONetworkStackRegisterInterfaceWithLowestUnit: c_uint = 1;
pub const kIONetworkStackRegisterInterfaceAll: c_uint = 2;

///
/// ## Discussion
///
/// The interface object has registered with the data link layer.
///
///
pub const kIONetworkInterfaceRegisteredState: c_uint = 0x1;
///
/// ## Discussion
///
/// One or more clients have an open on the interface object.
///
///
pub const kIONetworkInterfaceOpenedState: c_uint = 0x2;
///
/// ## Discussion
///
/// The interface is temporarily unable to service its clients. This will occur when the network controller that is servicing the interface has entered a low power state that renders it unusable.
///
///
pub const kIONetworkInterfaceDisabledState: c_uint = 0x4;

///
/// ## Overview
///
/// Generic network statistics structure.
///
///
/// Generic network statistics structure.
/// Field: inputPackets count input packets.
/// Field: inputErrors count input errors.
/// Field: outputPackets count output packets.
/// Field: outputErrors count output errors.
/// Field: collisions count collisions on CDMA networks.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IONetworkStats {
    pub inputPackets: u32,
    pub inputErrors: u32,
    pub outputPackets: u32,
    pub outputErrors: u32,
    pub collisions: u32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IONetworkStats {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IONetworkStats {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Statistics recorded by IOOutputQueue objects.
///
///
/// Statistics recorded by IOOutputQueue objects.
/// Field: capacity queue capacity.
/// Field: size current size of the queue.
/// Field: peakSize peak size of the queue.
/// Field: dropCount number of packets dropped.
/// Field: outputCount number of output packets.
/// Field: retryCount number of retries.
/// Field: stallCount number of queue stalls.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOOutputQueueStats {
    pub capacity: u32,
    pub size: u32,
    pub peakSize: u32,
    pub dropCount: u32,
    pub outputCount: u32,
    pub retryCount: u32,
    pub stallCount: u32,
    pub reserved: [u32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOOutputQueueStats {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOOutputQueueStats {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Ethernet MIB statistics structure.
///
///
/// Ethernet MIB statistics structure.
/// Field: alignmentErrors            dot3StatsAlignmentErrors.
/// Field: fcsErrors                  dot3StatsFCSErrors.
/// Field: singleCollisionFrames      dot3StatsSingleCollisionFrames.
/// Field: multipleCollisionFrames    dot3StatsMultipleCollisionFrames.
/// Field: sqeTestErrors              dot3StatsSQETestErrors.
/// Field: deferredTransmissions      dot3StatsDeferredTransmissions.
/// Field: lateCollisions             dot3StatsLateCollisions.
/// Field: excessiveCollisions        dot3StatsExcessiveCollisions.
/// Field: internalMacTransmitErrors  dot3StatsInternalMacTransmitErrors.
/// Field: carrierSenseErrors         dot3StatsCarrierSenseErrors.
/// Field: frameTooLongs              dot3StatsFrameTooLongs.
/// Field: internalMacReceiveErrors   dot3StatsInternalMacReceiveErrors.
/// Field: etherChipSet               dot3StatsEtherChipSet.
/// Field: missedFrames               dot3StatsMissedFrames (not in RFC1650).
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IODot3StatsEntry {
    pub alignmentErrors: u32,
    pub fcsErrors: u32,
    pub singleCollisionFrames: u32,
    pub multipleCollisionFrames: u32,
    pub sqeTestErrors: u32,
    pub deferredTransmissions: u32,
    pub lateCollisions: u32,
    pub excessiveCollisions: u32,
    pub internalMacTransmitErrors: u32,
    pub carrierSenseErrors: u32,
    pub frameTooLongs: u32,
    pub internalMacReceiveErrors: u32,
    pub etherChipSet: u32,
    pub missedFrames: u32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODot3StatsEntry {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODot3StatsEntry {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Collision statistics structure.
///
///
/// Collision statistics structure.
/// Field: collFrequencies            dot3StatsCollFrequencies.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IODot3CollEntry {
    pub collFrequencies: [u32; 16],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODot3CollEntry {
    const ENCODING: Encoding = Encoding::Struct("?", &[<[u32; 16]>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODot3CollEntry {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Extra receiver statistics not defined by RFC1650.
///
///
/// Extra receiver statistics not defined by RFC1650.
/// Field: overruns            receiver overruns.
/// Field: watchdogTimeouts    watchdog timer expirations.
/// Field: frameTooShorts      runt frames.
/// Field: collisionErrors     frames damages by late collision.
/// Field: phyErrors           PHY receive errors.
/// Field: timeouts            receiver timeouts.
/// Field: interrupts          receiver interrupts.
/// Field: resets              receiver resets.
/// Field: resourceErrors      receiver resource shortages.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IODot3RxExtraEntry {
    pub overruns: u32,
    pub watchdogTimeouts: u32,
    pub frameTooShorts: u32,
    pub collisionErrors: u32,
    pub phyErrors: u32,
    pub timeouts: u32,
    pub interrupts: u32,
    pub resets: u32,
    pub resourceErrors: u32,
    pub reserved: [u32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODot3RxExtraEntry {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODot3RxExtraEntry {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Extra transmitter statistics not defined by RFC1650.
///
///
/// Extra transmitter statistics not defined by RFC1650.
/// Field: underruns           transmit underruns.
/// Field: jabbers             jabber events.
/// Field: phyErrors           PHY transmit errors.
/// Field: timeouts            transmitter timeouts.
/// Field: interrupts          transmitter interrupts.
/// Field: resets              transmitter resets.
/// Field: resourceErrors      transmitter resource shortages.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IODot3TxExtraEntry {
    pub underruns: u32,
    pub jabbers: u32,
    pub phyErrors: u32,
    pub timeouts: u32,
    pub interrupts: u32,
    pub resets: u32,
    pub resourceErrors: u32,
    pub reserved: [u32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODot3TxExtraEntry {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODot3TxExtraEntry {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Aggregate Ethernet statistics structure.
///
///
/// Aggregate Ethernet statistics structure.
/// Field: dot3StatsEntry      IODot3StatsEntry statistics group.
/// Field: dot3CollEntry       IODot3CollEntry statistics group.
/// Field: dot3RxExtraEntry    IODot3RxExtraEntry statistics group.
/// Field: dot3TxExtraEntry    IODot3TxExtraEntry statistics group.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOEthernetStats {
    pub dot3StatsEntry: IODot3StatsEntry,
    pub dot3CollEntry: IODot3CollEntry,
    pub dot3RxExtraEntry: IODot3RxExtraEntry,
    pub dot3TxExtraEntry: IODot3TxExtraEntry,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOEthernetStats {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <IODot3StatsEntry>::ENCODING,
            <IODot3CollEntry>::ENCODING,
            <IODot3RxExtraEntry>::ENCODING,
            <IODot3TxExtraEntry>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOEthernetStats {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Discussion
///
/// A 32-bit value divided into fields which describes a single medium type.
///
///
/// A 32-bit value divided into fields which describes
/// a single medium type.
pub type IOMediumType = u32;

pub const kIOMediumEthernet: c_uint = 32;
pub const kIOMediumEthernetAuto: c_uint = 32;
pub const kIOMediumEthernetManual: c_uint = 33;
pub const kIOMediumEthernetNone: c_uint = 34;
pub const kIOMediumEthernet10BaseT: c_uint = 35;
pub const kIOMediumEthernet10Base2: c_uint = 36;
pub const kIOMediumEthernet10Base5: c_uint = 37;
pub const kIOMediumEthernet100BaseTX: c_uint = 38;
pub const kIOMediumEthernet100BaseFX: c_uint = 39;
pub const kIOMediumEthernet100BaseT4: c_uint = 40;
pub const kIOMediumEthernet100BaseVG: c_uint = 41;
pub const kIOMediumEthernet100BaseT2: c_uint = 42;
pub const kIOMediumEthernet1000BaseSX: c_uint = 43;
pub const kIOMediumEthernet10BaseSTP: c_uint = 44;
pub const kIOMediumEthernet10BaseFL: c_uint = 45;
pub const kIOMediumEthernet1000BaseLX: c_uint = 46;
pub const kIOMediumEthernet1000BaseCX: c_uint = 47;
pub const kIOMediumEthernet1000BaseTX: c_uint = 48;
pub const kIOMediumEthernet1000BaseT: c_uint = 48;
pub const kIOMediumEthernetHomePNA1: c_uint = 49;
pub const kIOMediumEthernet10GBaseSR: c_uint = 50;
pub const kIOMediumEthernet10GBaseLR: c_uint = 51;
pub const kIOMediumEthernet10GBaseCX4: c_uint = 52;
pub const kIOMediumEthernet10GBaseT: c_uint = 53;
pub const kIOMediumEthernet2500BaseT: c_uint = 54;
pub const kIOMediumEthernet5000BaseT: c_uint = 55;

pub const kIOMediumIEEE80211: c_uint = 128;
pub const kIOMediumIEEE80211Auto: c_uint = 128;
pub const kIOMediumIEEE80211Manual: c_uint = 129;
pub const kIOMediumIEEE80211None: c_uint = 130;
pub const kIOMediumIEEE80211FH1: c_uint = 131;
pub const kIOMediumIEEE80211FH2: c_uint = 132;
pub const kIOMediumIEEE80211DS2: c_uint = 133;
pub const kIOMediumIEEE80211DS5: c_uint = 134;
pub const kIOMediumIEEE80211DS11: c_uint = 135;
pub const kIOMediumIEEE80211DS1: c_uint = 136;
pub const kIOMediumIEEE80211OptionAdhoc: c_uint = 256;

pub const kIOMediumOptionFullDuplex: c_uint = 1048576;
pub const kIOMediumOptionHalfDuplex: c_uint = 2097152;
pub const kIOMediumOptionFlowControl: c_uint = 4194304;
pub const kIOMediumOptionEEE: c_uint = 8388608;
pub const kIOMediumOptionFlag0: c_uint = 16777216;
pub const kIOMediumOptionFlag1: c_uint = 33554432;
pub const kIOMediumOptionFlag2: c_uint = 67108864;
pub const kIOMediumOptionLoopback: c_uint = 134217728;

pub const kIONetworkLinkValid: c_uint = 1;
pub const kIONetworkLinkActive: c_uint = 2;
pub const kIONetworkLinkNoNetworkChange: c_uint = 4;

pub const kIONUCResetNetworkDataIndex: c_uint = 0;
pub const kIONUCWriteNetworkDataIndex: c_uint = 1;
pub const kIONUCReadNetworkDataIndex: c_uint = 2;
pub const kIONUCGetNetworkDataCapacityIndex: c_uint = 3;
pub const kIONUCGetNetworkDataHandleIndex: c_uint = 4;
pub const kIONUCLastIndex: c_uint = 5;

pub type IONDHandle = u32;

extern "C-unwind" {
    /// Open a connection to an IONetworkInterface object. An IONetworkUserClient object is created to manage the connection.
    /// Open a connection to an IONetworkInterface object.
    /// An IONetworkUserClient object is created to manage the connection.
    ///
    /// # Safety
    ///
    /// `con` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IONetworkOpen(obj: io_object_t, con: *mut io_connect_t) -> IOReturn;
}

/// Close the connection to an IONetworkInterface object.
/// Close the connection to an IONetworkInterface object.
#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IONetworkClose(con: io_connect_t) -> IOReturn {
    extern "C-unwind" {
        fn IONetworkClose(con: io_connect_t) -> IOReturn;
    }
    unsafe { IONetworkClose(con) }
}

extern "C-unwind" {
    /// Write to the buffer of a network data object.
    ///
    /// Parameters:
    /// - conObj: The connection object.
    ///
    /// - dataHandle: The handle of a network data object.
    ///
    /// - srcBuf: The data to write is taken from this buffer.
    ///
    /// - inSize: The size of the source buffer.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// kIOReturnSuccess on success, or an error code otherwise.
    ///
    ///
    /// Write to the buffer of a network data object.
    ///
    /// Parameter `conObj`: The connection object.
    ///
    /// Parameter `dataHandle`: The handle of a network data object.
    ///
    /// Parameter `srcBuf`: The data to write is taken from this buffer.
    ///
    /// Parameter `inSize`: The size of the source buffer.
    ///
    /// Returns: kIOReturnSuccess on success, or an error code otherwise.
    ///
    /// # Safety
    ///
    /// `src_buf` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IONetworkWriteData(
        con_obj: io_connect_t,
        data_handle: IONDHandle,
        src_buf: *mut u8,
        in_size: u32,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Read the buffer of a network data object.
    ///
    /// Parameters:
    /// - conObj: The connection object.
    ///
    /// - dataHandle: The handle of a network data object.
    ///
    /// - destBuf: The buffer where the data read shall be written to.
    ///
    /// - inOutSizeP: Pointer to an integer that the caller must initialize to contain the size of the buffer. This function will overwrite it with the actual number of bytes written to the buffer.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// kIOReturnSuccess on success, or an error code otherwise.
    ///
    ///
    /// Read the buffer of a network data object.
    ///
    /// Parameter `conObj`: The connection object.
    ///
    /// Parameter `dataHandle`: The handle of a network data object.
    ///
    /// Parameter `destBuf`: The buffer where the data read shall be written to.
    ///
    /// Parameter `inOutSizeP`: Pointer to an integer that the caller must initialize
    /// to contain the size of the buffer. This function will overwrite
    /// it with the actual number of bytes written to the buffer.
    ///
    /// Returns: kIOReturnSuccess on success, or an error code otherwise.
    ///
    /// # Safety
    ///
    /// - `dest_buf` must be a valid pointer.
    /// - `in_out_size_p` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IONetworkReadData(
        con_obj: io_connect_t,
        data_handle: IONDHandle,
        dest_buf: *mut u8,
        in_out_size_p: *mut u32,
    ) -> IOReturn;
}

/// Fill the buffer of a network data object with zeroes.
///
/// Parameters:
/// - conObject: The connection object.
///
/// - dataHandle: The handle of a network data object.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// kIOReturnSuccess on success, or an error code otherwise.
///
///
/// Fill the buffer of a network data object with zeroes.
///
/// Parameter `conObject`: The connection object.
///
/// Parameter `dataHandle`: The handle of a network data object.
///
/// Returns: kIOReturnSuccess on success, or an error code otherwise.
#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IONetworkResetData(
    con_object: io_connect_t,
    data_handle: IONDHandle,
) -> IOReturn {
    extern "C-unwind" {
        fn IONetworkResetData(con_object: io_connect_t, data_handle: IONDHandle) -> IOReturn;
    }
    unsafe { IONetworkResetData(con_object, data_handle) }
}

extern "C-unwind" {
    /// Get the capacity (in bytes) of a network data object.
    ///
    /// Parameters:
    /// - conObject: The connection object.
    ///
    /// - dataHandle: The handle of a network data object.
    ///
    /// - capacityP: Upon success, the capacity is written to this address.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// kIOReturnSuccess on success, or an error code otherwise.
    ///
    ///
    /// Get the capacity (in bytes) of a network data object.
    ///
    /// Parameter `conObject`: The connection object.
    ///
    /// Parameter `dataHandle`: The handle of a network data object.
    ///
    /// Parameter `capacityP`: Upon success, the capacity is written to this address.
    ///
    /// Returns: kIOReturnSuccess on success, or an error code otherwise.
    ///
    /// # Safety
    ///
    /// `capacity_p` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IONetworkGetDataCapacity(
        con_object: io_connect_t,
        data_handle: IONDHandle,
        capacity_p: *mut u32,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Get the handle of a network data object with the given name.
    ///
    /// Parameters:
    /// - conObject: The connection object.
    ///
    /// - dataName: The name of the network data object.
    ///
    /// - dataHandleP: Upon success, the handle is written to this address.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// kIOReturnSuccess on success, or an error code otherwise.
    ///
    ///
    /// Get the handle of a network data object with the given name.
    ///
    /// Parameter `conObject`: The connection object.
    ///
    /// Parameter `dataName`: The name of the network data object.
    ///
    /// Parameter `dataHandleP`: Upon success, the handle is written to this address.
    ///
    /// Returns: kIOReturnSuccess on success, or an error code otherwise.
    ///
    /// # Safety
    ///
    /// - `data_name` must be a valid pointer.
    /// - `data_handle_p` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IONetworkGetDataHandle(
        con_object: io_connect_t,
        data_name: *const c_char,
        data_handle_p: *mut IONDHandle,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Set the packet filters for a given filter group.
    ///
    /// Parameters:
    /// - connect: The connection object returned from IONetworkOpen().
    ///
    /// - filterGroup: The name of the packet filter group.
    ///
    /// - filtersMask: A mask of filters to set.
    ///
    /// - options: No options are currently defined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// An IOReturn error code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A network controller may support a number of packets filters that can accept or reject a type of packet seen on the network. A filter group identifies a set of related filters, such as all filters that will allow a packet to pass upstream based on the destination address encoded within the packet. This function allows an user-space program to set the filtering performed by a given filter group.
    ///
    ///
    /// Set the packet filters for a given filter group.
    ///
    /// A network controller may support a number of packets filters
    /// that can accept or reject a type of packet seen on the network. A filter
    /// group identifies a set of related filters, such as all filters that will
    /// allow a packet to pass upstream based on the destination address encoded
    /// within the packet. This function allows an user-space program to set the
    /// filtering performed by a given filter group.
    ///
    /// Parameter `connect`: The connection object returned from IONetworkOpen().
    ///
    /// Parameter `filterGroup`: The name of the packet filter group.
    ///
    /// Parameter `filtersMask`: A mask of filters to set.
    ///
    /// Parameter `options`: No options are currently defined.
    ///
    /// Returns: An IOReturn error code.
    ///
    /// # Safety
    ///
    /// `filter_group` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IONetworkSetPacketFiltersMask(
        connect: io_connect_t,
        filter_group: *mut io_name_t,
        filters_mask: u32,
        options: IOOptionBits,
    ) -> IOReturn;
}

///
/// ## Discussion
///
/// Indicate the filters that are supported by the hardware.
///
///
pub const kIONetworkSupportedPacketFilters: c_uint = 0x0001;

extern "C-unwind" {
    /// Get the packet filters for a given filter group.
    ///
    /// Parameters:
    /// - connect: The connection object returned from IONetworkOpen().
    ///
    /// - filterGroup: The name of the packet filter group.
    ///
    /// - filtersMask: Pointer to the return value containing a mask of packet filters.
    ///
    /// - options: kIONetworkSupportedPacketFilters may be set to fetch the filters that are supported by the hardware.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// An IOReturn error code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A network controller may support a number of packets filters that can accept or reject a type of packet seen on the network. A filter group identifies a set of related filters, such as all filters that will allow a packet to pass upstream based on the destination address encoded within the packet. This function allows an user-space program to get the filtering performed by a given filter group.
    ///
    ///
    /// Get the packet filters for a given filter group.
    ///
    /// A network controller may support a number of packets filters
    /// that can accept or reject a type of packet seen on the network. A filter
    /// group identifies a set of related filters, such as all filters that will
    /// allow a packet to pass upstream based on the destination address encoded
    /// within the packet. This function allows an user-space program to get the
    /// filtering performed by a given filter group.
    ///
    /// Parameter `connect`: The connection object returned from IONetworkOpen().
    ///
    /// Parameter `filterGroup`: The name of the packet filter group.
    ///
    /// Parameter `filtersMask`: Pointer to the return value containing a mask of
    /// packet filters.
    ///
    /// Parameter `options`: kIONetworkSupportedPacketFilters may be set to fetch the
    /// filters that are supported by the hardware.
    ///
    /// Returns: An IOReturn error code.
    ///
    /// # Safety
    ///
    /// - `filter_group` must be a valid pointer.
    /// - `filters_mask` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IONetworkGetPacketFiltersMask(
        connect: io_connect_t,
        filter_group: *mut io_name_t,
        filters_mask: *mut u32,
        options: IOOptionBits,
    ) -> IOReturn;
}
