//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

pub const kIOAcceleratorClassName: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOAccelerator\0") };
pub const kCurrentGraphicsInterfaceVersion: c_uint = 1;
pub const kCurrentGraphicsInterfaceRevision: c_uint = 2;
pub const kIOAccelTypesKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOAccelTypes\0") };
pub const kIOAccelIndexKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOAccelIndex\0") };
pub const kIOAccelRevisionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOAccelRevision\0") };
pub const IO1BitIndexedPixels: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"P\0") };
pub const IO2BitIndexedPixels: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"PP\0") };
pub const IO4BitIndexedPixels: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"PPPP\0") };
pub const IO8BitIndexedPixels: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"PPPPPPPP\0") };
pub const IO16BitDirectPixels: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"-RRRRRGGGGGBBBBB\0") };
pub const IO32BitDirectPixels: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"--------RRRRRRRRGGGGGGGGBBBBBBBB\0") };
pub const kIO30BitDirectPixels: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"--RRRRRRRRRRGGGGGGGGGGBBBBBBBBBB\0") };
pub const kIO64BitDirectPixels: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"-16R16G16B16\0") };
pub const kIO16BitFloatPixels: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"-16FR16FG16FB16\0") };
pub const kIO32BitFloatPixels: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"-32FR32FG32FB32\0") };
pub const IOYUV422Pixels: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Y4U2V2\0") };
pub const IO8BitOverlayPixels: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"O8\0") };
pub const IOPagedPixels: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"Page1\0") };
pub const IO_SampleTypeAlpha: c_uint = b'A' as _;
pub const IO_SampleTypeSkip: c_uint = b'-' as _;
pub const kIOFBSetGammaSyncNotSpecified: c_int = -1;
pub const kIOFBSetGammaSyncNoSync: c_uint = 0;
pub const kIOFBSetGammaSyncVerticalBlankSync: c_uint = 1;
pub const kIODisplayAttributesKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayAttributes\0") };
pub const kIODisplaySupportsUnderscanKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplaySupportsUnderscan\0") };
pub const kIODisplaySupportsBasicAudioKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplaySupportsBasicAudio\0") };
pub const kIODisplaySupportsYCbCr444Key: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplaySupportsYCbCr444\0") };
pub const kIODisplaySupportsYCbCr422Key: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplaySupportsYCbCr422\0") };
pub const kIODisplaySelectedColorModeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"cmod\0") };
pub const kIOFramebufferInfoKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFramebufferInformation\0") };
pub const kIOFBWidthKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBWidth\0") };
pub const kIOFBHeightKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBHeight\0") };
pub const kIOFBRefreshRateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBRefreshRate\0") };
pub const kIOFBFlagsKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBFlags\0") };
pub const kIOFBBytesPerRowKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBBytesPerRow\0") };
pub const kIOFBBytesPerPlaneKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBBytesPerPlane\0") };
pub const kIOFBBitsPerPixelKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBBitsPerPixel\0") };
pub const kIOFBComponentCountKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBComponentCount\0") };
pub const kIOFBBitsPerComponentKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBBitsPerComponent\0") };
pub const kIOFBDetailedTimingsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBDetailedTimings\0") };
pub const kIOFBTimingRangeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBTimingRange\0") };
pub const kIOFBScalerInfoKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBScalerInfo\0") };
pub const kIOFBCursorInfoKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBCursorInfo\0") };
pub const kIOFBHDMIDongleROMKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBHDMIDongleROM\0") };
pub const kIOFBHostAccessFlagsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBHostAccessFlags\0") };
pub const kIOFBMemorySizeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBMemorySize\0") };
pub const kIOFBNeedsRefreshKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBNeedsRefresh\0") };
pub const kIOFBProbeOptionsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBProbeOptions\0") };
pub const kIOFBGammaWidthKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBGammaWidth\0") };
pub const kIOFBGammaCountKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBGammaCount\0") };
pub const kIOFBCLUTDeferKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBCLUTDefer\0") };
pub const kIOFBDisplayPortConfigurationDataKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"dpcd-registers\0") };
pub const kIOHibernatePreviewActiveKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHibernatePreviewActive\0") };
pub const kIOHibernateEFIGfxStatusKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IOHibernateEFIGfxStatus\0") };
pub const kIOFBAVSignalTypeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"av-signal-type\0") };
pub const kIOFBConfigKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBConfig\0") };
pub const kIOFBModesKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"IOFBModes\0") };
pub const kIOFBModeIDKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"ID\0") };
pub const kIOFBModeDMKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"DM\0") };
pub const kIOFBModeTMKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"TM\0") };
pub const kIOFBModeAIDKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"AID\0") };
pub const kIOFBModeDFKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"DF\0") };
pub const kIOFBModePIKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"PI\0") };
pub const kIODisplayEDIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayEDID\0") };
pub const kIODisplayEDIDOriginalKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayEDIDOriginal\0") };
pub const kIODisplayLocationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayLocation\0") };
pub const kIODisplayConnectFlagsKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayConnectFlags\0") };
pub const kIODisplayHasBacklightKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayHasBacklight\0") };
pub const kIODisplayIsDigitalKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayIsDigital\0") };
pub const kDisplayBundleKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayBundle\0") };
pub const kAppleDisplayTypeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AppleDisplayType\0") };
pub const kAppleSenseKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"AppleSense\0") };
pub const kIODisplayMCCSVersionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayMCCSVersion\0") };
pub const kIODisplayTechnologyTypeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayTechnologyType\0") };
pub const kIODisplayUsageTimeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayUsageTime\0") };
pub const kIODisplayFirmwareLevelKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayFirmwareLevel\0") };
pub const kDisplayVendorID: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayVendorID\0") };
pub const kDisplayProductID: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayProductID\0") };
pub const kDisplaySerialNumber: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplaySerialNumber\0") };
pub const kDisplaySerialString: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplaySerialString\0") };
pub const kDisplayWeekOfManufacture: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayWeekManufacture\0") };
pub const kDisplayYearOfManufacture: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayYearManufacture\0") };
pub const kDisplayProductName: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayProductName\0") };
pub const kDisplayWhitePointX: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayWhitePointX\0") };
pub const kDisplayWhitePointY: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayWhitePointY\0") };
pub const kDisplayRedPointX: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayRedPointX\0") };
pub const kDisplayRedPointY: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayRedPointY\0") };
pub const kDisplayGreenPointX: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayGreenPointX\0") };
pub const kDisplayGreenPointY: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayGreenPointY\0") };
pub const kDisplayBluePointX: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayBluePointX\0") };
pub const kDisplayBluePointY: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayBluePointY\0") };
pub const kDisplayWhiteGamma: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayWhiteGamma\0") };
pub const kDisplayRedGamma: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayRedGamma\0") };
pub const kDisplayGreenGamma: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayGreenGamma\0") };
pub const kDisplayBlueGamma: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayBlueGamma\0") };
pub const kDisplayGammaChannels: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayGammaChannels\0") };
pub const kDisplayGammaEntryCount: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayGammaEntryCount\0") };
pub const kDisplayGammaEntrySize: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayGammaEntrySize\0") };
pub const kDisplayGammaTable: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayGammaTable\0") };
pub const kDisplayBrightnessAffectsGamma: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayBrightnessAffectsGamma\0") };
pub const kDisplayViewAngleAffectsGamma: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayViewAngleAffectsGamma\0") };
pub const kDisplayCSProfile: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayCSProfile\0") };
pub const kDisplayHorizontalImageSize: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayHorizontalImageSize\0") };
pub const kDisplayVerticalImageSize: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayVerticalImageSize\0") };
pub const kDisplayFixedPixelFormat: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplayFixedPixelFormat\0") };
pub const kDisplaySubPixelLayout: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplaySubPixelLayout\0") };
pub const kDisplaySubPixelConfiguration: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplaySubPixelConfiguration\0") };
pub const kDisplaySubPixelShape: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"DisplaySubPixelShape\0") };
pub const kIODisplayOverrideMatchingKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayOverrideMatching\0") };
pub const kIODisplayParametersKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayParameters\0") };
pub const kIODisplayGUIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayGUID\0") };
pub const kIODisplayValueKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"value\0") };
pub const kIODisplayMinValueKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"min\0") };
pub const kIODisplayMaxValueKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"max\0") };
pub const kIODisplayBrightnessProbeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"brightness-probe\0") };
pub const kIODisplayLinearBrightnessProbeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"linear-brightness-probe\0") };
pub const kIODisplayBrightnessKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"brightness\0") };
pub const kIODisplayLinearBrightnessKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"linear-brightness\0") };
pub const kIODisplayUsableLinearBrightnessKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"usable-linear-brightness\0") };
pub const kIODisplayBrightnessFadeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"brightness-fade\0") };
pub const kIODisplayContrastKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"contrast\0") };
pub const kIODisplayHorizontalPositionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"horizontal-position\0") };
pub const kIODisplayHorizontalSizeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"horizontal-size\0") };
pub const kIODisplayVerticalPositionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"vertical-position\0") };
pub const kIODisplayVerticalSizeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"vertical-size\0") };
pub const kIODisplayTrapezoidKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"trapezoid\0") };
pub const kIODisplayPincushionKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"pincushion\0") };
pub const kIODisplayParallelogramKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"parallelogram\0") };
pub const kIODisplayRotationKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"rotation\0") };
pub const kIODisplayTheatreModeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"theatre-mode\0") };
pub const kIODisplayTheatreModeWindowKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"theatre-mode-window\0") };
pub const kIODisplayOverscanKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"oscn\0") };
pub const kIODisplayVideoBestKey: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"vbst\0") };
pub const kIODisplaySpeakerVolumeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"speaker-volume\0") };
pub const kIODisplaySpeakerSelectKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"speaker-select\0") };
pub const kIODisplayMicrophoneVolumeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"microphone-volume\0") };
pub const kIODisplayAmbientLightSensorKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ambient-light-sensor\0") };
pub const kIODisplayAudioMuteAndScreenBlankKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"audio-mute-and-screen-blank\0") };
pub const kIODisplayAudioTrebleKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"audio-treble\0") };
pub const kIODisplayAudioBassKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"audio-bass\0") };
pub const kIODisplayAudioBalanceLRKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"audio-balance-LR\0") };
pub const kIODisplayAudioProcessorModeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"audio-processor-mode\0") };
pub const kIODisplayPowerModeKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"power-mode\0") };
pub const kIODisplayManufacturerSpecificKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"manufacturer-specific\0") };
pub const kIODisplayPowerStateKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"dsyp\0") };
pub const kIODisplayControllerIDKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayControllerID\0") };
pub const kIODisplayCapabilityStringKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"IODisplayCapabilityString\0") };
pub const kIODisplayRedGammaScaleKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"rgsc\0") };
pub const kIODisplayGreenGammaScaleKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ggsc\0") };
pub const kIODisplayBlueGammaScaleKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"bgsc\0") };
pub const kIODisplayGammaScaleKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"gsc \0") };
pub const kIODisplayParametersCommitKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"commit\0") };
pub const kIODisplayParametersDefaultKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"defaults\0") };
pub const kIODisplayParametersFlushKey: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"flush\0") };
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct eIOAcceleratorClientTypes(pub c_uint);
impl eIOAcceleratorClientTypes {
    #[doc(alias = "kIOAccelSurfaceClientType")]
    pub const IOAccelSurfaceClientType: Self = Self(0);
    #[doc(alias = "kIOAccelNumClientTypes")]
    pub const IOAccelNumClientTypes: Self = Self(1);
    #[doc(alias = "kIOAccelSurface2ClientType")]
    pub const IOAccelSurface2ClientType: Self = Self(0x20);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for eIOAcceleratorClientTypes {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for eIOAcceleratorClientTypes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOAccelBounds {
    pub x: i16,
    pub y: i16,
    pub w: i16,
    pub h: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOAccelBounds {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOAccelBounds {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOAccelSize {
    pub w: i16,
    pub h: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOAccelSize {
    const ENCODING: Encoding = Encoding::Struct("?", &[<i16>::ENCODING, <i16>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOAccelSize {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kIOAccelVolatileSurface: c_uint = 0x00000001;

#[cfg(feature = "libc")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOAccelSurfaceInformation {
    pub address: [libc::mach_vm_address_t; 4],
    pub rowBytes: u32,
    pub width: u32,
    pub height: u32,
    pub pixelFormat: u32,
    pub flags: IOOptionBits,
    pub colorTemperature: [IOFixed; 4],
    pub typeDependent: [u32; 4],
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOAccelSurfaceInformation {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <[libc::mach_vm_address_t; 4]>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <IOOptionBits>::ENCODING,
            <[IOFixed; 4]>::ENCODING,
            <[u32; 4]>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOAccelSurfaceInformation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "libc")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOAccelSurfaceReadData {
    pub x: i32,
    pub y: i32,
    pub w: i32,
    pub h: i32,
    pub client_addr: libc::mach_vm_address_t,
    pub client_row_bytes: u32,
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOAccelSurfaceReadData {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <libc::mach_vm_address_t>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOAccelSurfaceReadData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOAccelSurfaceScaling {
    pub buffer: IOAccelBounds,
    pub source: IOAccelSize,
    pub reserved: [u32; 8],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOAccelSurfaceScaling {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <IOAccelBounds>::ENCODING,
            <IOAccelSize>::ENCODING,
            <[u32; 8]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOAccelSurfaceScaling {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOAccelID = i32;

pub const kIOAccelPrivateID: c_uint = 0x00000001;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOAccelDeviceRegion {
    pub num_rects: u32,
    pub bounds: IOAccelBounds,
    pub rect: [IOAccelBounds; 0],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOAccelDeviceRegion {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <IOAccelBounds>::ENCODING,
            <[IOAccelBounds; 0]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOAccelDeviceRegion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct eIOAccelSurfaceMemoryTypes(pub c_uint);
impl eIOAccelSurfaceMemoryTypes {
    #[doc(alias = "kIOAccelNumSurfaceMemoryTypes")]
    pub const IOAccelNumSurfaceMemoryTypes: Self = Self(0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for eIOAccelSurfaceMemoryTypes {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for eIOAccelSurfaceMemoryTypes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct eIOAccelSurfaceMethods(pub c_uint);
impl eIOAccelSurfaceMethods {
    #[doc(alias = "kIOAccelSurfaceReadLockOptions")]
    pub const IOAccelSurfaceReadLockOptions: Self = Self(0);
    #[doc(alias = "kIOAccelSurfaceReadUnlockOptions")]
    pub const IOAccelSurfaceReadUnlockOptions: Self = Self(1);
    #[doc(alias = "kIOAccelSurfaceGetState")]
    pub const IOAccelSurfaceGetState: Self = Self(2);
    #[doc(alias = "kIOAccelSurfaceWriteLockOptions")]
    pub const IOAccelSurfaceWriteLockOptions: Self = Self(3);
    #[doc(alias = "kIOAccelSurfaceWriteUnlockOptions")]
    pub const IOAccelSurfaceWriteUnlockOptions: Self = Self(4);
    #[doc(alias = "kIOAccelSurfaceRead")]
    pub const IOAccelSurfaceRead: Self = Self(5);
    #[doc(alias = "kIOAccelSurfaceSetShapeBacking")]
    pub const IOAccelSurfaceSetShapeBacking: Self = Self(6);
    #[doc(alias = "kIOAccelSurfaceSetIDMode")]
    pub const IOAccelSurfaceSetIDMode: Self = Self(7);
    #[doc(alias = "kIOAccelSurfaceSetScale")]
    pub const IOAccelSurfaceSetScale: Self = Self(8);
    #[doc(alias = "kIOAccelSurfaceSetShape")]
    pub const IOAccelSurfaceSetShape: Self = Self(9);
    #[doc(alias = "kIOAccelSurfaceFlush")]
    pub const IOAccelSurfaceFlush: Self = Self(10);
    #[doc(alias = "kIOAccelSurfaceQueryLock")]
    pub const IOAccelSurfaceQueryLock: Self = Self(11);
    #[doc(alias = "kIOAccelSurfaceReadLock")]
    pub const IOAccelSurfaceReadLock: Self = Self(12);
    #[doc(alias = "kIOAccelSurfaceReadUnlock")]
    pub const IOAccelSurfaceReadUnlock: Self = Self(13);
    #[doc(alias = "kIOAccelSurfaceWriteLock")]
    pub const IOAccelSurfaceWriteLock: Self = Self(14);
    #[doc(alias = "kIOAccelSurfaceWriteUnlock")]
    pub const IOAccelSurfaceWriteUnlock: Self = Self(15);
    #[doc(alias = "kIOAccelSurfaceControl")]
    pub const IOAccelSurfaceControl: Self = Self(16);
    #[doc(alias = "kIOAccelSurfaceSetShapeBackingAndLength")]
    pub const IOAccelSurfaceSetShapeBackingAndLength: Self = Self(17);
    #[doc(alias = "kIOAccelNumSurfaceMethods")]
    pub const IOAccelNumSurfaceMethods: Self = Self(18);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for eIOAccelSurfaceMethods {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for eIOAccelSurfaceMethods {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct eIOAccelSurfaceModeBits(pub c_uint);
impl eIOAccelSurfaceModeBits {
    #[doc(alias = "kIOAccelSurfaceModeColorDepth1555")]
    pub const IOAccelSurfaceModeColorDepth1555: Self = Self(0x00000003);
    #[doc(alias = "kIOAccelSurfaceModeColorDepth8888")]
    pub const IOAccelSurfaceModeColorDepth8888: Self = Self(0x00000004);
    #[doc(alias = "kIOAccelSurfaceModeColorDepthYUV")]
    pub const IOAccelSurfaceModeColorDepthYUV: Self = Self(0x00000006);
    #[doc(alias = "kIOAccelSurfaceModeColorDepthYUV9")]
    pub const IOAccelSurfaceModeColorDepthYUV9: Self = Self(0x00000007);
    #[doc(alias = "kIOAccelSurfaceModeColorDepthYUV12")]
    pub const IOAccelSurfaceModeColorDepthYUV12: Self = Self(0x00000008);
    #[doc(alias = "kIOAccelSurfaceModeColorDepthYUV2")]
    pub const IOAccelSurfaceModeColorDepthYUV2: Self = Self(0x00000009);
    #[doc(alias = "kIOAccelSurfaceModeColorDepthBGRA32")]
    pub const IOAccelSurfaceModeColorDepthBGRA32: Self = Self(0x0000000A);
    #[doc(alias = "kIOAccelSurfaceModeColorDepth2101010")]
    pub const IOAccelSurfaceModeColorDepth2101010: Self = Self(0x0000000F);
    #[doc(alias = "kIOAccelSurfaceModeColorDepthBits")]
    pub const IOAccelSurfaceModeColorDepthBits: Self = Self(0x0000000F);
    #[doc(alias = "kIOAccelSurfaceModeStereoBit")]
    pub const IOAccelSurfaceModeStereoBit: Self = Self(0x00000010);
    #[doc(alias = "kIOAccelSurfaceModeWindowedBit")]
    pub const IOAccelSurfaceModeWindowedBit: Self = Self(0x00000020);
    #[doc(alias = "kIOAccelSurfaceModeSurface2")]
    pub const IOAccelSurfaceModeSurface2: Self = Self(0x00004000);
    #[doc(alias = "kIOAccelSurfaceModeBeamSync")]
    pub const IOAccelSurfaceModeBeamSync: Self = Self(0x00008000);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for eIOAccelSurfaceModeBits {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for eIOAccelSurfaceModeBits {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct eIOAccelSurfaceShapeBits(pub c_uint);
impl eIOAccelSurfaceShapeBits {
    #[doc(alias = "kIOAccelSurfaceShapeNone")]
    pub const IOAccelSurfaceShapeNone: Self = Self(0x00000000);
    #[doc(alias = "kIOAccelSurfaceShapeNonBlockingBit")]
    pub const IOAccelSurfaceShapeNonBlockingBit: Self = Self(0x00000001);
    #[doc(alias = "kIOAccelSurfaceShapeNonSimpleBit")]
    pub const IOAccelSurfaceShapeNonSimpleBit: Self = Self(0x00000002);
    #[doc(alias = "kIOAccelSurfaceShapeIdentityScaleBit")]
    pub const IOAccelSurfaceShapeIdentityScaleBit: Self = Self(0x00000004);
    #[doc(alias = "kIOAccelSurfaceShapeFrameSyncBit")]
    pub const IOAccelSurfaceShapeFrameSyncBit: Self = Self(0x00000008);
    #[doc(alias = "kIOAccelSurfaceShapeBeamSyncBit")]
    pub const IOAccelSurfaceShapeBeamSyncBit: Self = Self(0x00000010);
    #[doc(alias = "kIOAccelSurfaceShapeStaleBackingBit")]
    pub const IOAccelSurfaceShapeStaleBackingBit: Self = Self(0x00000020);
    #[doc(alias = "kIOAccelSurfaceShapeAssemblyBit")]
    pub const IOAccelSurfaceShapeAssemblyBit: Self = Self(0x00000040);
    #[doc(alias = "kIOAccelSurfaceShapeWaitEnabledBit")]
    pub const IOAccelSurfaceShapeWaitEnabledBit: Self = Self(0x00000080);
    #[doc(alias = "kIOAccelSurfaceShapeBlockingBit")]
    pub const IOAccelSurfaceShapeBlockingBit: Self =
        Self(eIOAccelSurfaceShapeBits::IOAccelSurfaceShapeNonBlockingBit.0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for eIOAccelSurfaceShapeBits {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for eIOAccelSurfaceShapeBits {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct eIOAccelSurfaceStateBits(pub c_uint);
impl eIOAccelSurfaceStateBits {
    #[doc(alias = "kIOAccelSurfaceStateNone")]
    pub const IOAccelSurfaceStateNone: Self = Self(0x00000000);
    #[doc(alias = "kIOAccelSurfaceStateIdleBit")]
    pub const IOAccelSurfaceStateIdleBit: Self = Self(0x00000001);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for eIOAccelSurfaceStateBits {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for eIOAccelSurfaceStateBits {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct eIOAccelSurfaceScaleBits(pub c_uint);
impl eIOAccelSurfaceScaleBits {
    #[doc(alias = "kIOAccelSurfaceBeamSyncSwaps")]
    pub const IOAccelSurfaceBeamSyncSwaps: Self = Self(0x00000001);
    #[doc(alias = "kIOAccelSurfaceFixedSource")]
    pub const IOAccelSurfaceFixedSource: Self = Self(0x00000002);
    #[doc(alias = "kIOAccelSurfaceFiltering")]
    pub const IOAccelSurfaceFiltering: Self = Self(0x000000f0);
    #[doc(alias = "kIOAccelSurfaceFilterDefault")]
    pub const IOAccelSurfaceFilterDefault: Self = Self(0x00000000);
    #[doc(alias = "kIOAccelSurfaceFilterNone")]
    pub const IOAccelSurfaceFilterNone: Self = Self(0x00000010);
    #[doc(alias = "kIOAccelSurfaceFilterLinear")]
    pub const IOAccelSurfaceFilterLinear: Self = Self(0x00000020);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for eIOAccelSurfaceScaleBits {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for eIOAccelSurfaceScaleBits {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct eIOAccelSurfaceLockBits(pub c_uint);
impl eIOAccelSurfaceLockBits {
    #[doc(alias = "kIOAccelSurfaceLockInBacking")]
    pub const IOAccelSurfaceLockInBacking: Self = Self(0);
    #[doc(alias = "kIOAccelSurfaceLockInAccel")]
    pub const IOAccelSurfaceLockInAccel: Self = Self(1);
    #[doc(alias = "kIOAccelSurfaceLockInDontCare")]
    pub const IOAccelSurfaceLockInDontCare: Self = Self(2);
    #[doc(alias = "kIOAccelSurfaceLockInMask")]
    pub const IOAccelSurfaceLockInMask: Self = Self(0x00000003);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for eIOAccelSurfaceLockBits {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for eIOAccelSurfaceLockBits {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOFourCharCode = u32;

pub type IOBlitCompletionToken = i32;

pub type IOBlitType = u32;

pub const kIOBlitTypeVerbMask: c_uint = 0x000000ff;
pub const kIOBlitTypeRects: c_uint = 0;
pub const kIOBlitTypeCopyRects: c_uint = 1;
pub const kIOBlitTypeLines: c_uint = 2;
pub const kIOBlitTypeScanlines: c_uint = 3;
pub const kIOBlitTypeCopyRegion: c_uint = 4;
pub const kIOBlitTypeMoveCursor: c_uint = 5;
pub const kIOBlitTypeShowCursor: c_uint = 6;
pub const kIOBlitTypeHideCursor: c_uint = 7;
pub const kIOBlitTypeMonoExpand: c_uint = 0x00000100;
pub const kIOBlitTypeColorSpaceConvert: c_uint = 0x00000200;
pub const kIOBlitTypeScale: c_uint = 0x00000400;
pub const kIOBlitTypeSourceKeyColorModeMask: c_uint = 0x00003000;
pub const kIOBlitTypeDestKeyColorModeMask: c_uint = 0x0000c000;
pub const kIOBlitTypeSourceKeyColorEqual: c_uint = 0x00001000;
pub const kIOBlitTypeSourceKeyColorNotEqual: c_uint = 0x00002000;
pub const kIOBlitTypeDestKeyColorEqual: c_uint = 0x00004000;
pub const kIOBlitTypeDestKeyColorNotEqual: c_uint = 0x00008000;
pub const kIOBlitTypeOperationMask: c_uint = 0x0fff0000;
pub const kIOBlitTypeOperationShift: c_uint = 16;
pub const kIOBlitTypeOperationTypeMask: c_uint = 0x0f000000;
pub const kIOBlitTypeOperationType0: c_uint = 0x00000000;
pub const kIOBlitCopyOperation: c_uint = 0x00000000 | kIOBlitTypeOperationType0;
pub const kIOBlitOrOperation: c_uint = 0x00010000 | kIOBlitTypeOperationType0;
pub const kIOBlitXorOperation: c_uint = 0x00020000 | kIOBlitTypeOperationType0;
pub const kIOBlitBlendOperation: c_uint = 0x00030000 | kIOBlitTypeOperationType0;
pub const kIOBlitHighlightOperation: c_uint = 0x00040000 | kIOBlitTypeOperationType0;

pub type IOBlitSourceType = u32;

pub const kIOBlitSourceDefault: c_uint = 0x00000000;
pub const kIOBlitSourceFramebuffer: c_uint = 0x00001000;
pub const kIOBlitSourceMemory: c_uint = 0x00002000;
pub const kIOBlitSourceOOLMemory: c_uint = 0x00003000;
pub const kIOBlitSourcePattern: c_uint = 0x00004000;
pub const kIOBlitSourceOOLPattern: c_uint = 0x00005000;
pub const kIOBlitSourceSolid: c_uint = 0x00006000;
pub const kIOBlitSourceCGSSurface: c_uint = 0x00007000;
pub const kIOBlitSourceIsSame: c_uint = 0x80000000;

pub type IOBlitSourceDestType = IOBlitSourceType;

pub const kIOBlitDestFramebuffer: c_uint = 0x00000001;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOBlitOperationStruct {
    pub color0: u32,
    pub color1: u32,
    pub offsetX: i32,
    pub offsetY: i32,
    pub sourceKeyColor: u32,
    pub destKeyColor: u32,
    pub specific: [u32; 16],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitOperationStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitOperationStruct",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 16]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitOperationStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitOperation = IOBlitOperationStruct;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOBlitRectangleStruct {
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitRectangleStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitRectangleStruct",
        &[
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitRectangleStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitRectangle = IOBlitRectangleStruct;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOBlitRectanglesStruct {
    pub operation: IOBlitOperation,
    pub count: IOItemCount,
    pub rects: [IOBlitRectangle; 1],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitRectanglesStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitRectanglesStruct",
        &[
            <IOBlitOperation>::ENCODING,
            <IOItemCount>::ENCODING,
            <[IOBlitRectangle; 1]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitRectanglesStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitRectangles = IOBlitRectanglesStruct;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOBlitCopyRectangleStruct {
    pub sourceX: i32,
    pub sourceY: i32,
    pub x: i32,
    pub y: i32,
    pub width: i32,
    pub height: i32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitCopyRectangleStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitCopyRectangleStruct",
        &[
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitCopyRectangleStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitCopyRectangle = IOBlitCopyRectangleStruct;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOBlitCopyRectanglesStruct {
    pub operation: IOBlitOperation,
    pub count: IOItemCount,
    pub rects: [IOBlitCopyRectangle; 1],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitCopyRectanglesStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitCopyRectanglesStruct",
        &[
            <IOBlitOperation>::ENCODING,
            <IOItemCount>::ENCODING,
            <[IOBlitCopyRectangle; 1]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitCopyRectanglesStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitCopyRectangles = IOBlitCopyRectanglesStruct;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOBlitCopyRegionStruct {
    pub operation: IOBlitOperation,
    pub deltaX: i32,
    pub deltaY: i32,
    pub region: *mut IOAccelDeviceRegion,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitCopyRegionStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitCopyRegionStruct",
        &[
            <IOBlitOperation>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <*mut IOAccelDeviceRegion>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitCopyRegionStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitCopyRegion = IOBlitCopyRegionStruct;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOBlitVertexStruct {
    pub x: i32,
    pub y: i32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitVertexStruct {
    const ENCODING: Encoding =
        Encoding::Struct("IOBlitVertexStruct", &[<i32>::ENCODING, <i32>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitVertexStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitVertex = IOBlitVertexStruct;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOBlitVerticesStruct {
    pub operation: IOBlitOperation,
    pub count: IOItemCount,
    pub vertices: [IOBlitVertex; 2],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitVerticesStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitVerticesStruct",
        &[
            <IOBlitOperation>::ENCODING,
            <IOItemCount>::ENCODING,
            <[IOBlitVertex; 2]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitVerticesStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitVertices = IOBlitVerticesStruct;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOBlitScanlinesStruct {
    pub operation: IOBlitOperation,
    pub count: IOItemCount,
    pub y: i32,
    pub height: i32,
    pub x: [i32; 2],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitScanlinesStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitScanlinesStruct",
        &[
            <IOBlitOperation>::ENCODING,
            <IOItemCount>::ENCODING,
            <i32>::ENCODING,
            <i32>::ENCODING,
            <[i32; 2]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitScanlinesStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitScanlines = IOBlitScanlinesStruct;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOBlitCursorStruct {
    pub operation: IOBlitOperation,
    pub rect: IOBlitRectangle,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitCursorStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitCursorStruct",
        &[<IOBlitOperation>::ENCODING, <IOBlitRectangle>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitCursorStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitCursor = IOBlitCursorStruct;

#[repr(C)]
#[derive(Debug)]
pub struct _IOBlitMemory {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for _IOBlitMemory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Encoding::Struct("_IOBlitMemory", &[]));
}

pub type IOBlitMemoryRef = *mut _IOBlitMemory;

pub const kIO1MonochromePixelFormat: c_uint = 0x00000001;
pub const kIO2IndexedPixelFormat: c_uint = 0x00000002;
pub const kIO4IndexedPixelFormat: c_uint = 0x00000004;
pub const kIO8IndexedPixelFormat: c_uint = 0x00000008;
pub const kIO16BE555PixelFormat: c_uint = 0x00000010;
pub const kIO24RGBPixelFormat: c_uint = 0x00000018;
pub const kIO32ARGBPixelFormat: c_uint = 0x00000020;
pub const kIO1IndexedGrayPixelFormat: c_uint = 0x00000021;
pub const kIO2IndexedGrayPixelFormat: c_uint = 0x00000022;
pub const kIO4IndexedGrayPixelFormat: c_uint = 0x00000024;
pub const kIO8IndexedGrayPixelFormat: c_uint = 0x00000028;

pub const kIO16LE555PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x4c353535);
pub const kIO16LE5551PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x35353531);
pub const kIO16BE565PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x42353635);
pub const kIO16LE565PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x4c353635);
pub const kIO24BGRPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x32344247);
pub const kIO32BGRAPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x42475241);
pub const kIO32ABGRPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x41424752);
pub const kIO32RGBAPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x52474241);
pub const kIOYUVSPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x79757673);
pub const kIOYUVUPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x79757675);
pub const kIOYVU9PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x59565539);
pub const kIOYUV411PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x59343131);
pub const kIOYVYU422PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x59565955);
pub const kIOUYVY422PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x55595659);
pub const kIOYUV211PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x59323131);
pub const kIO2vuyPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x32767579);

pub const kIO16LE4444PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x4c343434);
pub const kIO16BE4444PixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x42343434);
pub const kIO64BGRAPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x42313649);
pub const kIO64RGBAFloatPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x42313646);
pub const kIO128RGBAFloatPixelFormat: c_uint = IO_FOUR_CHAR_CODE!(0x42333246);

pub const kIOBlitMemoryRequiresHostFlush: c_uint = 0x00000001;

#[repr(C)]
#[derive(Clone, Copy)]
pub union IOBlitSurfaceStruct_memory {
    pub bytes: *mut u8,
    pub r#ref: IOBlitMemoryRef,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitSurfaceStruct_memory {
    const ENCODING: Encoding =
        Encoding::Union("?", &[<*mut u8>::ENCODING, <IOBlitMemoryRef>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitSurfaceStruct_memory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct IOBlitSurfaceStruct {
    pub memory: IOBlitSurfaceStruct_memory,
    pub pixelFormat: IOFourCharCode,
    pub size: IOBlitRectangle,
    pub rowBytes: u32,
    pub byteOffset: u32,
    pub palette: *mut u32,
    pub accessFlags: IOOptionBits,
    pub interfaceRef: IOBlitMemoryRef,
    pub more: [u32; 14],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBlitSurfaceStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBlitSurfaceStruct",
        &[
            <IOBlitSurfaceStruct_memory>::ENCODING,
            <IOFourCharCode>::ENCODING,
            <IOBlitRectangle>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <*mut u32>::ENCODING,
            <IOOptionBits>::ENCODING,
            <IOBlitMemoryRef>::ENCODING,
            <[u32; 14]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBlitSurfaceStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBlitSurface = IOBlitSurfaceStruct;

pub type IOBlitMemory = IOBlitSurface;

pub const kIOBlitSynchronizeWaitBeamExit: c_uint = 0x00000001;
pub const kIOBlitSynchronizeFlushHostWrites: c_uint = 0x00000002;

pub const kIOBlitWaitContext: c_uint = 0x00000000;
pub const kIOBlitWaitAll2D: c_uint = 0x00000001;
pub const kIOBlitWaitGlobal: c_uint = 0x00000001;
pub const kIOBlitWaitAll: c_uint = 0x00000002;
pub const kIOBlitWaitCheck: c_uint = 0x00000080;
pub const kIOBlitFlushWithSwap: c_uint = 0x00010000;

pub const kIOBlitHasCGSSurface: c_uint = 0x00000001;
pub const kIOBlitFixedSource: c_uint = 0x00000002;
pub const kIOBlitBeamSyncSwaps: c_uint = 0x00000004;
pub const kIOBlitReferenceSource: c_uint = 0x00000008;

pub const kIOBlitUnlockWithSwap: c_uint = 0x80000000;

pub const kIOBlitFramebufferDestination: c_uint = 0x00000000;
pub const kIOBlitSurfaceDestination: c_uint = 0x00000001;

pub const kIOBlitBeamSync: c_uint = 0x00000001;
pub const kIOBlitBeamSyncAlways: c_uint = 0x00000002;
pub const kIOBlitBeamSyncSpin: c_uint = 0x00000004;
pub const kIOBlitAllOptions: c_uint = 0xffffffff;

pub const kIOBlitColorSpaceTypes: c_uint = IO_FOUR_CHAR_CODE!(0x63737063);

pub type IOBlitAccumulatePtr =
    Option<unsafe extern "C-unwind" fn(*mut c_void, i32, i32, i32, i32, i32, i32) -> IOReturn>;

pub type IOBlitProcPtr = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        IOOptionBits,
        IOBlitType,
        IOBlitSourceDestType,
        *mut IOBlitOperation,
        *mut c_void,
        *mut c_void,
        *mut IOBlitCompletionToken,
    ) -> IOReturn,
>;

pub type IOBlitterPtr = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        IOOptionBits,
        IOBlitType,
        IOBlitSourceType,
        *mut IOBlitOperation,
        *mut c_void,
    ) -> IOReturn,
>;

#[cfg(feature = "libc")]
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOGraphicsAcceleratorInterfaceStruct {
    pub(crate) _reserved: *mut c_void,
    pub QueryInterface:
        Option<unsafe extern "C-unwind" fn(*mut c_void, REFIID, *mut LPVOID) -> HRESULT>,
    pub AddRef: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub Release: Option<unsafe extern "C-unwind" fn(*mut c_void) -> ULONG>,
    pub version: u16,
    pub revision: u16,
    pub Probe: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            *const CFDictionary,
            io_service_t,
            *mut i32,
        ) -> IOReturn,
    >,
    pub Start: Option<
        unsafe extern "C-unwind" fn(*mut c_void, *const CFDictionary, io_service_t) -> IOReturn,
    >,
    pub Stop: Option<unsafe extern "C-unwind" fn(*mut c_void) -> IOReturn>,
    pub Reset: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub CopyCapabilities: Option<
        unsafe extern "C-unwind" fn(*mut c_void, FourCharCode, *mut *const CFType) -> IOReturn,
    >,
    pub GetBlitProc: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOOptionBits,
            IOBlitType,
            IOBlitSourceDestType,
            *mut IOBlitProcPtr,
        ) -> IOReturn,
    >,
    pub Flush: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub WaitForCompletion: Option<
        unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits, IOBlitCompletionToken) -> IOReturn,
    >,
    pub Synchronize:
        Option<unsafe extern "C-unwind" fn(*mut c_void, u32, u32, u32, u32, u32) -> IOReturn>,
    pub GetBeamPosition:
        Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits, *mut i32) -> IOReturn>,
    pub AllocateSurface: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOOptionBits,
            *mut IOBlitSurface,
            *mut c_void,
        ) -> IOReturn,
    >,
    pub FreeSurface: Option<
        unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits, *mut IOBlitSurface) -> IOReturn,
    >,
    pub LockSurface: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOOptionBits,
            *mut IOBlitSurface,
            *mut libc::vm_address_t,
        ) -> IOReturn,
    >,
    pub UnlockSurface: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOOptionBits,
            *mut IOBlitSurface,
            *mut IOOptionBits,
        ) -> IOReturn,
    >,
    pub SwapSurface: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOOptionBits,
            *mut IOBlitSurface,
            *mut IOOptionBits,
        ) -> IOReturn,
    >,
    pub SetDestination: Option<
        unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits, *mut IOBlitSurface) -> IOReturn,
    >,
    pub GetBlitter: Option<
        unsafe extern "C-unwind" fn(
            *mut c_void,
            IOOptionBits,
            IOBlitType,
            IOBlitSourceType,
            *mut IOBlitterPtr,
        ) -> IOReturn,
    >,
    pub WaitComplete: Option<unsafe extern "C-unwind" fn(*mut c_void, IOOptionBits) -> IOReturn>,
    pub(crate) __gaInterfaceReserved: [*mut c_void; 24],
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl Encode for IOGraphicsAcceleratorInterfaceStruct {
    const ENCODING: Encoding = Encoding::Struct("IOGraphicsAcceleratorInterfaceStruct", &[
        <*mut c_void>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,REFIID,*mut LPVOID,) -> HRESULT>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> ULONG>>::ENCODING,
        <u16>::ENCODING,
        <u16>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFDictionary,io_service_t,*mut i32,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,*const CFDictionary,io_service_t,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,FourCharCode,*mut *const CFType,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,IOBlitType,IOBlitSourceDestType,*mut IOBlitProcPtr,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,IOBlitCompletionToken,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,u32,u32,u32,u32,u32,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,*mut i32,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,*mut IOBlitSurface,*mut c_void,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,*mut IOBlitSurface,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,*mut IOBlitSurface,*mut libc::vm_address_t,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,*mut IOBlitSurface,*mut IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,*mut IOBlitSurface,*mut IOOptionBits,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,*mut IOBlitSurface,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,IOBlitType,IOBlitSourceType,*mut IOBlitterPtr,) -> IOReturn>>::ENCODING,
        <Option<unsafe extern "C-unwind" fn(*mut c_void,IOOptionBits,) -> IOReturn>>::ENCODING,
        <[*mut c_void; 24]>::ENCODING,
    ]);
}

#[cfg(all(feature = "libc", feature = "objc2"))]
unsafe impl RefEncode for IOGraphicsAcceleratorInterfaceStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(feature = "libc")]
pub type IOGraphicsAcceleratorInterface = IOGraphicsAcceleratorInterfaceStruct;

extern "C-unwind" {
    /// # Safety
    ///
    /// - `p_accelerator` must be a valid pointer.
    /// - `p_framebuffer_index` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IOAccelFindAccelerator(
        framebuffer: io_service_t,
        p_accelerator: *mut io_service_t,
        p_framebuffer_index: *mut u32,
    ) -> IOReturn;
}

pub type IOIndex = i32;

pub type IOSelect = u32;

pub type IOFixed1616 = u32;

pub type IODisplayVendorID = u32;

pub type IODisplayProductID = u32;

pub type IODisplayModeID = i32;

pub const kIOMaxPixelBits: c_uint = 64;

pub type IOPixelEncoding = [c_char; 64];

pub const kIOCLUTPixels: c_uint = 0;
pub const kIOFixedCLUTPixels: c_uint = 1;
pub const kIORGBDirectPixels: c_uint = 2;
pub const kIOMonoDirectPixels: c_uint = 3;
pub const kIOMonoInverseDirectPixels: c_uint = 4;
pub const kIORGBSignedDirectPixels: c_uint = 5;
pub const kIORGBSignedFloatingPointPixels: c_uint = 6;

/// A structure defining the format of a framebuffer.
///
/// This structure is used by IOFramebuffer to define the format of the pixels.
/// Field: bytesPerRow The number of bytes per row.
/// Field: bytesPerPlane Not used.
/// Field: bitsPerPixel The number of bits per pixel, including unused bits and alpha.
/// Field: pixelType One of kIOCLUTPixels (indexed pixels with changeable CLUT), kIORGBDirectPixels (direct pixels).
/// Field: componentCount One for indexed pixels, three for direct pixel formats.
/// Field: bitsPerComponent Number of bits per component in each pixel.
/// Field: componentMasks Mask of the bits valid for each component of the pixel - in R, G, B order for direct pixels.
/// Field: pixelFormat String description of the pixel format - IO32BitDirectPixels, IO16BitDirectPixels etc.
/// Field: flags None defined - set to zero.
/// Field: activeWidth Number of pixels visible per row.
/// Field: activeHeight Number of visible pixel rows.
/// Field: reserved Set to zero.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOPixelInformation {
    pub bytesPerRow: u32,
    pub bytesPerPlane: u32,
    pub bitsPerPixel: u32,
    pub pixelType: u32,
    pub componentCount: u32,
    pub bitsPerComponent: u32,
    pub componentMasks: [u32; 16],
    pub pixelFormat: IOPixelEncoding,
    pub flags: u32,
    pub activeWidth: u32,
    pub activeHeight: u32,
    pub reserved: [u32; 2],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOPixelInformation {
    const ENCODING: Encoding = Encoding::Struct(
        "IOPixelInformation",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 16]>::ENCODING,
            <IOPixelEncoding>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 2]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOPixelInformation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOAppleTimingID = u32;

/// A structure defining the format of a framebuffer.
///
/// This structure is used by IOFramebuffer to define the format of the pixels.
/// Field: nominalWidth Number of pixels visible per row.
/// Field: nominalHeight Number of visible pixel rows.
/// Field: refreshRate Refresh rate in fixed point 16.16.
/// Field: maxDepthIndex Highest depth index available in this display mode.
/// Field: flags Flags for the mode, including:
/// <br>
/// kDisplayModeInterlacedFlag mode is interlaced.
/// <br>
/// kDisplayModeSimulscanFlag mode is available on multiple display connections.
/// <br>
/// kDisplayModeNotPresetFlag mode is not a factory preset for the display (geometry may need correction).
/// <br>
/// kDisplayModeStretchedFlag mode is stretched/distorted to match the display aspect ratio.
/// <br>
/// Field: imageWidth Physical width of active image if known, in millimeters, otherwise zero.
/// <br>
/// Field: imageHeight Physical height of active image if known, in millimeters, otherwise zero.
/// <br>
/// Field: reserved Set to zero.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IODisplayModeInformation {
    pub nominalWidth: u32,
    pub nominalHeight: u32,
    pub refreshRate: IOFixed1616,
    pub maxDepthIndex: IOIndex,
    pub flags: u32,
    pub imageWidth: u16,
    pub imageHeight: u16,
    pub reserved: [u32; 3],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODisplayModeInformation {
    const ENCODING: Encoding = Encoding::Struct(
        "IODisplayModeInformation",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <IOFixed1616>::ENCODING,
            <IOIndex>::ENCODING,
            <u32>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <[u32; 3]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODisplayModeInformation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kDisplayModeSafetyFlags: c_uint = 0x00000007;
pub const kDisplayModeAlwaysShowFlag: c_uint = 0x00000008;
pub const kDisplayModeNeverShowFlag: c_uint = 0x00000080;
pub const kDisplayModeNotResizeFlag: c_uint = 0x00000010;
pub const kDisplayModeRequiresPanFlag: c_uint = 0x00000020;
pub const kDisplayModeInterlacedFlag: c_uint = 0x00000040;
pub const kDisplayModeSimulscanFlag: c_uint = 0x00000100;
pub const kDisplayModeBuiltInFlag: c_uint = 0x00000400;
pub const kDisplayModeNotPresetFlag: c_uint = 0x00000200;
pub const kDisplayModeStretchedFlag: c_uint = 0x00000800;
pub const kDisplayModeNotGraphicsQualityFlag: c_uint = 0x00001000;
pub const kDisplayModeValidateAgainstDisplay: c_uint = 0x00002000;
pub const kDisplayModeTelevisionFlag: c_uint = 0x00100000;
pub const kDisplayModeValidForMirroringFlag: c_uint = 0x00200000;
pub const kDisplayModeAcceleratorBackedFlag: c_uint = 0x00400000;
pub const kDisplayModeValidForHiResFlag: c_uint = 0x00800000;
pub const kDisplayModeValidForAirPlayFlag: c_uint = 0x01000000;
pub const kDisplayModeNativeFlag: c_uint = 0x02000000;

pub const kDisplayModeValidFlag: c_uint = 0x00000001;
pub const kDisplayModeSafeFlag: c_uint = 0x00000002;
pub const kDisplayModeDefaultFlag: c_uint = 0x00000004;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOFramebufferInformation {
    pub baseAddress: IOPhysicalAddress,
    pub activeWidth: u32,
    pub activeHeight: u32,
    pub bytesPerRow: IOByteCount,
    pub bytesPerPlane: IOByteCount,
    pub bitsPerPixel: u32,
    pub pixelType: u32,
    pub flags: u32,
    pub reserved: [u32; 4],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOFramebufferInformation {
    const ENCODING: Encoding = Encoding::Struct(
        "IOFramebufferInformation",
        &[
            <IOPhysicalAddress>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <IOByteCount>::ENCODING,
            <IOByteCount>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 4]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOFramebufferInformation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kFramebufferSupportsCopybackCache: c_uint = 0x00010000;
pub const kFramebufferSupportsWritethruCache: c_uint = 0x00020000;
pub const kFramebufferSupportsGammaCorrection: c_uint = 0x00040000;
pub const kFramebufferDisableAltivecAccess: c_uint = 0x00080000;

pub type IOPixelAperture = IOIndex;

pub const kIOFBSystemAperture: c_uint = 0;

pub type IOColorComponent = u16;

/// A structure defining one entry of a color lookup table.
///
/// ## Overview
///
/// This structure is used by IOFramebuffer to define an entry of a color lookup table.
///
///
/// A structure defining one entry of a color lookup table.
///
/// This structure is used by IOFramebuffer to define an entry of a color lookup table.
/// Field: index Number of pixels visible per row.
/// Field: red Value of red component 0-65535.
/// Field: green Value of green component 0-65535.
/// Field: blue Value of blue component 0-65535.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOColorEntry {
    pub index: u16,
    pub red: IOColorComponent,
    pub green: IOColorComponent,
    pub blue: IOColorComponent,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOColorEntry {
    const ENCODING: Encoding = Encoding::Struct(
        "IOColorEntry",
        &[
            <u16>::ENCODING,
            <IOColorComponent>::ENCODING,
            <IOColorComponent>::ENCODING,
            <IOColorComponent>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOColorEntry {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kSetCLUTByValue: c_uint = 0x00000001;
pub const kSetCLUTImmediately: c_uint = 0x00000002;
pub const kSetCLUTWithLuminance: c_uint = 0x00000004;

pub const kIOPowerStateAttribute: c_uint = 0x70777273;
pub const kIOPowerAttribute: c_uint = 0x706f7772;
pub const kIODriverPowerAttribute: c_uint = 0x64706f77;
pub const kIOHardwareCursorAttribute: c_uint = 0x63727372;
pub const kIOMirrorAttribute: c_uint = 0x6d697272;
pub const kIOMirrorDefaultAttribute: c_uint = 0x6d726466;
pub const kIOCapturedAttribute: c_uint = 0x63617064;
pub const kIOCursorControlAttribute: c_uint = 0x63727363;
pub const kIOSystemPowerAttribute: c_uint = 0x73707772;
pub const kIOWindowServerActiveAttribute: c_uint = 0x77737276;
pub const kIOVRAMSaveAttribute: c_uint = 0x76727376;
pub const kIODeferCLUTSetAttribute: c_uint = 0x76636c74;
pub const kIOClamshellStateAttribute: c_uint = 0x636c616d;
pub const kIOFBDisplayPortTrainingAttribute: c_uint = 0x64707461;
pub const kIOFBDisplayState: c_uint = 0x64737474;
pub const kIOFBVariableRefreshRate: c_uint = 0x7672723f;
pub const kIOFBLimitHDCPAttribute: c_uint = 0x68646370;
pub const kIOFBLimitHDCPStateAttribute: c_uint = 0x73484443;
pub const kIOFBStop: c_uint = 0x73746f70;
pub const kIOFBRedGammaScaleAttribute: c_uint = 0x67736c72;
pub const kIOFBGreenGammaScaleAttribute: c_uint = 0x67736c67;
pub const kIOFBBlueGammaScaleAttribute: c_uint = 0x67736c62;
pub const kIOFBHDRMetaDataAttribute: c_uint = 0x6864726d;
pub const kIOBuiltinPanelPowerAttribute: c_uint = 0x706e6c70;

pub const kIOFBHDCPLimit_AllowAll: c_uint = 0;
pub const kIOFBHDCPLimit_NoHDCP1x: c_uint = 1 << 0;
pub const kIOFBHDCPLimit_NoHDCP20Type0: c_uint = 1 << 1;
pub const kIOFBHDCPLimit_NoHDCP20Type1: c_uint = 1 << 2;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOFBHDRMetaDataV1 {
    pub displayPrimary_X0: u16,
    pub displayPrimary_Y0: u16,
    pub displayPrimary_X1: u16,
    pub displayPrimary_Y1: u16,
    pub displayPrimary_X2: u16,
    pub displayPrimary_Y2: u16,
    pub displayPrimary_X: u16,
    pub displayPrimary_Y: u16,
    pub desiredLuminance_Max: u16,
    pub desiredLuminance_Min: u16,
    pub desiredLightLevel_Avg: u16,
    pub desiredLightLevel_Max: u16,
    pub(crate) __reservedA: [u64; 5],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOFBHDRMetaDataV1 {
    const ENCODING: Encoding = Encoding::Struct(
        "IOFBHDRMetaDataV1",
        &[
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <[u64; 5]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOFBHDRMetaDataV1 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy)]
pub union IOFBHDRMetaData {
    pub v1: IOFBHDRMetaDataV1,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOFBHDRMetaData {
    const ENCODING: Encoding = Encoding::Union("?", &[<IOFBHDRMetaDataV1>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOFBHDRMetaData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kIOFBDisplayState_AlreadyActive: c_uint = 1 << 0;
pub const kIOFBDisplayState_RestoredProfile: c_uint = 1 << 1;
pub const kIOFBDisplayState_PipelineBlack: c_uint = 1 << 2;
pub const kIOFBDisplayState_Mask: c_uint = kIOFBDisplayState_AlreadyActive
    | kIOFBDisplayState_RestoredProfile
    | kIOFBDisplayState_PipelineBlack;

pub const kIOWSAA_Unaccelerated: c_uint = 0;
pub const kIOWSAA_Accelerated: c_uint = 1;
pub const kIOWSAA_From_Accelerated: c_uint = 2;
pub const kIOWSAA_To_Accelerated: c_uint = 3;
pub const kIOWSAA_Sleep: c_uint = 4;
pub const kIOWSAA_Hibernate: c_uint = kIOWSAA_Sleep;
pub const kIOWSAA_DriverOpen: c_uint = 5;
pub const kIOWSAA_StateMask: c_uint = 0xF;
pub const kIOWSAA_Transactional: c_uint = 0x10;
pub const kIOWSAA_DeferStart: c_uint = 0x100;
pub const kIOWSAA_DeferEnd: c_uint = 0x200;
pub const kIOWSAA_NonConsoleDevice: c_uint = 0x400;
pub const kIOWSAA_Reserved: c_uint = 0xF0000000;

pub const kIOFBNS_Rendezvous: c_uint = 0x87654321;
pub const kIOFBNS_MessageMask: c_uint = 0x0000000f;
pub const kIOFBNS_Sleep: c_uint = 0x00;
pub const kIOFBNS_Wake: c_uint = 0x01;
pub const kIOFBNS_Doze: c_uint = 0x02;
pub const kIOFBNS_Dim: c_uint = 0x03;
pub const kIOFBNS_UnDim: c_uint = 0x04;
pub const kIOFBNS_DisplayStateMask: c_uint = 0x00000f00;
pub const kIOFBNS_DisplayStateShift: c_uint = 8;
pub const kIOFBNS_GenerationMask: c_uint = 0x7fff0000;
pub const kIOFBNS_GenerationShift: c_uint = 16;

pub const kIOMirrorIsPrimary: c_uint = 0x80000000;
pub const kIOMirrorHWClipped: c_uint = 0x40000000;
pub const kIOMirrorIsMirrored: c_uint = 0x20000000;

pub const kIOMirrorDefault: c_uint = 0x00000001;
pub const kIOMirrorForced: c_uint = 0x00000002;

/// / Display mode timing information
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IODetailedTimingInformationV1 {
    pub pixelClock: u32,
    pub horizontalActive: u32,
    pub horizontalBlanking: u32,
    pub horizontalBorder: u32,
    pub horizontalSyncOffset: u32,
    pub horizontalSyncWidth: u32,
    pub verticalActive: u32,
    pub verticalBlanking: u32,
    pub verticalBorder: u32,
    pub verticalSyncOffset: u32,
    pub verticalSyncWidth: u32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODetailedTimingInformationV1 {
    const ENCODING: Encoding = Encoding::Struct(
        "IODetailedTimingInformationV1",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODetailedTimingInformationV1 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A structure defining the detailed timing information of a display mode.
///
/// This structure is used by IOFramebuffer to define detailed timing information for a display mode. The VESA EDID document has more information.
/// Field: __reservedA Set to zero.
/// Field: horizontalScaledInset If the mode is scaled, sets the number of active pixels to remove the left and right edges in order to display an underscanned image.
/// Field: verticalScaledInset If the mode is scaled, sets the number of active lines to remove the top and bottom edges in order to display an underscanned image.
/// Field: scalerFlags If the mode is scaled,
/// kIOScaleStretchToFit may be set to allow stretching.
/// kIOScaleRotateFlags is mask which may have the value given by kIOScaleRotate90, kIOScaleRotate180, kIOScaleRotate270 to display a rotated framebuffer.
/// Field: horizontalScaled If the mode is scaled, sets the size of the image before scaling or rotation.
/// Field: verticalScaled If the mode is scaled, sets the size of the image before scaling or rotation.
/// Field: signalConfig
/// kIOAnalogSetupExpected set if display expects a blank-to-black setup or pedestal.  See VESA signal standards.
/// <br>
/// kIOInterlacedCEATiming set for a CEA style interlaced timing:
/// <br>
/// Field 1 vertical blanking = half specified vertical blanking lines.
/// <br>
/// Field 2 vertical blanking = (half vertical blanking lines) + 1 line.
/// <br>
/// Field 1 vertical offset = half specified vertical sync offset.
/// <br>
/// Field 2 vertical offset = (half specified vertical sync offset) + 0.5 lines.
/// <br>
/// Field: signalLevels One of:
/// <br>
/// kIOAnalogSignalLevel_0700_0300 0.700 - 0.300 V p-p.
/// <br>
/// kIOAnalogSignalLevel_0714_0286 0.714 - 0.286 V p-p.
/// <br>
/// kIOAnalogSignalLevel_1000_0400 1.000 - 0.400 V p-p.
/// <br>
/// kIOAnalogSignalLevel_0700_0000 0.700 - 0.000 V p-p.
/// <br>
/// Field: pixelClock Pixel clock frequency in Hz.
/// Field: minPixelClock Minimum pixel clock frequency in Hz, with error.
/// Field: maxPixelClock Maximum pixel clock frequency in Hz, with error.
/// Field: horizontalActive Pixel clocks per line.
/// Field: horizontalBlanking Blanking clocks per line.
/// Field: horizontalSyncOffset First clock of horizontal sync.
/// Field: horizontalSyncPulseWidth Width of horizontal sync.
/// Field: verticalActive Number of lines per frame.
/// Field: verticalBlanking Blanking lines per frame.
/// Field: verticalSyncOffset First line of vertical sync.
/// Field: verticalSyncPulseWidth Height of vertical sync.
/// Field: horizontalBorderLeft Number of pixels in left horizontal border.
/// Field: horizontalBorderRight Number of pixels in right horizontal border.
/// Field: verticalBorderTop Number of lines in top vertical border.
/// Field: verticalBorderBottom Number of lines in bottom vertical border.
/// Field: horizontalSyncConfig kIOSyncPositivePolarity for positive polarity horizontal sync (0 for negative).
/// Field: horizontalSyncLevel Zero.
/// Field: verticalSyncConfig kIOSyncPositivePolarity for positive polarity vertical sync (0 for negative).
/// Field: verticalSyncLevel Zero.
/// Field: numLinks number of links to be used by a dual link timing, if zero, assume one link.
/// Field: verticalBlankingExtension maximum number of blanking extension lines that is available. (0 for none).
/// Field: pixelEncoding 2017 Timing Features - ERS 2-58 (6.3.1)
/// Field: bitsPerColorComponent 2017 Timing Features - ERS 2-58 (6.3.1)
/// Field: colorimetry 2017 Timing Features - ERS 2-58 (6.3.1)
/// Field: dynamicRange 2017 Timing Features - ERS 2-58 (6.3.1)
/// Field: dscCompressedBitsPerPixel 2018 Timing Features - ERS 2-63 (6.3.1)
/// Field: dscSliceHeight 2018 Timing Features - ERS 2-63 (6.3.1)
/// Field: dscSliceWidth 2018 Timing Features - ERS 2-63 (6.3.1)
/// Field: verticalBlankingMaxStretchPerFrame Max stretch time used for VRR refresh rate ramps
/// Field: verticalBlankingMaxShrinkPerFrame Max shrink time used for VRR refresh rate ramps
/// Field: __reservedB Reserved set to zero.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IODetailedTimingInformationV2 {
    pub(crate) __reservedA: [u32; 3],
    pub horizontalScaledInset: u32,
    pub verticalScaledInset: u32,
    pub scalerFlags: u32,
    pub horizontalScaled: u32,
    pub verticalScaled: u32,
    pub signalConfig: u32,
    pub signalLevels: u32,
    pub pixelClock: u64,
    pub minPixelClock: u64,
    pub maxPixelClock: u64,
    pub horizontalActive: u32,
    pub horizontalBlanking: u32,
    pub horizontalSyncOffset: u32,
    pub horizontalSyncPulseWidth: u32,
    pub verticalActive: u32,
    pub verticalBlanking: u32,
    pub verticalSyncOffset: u32,
    pub verticalSyncPulseWidth: u32,
    pub horizontalBorderLeft: u32,
    pub horizontalBorderRight: u32,
    pub verticalBorderTop: u32,
    pub verticalBorderBottom: u32,
    pub horizontalSyncConfig: u32,
    pub horizontalSyncLevel: u32,
    pub verticalSyncConfig: u32,
    pub verticalSyncLevel: u32,
    pub numLinks: u32,
    pub verticalBlankingExtension: u32,
    pub pixelEncoding: u16,
    pub bitsPerColorComponent: u16,
    pub colorimetry: u16,
    pub dynamicRange: u16,
    pub dscCompressedBitsPerPixel: u16,
    pub dscSliceHeight: u16,
    pub dscSliceWidth: u16,
    pub verticalBlankingMaxStretchPerFrame: u16,
    pub verticalBlankingMaxShrinkPerFrame: u16,
    pub(crate) __reservedB: [u16; 3],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODetailedTimingInformationV2 {
    const ENCODING: Encoding = Encoding::Struct(
        "IODetailedTimingInformationV2",
        &[
            <[u32; 3]>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u64>::ENCODING,
            <u64>::ENCODING,
            <u64>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <[u16; 3]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODetailedTimingInformationV2 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IODetailedTimingInformation = IODetailedTimingInformationV2;

#[repr(C)]
#[derive(Clone, Copy)]
pub union IOTimingInformation_detailedInfo {
    pub v1: IODetailedTimingInformationV1,
    pub v2: IODetailedTimingInformationV2,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOTimingInformation_detailedInfo {
    const ENCODING: Encoding = Encoding::Union(
        "?",
        &[
            <IODetailedTimingInformationV1>::ENCODING,
            <IODetailedTimingInformationV2>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOTimingInformation_detailedInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy)]
pub struct IOTimingInformation {
    pub appleTimingID: IOAppleTimingID,
    pub flags: u32,
    pub detailedInfo: IOTimingInformation_detailedInfo,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOTimingInformation {
    const ENCODING: Encoding = Encoding::Struct(
        "IOTimingInformation",
        &[
            <IOAppleTimingID>::ENCODING,
            <u32>::ENCODING,
            <IOTimingInformation_detailedInfo>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOTimingInformation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kIODetailedTimingValid: c_uint = 0x80000000;
pub const kIOScalingInfoValid: c_uint = 0x40000000;

pub const kIOScaleStretchToFit: c_uint = 0x00000001;
pub const kIOScaleRotateFlags: c_uint = 0x000000f0;
pub const kIOScaleSwapAxes: c_uint = 0x00000010;
pub const kIOScaleInvertX: c_uint = 0x00000020;
pub const kIOScaleInvertY: c_uint = 0x00000040;
pub const kIOScaleRotate0: c_uint = 0x00000000;
pub const kIOScaleRotate90: c_uint = kIOScaleSwapAxes | kIOScaleInvertX;
pub const kIOScaleRotate180: c_uint = kIOScaleInvertX | kIOScaleInvertY;
pub const kIOScaleRotate270: c_uint = kIOScaleSwapAxes | kIOScaleInvertY;

pub const kIOPixelEncodingNotSupported: c_uint = 0x0000;
pub const kIOPixelEncodingRGB444: c_uint = 0x0001;
pub const kIOPixelEncodingYCbCr444: c_uint = 0x0002;
pub const kIOPixelEncodingYCbCr422: c_uint = 0x0004;
pub const kIOPixelEncodingYCbCr420: c_uint = 0x0008;

pub const kIOBitsPerColorComponentNotSupported: c_uint = 0x0000;
pub const kIOBitsPerColorComponent6: c_uint = 0x0001;
pub const kIOBitsPerColorComponent8: c_uint = 0x0002;
pub const kIOBitsPerColorComponent10: c_uint = 0x0004;
pub const kIOBitsPerColorComponent12: c_uint = 0x0008;
pub const kIOBitsPerColorComponent16: c_uint = 0x0010;

pub const kIOColorimetryNotSupported: c_uint = 0x0000;
pub const kIOColorimetryNativeRGB: c_uint = 0x0001;
pub const kIOColorimetrysRGB: c_uint = 0x0002;
pub const kIOColorimetryDCIP3: c_uint = 0x0004;
pub const kIOColorimetryAdobeRGB: c_uint = 0x0008;
pub const kIOColorimetryxvYCC: c_uint = 0x0010;
pub const kIOColorimetryWGRGB: c_uint = 0x0020;
pub const kIOColorimetryBT601: c_uint = 0x0040;
pub const kIOColorimetryBT709: c_uint = 0x0080;
pub const kIOColorimetryBT2020: c_uint = 0x0100;
pub const kIOColorimetryBT2100: c_uint = 0x0200;

pub const kIODynamicRangeNotSupported: c_uint = 0x0000;
pub const kIODynamicRangeSDR: c_uint = 0x0001;
pub const kIODynamicRangeHDR10: c_uint = 0x0002;
pub const kIODynamicRangeDolbyNormalMode: c_uint = 0x0004;
pub const kIODynamicRangeDolbyTunnelMode: c_uint = 0x0008;
pub const kIODynamicRangeTraditionalGammaHDR: c_uint = 0x0010;
pub const kIODynamicRangeTraditionalGammaSDR: c_uint = 0x0020;

#[repr(C, packed(4))]
#[derive(Clone, Copy)]
pub struct IOFBDisplayModeDescription {
    pub info: IODisplayModeInformation,
    pub timingInfo: IOTimingInformation,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOFBDisplayModeDescription {
    const ENCODING: Encoding = Encoding::Struct(
        "IOFBDisplayModeDescription",
        &[
            <IODisplayModeInformation>::ENCODING,
            <IOTimingInformation>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOFBDisplayModeDescription {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A structure defining the limits and attributes of a display or framebuffer.
///
/// This structure is used to define the limits for modes programmed as detailed timings by the OS. The VESA EDID is useful background information for many of these fields. A data property with this structure under the key kIOFBTimingRangeKey in a framebuffer will allow the OS to program detailed timings that fall within its range.
/// Field: __reservedA Set to zero.
/// Field: version Set to zero.
/// Field: __reservedB Set to zero.
/// Field: minPixelClock minimum pixel clock frequency in range, in Hz.
/// Field: minPixelClock maximum pixel clock frequency in range, in Hz.
/// Field: maxPixelError largest variation between specified and actual pixel clock frequency, in Hz.
/// Field: supportedSyncFlags mask of supported sync attributes. The following are defined:
/// <br>
/// kIORangeSupportsSeparateSyncs - digital separate syncs.
/// <br>
/// kIORangeSupportsSyncOnGreen - sync on green.
/// <br>
/// kIORangeSupportsCompositeSync - composite sync.
/// <br>
/// kIORangeSupportsVSyncSerration - vertical sync has serration and equalization pulses.
/// <br>
/// kIORangeSupportsVRR - variable refresh rate.
/// <br>
/// Field: supportedSignalLevels mask of possible signal levels. The following are defined:
/// <br>
/// kIORangeSupportsSignal_0700_0300 0.700 - 0.300 V p-p.
/// <br>
/// kIORangeSupportsSignal_0714_0286 0.714 - 0.286 V p-p.
/// <br>
/// kIORangeSupportsSignal_1000_0400 1.000 - 0.400 V p-p.
/// <br>
/// kIORangeSupportsSignal_0700_0000 0.700 - 0.000 V p-p.
/// <br>
/// Field: supportedSignalConfigs mask of possible signal configurations. The following are defined:
/// <br>
/// kIORangeSupportsInterlacedCEATiming Supports CEA style interlaced timing:
/// <br>
/// Field 1 vertical blanking = specified vertical blanking lines.
/// <br>
/// Field 2 vertical blanking = vertical blanking lines + 1 line.
/// <br>
/// Field 1 vertical offset = specified vertical sync offset.
/// <br>
/// Field 2 vertical offset = specified vertical sync offset + 0.5 lines.
/// <br>
/// kIORangeSupportsInterlacedCEATimingWithConfirm Supports CEA style interlaced timing, but require a confirm.
/// Field: minFrameRate minimum frame rate (vertical refresh frequency) in range, in Hz.
/// Field: maxFrameRate maximum frame rate (vertical refresh frequency) in range, in Hz.
/// Field: minLineRate minimum line rate (horizontal refresh frequency) in range, in Hz.
/// Field: maxLineRate maximum line rate (horizontal refresh frequency) in range, in Hz.
/// Field: maxHorizontalTotal maximum clocks in horizontal line (active + blanking).
/// Field: maxVerticalTotal maximum lines in vertical frame (active + blanking).
/// Field: __reservedD Set to zero.
/// Field: charSizeHorizontalActive horizontalActive must be a multiple of charSizeHorizontalActive.
/// Field: charSizeHorizontalBlanking horizontalBlanking must be a multiple of charSizeHorizontalBlanking.
/// Field: charSizeHorizontalSyncOffset horizontalSyncOffset must be a multiple of charSizeHorizontalSyncOffset.
/// Field: charSizeHorizontalSyncPulse horizontalSyncPulse must be a multiple of charSizeHorizontalSyncPulse.
/// Field: charSizeVerticalActive verticalActive must be a multiple of charSizeVerticalActive.
/// Field: charSizeVerticalBlanking verticalBlanking must be a multiple of charSizeVerticalBlanking.
/// Field: charSizeVerticalSyncOffset verticalSyncOffset must be a multiple of charSizeVerticalSyncOffset.
/// Field: charSizeVerticalSyncPulse verticalSyncPulse must be a multiple of charSizeVerticalSyncPulse.
/// Field: charSizeHorizontalBorderLeft horizontalBorderLeft must be a multiple of charSizeHorizontalBorderLeft.
/// Field: charSizeHorizontalBorderRight horizontalBorderRight must be a multiple of charSizeHorizontalBorderRight.
/// Field: charSizeVerticalBorderTop verticalBorderTop must be a multiple of charSizeVerticalBorderTop.
/// Field: charSizeVerticalBorderBottom verticalBorderBottom must be a multiple of charSizeVerticalBorderBottom.
/// Field: charSizeHorizontalTotal (horizontalActive + horizontalBlanking) must be a multiple of charSizeHorizontalTotal.
/// Field: charSizeVerticalTotal (verticalActive + verticalBlanking) must be a multiple of charSizeVerticalTotal.
/// Field: __reservedE Set to zero.
/// Field: minHorizontalActiveClocks minimum value of horizontalActive.
/// Field: maxHorizontalActiveClocks maximum value of horizontalActive.
/// Field: minHorizontalBlankingClocks minimum value of horizontalBlanking.
/// Field: maxHorizontalBlankingClocks maximum value of horizontalBlanking.
/// Field: minHorizontalSyncOffsetClocks minimum value of horizontalSyncOffset.
/// Field: maxHorizontalSyncOffsetClocks maximum value of horizontalSyncOffset.
/// Field: minHorizontalPulseWidthClocks minimum value of horizontalPulseWidth.
/// Field: maxHorizontalPulseWidthClocks maximum value of horizontalPulseWidth.
/// Field: minVerticalActiveClocks minimum value of verticalActive.
/// Field: maxVerticalActiveClocks maximum value of verticalActive.
/// Field: minVerticalBlankingClocks minimum value of verticalBlanking.
/// Field: maxVerticalBlankingClocks maximum value of verticalBlanking.
/// Field: minVerticalSyncOffsetClocks minimum value of verticalSyncOffset.
/// Field: maxVerticalSyncOffsetClocks maximum value of verticalSyncOffset.
/// Field: minVerticalPulseWidthClocks minimum value of verticalPulseWidth.
/// Field: maxVerticalPulseWidthClocks maximum value of verticalPulseWidth.
/// Field: minHorizontalBorderLeft minimum value of horizontalBorderLeft.
/// Field: maxHorizontalBorderLeft maximum value of horizontalBorderLeft.
/// Field: minHorizontalBorderRight minimum value of horizontalBorderRight.
/// Field: maxHorizontalBorderRight maximum value of horizontalBorderRight.
/// Field: minVerticalBorderTop minimum value of verticalBorderTop.
/// Field: maxVerticalBorderTop maximum value of verticalBorderTop.
/// Field: minVerticalBorderBottom minimum value of verticalBorderBottom.
/// Field: maxVerticalBorderBottom maximum value of verticalBorderBottom.
/// Field: maxNumLinks number of links supported, if zero, 1 link is assumed.
/// Field: minLink0PixelClock minimum pixel clock for link 0 (kHz).
/// Field: maxLink0PixelClock maximum pixel clock for link 0 (kHz).
/// Field: minLink1PixelClock minimum pixel clock for link 1 (kHz).
/// Field: maxLink1PixelClock maximum pixel clock for link 1 (kHz).
/// Field: supportedPixelEncoding 2017 Timing Features - ERS 2-58 (6.3.1)
/// Field: supportedBitsPerColorComponent 2017 Timing Features - ERS 2-58 (6.3.1)
/// Field: supportedColorimetry 2017 Timing Features - ERS 2-58 (6.3.1)
/// Field: supportedDynamicRange 2017 Timing Features - ERS 2-58 (6.3.1)
/// Field: __reservedF Set to zero.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IODisplayTimingRangeV1 {
    pub(crate) __reservedA: [u32; 2],
    pub version: u32,
    pub(crate) __reservedB: [u32; 5],
    pub minPixelClock: u64,
    pub maxPixelClock: u64,
    pub maxPixelError: u32,
    pub supportedSyncFlags: u32,
    pub supportedSignalLevels: u32,
    pub supportedSignalConfigs: u32,
    pub minFrameRate: u32,
    pub maxFrameRate: u32,
    pub minLineRate: u32,
    pub maxLineRate: u32,
    pub maxHorizontalTotal: u32,
    pub maxVerticalTotal: u32,
    pub(crate) __reservedD: [u32; 2],
    pub charSizeHorizontalActive: u8,
    pub charSizeHorizontalBlanking: u8,
    pub charSizeHorizontalSyncOffset: u8,
    pub charSizeHorizontalSyncPulse: u8,
    pub charSizeVerticalActive: u8,
    pub charSizeVerticalBlanking: u8,
    pub charSizeVerticalSyncOffset: u8,
    pub charSizeVerticalSyncPulse: u8,
    pub charSizeHorizontalBorderLeft: u8,
    pub charSizeHorizontalBorderRight: u8,
    pub charSizeVerticalBorderTop: u8,
    pub charSizeVerticalBorderBottom: u8,
    pub charSizeHorizontalTotal: u8,
    pub charSizeVerticalTotal: u8,
    pub(crate) __reservedE: u16,
    pub minHorizontalActiveClocks: u32,
    pub maxHorizontalActiveClocks: u32,
    pub minHorizontalBlankingClocks: u32,
    pub maxHorizontalBlankingClocks: u32,
    pub minHorizontalSyncOffsetClocks: u32,
    pub maxHorizontalSyncOffsetClocks: u32,
    pub minHorizontalPulseWidthClocks: u32,
    pub maxHorizontalPulseWidthClocks: u32,
    pub minVerticalActiveClocks: u32,
    pub maxVerticalActiveClocks: u32,
    pub minVerticalBlankingClocks: u32,
    pub maxVerticalBlankingClocks: u32,
    pub minVerticalSyncOffsetClocks: u32,
    pub maxVerticalSyncOffsetClocks: u32,
    pub minVerticalPulseWidthClocks: u32,
    pub maxVerticalPulseWidthClocks: u32,
    pub minHorizontalBorderLeft: u32,
    pub maxHorizontalBorderLeft: u32,
    pub minHorizontalBorderRight: u32,
    pub maxHorizontalBorderRight: u32,
    pub minVerticalBorderTop: u32,
    pub maxVerticalBorderTop: u32,
    pub minVerticalBorderBottom: u32,
    pub maxVerticalBorderBottom: u32,
    pub maxNumLinks: u32,
    pub minLink0PixelClock: u32,
    pub maxLink0PixelClock: u32,
    pub minLink1PixelClock: u32,
    pub maxLink1PixelClock: u32,
    pub supportedPixelEncoding: u16,
    pub supportedBitsPerColorComponent: u16,
    pub supportedColorimetryModes: u16,
    pub supportedDynamicRangeModes: u16,
    pub(crate) __reservedF: [u32; 1],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODisplayTimingRangeV1 {
    const ENCODING: Encoding = Encoding::Struct(
        "IODisplayTimingRangeV1",
        &[
            <[u32; 2]>::ENCODING,
            <u32>::ENCODING,
            <[u32; 5]>::ENCODING,
            <u64>::ENCODING,
            <u64>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 2]>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u16>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <[u32; 1]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODisplayTimingRangeV1 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A structure defining the limits and attributes of DSC capabilities in a  framebuffer.
///
/// This structure is used to define the limits for DSC enabled modes programmed as detailed timings by the OS. The VESA DSC spec is useful background information for many of these fields.
/// Field: maxBandwidth Maximum permitted bandwidth of the given topology in bits per second.
/// Field: dscMinSliceHeight Minimum slice Height, in units of line.
/// Field: dscMaxSliceHeight Maximum slice Height, in units of line.
/// Field: dscMinSliceWidth  Minimum slice width, in units of line.
/// Field: dscMaxSliceWidth  Maximum slice width, in units of line.
/// Field: dscMinSlicePerLine Minimum slice per Line.
/// Field: dscMaxSlicePerLine Maximum slice per Line.
/// Field: dscMinBPC  Minimum Bits per component, in units of bits.
/// Field: dscMaxBPC  Maximum Bits per component, in units of bits.
/// Field: dscMinBPP  Minimum target bits/pixel, in bpp.
/// Field: dscMaxBPP  Maximum target bits/pixel, in bpp.
/// Field: dscVBR     VBR mode, 0:disabled 1:enabled.
/// Field: dscBlockPredEnable  DSC BP is user or not, 0: not used, 1: used.
/// Field: __reservedF  Set to zero.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IODisplayTimingRangeV2 {
    pub(crate) __reservedA: [u32; 2],
    pub version: u32,
    pub(crate) __reservedB: [u32; 5],
    pub minPixelClock: u64,
    pub maxPixelClock: u64,
    pub maxPixelError: u32,
    pub supportedSyncFlags: u32,
    pub supportedSignalLevels: u32,
    pub supportedSignalConfigs: u32,
    pub minFrameRate: u32,
    pub maxFrameRate: u32,
    pub minLineRate: u32,
    pub maxLineRate: u32,
    pub maxHorizontalTotal: u32,
    pub maxVerticalTotal: u32,
    pub(crate) __reservedD: [u32; 2],
    pub charSizeHorizontalActive: u8,
    pub charSizeHorizontalBlanking: u8,
    pub charSizeHorizontalSyncOffset: u8,
    pub charSizeHorizontalSyncPulse: u8,
    pub charSizeVerticalActive: u8,
    pub charSizeVerticalBlanking: u8,
    pub charSizeVerticalSyncOffset: u8,
    pub charSizeVerticalSyncPulse: u8,
    pub charSizeHorizontalBorderLeft: u8,
    pub charSizeHorizontalBorderRight: u8,
    pub charSizeVerticalBorderTop: u8,
    pub charSizeVerticalBorderBottom: u8,
    pub charSizeHorizontalTotal: u8,
    pub charSizeVerticalTotal: u8,
    pub(crate) __reservedE: u16,
    pub minHorizontalActiveClocks: u32,
    pub maxHorizontalActiveClocks: u32,
    pub minHorizontalBlankingClocks: u32,
    pub maxHorizontalBlankingClocks: u32,
    pub minHorizontalSyncOffsetClocks: u32,
    pub maxHorizontalSyncOffsetClocks: u32,
    pub minHorizontalPulseWidthClocks: u32,
    pub maxHorizontalPulseWidthClocks: u32,
    pub minVerticalActiveClocks: u32,
    pub maxVerticalActiveClocks: u32,
    pub minVerticalBlankingClocks: u32,
    pub maxVerticalBlankingClocks: u32,
    pub minVerticalSyncOffsetClocks: u32,
    pub maxVerticalSyncOffsetClocks: u32,
    pub minVerticalPulseWidthClocks: u32,
    pub maxVerticalPulseWidthClocks: u32,
    pub minHorizontalBorderLeft: u32,
    pub maxHorizontalBorderLeft: u32,
    pub minHorizontalBorderRight: u32,
    pub maxHorizontalBorderRight: u32,
    pub minVerticalBorderTop: u32,
    pub maxVerticalBorderTop: u32,
    pub minVerticalBorderBottom: u32,
    pub maxVerticalBorderBottom: u32,
    pub maxNumLinks: u32,
    pub minLink0PixelClock: u32,
    pub maxLink0PixelClock: u32,
    pub minLink1PixelClock: u32,
    pub maxLink1PixelClock: u32,
    pub supportedPixelEncoding: u16,
    pub supportedBitsPerColorComponent: u16,
    pub supportedColorimetryModes: u16,
    pub supportedDynamicRangeModes: u16,
    pub(crate) __reservedF: [u32; 1],
    pub maxBandwidth: u64,
    pub dscMinSliceHeight: u32,
    pub dscMaxSliceHeight: u32,
    pub dscMinSliceWidth: u32,
    pub dscMaxSliceWidth: u32,
    pub dscMinSlicePerLine: u32,
    pub dscMaxSlicePerLine: u32,
    pub dscMinBPC: u16,
    pub dscMaxBPC: u16,
    pub dscMinBPP: u16,
    pub dscMaxBPP: u16,
    pub dscVBR: u8,
    pub dscBlockPredEnable: u8,
    pub(crate) __reservedC: [u32; 6],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODisplayTimingRangeV2 {
    const ENCODING: Encoding = Encoding::Struct(
        "IODisplayTimingRangeV2",
        &[
            <[u32; 2]>::ENCODING,
            <u32>::ENCODING,
            <[u32; 5]>::ENCODING,
            <u64>::ENCODING,
            <u64>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 2]>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u16>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <[u32; 1]>::ENCODING,
            <u64>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <[u32; 6]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODisplayTimingRangeV2 {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IODisplayTimingRange = IODisplayTimingRangeV2;

pub const kIOTimingRangeV2: c_uint = 0x00000002;
pub const kIOTimingRangeV1: c_uint = 0x00000000;

pub const kIORangePixelEncodingNotSupported: c_uint = 0x0000;
pub const kIORangePixelEncodingRGB444: c_uint = 0x0001;
pub const kIORangePixelEncodingYCbCr444: c_uint = 0x0002;
pub const kIORangePixelEncodingYCbCr422: c_uint = 0x0004;
pub const kIORangePixelEncodingYCbCr420: c_uint = 0x0008;

pub const kIORangeBitsPerColorComponentNotSupported: c_uint = 0x0000;
pub const kIORangeBitsPerColorComponent6: c_uint = 0x0001;
pub const kIORangeBitsPerColorComponent8: c_uint = 0x0002;
pub const kIORangeBitsPerColorComponent10: c_uint = 0x0004;
pub const kIORangeBitsPerColorComponent12: c_uint = 0x0008;
pub const kIORangeBitsPerColorComponent16: c_uint = 0x0010;

pub const kIORangeColorimetryNotSupported: c_uint = 0x0000;
pub const kIORangeColorimetryNativeRGB: c_uint = 0x0001;
pub const kIORangeColorimetrysRGB: c_uint = 0x0002;
pub const kIORangeColorimetryDCIP3: c_uint = 0x0004;
pub const kIORangeColorimetryAdobeRGB: c_uint = 0x0008;
pub const kIORangeColorimetryxvYCC: c_uint = 0x0010;
pub const kIORangeColorimetryWGRGB: c_uint = 0x0020;
pub const kIORangeColorimetryBT601: c_uint = 0x0040;
pub const kIORangeColorimetryBT709: c_uint = 0x0080;
pub const kIORangeColorimetryBT2020: c_uint = 0x0100;
pub const kIORangeColorimetryBT2100: c_uint = 0x0200;

pub const kIORangeDynamicRangeNotSupported: c_uint = 0x0000;
pub const kIORangeDynamicRangeSDR: c_uint = 0x0001;
pub const kIORangeDynamicRangeHDR10: c_uint = 0x0002;
pub const kIORangeDynamicRangeDolbyNormalMode: c_uint = 0x0004;
pub const kIORangeDynamicRangeDolbyTunnelMode: c_uint = 0x0008;
pub const kIORangeDynamicRangeTraditionalGammaHDR: c_uint = 0x0010;
pub const kIORangeDynamicRangeTraditionalGammaSDR: c_uint = 0x0020;

pub const kIORangeSupportsSignal_0700_0300: c_uint = 0x00000001;
pub const kIORangeSupportsSignal_0714_0286: c_uint = 0x00000002;
pub const kIORangeSupportsSignal_1000_0400: c_uint = 0x00000004;
pub const kIORangeSupportsSignal_0700_0000: c_uint = 0x00000008;

pub const kIORangeSupportsSeparateSyncs: c_uint = 0x00000001;
pub const kIORangeSupportsSyncOnGreen: c_uint = 0x00000002;
pub const kIORangeSupportsCompositeSync: c_uint = 0x00000004;
pub const kIORangeSupportsVSyncSerration: c_uint = 0x00000008;
pub const kIORangeSupportsVRR: c_uint = 0x00000010;

pub const kIORangeSupportsInterlacedCEATiming: c_uint = 0x00000004;
pub const kIORangeSupportsInterlacedCEATimingWithConfirm: c_uint = 0x00000008;
pub const kIORangeSupportsMultiAlignedTiming: c_uint = 0x00000040;

pub const kIODigitalSignal: c_uint = 0x00000001;
pub const kIOAnalogSetupExpected: c_uint = 0x00000002;
pub const kIOInterlacedCEATiming: c_uint = 0x00000004;
pub const kIONTSCTiming: c_uint = 0x00000008;
pub const kIOPALTiming: c_uint = 0x00000010;
pub const kIODSCBlockPredEnable: c_uint = 0x00000020;
pub const kIOMultiAlignedTiming: c_uint = 0x00000040;

pub const kIOAnalogSignalLevel_0700_0300: c_uint = 0;
pub const kIOAnalogSignalLevel_0714_0286: c_uint = 1;
pub const kIOAnalogSignalLevel_1000_0400: c_uint = 2;
pub const kIOAnalogSignalLevel_0700_0000: c_uint = 3;

pub const kIOSyncPositivePolarity: c_uint = 0x00000001;

/// A structure defining the scaling capabilities of a framebuffer.
///
/// This structure is used to define the limits for modes programmed as detailed timings by the OS. A data property with this structure under the key kIOFBScalerInfoKey in a framebuffer will allow the OS to program detailed timings that are scaled to a displays native resolution.
/// Field: __reservedA Set to zero.
/// Field: version Set to zero.
/// Field: __reservedB Set to zero.
/// Field: scalerFeatures Mask of scaling features. The following are defined:
/// <br>
/// kIOScaleStretchOnly If set the framebuffer can only provide stretched scaling with non-square pixels, without borders.
/// <br>
/// kIOScaleCanUpSamplePixels If set framebuffer can scale up from a smaller number of source pixels to a larger native timing (eg. 640x480 pixels on a 1600x1200 timing).
/// <br>
/// kIOScaleCanDownSamplePixels If set framebuffer can scale down from a larger number of source pixels to a smaller native timing (eg. 1600x1200 pixels on a 640x480 timing).
/// <br>
/// kIOScaleCanScaleInterlaced If set framebuffer can scale an interlaced detailed timing.
/// <br>
/// kIOScaleCanSupportInset If set framebuffer can support scaled modes with non-zero horizontalScaledInset, verticalScaledInset fields.
/// <br>
/// kIOScaleCanRotate If set framebuffer can support some of the flags in the kIOScaleRotateFlags mask.
/// <br>
/// kIOScaleCanBorderInsetOnly If set framebuffer can support scaled modes with non-zero horizontalScaledInset, verticalScaledInset fields, but requires the active pixels to be equal in size to the inset area, ie. can do insets with a border versus scaling an image.
/// <br>
/// Field: maxHorizontalPixels Maximum number of horizontal source pixels (horizontalScaled).
/// <br>
/// Field: maxVerticalPixels Maximum number of vertical source pixels (verticalScaled).
/// <br>
/// Field: __reservedC Set to zero.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IODisplayScalerInformation {
    pub(crate) __reservedA: [u32; 1],
    pub version: u32,
    pub(crate) __reservedB: [u32; 2],
    pub scalerFeatures: IOOptionBits,
    pub maxHorizontalPixels: u32,
    pub maxVerticalPixels: u32,
    pub(crate) __reservedC: [u32; 5],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IODisplayScalerInformation {
    const ENCODING: Encoding = Encoding::Struct(
        "IODisplayScalerInformation",
        &[
            <[u32; 1]>::ENCODING,
            <u32>::ENCODING,
            <[u32; 2]>::ENCODING,
            <IOOptionBits>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 5]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IODisplayScalerInformation {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kIOScaleStretchOnly: c_uint = 0x00000001;
pub const kIOScaleCanUpSamplePixels: c_uint = 0x00000002;
pub const kIOScaleCanDownSamplePixels: c_uint = 0x00000004;
pub const kIOScaleCanScaleInterlaced: c_uint = 0x00000008;
pub const kIOScaleCanSupportInset: c_uint = 0x00000010;
pub const kIOScaleCanRotate: c_uint = 0x00000020;
pub const kIOScaleCanBorderInsetOnly: c_uint = 0x00000040;

pub const kOrConnections: c_uint = 0xffffffe;
pub const kAndConnections: c_uint = 0xffffffd;

pub const kConnectionFlags: c_uint = 0x666c6773;
pub const kConnectionSyncEnable: c_uint = 0x73796e63;
pub const kConnectionSyncFlags: c_uint = 0x73796366;
pub const kConnectionSupportsAppleSense: c_uint = 0x61736e73;
pub const kConnectionSupportsLLDDCSense: c_uint = 0x6c646463;
pub const kConnectionSupportsHLDDCSense: c_uint = 0x68646463;
pub const kConnectionEnable: c_uint = 0x656e6162;
pub const kConnectionCheckEnable: c_uint = 0x63656e61;
pub const kConnectionProbe: c_uint = 0x70726f62;
pub const kConnectionIgnore: c_uint = 0x00696772;
pub const kConnectionChanged: c_uint = 0x63686e67;
pub const kConnectionPower: c_uint = 0x706f7772;
pub const kConnectionPostWake: c_uint = 0x7077616b;
pub const kConnectionDisplayParameterCount: c_uint = 0x70636e74;
pub const kConnectionDisplayParameters: c_uint = 0x7061726d;
pub const kConnectionOverscan: c_uint = 0x6f73636e;
pub const kConnectionVideoBest: c_uint = 0x76627374;
pub const kConnectionRedGammaScale: c_uint = 0x72677363;
pub const kConnectionGreenGammaScale: c_uint = 0x67677363;
pub const kConnectionBlueGammaScale: c_uint = 0x62677363;
pub const kConnectionGammaScale: c_uint = 0x67736320;
pub const kConnectionFlushParameters: c_uint = 0x666c7573;
pub const kConnectionVBLMultiplier: c_uint = 0x76626c6d;
pub const kConnectionHandleDisplayPortEvent: c_uint = 0x64706972;
pub const kConnectionPanelTimingDisable: c_uint = 0x706e6c74;
pub const kConnectionColorMode: c_uint = 0x63797576;
pub const kConnectionColorModesSupported: c_uint = 0x636f6c72;
pub const kConnectionColorDepthsSupported: c_uint = 0x20627063;
pub const kConnectionControllerDepthsSupported: c_uint = 0x00677264;
pub const kConnectionControllerColorDepth: c_uint = 0x00647064;
pub const kConnectionControllerDitherControl: c_uint = 0x00676463;
pub const kConnectionDisplayFlags: c_uint = 0x64666c67;
pub const kConnectionEnableAudio: c_uint = 0x61756420;
pub const kConnectionAudioStreaming: c_uint = 0x61756473;
pub const kConnectionStartOfFrameTime: c_uint = 0x736f6674;

pub const kIOConnectionBuiltIn: c_uint = 0x00000800;
pub const kIOConnectionStereoSync: c_uint = 0x00008000;

pub const kIOHSyncDisable: c_uint = 0x00000001;
pub const kIOVSyncDisable: c_uint = 0x00000002;
pub const kIOCSyncDisable: c_uint = 0x00000004;
pub const kIONoSeparateSyncControl: c_uint = 0x00000040;
pub const kIOTriStateSyncs: c_uint = 0x00000080;
pub const kIOSyncOnBlue: c_uint = 0x00000008;
pub const kIOSyncOnGreen: c_uint = 0x00000010;
pub const kIOSyncOnRed: c_uint = 0x00000020;

pub const kIODPEventStart: c_uint = 1;
pub const kIODPEventIdle: c_uint = 2;
pub const kIODPEventForceRetrain: c_uint = 3;
pub const kIODPEventRemoteControlCommandPending: c_uint = 256;
pub const kIODPEventAutomatedTestRequest: c_uint = 257;
pub const kIODPEventContentProtection: c_uint = 258;
pub const kIODPEventMCCS: c_uint = 259;
pub const kIODPEventSinkSpecific: c_uint = 260;

pub const kIODisplayColorMode: c_uint = kConnectionColorMode;

pub const kIODisplayRGBColorComponentBitsUnknown: c_uint = 0x00000000;
pub const kIODisplayRGBColorComponentBits6: c_uint = 0x00000001;
pub const kIODisplayRGBColorComponentBits8: c_uint = 0x00000002;
pub const kIODisplayRGBColorComponentBits10: c_uint = 0x00000004;
pub const kIODisplayRGBColorComponentBits12: c_uint = 0x00000008;
pub const kIODisplayRGBColorComponentBits14: c_uint = 0x00000010;
pub const kIODisplayRGBColorComponentBits16: c_uint = 0x00000020;
pub const kIODisplayYCbCr444ColorComponentBitsUnknown: c_uint = 0x00000000;
pub const kIODisplayYCbCr444ColorComponentBits6: c_uint = 0x00000100;
pub const kIODisplayYCbCr444ColorComponentBits8: c_uint = 0x00000200;
pub const kIODisplayYCbCr444ColorComponentBits10: c_uint = 0x00000400;
pub const kIODisplayYCbCr444ColorComponentBits12: c_uint = 0x00000800;
pub const kIODisplayYCbCr444ColorComponentBits14: c_uint = 0x00001000;
pub const kIODisplayYCbCr444ColorComponentBits16: c_uint = 0x00002000;
pub const kIODisplayYCbCr422ColorComponentBitsUnknown: c_uint = 0x00000000;
pub const kIODisplayYCbCr422ColorComponentBits6: c_uint = 0x00010000;
pub const kIODisplayYCbCr422ColorComponentBits8: c_uint = 0x00020000;
pub const kIODisplayYCbCr422ColorComponentBits10: c_uint = 0x00040000;
pub const kIODisplayYCbCr422ColorComponentBits12: c_uint = 0x00080000;
pub const kIODisplayYCbCr422ColorComponentBits14: c_uint = 0x00100000;
pub const kIODisplayYCbCr422ColorComponentBits16: c_uint = 0x00200000;

pub const kIODisplayDitherDisable: c_uint = 0x00000000;
pub const kIODisplayDitherSpatial: c_uint = 0x00000001;
pub const kIODisplayDitherTemporal: c_uint = 0x00000002;
pub const kIODisplayDitherFrameRateControl: c_uint = 0x00000004;
pub const kIODisplayDitherDefault: c_uint = 0x00000080;
pub const kIODisplayDitherAll: c_uint = 0x000000FF;
pub const kIODisplayDitherRGBShift: c_uint = 0;
pub const kIODisplayDitherYCbCr444Shift: c_uint = 8;
pub const kIODisplayDitherYCbCr422Shift: c_uint = 16;

pub const kIODisplayNeedsCEAUnderscan: c_uint = 0x00000001;

pub const kIODisplayPowerStateOff: c_uint = 0;
pub const kIODisplayPowerStateMinUsable: c_uint = 1;
pub const kIODisplayPowerStateOn: c_uint = 2;

pub const kIOFBServerConnectType: c_uint = 0;
pub const kIOFBSharedConnectType: c_uint = 1;
pub const kIOGDiagnoseGTraceType: c_uint = 11452;
pub const kIOGDiagnoseConnectType: c_uint = 38744;
pub const kIODisplayAssertionConnectType: c_uint = 61074;

pub const kIOFBUserRequestProbe: c_uint = 0x00000001;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOGPoint {
    pub x: i16,
    pub y: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOGPoint {
    const ENCODING: Encoding = Encoding::Struct("IOGPoint", &[<i16>::ENCODING, <i16>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOGPoint {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOGSize {
    pub width: i16,
    pub height: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOGSize {
    const ENCODING: Encoding = Encoding::Struct("IOGSize", &[<i16>::ENCODING, <i16>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOGSize {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOGBounds {
    pub minx: i16,
    pub maxx: i16,
    pub miny: i16,
    pub maxy: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOGBounds {
    const ENCODING: Encoding = Encoding::Struct(
        "IOGBounds",
        &[
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
            <i16>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOGBounds {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kTransparentEncoding: c_uint = 0;
pub const kInvertingEncoding: c_uint = 1;

pub const kTransparentEncodingShift: c_uint = kTransparentEncoding << 1;
pub const kTransparentEncodedPixel: c_uint = 0x01 << kTransparentEncodingShift;
pub const kInvertingEncodingShift: c_uint = kInvertingEncoding << 1;
pub const kInvertingEncodedPixel: c_uint = 0x01 << kInvertingEncodingShift;

pub const kHardwareCursorDescriptorMajorVersion: c_uint = 0x0001;
pub const kHardwareCursorDescriptorMinorVersion: c_uint = 0x0000;

/// A structure defining the format of a hardware cursor.
///
/// ## Overview
///
/// This structure is used by IOFramebuffer to define the format of a hardware cursor.
///
///
/// A structure defining the format of a hardware cursor.
///
/// This structure is used by IOFramebuffer to define the format of a hardware cursor.
/// Field: majorVersion Set to kHardwareCursorDescriptorMajorVersion.
/// Field: minorVersion Set to kHardwareCursorDescriptorMinorVersion.
/// Field: height Maximum size of the cursor.
/// Field: width Maximum size of the cursor.
/// Field: bitDepth Number bits per pixel, or a QD/QT pixel type, for example kIO8IndexedPixelFormat, kIO32ARGBPixelFormat.
/// Field: maskBitDepth Unused.
/// Field: numColors Number of colors for indexed pixel types.
/// Field: colorEncodings An array pointer specifying the pixel values corresponding to the indices into the color table, for indexed pixel types.
/// Field: flags None defined, set to zero.
/// Field: supportedSpecialEncodings Mask of supported special pixel values, eg. kTransparentEncodedPixel, kInvertingEncodedPixel.
/// Field: specialEncodings Array of pixel values for each supported special encoding.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHardwareCursorDescriptor {
    pub majorVersion: u16,
    pub minorVersion: u16,
    pub height: u32,
    pub width: u32,
    pub bitDepth: u32,
    pub maskBitDepth: u32,
    pub numColors: u32,
    pub colorEncodings: *mut u32,
    pub flags: u32,
    pub supportedSpecialEncodings: u32,
    pub specialEncodings: [u32; 16],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHardwareCursorDescriptor {
    const ENCODING: Encoding = Encoding::Struct(
        "IOHardwareCursorDescriptor",
        &[
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <*mut u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <[u32; 16]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHardwareCursorDescriptor {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kHardwareCursorInfoMajorVersion: c_uint = 0x0001;
pub const kHardwareCursorInfoMinorVersion: c_uint = 0x0000;

/// A structure defining the converted data of a hardware cursor.
///
/// ## Overview
///
/// This structure is used by IOFramebuffer to return the data of a hardware cursor by convertCursorImage() after conversion based on the IOHardwareCursorDescriptor passed to that routine.
///
///
/// A structure defining the converted data of a hardware cursor.
///
/// This structure is used by IOFramebuffer to return the data of a hardware cursor by convertCursorImage() after conversion based on the IOHardwareCursorDescriptor passed to that routine.
/// Field: majorVersion Set to kHardwareCursorInfoMajorVersion.
/// Field: minorVersion Set to kHardwareCursorInfoMinorVersion.
/// Field: cursorHeight The actual size of the cursor is returned.
/// Field: cursorWidth The actual size of the cursor is returned.
/// Field: colorMap Pointer to array of IOColorEntry structures, with the number of elements set by the numColors field of the IOHardwareCursorDescriptor. Zero should be passed for direct pixel formats.
/// Field: hardwareCursorData Buffer to receive the converted cursor data.
/// Field: cursorHotSpotX Cursor's hotspot.
/// Field: cursorHotSpotY Cursor's hotspot.
/// Field: reserved Reserved, set to zero.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOHardwareCursorInfo {
    pub majorVersion: u16,
    pub minorVersion: u16,
    pub cursorHeight: u32,
    pub cursorWidth: u32,
    pub colorMap: *mut IOColorEntry,
    pub hardwareCursorData: *mut u8,
    pub cursorHotSpotX: u16,
    pub cursorHotSpotY: u16,
    pub reserved: [u32; 5],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOHardwareCursorInfo {
    const ENCODING: Encoding = Encoding::Struct(
        "IOHardwareCursorInfo",
        &[
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <*mut IOColorEntry>::ENCODING,
            <*mut u8>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <[u32; 5]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOHardwareCursorInfo {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kIOFBVBLInterruptType: c_uint = 0x76626c20;
pub const kIOFBHBLInterruptType: c_uint = 0x68626c20;
pub const kIOFBFrameInterruptType: c_uint = 0x6672616d;
pub const kIOFBConnectInterruptType: c_uint = 0x64636920;
pub const kIOFBChangedInterruptType: c_uint = 0x63686e67;
pub const kIOFBOfflineInterruptType: c_uint = 0x72656d76;
pub const kIOFBOnlineInterruptType: c_uint = 0x61646420;
pub const kIOFBDisplayPortInterruptType: c_uint = 0x64706972;
pub const kIOFBDisplayPortLinkChangeInterruptType: c_uint = 0x64706c6b;
pub const kIOFBMCCSInterruptType: c_uint = 0x6d636373;
pub const kIOFBWakeInterruptType: c_uint = 0x7677616b;

pub const kIOTimingIDInvalid: c_uint = 0;
pub const kIOTimingIDApple_FixedRateLCD: c_uint = 42;
pub const kIOTimingIDApple_512x384_60hz: c_uint = 130;
pub const kIOTimingIDApple_560x384_60hz: c_uint = 135;
pub const kIOTimingIDApple_640x480_67hz: c_uint = 140;
pub const kIOTimingIDApple_640x400_67hz: c_uint = 145;
pub const kIOTimingIDVESA_640x480_60hz: c_uint = 150;
pub const kIOTimingIDVESA_640x480_72hz: c_uint = 152;
pub const kIOTimingIDVESA_640x480_75hz: c_uint = 154;
pub const kIOTimingIDVESA_640x480_85hz: c_uint = 158;
pub const kIOTimingIDGTF_640x480_120hz: c_uint = 159;
pub const kIOTimingIDApple_640x870_75hz: c_uint = 160;
pub const kIOTimingIDApple_640x818_75hz: c_uint = 165;
pub const kIOTimingIDApple_832x624_75hz: c_uint = 170;
pub const kIOTimingIDVESA_800x600_56hz: c_uint = 180;
pub const kIOTimingIDVESA_800x600_60hz: c_uint = 182;
pub const kIOTimingIDVESA_800x600_72hz: c_uint = 184;
pub const kIOTimingIDVESA_800x600_75hz: c_uint = 186;
pub const kIOTimingIDVESA_800x600_85hz: c_uint = 188;
pub const kIOTimingIDVESA_1024x768_60hz: c_uint = 190;
pub const kIOTimingIDVESA_1024x768_70hz: c_uint = 200;
pub const kIOTimingIDVESA_1024x768_75hz: c_uint = 204;
pub const kIOTimingIDVESA_1024x768_85hz: c_uint = 208;
pub const kIOTimingIDApple_1024x768_75hz: c_uint = 210;
pub const kIOTimingIDVESA_1152x864_75hz: c_uint = 215;
pub const kIOTimingIDApple_1152x870_75hz: c_uint = 220;
pub const kIOTimingIDAppleNTSC_ST: c_uint = 230;
pub const kIOTimingIDAppleNTSC_FF: c_uint = 232;
pub const kIOTimingIDAppleNTSC_STconv: c_uint = 234;
pub const kIOTimingIDAppleNTSC_FFconv: c_uint = 236;
pub const kIOTimingIDApplePAL_ST: c_uint = 238;
pub const kIOTimingIDApplePAL_FF: c_uint = 240;
pub const kIOTimingIDApplePAL_STconv: c_uint = 242;
pub const kIOTimingIDApplePAL_FFconv: c_uint = 244;
pub const kIOTimingIDVESA_1280x960_75hz: c_uint = 250;
pub const kIOTimingIDVESA_1280x960_60hz: c_uint = 252;
pub const kIOTimingIDVESA_1280x960_85hz: c_uint = 254;
pub const kIOTimingIDVESA_1280x1024_60hz: c_uint = 260;
pub const kIOTimingIDVESA_1280x1024_75hz: c_uint = 262;
pub const kIOTimingIDVESA_1280x1024_85hz: c_uint = 268;
pub const kIOTimingIDVESA_1600x1200_60hz: c_uint = 280;
pub const kIOTimingIDVESA_1600x1200_65hz: c_uint = 282;
pub const kIOTimingIDVESA_1600x1200_70hz: c_uint = 284;
pub const kIOTimingIDVESA_1600x1200_75hz: c_uint = 286;
pub const kIOTimingIDVESA_1600x1200_80hz: c_uint = 288;
pub const kIOTimingIDVESA_1600x1200_85hz: c_uint = 289;
pub const kIOTimingIDVESA_1792x1344_60hz: c_uint = 296;
pub const kIOTimingIDVESA_1792x1344_75hz: c_uint = 298;
pub const kIOTimingIDVESA_1856x1392_60hz: c_uint = 300;
pub const kIOTimingIDVESA_1856x1392_75hz: c_uint = 302;
pub const kIOTimingIDVESA_1920x1440_60hz: c_uint = 304;
pub const kIOTimingIDVESA_1920x1440_75hz: c_uint = 306;
pub const kIOTimingIDSMPTE240M_60hz: c_uint = 400;
pub const kIOTimingIDFilmRate_48hz: c_uint = 410;
pub const kIOTimingIDSony_1600x1024_76hz: c_uint = 500;
pub const kIOTimingIDSony_1920x1080_60hz: c_uint = 510;
pub const kIOTimingIDSony_1920x1080_72hz: c_uint = 520;
pub const kIOTimingIDSony_1920x1200_76hz: c_uint = 540;
pub const kIOTimingIDApple_0x0_0hz_Offline: c_uint = 550;
pub const kIOTimingIDVESA_848x480_60hz: c_uint = 570;
pub const kIOTimingIDVESA_1360x768_60hz: c_uint = 590;

pub const kIOHibernatePreviewActive: c_uint = 0x00000001;
pub const kIOHibernatePreviewUpdates: c_uint = 0x00000002;

pub const kIOFBAVSignalTypeUnknown: c_uint = 0x00000000;
pub const kIOFBAVSignalTypeVGA: c_uint = 0x00000001;
pub const kIOFBAVSignalTypeDVI: c_uint = 0x00000002;
pub const kIOFBAVSignalTypeHDMI: c_uint = 0x00000008;
pub const kIOFBAVSignalTypeDP: c_uint = 0x00000010;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOFBDPLinkConfig {
    pub version: u16,
    pub bitRate: u8,
    pub(crate) __reservedA: [u8; 1],
    pub t1Time: u16,
    pub t2Time: u16,
    pub t3Time: u16,
    pub idlePatterns: u8,
    pub laneCount: u8,
    pub voltage: u8,
    pub preEmphasis: u8,
    pub downspread: u8,
    pub scrambler: u8,
    pub maxBitRate: u8,
    pub maxLaneCount: u8,
    pub maxDownspread: u8,
    pub(crate) __reservedB: [u8; 9],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOFBDPLinkConfig {
    const ENCODING: Encoding = Encoding::Struct(
        "IOFBDPLinkConfig",
        &[
            <u16>::ENCODING,
            <u8>::ENCODING,
            <[u8; 1]>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <[u8; 9]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOFBDPLinkConfig {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kIOFBBitRateRBR: c_uint = 0x06;
pub const kIOFBBitRateHBR: c_uint = 0x0A;
pub const kIOFBBitRateHBR2: c_uint = 0x14;

pub const kIOFBLinkVoltageLevel0: c_uint = 0x00;
pub const kIOFBLinkVoltageLevel1: c_uint = 0x01;
pub const kIOFBLinkVoltageLevel2: c_uint = 0x02;
pub const kIOFBLinkVoltageLevel3: c_uint = 0x03;

pub const kIOFBLinkPreEmphasisLevel0: c_uint = 0x00;
pub const kIOFBLinkPreEmphasisLevel1: c_uint = 0x01;
pub const kIOFBLinkPreEmphasisLevel2: c_uint = 0x02;
pub const kIOFBLinkPreEmphasisLevel3: c_uint = 0x03;

pub const kIOFBLinkDownspreadNone: c_uint = 0x0;
pub const kIOFBLinkDownspreadMax: c_uint = 0x1;

pub const kIOFBLinkScramblerNormal: c_uint = 0x0;
pub const kIOFBLinkScramblerAlternate: c_uint = 0x1;

pub const kDisplayVendorIDUnknown: c_uint = 0x756e6b6e;
pub const kDisplayProductIDGeneric: c_uint = 0x717;

pub const kDisplaySubPixelLayoutUndefined: c_uint = 0x00000000;
pub const kDisplaySubPixelLayoutRGB: c_uint = 0x00000001;
pub const kDisplaySubPixelLayoutBGR: c_uint = 0x00000002;
pub const kDisplaySubPixelLayoutQuadGBL: c_uint = 0x00000003;
pub const kDisplaySubPixelLayoutQuadGBR: c_uint = 0x00000004;
pub const kDisplaySubPixelConfigurationUndefined: c_uint = 0x00000000;
pub const kDisplaySubPixelConfigurationDelta: c_uint = 0x00000001;
pub const kDisplaySubPixelConfigurationStripe: c_uint = 0x00000002;
pub const kDisplaySubPixelConfigurationStripeOffset: c_uint = 0x00000003;
pub const kDisplaySubPixelConfigurationQuad: c_uint = 0x00000004;
pub const kDisplaySubPixelShapeUndefined: c_uint = 0x00000000;
pub const kDisplaySubPixelShapeRound: c_uint = 0x00000001;
pub const kDisplaySubPixelShapeSquare: c_uint = 0x00000002;
pub const kDisplaySubPixelShapeRectangular: c_uint = 0x00000003;
pub const kDisplaySubPixelShapeOval: c_uint = 0x00000004;
pub const kDisplaySubPixelShapeElliptical: c_uint = 0x00000005;

///
/// ## Discussion
///
/// The number of cursor images stored in the StdFBShmem_t structure.
///
///
pub const kIOFBNumCursorFrames: c_uint = 4;
///
/// ## Discussion
///
/// Used with waiting cursors.
///
///
pub const kIOFBNumCursorFramesShift: c_uint = 2;
///
/// ## Discussion
///
/// The maximum cursor pixel depth.
///
///
pub const kIOFBMaxCursorDepth: c_uint = 32;
pub const kIOFBMaxCursorWidth: c_uint = 256;
pub const kIOFBMaxCursorFrames: c_uint = 32;

/// Cursor image for 1-bit cursor.
///
/// ## Discussion
///
/// This structure stores 16 pixel x 16 pixel cursors to be used with 1-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
///
///
/// Cursor image for 1-bit cursor.
///
/// This structure stores 16 pixel x 16 pixel cursors to be used with 1-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
/// Field: image This array contains the cursor images.
/// Field: mask This array contains the cursor mask.
/// Field: save This array stores the pixel values of the region underneath the cursor in its last drawn position.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct bm12Cursor {
    pub image: [[c_uint; 16]; 4],
    pub mask: [[c_uint; 16]; 4],
    pub save: [c_uint; 16],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for bm12Cursor {
    const ENCODING: Encoding = Encoding::Struct(
        "bm12Cursor",
        &[
            <[[c_uint; 16]; 4]>::ENCODING,
            <[[c_uint; 16]; 4]>::ENCODING,
            <[c_uint; 16]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for bm12Cursor {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Cursor image for 8-bit cursor.
///
/// ## Discussion
///
/// This structure stores 16 pixel x 16 pixel cursors to be used with 8-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
///
///
/// Cursor image for 8-bit cursor.
///
/// This structure stores 16 pixel x 16 pixel cursors to be used with 8-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
/// Field: image This array contains cursor color values, which are converted to displayed colors through the color table. The array is two dimensional and its first index is the cursor frame and the second index is the cursor pixel.
/// Field: mask This array contains the cursor alpha mask. The array is two dimensional with the same indexing as the image. If an alpha mask pixel is 0 and the corresponding image pixel is set to white for the display, then this cursor pixel will invert pixels on the display.
/// Field: save This array stores the color values of the region underneath the cursor in its last drawn position.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct bm18Cursor {
    pub image: [[c_uchar; 256]; 4],
    pub mask: [[c_uchar; 256]; 4],
    pub save: [c_uchar; 256],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for bm18Cursor {
    const ENCODING: Encoding = Encoding::Struct(
        "bm18Cursor",
        &[
            <[[c_uchar; 256]; 4]>::ENCODING,
            <[[c_uchar; 256]; 4]>::ENCODING,
            <[c_uchar; 256]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for bm18Cursor {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Cursor image for 15-bit cursor.
///
/// ## Discussion
///
/// This structure stores 16 pixel x 16 pixel cursors to be used with 15-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
///
///
/// Cursor image for 15-bit cursor.
///
/// This structure stores 16 pixel x 16 pixel cursors to be used with 15-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
/// Field: image This array defines the cursor color values and transparency. The array is two dimensional and its first index is the cursor frame and the second index is the cursor pixel. A value of 0 means the pixel is transparent. Non-zero values are stored with the red, green, blue, and alpha values encoded with the following masks:
/// <BR
/// >
/// red mask = 0xF000
/// <br>
/// blue mask 0x0F00
/// <br>
/// green mask 0x00F0
/// <br>
/// alpha mask = 0x000F
/// <br>
/// Note, only 4 bits are allocated for each color component.
/// Field: save This array stores the color values of the region underneath the cursor in its last drawn position.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct bm34Cursor {
    pub image: [[c_ushort; 256]; 4],
    pub save: [c_ushort; 256],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for bm34Cursor {
    const ENCODING: Encoding = Encoding::Struct(
        "bm34Cursor",
        &[
            <[[c_ushort; 256]; 4]>::ENCODING,
            <[c_ushort; 256]>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for bm34Cursor {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Cursor image for 24-bit cursor.
///
/// ## Discussion
///
/// This structure stores 16 pixel x 16 pixel cursors to be used with 24-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
///
///
/// Cursor image for 24-bit cursor.
///
/// This structure stores 16 pixel x 16 pixel cursors to be used with 24-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
/// Field: image This array defines the cursor color values and transparency. The array is two dimensional and its first index is the cursor frame and the second index is the cursor pixel. The lower 24 bits of a pixel's value contain the RGB color, while the upper 8 bits contain the alpha value.
/// Field: save This array stores the color values of the region underneath the cursor in its last drawn position.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct bm38Cursor {
    pub image: [[c_uint; 256]; 4],
    pub save: [c_uint; 256],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for bm38Cursor {
    const ENCODING: Encoding = Encoding::Struct(
        "bm38Cursor",
        &[<[[c_uint; 256]; 4]>::ENCODING, <[c_uint; 256]>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for bm38Cursor {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kIOFBCursorImageNew: c_uint = 0x01;
pub const kIOFBCursorHWCapable: c_uint = 0x02;

pub const kIOFBHardwareCursorActive: c_uint = 0x01;
pub const kIOFBHardwareCursorInVRAM: c_uint = 0x02;

pub const kIOFBShmemVersionMask: c_uint = 0x000000ff;
pub const kIOFBTenPtOneShmemVersion: c_uint = 2;
pub const kIOFBTenPtTwoShmemVersion: c_uint = 3;
///
/// ## Discussion
///
/// The current version of the slice of shared memory that contains the cursor and window server state data in the StdFBShmem_t structure.
///
///
pub const kIOFBCurrentShmemVersion: c_uint = 2;
pub const kIOFBShmemCursorNumFramesMask: c_uint = 0x00ff0000;
pub const kIOFBShmemCursorNumFramesShift: c_uint = 16;
///
/// ## Discussion
///
/// The memory type for IOConnectMapMemory() to get a slice of shared memory that contains the StdFBShmem_t structure.
///
///
pub const kIOFBCursorMemory: c_uint = 100;

extern "C-unwind" {
    /// IOGraphicsLib
    /// IOGraphicsLib implements non-kernel task access to IOGraphics family object types - IOFramebuffer and IOAccelerator. These functions implement a graphics family specific API.
    /// <br>
    /// A connection to a graphics IOService must be made before these functions are called. A connection is made with the IOServiceOpen() function described in IOKitLib.h. An io_connect_t handle is returned by IOServiceOpen(), which must be passed to the IOGraphicsLib functions. The appropriate connection type from IOGraphicsTypes.h must be specified in the call to IOServiceOpen(). All of the IOFramebuffer functions can only be called from a kIOFBServerConnectType connection. Except as specified below, functions whose names begin with IOFB are IOFramebuffer functions. Functions whose names begin with IOPS are IOAccelerator functions and must be called from connections of type kIOFBEngineControllerConnectType or kIOFBEngineConnectType.
    /// <br>
    /// The functions in IOGraphicsLib use a number of special types. The display mode is the screen's resolution and refresh rate. The known display modes are referred to by an index of type IODisplayModeID. The display depth is the number of significant color bits used in representing each pixel. Depths are also referred to by an index value that is 0 for 8 bits, 1 for 15 bits, and 2 for 24 bits. A combination of display mode and depth may have a number of supported pixel formats. The pixel aperture is an index of supported pixel formats for a display mode and depth. This index is of type IOPixelAperture. All of these graphics specific types are defined in IOGraphicsTypes.h.
    ///
    /// # Safety
    ///
    /// `connect` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IOFramebufferOpen(
        service: io_service_t,
        owning_task: task_port_t,
        r#type: c_uint,
        connect: *mut io_connect_t,
    ) -> libc::kern_return_t;
}

///
/// ## Discussion
///
/// Include only the keys necessary to match two displays with IODisplayMatchDictionaries().
///
///
pub const kIODisplayMatchingInfo: c_uint = 0x00000100;
///
/// ## Discussion
///
/// The kDisplayProductName property includes only the localized names returned by CFBundleCopyPreferredLocalizationsFromArray().
///
///
pub const kIODisplayOnlyPreferredName: c_uint = 0x00000200;
///
/// ## Discussion
///
/// The kDisplayProductName property is not included in the returned dictionary.
///
///
pub const kIODisplayNoProductName: c_uint = 0x00000400;

/// Create a CFDictionary with information about display hardware.
///
/// Parameters:
/// - framebuffer: The IOService handle for an IOFramebuffer service.
///
/// - options: Use IODisplayDictionaryOptions to specify which keys to include.
///
///
/// <a id="return_value"></a>
/// ## Return Value
///
/// The returned CFDictionary that should be released by the caller with CFRelease().
///
///
///
/// ## Discussion
///
/// The CFDictionary created by this function contains information about the display hardware associated with a framebuffer. The keys for the dictionary are listed in IOGraphicsTypes.h.
///
///
/// Create a CFDictionary with information about display hardware.
///
/// The CFDictionary created by this function contains information about the display hardware associated with a framebuffer. The keys for the dictionary are listed in IOGraphicsTypes.h.
///
/// Parameter `framebuffer`: The IOService handle for an IOFramebuffer service.
///
/// Parameter `options`: Use IODisplayDictionaryOptions to specify which keys to include.
///
/// Returns: The returned CFDictionary that should be released by the caller with CFRelease().
#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IODisplayCreateInfoDictionary(
    framebuffer: io_service_t,
    options: IOOptionBits,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn IODisplayCreateInfoDictionary(
            framebuffer: io_service_t,
            options: IOOptionBits,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { IODisplayCreateInfoDictionary(framebuffer, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    /// Match two display information dictionaries to see if they are for the same display.
    ///
    /// Parameters:
    /// - matching1: A CFDictionary returned from IODisplayCreateInfoDictionary().
    ///
    /// - matching2: Another CFDictionary returned from IODisplayCreateInfoDictionary().
    ///
    /// - options: No options are currently defined.
    ///
    ///
    /// <a id="return_value"></a>
    /// ## Return Value
    ///
    /// Returns FALSE if the two displays are not equivalent or TRUE if they are.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// By comparing two CFDictionaries returned from IODisplayCreateInfoDictionary(), this function determines if the displays are the same. The information compared is what is returned by calling IODisplayCreateInfoDictionary() with an option of kIODisplayMatchingInfo. This includes information such as the vendor, product, and serial number.
    ///
    ///
    /// Match two display information dictionaries to see if they are for the same display.
    ///
    /// By comparing two CFDictionaries returned from IODisplayCreateInfoDictionary(), this function determines if the displays are the same. The information compared is what is returned by calling IODisplayCreateInfoDictionary() with an option of kIODisplayMatchingInfo. This includes information such as the vendor, product, and serial number.
    ///
    /// Parameter `matching1`: A CFDictionary returned from IODisplayCreateInfoDictionary().
    ///
    /// Parameter `matching2`: Another CFDictionary returned from IODisplayCreateInfoDictionary().
    ///
    /// Parameter `options`: No options are currently defined.
    ///
    /// Returns: Returns FALSE if the two displays are not equivalent or TRUE if they are.
    ///
    /// # Safety
    ///
    /// - `matching1` generic must be of the correct type.
    /// - `matching1` generic must be of the correct type.
    /// - `matching1` might not allow `None`.
    /// - `matching2` generic must be of the correct type.
    /// - `matching2` generic must be of the correct type.
    /// - `matching2` might not allow `None`.
    pub fn IODisplayMatchDictionaries(
        matching1: Option<&CFDictionary>,
        matching2: Option<&CFDictionary>,
        options: IOOptionBits,
    ) -> i32;
}

#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IODisplayForFramebuffer(
    framebuffer: io_service_t,
    options: IOOptionBits,
) -> io_service_t {
    extern "C-unwind" {
        fn IODisplayForFramebuffer(
            framebuffer: io_service_t,
            options: IOOptionBits,
        ) -> io_service_t;
    }
    unsafe { IODisplayForFramebuffer(framebuffer, options) }
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `params` generic must be of the correct type.
    /// - `params` generic must be of the correct type.
    /// - `params` might not allow `None`.
    #[cfg(feature = "libc")]
    pub fn IODisplaySetParameters(
        service: io_service_t,
        options: IOOptionBits,
        params: Option<&CFDictionary>,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `parameter_name` might not allow `None`.
    #[cfg(feature = "libc")]
    pub fn IODisplaySetFloatParameter(
        service: io_service_t,
        options: IOOptionBits,
        parameter_name: Option<&CFString>,
        value: c_float,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `parameter_name` might not allow `None`.
    #[cfg(feature = "libc")]
    pub fn IODisplaySetIntegerParameter(
        service: io_service_t,
        options: IOOptionBits,
        parameter_name: Option<&CFString>,
        value: i32,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `params` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IODisplayCopyParameters(
        service: io_service_t,
        options: IOOptionBits,
        params: *mut *const CFDictionary,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// `params` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IODisplayCopyFloatParameters(
        service: io_service_t,
        options: IOOptionBits,
        params: *mut *const CFDictionary,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `parameter_name` might not allow `None`.
    /// - `value` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IODisplayGetFloatParameter(
        service: io_service_t,
        options: IOOptionBits,
        parameter_name: Option<&CFString>,
        value: *mut c_float,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// # Safety
    ///
    /// - `parameter_name` might not allow `None`.
    /// - `value` must be a valid pointer.
    /// - `min` must be a valid pointer.
    /// - `max` must be a valid pointer.
    #[cfg(feature = "libc")]
    pub fn IODisplayGetIntegerRangeParameter(
        service: io_service_t,
        options: IOOptionBits,
        parameter_name: Option<&CFString>,
        value: *mut i32,
        min: *mut i32,
        max: *mut i32,
    ) -> IOReturn;
}

#[cfg(feature = "libc")]
#[inline]
pub extern "C-unwind" fn IODisplayCommitParameters(
    service: io_service_t,
    options: IOOptionBits,
) -> IOReturn {
    extern "C-unwind" {
        fn IODisplayCommitParameters(service: io_service_t, options: IOOptionBits) -> IOReturn;
    }
    unsafe { IODisplayCommitParameters(service, options) }
}
