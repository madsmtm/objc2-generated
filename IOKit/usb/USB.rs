//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

///
/// ## Discussion
///
/// If the USB Device has this property, drivers for any of its interfaces will have their handleOpen method called while holding the workloop gate.
///
///
pub const kCallInterfaceOpenWithGate: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"kCallInterfaceOpenWithGate\0") };
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBUnknownPipeErr: c_uint = iokit_usb_err!(0x61);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBTooManyPipesErr: c_uint = iokit_usb_err!(0x60);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBNoAsyncPortErr: c_uint = iokit_usb_err!(0x5f);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBNotEnoughPipesErr: c_uint = iokit_usb_err!(0x5e);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBNotEnoughPowerErr: c_uint = iokit_usb_err!(0x5d);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBEndpointNotFound: c_uint = iokit_usb_err!(0x57);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBConfigNotFound: c_uint = iokit_usb_err!(0x56);
pub const kIOUSBPortWasSuspended: c_uint = iokit_usb_err!(0x52);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBPipeStalled: c_uint = iokit_usb_err!(0x4f);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBInterfaceNotFound: c_uint = iokit_usb_err!(0x4e);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBLowLatencyBufferNotPreviouslyAllocated: c_uint = iokit_usb_err!(0x4d);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBLowLatencyFrameListNotPreviouslyAllocated: c_uint = iokit_usb_err!(0x4c);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBHighSpeedSplitError: c_uint = iokit_usb_err!(0x4b);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBSyncRequestOnWLThread: c_uint = iokit_usb_err!(0x4a);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBDeviceNotHighSpeed: c_uint = iokit_usb_err!(0x49);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBDeviceTransferredToCompanion: c_uint = iokit_usb_err!(0x49);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBClearPipeStallNotRecursive: c_uint = iokit_usb_err!(0x48);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBDevicePortWasNotSuspended: c_uint = iokit_usb_err!(0x47);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBEndpointCountExceeded: c_uint = iokit_usb_err!(0x46);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBDeviceCountExceeded: c_uint = iokit_usb_err!(0x45);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBStreamsNotSupported: c_uint = iokit_usb_err!(0x44);
pub const kIOUSBInvalidSSEndpoint: c_uint = iokit_usb_err!(0x43);
pub const kIOUSBTooManyTransactionsPending: c_uint = iokit_usb_err!(0x42);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBTransactionReturned: c_uint = iokit_usb_err!(0x50);
///
/// ## Discussion
///
/// Errors specific to the IOUSBFamily. Note that the iokit_usb_err(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBTransactionTimeout: c_uint = iokit_usb_err!(0x51);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBLinkErr: c_uint = iokit_usb_err!(0x10);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBNotSent2Err: c_uint = iokit_usb_err!(0x0f);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBNotSent1Err: c_uint = iokit_usb_err!(0x0e);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBBufferUnderrunErr: c_uint = iokit_usb_err!(0x0d);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBBufferOverrunErr: c_uint = iokit_usb_err!(0x0c);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBReserved2Err: c_uint = iokit_usb_err!(0x0b);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBReserved1Err: c_uint = iokit_usb_err!(0x0a);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBWrongPIDErr: c_uint = iokit_usb_err!(0x07);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBPIDCheckErr: c_uint = iokit_usb_err!(0x06);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBDataToggleErr: c_uint = iokit_usb_err!(0x03);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBBitstufErr: c_uint = iokit_usb_err!(0x02);
///
/// ## Discussion
///
/// These errors are returned by the OHCI controller. The # in parenthesis (xx) corresponds to the OHCI Completion Code. For the following Completion codes, we return a generic IOKit error instead of a USB specific error.
///
/// ```occ
///  
/// Completion Code         Error Returned              Description
/// 9                       kIOReturnUnderrun           (Data Underrun) EP returned less data than max packet size
/// 8                       kIOReturnOverrun            (Data Overrun) Packet too large or more data than buffer
/// 5                       kIOReturnNotResponding      Device Not responding
/// 4                       kIOUSBPipeStalled           Endpoint returned a STALL PID
/// ```
///
///
///
///
pub const kIOUSBCRCErr: c_uint = iokit_usb_err!(0x01);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageHubResetPort: c_uint = iokit_usb_msg!(0x01);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageHubSuspendPort: c_uint = iokit_usb_msg!(0x02);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageHubResumePort: c_uint = iokit_usb_msg!(0x03);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageHubIsDeviceConnected: c_uint = iokit_usb_msg!(0x04);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageHubIsPortEnabled: c_uint = iokit_usb_msg!(0x05);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageHubReEnumeratePort: c_uint = iokit_usb_msg!(0x06);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessagePortHasBeenReset: c_uint = iokit_usb_msg!(0x0a);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessagePortHasBeenResumed: c_uint = iokit_usb_msg!(0x0b);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageHubPortClearTT: c_uint = iokit_usb_msg!(0x0c);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessagePortHasBeenSuspended: c_uint = iokit_usb_msg!(0x0d);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageFromThirdParty: c_uint = iokit_usb_msg!(0x0e);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessagePortWasNotSuspended: c_uint = iokit_usb_msg!(0x0f);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageExpressCardCantWake: c_uint = iokit_usb_msg!(0x10);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageCompositeDriverReconfigured: c_uint = iokit_usb_msg!(0x11);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageHubSetPortRecoveryTime: c_uint = iokit_usb_msg!(0x12);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageOvercurrentCondition: c_uint = iokit_usb_msg!(0x13);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageNotEnoughPower: c_uint = iokit_usb_msg!(0x14);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageController: c_uint = iokit_usb_msg!(0x15);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageRootHubWakeEvent: c_uint = iokit_usb_msg!(0x16);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageReleaseExtraCurrent: c_uint = iokit_usb_msg!(0x17);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageReallocateExtraCurrent: c_uint = iokit_usb_msg!(0x18);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageEndpointCountExceeded: c_uint = iokit_usb_msg!(0x19);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageDeviceCountExceeded: c_uint = iokit_usb_msg!(0x1a);
///
/// ## Discussion
///
/// Messages specific to the IOUSBFamily. Note that the iokit_usb_msg(x) translates to 0xe0004xxx, where xxx is the value in parenthesis as a hex number.
///
///
pub const kIOUSBMessageHubPortDeviceDisconnected: c_uint = iokit_usb_msg!(0x1b);
pub const kIOUSBMessageUnsupportedConfiguration: c_uint = iokit_usb_msg!(0x1c);
pub const kIOUSBMessageHubCountExceeded: c_uint = iokit_usb_msg!(0x1d);
pub const kIOUSBMessageTDMLowBattery: c_uint = iokit_usb_msg!(0x1e);
pub const kIOUSBMessageLegacySuspendDevice: c_uint = iokit_usb_msg!(0x1f);
pub const kIOUSBMessageLegacyResetDevice: c_uint = iokit_usb_msg!(0x20);
pub const kIOUSBMessageLegacyReEnumerateDevice: c_uint = iokit_usb_msg!(0x21);
pub const kIOUSBMessageConfigurationSet: c_uint = iokit_usb_msg!(0x22);
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kUSBDevicePropertyBusPowerAvailable: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Bus Power Available\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBDevicePropertyLocationID: &CStr = kUSBHostPropertyLocationID;
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBProductIDMask: &CStr = kUSBHostMatchingPropertyProductIDMask;
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBProductIdsArrayName: &CStr = kUSBHostMatchingPropertyProductIDArray;
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kUSBSuspendPort: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"kSuspendPort\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kUSBExpressCardCantWake: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ExpressCardCantWake\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBDeviceResumeRecoveryTime: &CStr = kUSBHostDevicePropertyResumeRecoveryTime;
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kUSBOutOfSpecMPSOK: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Out of spec MPS OK\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kOverrideIfAtLocationID: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"OverrideIfAtLocationID\0") };
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBDeviceCurrentConfiguration: &CStr = kUSBHostDevicePropertyCurrentConfiguration;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBDeviceRemoteWakeOverride: &CStr = kUSBHostDevicePropertyRemoteWakeOverride;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBDeviceConfigurationCurrentOverride: &CStr =
    kUSBHostDevicePropertyConfigurationCurrentOverride;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBDeviceResetDurationOverride: &CStr = kUSBHostDevicePropertyResetDurationOverride;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBDeviceFailedRequestedPower: &CStr = kUSBHostDevicePropertyFailedRequestedPower;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBPropertyRemovable: &CStr = kUSBHostPortPropertyRemovable;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBPropertyTestMode: &CStr = kUSBHostPortPropertyTestMode;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBPropertyDebugLevel: &CStr = kUSBHostPropertyDebugOptions;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBHubPropertyPowerSupply: &CStr = kUSBHostHubPropertyPowerSupply;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBControllerSleepSupported: &CStr = kUSBHostControllerPropertySleepSupported;
#[cfg(feature = "IOUSBHostFamilyDefinitions")]
pub const kUSBPortPropertyBusCurrentAllocation: &CStr = kUSBHostPortPropertyBusCurrentAllocation;
pub const kUSBPreferredInterface: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Preferred Interface\0") };
pub const kUSBPreferredInterfacePriority: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"priority\0") };
pub const kOverrideAllowLowPower: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"kOverrideAllowLowPower\0") };
pub const kUSBUserClientEntitlementRequired: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"UsbUserClientEntitlementRequired\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kUSBDevicePropertySpeed: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Device Speed\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kUSBDevicePropertyAddress: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"USB Address\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kUSBPreferredConfiguration: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Preferred Configuration\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kUSBControllerNeedsContiguousMemoryForIsoch: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"Need contiguous memory for isoch\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kUSBHubDontAllowLowPower: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"kUSBHubDontAllowLowPower\0") };
///
/// ## Discussion
///
/// Useful property names in USB land.
///
///
pub const kConfigurationDescriptorOverride: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"ConfigurationDescriptorOverride\0") };
pub const kAppleRevocableExtraCurrent: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,revocable-extra-current\0") };
pub const kAppleExternalSuperSpeedPorts: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,ExternalSSPorts\0") };
pub const kAppleUnconnectedSuperSpeedPorts: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,UnconnectedSSPorts\0") };
pub const kAppleAcpiRootHubDepth: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,root-hub-depth\0") };
pub const kAppleStandardPortCurrentInSleep: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,standard-port-current-in-sleep\0") };
pub const kAppleInternalUSBDevice: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,device-internal\0") };
pub const kUSBBusID: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,bus-id\0") };
pub const kApplePowerSupply: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,power-supply\0") };
pub const kAppleCurrentAvailable: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,current-available\0") };
pub const kAppleCurrentInSleep: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,current-in-sleep\0") };
pub const kApplePortCurrentInSleep: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"AAPL,port-current-in-sleep\0") };
pub const kOverrideAttachedToCPU: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"kOverrideAttachedToCPU\0") };
pub const kEHCIIsochMaxBusStall: c_uint = 25000;
pub const kXHCIIsochMaxBusStall: c_uint = 25000;
pub const kOHCIIsochMaxBusStall: c_uint = 25000;
pub const kUHCIIsochMaxBusStall: c_uint = 10000;
pub const kMaxBusStall10uS: c_uint = 10000;
pub const kMaxBusStall25uS: c_uint = 25000;
pub const kUSBDeviceIDShift: c_long = 7;
pub const kUSBMaxDevices: c_long = 128;
pub const kUSBMaxDevice: c_long = kUSBMaxDevices - 1;
pub const kUSBDeviceIDMask: c_long = 0x7f;
pub const kUSBTooManyDevicesAddress: c_long = 0xfffe;
pub const kUSBPipeIDMask: c_long = 0xf;
pub const kUSBMaxPipes: c_long = 32;
pub const kUSBInterfaceIDShift: c_long = 8;
pub const kUSBMaxInterfaces: c_long = 1 << kUSBInterfaceIDShift;
pub const kUSBInterfaceIDMask: c_long = kUSBMaxInterfaces - 1;
pub const kUSBEndPtShift: c_long = 7;
pub const kUSBDeviceMask: c_long = (1 << kUSBEndPtShift) - 1;
pub const kUSBNoPipeIdx: c_long = -1;
pub const kUSBUCRequestWithoutUSBNotificationMask: c_long = 1 << 30;
pub const kUSBEndpointTransferTypeUCMask: c_long = 1 << 7;
pub const kUSBStream0: c_long = 0;
pub const kUSBMaxStream: c_long = 65533;
pub const kUSBPRimeStream: c_long = 0xfffe;
pub const kUSBNoStream: c_long = 0xffff;
pub const kUSBStreamIDMask: c_long = 0xffff;
pub const kUSBStreamIDAllStreamsMask: c_long = 1 << 31;

#[cfg(feature = "AppleUSBDefinitions")]
pub const kUSBRqDirnShift: c_uint = tIOUSBDeviceRequest::IOUSBDeviceRequestDirectionPhase.0;
pub const kUSBRqDirnMask: c_uint = 1;
#[cfg(feature = "AppleUSBDefinitions")]
pub const kUSBRqTypeShift: c_uint = tIOUSBDeviceRequest::IOUSBDeviceRequestTypePhase.0;
pub const kUSBRqTypeMask: c_uint = 3;
#[cfg(feature = "AppleUSBDefinitions")]
pub const kUSBRqRecipientMask: c_uint = tIOUSBDeviceRequest::IOUSBDeviceRequestRecipientMask.0;

pub const kUSBMaxFSIsocEndpointReqCount: c_uint = 1023;
pub const kUSBMaxHSIsocEndpointReqCount: c_uint = 3072;
pub const kUSBMaxHSIsocFrameCount: c_uint = 7168;

#[cfg(feature = "USBSpec")]
pub const kClearDeviceFeature: c_uint =
    EncodeRequest!(kUSBRqClearFeature, kUSBOut, kUSBStandard, kUSBDevice);
#[cfg(feature = "USBSpec")]
pub const kClearInterfaceFeature: c_uint =
    EncodeRequest!(kUSBRqClearFeature, kUSBOut, kUSBStandard, kUSBInterface);
#[cfg(feature = "USBSpec")]
pub const kClearEndpointFeature: c_uint =
    EncodeRequest!(kUSBRqClearFeature, kUSBOut, kUSBStandard, kUSBEndpoint);
#[cfg(feature = "USBSpec")]
pub const kGetConfiguration: c_uint =
    EncodeRequest!(kUSBRqGetConfig, kUSBIn, kUSBStandard, kUSBDevice);
#[cfg(feature = "USBSpec")]
pub const kGetDescriptor: c_uint =
    EncodeRequest!(kUSBRqGetDescriptor, kUSBIn, kUSBStandard, kUSBDevice);
#[cfg(feature = "USBSpec")]
pub const kGetInterface: c_uint =
    EncodeRequest!(kUSBRqGetInterface, kUSBIn, kUSBStandard, kUSBInterface);
#[cfg(feature = "USBSpec")]
pub const kGetDeviceStatus: c_uint =
    EncodeRequest!(kUSBRqGetStatus, kUSBIn, kUSBStandard, kUSBDevice);
#[cfg(feature = "USBSpec")]
pub const kGetInterfaceStatus: c_uint =
    EncodeRequest!(kUSBRqGetStatus, kUSBIn, kUSBStandard, kUSBInterface);
#[cfg(feature = "USBSpec")]
pub const kGetEndpointStatus: c_uint =
    EncodeRequest!(kUSBRqGetStatus, kUSBIn, kUSBStandard, kUSBEndpoint);
#[cfg(feature = "USBSpec")]
pub const kSetAddress: c_uint = EncodeRequest!(kUSBRqSetAddress, kUSBOut, kUSBStandard, kUSBDevice);
#[cfg(feature = "USBSpec")]
pub const kSetConfiguration: c_uint =
    EncodeRequest!(kUSBRqSetConfig, kUSBOut, kUSBStandard, kUSBDevice);
#[cfg(feature = "USBSpec")]
pub const kSetDescriptor: c_uint =
    EncodeRequest!(kUSBRqSetDescriptor, kUSBOut, kUSBStandard, kUSBDevice);
#[cfg(feature = "USBSpec")]
pub const kSetDeviceFeature: c_uint =
    EncodeRequest!(kUSBRqSetFeature, kUSBOut, kUSBStandard, kUSBDevice);
#[cfg(feature = "USBSpec")]
pub const kSetInterfaceFeature: c_uint =
    EncodeRequest!(kUSBRqSetFeature, kUSBOut, kUSBStandard, kUSBInterface);
#[cfg(feature = "USBSpec")]
pub const kSetEndpointFeature: c_uint =
    EncodeRequest!(kUSBRqSetFeature, kUSBOut, kUSBStandard, kUSBEndpoint);
#[cfg(feature = "USBSpec")]
pub const kSetInterface: c_uint =
    EncodeRequest!(kUSBRqSetInterface, kUSBOut, kUSBStandard, kUSBInterface);
#[cfg(feature = "USBSpec")]
pub const kSyncFrame: c_uint = EncodeRequest!(kUSBRqSyncFrame, kUSBIn, kUSBStandard, kUSBEndpoint);

pub type USBDeviceAddress = u16;

pub type USBPhysicalAddress32 = u32;

///
/// ## Overview
///
/// Structure used to encode information about each isoc frame.
///
///
/// Structure used to encode information about each isoc frame.
///
/// Parameter `frStatus`: Returns status associated with the frame.
///
/// Parameter `frReqCount`: Input specifiying how many bytes to read or write.
///
/// Parameter `frActCount`: Actual # of bytes transferred.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBIsocFrame {
    pub frStatus: IOReturn,
    pub frReqCount: u16,
    pub frActCount: u16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBIsocFrame {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBIsocFrame",
        &[<IOReturn>::ENCODING, <u16>::ENCODING, <u16>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBIsocFrame {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Structure used to encode information about each isoc frame that is processed at hardware interrupt time (low latency).
///
///
/// Structure used to encode information about each isoc frame that is processed
/// at hardware interrupt time (low latency).
///
/// Parameter `frStatus`: Returns status associated with the frame.
///
/// Parameter `frReqCount`: Input specifiying how many bytes to read or write.
///
/// Parameter `frActCount`: Actual # of bytes transferred.
///
/// Parameter `frTimeStamp`: Time stamp that indicates time when frame was procesed.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBLowLatencyIsocFrame {
    pub frStatus: IOReturn,
    pub frReqCount: u16,
    pub frActCount: u16,
    pub frTimeStamp: AbsoluteTime,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBLowLatencyIsocFrame {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBLowLatencyIsocFrame",
        &[
            <IOReturn>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <AbsoluteTime>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBLowLatencyIsocFrame {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// Parameters:
/// - target: The target specified in the IOUSBCompletion struct.
///
/// - parameter: The parameter specified in the IOUSBCompletion struct.
///
/// - status: Completion status.
///
/// - bufferSizeRemaining: Bytes left to be transferred.
///
///
/// ## Discussion
///
/// Function called when USB I/O completes.
///
///
/// Function called when USB I/O completes.
///
/// Parameter `target`: The target specified in the IOUSBCompletion struct.
///
/// Parameter `parameter`: The parameter specified in the IOUSBCompletion struct.
///
/// Parameter `status`: Completion status.
///
/// Parameter `bufferSizeRemaining`: Bytes left to be transferred.
pub type IOUSBCompletionAction =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *mut c_void, IOReturn, u32)>;

///
/// Parameters:
/// - target: The target specified in the IOUSBCompletion struct.
///
/// - parameter: The parameter specified in the IOUSBCompletion struct.
///
/// - status: Completion status.
///
/// - bufferSizeRemaining: Bytes left to be transferred.
///
/// - timeStamp: Time at which the transaction was processed.
///
///
/// ## Discussion
///
/// Function called when USB I/O completes.
///
///
/// Function called when USB I/O completes.
///
/// Parameter `target`: The target specified in the IOUSBCompletion struct.
///
/// Parameter `parameter`: The parameter specified in the IOUSBCompletion struct.
///
/// Parameter `status`: Completion status.
///
/// Parameter `bufferSizeRemaining`: Bytes left to be transferred.
///
/// Parameter `timeStamp`: Time at which the transaction was processed.
pub type IOUSBCompletionActionWithTimeStamp =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *mut c_void, IOReturn, u32, AbsoluteTime)>;

///
/// Parameters:
/// - target: The target specified in the IOUSBIsocCompletionn struct.
///
/// - parameter: The parameter specified in the IOUSBIsocCompletion struct.
///
/// - status: Completion status.
///
/// - pFrames: Pointer to the frame list containing the status for each frame transferred.
///
///
/// ## Discussion
///
/// Function called when Isochronous USB I/O completes.
///
///
/// Function called when Isochronous USB I/O completes.
///
/// Parameter `target`: The target specified in the IOUSBIsocCompletionn struct.
///
/// Parameter `parameter`: The parameter specified in the IOUSBIsocCompletion struct.
///
/// Parameter `status`: Completion status.
///
/// Parameter `pFrames`: Pointer to the frame list containing the status for each frame transferred.
pub type IOUSBIsocCompletionAction =
    Option<unsafe extern "C-unwind" fn(*mut c_void, *mut c_void, IOReturn, *mut IOUSBIsocFrame)>;

///
/// Parameters:
/// - target: The target specified in the IOUSBLowLatencyIsocCompletion struct.
///
/// - parameter: The parameter specified in the IOUSBLowLatencyIsocCompletion struct.
///
/// - status: Completion status.
///
/// - pFrames: Pointer to the low latency frame list containing the status for each frame transferred.
///
///
/// ## Discussion
///
/// Function called when Low Latency Isochronous USB I/O completes.
///
///
/// Function called when Low Latency Isochronous USB I/O completes.
///
/// Parameter `target`: The target specified in the IOUSBLowLatencyIsocCompletion struct.
///
/// Parameter `parameter`: The parameter specified in the IOUSBLowLatencyIsocCompletion struct.
///
/// Parameter `status`: Completion status.
///
/// Parameter `pFrames`: Pointer to the low latency frame list containing the status for each frame transferred.
pub type IOUSBLowLatencyIsocCompletionAction = Option<
    unsafe extern "C-unwind" fn(*mut c_void, *mut c_void, IOReturn, *mut IOUSBLowLatencyIsocFrame),
>;

///
/// ## Overview
///
/// Struct specifying action to perform when a USB I/O completes.
///
///
/// Struct specifying action to perform when a USB I/O completes.
///
/// Parameter `target`: The target to pass to the action function.
///
/// Parameter `action`: The function to call.
///
/// Parameter `parameter`: The parameter to pass to the action function.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBCompletion {
    pub target: *mut c_void,
    pub action: IOUSBCompletionAction,
    pub parameter: *mut c_void,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBCompletion {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBCompletion",
        &[
            <*mut c_void>::ENCODING,
            <IOUSBCompletionAction>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBCompletion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Struct specifying action to perform when a USB I/O completes.
///
///
/// Struct specifying action to perform when a USB I/O completes.
///
/// Parameter `target`: The target to pass to the action function.
///
/// Parameter `action`: The function to call.
///
/// Parameter `parameter`: The parameter to pass to the action function.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBCompletionWithTimeStamp {
    pub target: *mut c_void,
    pub action: IOUSBCompletionActionWithTimeStamp,
    pub parameter: *mut c_void,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBCompletionWithTimeStamp {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBCompletionWithTimeStamp",
        &[
            <*mut c_void>::ENCODING,
            <IOUSBCompletionActionWithTimeStamp>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBCompletionWithTimeStamp {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Struct specifying action to perform when an Isochronous USB I/O completes.
///
///
/// Struct specifying action to perform when an Isochronous USB I/O completes.
///
/// Parameter `target`: The target to pass to the action function.
///
/// Parameter `action`: The function to call.
///
/// Parameter `parameter`: The parameter to pass to the action function.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBIsocCompletion {
    pub target: *mut c_void,
    pub action: IOUSBIsocCompletionAction,
    pub parameter: *mut c_void,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBIsocCompletion {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBIsocCompletion",
        &[
            <*mut c_void>::ENCODING,
            <IOUSBIsocCompletionAction>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBIsocCompletion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Struct specifying action to perform when an Low Latency Isochronous USB I/O completes.
///
///
/// Struct specifying action to perform when an Low Latency Isochronous USB I/O completes.
///
/// Parameter `target`: The target to pass to the action function.
///
/// Parameter `action`: The function to call.
///
/// Parameter `parameter`: The parameter to pass to the action function.
#[repr(C)]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBLowLatencyIsocCompletion {
    pub target: *mut c_void,
    pub action: IOUSBLowLatencyIsocCompletionAction,
    pub parameter: *mut c_void,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBLowLatencyIsocCompletion {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBLowLatencyIsocCompletion",
        &[
            <*mut c_void>::ENCODING,
            <IOUSBLowLatencyIsocCompletionAction>::ENCODING,
            <*mut c_void>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBLowLatencyIsocCompletion {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBMouseData {
    pub buttons: u16,
    pub XDelta: i16,
    pub YDelta: i16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBMouseData {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBMouseData",
        &[<u16>::ENCODING, <i16>::ENCODING, <i16>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBMouseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOUSBMouseDataPtr = *mut IOUSBMouseData;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBKeyboardData {
    pub keycount: u16,
    pub usbkeycode: [u16; 32],
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBKeyboardData {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBKeyboardData",
        &[<u16>::ENCODING, <[u16; 32]>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBKeyboardData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOUSBKeyboardDataPtr = *mut IOUSBKeyboardData;

#[repr(C)]
#[derive(Clone, Copy)]
pub union IOUSBHIDData {
    pub kbd: IOUSBKeyboardData,
    pub mouse: IOUSBMouseData,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBHIDData {
    const ENCODING: Encoding = Encoding::Union(
        "IOUSBHIDData",
        &[<IOUSBKeyboardData>::ENCODING, <IOUSBMouseData>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBHIDData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOUSBHIDDataPtr = *mut IOUSBHIDData;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceDescriptorPtr = *mut IOUSBDeviceDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDescriptorHeaderPtr = *mut IOUSBDescriptorHeader;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBBOSDescriptorPtr = *mut IOUSBBOSDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceCapabilityDescriptorHeaderPtr = *mut IOUSBDeviceCapabilityDescriptorHeader;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceCapabilityUSB2ExtensionPtr = *mut IOUSBDeviceCapabilityUSB2Extension;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceCapabilitySuperSpeedUSBPtr = *mut IOUSBDeviceCapabilitySuperSpeedUSB;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceCapabilitySuperSpeedPlusUSBPtr = *mut IOUSBDeviceCapabilitySuperSpeedPlusUSB;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceCapabilityContainerIDPtr = *mut IOUSBDeviceCapabilityContainerID;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBPlatformCapabilityDescriptorPtr = *mut IOUSBPlatformCapabilityDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceCapabilityBillboardAltConfigPtr = *mut IOUSBDeviceCapabilityBillboardAltConfig;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceCapabilityBillboardPtr = *mut IOUSBDeviceCapabilityBillboard;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceCapabilityBillboardAltModePtr = *mut IOUSBDeviceCapabilityBillboardAltMode;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBConfigurationDescriptorPtr = *mut IOUSBConfigurationDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBConfigurationDescHeaderPtr = *mut IOUSBConfigurationDescHeader;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBInterfaceDescriptorPtr = *mut IOUSBInterfaceDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBEndpointDescriptorPtr = *mut IOUSBEndpointDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBStringDescriptorPtr = *mut IOUSBStringDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBSuperSpeedEndpointCompanionDescriptorPtr =
    *mut IOUSBSuperSpeedEndpointCompanionDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptorPtr =
    *mut IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type UASPipeDescriptorPtr = *mut UASPipeDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBHIDDescriptorPtr = *mut IOUSBHIDDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBHIDReportDescPtr = *mut IOUSBHIDReportDesc;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDeviceQualifierDescriptorPtr = *mut IOUSBDeviceQualifierDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBDFUDescriptorPtr = *mut IOUSBDFUDescriptor;

#[cfg(feature = "AppleUSBDefinitions")]
pub type IOUSBInterfaceAssociationDescriptorPtr = *mut IOUSBInterfaceAssociationDescriptor;

pub const kIOUSBDeviceCapabilityDescriptorType: c_uint = 16;
pub const kIOUSBDeviceCapabilityDescriptorLengthMin: c_uint = 3;

pub const kUSB_EPDesc_bmAttributes_TranType_Mask: c_uint = USBBitRange!(0, 1);
pub const kUSB_EPDesc_bmAttributes_TranType_Shift: c_uint = USBBitRangePhase!(0, 1);
pub const kUSB_EPDesc_bmAttributes_SyncType_Mask: c_uint = USBBitRange!(2, 3);
pub const kUSB_EPDesc_bmAttributes_SyncType_Shift: c_uint = USBBitRangePhase!(2, 3);
pub const kUSB_EPDesc_bmAttributes_UsageType_Mask: c_uint = USBBitRange!(4, 5);
pub const kUSB_EPDesc_bmAttributes_UsageType_Shift: c_uint = USBBitRangePhase!(4, 5);
pub const kUSB_EPDesc_wMaxPacketSize_MPS_Mask: c_uint = USBBitRange!(0, 10);
pub const kUSB_EPDesc_wMaxPacketSize_MPS_Shift: c_uint = USBBitRangePhase!(0, 10);
pub const kUSB_EPDesc_MaxMPS: c_uint = 1024;
pub const kUSB_HSFSEPDesc_wMaxPacketSize_Mult_Mask: c_uint = USBBitRange!(11, 12);
pub const kUSB_HSFSEPDesc_wMaxPacketSize_Mult_Shift: c_uint = USBBitRangePhase!(11, 12);

pub const kUSB_SSCompDesc_Bulk_MaxStreams_Mask: c_uint = USBBitRange!(0, 4);
pub const kUSB_SSCompDesc_Bulk_MaxStreams_Shift: c_uint = USBBitRangePhase!(0, 4);
pub const kUSB_SSCompDesc_Isoc_Mult_Mask: c_uint = USBBitRange!(0, 1);
pub const kUSB_SSCompDesc_Isoc_Mult_Shift: c_uint = USBBitRangePhase!(0, 1);

pub const addPacketShift: c_uint = 11;

///
/// ## Overview
///
/// Structure used with the IOUSBLib GetEndpointPropertiesV3 and GetPipePropertiesV3 API. Most of the fields are taken directly from corresponding Standard Endpoint Descriptor and SuperSpeed Endpoint Companion Descriptor. wBytesPerInterval will be synthesized for High Speed High Bandwidth Isochronous endpoints.
///
///
/// Structure used with the IOUSBLib GetEndpointPropertiesV3 and GetPipePropertiesV3 API. Most of the fields are taken directly from corresponding Standard Endpoint Descriptor and SuperSpeed Endpoint Companion Descriptor. wBytesPerInterval will be synthesized for  High Speed High Bandwidth Isochronous endpoints.
/// Field: bVersion  Version of the structure.  Currently kUSBEndpointPropertiesVersion3.  Need to set this when using this structure
/// Field: bAlternateSetting Used as an input for GetEndpointPropertiesV3.  Used as an output for GetPipePropertiesV3
/// Field: bDirection Used as an input for GetEndpointPropertiesV3.  Used as an output for GetPipePropertiesV3. One of kUSBIn or kUSBOut.
/// Field: bEndpointNumber Used as an input for GetEndpointPropertiesV3.  Used as an output for GetPipePropertiesV3
/// Field: bTransferType  One of kUSBControl, kUSBBulk, kUSBIsoc, or kUSBInterrupt
/// Field: bUsageType  For interrupt and isoc endpoints, the usage type.  For Bulk endpoints of the UAS Mass Storage Protocol, the pipe ID.
/// Field: bSyncType    For isoc endpoints only
/// Field: bInterval    The bInterval field from the Standard Endpoint descriptor.
/// Field: wMaxPacketSize  The meaning of this value depends on whether this is called with GetPipePropertiesV3 or GetEndpointPropertiesV3. See the documentation of those calls for more info.
/// Field: bMaxBurst  For SuperSpeed endpoints, maximum number of packets the endpoint can send or receive as part of a burst
/// Field: bMaxStreams  For SuperSpeed bulk endpoints, maximum number of streams this endpoint supports.
/// Field: bMult  For SuperSpeed isoc endpoints, this is the mult value from the SuperSpeed Endpoint Companion Descriptor. For High Speed isoc and interrupt endpoints, this is bits 11 and 12 of the Standard Endpoint Descriptor, which represents a similar value.
/// Field: wBytesPerInterval  For SuperSpeed interrupt and isoc endpoints, this is the wBytesPerInterval from the SuperSpeed Endpoint Companion Descriptor. For High Speed High Bandwidth isoc endpoints, this will be equal to wMaxPacketSize * (bMult+1).
#[repr(C, packed)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBEndpointProperties {
    pub bVersion: u8,
    pub bAlternateSetting: u8,
    pub bDirection: u8,
    pub bEndpointNumber: u8,
    pub bTransferType: u8,
    pub bUsageType: u8,
    pub bSyncType: u8,
    pub bInterval: u8,
    pub wMaxPacketSize: u16,
    pub bMaxBurst: u8,
    pub bMaxStreams: u8,
    pub bMult: u8,
    pub wBytesPerInterval: u16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBEndpointProperties {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBEndpointProperties",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u16>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u16>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBEndpointProperties {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOUSBEndpointPropertiesPtr = *mut IOUSBEndpointProperties;

///
/// ## Discussion
///
/// Version that has support for USB3 SuperSpeed Endpoint Companion fields.
///
///
pub const kUSBEndpointPropertiesVersion3: c_uint = 0x03;

///
/// ## Discussion
///
/// Type used to get a DeviceStatus as a single quantity.
///
///
/// Type used to get a DeviceStatus as a single quantity.
pub type USBStatus = u16;

pub type USBStatusPtr = *mut USBStatus;

pub const kIOUSBAnyClass: c_uint = 0xFFFF;
pub const kIOUSBAnySubClass: c_uint = 0xFFFF;
pub const kIOUSBAnyProtocol: c_uint = 0xFFFF;
pub const kIOUSBAnyVendor: c_uint = 0xFFFF;
pub const kIOUSBAnyProduct: c_uint = 0xFFFF;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBMatch {
    pub usbClass: u16,
    pub usbSubClass: u16,
    pub usbProtocol: u16,
    pub usbVendor: u16,
    pub usbProduct: u16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBMatch {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBMatch",
        &[
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBMatch {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Struct used to find endpoints of an interface type and direction are used to match endpoints, type, direction, maxPacketSize and interval are updated with the properties of the found endpoint.
///
///
/// Struct used to find endpoints of an interface
/// type and direction are used to match endpoints,
/// type, direction, maxPacketSize and interval are updated
/// with the properties of the found endpoint.
/// Field: type Type of endpoint: kUSBControl, kUSBIsoc, kUSBBulk, kUSBInterrupt, kUSBAnyType.  If kUSBAnyType is specified, this field is treated as a don't care.
/// Field: direction Direction of endpoint: kUSBOut, kUSBIn, kUSBAnyDirn.   If kUSBAnyDirn is specified, this field is treated as a don't care.
/// Field: maxPacketSize maximum packet size of endpoint.
/// Field: interval Polling interval in mSec for endpoint.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBFindEndpointRequest {
    pub r#type: u8,
    pub direction: u8,
    pub maxPacketSize: u16,
    pub interval: u8,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBFindEndpointRequest {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u16>::ENCODING,
            <u8>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBFindEndpointRequest {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Parameter block for control requests, using a simple pointer for the data to be transferred.
///
///
/// Parameter block for control requests, using a simple pointer
/// for the data to be transferred.
/// Field: bmRequestType Request type: kUSBStandard, kUSBClass or kUSBVendor
/// Field: bRequest Request code
/// Field: wValue 16 bit parameter for request, host endianess
/// Field: wIndex 16 bit parameter for request, host endianess
/// Field: wLength Length of data part of request, 16 bits, host endianess
/// Field: pData Pointer to data for request - data returned in bus endianess
/// Field: wLenDone Set by standard completion routine to number of data bytes
/// actually transferred
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBDevRequest {
    pub bmRequestType: u8,
    pub bRequest: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
    pub pData: *mut c_void,
    pub wLenDone: u32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBDevRequest {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <*mut c_void>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBDevRequest {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOUSBDeviceRequestPtr = *mut IOUSBDevRequest;

///
/// ## Overview
///
/// Parameter block for control requests with timeouts, using a simple pointer for the data to be transferred. Same as a IOUSBDevRequest except for the two extra timeout fields.
///
///
/// Parameter block for control requests with timeouts, using a simple pointer
/// for the data to be transferred.  Same as a IOUSBDevRequest except for the two extra timeout fields.
/// Field: bmRequestType Request type: kUSBStandard, kUSBClass or kUSBVendor
/// Field: bRequest Request code
/// Field: wValue 16 bit parameter for request, host endianess
/// Field: wIndex 16 bit parameter for request, host endianess
/// Field: wLength Length of data part of request, 16 bits, host endianess
/// Field: pData Pointer to data for request - data returned in bus endianess
/// Field: wLenDone Set by standard completion routine to number of data bytes
/// actually transferred
/// Field: noDataTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if no data is transferred in this amount of time, the request will be aborted and returned.
/// Field: completionTimeout Specifies a time value in milliseconds. Once the request is queued on the bus, if the entire request is not completed in this amount of time, the request will be aborted and returned
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBDevRequestTO {
    pub bmRequestType: u8,
    pub bRequest: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
    pub pData: *mut c_void,
    pub wLenDone: u32,
    pub noDataTimeout: u32,
    pub completionTimeout: u32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBDevRequestTO {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <*mut c_void>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBDevRequestTO {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kUSBDefaultControlNoDataTimeoutMS: c_uint = 5000;
pub const kUSBDefaultControlCompletionTimeoutMS: c_uint = 0;

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBBulkPipeReq {
    pub pipeRef: u32,
    pub buf: *mut c_void,
    pub size: u32,
    pub noDataTimeout: u32,
    pub completionTimeout: u32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBBulkPipeReq {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <*mut c_void>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBBulkPipeReq {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBDevReqOOL {
    pub bmRequestType: u8,
    pub bRequest: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
    pub pData: *mut c_void,
    pub wLenDone: u32,
    pub pipeRef: u8,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBDevReqOOL {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <*mut c_void>::ENCODING,
            <u32>::ENCODING,
            <u8>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBDevReqOOL {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBDevReqOOLTO {
    pub bmRequestType: u8,
    pub bRequest: u8,
    pub wValue: u16,
    pub wIndex: u16,
    pub wLength: u16,
    pub pData: *mut c_void,
    pub wLenDone: u32,
    pub pipeRef: u8,
    pub noDataTimeout: u32,
    pub completionTimeout: u32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBDevReqOOLTO {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u8>::ENCODING,
            <u8>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <*mut c_void>::ENCODING,
            <u32>::ENCODING,
            <u8>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBDevReqOOLTO {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOUSBIsocStruct {
    pub fPipe: u32,
    pub fBuffer: *mut c_void,
    pub fBufSize: u32,
    pub fStartFrame: u64,
    pub fNumFrames: u32,
    pub fFrameCounts: *mut IOUSBIsocFrame,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBIsocStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <*mut c_void>::ENCODING,
            <u32>::ENCODING,
            <u64>::ENCODING,
            <u32>::ENCODING,
            <*mut IOUSBIsocFrame>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBIsocStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBLowLatencyIsocStruct {
    pub fPipe: u32,
    pub fBufSize: u32,
    pub fStartFrame: u64,
    pub fNumFrames: u32,
    pub fUpdateFrequency: u32,
    pub fDataBufferCookie: u32,
    pub fDataBufferOffset: u32,
    pub fFrameListBufferCookie: u32,
    pub fFrameListBufferOffset: u32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBLowLatencyIsocStruct {
    const ENCODING: Encoding = Encoding::Struct(
        "IOUSBLowLatencyIsocStruct",
        &[
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u64>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
            <u32>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBLowLatencyIsocStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Structure used from user space to return the frame number and a timestamp on when the frame register was read.
///
///
/// Structure used from user space to return the frame number and a timestamp on when the frame register was read.
/// Field: frame frame number
/// Field: timeStamp  AbsoluteTime when the frame was updated
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBGetFrameStruct {
    pub frame: u64,
    pub timeStamp: AbsoluteTime,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBGetFrameStruct {
    const ENCODING: Encoding = Encoding::Struct("?", &[<u64>::ENCODING, <AbsoluteTime>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBGetFrameStruct {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Structure used with FindNextInterface.
///
///
/// Structure used with FindNextInterface.
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct IOUSBFindInterfaceRequest {
    pub bInterfaceClass: u16,
    pub bInterfaceSubClass: u16,
    pub bInterfaceProtocol: u16,
    pub bAlternateSetting: u16,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOUSBFindInterfaceRequest {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
            <u16>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOUSBFindInterfaceRequest {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kIOUSBFindInterfaceDontCare: c_uint = 0xFFFF;

#[cfg(feature = "AppleUSBDefinitions")]
pub const kIOUSBVendorIDAppleComputer: c_uint = kIOUSBAppleVendorID;
#[cfg(feature = "AppleUSBDefinitions")]
pub const kIOUSBVendorIDApple: c_uint = kIOUSBAppleVendorID;

///
/// ## Discussion
///
/// The device is a low speed device.
///
///
pub const kUSBDeviceSpeedLow: c_uint = 0;
///
/// ## Discussion
///
/// The device is a full speed device.
///
///
pub const kUSBDeviceSpeedFull: c_uint = 1;
///
/// ## Discussion
///
/// The device is a high speed device.
///
///
pub const kUSBDeviceSpeedHigh: c_uint = 2;
///
/// ## Discussion
///
/// The device is a SuperSpeed device
///
///
pub const kUSBDeviceSpeedSuper: c_uint = 3;
pub const kUSBDeviceSpeedSuperPlus: c_uint = 4;
pub const kUSBDeviceSpeedSuperPlusBy2: c_uint = 5;

///
/// ## Discussion
///
/// The device is attached to a bus running at full speed (1 ms / frame).
///
///
pub const kUSBFullSpeedMicrosecondsInFrame: c_uint = 1000;
///
/// ## Discussion
///
/// The device is attached to a bus running at high speed (125 microseconds / frame).
///
///
pub const kUSBHighSpeedMicrosecondsInFrame: c_uint = 125;

pub const kUSBLowLatencyIsochTransferKey: c_uint = 0x6c6c6974;

///
/// ## Overview
///
/// Used to specify what kind of buffer to create when calling LowLatencyCreateBuffer().
///
///
/// Used to specify what kind of buffer to create when calling LowLatencyCreateBuffer().
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct USBLowLatencyBufferType(pub c_uint);
impl USBLowLatencyBufferType {
    ///
    /// ## Discussion
    ///
    /// The buffer will be used to write data out to a device.
    ///
    ///
    #[doc(alias = "kUSBLowLatencyWriteBuffer")]
    pub const WriteBuffer: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// The buffer will be used to read data from a device.
    ///
    ///
    #[doc(alias = "kUSBLowLatencyReadBuffer")]
    pub const ReadBuffer: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// The buffer will be used for a low latency isoch frame list.
    ///
    ///
    #[doc(alias = "kUSBLowLatencyFrameListBuffer")]
    pub const FrameListBuffer: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for USBLowLatencyBufferType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for USBLowLatencyBufferType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kUSBNoUserNotificationType: c_uint = 0;
pub const kUSBNotEnoughPowerNotificationType: c_uint = 1;
pub const kUSBIndividualOverCurrentNotificationType: c_uint = 2;
pub const kUSBGangOverCurrentNotificationType: c_uint = 3;
pub const kUSBiOSDeviceNotEnoughPowerNotificationType: c_uint = 4;
pub const kUSBNotEnoughPowerNoACNotificationType: c_uint = 5;
pub const kUSBDeviceCountExceededNotificationType: c_uint = 6;
pub const kUSBEndpointCountExceededNotificationType: c_uint = 7;
pub const kUSBUnsupportedNotificationType: c_uint = 8;
pub const kUSBHubCountExceededNotificationType: c_uint = 9;
pub const kUSBTDMLowBatteryType: c_uint = 10;
pub const kUSBCTBNotEnoughPowerNotificationType: c_uint = 11;
pub const kUSBCTBUnsupportedNotificationType: c_uint = 12;
pub const kUSBCUnsupportedTBPortNotificationType: c_uint = 13;
pub const kUSBCUnsupportedTBCableNotificationType: c_uint = 14;

///
/// ## Overview
///
/// Options used when calling ReEnumerateDevice.
///
///
/// Options used when calling ReEnumerateDevice.
///
///
/// any drivers attached to a Mass Storage Class IOUSBInterface.  A client needs to have the appropriate permissions in order to specify this bit.  See IOUSBLib.h
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct USBReEnumerateOptions(pub c_int);
impl USBReEnumerateOptions {
    ///
    /// ## Discussion
    ///
    /// Setting this bit will cause the Hub driver to wait 100ms before addressing the device after the reset following the re-enumeration.
    ///
    ///
    #[doc(alias = "kUSBAddExtraResetTimeBit")]
    pub const AddExtraResetTimeBit: Self = Self(31);
    #[doc(alias = "kUSBReEnumerateCaptureDeviceBit")]
    pub const ReEnumerateCaptureDeviceBit: Self = Self(30);
    #[doc(alias = "kUSBReEnumerateReleaseDeviceBit")]
    pub const ReEnumerateReleaseDeviceBit: Self = Self(29);
    #[doc(alias = "kUSBAddExtraResetTimeMask")]
    pub const AddExtraResetTimeMask: Self =
        Self(1 << USBReEnumerateOptions::AddExtraResetTimeBit.0);
    #[doc(alias = "kUSBReEnumerateCaptureDeviceMask")]
    pub const ReEnumerateCaptureDeviceMask: Self =
        Self(1 << USBReEnumerateOptions::ReEnumerateCaptureDeviceBit.0);
    #[doc(alias = "kUSBReEnumerateReleaseDeviceMask")]
    pub const ReEnumerateReleaseDeviceMask: Self =
        Self(1 << USBReEnumerateOptions::ReEnumerateReleaseDeviceBit.0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for USBReEnumerateOptions {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for USBReEnumerateOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// GetUSBDeviceInformation will return a unit32_t value with bits set indicating that a particular state is present in the USB device. These bits are described here
///
///
/// GetUSBDeviceInformation will return a unit32_t value with bits set indicating that a particular state is present in the USB device.  These bits are described here
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct USBDeviceInformationBits(pub c_uint);
impl USBDeviceInformationBits {
    ///
    /// ## Discussion
    ///
    /// The USB device is directly attached to its hub and cannot be removed.
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsCaptiveBit")]
    pub const InformationDeviceIsCaptiveBit: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// The USB device is directly attached to the root hub
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsAttachedToRootHubBit")]
    pub const InformationDeviceIsAttachedToRootHubBit: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// The USB device is internal to the enclosure (all the hubs it attaches to are captive)
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsInternalBit")]
    pub const InformationDeviceIsInternalBit: Self = Self(2);
    ///
    /// ## Discussion
    ///
    /// The USB device is connected to its hub
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsConnectedBit")]
    pub const InformationDeviceIsConnectedBit: Self = Self(3);
    ///
    /// ## Discussion
    ///
    /// The hub port to which the USB device is attached is enabled
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsEnabledBit")]
    pub const InformationDeviceIsEnabledBit: Self = Self(4);
    ///
    /// ## Discussion
    ///
    /// The hub port to which the USB device is attached is suspended
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsSuspendedBit")]
    pub const InformationDeviceIsSuspendedBit: Self = Self(5);
    ///
    /// ## Discussion
    ///
    /// The hub port to which the USB device is attached is being reset
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsInResetBit")]
    pub const InformationDeviceIsInResetBit: Self = Self(6);
    ///
    /// ## Discussion
    ///
    /// The USB device generated an overcurrent
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceOvercurrentBit")]
    pub const InformationDeviceOvercurrentBit: Self = Self(7);
    ///
    /// ## Discussion
    ///
    /// The hub port to which the USB device is attached is in test mode
    ///
    ///
    #[doc(alias = "kUSBInformationDevicePortIsInTestModeBit")]
    pub const InformationDevicePortIsInTestModeBit: Self = Self(8);
    ///
    /// ## Discussion
    ///
    /// The device is the root hub simulation
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsRootHub")]
    pub const InformationDeviceIsRootHub: Self = Self(9);
    ///
    /// ## Discussion
    ///
    /// If this is a root hub simulation and it's built into the enclosure, this bit is set. If it's on an expansion card, it will be cleared
    ///
    ///
    #[doc(alias = "kUSBInformationRootHubisBuiltIn")]
    pub const InformationRootHubisBuiltIn: Self = Self(10);
    #[doc(alias = "kUSBInformationRootHubIsBuiltInBit")]
    pub const InformationRootHubIsBuiltInBit: Self = Self(10);
    ///
    /// ## Discussion
    ///
    /// This device is "attached" to the controller through a remote connection
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsRemote")]
    pub const InformationDeviceIsRemote: Self = Self(11);
    ///
    /// ## Discussion
    ///
    /// The hub port to which the USB device is connected has a USB connector on the enclosure
    ///
    ///
    #[doc(alias = "kUSBInformationDeviceIsAttachedToEnclosure")]
    pub const InformationDeviceIsAttachedToEnclosure: Self = Self(12);
    #[doc(alias = "kUSBInformationDeviceIsOnThunderboltBit")]
    pub const InformationDeviceIsOnThunderboltBit: Self = Self(13);
    #[doc(alias = "kUSBInformationDeviceIsCaptiveMask")]
    pub const InformationDeviceIsCaptiveMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsCaptiveBit.0);
    #[doc(alias = "kUSBInformationDeviceIsAttachedToRootHubMask")]
    pub const InformationDeviceIsAttachedToRootHubMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsAttachedToRootHubBit.0);
    #[doc(alias = "kUSBInformationDeviceIsInternalMask")]
    pub const InformationDeviceIsInternalMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsInternalBit.0);
    #[doc(alias = "kUSBInformationDeviceIsConnectedMask")]
    pub const InformationDeviceIsConnectedMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsConnectedBit.0);
    #[doc(alias = "kUSBInformationDeviceIsEnabledMask")]
    pub const InformationDeviceIsEnabledMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsEnabledBit.0);
    #[doc(alias = "kUSBInformationDeviceIsSuspendedMask")]
    pub const InformationDeviceIsSuspendedMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsSuspendedBit.0);
    #[doc(alias = "kUSBInformationDeviceIsInResetMask")]
    pub const InformationDeviceIsInResetMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsInResetBit.0);
    #[doc(alias = "kUSBInformationDeviceOvercurrentMask")]
    pub const InformationDeviceOvercurrentMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceOvercurrentBit.0);
    #[doc(alias = "kUSBInformationDevicePortIsInTestModeMask")]
    pub const InformationDevicePortIsInTestModeMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDevicePortIsInTestModeBit.0);
    #[doc(alias = "kUSBInformationDeviceIsRootHubMask")]
    pub const InformationDeviceIsRootHubMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsRootHub.0);
    #[doc(alias = "kUSBInformationRootHubisBuiltInMask")]
    pub const InformationRootHubisBuiltInMask: Self =
        Self(1 << USBDeviceInformationBits::InformationRootHubisBuiltIn.0);
    #[doc(alias = "kUSBInformationRootHubIsBuiltInMask")]
    pub const InformationRootHubIsBuiltInMask: Self =
        Self(1 << USBDeviceInformationBits::InformationRootHubIsBuiltInBit.0);
    #[doc(alias = "kUSBInformationDeviceIsRemoteMask")]
    pub const InformationDeviceIsRemoteMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsRemote.0);
    #[doc(alias = "kUSBInformationDeviceIsAttachedToEnclosureMask")]
    pub const InformationDeviceIsAttachedToEnclosureMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsAttachedToEnclosure.0);
    #[doc(alias = "kUSBInformationDeviceIsOnThunderboltMask")]
    pub const InformationDeviceIsOnThunderboltMask: Self =
        Self(1 << USBDeviceInformationBits::InformationDeviceIsOnThunderboltBit.0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for USBDeviceInformationBits {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for USBDeviceInformationBits {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Used to specify what kind of power will be reserved using the IOUSBDevice RequestExtraPower and ReturnExtraPower APIs.
///
///
/// Used to specify what kind of power will be reserved using the IOUSBDevice RequestExtraPower and ReturnExtraPower APIs.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct USBPowerRequestTypes(pub c_uint);
impl USBPowerRequestTypes {
    ///
    /// ## Discussion
    ///
    /// The power is to be used during sleep.
    ///
    ///
    #[doc(alias = "kUSBPowerDuringSleep")]
    pub const DuringSleep: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// The power is to be used while the system is awake (i.e not sleeping)
    ///
    ///
    #[doc(alias = "kUSBPowerDuringWake")]
    pub const DuringWake: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// When used with ReturnExtraPower(), it will send a message to all devices to return any extra wake power if possible.
    ///
    ///
    #[doc(alias = "kUSBPowerRequestWakeRelease")]
    pub const RequestWakeRelease: Self = Self(2);
    ///
    /// ## Discussion
    ///
    /// When used with ReturnExtraPower(), it will send a message to all devices to return any sleep power if possible.
    ///
    ///
    #[doc(alias = "kUSBPowerRequestSleepRelease")]
    pub const RequestSleepRelease: Self = Self(3);
    ///
    /// ## Discussion
    ///
    /// When used with ReturnExtraPower(), it will send a message to all devices indicating that they can ask for more wake power, as some device has released it.
    ///
    ///
    #[doc(alias = "kUSBPowerRequestWakeReallocate")]
    pub const RequestWakeReallocate: Self = Self(4);
    ///
    /// ## Discussion
    ///
    /// When used with ReturnExtraPower(), it will send a message to all devices indicating that they can ask for more sleep power, as some device has released it.
    ///
    ///
    #[doc(alias = "kUSBPowerRequestSleepReallocate")]
    pub const RequestSleepReallocate: Self = Self(5);
    ///
    /// ## Discussion
    ///
    /// The power is to be used while the system is awake (i.e not sleeping), but can be taken away (via the kUSBPowerRequestWakeRelease message). The system can then allocate that extra power to another device.
    ///
    ///
    #[doc(alias = "kUSBPowerDuringWakeRevocable")]
    pub const DuringWakeRevocable: Self = Self(6);
    ///
    /// ## Discussion
    ///
    /// This is used by the USB stack to allocate the 400mA extra for USB3, above the 500ma allocated by USB2
    ///
    ///
    #[doc(alias = "kUSBPowerDuringWakeUSB3")]
    pub const DuringWakeUSB3: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for USBPowerRequestTypes {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for USBPowerRequestTypes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kUSBNotificationPreForcedSuspendBit: c_uint = 0;
pub const kUSBNotificationPostForcedSuspendBit: c_uint = 1;
pub const kUSBNotificationPreForcedResumeBit: c_uint = 2;
pub const kUSBNotificationPostForcedResumeBit: c_uint = 3;

///
/// ## Overview
///
/// Used to register for USB notifications. These types may be OR'd together if more than one notification is desired. These notification are expected to be acknowledged before the process (e.g. system sleep or system wake) can be continued. See RegisterForNotification and AcknowledgeNotification in IOUSBDeviceInterface and IOUSBInterfaceInterface.
///
///
/// Used to register for USB notifications. These types may be OR'd together if more than one notification is desired. These notification are expected to be acknowledged before the process (e.g. system sleep or system wake) can be continued. See RegisterForNotification and AcknowledgeNotification in IOUSBDeviceInterface and IOUSBInterfaceInterface.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct USBNotificationTypes(pub c_uint);
impl USBNotificationTypes {
    ///
    /// ## Discussion
    ///
    /// A notification is sent prior to a forced suspend (e.g. system sleep).
    ///
    ///
    #[doc(alias = "kUSBNotificationPreForcedSuspend")]
    pub const PreForcedSuspend: Self = Self(1 << kUSBNotificationPreForcedSuspendBit);
    ///
    /// ## Discussion
    ///
    /// A notification is sent after a forced suspend has been completed (e.g. system sleep).
    ///
    ///
    #[doc(alias = "kUSBNotificationPostForcedSuspend")]
    pub const PostForcedSuspend: Self = Self(1 << kUSBNotificationPostForcedSuspendBit);
    ///
    /// ## Discussion
    ///
    /// A notification is sent before a resume which happens after a forced suspend (e.g. system wake).
    ///
    ///
    #[doc(alias = "kUSBNotificationPreForcedResume")]
    pub const PreForcedResume: Self = Self(1 << kUSBNotificationPreForcedResumeBit);
    ///
    /// ## Discussion
    ///
    /// A notification is sent after a resume which happens after a forced suspend (e.g. system wake).
    ///
    ///
    #[doc(alias = "kUSBNotificationPostForcedResume")]
    pub const PostForcedResume: Self = Self(1 << kUSBNotificationPostForcedResumeBit);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for USBNotificationTypes {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for USBNotificationTypes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct kUSBConnectable(pub c_uint);
impl kUSBConnectable {
    #[doc(alias = "kUSBPortNotConnectable")]
    pub const USBPortNotConnectable: Self = Self(0);
    #[doc(alias = "kUSBPortConnectable")]
    pub const USBPortConnectable: Self = Self(1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for kUSBConnectable {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for kUSBConnectable {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct kUSBHostConnectorType(pub c_uint);
impl kUSBHostConnectorType {
    #[doc(alias = "kUSBTypeAConnector")]
    pub const USBTypeAConnector: Self = Self(0x00);
    #[doc(alias = "kUSBTypeMiniABConnector")]
    pub const USBTypeMiniABConnector: Self = Self(0x01);
    #[doc(alias = "kUSBTypeExpressCard")]
    pub const USBTypeExpressCard: Self = Self(0x02);
    #[doc(alias = "kUSB3TypeStdAConnector")]
    pub const USB3TypeStdAConnector: Self = Self(0x03);
    #[doc(alias = "kUSB3TypeStdBConnector")]
    pub const USB3TypeStdBConnector: Self = Self(0x04);
    #[doc(alias = "kUSB3TypeMicroBConnector")]
    pub const USB3TypeMicroBConnector: Self = Self(0x05);
    #[doc(alias = "kUSB3TypeMicroABConnector")]
    pub const USB3TypeMicroABConnector: Self = Self(0x06);
    #[doc(alias = "kUSB3TypePowerBConnector")]
    pub const USB3TypePowerBConnector: Self = Self(0x07);
    #[doc(alias = "kUSBProprietaryConnector")]
    pub const USBProprietaryConnector: Self = Self(0xFF);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for kUSBHostConnectorType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for kUSBHostConnectorType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub const kUSBSpeed_Mask: c_uint = USBBitRange!(0, 1);
pub const kUSBSpeed_Shift: c_uint = USBBitRangePhase!(0, 1);
pub const kUSBAddress_Mask: c_uint = USBBitRange!(8, 15);
pub const kUSBAddress_Shift: c_uint = USBBitRangePhase!(8, 15);

pub const kXHCISSRootHubAddress: c_long = kUSBMaxDevices;
pub const kXHCIUSB2RootHubAddress: c_long = kUSBMaxDevices + 1;
pub const kSuperSpeedBusBitMask: c_long = 0x01000000;
