//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-av-foundation")]
use objc2_av_foundation::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-media")]
use objc2_core_media::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-uniform-type-identifiers")]
use objc2_uniform_type_identifiers::*;

use crate::*;

/// Describes whether a file supports or contains fragments. For QuickTime movie and ISO files, it indicates the presence of an 'mvex' box, which is necessary in order to signal the possible presence of later 'moof' boxes.
///
/// The file is not capable of being extended by fragments.
///
/// The file is capable of being extended by fragments *and* contains at least one fragment.
///
/// The file is capable of being extended by fragments, but does not contain any fragments.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/mefileinfofragmentsstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MEFileInfoFragmentsStatus(pub NSInteger);
impl MEFileInfoFragmentsStatus {
    #[doc(alias = "MEFileInfoCouldNotContainFragments")]
    pub const CouldNotContainFragments: Self = Self(0);
    #[doc(alias = "MEFileInfoContainsFragments")]
    pub const ContainsFragments: Self = Self(1);
    #[doc(alias = "MEFileInfoCouldContainButDoesNotContainFragments")]
    pub const CouldContainButDoesNotContainFragments: Self = Self(2);
}

unsafe impl Encode for MEFileInfoFragmentsStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MEFileInfoFragmentsStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Informational status flags returned by parseAdditionalFragmentsWithCompletionHandler.
///
/// A combination of these values may be returned in the statusOut field from parseAdditionalFragmentsWithCompletionHandler.
///
/// Set if the size of the file increased.
///
/// Set if one or more fragments were added.
///
/// Set if no more fragments can be added. Further calls to parseAdditionalFragmentsWithCompletionHandler will return an error.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/meformatreaderparseadditionalfragmentsstatus?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct MEFormatReaderParseAdditionalFragmentsStatus(pub NSUInteger);
bitflags::bitflags! {
    impl MEFormatReaderParseAdditionalFragmentsStatus: NSUInteger {
        #[doc(alias = "MEFormatReaderParseAdditionalFragmentsStatusSizeIncreased")]
        const SizeIncreased = 1<<0;
        #[doc(alias = "MEFormatReaderParseAdditionalFragmentsStatusFragmentAdded")]
        const FragmentAdded = 1<<1;
        #[doc(alias = "MEFormatReaderParseAdditionalFragmentsStatusFragmentsComplete")]
        const FragmentsComplete = 1<<2;
    }
}

unsafe impl Encode for MEFormatReaderParseAdditionalFragmentsStatus {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for MEFormatReaderParseAdditionalFragmentsStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A class that encapsulates options to be passed to MEFormatReaderExtension
    ///
    /// The class MEFormatReaderInstantiationOptions is mutable, with options set through instance properties.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/meformatreaderinstantiationoptions?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MEFormatReaderInstantiationOptions;
);

unsafe impl Send for MEFormatReaderInstantiationOptions {}

unsafe impl Sync for MEFormatReaderInstantiationOptions {}

extern_conformance!(
    unsafe impl NSCopying for MEFormatReaderInstantiationOptions {}
);

unsafe impl CopyingHelper for MEFormatReaderInstantiationOptions {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MEFormatReaderInstantiationOptions {}
);

impl MEFormatReaderInstantiationOptions {
    extern_methods!(
        /// Enables support for parsing additional fragments
        ///
        /// If YES, requests that the MEFormatReader be configured to support calls to parseAdditionalFragments. By default the MEFormatReader does not support calls to parseAdditionalFragments.
        #[unsafe(method(allowIncrementalFragmentParsing))]
        #[unsafe(method_family = none)]
        pub unsafe fn allowIncrementalFragmentParsing(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl MEFormatReaderInstantiationOptions {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Provides a factory method for creating MEFormatReader objects.
    ///
    /// The MEFormatReaderExtension protocol provides a factory method to create a new MEFormatReader when provided with an MEByteSource object. MEFormatReaderExtension is always instantiated by the Media Toolbox, and the MEByteSource object is also created by Media Toolbox based on the specified media asset. All async methods in MEFormatReader/METrackReader/MESampleCursor are allowed to call the completion handlers on any thread or queue.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/meformatreaderextension?language=objc)
    pub unsafe trait MEFormatReaderExtension: NSObjectProtocol {
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// The factory method to create a new MEFormatReader.
        ///
        /// Creates a new MEFormatReader given an MEByteSource, with optional MEFileReaderInstantiationOptions.
        ///
        /// Parameter `primaryByteSource`: The primary MEByteSource instance for the format reader. The MEFormatReader should retain this object for use when responding to later requests for information, and release it in the object finalize method.
        ///
        /// Parameter `options`: An optional instance of MEFormatReaderInstantiationOptions
        ///
        /// Parameter `error`: On return, if initialization of the MEFormatReader fails, points to an NSError describing the nature of the failure.
        ///
        /// Returns: A newly created instance of MEFormatReader.
        #[unsafe(method(formatReaderWithByteSource:options:error:_))]
        #[unsafe(method_family = none)]
        unsafe fn formatReaderWithByteSource_options_error(
            &self,
            primary_byte_source: &MEByteSource,
            options: Option<&MEFormatReaderInstantiationOptions>,
        ) -> Result<Retained<ProtocolObject<dyn MEFormatReader>>, Retained<NSError>>;
    }
);

extern_protocol!(
    /// The primary object for a MediaExtension format reader, representing a single media asset.
    ///
    /// The MEFormatReader protocol provides an interface for the MediaToolbox to interact with MediaExtension format readers, which provide information about media assets. MEFormatReader objects are always instantiated by the MediaToolbox. To create an MEFormatReader object, MediaToolbox first creates a primary MEByteSource object around a source media asset. It then creates an MEFormatReaderExtension object and calls its formatReaderWithByteSource method. MEFormatReaders should expect to run in a sandboxed process with restricted access to the filesystem, network and other kernel resources.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/meformatreader?language=objc)
    pub unsafe trait MEFormatReader: NSObjectProtocol {
        #[cfg(feature = "block2")]
        /// Asynchronously loads the MEFileInfo object with properties of the media asset.
        ///
        /// This method should provide either a valid MEFileInfo object or nil in case of failure.  If the method fails, the NSError will contain error information.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'fileInfo'
        /// The returned MEFileInfo object.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(loadFileInfoWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadFileInfoWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut MEFileInfo, *mut NSError)>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-av-foundation"))]
        /// Asynchronously loads the array of AVMetadataItems representing metadata from the media asset.
        ///
        /// This method should provide either a valid NSArray or nil. If the method fails, the NSError will contain error information.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'metadata'
        /// The returned NSArray of AVMetadataItem objects.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(loadMetadataWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadMetadataWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVMetadataItem>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Asynchronously loads the array of METrackReader objects representing the tracks in the media asset.
        ///
        /// This method should provide either a valid NSArray object or nil. If the method fails, the NSError will contain error information.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'trackReaders'
        /// The returned NSArray of METrackReader objects.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(loadTrackReadersWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadTrackReadersWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<ProtocolObject<dyn METrackReader>>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Asynchronously incorporates additional fragments that have been appended since the file was last parsed.
        ///
        /// Parses additional fragments of the media asset if they exist. Media asset formats that do not support incremental fragments do not need implement this method. The MEFormatReader must have been instantiated with the MEFormatReaderInstantiationOptions property allowIncrementalFragmentParsing set to YES. Does nothing unless the MEFileInfo property fragmentsStatus is MEFileInfoContainsFragments. Once this function returns an error, later calls should also always fail.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'fragmentStatus'
        /// The returned MEFormatReaderParseAdditionalFragmentsStatus flags with status information.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil. Returns an error of MEFormatReaderErrorUnsupportedFeature if the MEFormatReaderInstantiationOptions property allowIncrementalFragmentParsing was not set to YES at creation time. Returns an error of MEFormatReaderErrorParsingFailure if there was a parsing failure.
        #[optional]
        #[unsafe(method(parseAdditionalFragmentsWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn parseAdditionalFragmentsWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(MEFormatReaderParseAdditionalFragmentsStatus, *mut NSError),
            >,
        );
    }
);

extern_class!(
    /// A class incorporating file properties parsed from the media asset.
    ///
    /// The MEFileInfo properties are parsed asynchronously through the loadFileInfoWithCompletionHandler method of MEFormatReader.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/mefileinfo?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MEFileInfo;
);

unsafe impl Send for MEFileInfo {}

unsafe impl Sync for MEFileInfo {}

extern_conformance!(
    unsafe impl NSCopying for MEFileInfo {}
);

unsafe impl CopyingHelper for MEFileInfo {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MEFileInfo {}
);

impl MEFileInfo {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// The duration of the media asset if known, otherwise kCMTimeInvalid.
        #[unsafe(method(duration))]
        #[unsafe(method_family = none)]
        pub unsafe fn duration(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`duration`][Self::duration].
        #[unsafe(method(setDuration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDuration(&self, duration: CMTime);

        /// Indicates if the media asset is capable of being extended by fragments or contains fragments
        ///
        /// See the MEFileInfoFragmentsStatus values for details of the return value. The value will default to MEFileInfoCouldNotContainFragments.
        #[unsafe(method(fragmentsStatus))]
        #[unsafe(method_family = none)]
        pub unsafe fn fragmentsStatus(&self) -> MEFileInfoFragmentsStatus;

        /// Setter for [`fragmentsStatus`][Self::fragmentsStatus].
        #[unsafe(method(setFragmentsStatus:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFragmentsStatus(&self, fragments_status: MEFileInfoFragmentsStatus);

        /// The sidecar filename used by the MediaExtension.
        ///
        /// Represents a new or existing sidecar file located in the same directory as the primary media file. The filename should include the file extension, and should not contain the file path, or contain any slashes. The file extension should be supported by the format reader, and present in the EXAppExtensionAttributes and UTExportedTypeDeclarations dictionaries in the MediaExtension format reader Info.plist.
        #[unsafe(method(sidecarFileName))]
        #[unsafe(method_family = none)]
        pub unsafe fn sidecarFileName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`sidecarFileName`][Self::sidecarFileName].
        #[unsafe(method(setSidecarFileName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSidecarFileName(&self, sidecar_file_name: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl MEFileInfo {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// Provides information about a track within a media asset.
    ///
    /// The MEFormatReader creates METrackReader objects for each track in the media asset. MEFormatReader plugin authors should provide code to implement the METrackReader protocol methods. Since not every method or property applies to every track type, those that don't make sense should return default values.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/metrackreader?language=objc)
    pub unsafe trait METrackReader: NSObjectProtocol {
        #[cfg(feature = "block2")]
        /// Asynchronously loads the METrackInfo object with properties of the media asset track.
        ///
        /// This method should provide either a valid METrackInfo object or nil.  If the method fails, the NSError will contain error information.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'trackInfo'
        /// The returned METrackInfo object if the method succeeds, otherwise nil.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(loadTrackInfoWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadTrackInfoWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut METrackInfo, *mut NSError)>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
        /// Provides a new MESampleCursor object pointing to the sample at or near the specified presentation timestamp.
        ///
        /// The new MESampleCursor will point to the last sample with a PTS less than or equal to presentationTimeStamp, or if there are no such samples, the first sample in PTS order.
        ///
        /// Parameter `presentationTimeStamp`: The desired PTS.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'sampleCursor'
        /// The returned MESampleCursor if the method succeeds, otherwise nil.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(generateSampleCursorAtPresentationTimeStamp:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn generateSampleCursorAtPresentationTimeStamp_completionHandler(
            &self,
            presentation_time_stamp: CMTime,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut ProtocolObject<dyn MESampleCursor>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Provides a new MESampleCursor object pointing to the first sample in decode order.
        ///
        /// The new MESampleCursor will point to the first sample in decode order regardless of the presentation time.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'sampleCursor'
        /// The returned MESampleCursor if the method succeeds, otherwise nil.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(generateSampleCursorAtFirstSampleInDecodeOrderWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn generateSampleCursorAtFirstSampleInDecodeOrderWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut ProtocolObject<dyn MESampleCursor>, *mut NSError),
            >,
        );

        #[cfg(feature = "block2")]
        /// Provides a new MESampleCursor object pointing to the last sample in decode order.
        ///
        /// The new MESampleCursor will point to the last sample in decode order regardless of the presentation time.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'sampleCursor'
        /// The returned MESampleCursor if the method succeeds, otherwise nil.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(generateSampleCursorAtLastSampleInDecodeOrderWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn generateSampleCursorAtLastSampleInDecodeOrderWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut ProtocolObject<dyn MESampleCursor>, *mut NSError),
            >,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
        /// Returns the duration of the track as a CMTime disregarding any edits.
        ///
        /// This information may be used by the MediaToolbox to validate edit information or to check if the media is suitable for gapless playback.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'uneditedDuration'
        /// A valid duration if the method succeeds, otherwise kCMTimeInvalid.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[optional]
        #[unsafe(method(loadUneditedDurationWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadUneditedDurationWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(CMTime, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Loads the total size in bytes of all the samples in the track.
        ///
        /// If the method fails, the NSError will contain error information.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'totalSampleDataLength'
        /// A valid data length if the method succeeds, otherwise 0.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[optional]
        #[unsafe(method(loadTotalSampleDataLengthWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadTotalSampleDataLengthWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(i64, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Loads the approximate data rate of the track in bytes per second as a floating point number.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'estimatedDataRate'
        /// A valid data rate if the method succeeds, otherwise 0.0.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[optional]
        #[unsafe(method(loadEstimatedDataRateWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadEstimatedDataRateWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(f32, *mut NSError)>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-av-foundation"))]
        /// Asynchronously loads an NSArray object with metadata from the media asset track.
        ///
        /// This method should provide either a valid NSArray object or nil. If the method fails, the NSError will contain error information.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'metadata'
        /// An NSArray of AVMetadataItem objects if the method succeeds, otherwise nil.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[optional]
        #[unsafe(method(loadMetadataWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadMetadataWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSArray<AVMetadataItem>, *mut NSError),
            >,
        );
    }
);

extern_class!(
    /// A class incorporating track properties parsed from the media asset.
    ///
    /// The METrackInfo properties are parsed asynchronously through the loadTrackInfoWithCompletionHandler method of METrackReader.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/metrackinfo?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct METrackInfo;
);

unsafe impl Send for METrackInfo {}

unsafe impl Sync for METrackInfo {}

extern_conformance!(
    unsafe impl NSCopying for METrackInfo {}
);

unsafe impl CopyingHelper for METrackInfo {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for METrackInfo {}
);

impl METrackInfo {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "objc2-core-media")]
        /// Initializes a new METrackInfo instance.
        ///
        /// The main initializer for the METrackInfo class. After creating the class, the METrackReader should fill in all the relevant properties with the values read in from the media track.
        ///
        /// Parameter `mediaType`: The media type of the track.
        ///
        /// Parameter `trackID`: An integer identifying the track within the media asset.
        ///
        /// Parameter `formatDescriptions`: The format descriptions for the track, as an NSArray.
        ///
        /// Returns: A new instance of METrackInfo.
        #[unsafe(method(initWithMediaType:trackID:formatDescriptions:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithMediaType_trackID_formatDescriptions(
            this: Allocated<Self>,
            media_type: CMMediaType,
            track_id: CMPersistentTrackID,
            format_descriptions: &NSArray,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-media")]
        /// The media type of the track.
        ///
        /// This value is set through the class initializer.
        #[unsafe(method(mediaType))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaType(&self) -> CMMediaType;

        #[cfg(feature = "objc2-core-media")]
        /// An integer identifying the track within the media asset.
        ///
        /// The track ID is used to uniquely identify the track within the MEFormatReader. Track IDs must be unique within a media asset but do not need to be unique across assets. If a media format does not have a native concept of track IDs, track IDs may be assigned starting from 1. The track ID value of 0 is reserved to indicate an invalid track ID. This value is set through the class initializer.
        #[unsafe(method(trackID))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackID(&self) -> CMPersistentTrackID;

        /// A BOOL value indicating whether the track is enabled by default.
        #[unsafe(method(isEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEnabled(&self) -> bool;

        /// Setter for [`isEnabled`][Self::isEnabled].
        #[unsafe(method(setEnabled:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEnabled(&self, enabled: bool);

        /// The format descriptions for the track, as an NSArray.
        ///
        /// This value is set through the class initializer.
        #[unsafe(method(formatDescriptions))]
        #[unsafe(method_family = none)]
        pub unsafe fn formatDescriptions(&self) -> Retained<NSArray>;
    );
}

/// OptionalProperties.
impl METrackInfo {
    extern_methods!(
        #[cfg(feature = "objc2-core-media")]
        /// The natural timescale of the track, as a CMTimeScale value.
        #[unsafe(method(naturalTimescale))]
        #[unsafe(method_family = none)]
        pub unsafe fn naturalTimescale(&self) -> CMTimeScale;

        #[cfg(feature = "objc2-core-media")]
        /// Setter for [`naturalTimescale`][Self::naturalTimescale].
        #[unsafe(method(setNaturalTimescale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNaturalTimescale(&self, natural_timescale: CMTimeScale);

        /// Returns the array of edit segments for the given track.
        ///
        /// Each NSValue in the array contains a CMTimeMapping object describing the track edit. The CMTimeMapping.target time ranges for successive edits must partition the time range from 0 to the track's duration. In other words, for edit index = 0 the CMTimeMapping.target.start must be kCMTimeZero, while for edit index > 0, the CMTimeMapping.target.start must match the CMTimeRangeGetEnd(CMTimeMapping.target) for edit (index - 1). It is valid for a track to have an empty trackEdits array; this means that there is nothing at all in the track and the track duration is zero. If this property is implemented for media asset formats that do not support edit segments, it can return nil.
        #[unsafe(method(trackEdits))]
        #[unsafe(method_family = none)]
        pub unsafe fn trackEdits(&self) -> Option<Retained<NSArray<NSValue>>>;

        /// Setter for [`trackEdits`][Self::trackEdits].
        #[unsafe(method(setTrackEdits:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTrackEdits(&self, track_edits: Option<&NSArray<NSValue>>);
    );
}

/// LanguageTagOptionalProperties.
impl METrackInfo {
    extern_methods!(
        /// Indicates the language tag associated with the track, as an IETF BCP 47 (RFC 4646) language identifier.
        ///
        /// This property may be used by the MediaToolbox to group similar language tracks together or to match audio and caption tracks. If no language tag is indicated, this property should be set to nil.
        #[unsafe(method(extendedLanguageTag))]
        #[unsafe(method_family = none)]
        pub unsafe fn extendedLanguageTag(&self) -> Option<Retained<NSString>>;

        /// Setter for [`extendedLanguageTag`][Self::extendedLanguageTag].
        #[unsafe(method(setExtendedLanguageTag:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExtendedLanguageTag(&self, extended_language_tag: Option<&NSString>);
    );
}

/// VideoSpecificOptionalProperties.
impl METrackInfo {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        /// Indicates the natural dimensions of the media data referenced by the track as a CGSize.
        ///
        /// This property is only valid for tracks with visual media types and should return CGSizeZero if implemented for other track types.
        #[unsafe(method(naturalSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn naturalSize(&self) -> CGSize;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`naturalSize`][Self::naturalSize].
        #[unsafe(method(setNaturalSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNaturalSize(&self, natural_size: CGSize);

        #[cfg(feature = "objc2-core-foundation")]
        /// Indicates the preferred affine display transform of the track media for visual display.
        ///
        /// Returns an CGAffineTransform representing the preferred affine transform of the track for visual display. This property is only valid for tracks with visual media types and should return CGAffineTransformIdentity if implemented for other track types.
        #[unsafe(method(preferredTransform))]
        #[unsafe(method_family = none)]
        pub unsafe fn preferredTransform(&self) -> CGAffineTransform;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`preferredTransform`][Self::preferredTransform].
        #[unsafe(method(setPreferredTransform:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPreferredTransform(&self, preferred_transform: CGAffineTransform);

        /// The frame rate of the track, in frames per second, as a 32-bit floating point number.
        ///
        /// For field-based video tracks that carry one field per media sample, the value of this property is the field rate, not the frame rate. This information from this property may be used by the MediaToolbox to calculate the maximum playback speed.
        #[unsafe(method(nominalFrameRate))]
        #[unsafe(method_family = none)]
        pub unsafe fn nominalFrameRate(&self) -> f32;

        /// Setter for [`nominalFrameRate`][Self::nominalFrameRate].
        #[unsafe(method(setNominalFrameRate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setNominalFrameRate(&self, nominal_frame_rate: f32);

        /// Indicates whether frame reordering occurs in the track.
        ///
        /// The value is YES if frame reordering occurs, NO otherwise. This property is only valid for tracks with video media type and should return NO for if implemented for other track types.
        #[unsafe(method(requiresFrameReordering))]
        #[unsafe(method_family = none)]
        pub unsafe fn requiresFrameReordering(&self) -> bool;

        /// Setter for [`requiresFrameReordering`][Self::requiresFrameReordering].
        #[unsafe(method(setRequiresFrameReordering:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRequiresFrameReordering(&self, requires_frame_reordering: bool);
    );
}

extern_protocol!(
    /// Provides information about samples within a track of a media asset.
    ///
    /// The Media Toolbox creates an MESampleCursor object by calling one of the METrackReader sample cursor creation methods. It then makes method calls using the MESampleCursor protocol. MESampleCursors can deliver sample data either by providing sample location and sample chunk information, or by directly generating a sample buffer.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/mesamplecursor?language=objc)
    pub unsafe trait MESampleCursor: NSObjectProtocol + NSCopying {
        #[cfg(feature = "objc2-core-media")]
        /// The presentation timestamp (PTS) of the sample at the current position of the cursor.
        #[unsafe(method(presentationTimeStamp))]
        #[unsafe(method_family = none)]
        unsafe fn presentationTimeStamp(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// The decode timestamp (DTS) of the sample at the current position of the cursor.
        #[unsafe(method(decodeTimeStamp))]
        #[unsafe(method_family = none)]
        unsafe fn decodeTimeStamp(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// Indicates the decode duration of the sample at the receiver's current position.
        ///
        /// If the receiver must be advanced past its current position in order to determine the decode duration of the current sample, the value of currentSampleDuration is equal to kCMTimeIndefinite. This can occur with streaming formats such as MPEG-2 transport streams.
        #[unsafe(method(currentSampleDuration))]
        #[unsafe(method_family = none)]
        unsafe fn currentSampleDuration(&self) -> CMTime;

        #[cfg(feature = "objc2-core-media")]
        /// The format description for the sample at the current position of the cursor.
        #[unsafe(method(currentSampleFormatDescription))]
        #[unsafe(method_family = none)]
        unsafe fn currentSampleFormatDescription(&self) -> Option<Retained<CMFormatDescription>>;

        #[cfg(feature = "block2")]
        /// Moves the cursor a given number of samples in decode order.
        ///
        /// If the request would advance the cursor past the last sample or before the first sample, the cursor should be set to point to that limiting sample and actualStepCount will report the number of samples the cursor was able to move.
        ///
        /// Parameter `stepCount`: The number of samples to move. If positive, step forward this many samples. If negative, step backward (-stepCount) samples.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'actualStepCount'
        /// The final count of steps taken.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(stepInDecodeOrderByCount:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn stepInDecodeOrderByCount_completionHandler(
            &self,
            step_count: i64,
            completion_handler: &block2::DynBlock<dyn Fn(i64, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// @
        ///
        ///
        /// Moves the cursor a given number of samples in presentation order.
        ///
        /// If the request would advance the cursor past the last sample or before the first sample, the cursor should be set to point to that limiting sample and actualStepCount will report the number of samples the cursor was able to move. If decode order and presentation order are the same (ie, the samples are not reordered), this method should have the same effect as stepInDecodeOrderByCount.
        ///
        /// Parameter `stepCount`: The number of samples to move. If positive, step forward this many samples. If negative, step backward (-stepCount) samples.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'actualStepCount'
        /// The final count of steps taken.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(stepInPresentationOrderByCount:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn stepInPresentationOrderByCount_completionHandler(
            &self,
            step_count: i64,
            completion_handler: &block2::DynBlock<dyn Fn(i64, *mut NSError)>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
        /// Moves the cursor by a given deltaDecodeTime on the decode timeline.
        ///
        /// If the request would advance the cursor past the end of the last sample or before the first sample, the cursor should be set to point to that limiting sample, and positionWasPinned will be set to YES. Otherwise, positionWasPinned will be set to NO.
        ///
        /// Parameter `deltaDecodeTime`: The cursor is moved to the sample at decode time (current sample decode time + deltaDecodeTime).
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'actualDecodeTime'
        /// The final cursor decode time. Because sample cursors snap to sample boundaries when stepped, this value may not be equal to (current sample decode time + deltaDecodeTime) even if the cursor was not pinned.
        /// 'positionWasPinned'
        /// YES if the request attempted to advance the cursor beyond the track limits, otherwise NO.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(stepByDecodeTime:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn stepByDecodeTime_completionHandler(
            &self,
            delta_decode_time: CMTime,
            completion_handler: &block2::DynBlock<dyn Fn(CMTime, Bool, *mut NSError)>,
        );

        #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
        /// Moves the cursor by a given deltaPresentationTime on the presentation timeline.
        ///
        /// If the request would advance the cursor past the end of the last sample or before the first sample, the cursor should be set to point to that limiting sample, and positionWasPinned will be set to YES. Otherwise, positionWasPinned will be set to NO.
        ///
        /// Parameter `deltaPresentationTime`: The cursor is moved to the sample at presentation time (current sample presentation time + deltaPresentationTime).
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'actualPresentationTime'
        /// The final cursor presentation time. Because sample cursors snap to sample boundaries when stepped, this value may not be equal to (current sample presentation time + deltaPresentationTime) even if the cursor was not pinned.
        /// 'positionWasPinned'
        /// YES if the request attempted to advance the cursor beyond the track limits, otherwise NO.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[unsafe(method(stepByPresentationTime:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn stepByPresentationTime_completionHandler(
            &self,
            delta_presentation_time: CMTime,
            completion_handler: &block2::DynBlock<dyn Fn(CMTime, Bool, *mut NSError)>,
        );

        #[cfg(feature = "objc2-av-foundation")]
        /// Retrieves decoder synchronization information about the sample pointed to by the cursor.
        ///
        /// The returned value will be an AVSampleCursorSyncInfo structure with any valid flags set. If this kind of synchronization information does not make sense for the sequence of samples, this property should not be implemented.
        #[optional]
        #[unsafe(method(syncInfo))]
        #[unsafe(method_family = none)]
        unsafe fn syncInfo(&self) -> AVSampleCursorSyncInfo;

        #[cfg(feature = "objc2-av-foundation")]
        /// Retrieves generic dependency information about the sample pointed to by the cursor.
        ///
        /// The returned value will be an AVSampleCursorDependencyInfo structure with any valid flags set. If this kind of dependency information does not make sense for the sequence of samples, this property should not be implemented.
        #[optional]
        #[unsafe(method(dependencyInfo))]
        #[unsafe(method_family = none)]
        unsafe fn dependencyInfo(&self) -> AVSampleCursorDependencyInfo;

        /// Retrieves additional information necessary to recover complete sample dependency information.
        ///
        /// hevcDependencyInfo is an optional property that communicates additional sample dependency information not contained in syncInfo or dependencyInfo. Examples of this are the NAL unit type of an HEVC sync sample or the number of samples necessary to refresh the decoder after a USAC Independent Frame. For formats where this information does not make sense, this property should be set to nil.
        #[optional]
        #[unsafe(method(hevcDependencyInfo))]
        #[unsafe(method_family = none)]
        unsafe fn hevcDependencyInfo(&self) -> Retained<MEHEVCDependencyInfo>;

        #[cfg(feature = "objc2-core-media")]
        /// Retrieves the duration of the content playable from the cursor as a CMTime.
        ///
        /// Indicates the time difference between the current cursor DTS and last reachable sample DTS. This is necessary to play assets with e.g. HTTP URLs as it indicates what samples have already been loaded by the byte source.
        #[optional]
        #[unsafe(method(decodeTimeOfLastSampleReachableByForwardSteppingThatIsAlreadyLoadedByByteSource))]
        #[unsafe(method_family = none)]
        unsafe fn decodeTimeOfLastSampleReachableByForwardSteppingThatIsAlreadyLoadedByByteSource(
            &self,
        ) -> CMTime;

        /// Tests for an earlier boundary in sample reordering.
        ///
        /// This method tests for a boundary in the reordering from decode order to presentation order, determining when it could be possible for any sample earlier in decode order than the receiver current sample to have a presentation time later than the current sample of the specified cursor. This test can be used to limit backward scans, e.g. to start forward playback. For example, with the argument cursor fixed, step the receiver backwards until it is impossible for any earlier-in-decode-order receiver samples to be later-in-presentation-order than the argument cursor sample. If sample reordering does not make sense for the track content, this method should not be implemented. If this method is not implemented, clients should assume the samples are not reordered.
        ///
        /// Parameter `cursor`: An instance of id
        /// <MESampleCursor
        /// > with which to test the sample reordering boundary.
        ///
        /// Returns: YES if it is possible earlier samples in decode order than that of the receiver can have a presentation timestamp later than that of the specified sample cursor, otherwise NO. If the receiver and argument cursors reference different sequences of samples, for example if they were created by different instances of MTTrackReader, the results are undefined.
        #[optional]
        #[unsafe(method(samplesWithEarlierDTSsMayHaveLaterPTSsThanCursor:))]
        #[unsafe(method_family = none)]
        unsafe fn samplesWithEarlierDTSsMayHaveLaterPTSsThanCursor(
            &self,
            cursor: &ProtocolObject<dyn MESampleCursor>,
        ) -> bool;

        /// Tests for a later boundary in sample reordering.
        ///
        /// This method tests for a boundary in the reordering from decode order to presentation order, determining when it could be possible for any sample later in decode order than the receiver current sample to have a presentation time earlier than the current sample of the specified cursor. This test can be used to limit forward scans, e.g. to start reverse playback. For example, with the argument cursor fixed, step the receiver forwards until it is impossible for any later-in-decode-order receiver samples to be earlier-in-presentation-order than the argument cursor sample. If sample reordering does not make sense for the track content, this method should not be implemented. If this method is not implemented, clients should assume the samples are not reordered.
        ///
        /// Parameter `cursor`: An instance of id
        /// <MESampleCursor
        /// > with which to test the sample reordering boundary.
        ///
        /// Returns: YES if it is possible later samples in decode order than that of the receiver can have a presentation timestamp earlier than that of the specified sample cursor, otherwise NO. If the receiver and argument cursors reference different sequences of samples, for example if they were created by different instances of MTTrackReader, the results are undefined.
        #[optional]
        #[unsafe(method(samplesWithLaterDTSsMayHaveEarlierPTSsThanCursor:))]
        #[unsafe(method_family = none)]
        unsafe fn samplesWithLaterDTSsMayHaveEarlierPTSsThanCursor(
            &self,
            cursor: &ProtocolObject<dyn MESampleCursor>,
        ) -> bool;

        /// Returns information about the chunk holding the sample indicated by the cursor.
        ///
        /// If the sample resides in a contiguous chunk of the file among similar samples, chunkDetails returns information about that chunk. Note: For some media asset formats it is not practical to implement chunkDetails. In this case chunkDetails should return MEErrorLocationNotAvailable and loadSampleBufferContainingSamplesToEndCursor must be used to load the sample data.
        ///
        /// Parameter `error`: If provided, returns error information in the event that the method fails.
        ///
        /// Returns: Returns an instance of MESampleCursorChunk with details about the chunk if successful, returns NULL and fails with MEErrorLocationNotAvailable if sampleCursor does not support chunkDetails, or returns NULL if the method otherwise fails with error.
        #[optional]
        #[unsafe(method(chunkDetailsReturningError:_))]
        #[unsafe(method_family = none)]
        unsafe fn chunkDetailsReturningError(
            &self,
        ) -> Result<Retained<MESampleCursorChunk>, Retained<NSError>>;

        /// Returns the location and byte source of the sample indicated by the cursor.
        ///
        /// This method is used to allow the system to handle reading the sample data. Sample data is expected to be contiguous. For some media asset formats, most samples are contiguous but there are exceptions; such MESampleCursors should support both sampleLocation and loadSampleBufferContainingSamplesToEndCursor. For samples that are not contiguous, sampleLocation should return MEErrorLocationNotAvailable. For other media asset formats, it is not practical to implement sampleLocation; such MESampleCursors must implement loadSampleBufferContainingSamplesToEndCursor instead.
        ///
        /// Parameter `error`: If provided, returns error information in the event that the method fails.
        ///
        /// Returns: Returns an instance of MESampleLocation with information about the sample location if successful, returns NULL and fails with MEErrorLocationNotAvailable if the sample is not contiguous or this method is not supported, in which case loadSampleBufferContainingSamplesToEndCursor must be called instead in order to load the sample data, or returns NULL if the method otherwise fails with error.
        #[optional]
        #[unsafe(method(sampleLocationReturningError:_))]
        #[unsafe(method_family = none)]
        unsafe fn sampleLocationReturningError(
            &self,
        ) -> Result<Retained<MESampleLocation>, Retained<NSError>>;

        /// Returns an estimate of the sample location indicated by the cursor that can later be refined using refineSampleLocation.
        ///
        /// Optional addition to sampleLocationReturningError. For formats that need to read some data on a per-sample basis to produce the exact sample location, it may be more efficient to read a slightly larger chunk of data containing both the data necessary to produce the exact sample location and the actual sample data. The exact sample location will then be requested in a subsequent call to refineSampleLocation. It is possible to indicate that no refinement is necessary by returning a value for refinementDataLocation that has a zero length. If a non-zero length refinement location is returned, the range for the estimated sample location returned must fully cover the refined range returned by refineSampleLocation and the refinement data location. Note: Implementing estimatedSampleLocationReturningError also requires implementing refineSampleLocation. If the sample indicated by the cursor is not contiguous, this method will return MEErrorLocationNotAvailable. In this case the loadSampleBufferContainingSamplesToEndCursor must be used to load the sample data.
        ///
        /// Parameter `error`: If provided, returns error information in the event that the method fails.
        ///
        /// Returns: Returns an instance of MEEstimatedSampleLocation with information about the estimated sample location if successful, returns NULL and fails with MEErrorLocationNotAvailable if the sample is not contiguous or this method is not supported, in which case loadSampleBufferContainingSamplesToEndCursor must be called instead in order to load the sample data, or returns NULL if the method otherwise fails with error.
        #[optional]
        #[unsafe(method(estimatedSampleLocationReturningError:_))]
        #[unsafe(method_family = none)]
        unsafe fn estimatedSampleLocationReturningError(
            &self,
        ) -> Result<Retained<MEEstimatedSampleLocation>, Retained<NSError>>;

        #[cfg(feature = "objc2-av-foundation")]
        /// Produces an exact sample location based on data returned from a call to estimatedSampleLocationReturningError.
        ///
        /// See the discussion in estimatedSampleLocationReturningError for details.
        ///
        /// Parameter `estimatedSampleLocation`: The value that was previously returned in the MEEstimatedSampleLocation object from estimatedSampleLocationReturningError
        ///
        /// Parameter `refinementData`: The refinement data returned from estimateSampleLocation in MEEstimatedSampleLocation.
        ///
        /// Parameter `refinementDataLength`: The length of refinementData in bytes.
        ///
        /// Parameter `refinedLocationOut`: Returns the exact starting file offset and size of the sample in bytes.
        ///
        /// Parameter `error`: If provided, returns error information in the event that the method fails.
        ///
        /// Returns: YES if the method succeeds, NO if it fails. If the method fails, error will contain error information.
        #[optional]
        #[unsafe(method(refineSampleLocation:refinementData:refinementDataLength:refinedLocation:error:_))]
        #[unsafe(method_family = none)]
        unsafe fn refineSampleLocation_refinementData_refinementDataLength_refinedLocation_error(
            &self,
            estimated_sample_location: AVSampleCursorStorageRange,
            refinement_data: NonNull<u8>,
            refinement_data_length: usize,
            refined_location_out: NonNull<AVSampleCursorStorageRange>,
        ) -> Result<(), Retained<NSError>>;

        #[cfg(all(feature = "block2", feature = "objc2-core-media"))]
        /// Builds a sample buffer containing the sample(s) at the cursor.
        ///
        /// This method is to be implemented by those plugin format readers that always load sample data in order to answer cursor queries. If a plugin format reader does not implement sampleLocation, implementing loadSampleBufferContainingSamplesToEndCursor is required. If the MESampleCursor does implement sampleLocation, implementing loadSampleBufferContainingSamplesToEndCursor is optional. Important note: If there is a change of format description between the receiver and endSampleCursor, the returned sample buffer must contain only the contiguous samples with the same format description as the first sample. If there is no sample data between cursor and endSampleCursor, this method should return an empty sample buffer. This method should only provide a NULL sample buffer when there is an error.
        ///
        /// Parameter `endSampleCursor`: If not nil, indicates the last sample that the new sample buffer should contain. If endSampleCursor refers to a sample earlier than the receiver, this method should fail and return MEErrorNoSamples as error code. If endSampleCursor is nil or refers to the same sample as the receiver, only a single sample should be returned in the new sample buffer.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'newSampleBuffer'
        /// A CMSampleBufferRef with the newly created sample buffer. If the sample cursor is implemented in Objective-C, it is the responsibility of the sample cursor implementation to balance the creation of this sample buffer by calling CFRelease.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[optional]
        #[unsafe(method(loadSampleBufferContainingSamplesToEndCursor:completionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadSampleBufferContainingSamplesToEndCursor_completionHandler(
            &self,
            end_sample_cursor: Option<&ProtocolObject<dyn MESampleCursor>>,
            completion_handler: &block2::DynBlock<dyn Fn(*mut CMSampleBuffer, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Asynchronously loads a dictionary that represents frame level metadata for post decode processing.
        ///
        /// This method should provide either a valid NSDictionary or nil. If the method fails, the NSError will contain error information.
        /// The post decode processing metadata could either be contained in the media asset primary file or be located in a separate related "sidecar" file. If contained in a separate file with a different extension, that file extension should be included in the EXAppExtensionAttributes and UTExportedTypeDeclarations dictionaries in the MediaExtension format reader Info.plist. The metadata returned should contain sequence level metadata for post decode processing, along with optional frame level metadata if present.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes, or if it is nil.
        /// 'postDecodeProcessingMetadata'
        /// The returned NSDictionary should conform to a CFPropertyList.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil.
        #[optional]
        #[unsafe(method(loadPostDecodeProcessingMetadataWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn loadPostDecodeProcessingMetadataWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSDictionary<NSString, AnyObject>, *mut NSError),
            >,
        );
    }
);

extern_class!(
    /// Provides information about the chunk of media where a sample is located.
    ///
    /// An instance of this class is returned by calls to the MESampleCursor method chunkDetails.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/mesamplecursorchunk?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MESampleCursorChunk;
);

unsafe impl Send for MESampleCursorChunk {}

unsafe impl Sync for MESampleCursorChunk {}

extern_conformance!(
    unsafe impl NSCopying for MESampleCursorChunk {}
);

unsafe impl CopyingHelper for MESampleCursorChunk {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MESampleCursorChunk {}
);

impl MESampleCursorChunk {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(all(feature = "objc2-av-foundation", feature = "objc2-core-foundation"))]
        /// The initializer for the MESampleCursorChunk class.
        ///
        /// Parameter `byteSource`: The MEByteSource to be used to read the data for the sample.
        ///
        /// Parameter `chunkStorageRange`: The offset location and length of the sample's chunk within the MEByteSource.
        ///
        /// Parameter `chunkInfo`: A completed AVSampleCursorChunkInfo with details about the chunk in the media.
        ///
        /// Parameter `sampleIndexWithinChunk`: The offset of the sample within the chunk, in samples.
        #[unsafe(method(initWithByteSource:chunkStorageRange:chunkInfo:sampleIndexWithinChunk:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithByteSource_chunkStorageRange_chunkInfo_sampleIndexWithinChunk(
            this: Allocated<Self>,
            byte_source: &MEByteSource,
            chunk_storage_range: AVSampleCursorStorageRange,
            chunk_info: AVSampleCursorChunkInfo,
            sample_index_within_chunk: CFIndex,
        ) -> Retained<Self>;

        /// The MEByteSource to be used to read the data for the sample.
        #[unsafe(method(byteSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn byteSource(&self) -> Retained<MEByteSource>;

        #[cfg(feature = "objc2-av-foundation")]
        /// The offset location and length of the sample's chunk, in bytes, within the MEByteSource.
        ///
        /// The length should be set to 0 if there is no chunk associated with the sample.
        #[unsafe(method(chunkStorageRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn chunkStorageRange(&self) -> AVSampleCursorStorageRange;

        #[cfg(feature = "objc2-av-foundation")]
        /// Provides information about the chunk of media samples.
        #[unsafe(method(chunkInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn chunkInfo(&self) -> AVSampleCursorChunkInfo;

        #[cfg(feature = "objc2-core-foundation")]
        /// The offset of the sample within the chunk, in samples.
        ///
        /// Index value 0 corresponds to the start of the chunk. You would step back this many samples to position the cursor at the start of the chunk. Subtract from the chunkInfo.chunkSampleCount field to obtain the number of samples to the end of the chunk.
        #[unsafe(method(sampleIndexWithinChunk))]
        #[unsafe(method_family = none)]
        pub unsafe fn sampleIndexWithinChunk(&self) -> CFIndex;
    );
}

extern_class!(
    /// Provides information about the sample location with the media.
    ///
    /// An instance of this class is returned by calls to the MESampleCursor method sampleLocation.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/mesamplelocation?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MESampleLocation;
);

unsafe impl Send for MESampleLocation {}

unsafe impl Sync for MESampleLocation {}

extern_conformance!(
    unsafe impl NSCopying for MESampleLocation {}
);

unsafe impl CopyingHelper for MESampleLocation {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MESampleLocation {}
);

impl MESampleLocation {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "objc2-av-foundation")]
        /// The initializer for the MESampleLocation class.
        ///
        /// Parameter `byteSource`: The MEByteSource to be used to read the data for the sample.
        ///
        /// Parameter `sampleLocation`: The starting file offset and size in bytes of the sample.
        #[unsafe(method(initWithByteSource:sampleLocation:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithByteSource_sampleLocation(
            this: Allocated<Self>,
            byte_source: &MEByteSource,
            sample_location: AVSampleCursorStorageRange,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-av-foundation")]
        /// The starting file offset and size in bytes of the sample.
        #[unsafe(method(sampleLocation))]
        #[unsafe(method_family = none)]
        pub unsafe fn sampleLocation(&self) -> AVSampleCursorStorageRange;

        /// The MEByteSource to be used to read the data for the sample.
        #[unsafe(method(byteSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn byteSource(&self) -> Retained<MEByteSource>;
    );
}

extern_class!(
    /// Provides information about the estimated sample location with the media.
    ///
    /// An instance of this class is returned by calls to the MESampleCursor method estimatedSampleLocationReturningError.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/meestimatedsamplelocation?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MEEstimatedSampleLocation;
);

unsafe impl Send for MEEstimatedSampleLocation {}

unsafe impl Sync for MEEstimatedSampleLocation {}

extern_conformance!(
    unsafe impl NSCopying for MEEstimatedSampleLocation {}
);

unsafe impl CopyingHelper for MEEstimatedSampleLocation {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MEEstimatedSampleLocation {}
);

impl MEEstimatedSampleLocation {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "objc2-av-foundation")]
        /// The initializer for the MEEstimatedSampleLocation class.
        ///
        /// Parameter `byteSource`: The MEByteSource to be used to read the data for the sample.
        ///
        /// Parameter `estimatedSampleLocation`: The estimated starting file offset and size in bytes of the sample.
        ///
        /// Parameter `refinementDataLocation`: The starting file offset and size in bytes of the the data necessary to provide an accurate sample location.
        #[unsafe(method(initWithByteSource:estimatedSampleLocation:refinementDataLocation:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithByteSource_estimatedSampleLocation_refinementDataLocation(
            this: Allocated<Self>,
            byte_source: &MEByteSource,
            estimated_sample_location: AVSampleCursorStorageRange,
            refinement_data_location: AVSampleCursorStorageRange,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-av-foundation")]
        /// The estimated starting file offset and size in bytes of the sample.
        #[unsafe(method(estimatedSampleLocation))]
        #[unsafe(method_family = none)]
        pub unsafe fn estimatedSampleLocation(&self) -> AVSampleCursorStorageRange;

        #[cfg(feature = "objc2-av-foundation")]
        /// The starting file offset and size in bytes of the the data necessary to provide an accurate sample location.
        ///
        /// The refinement data can be provided to the MESampleCursor method refineSampleLocation to determine the exact sample location.
        #[unsafe(method(refinementDataLocation))]
        #[unsafe(method_family = none)]
        pub unsafe fn refinementDataLocation(&self) -> AVSampleCursorStorageRange;

        /// The MEByteSource to be used to read the data for the sample.
        #[unsafe(method(byteSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn byteSource(&self) -> Retained<MEByteSource>;
    );
}

extern_class!(
    /// Provides information about the HEVC dependency attributes of a sample.
    ///
    /// An instance of this class is returned by MESampleCursor property hevcDependencyInfo.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/mehevcdependencyinfo?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MEHEVCDependencyInfo;
);

unsafe impl Send for MEHEVCDependencyInfo {}

unsafe impl Sync for MEHEVCDependencyInfo {}

extern_conformance!(
    unsafe impl NSCopying for MEHEVCDependencyInfo {}
);

unsafe impl CopyingHelper for MEHEVCDependencyInfo {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for MEHEVCDependencyInfo {}
);

impl MEHEVCDependencyInfo {
    extern_methods!(
        /// YES if the sample is an HEVC 'TSA' picture, NO otherwise.
        ///
        /// Maps to the kCMSampleAttachmentKey_HEVCTemporalSubLayerAccess sample buffer attachment.
        #[unsafe(method(hasTemporalSubLayerAccess))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasTemporalSubLayerAccess(&self) -> bool;

        /// Setter for [`hasTemporalSubLayerAccess`][Self::hasTemporalSubLayerAccess].
        #[unsafe(method(setTemporalSubLayerAccess:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTemporalSubLayerAccess(&self, temporal_sub_layer_access: bool);

        /// YES if the sample is an HEVC 'STSA' picture, NO otherwise.
        ///
        /// Maps to the kCMSampleAttachmentKey_HEVCStepwiseTemporalSubLayerAccess sample buffer attachment.
        #[unsafe(method(hasStepwiseTemporalSubLayerAccess))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasStepwiseTemporalSubLayerAccess(&self) -> bool;

        /// Setter for [`hasStepwiseTemporalSubLayerAccess`][Self::hasStepwiseTemporalSubLayerAccess].
        #[unsafe(method(setStepwiseTemporalSubLayerAccess:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setStepwiseTemporalSubLayerAccess(
            &self,
            stepwise_temporal_sub_layer_access: bool,
        );

        /// The NAL unit type for HEVC 'sync' sample groups, or -1 if this information is not available.
        ///
        /// Maps to the kCMSampleAttachmentKey_HEVCSyncSampleNALUnitType sample buffer attachment.
        #[unsafe(method(syncSampleNALUnitType))]
        #[unsafe(method_family = none)]
        pub unsafe fn syncSampleNALUnitType(&self) -> i16;

        /// Setter for [`syncSampleNALUnitType`][Self::syncSampleNALUnitType].
        #[unsafe(method(setSyncSampleNALUnitType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSyncSampleNALUnitType(&self, sync_sample_nal_unit_type: i16);
    );
}

/// Methods declared on superclass `NSObject`.
impl MEHEVCDependencyInfo {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// HEVCTemporalLevelInfo.
/// Indicates a video frame's level within a hierarchical frame dependency structure.
///
/// The properties here map to the kCMSampleAttachmentKey_HEVCTemporalLevelInfo sample buffer attachment dictionary.
impl MEHEVCDependencyInfo {
    extern_methods!(
        /// The HEVC temporal level, or -1 if this information is not available.
        ///
        /// Maps to the kCMHEVCTemporalLevelInfoKey_TemporalLevel sample buffer attachment.
        #[unsafe(method(temporalLevel))]
        #[unsafe(method_family = none)]
        pub unsafe fn temporalLevel(&self) -> i16;

        /// Setter for [`temporalLevel`][Self::temporalLevel].
        #[unsafe(method(setTemporalLevel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTemporalLevel(&self, temporal_level: i16);

        /// The HEVC profile space, or -1 if this information is not available.
        ///
        /// Maps to the kCMHEVCTemporalLevelInfoKey_ProfileSpace sample buffer attachment.
        #[unsafe(method(profileSpace))]
        #[unsafe(method_family = none)]
        pub unsafe fn profileSpace(&self) -> i16;

        /// Setter for [`profileSpace`][Self::profileSpace].
        #[unsafe(method(setProfileSpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProfileSpace(&self, profile_space: i16);

        /// The HEVC tier level flag, or -1 if this information is not available.
        ///
        /// Maps to the kCMHEVCTemporalLevelInfoKey_TierFlag sample buffer attachment.
        #[unsafe(method(tierFlag))]
        #[unsafe(method_family = none)]
        pub unsafe fn tierFlag(&self) -> i16;

        /// Setter for [`tierFlag`][Self::tierFlag].
        #[unsafe(method(setTierFlag:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTierFlag(&self, tier_flag: i16);

        /// The HEVC profile index, or -1 if this information is not available.
        ///
        /// Maps to the kCMHEVCTemporalLevelInfoKey_ProfileIndex sample buffer attachment.
        #[unsafe(method(profileIndex))]
        #[unsafe(method_family = none)]
        pub unsafe fn profileIndex(&self) -> i16;

        /// Setter for [`profileIndex`][Self::profileIndex].
        #[unsafe(method(setProfileIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProfileIndex(&self, profile_index: i16);

        /// The HEVC profile compatibility flags (4 bytes), or nil of this information is not available.
        ///
        /// Maps to the kCMHEVCTemporalLevelInfoKey_ProfileCompatibilityFlags sample buffer attachment.
        #[unsafe(method(profileCompatibilityFlags))]
        #[unsafe(method_family = none)]
        pub unsafe fn profileCompatibilityFlags(&self) -> Option<Retained<NSData>>;

        /// Setter for [`profileCompatibilityFlags`][Self::profileCompatibilityFlags].
        #[unsafe(method(setProfileCompatibilityFlags:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProfileCompatibilityFlags(
            &self,
            profile_compatibility_flags: Option<&NSData>,
        );

        /// The HEVC constraint indicator flags (6 bytes), or nil of this information is not available.
        ///
        /// Maps to the kCMHEVCTemporalLevelInfoKey_ConstraintIndicatorFlags sample buffer attachment.
        #[unsafe(method(constraintIndicatorFlags))]
        #[unsafe(method_family = none)]
        pub unsafe fn constraintIndicatorFlags(&self) -> Option<Retained<NSData>>;

        /// Setter for [`constraintIndicatorFlags`][Self::constraintIndicatorFlags].
        #[unsafe(method(setConstraintIndicatorFlags:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConstraintIndicatorFlags(
            &self,
            constraint_indicator_flags: Option<&NSData>,
        );

        /// The HEVC level index, or -1 if this information is not available.
        ///
        /// Maps to the kCMHEVCTemporalLevelInfoKey_LevelIndex sample buffer attachment.
        #[unsafe(method(levelIndex))]
        #[unsafe(method_family = none)]
        pub unsafe fn levelIndex(&self) -> i16;

        /// Setter for [`levelIndex`][Self::levelIndex].
        #[unsafe(method(setLevelIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLevelIndex(&self, level_index: i16);
    );
}

extern_class!(
    /// Provides read access to the data in a media asset file.
    ///
    /// The Media Toolbox passes an MEByteSource instance for the media asset's primary file when initializing an MEFormatReader object. The MEFormatReader may request additional MEByteSources be created for related files in the same directory as the primary file by calling the byteSourceForRelatedFileName method.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/mediaextension/mebytesource?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MEByteSource;
);

unsafe impl Send for MEByteSource {}

unsafe impl Sync for MEByteSource {}

extern_conformance!(
    unsafe impl NSObjectProtocol for MEByteSource {}
);

impl MEByteSource {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// The name of a MEByteSource's file.
        ///
        /// The name of the source file for the MEByteSource.
        #[unsafe(method(fileName))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileName(&self) -> Retained<NSString>;

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        /// A UTType indicating the format of the MEByteSource's file.
        ///
        /// A UTType indicating the format of the source file for the MEByteSource.
        #[unsafe(method(contentType))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentType(&self) -> Option<Retained<UTType>>;

        /// The length of the MEByteSource's file.
        ///
        /// The length in bytes of the source file for the MEByteSource, or 0 if that information is not available.
        #[unsafe(method(fileLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn fileLength(&self) -> i64;

        /// The array of related file names in the MEByteSource's parent directory.
        ///
        /// The array of related files within the MEByteSource's parent directory that are accessible to the MEByteSource. Only the relative file names are returned, not the paths. If no related files are available, returns an empty array.
        #[unsafe(method(relatedFileNamesInSameDirectory))]
        #[unsafe(method_family = none)]
        pub unsafe fn relatedFileNamesInSameDirectory(&self) -> Retained<NSArray<NSString>>;

        #[cfg(feature = "block2")]
        /// Reads bytes from an MEByteSource asynchronously into a buffer.
        ///
        /// Asynchronously reads out the specified number of bytes starting at the indicated offset. Returns the actual number of bytes read out in bytesRead. Read attempts that extend beyond the end of the MEByteSource will succeed if they include at least one valid byte before the end of the MEByteSource.
        ///
        /// Parameter `length`: The number of bytes to read.
        ///
        /// Parameter `offset`: The relative offset in bytes from the beginning of the file from which to start reading.
        ///
        /// Parameter `dest`: The block of memory to hold the data to be read.  Must be at least num bytes in length.
        ///
        /// Parameter `completionHandler`: The handler that will be invoked when the method completes.
        /// 'bytesRead'
        /// The actual number of bytes read.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil. Returns MEErrorEndOfStream if no more bytes can be read.
        #[unsafe(method(readDataOfLength:fromOffset:toDestination:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readDataOfLength_fromOffset_toDestination_completionHandler(
            &self,
            length: usize,
            offset: i64,
            dest: NonNull<c_void>,
            completion_handler: &block2::DynBlock<dyn Fn(usize, *mut NSError)>,
        );

        #[cfg(feature = "block2")]
        /// Reads bytes from an MEByteSource asynchronously into an NSData object.
        ///
        /// Asynchronously reads out the specified number of bytes starting at the indicated offset. Returns the actual number of bytes read out in bytesRead. Read attempts that extend beyond the end of the MEByteSource will succeed if they include at least one valid byte before the end of the MEByteSource.
        ///
        /// Parameter `length`: The number of bytes to read.
        ///
        /// Parameter `offset`: The relative offset in bytes from the beginning of the file from which to start reading.
        ///
        /// Parameter `completionHandler`: Completion block called when the method completes.
        /// 'data'
        /// The NSData object holding the data that have been read. The NSData length property will indicate the actual number of bytes read.
        /// 'error'
        /// An NSError object that will contain error information if the method fails, otherwise nil. Returns MEErrorEndOfStream if no more bytes can be read.
        #[unsafe(method(readDataOfLength:fromOffset:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn readDataOfLength_fromOffset_completionHandler(
            &self,
            length: usize,
            offset: i64,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        /// Reads bytes from an MEByteSource synchronously into a buffer.
        ///
        /// Synchronously reads out the specified number of bytes starting at the indicated offset. Returns the actual number of bytes read out in bytesReadOut. Read attempts that extend beyond the end of the MEByteSource will succeed if they include at least one valid byte before the end of the MEByteSource.
        ///
        /// Parameter `length`: The number of bytes to read.
        ///
        /// Parameter `offset`: The relative offset in bytes from the beginning of the file from which to start reading.
        ///
        /// Parameter `dest`: The block of memory to hold the data to be read.  Must be at least num bytes in length.
        ///
        /// Parameter `bytesReadOut`: The actual number of bytes read.
        ///
        /// Parameter `error`: Reports any errors. Returns MEErrorEndOfStream if no more bytes can be read.
        ///
        /// Returns: Returns YES if successful, NO if an error occured.
        #[unsafe(method(readDataOfLength:fromOffset:toDestination:bytesRead:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn readDataOfLength_fromOffset_toDestination_bytesRead_error(
            &self,
            length: usize,
            offset: i64,
            dest: NonNull<c_void>,
            bytes_read_out: NonNull<usize>,
        ) -> Result<(), Retained<NSError>>;

        /// Returns the number of available bytes from the offset within the MEByteSource.
        ///
        /// Returns the number of available bytes at the time of the query. This value could change over time. Attempting to read past this value may cause slow I/O.
        ///
        /// Parameter `offset`: The offset in bytes from the beginning of the MEByteSource.
        ///
        /// Returns: Returns the number of available bytes from the offset, or 0 if that information is not available.
        #[unsafe(method(availableLengthAtOffset:))]
        #[unsafe(method_family = none)]
        pub unsafe fn availableLengthAtOffset(&self, offset: i64) -> i64;

        /// Requests creation of a new MEByteSource for a related file.
        ///
        /// Requests creation of a new MEByteSource for a file related to the receiving MEByteSource. The scope of fileName that may be opened is restricted. Only files in the same directory as the receiver MEByteSource may be accessed, and the file extension must match one of the extensions listed in the format reader bundle plist.
        ///
        /// Parameter `fileName`: The relative file name in the receiver MEByteSource's parent directory.
        ///
        /// Parameter `errorOut`: Reports any errors. Returns MEErrorPermissionDenied if the file cannot be accessed or is prohibited.
        ///
        /// Returns: Returns nil if fileName refers to a file that cannot be accessed or is prohibited, or if an error occured. The returned MEByteSource is autoreleased.
        #[unsafe(method(byteSourceForRelatedFileName:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn byteSourceForRelatedFileName_error(
            &self,
            file_name: &NSString,
        ) -> Result<Retained<MEByteSource>, Retained<NSError>>;
    );
}
