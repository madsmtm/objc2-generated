//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Overall status of Exposure Notification on the system.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/enstatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct ENStatus(pub NSInteger);
impl ENStatus {
    /// Status of Exposure Notification is unknown. This is the status before ENManager has activated successfully.
    #[doc(alias = "ENStatusUnknown")]
    pub const Unknown: Self = Self(0);
    /// Exposure Notification is active on the system.
    #[doc(alias = "ENStatusActive")]
    pub const Active: Self = Self(1);
    /// Exposure Notification is disabled. setExposureNotificationEnabled:completionHandler can be used to enable it.
    #[doc(alias = "ENStatusDisabled")]
    pub const Disabled: Self = Self(2);
    /// Bluetooth has been turned off on the system. Bluetooth is required for Exposure Notification.
    /// Note: this may not match the state of Bluetooth as reported by CoreBluetooth.
    /// Exposure Notification is a system service and can use Bluetooth in situations when apps cannot.
    /// So for the purposes of Exposure Notification, it's better to use this API instead of CoreBluetooth.
    #[doc(alias = "ENStatusBluetoothOff")]
    pub const BluetoothOff: Self = Self(3);
    /// Exposure Notification is not active due to system restrictions, such as parental controls.
    /// When in this state, the app cannot enable Exposure Notification.
    #[doc(alias = "ENStatusRestricted")]
    pub const Restricted: Self = Self(4);
    /// For future use. Not returned by any APIs yet.
    #[doc(alias = "ENStatusPaused")]
    pub const Paused: Self = Self(5);
    /// Exposure Notification is not available due to insufficient authorization.
    #[doc(alias = "ENStatusUnauthorized")]
    pub const Unauthorized: Self = Self(6);
}

unsafe impl Encode for ENStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for ENStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Activities that occurred while the app might not be running.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/enactivityflags?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct ENActivityFlags(pub u32);
bitflags::bitflags! {
    impl ENActivityFlags: u32 {
/// Reserved field
        #[doc(alias = "ENActivityFlagsReserved1")]
        const Reserved1 = 1<<0;
/// Reserved field
        #[doc(alias = "ENActivityFlagsReserved2")]
        const Reserved2 = 1<<1;
/// The app launched in the background to perform periodic operations on iOS 12.5.
        #[doc(alias = "ENActivityFlagsPeriodicRun")]
        const PeriodicRun = 1<<2;
/// The app launched in the foreground to display information about the pre-authorized key release
        #[doc(alias = "ENActivityFlagsPreAuthorizedKeyReleaseNotificationTapped")]
        const PreAuthorizedKeyReleaseNotificationTapped = 1<<3;
    }
}

unsafe impl Encode for ENActivityFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

unsafe impl RefEncode for ENActivityFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Invoked after the app is launched to report activities that occurred while the app might not be running.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/enactivityhandler?language=objc)
#[cfg(feature = "block2")]
pub type ENActivityHandler = *mut block2::DynBlock<dyn Fn(ENActivityFlags)>;

/// Invoked when getDiagnosisKeysWithCompletionHandler completes.
/// If it completes successfully, keys will contain the Diagnosis Keys for this device and error will be nil.
/// If it fails, keys will be nil and error indicates the reason it failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/engetdiagnosiskeyshandler?language=objc)
#[cfg(all(feature = "ENCommon", feature = "block2"))]
pub type ENGetDiagnosisKeysHandler =
    *mut block2::DynBlock<dyn Fn(*mut NSArray<ENTemporaryExposureKey>, *mut NSError)>;

/// Invoked when detecting exposures completes. It provides a summary of exposures.
/// If it completes successfully, summary will contain a summary of exposures and error will be nil.
/// If it fails, summary will be nil and error indicates the reason it failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/endetectexposureshandler?language=objc)
#[cfg(all(feature = "ENCommon", feature = "block2"))]
pub type ENDetectExposuresHandler =
    *mut block2::DynBlock<dyn Fn(*mut ENExposureDetectionSummary, *mut NSError)>;

/// [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/endiagnosiskeysavailablehandler?language=objc)
#[cfg(all(feature = "ENCommon", feature = "block2"))]
pub type ENDiagnosisKeysAvailableHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<NSArray<ENTemporaryExposureKey>>)>;

/// Invoked when getting exposures completes. It provides info about each exposure.
/// If it completes successfully, exposures will contain info about each exposure and error will be nil.
/// If it fails, exposures will be nil and error indicates the reason it failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/engetexposureinfohandler?language=objc)
#[cfg(all(feature = "ENCommon", feature = "block2"))]
pub type ENGetExposureInfoHandler =
    *mut block2::DynBlock<dyn Fn(*mut NSArray<ENExposureInfo>, *mut NSError)>;

/// Invoked when getExposureWindows completes. It provides info about each exposure window.
/// If it completes successfully, exposureWindows will non-nil and error will be nil.
/// If it fails, exposureWindows will be nil and error indicates the reason it failed.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/engetexposurewindowshandler?language=objc)
#[cfg(all(feature = "ENCommon", feature = "block2"))]
pub type ENGetExposureWindowsHandler =
    *mut block2::DynBlock<dyn Fn(*mut NSArray<ENExposureWindow>, *mut NSError)>;

/// Invoked when getUserTraveled completes.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/engetusertraveledhandler?language=objc)
#[cfg(feature = "block2")]
pub type ENGetUserTraveledHandler = *mut block2::DynBlock<dyn Fn(Bool, *mut NSError)>;

extern_class!(
    /// Manages Exposure Notification functionality.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/exposurenotification/enmanager?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct ENManager;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for ENManager {}
);

impl ENManager {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// Invoked when the app is launched for an activity while it might not be running.
        /// When the app is launched, it should create an ENManager instance, set this handler, and then activate the manager.
        #[unsafe(method(activityHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn activityHandler(&self) -> ENActivityHandler;

        #[cfg(feature = "block2")]
        /// Setter for [`activityHandler`][Self::activityHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setActivityHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setActivityHandler(&self, activity_handler: ENActivityHandler);

        #[cfg(feature = "dispatch2")]
        #[unsafe(method(dispatchQueue))]
        #[unsafe(method_family = none)]
        pub unsafe fn dispatchQueue(&self) -> Retained<DispatchQueue>;

        #[cfg(feature = "dispatch2")]
        /// Setter for [`dispatchQueue`][Self::dispatchQueue].
        #[unsafe(method(setDispatchQueue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDispatchQueue(&self, dispatch_queue: &DispatchQueue);

        /// Overall status of Exposure Notification. KVO may be used to monitor for changes.
        #[unsafe(method(exposureNotificationStatus))]
        #[unsafe(method_family = none)]
        pub unsafe fn exposureNotificationStatus(&self) -> ENStatus;

        #[cfg(feature = "dispatch2")]
        /// Invoked exactly once when invalidation completes. This property is cleared before it's invoked to break retain cycles.
        #[unsafe(method(invalidationHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidationHandler(&self) -> dispatch_block_t;

        #[cfg(feature = "dispatch2")]
        /// Setter for [`invalidationHandler`][Self::invalidationHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setInvalidationHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInvalidationHandler(&self, invalidation_handler: dispatch_block_t);

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Activates the object to prepare it for use. Properties may not be usable until the completion handler reports success.
        #[unsafe(method(activateWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn activateWithCompletionHandler(&self, completion_handler: ENErrorHandler);

        /// Stops any outstanding operations and invalidates this object. Once this is called, the object can no longer be used.
        /// To start using ENManager again, a new instance of the class must be created and activated.
        #[unsafe(method(invalidate))]
        #[unsafe(method_family = none)]
        pub unsafe fn invalidate(&self);

        #[cfg(feature = "block2")]
        /// Reports if the user traveled within an exposure period (e.g. 14 days).
        #[unsafe(method(getUserTraveledWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getUserTraveledWithCompletionHandler(
            &self,
            completion_handler: ENGetUserTraveledHandler,
        );

        #[cfg(feature = "ENCommon")]
        /// Reports the current authorization status of the app.
        /// Apps can use this property to preflight authorization in order to determine if the user will be prompted.
        #[unsafe(method(authorizationStatus))]
        #[unsafe(method_family = none)]
        pub unsafe fn authorizationStatus() -> ENAuthorizationStatus;

        /// Indicates if Exposure Notification is enabled on the system. KVO may be used to monitor for changes.
        /// This will be NO until activateWithCompletionHandler has completed successfully.
        /// Note that even if it's enabled, it may be inactive for other reasons, such as Bluetooth being turned off.
        /// The exposureNotificationStatus property can be monitored for the overall status of Exposure Notification.
        #[unsafe(method(exposureNotificationEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn exposureNotificationEnabled(&self) -> bool;

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Enables or disables Exposure Notification.
        /// If not previously authorized, this shows a user dialog for consent to enable Exposure Notification.
        /// Note: Disabling stops Bluetooth advertising and scanning related to Exposure Notification, but the
        /// Diagnosis Keys and data will remain.
        #[unsafe(method(setExposureNotificationEnabled:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setExposureNotificationEnabled_completionHandler(
            &self,
            enabled: bool,
            completion_handler: ENErrorHandler,
        );

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Detects exposures using the specified configuration to control the scoring algorithm.
        /// This uses the diagnosis keys already known to the system.
        /// Only available to apps with ENAPIVersion 2 or higher.
        #[unsafe(method(detectExposuresWithConfiguration:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn detectExposuresWithConfiguration_completionHandler(
            &self,
            configuration: &ENExposureConfiguration,
            completion_handler: ENDetectExposuresHandler,
        ) -> Retained<NSProgress>;

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Detects exposures using the specified configuration to control the scoring algorithm and URLs to specify the
        /// files containing diagnosis keys the app has downloaded. The diagnosis key files must be signed appropriately.
        /// When the app's ENAPIVersion is 2 or higher, keys already known to the system are included in the analysis.
        #[unsafe(method(detectExposuresWithConfiguration:diagnosisKeyURLs:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn detectExposuresWithConfiguration_diagnosisKeyURLs_completionHandler(
            &self,
            configuration: &ENExposureConfiguration,
            diagnosis_key_ur_ls: &NSArray<NSURL>,
            completion_handler: ENDetectExposuresHandler,
        ) -> Retained<NSProgress>;

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Gets info about each exposure from the summary provided when exposure detection completes.
        /// Using this API will inform the user that their exposure details have been revealed to the app.
        /// The user explanation string will be displayed as part of the UI to inform the user of using this API.
        #[deprecated = "Use getExposureWindowsFromSummary, if needed."]
        #[unsafe(method(getExposureInfoFromSummary:userExplanation:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getExposureInfoFromSummary_userExplanation_completionHandler(
            &self,
            summary: &ENExposureDetectionSummary,
            user_explanation: &NSString,
            completion_handler: ENGetExposureInfoHandler,
        ) -> Retained<NSProgress>;

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Gets info about each exposure window from the summary provided when exposure detection completes.
        #[unsafe(method(getExposureWindowsFromSummary:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getExposureWindowsFromSummary_completionHandler(
            &self,
            summary: &ENExposureDetectionSummary,
            completion_handler: ENGetExposureWindowsHandler,
        ) -> Retained<NSProgress>;

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Requests the temporary exposure keys used by this device to share with a server.
        /// Each use of this API will present the user with system UI to authorize it.
        #[unsafe(method(getDiagnosisKeysWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getDiagnosisKeysWithCompletionHandler(
            &self,
            completion_handler: ENGetDiagnosisKeysHandler,
        );

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Requests the temporary exposure keys, including the current key, used by this device for testing.
        /// Each use of this API will present the user with system UI to authorize it.
        /// WARNING: This API is only for use by developers. It requires a special entitlement that is not allowed in the app store.
        /// It's only intended to allow developers to test without needing to wait 24 hours for a key to be released.
        #[unsafe(method(getTestDiagnosisKeysWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getTestDiagnosisKeysWithCompletionHandler(
            &self,
            completion_handler: ENGetDiagnosisKeysHandler,
        );

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Invoked after requestPreAuthorizedDiagnosisKeys if user authorization is still valid.
        #[unsafe(method(diagnosisKeysAvailableHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn diagnosisKeysAvailableHandler(&self) -> ENDiagnosisKeysAvailableHandler;

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Setter for [`diagnosisKeysAvailableHandler`][Self::diagnosisKeysAvailableHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDiagnosisKeysAvailableHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDiagnosisKeysAvailableHandler(
            &self,
            diagnosis_keys_available_handler: ENDiagnosisKeysAvailableHandler,
        );

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Authorizes a one-time, future release of diagnosis keys without a user prompt at the time of release.
        /// This allows the user to authorize ahead of time in case they are unable to approve at the time of positive diagnosis.
        /// WARNING: Application should be in foreground to request the authorization
        #[unsafe(method(preAuthorizeDiagnosisKeysWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn preAuthorizeDiagnosisKeysWithCompletionHandler(
            &self,
            completion_handler: ENErrorHandler,
        );

        #[cfg(all(feature = "ENCommon", feature = "block2"))]
        /// Requests diagnosis keys after previously using preAuthorizeDiagnosisKeys successfully.
        /// This will display a notification to the user for the user to know the keys will be returned.
        /// Keys are returned by invoking diagnosisKeysAvailable, which must be set before calling this.
        #[unsafe(method(requestPreAuthorizedDiagnosisKeysWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestPreAuthorizedDiagnosisKeysWithCompletionHandler(
            &self,
            completion_handler: ENErrorHandler,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl ENManager {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
