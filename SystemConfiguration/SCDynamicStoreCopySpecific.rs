//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "SCDynamicStore")]
impl SCDynamicStore {
    /// Returns the current computer name.
    ///
    /// Parameters:
    /// - store: The dynamic store session that should be used for communication with the server. Pass `NULL` to use a temporary session.
    ///
    /// - nameEncoding: A pointer to memory that, on output, is filled with the encoding associated with the computer or host name, if it is non-`NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// The current computer name, or `NULL` if the name has not been set or if an error occurred. You must release the return value.
    ///
    ///
    /// Gets the current computer name.
    ///
    /// Parameter `store`: An SCDynamicStoreRef representing the dynamic store
    /// session that should be used for communication with the server.
    /// If NULL, a temporary session will be used.
    ///
    /// Parameter `nameEncoding`: A pointer to memory that, if non-NULL, will be
    /// filled with the encoding associated with the computer or
    /// host name.
    ///
    /// Returns: Returns the current computer name;
    /// NULL if the name has not been set or if an error was encountered.
    /// You must release the returned value.
    ///
    /// # Safety
    ///
    /// `name_encoding` must be a valid pointer or null.
    #[doc(alias = "SCDynamicStoreCopyComputerName")]
    #[cfg(feature = "SCDynamicStore")]
    #[inline]
    pub unsafe fn computer_name(
        store: Option<&SCDynamicStore>,
        name_encoding: *mut CFStringEncoding,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn SCDynamicStoreCopyComputerName(
                store: Option<&SCDynamicStore>,
                name_encoding: *mut CFStringEncoding,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreCopyComputerName(store, name_encoding) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns information about the user currently logged into the system.
    ///
    /// Parameters:
    /// - store: The dynamic store session that should be used for communication with the server. Pass `NULL` to use a temporary session.
    ///
    /// - uid: A pointer to memory that, on output, is filled with the user ID of the currently logged-in user. If `NULL`, this value is not returned.
    ///
    /// - gid: A pointer to memory that, on output, is filled with the group ID of the currently logged-in user. If `NULL`, this value is not returned.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the name, user ID, and group ID of the user currently logged into the system, or `NULL` if no user is logged in or if an error occurred. You must release the returned values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Note that this function only provides information about the primary console. It does not provide any details about console sessions that have fast user switched out or about other consoles.
    ///
    ///
    /// Gets the name, user ID, and group ID of the currently
    /// logged-in user.
    ///
    /// Note: this function only provides information about the
    /// primary console.  It does not provide any details
    /// about console sessions that have fast user switched
    /// out or about other consoles.
    ///
    /// Parameter `store`: An SCDynamicStoreRef representing the dynamic store
    /// session that should be used for communication with the server.
    /// If NULL, a temporary session will be used.
    ///
    /// Parameter `uid`: A pointer to memory that will be filled with the user ID
    /// of the current console user. If NULL, this value will not
    /// be returned.
    ///
    /// Parameter `gid`: A pointer to memory that will be filled with the group ID
    /// of the current console user. If NULL, this value will not be
    /// returned.
    ///
    /// Returns: Returns the user currently logged into the system;
    /// NULL if no user is logged in or if an error was encountered.
    /// You must release the returned value.
    ///
    /// # Safety
    ///
    /// - `uid` must be a valid pointer or null.
    /// - `gid` must be a valid pointer or null.
    #[doc(alias = "SCDynamicStoreCopyConsoleUser")]
    #[cfg(all(feature = "SCDynamicStore", feature = "libc"))]
    #[inline]
    pub unsafe fn console_user(
        store: Option<&SCDynamicStore>,
        uid: *mut libc::uid_t,
        gid: *mut libc::gid_t,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn SCDynamicStoreCopyConsoleUser(
                store: Option<&SCDynamicStore>,
                uid: *mut libc::uid_t,
                gid: *mut libc::gid_t,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreCopyConsoleUser(store, uid, gid) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the current local host name.
    ///
    /// Parameters:
    /// - store: The dynamic store session that should be used for communication with the server. Pass `NULL` to use a temporary session.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the current local host name, or `NULL` if the name has not been set or if an error occurred. You must release the return value.
    ///
    ///
    /// Gets the current local host name.
    ///
    /// Parameter `store`: An SCDynamicStoreRef representing the dynamic store
    /// session that should be used for communication with the server.
    /// If NULL, a temporary session will be used.
    ///
    /// Returns: Returns the current local host name;
    /// NULL if the name has not been set or if an error was encountered.
    /// You must release the returned value.
    #[doc(alias = "SCDynamicStoreCopyLocalHostName")]
    #[cfg(feature = "SCDynamicStore")]
    #[inline]
    pub fn local_host_name(store: Option<&SCDynamicStore>) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn SCDynamicStoreCopyLocalHostName(
                store: Option<&SCDynamicStore>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreCopyLocalHostName(store) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the current location identifier.
    ///
    /// Parameters:
    /// - store: The dynamic store session that should be used for communication with the server. Pass `NULL` to use a temporary session.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the current location identifier, or `NULL` if no location identifier has been defined or if an error occurred. You must release the returned value.
    ///
    ///
    /// Gets the current location identifier.
    ///
    /// Parameter `store`: An SCDynamicStoreRef representing the dynamic store
    /// session that should be used for communication with the server.
    /// If NULL, a temporary session will be used.
    ///
    /// Returns: Returns a string representing the current location identifier;
    /// NULL if no location identifier has been defined or if an error
    /// was encountered.
    /// You must release the returned value.
    #[doc(alias = "SCDynamicStoreCopyLocation")]
    #[cfg(feature = "SCDynamicStore")]
    #[inline]
    pub fn location(store: Option<&SCDynamicStore>) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn SCDynamicStoreCopyLocation(
                store: Option<&SCDynamicStore>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreCopyLocation(store) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the key-value pairs that represent the current internet proxy settings.
    ///
    /// Parameters:
    /// - store: The dynamic store session that should be used for communication with the server. Pass `NULL` to use a temporary session.
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary of key-value pairs that represent the current internet proxy settings, or `NULL` if no proxy settings have been defined or if an error occurred. You must release the returned value.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The returned proxy settings dictionary can include the following key-value pairs:
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Type" }] }], [Paragraph { inline_content: [Text { text: "Description" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesExceptionsList" }] }], [Paragraph { inline_content: [Text { text: "A " }, CodeVoice { code: "CFArray" }, Text { text: " of " }, CodeVoice { code: "CFString" }, Text { text: " objects" }] }], [Paragraph { inline_content: [Text { text: "Host name patterns that should bypass the proxy" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesHTTPEnable" }] }], [Paragraph { inline_content: [Text { text: "A " }, CodeVoice { code: "CFNumber" }, Text { text: " with the value " }, CodeVoice { code: "0" }, Text { text: " or " }, CodeVoice { code: "1" }] }], [Paragraph { inline_content: [Text { text: "Enables or disables the use of an HTTP proxy" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesHTTPProxy" }] }], [Paragraph { inline_content: [CodeVoice { code: "CFString" }] }], [Paragraph { inline_content: [Text { text: "The proxy host" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesHTTPPort" }] }], [Paragraph { inline_content: [CodeVoice { code: "CFNumber" }] }], [Paragraph { inline_content: [Text { text: "The proxy port number" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesHTTPSEnable" }] }], [Paragraph { inline_content: [Text { text: "A " }, CodeVoice { code: "CFNumber" }, Text { text: " with the value " }, CodeVoice { code: "0" }, Text { text: " or " }, CodeVoice { code: "1" }] }], [Paragraph { inline_content: [Text { text: "Enables or disables the use of an HTTPS proxy" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesHTTPSProxy" }] }], [Paragraph { inline_content: [CodeVoice { code: "CFString" }] }], [Paragraph { inline_content: [Text { text: "The proxy host" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesHTTPSPort" }] }], [Paragraph { inline_content: [CodeVoice { code: "CFNumber" }] }], [Paragraph { inline_content: [Text { text: "The proxy port number" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesFTPEnable" }] }], [Paragraph { inline_content: [Text { text: "A " }, CodeVoice { code: "CFNumber" }, Text { text: " with the value " }, CodeVoice { code: "0" }, Text { text: " or " }, CodeVoice { code: "1" }] }], [Paragraph { inline_content: [Text { text: "Enables or disables the use of an FTP proxy" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesFTPProxy" }] }], [Paragraph { inline_content: [CodeVoice { code: "CFString" }] }], [Paragraph { inline_content: [Text { text: "The proxy host" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesFTPPort" }] }], [Paragraph { inline_content: [CodeVoice { code: "CFNumber" }] }], [Paragraph { inline_content: [Text { text: "The proxy port number" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "kSCPropNetProxiesFTPPassive" }] }], [Paragraph { inline_content: [Text { text: "A " }, CodeVoice { code: "CFNumber" }, Text { text: " with the value " }, CodeVoice { code: "0" }, Text { text: " or " }, CodeVoice { code: "1" }] }], [Paragraph { inline_content: [Text { text: "Enables or disables passive mode operation for use behind connection filtering firewalls" }] }]]], alignments: None, metadata: None })
    ///
    /// Gets the current internet proxy settings.
    /// The returned proxy settings dictionary includes:
    ///
    /// <TABLE
    /// BORDER>
    /// <TR
    /// >
    /// <TH
    /// >key
    /// </TD
    /// >
    /// <TH
    /// >type
    /// </TD
    /// >
    /// <TH
    /// >description
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesExceptionsList
    /// </TD
    /// >
    /// <TD
    /// >CFArray[CFString]
    /// </TD
    /// >
    /// <TD
    /// >Host name patterns which should bypass the proxy
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesHTTPEnable
    /// </TD
    /// >
    /// <TD
    /// >CFNumber (0 or 1)
    /// </TD
    /// >
    /// <TD
    /// >Enables/disables the use of an HTTP proxy
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesHTTPProxy
    /// </TD
    /// >
    /// <TD
    /// >CFString
    /// </TD
    /// >
    /// <TD
    /// >The proxy host
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesHTTPPort
    /// </TD
    /// >
    /// <TD
    /// >CFNumber
    /// </TD
    /// >
    /// <TD
    /// >The proxy port number
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesHTTPSEnable
    /// </TD
    /// >
    /// <TD
    /// >CFNumber (0 or 1)
    /// </TD
    /// >
    /// <TD
    /// >Enables/disables the use of an HTTPS proxy
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesHTTPSProxy
    /// </TD
    /// >
    /// <TD
    /// >CFString
    /// </TD
    /// >
    /// <TD
    /// >The proxy host
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesHTTPSPort
    /// </TD
    /// >
    /// <TD
    /// >CFNumber
    /// </TD
    /// >
    /// <TD
    /// >The proxy port number
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesFTPEnable
    /// </TD
    /// >
    /// <TD
    /// >CFNumber (0 or 1)
    /// </TD
    /// >
    /// <TD
    /// >Enables/disables the use of an FTP proxy
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesFTPProxy
    /// </TD
    /// >
    /// <TD
    /// >CFString
    /// </TD
    /// >
    /// <TD
    /// >The proxy host
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesFTPPort
    /// </TD
    /// >
    /// <TD
    /// >CFNumber
    /// </TD
    /// >
    /// <TD
    /// >The proxy port number
    /// </TD
    /// >
    /// </TR
    /// >
    /// <TR
    /// >
    /// <TD
    /// >kSCPropNetProxiesFTPPassive
    /// </TD
    /// >
    /// <TD
    /// >CFNumber (0 or 1)
    /// </TD
    /// >
    /// <TD
    /// >Enable passive mode operation for use behind connection
    /// filter-ing firewalls.
    /// </TD
    /// >
    /// </TR
    /// >
    /// </TABLE
    /// >
    ///
    /// Other key-value pairs are defined in the SCSchemaDefinitions.h
    /// header file.
    ///
    /// Parameter `store`: An SCDynamicStoreRef representing the dynamic store
    /// session that should be used for communication with the server.
    /// If NULL, a temporary session will be used.
    ///
    /// Returns: Returns a dictionary containing key-value pairs that represent
    /// the current internet proxy settings;
    /// NULL if no proxy settings have been defined or if an error
    /// was encountered.
    /// You must release the returned value.
    #[doc(alias = "SCDynamicStoreCopyProxies")]
    #[cfg(feature = "SCDynamicStore")]
    #[inline]
    pub fn proxies(store: Option<&SCDynamicStore>) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn SCDynamicStoreCopyProxies(
                store: Option<&SCDynamicStore>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { SCDynamicStoreCopyProxies(store) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

#[cfg(feature = "SCDynamicStore")]
#[deprecated = "renamed to `SCDynamicStore::computer_name`"]
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreCopyComputerName(
    store: Option<&SCDynamicStore>,
    name_encoding: *mut CFStringEncoding,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn SCDynamicStoreCopyComputerName(
            store: Option<&SCDynamicStore>,
            name_encoding: *mut CFStringEncoding,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreCopyComputerName(store, name_encoding) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "SCDynamicStore", feature = "libc"))]
#[deprecated = "renamed to `SCDynamicStore::console_user`"]
#[inline]
pub unsafe extern "C-unwind" fn SCDynamicStoreCopyConsoleUser(
    store: Option<&SCDynamicStore>,
    uid: *mut libc::uid_t,
    gid: *mut libc::gid_t,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn SCDynamicStoreCopyConsoleUser(
            store: Option<&SCDynamicStore>,
            uid: *mut libc::uid_t,
            gid: *mut libc::gid_t,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreCopyConsoleUser(store, uid, gid) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SCDynamicStore")]
#[deprecated = "renamed to `SCDynamicStore::local_host_name`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreCopyLocalHostName(
    store: Option<&SCDynamicStore>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn SCDynamicStoreCopyLocalHostName(
            store: Option<&SCDynamicStore>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreCopyLocalHostName(store) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SCDynamicStore")]
#[deprecated = "renamed to `SCDynamicStore::location`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreCopyLocation(
    store: Option<&SCDynamicStore>,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn SCDynamicStoreCopyLocation(store: Option<&SCDynamicStore>) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreCopyLocation(store) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "SCDynamicStore")]
#[deprecated = "renamed to `SCDynamicStore::proxies`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreCopyProxies(
    store: Option<&SCDynamicStore>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn SCDynamicStoreCopyProxies(
            store: Option<&SCDynamicStore>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { SCDynamicStoreCopyProxies(store) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
