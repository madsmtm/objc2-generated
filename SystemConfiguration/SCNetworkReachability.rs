//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// This is the handle to a network address or name.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/systemconfiguration/scnetworkreachability?language=objc)
#[repr(C)]
pub struct SCNetworkReachability {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    #[encoding_name = "__SCNetworkReachability"]
    unsafe impl SCNetworkReachability {}
);

/// Structure containing user-specified data and callbacks for SCNetworkReachability.
/// Field: version The version number of the structure type being passed
/// in as a parameter to the SCDynamicStore creation function.
/// This structure is version 0.
/// Field: info A C pointer to a user-specified block of data.
/// Field: retain The callback used to add a retain for the info field.
/// If this parameter is not a pointer to a function of the correct
/// prototype, the behavior is undefined.  The value may be NULL.
/// Field: release The calllback used to remove a retain previously added
/// for the info field.  If this parameter is not a pointer to a
/// function of the correct prototype, the behavior is undefined.
/// The value may be NULL.
/// Field: copyDescription The callback used to provide a description of
/// the info field.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/systemconfiguration/scnetworkreachabilitycontext?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct SCNetworkReachabilityContext {
    pub version: CFIndex,
    pub info: *mut c_void,
    pub retain: Option<unsafe extern "C-unwind" fn(NonNull<c_void>) -> NonNull<c_void>>,
    pub release: Option<unsafe extern "C-unwind" fn(NonNull<c_void>)>,
    pub copyDescription: Option<unsafe extern "C-unwind" fn(NonNull<c_void>) -> NonNull<CFString>>,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SCNetworkReachabilityContext {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CFIndex>::ENCODING,
            <*mut c_void>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(NonNull<c_void>) -> NonNull<c_void>>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(NonNull<c_void>)>>::ENCODING,
            <Option<unsafe extern "C-unwind" fn(NonNull<c_void>) -> NonNull<CFString>>>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SCNetworkReachabilityContext {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags that indicate whether the specified network
/// nodename or address is reachable, whether a connection is
/// required, and whether some user intervention may be required
/// when establishing a connection.
///
/// This flag indicates that the specified nodename or address can
/// be reached via a transient connection, such as PPP.
///
/// This flag indicates that the specified nodename or address can
/// be reached using the current network configuration.
///
/// This flag indicates that the specified nodename or address can
/// be reached using the current network configuration, but a
/// connection must first be established.
///
/// As an example, this status would be returned for a dialup
/// connection that was not currently active, but could handle
/// network traffic for the target system.
///
/// This flag indicates that the specified nodename or address can
/// be reached using the current network configuration, but a
/// connection must first be established.  Any traffic directed
/// to the specified name or address will initiate the connection.
///
/// Note: this flag was previously named kSCNetworkReachabilityFlagsConnectionAutomatic
///
/// This flag indicates that the specified nodename or address can
/// be reached using the current network configuration, but a
/// connection must first be established.  In addition, some
/// form of user intervention will be required to establish this
/// connection, such as providing a password, an authentication
/// token, etc.
///
/// Note: At the present time, this flag will only be returned
/// in the case where you have a dial-on-traffic configuration
/// (ConnectionOnTraffic), where an attempt to connect has
/// already been made, and where some error (e.g. no dial tone,
/// no answer, bad password, ...) was encountered during the
/// automatic connection attempt.  In this case the PPP controller
/// will stop attempting to establish a connection until the user
/// has intervened.
///
/// This flag indicates that the specified nodename or address can
/// be reached using the current network configuration, but a
/// connection must first be established.
/// The connection will be established "On Demand" by the
/// CFSocketStream APIs.
/// Other APIs will not establish the connection.
///
/// This flag indicates that the specified nodename or address
/// is one associated with a network interface on the current
/// system.
///
/// This flag indicates that network traffic to the specified
/// nodename or address will not go through a gateway, but is
/// routed directly to one of the interfaces in the system.
///
/// This flag indicates that the specified nodename or address can
/// be reached via an EDGE, GPRS, or other "cell" connection.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/systemconfiguration/scnetworkreachabilityflags?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SCNetworkReachabilityFlags(pub u32);
bitflags::bitflags! {
    impl SCNetworkReachabilityFlags: u32 {
        #[doc(alias = "kSCNetworkReachabilityFlagsTransientConnection")]
        const TransientConnection = 1<<0;
        #[doc(alias = "kSCNetworkReachabilityFlagsReachable")]
        const Reachable = 1<<1;
        #[doc(alias = "kSCNetworkReachabilityFlagsConnectionRequired")]
        const ConnectionRequired = 1<<2;
        #[doc(alias = "kSCNetworkReachabilityFlagsConnectionOnTraffic")]
        const ConnectionOnTraffic = 1<<3;
        #[doc(alias = "kSCNetworkReachabilityFlagsInterventionRequired")]
        const InterventionRequired = 1<<4;
        #[doc(alias = "kSCNetworkReachabilityFlagsConnectionOnDemand")]
        const ConnectionOnDemand = 1<<5;
        #[doc(alias = "kSCNetworkReachabilityFlagsIsLocalAddress")]
        const IsLocalAddress = 1<<16;
        #[doc(alias = "kSCNetworkReachabilityFlagsIsDirect")]
        const IsDirect = 1<<17;
        #[doc(alias = "kSCNetworkReachabilityFlagsIsWWAN")]
        const IsWWAN = 1<<18;
        #[doc(alias = "kSCNetworkReachabilityFlagsConnectionAutomatic")]
        const ConnectionAutomatic = SCNetworkReachabilityFlags::ConnectionOnTraffic.0;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for SCNetworkReachabilityFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for SCNetworkReachabilityFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Type of the callback function used when the
/// reachability of a network address or name changes.
///
/// Parameter `target`: The SCNetworkReachability reference being monitored
/// for changes.
///
/// Parameter `flags`: The new SCNetworkReachabilityFlags representing the
/// reachability status of the network address/name.
///
/// Parameter `info`: A C pointer to a user-specified block of data.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/systemconfiguration/scnetworkreachabilitycallback?language=objc)
pub type SCNetworkReachabilityCallBack = Option<
    unsafe extern "C-unwind" fn(
        NonNull<SCNetworkReachability>,
        SCNetworkReachabilityFlags,
        *mut c_void,
    ),
>;

/// Creates a reference to the specified network
/// address.  This reference can be used later to monitor the
/// reachability of the target host.
///
/// Parameter `address`: The address of the desired host.
///
/// Returns: Returns a reference to the new immutable SCNetworkReachabilityRef.
///
/// You must release the returned value.
#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn SCNetworkReachabilityCreateWithAddress(
    allocator: Option<&CFAllocator>,
    address: NonNull<libc::sockaddr>,
) -> Option<CFRetained<SCNetworkReachability>> {
    extern "C-unwind" {
        fn SCNetworkReachabilityCreateWithAddress(
            allocator: Option<&CFAllocator>,
            address: NonNull<libc::sockaddr>,
        ) -> *mut SCNetworkReachability;
    }
    let ret = unsafe { SCNetworkReachabilityCreateWithAddress(allocator, address) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Creates a reference to the specified network
/// address.  This reference can be used later to monitor the
/// reachability of the target host.
///
/// Parameter `localAddress`: The local address associated with a network
/// connection.  If NULL, only the remote address is of interest.
///
/// Parameter `remoteAddress`: The remote address associated with a network
/// connection.  If NULL, only the local address is of interest.
///
/// Returns: Returns a reference to the new immutable SCNetworkReachabilityRef.
///
/// You must release the returned value.
#[cfg(feature = "libc")]
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn SCNetworkReachabilityCreateWithAddressPair(
    allocator: Option<&CFAllocator>,
    local_address: *const libc::sockaddr,
    remote_address: *const libc::sockaddr,
) -> Option<CFRetained<SCNetworkReachability>> {
    extern "C-unwind" {
        fn SCNetworkReachabilityCreateWithAddressPair(
            allocator: Option<&CFAllocator>,
            local_address: *const libc::sockaddr,
            remote_address: *const libc::sockaddr,
        ) -> *mut SCNetworkReachability;
    }
    let ret = unsafe {
        SCNetworkReachabilityCreateWithAddressPair(allocator, local_address, remote_address)
    };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Creates a reference to the specified network host or node
/// name.  This reference can be used later to monitor the
/// reachability of the target host.
///
/// Parameter `nodename`: The node name of the desired host.
/// This name would be the same as that passed to the
/// gethostbyname(3) or getaddrinfo(3) functions.
///
/// Returns: Returns a reference to the new immutable SCNetworkReachabilityRef.
///
/// You must release the returned value.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn SCNetworkReachabilityCreateWithName(
    allocator: Option<&CFAllocator>,
    nodename: NonNull<c_char>,
) -> Option<CFRetained<SCNetworkReachability>> {
    extern "C-unwind" {
        fn SCNetworkReachabilityCreateWithName(
            allocator: Option<&CFAllocator>,
            nodename: NonNull<c_char>,
        ) -> *mut SCNetworkReachability;
    }
    let ret = unsafe { SCNetworkReachabilityCreateWithName(allocator, nodename) };
    NonNull::new(ret).map(|ret| unsafe { CFRetained::from_raw(ret) })
}

unsafe impl ConcreteType for SCNetworkReachability {
    /// Returns the type identifier of all SCNetworkReachability
    /// instances.
    #[doc(alias = "SCNetworkReachabilityGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn SCNetworkReachabilityGetTypeID() -> CFTypeID;
        }
        unsafe { SCNetworkReachabilityGetTypeID() }
    }
}

/// Determines if the given target is reachable using the
/// current network configuration.
///
/// Parameter `target`: The network reference associated with the address or name
/// to be checked for reachability.
///
/// Parameter `flags`: A pointer to memory that will be filled with the
/// SCNetworkReachabilityFlags detailing the reachability
/// of the specified target.
///
/// Returns: Returns TRUE if the network connection flags are valid;
/// FALSE if the status could not be determined.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn SCNetworkReachabilityGetFlags(
    target: &SCNetworkReachability,
    flags: NonNull<SCNetworkReachabilityFlags>,
) -> bool {
    extern "C-unwind" {
        fn SCNetworkReachabilityGetFlags(
            target: &SCNetworkReachability,
            flags: NonNull<SCNetworkReachabilityFlags>,
        ) -> Boolean;
    }
    let ret = unsafe { SCNetworkReachabilityGetFlags(target, flags) };
    ret != 0
}

/// Assigns a client to a target, which receives callbacks
/// when the reachability of the target changes.
///
/// Parameter `target`: The network reference associated with the address or
/// name to be checked for reachability.
///
/// Parameter `callout`: The function to be called when the reachability of the
/// target changes.  If NULL, the current client for the target
/// is removed.
///
/// Parameter `context`: The SCNetworkReachabilityContext associated with
/// the callout.  The value may be NULL.
///
/// Returns: Returns TRUE if the notification client was successfully set.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn SCNetworkReachabilitySetCallback(
    target: &SCNetworkReachability,
    callout: SCNetworkReachabilityCallBack,
    context: *mut SCNetworkReachabilityContext,
) -> bool {
    extern "C-unwind" {
        fn SCNetworkReachabilitySetCallback(
            target: &SCNetworkReachability,
            callout: SCNetworkReachabilityCallBack,
            context: *mut SCNetworkReachabilityContext,
        ) -> Boolean;
    }
    let ret = unsafe { SCNetworkReachabilitySetCallback(target, callout, context) };
    ret != 0
}

/// Schedules the given target with the given run loop and mode.
///
/// Parameter `target`: The address or name that is set up for asynchronous
/// notifications.  Must be non-NULL.
///
/// Parameter `runLoop`: A reference to a run loop on which the target should
/// be scheduled.  Must be non-NULL.
///
/// Parameter `runLoopMode`: The mode on which to schedule the target.
/// Must be non-NULL.
///
/// Returns: Returns TRUE if the target is scheduled successfully;
/// FALSE otherwise.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn SCNetworkReachabilityScheduleWithRunLoop(
    target: &SCNetworkReachability,
    run_loop: &CFRunLoop,
    run_loop_mode: &CFString,
) -> bool {
    extern "C-unwind" {
        fn SCNetworkReachabilityScheduleWithRunLoop(
            target: &SCNetworkReachability,
            run_loop: &CFRunLoop,
            run_loop_mode: &CFString,
        ) -> Boolean;
    }
    let ret = unsafe { SCNetworkReachabilityScheduleWithRunLoop(target, run_loop, run_loop_mode) };
    ret != 0
}

/// Unschedules the given target from the given run loop
/// and mode.
///
/// Parameter `target`: The address or name that is set up for asynchronous
/// notifications.  Must be non-NULL.
///
/// Parameter `runLoop`: A reference to a run loop from which the target
/// should be unscheduled.  Must be non-NULL.
///
/// Parameter `runLoopMode`: The mode on which to unschedule the target.
/// Must be non-NULL.
///
/// Returns: Returns TRUE if the target is unscheduled successfully;
/// FALSE otherwise.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn SCNetworkReachabilityUnscheduleFromRunLoop(
    target: &SCNetworkReachability,
    run_loop: &CFRunLoop,
    run_loop_mode: &CFString,
) -> bool {
    extern "C-unwind" {
        fn SCNetworkReachabilityUnscheduleFromRunLoop(
            target: &SCNetworkReachability,
            run_loop: &CFRunLoop,
            run_loop_mode: &CFString,
        ) -> Boolean;
    }
    let ret =
        unsafe { SCNetworkReachabilityUnscheduleFromRunLoop(target, run_loop, run_loop_mode) };
    ret != 0
}
