//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

#[cfg(feature = "SCDynamicStore")]
impl SCDynamicStore {
    /// Creates a dynamic store key that can be used to access a specific global (as opposed to a per-service or per-interface) network configuration entity.
    ///
    /// Parameters:
    /// - allocator: The allocator that should be used to allocate memory for this key. This parameter may be `NULL` in which case the current default allocator is used. If this value is not a valid [`CFAllocatorRef`](https://developer.apple.com/documentation/corefoundation/cfallocator), the behavior is undefined.
    ///
    /// - domain: The desired domain, such as the requested configuration or the current state.
    ///
    /// - entity: The specific global entity, such as IPv4 or DNS.
    ///
    ///
    /// ## Return Value
    ///
    /// A string containing the formatted key.
    ///
    ///
    /// Creates a dynamic store key that can be used to access
    /// a specific global (as opposed to a per-service or per-interface)
    /// network configuration entity.
    ///
    /// Parameter `allocator`: The CFAllocator that should be used to allocate
    /// memory for this key.
    /// This parameter may be NULL in which case the current
    /// default CFAllocator is used. If this reference is not
    /// a valid CFAllocator, the behavior is undefined.
    ///
    /// Parameter `domain`: A string specifying the desired domain, such as the
    /// requested configuration (kSCDynamicStoreDomainSetup) or the
    /// actual state (kSCDynamicStoreDomainState).
    ///
    /// Parameter `entity`: A string containing the specific global entity, such
    /// as IPv4 (kSCEntNetIPv4) or DNS (kSCEntNetDNS).
    ///
    /// Returns: Returns a string containing the formatted key.
    #[doc(alias = "SCDynamicStoreKeyCreateNetworkGlobalEntity")]
    #[inline]
    pub fn key_create_network_global_entity(
        allocator: Option<&CFAllocator>,
        domain: &CFString,
        entity: &CFString,
    ) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn SCDynamicStoreKeyCreateNetworkGlobalEntity(
                allocator: Option<&CFAllocator>,
                domain: &CFString,
                entity: &CFString,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreKeyCreateNetworkGlobalEntity(allocator, domain, entity) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a dynamic store key that can be used to access the network interface configuration information in the dynamic store.
    ///
    /// Parameters:
    /// - allocator: The allocator that should be used to allocate memory for this key. This parameter may be `NULL` in which case the current default allocator is used. If this value is not a valid [`CFAllocatorRef`](https://developer.apple.com/documentation/corefoundation/cfallocator), the behavior is undefined.
    ///
    /// - domain: The desired domain, such as the requested configuration or the current state.
    ///
    ///
    /// ## Return Value
    ///
    /// A string containing the formatted key.
    ///
    ///
    /// Creates a dynamic store key that can be used to access
    /// the network interface configuration information stored in
    /// the dynamic store.
    ///
    /// Parameter `allocator`: The CFAllocator that should be used to allocate
    /// memory for this key.
    /// This parameter may be NULL in which case the current
    /// default CFAllocator is used. If this reference is not
    /// a valid CFAllocator, the behavior is undefined.
    ///
    /// Parameter `domain`: A string specifying the desired domain, such as the
    /// requested configuration (kSCDynamicStoreDomainSetup) or the
    /// actual state (kSCDynamicStoreDomainState).
    ///
    /// Returns: Returns a string containing the formatted key.
    #[doc(alias = "SCDynamicStoreKeyCreateNetworkInterface")]
    #[inline]
    pub fn key_create_network_interface(
        allocator: Option<&CFAllocator>,
        domain: &CFString,
    ) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn SCDynamicStoreKeyCreateNetworkInterface(
                allocator: Option<&CFAllocator>,
                domain: &CFString,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreKeyCreateNetworkInterface(allocator, domain) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a dynamic store key that can be used to access the per-interface network configuration information in the dynamic store.
    ///
    /// Parameters:
    /// - allocator: The allocator that should be used to allocate memory for this key. This parameter may be `NULL` in which case the current default allocator is used. If this value is not a valid [`CFAllocatorRef`](https://developer.apple.com/documentation/corefoundation/cfallocator), the behavior is undefined.
    ///
    /// - domain: The desired domain, such as the requested configuration or the current state.
    ///
    /// - ifname: The interface name or a regular expression pattern.
    ///
    /// - entity: The specific global entity, such as IPv4 or DNS.
    ///
    ///
    /// ## Return Value
    ///
    /// A string containing the formatted key.
    ///
    ///
    /// Creates a dynamic store key that can be used to access
    /// the per-interface network configuration information stored in
    /// the dynamic store.
    ///
    /// Parameter `allocator`: The CFAllocator that should be used to allocate
    /// memory for this key.
    /// This parameter may be NULL in which case the current
    /// default CFAllocator is used. If this reference is not
    /// a valid CFAllocator, the behavior is undefined.
    ///
    /// Parameter `domain`: A string specifying the desired domain, such as the
    /// requested configuration (kSCDynamicStoreDomainSetup) or the
    /// actual state (kSCDynamicStoreDomainState).
    ///
    /// Parameter `ifname`: A string containing the interface name or a regular
    /// expression pattern.
    ///
    /// Parameter `entity`: A string containing the specific global entity, such
    /// as IPv4 (kSCEntNetIPv4) or DNS (kSCEntNetDNS).
    ///
    /// Returns: Returns a string containing the formatted key.
    #[doc(alias = "SCDynamicStoreKeyCreateNetworkInterfaceEntity")]
    #[inline]
    pub fn key_create_network_interface_entity(
        allocator: Option<&CFAllocator>,
        domain: &CFString,
        ifname: &CFString,
        entity: Option<&CFString>,
    ) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn SCDynamicStoreKeyCreateNetworkInterfaceEntity(
                allocator: Option<&CFAllocator>,
                domain: &CFString,
                ifname: &CFString,
                entity: Option<&CFString>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe {
            SCDynamicStoreKeyCreateNetworkInterfaceEntity(allocator, domain, ifname, entity)
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a dynamic store key that can be used to access the per-service network configuration information.
    ///
    /// Parameters:
    /// - allocator: The allocator that should be used to allocate memory for this key. This parameter may be `NULL` in which case the current default allocator is used. If this value is not a valid [`CFAllocatorRef`](https://developer.apple.com/documentation/corefoundation/cfallocator), the behavior is undefined.
    ///
    /// - domain: The desired domain, such as the requested configuration or the current state.
    ///
    /// - serviceID: The service ID or a regular expression pattern.
    ///
    /// - entity: The specific global entity, such as IPv4 or DNS.
    ///
    /// Creates a dynamic store key that can be used to access
    /// the per-service network configuration information stored in
    /// the dynamic store.
    ///
    /// Parameter `allocator`: The CFAllocator that should be used to allocate
    /// memory for this key.
    /// This parameter may be NULL in which case the current
    /// default CFAllocator is used. If this reference is not
    /// a valid CFAllocator, the behavior is undefined.
    ///
    /// Parameter `domain`: A string specifying the desired domain, such as the
    /// requested configuration (kSCDynamicStoreDomainSetup) or the
    /// actual state (kSCDynamicStoreDomainState).
    ///
    /// Parameter `serviceID`: A string containing the service ID or a regular
    /// expression pattern.
    ///
    /// Parameter `entity`: A string containing the specific global entity, such
    /// as IPv4 (kSCEntNetIPv4) or DNS (kSCEntNetDNS).
    ///
    /// Returns: Returns a string containing the formatted key.
    #[doc(alias = "SCDynamicStoreKeyCreateNetworkServiceEntity")]
    #[inline]
    pub fn key_create_network_service_entity(
        allocator: Option<&CFAllocator>,
        domain: &CFString,
        service_id: &CFString,
        entity: Option<&CFString>,
    ) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn SCDynamicStoreKeyCreateNetworkServiceEntity(
                allocator: Option<&CFAllocator>,
                domain: &CFString,
                service_id: &CFString,
                entity: Option<&CFString>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe {
            SCDynamicStoreKeyCreateNetworkServiceEntity(allocator, domain, service_id, entity)
        };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a key that can be used to receive notifications when the current computer name changes.
    ///
    /// Parameters:
    /// - allocator: The allocator that should be used to allocate memory for this key. This parameter may be `NULL` in which case the current default allocator is used. If this value is not a valid [`CFAllocatorRef`](https://developer.apple.com/documentation/corefoundation/cfallocator), the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// A notification string for the current computer or host name.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this key with the [`SCDynamicStoreSetNotificationKeys`](https://developer.apple.com/documentation/systemconfiguration/scdynamicstoresetnotificationkeys(_:_:_:)) function.
    ///
    ///
    /// Creates a key that can be used in conjuntion with
    /// SCDynamicStoreSetNotificationKeys function to receive
    /// notifications when the current computer name changes.
    ///
    /// Parameter `allocator`: The CFAllocator that should be used to allocate
    /// memory for this key.
    /// This parameter may be NULL in which case the current
    /// default CFAllocator is used. If this reference is not
    /// a valid CFAllocator, the behavior is undefined.
    ///
    /// Returns: Returns a notification string for the current computer or
    /// host name.
    #[doc(alias = "SCDynamicStoreKeyCreateComputerName")]
    #[inline]
    pub fn key_create_computer_name(allocator: Option<&CFAllocator>) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn SCDynamicStoreKeyCreateComputerName(
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreKeyCreateComputerName(allocator) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a key that can be used to receive notifications when the current console user changes.
    ///
    /// Parameters:
    /// - allocator: The allocator that should be used to allocate memory for this key. This parameter may be `NULL` in which case the current default allocator is used. If this value is not a valid [`CFAllocatorRef`](https://developer.apple.com/documentation/corefoundation/cfallocator), the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// A notification string for the current console user.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this key with the [`SCDynamicStoreSetNotificationKeys`](https://developer.apple.com/documentation/systemconfiguration/scdynamicstoresetnotificationkeys(_:_:_:)) function.
    ///
    ///
    /// Creates a key that can be used in conjunction with
    /// SCDynamicStoreSetNotificationKeys function to receive
    /// notifications when the current console user changes.
    ///
    /// Parameter `allocator`: The CFAllocator that should be used to allocate
    /// memory for this key.
    /// This parameter may be NULL in which case the current
    /// default CFAllocator is used. If this reference is not
    /// a valid CFAllocator, the behavior is undefined.
    ///
    /// Returns: Returns a notification string for the current console user.
    #[doc(alias = "SCDynamicStoreKeyCreateConsoleUser")]
    #[inline]
    pub fn key_create_console_user(allocator: Option<&CFAllocator>) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn SCDynamicStoreKeyCreateConsoleUser(
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreKeyCreateConsoleUser(allocator) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a key that can be used to receive notifications when the `HostNames` entity changes.
    ///
    /// Parameters:
    /// - allocator: The allocator that should be used to allocate memory for this key. This parameter may be `NULL` in which case the current default allocator is used. If this value is not a valid [`CFAllocatorRef`](https://developer.apple.com/documentation/corefoundation/cfallocator), the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// A notification string for the `HostNames` entity.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this key with the [`SCDynamicStoreSetNotificationKeys`](https://developer.apple.com/documentation/systemconfiguration/scdynamicstoresetnotificationkeys(_:_:_:)) function. Note that the `HostNames` entity includes the local host name.
    ///
    ///
    /// Creates a key that can be used in conjunction with the
    /// SCDynamicStoreSetNotificationKeys function to receive
    /// notifications when the HostNames entity changes.  The
    /// HostNames entity includes the local host name.
    ///
    /// Parameter `allocator`: The CFAllocator that should be used to allocate
    /// memory for this key.
    /// This parameter may be NULL in which case the current
    /// default CFAllocator is used. If this reference is not
    /// a valid CFAllocator, the behavior is undefined.
    ///
    /// Returns: Returns a notification string for the HostNames entity.
    #[doc(alias = "SCDynamicStoreKeyCreateHostNames")]
    #[inline]
    pub fn key_create_host_names(allocator: Option<&CFAllocator>) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn SCDynamicStoreKeyCreateHostNames(
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreKeyCreateHostNames(allocator) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a key that can be used to receive notifications when the location identifier changes.
    ///
    /// Parameters:
    /// - allocator: The allocator that should be used to allocate memory for this key. This parameter may be `NULL` in which case the current default allocator is used. If this value is not a valid [`CFAllocatorRef`](https://developer.apple.com/documentation/corefoundation/cfallocator), the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// A notification string for the current location identifier.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this key with the [`SCDynamicStoreSetNotificationKeys`](https://developer.apple.com/documentation/systemconfiguration/scdynamicstoresetnotificationkeys(_:_:_:)) function.
    ///
    ///
    /// Creates a key that can be used in conjunction with the
    /// SCDynamicStoreSetNotificationKeys function to receive
    /// notifications when the location identifier changes.
    ///
    /// Parameter `allocator`: The CFAllocator that should be used to allocate
    /// memory for this key.
    /// This parameter may be NULL in which case the current
    /// default CFAllocator is used. If this reference is not
    /// a valid CFAllocator, the behavior is undefined.
    ///
    /// Returns: Returns a notification string for the current location
    /// identifier.
    #[doc(alias = "SCDynamicStoreKeyCreateLocation")]
    #[inline]
    pub fn key_create_location(allocator: Option<&CFAllocator>) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn SCDynamicStoreKeyCreateLocation(
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreKeyCreateLocation(allocator) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a key that can be used to receive notifications when the current network proxy settings are changed.
    ///
    /// Parameters:
    /// - allocator: The allocator that should be used to allocate memory for this key. This parameter may be `NULL` in which case the current default allocator is used. If this value is not a valid [`CFAllocatorRef`](https://developer.apple.com/documentation/corefoundation/cfallocator), the behavior is undefined.
    ///
    ///
    /// ## Return Value
    ///
    /// A notification string for the current proxy settings.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Use this key with the [`SCDynamicStoreSetNotificationKeys`](https://developer.apple.com/documentation/systemconfiguration/scdynamicstoresetnotificationkeys(_:_:_:)) function.
    ///
    ///
    /// Creates a key that can be used in conjunction with
    /// the SCDynamicStoreSetNotificationKeys function to receive
    /// notifications when the current network proxy settings
    /// (such as HTTP or FTP) are changed.
    ///
    /// Parameter `allocator`: The CFAllocator that should be used to allocate
    /// memory for this key.
    /// This parameter may be NULL in which case the current
    /// default CFAllocator is used. If this reference is not
    /// a valid CFAllocator, the behavior is undefined.
    ///
    /// Returns: Returns a notification string for the current proxy settings.
    #[doc(alias = "SCDynamicStoreKeyCreateProxies")]
    #[inline]
    pub fn key_create_proxies(allocator: Option<&CFAllocator>) -> CFRetained<CFString> {
        extern "C-unwind" {
            fn SCDynamicStoreKeyCreateProxies(
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { SCDynamicStoreKeyCreateProxies(allocator) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }
}

#[deprecated = "renamed to `SCDynamicStore::key_create_network_global_entity`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreKeyCreateNetworkGlobalEntity(
    allocator: Option<&CFAllocator>,
    domain: &CFString,
    entity: &CFString,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateNetworkGlobalEntity(
            allocator: Option<&CFAllocator>,
            domain: &CFString,
            entity: &CFString,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateNetworkGlobalEntity(allocator, domain, entity) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `SCDynamicStore::key_create_network_interface`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreKeyCreateNetworkInterface(
    allocator: Option<&CFAllocator>,
    domain: &CFString,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateNetworkInterface(
            allocator: Option<&CFAllocator>,
            domain: &CFString,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateNetworkInterface(allocator, domain) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `SCDynamicStore::key_create_network_interface_entity`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreKeyCreateNetworkInterfaceEntity(
    allocator: Option<&CFAllocator>,
    domain: &CFString,
    ifname: &CFString,
    entity: Option<&CFString>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateNetworkInterfaceEntity(
            allocator: Option<&CFAllocator>,
            domain: &CFString,
            ifname: &CFString,
            entity: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret =
        unsafe { SCDynamicStoreKeyCreateNetworkInterfaceEntity(allocator, domain, ifname, entity) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `SCDynamicStore::key_create_network_service_entity`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreKeyCreateNetworkServiceEntity(
    allocator: Option<&CFAllocator>,
    domain: &CFString,
    service_id: &CFString,
    entity: Option<&CFString>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateNetworkServiceEntity(
            allocator: Option<&CFAllocator>,
            domain: &CFString,
            service_id: &CFString,
            entity: Option<&CFString>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe {
        SCDynamicStoreKeyCreateNetworkServiceEntity(allocator, domain, service_id, entity)
    };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `SCDynamicStore::key_create_computer_name`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreKeyCreateComputerName(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateComputerName(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateComputerName(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `SCDynamicStore::key_create_console_user`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreKeyCreateConsoleUser(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateConsoleUser(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateConsoleUser(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `SCDynamicStore::key_create_host_names`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreKeyCreateHostNames(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateHostNames(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateHostNames(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `SCDynamicStore::key_create_location`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreKeyCreateLocation(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateLocation(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateLocation(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `SCDynamicStore::key_create_proxies`"]
#[inline]
pub extern "C-unwind" fn SCDynamicStoreKeyCreateProxies(
    allocator: Option<&CFAllocator>,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn SCDynamicStoreKeyCreateProxies(
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { SCDynamicStoreKeyCreateProxies(allocator) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}
