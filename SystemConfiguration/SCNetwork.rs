//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

/// The specified node name or address can be reached via a transient connection, such as PPP.
pub const kSCNetworkFlagsTransientConnection: c_uint = 1 << 0;
/// The specified node name or address can be reached using the current network configuration.
pub const kSCNetworkFlagsReachable: c_uint = 1 << 1;
/// The specified node name or address can be reached using the current network configuration, but a connection must first be established.
///
/// ## Discussion
///
/// For example, this status would be returned for a dialup connection that was not currently active, but could handle network traffic for the target system.
///
///
pub const kSCNetworkFlagsConnectionRequired: c_uint = 1 << 2;
/// The specified node name or address can be reached using the current network configuration, but a connection must first be established.
///
/// ## Discussion
///
/// Any traffic directed to the specified name or address will initiate the connection.
///
///
pub const kSCNetworkFlagsConnectionAutomatic: c_uint = 1 << 3;
/// The specified node name or address can be reached using the current network configuration, but a connection must first be established.
///
/// ## Discussion
///
/// In addition, some form of user intervention will be required to establish this connection, such as providing a password, an authentication token, etc.
///
/// Currently, this flag is returned when there is a dial-on-traffic configuration (`ConnectionAutomatic`), an attempt to connect has already been made, and when some error (for example, no dial tone, no answer, bad password, etc.) was encountered during the automatic connection attempt. In this case the PPP controller stops attempting to establish a connection until the user has intervened.
///
///
pub const kSCNetworkFlagsInterventionRequired: c_uint = 1 << 4;
/// The specified node name or address is one associated with a network interface on the current system.
pub const kSCNetworkFlagsIsLocalAddress: c_uint = 1 << 16;
/// Network traffic to the specified node name or address does not go through a gateway, but is routed directly to one of the interfaces in the system.
pub const kSCNetworkFlagsIsDirect: c_uint = 1 << 17;

/// Flags that indicate whether the specified network node name or address is reachable, whether a connection is required, and whether some user intervention may be required when establishing a connection.
pub type SCNetworkConnectionFlags = u32;

/// Determines whether the specified network address is reachable using the current network configuration.
///
/// Parameters:
/// - address: The network address of the desired host.
///
/// - addrlen: The length, in bytes, of the address.
///
/// - flags: A pointer to memory that, on output, will be filled with a set of [`SCNetworkConnectionFlags`](https://developer.apple.com/documentation/systemconfiguration/scnetworkconnectionflags) values detailing the reachability of the specified address
///
///
/// ## Return Value
///
/// `TRUE` if the network connection flags are valid; `FALSE` if the status could not be determined.
///
///
///
/// ## Discussion
///
/// This function is deprecated, but you can get equivalent results using the following code:
///
/// ```objc
/// SCNetworkReachabilityRef target;
/// SCNetworkConnectionFlags flags = 0;
/// Boolean ok;
/// target = SCNetworkReachabilityCreateWithAddress(NULL, address);
/// ok = SCNetworkReachabilityGetFlags(target, &flags);
/// CFRelease(target);
/// ```
///
///
/// Determines if the given network address is
/// reachable using the current network configuration.
///
/// Note: this API has been deprecated but you can
/// get equivalent results with :
/// <pre>
/// SCNetworkReachabilityRef   target;
/// SCNetworkReachabilityFlags flags = 0;
/// Boolean                   ok;
///
/// target = SCNetworkReachabilityCreateWithAddress(NULL, address);
/// ok = SCNetworkReachabilityGetFlags(target,
/// &flags
/// );
/// CFRelease(target);
/// </pre>
///
/// Parameter `address`: The network address of the desired host.
///
/// Parameter `addrlen`: The length, in bytes, of the address.
///
/// Parameter `flags`: A pointer to memory that will be filled with a
/// set of SCNetworkConnectionFlags detailing the reachability
/// of the specified address.
///
/// Returns: Returns TRUE if the network connection flags are valid;
/// FALSE if the status could not be determined.
///
/// # Safety
///
/// - `address` must be a valid pointer.
/// - `flags` must be a valid pointer.
#[cfg(feature = "libc")]
#[deprecated = "No longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SCNetworkCheckReachabilityByAddress(
    address: NonNull<libc::sockaddr>,
    addrlen: libc::socklen_t,
    flags: NonNull<SCNetworkConnectionFlags>,
) -> bool {
    extern "C-unwind" {
        fn SCNetworkCheckReachabilityByAddress(
            address: NonNull<libc::sockaddr>,
            addrlen: libc::socklen_t,
            flags: NonNull<SCNetworkConnectionFlags>,
        ) -> Boolean;
    }
    let ret = unsafe { SCNetworkCheckReachabilityByAddress(address, addrlen, flags) };
    ret != 0
}

/// Determines whether the specified network host or node name is reachable using the current network configuration.
///
/// Parameters:
/// - nodename: The node name of the desired host. This is the same name that would be passed to the gethostbyname(3) or getaddrinfo(3) functions.
///
/// - flags: A pointer to memory that, on output, will be filled with a set of [`SCNetworkConnectionFlags`](https://developer.apple.com/documentation/systemconfiguration/scnetworkconnectionflags) values detailing the reachability of the specified address
///
///
/// ## Return Value
///
/// `TRUE` if the network connection flags are valid; `FALSE` if the status could not be determined.
///
///
///
/// ## Discussion
///
/// This function is deprecated, but you can get equivalent results using the following code:
///
/// ```objc
/// SCNetworkReachabilityRef target;
/// SCNetworkConnectionFlags flags = 0;
/// Boolean ok;
/// target = SCNetworkReachabilityCreateWithName(NULL, name);
/// ok = SCNetworkReachabilityGetFlags(target, &flags);
/// CFRelease(target);
/// ```
///
///
/// Determines if the given network host or node name is
/// reachable using the current network configuration.
///
/// Note: this API has been deprecated but you can
/// get equivalent results with :
/// <pre>
/// SCNetworkReachabilityRef   target;
/// SCNetworkReachabilityFlags flags = 0;
/// Boolean                   ok;
///
/// target = SCNetworkReachabilityCreateWithName(NULL, name);
/// ok = SCNetworkReachabilityGetFlags(target,
/// &flags
/// );
/// CFRelease(target);
/// </pre>
///
/// Parameter `nodename`: The node name of the desired host. This name would
/// be the same as that passed to the gethostbyname(3) or
/// getaddrinfo(3) functions.
///
/// Parameter `flags`: A pointer to memory that will be filled with a
/// set of SCNetworkConnectionFlags detailing the reachability
/// of the specified node name.
///
/// Returns: Returns TRUE if the network connection flags are valid;
/// FALSE if the status could not be determined.
///
/// # Safety
///
/// - `nodename` must be a valid pointer.
/// - `flags` must be a valid pointer.
#[deprecated = "No longer supported"]
#[inline]
pub unsafe extern "C-unwind" fn SCNetworkCheckReachabilityByName(
    nodename: NonNull<c_char>,
    flags: NonNull<SCNetworkConnectionFlags>,
) -> bool {
    extern "C-unwind" {
        fn SCNetworkCheckReachabilityByName(
            nodename: NonNull<c_char>,
            flags: NonNull<SCNetworkConnectionFlags>,
        ) -> Boolean;
    }
    let ret = unsafe { SCNetworkCheckReachabilityByName(nodename, flags) };
    ret != 0
}

/// Sends a notification to interested configuration agents to have them immediately retry their configuration over a particular network interface.
///
/// Parameters:
/// - ifName: The BSD name of the network interface, such as `CFSTR("en0")`.
///
///
/// ## Return Value
///
/// `TRUE` if the notification was sent; otherwise, `FALSE`.
///
///
///
/// ## Discussion
///
/// This function must be invoked by root (in other words, the user with uid equal to `0`).
///
///
/// Sends a notification to interested configuration agents
/// to have them immediately retry their configuration over a
/// particular network interface.
///
/// Note: This function must be invoked by root (uid == 0).
///
/// Parameter `ifName`: The BSD name of the network interface, such as
/// CFSTR("en0").
///
/// Returns: Returns TRUE if the notification was sent; FALSE otherwise.
#[deprecated = "No longer supported"]
#[inline]
pub extern "C-unwind" fn SCNetworkInterfaceRefreshConfiguration(if_name: &CFString) -> bool {
    extern "C-unwind" {
        fn SCNetworkInterfaceRefreshConfiguration(if_name: &CFString) -> Boolean;
    }
    let ret = unsafe { SCNetworkInterfaceRefreshConfiguration(if_name) };
    ret != 0
}
