//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-uniform-type-identifiers")]
use objc2_uniform_type_identifiers::*;

use crate::*;

/// String values for the manner in which an app interacts with a device.
///
/// ## Discussion
///
/// When an app creates a device discovery extension to stream content to a third-party media receiver, the protocol is Discovery and Launch (DIAL), as designated by the [`DDDeviceProtocolDIAL`](https://developer.apple.com/documentation/devicediscoveryextension/dddevice/protocol-swift.enum/dial) option.
///
///
// NS_TYPED_ENUM
pub type DDDeviceProtocolString = NSString;

extern "C" {
    /// A human-readable string for the default device protocol.
    pub static DDDeviceProtocolStringInvalid: &'static DDDeviceProtocolString;
}

extern "C" {
    /// A human-readable string for the Discovery and Launch protocol.
    pub static DDDeviceProtocolStringDIAL: &'static DDDeviceProtocolString;
}

/// An identifier for the manner in which an app interacts with a device.
///
/// ## Overview
///
/// The device ([`DDDevice`](https://developer.apple.com/documentation/devicediscoveryextension/dddevice)) [`protocol`](https://developer.apple.com/documentation/devicediscoveryextension/dddevice/protocol-swift.property) property is of this type.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct DDDeviceProtocol(pub NSInteger);
impl DDDeviceProtocol {
    /// A default value for a device protocol.
    #[doc(alias = "DDDeviceProtocolInvalid")]
    pub const Invalid: Self = Self(0);
    /// A protocol for client devices that stream media to a TV or set-top box.
    /// Invalid protocol.
    #[doc(alias = "DDDeviceProtocolDIAL")]
    pub const DIAL: Self = Self(1);
}

unsafe impl Encode for DDDeviceProtocol {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceProtocol {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl DDDeviceProtocol {
    /// Returns human-readable text for the specified protocol identifier.
    ///
    /// Parameters:
    /// - inValue: A device-protocol identifier to convert to text.
    ///
    ///
    /// ## Return Value
    ///
    /// A textual value for the specified device protocol.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Your extension can use this function for logging.
    ///
    ///
    /// Converts a device protocol type to a string for logging, etc.
    #[doc(alias = "DDDeviceProtocolToString")]
    #[inline]
    pub unsafe fn to_string(self) -> Retained<NSString> {
        extern "C-unwind" {
            fn DDDeviceProtocolToString(in_value: DDDeviceProtocol) -> *mut NSString;
        }
        let ret = unsafe { DDDeviceProtocolToString(self) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// An option that determines the icon for the device in the picker UI.
///
/// ## Overview
///
/// The device ([`DDDevice`](https://developer.apple.com/documentation/devicediscoveryextension/dddevice)) [`category`](https://developer.apple.com/documentation/devicediscoveryextension/dddevice/category-swift.property) property is of this type.
///
/// Each value in this enumeration determines a different icon that the picker UI ([`AVRoutePickerView`](https://developer.apple.com/documentation/avkit/avroutepickerview)) displays, which helps the user visually confirm that their selection corresponds to the device they intend to stream media to.
///
///
/// Category of the device.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct DDDeviceCategory(pub NSInteger);
impl DDDeviceCategory {
    /// An icon that depicts a high-fidelity speaker.
    #[doc(alias = "DDDeviceCategoryHiFiSpeaker")]
    pub const HiFiSpeaker: Self = Self(0);
    /// An icon that depicts multiple high-fidelity speakers.
    /// Hi-Fi speaker.
    #[doc(alias = "DDDeviceCategoryHiFiSpeakerMultiple")]
    pub const HiFiSpeakerMultiple: Self = Self(1);
    /// An icon that depicts a TV with a set-top box.
    /// Multiple Hi-Fi speakers.
    #[doc(alias = "DDDeviceCategoryTVWithMediaBox")]
    pub const TVWithMediaBox: Self = Self(2);
    /// An icon that depicts a television.
    /// TV with MediaBox.
    #[doc(alias = "DDDeviceCategoryTV")]
    pub const TV: Self = Self(3);
    /// An icon that depicts a laptop computer.
    /// TV.
    #[doc(alias = "DDDeviceCategoryLaptopComputer")]
    pub const LaptopComputer: Self = Self(4);
    /// An icon that depicts a desktop computer.
    /// Laptop computer.
    #[doc(alias = "DDDeviceCategoryDesktopComputer")]
    pub const DesktopComputer: Self = Self(5);
    /// Desktop computer.
    #[doc(alias = "DDDeviceCategoryAccessorySetup")]
    pub const AccessorySetup: Self = Self(6);
}

unsafe impl Encode for DDDeviceCategory {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceCategory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl DDDeviceCategory {
    /// Returns human-readable text for the specified identifier that describes a device’s category.
    ///
    /// Parameters:
    /// - inValue: A category identifier to convert to text.
    ///
    ///
    /// ## Return Value
    ///
    /// A textual value for the specified category.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Your extension can use this function for logging.
    ///
    ///
    /// Converts a device category to a string for logging, etc.
    #[doc(alias = "DDDeviceCategoryToString")]
    #[inline]
    pub unsafe fn to_string(self) -> Retained<NSString> {
        extern "C-unwind" {
            fn DDDeviceCategoryToString(in_value: DDDeviceCategory) -> *mut NSString;
        }
        let ret = unsafe { DDDeviceCategoryToString(self) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// A state that represents the level of user interaction with the device.
///
/// ## Overview
///
/// The device ([`DDDevice`](https://developer.apple.com/documentation/devicediscoveryextension/dddevice)) [`state`](https://developer.apple.com/documentation/devicediscoveryextension/dddevice/state) property is of this type.
///
///
/// State of the device.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct DDDeviceState(pub NSInteger);
impl DDDeviceState {
    /// A state that indicates the device is invalid or that the user disapproves of the device.
    #[doc(alias = "DDDeviceStateInvalid")]
    pub const Invalid: Self = Self(0);
    /// A state that indicates when the user selects the device in the picker UI.
    /// Invalid/unapproved state.
    #[doc(alias = "DDDeviceStateActivating")]
    pub const Activating: Self = Self(10);
    /// A state that indicates when the user authorizes the device and the app connects to the device.
    /// Selected by the user.
    #[doc(alias = "DDDeviceStateActivated")]
    pub const Activated: Self = Self(20);
    /// A state that indicates when the user authorizes the device.
    /// Authorized and connected.
    #[doc(alias = "DDDeviceStateAuthorized")]
    pub const Authorized: Self = Self(25);
    /// A state that indicates that the device is soon to be invalid.
    /// Authorized by the user.
    #[doc(alias = "DDDeviceStateInvalidating")]
    pub const Invalidating: Self = Self(30);
}

unsafe impl Encode for DDDeviceState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl DDDeviceState {
    /// Returns human-readable text for the specified identifier that describes a device’s status.
    ///
    /// Parameters:
    /// - inValue: A state identifier to convert to text.
    ///
    ///
    /// ## Return Value
    ///
    /// A textual value for the specified device state.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Your extension can use this function for logging.
    ///
    ///
    /// Converts a device state to a string for logging, etc.
    #[doc(alias = "DDDeviceStateToString")]
    #[inline]
    pub unsafe fn to_string(self) -> Retained<NSString> {
        extern "C-unwind" {
            fn DDDeviceStateToString(in_value: DDDeviceState) -> *mut NSString;
        }
        let ret = unsafe { DDDeviceStateToString(self) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// States that indicate the status of a device’s media playback.
///
/// ## Overview
///
/// The device ([`DDDevice`](https://developer.apple.com/documentation/devicediscoveryextension/dddevice)) property [`mediaPlaybackState`](https://developer.apple.com/documentation/devicediscoveryextension/dddevice/mediaplaybackstate-swift.property) is of this type.
///
///
/// State of media playback on the device.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct DDDeviceMediaPlaybackState(pub NSInteger);
impl DDDeviceMediaPlaybackState {
    /// A state that indicates when the device plays no content.
    #[doc(alias = "DDDeviceMediaPlaybackStateNoContent")]
    pub const NoContent: Self = Self(0);
    /// A state that indicates when content playback for the device pauses.
    /// Not playing any media content.
    #[doc(alias = "DDDeviceMediaPlaybackStatePaused")]
    pub const Paused: Self = Self(1);
    /// A state that indicates when the device plays media.
    /// Media content playback is paused.
    #[doc(alias = "DDDeviceMediaPlaybackStatePlaying")]
    pub const Playing: Self = Self(2);
}

unsafe impl Encode for DDDeviceMediaPlaybackState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceMediaPlaybackState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Device Support
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct DDDeviceSupports(pub NSUInteger);
bitflags::bitflags! {
    impl DDDeviceSupports: NSUInteger {
        #[doc(alias = "DDDeviceSupportsBluetoothPairingLE")]
        const BluetoothPairingLE = 1<<1;
/// Device supports Bluetooth Low Energy pairing.
        #[doc(alias = "DDDeviceSupportsBluetoothTransportBridging")]
        const BluetoothTransportBridging = 1<<2;
/// Device supports bring up of classic transport profiles when low energy transport for peripheral is connected.
/// Device supports bring up of classic transport profiles when low energy transport for peripheral is connected.
        #[doc(alias = "DDDeviceSupportsBluetoothHID")]
        const BluetoothHID = 1<<3;
    }
}

unsafe impl Encode for DDDeviceSupports {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceSupports {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// Wi-Fi Aware Service’s Role
///
///
/// Wi-Fi Aware Service's Role
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct DDDeviceWiFiAwareServiceRole(pub NSInteger);
impl DDDeviceWiFiAwareServiceRole {
    #[doc(alias = "DDDeviceWiFiAwareServiceRoleSubscriber")]
    pub const Subscriber: Self = Self(10);
    #[doc(alias = "DDDeviceWiFiAwareServiceRolePublisher")]
    pub const Publisher: Self = Self(20);
}

unsafe impl Encode for DDDeviceWiFiAwareServiceRole {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceWiFiAwareServiceRole {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl DDDeviceMediaPlaybackState {
    /// Returns human-readable text for the specified media playback state.
    ///
    /// Parameters:
    /// - inValue: A media playback state to convert to text.
    ///
    ///
    /// ## Return Value
    ///
    /// A textual value for the specified device protocol.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Your extension can use this function for logging.
    ///
    ///
    /// Converts a device media playback state to a string for logging, etc.
    #[doc(alias = "DDDeviceMediaPlaybackStateToString")]
    #[inline]
    pub unsafe fn to_string(self) -> Retained<NSString> {
        extern "C-unwind" {
            fn DDDeviceMediaPlaybackStateToString(
                in_value: DDDeviceMediaPlaybackState,
            ) -> *mut NSString;
        }
        let ret = unsafe { DDDeviceMediaPlaybackStateToString(self) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

extern_class!(
    /// An object that describes a discovered device of interest.
    ///
    /// ## Overview
    ///
    /// The extension creates an instance of this class for a discovered device of interest and passes it to the system for display in the device picker UI ([`AVRoutePickerView`](https://developer.apple.com/documentation/avkit/avroutepickerview)).
    ///
    /// The extension discovers devices through either Core Bluetooth or the local network (that is, using [Bonjour](https://developer.apple.com/documentation/foundation/bonjour)).
    ///
    /// For device discovery extensions of third-party media receivers, an instance of this class corresponds to the media receiver of interest.
    ///
    /// The extension reports the status of discovered devices to the system using the [`reportEvent:`](https://developer.apple.com/documentation/devicediscoveryextension/dddiscoverysession/report(_:)) function, and it receives status updates about the device from the system by implementing [`didReceiveEvent(_:)`](https://developer.apple.com/documentation/devicediscoveryextension/dddiscoveryextension/didreceiveevent(_:)).
    ///
    ///
    /// DeviceDiscoveryExtension device.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct DDDevice;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for DDDevice {}
);

impl DDDevice {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        /// Initializes a DD device with display name, category, protocol type, and identifier.
        #[unsafe(method(initWithDisplayName:category:protocolType:identifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDisplayName_category_protocolType_identifier(
            this: Allocated<Self>,
            display_name: &NSString,
            category: DDDeviceCategory,
            protocol_type: &UTType,
            identifier: &NSString,
        ) -> Retained<Self>;

        /// Device supported capabilities.
        #[unsafe(method(deviceSupports))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceSupports(&self) -> DDDeviceSupports;

        /// Setter for [`deviceSupports`][Self::deviceSupports].
        #[unsafe(method(setDeviceSupports:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDeviceSupports(&self, device_supports: DDDeviceSupports);

        /// Identifier to communicate with the device via Bluetooth.
        #[unsafe(method(bluetoothIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn bluetoothIdentifier(&self) -> Option<Retained<NSUUID>>;

        /// Setter for [`bluetoothIdentifier`][Self::bluetoothIdentifier].
        #[unsafe(method(setBluetoothIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBluetoothIdentifier(&self, bluetooth_identifier: Option<&NSUUID>);

        /// Category of the device.
        #[unsafe(method(category))]
        #[unsafe(method_family = none)]
        pub unsafe fn category(&self) -> DDDeviceCategory;

        /// Setter for [`category`][Self::category].
        #[unsafe(method(setCategory:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCategory(&self, category: DDDeviceCategory);

        /// Device's custom asset for product image name in the main App bundle.
        #[unsafe(method(displayImageName))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayImageName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`displayImageName`][Self::displayImageName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDisplayImageName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisplayImageName(&self, display_image_name: Option<&NSString>);

        /// Name of the device. Should be suitable for displaying to a user.
        #[unsafe(method(displayName))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayName(&self) -> Retained<NSString>;

        /// Setter for [`displayName`][Self::displayName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDisplayName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisplayName(&self, display_name: &NSString);

        /// Identifier of the device.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSString>;

        /// Setter for [`identifier`][Self::identifier].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentifier(&self, identifier: &NSString);

        /// Current state of media playback on this device.
        #[unsafe(method(mediaPlaybackState))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaPlaybackState(&self) -> DDDeviceMediaPlaybackState;

        /// Setter for [`mediaPlaybackState`][Self::mediaPlaybackState].
        #[unsafe(method(setMediaPlaybackState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMediaPlaybackState(
            &self,
            media_playback_state: DDDeviceMediaPlaybackState,
        );

        /// Title of the media content being played.
        #[unsafe(method(mediaContentTitle))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaContentTitle(&self) -> Option<Retained<NSString>>;

        /// Setter for [`mediaContentTitle`][Self::mediaContentTitle].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMediaContentTitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMediaContentTitle(&self, media_content_title: Option<&NSString>);

        /// Subtitle of the media content being played. It can be used to display extra information about the content, such as the name of the artist.
        #[unsafe(method(mediaContentSubtitle))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaContentSubtitle(&self) -> Option<Retained<NSString>>;

        /// Setter for [`mediaContentSubtitle`][Self::mediaContentSubtitle].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMediaContentSubtitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMediaContentSubtitle(&self, media_content_subtitle: Option<&NSString>);

        /// Protocol of the device.
        #[unsafe(method(protocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocol(&self) -> DDDeviceProtocol;

        /// Setter for [`protocol`][Self::protocol].
        #[unsafe(method(setProtocol:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProtocol(&self, protocol: DDDeviceProtocol);

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        /// Uniform Type for the protocol.
        #[unsafe(method(protocolType))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocolType(&self) -> Retained<UTType>;

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        /// Setter for [`protocolType`][Self::protocolType].
        #[unsafe(method(setProtocolType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProtocolType(&self, protocol_type: &UTType);

        /// State of the device.
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> DDDeviceState;

        /// Setter for [`state`][Self::state].
        #[unsafe(method(setState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setState(&self, state: DDDeviceState);

        /// Device's WiFi Hotspot SSID.
        #[unsafe(method(SSID))]
        #[unsafe(method_family = none)]
        pub unsafe fn SSID(&self) -> Option<Retained<NSString>>;

        /// Setter for [`SSID`][Self::SSID].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setSSID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSSID(&self, ssid: Option<&NSString>);

        /// Whether the device supports grouping with other devices with the same protocol.
        #[unsafe(method(supportsGrouping))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsGrouping(&self) -> bool;

        /// Setter for [`supportsGrouping`][Self::supportsGrouping].
        #[unsafe(method(setSupportsGrouping:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsGrouping(&self, supports_grouping: bool);

        /// TXT record of the device.
        #[unsafe(method(txtRecordData))]
        #[unsafe(method_family = none)]
        pub unsafe fn txtRecordData(&self) -> Option<Retained<NSData>>;

        /// Setter for [`txtRecordData`][Self::txtRecordData].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTxtRecordData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTxtRecordData(&self, txt_record_data: Option<&NSData>);

        /// URL used for SSDP connection.
        /// The URL must have a valid hostname, no query parameters, and a maximum size of 100 bytes.
        #[unsafe(method(url))]
        #[unsafe(method_family = none)]
        pub unsafe fn url(&self) -> Retained<NSURL>;

        /// Setter for [`url`][Self::url].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setUrl:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUrl(&self, url: &NSURL);

        /// Device's Wi-Fi Aware's service name.
        #[unsafe(method(wifiAwareServiceName))]
        #[unsafe(method_family = none)]
        pub unsafe fn wifiAwareServiceName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`wifiAwareServiceName`][Self::wifiAwareServiceName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setWifiAwareServiceName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWifiAwareServiceName(&self, wifi_aware_service_name: Option<&NSString>);

        /// Device's Wi-Fi Aware's service. Default is `DDDeviceWiFiAwareServiceRoleSubscriber`
        #[unsafe(method(wifiAwareServiceRole))]
        #[unsafe(method_family = none)]
        pub unsafe fn wifiAwareServiceRole(&self) -> DDDeviceWiFiAwareServiceRole;

        /// Setter for [`wifiAwareServiceRole`][Self::wifiAwareServiceRole].
        #[unsafe(method(setWifiAwareServiceRole:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWifiAwareServiceRole(
            &self,
            wifi_aware_service_role: DDDeviceWiFiAwareServiceRole,
        );

        /// Device's Wi-Fi Aware model name.
        #[unsafe(method(wifiAwareModelName))]
        #[unsafe(method_family = none)]
        pub unsafe fn wifiAwareModelName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`wifiAwareModelName`][Self::wifiAwareModelName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setWifiAwareModelName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWifiAwareModelName(&self, wifi_aware_model_name: Option<&NSString>);

        /// Device's Wi-Fi Aware vendor name.
        #[unsafe(method(wifiAwareVendorName))]
        #[unsafe(method_family = none)]
        pub unsafe fn wifiAwareVendorName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`wifiAwareVendorName`][Self::wifiAwareVendorName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setWifiAwareVendorName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWifiAwareVendorName(&self, wifi_aware_vendor_name: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl DDDevice {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

#[deprecated = "renamed to `DDDeviceProtocol::to_string`"]
#[inline]
pub unsafe extern "C-unwind" fn DDDeviceProtocolToString(
    in_value: DDDeviceProtocol,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn DDDeviceProtocolToString(in_value: DDDeviceProtocol) -> *mut NSString;
    }
    let ret = unsafe { DDDeviceProtocolToString(in_value) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `DDDeviceCategory::to_string`"]
#[inline]
pub unsafe extern "C-unwind" fn DDDeviceCategoryToString(
    in_value: DDDeviceCategory,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn DDDeviceCategoryToString(in_value: DDDeviceCategory) -> *mut NSString;
    }
    let ret = unsafe { DDDeviceCategoryToString(in_value) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `DDDeviceState::to_string`"]
#[inline]
pub unsafe extern "C-unwind" fn DDDeviceStateToString(
    in_value: DDDeviceState,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn DDDeviceStateToString(in_value: DDDeviceState) -> *mut NSString;
    }
    let ret = unsafe { DDDeviceStateToString(in_value) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `DDDeviceMediaPlaybackState::to_string`"]
#[inline]
pub unsafe extern "C-unwind" fn DDDeviceMediaPlaybackStateToString(
    in_value: DDDeviceMediaPlaybackState,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn DDDeviceMediaPlaybackStateToString(
            in_value: DDDeviceMediaPlaybackState,
        ) -> *mut NSString;
    }
    let ret = unsafe { DDDeviceMediaPlaybackStateToString(in_value) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}
