//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-uniform-type-identifiers")]
use objc2_uniform_type_identifiers::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddeviceprotocolstring?language=objc)
// NS_TYPED_ENUM
pub type DDDeviceProtocolString = NSString;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddeviceprotocolstringinvalid?language=objc)
    pub static DDDeviceProtocolStringInvalid: &'static DDDeviceProtocolString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddeviceprotocolstringdial?language=objc)
    pub static DDDeviceProtocolStringDIAL: &'static DDDeviceProtocolString;
}

/// [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddeviceprotocol?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct DDDeviceProtocol(pub NSInteger);
impl DDDeviceProtocol {
    #[doc(alias = "DDDeviceProtocolInvalid")]
    pub const Invalid: Self = Self(0);
    /// Invalid protocol.
    #[doc(alias = "DDDeviceProtocolDIAL")]
    pub const DIAL: Self = Self(1);
}

unsafe impl Encode for DDDeviceProtocol {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceProtocol {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl DDDeviceProtocol {
    /// Converts a device protocol type to a string for logging, etc.
    #[doc(alias = "DDDeviceProtocolToString")]
    #[inline]
    pub unsafe fn to_string(self: DDDeviceProtocol) -> Retained<NSString> {
        extern "C-unwind" {
            fn DDDeviceProtocolToString(in_value: DDDeviceProtocol) -> *mut NSString;
        }
        let ret = unsafe { DDDeviceProtocolToString(self) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// Category of the device.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddevicecategory?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct DDDeviceCategory(pub NSInteger);
impl DDDeviceCategory {
    #[doc(alias = "DDDeviceCategoryHiFiSpeaker")]
    pub const HiFiSpeaker: Self = Self(0);
    /// Hi-Fi speaker.
    #[doc(alias = "DDDeviceCategoryHiFiSpeakerMultiple")]
    pub const HiFiSpeakerMultiple: Self = Self(1);
    /// Multiple Hi-Fi speakers.
    #[doc(alias = "DDDeviceCategoryTVWithMediaBox")]
    pub const TVWithMediaBox: Self = Self(2);
    /// TV with MediaBox.
    #[doc(alias = "DDDeviceCategoryTV")]
    pub const TV: Self = Self(3);
    /// TV.
    #[doc(alias = "DDDeviceCategoryLaptopComputer")]
    pub const LaptopComputer: Self = Self(4);
    /// Laptop computer.
    #[doc(alias = "DDDeviceCategoryDesktopComputer")]
    pub const DesktopComputer: Self = Self(5);
    /// Desktop computer.
    #[doc(alias = "DDDeviceCategoryAccessorySetup")]
    pub const AccessorySetup: Self = Self(6);
}

unsafe impl Encode for DDDeviceCategory {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceCategory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl DDDeviceCategory {
    /// Converts a device category to a string for logging, etc.
    #[doc(alias = "DDDeviceCategoryToString")]
    #[inline]
    pub unsafe fn to_string(self: DDDeviceCategory) -> Retained<NSString> {
        extern "C-unwind" {
            fn DDDeviceCategoryToString(in_value: DDDeviceCategory) -> *mut NSString;
        }
        let ret = unsafe { DDDeviceCategoryToString(self) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// State of the device.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddevicestate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct DDDeviceState(pub NSInteger);
impl DDDeviceState {
    #[doc(alias = "DDDeviceStateInvalid")]
    pub const Invalid: Self = Self(0);
    /// Invalid/unapproved state.
    #[doc(alias = "DDDeviceStateActivating")]
    pub const Activating: Self = Self(10);
    /// Selected by the user.
    #[doc(alias = "DDDeviceStateActivated")]
    pub const Activated: Self = Self(20);
    /// Authorized and connected.
    #[doc(alias = "DDDeviceStateAuthorized")]
    pub const Authorized: Self = Self(25);
    /// Authorized by the user.
    #[doc(alias = "DDDeviceStateInvalidating")]
    pub const Invalidating: Self = Self(30);
}

unsafe impl Encode for DDDeviceState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl DDDeviceState {
    /// Converts a device state to a string for logging, etc.
    #[doc(alias = "DDDeviceStateToString")]
    #[inline]
    pub unsafe fn to_string(self: DDDeviceState) -> Retained<NSString> {
        extern "C-unwind" {
            fn DDDeviceStateToString(in_value: DDDeviceState) -> *mut NSString;
        }
        let ret = unsafe { DDDeviceStateToString(self) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

/// State of media playback on the device.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddevicemediaplaybackstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct DDDeviceMediaPlaybackState(pub NSInteger);
impl DDDeviceMediaPlaybackState {
    #[doc(alias = "DDDeviceMediaPlaybackStateNoContent")]
    pub const NoContent: Self = Self(0);
    /// Not playing any media content.
    #[doc(alias = "DDDeviceMediaPlaybackStatePaused")]
    pub const Paused: Self = Self(1);
    /// Media content playback is paused.
    #[doc(alias = "DDDeviceMediaPlaybackStatePlaying")]
    pub const Playing: Self = Self(2);
}

unsafe impl Encode for DDDeviceMediaPlaybackState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceMediaPlaybackState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Device Support
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddevicesupports?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct DDDeviceSupports(pub NSUInteger);
bitflags::bitflags! {
    impl DDDeviceSupports: NSUInteger {
        #[doc(alias = "DDDeviceSupportsBluetoothPairingLE")]
        const BluetoothPairingLE = 1<<1;
/// Device supports Bluetooth Low Energy pairing.
        #[doc(alias = "DDDeviceSupportsBluetoothTransportBridging")]
        const BluetoothTransportBridging = 1<<2;
/// Device supports bring up of classic transport profiles when low energy transport for peripheral is connected.
        #[doc(alias = "DDDeviceSupportsBluetoothHID")]
        const BluetoothHID = 1<<3;
    }
}

unsafe impl Encode for DDDeviceSupports {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceSupports {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Wi-Fi Aware Service's Role
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddevicewifiawareservicerole?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct DDDeviceWiFiAwareServiceRole(pub NSInteger);
impl DDDeviceWiFiAwareServiceRole {
    #[doc(alias = "DDDeviceWiFiAwareServiceRoleSubscriber")]
    pub const Subscriber: Self = Self(10);
    #[doc(alias = "DDDeviceWiFiAwareServiceRolePublisher")]
    pub const Publisher: Self = Self(20);
}

unsafe impl Encode for DDDeviceWiFiAwareServiceRole {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for DDDeviceWiFiAwareServiceRole {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl DDDeviceMediaPlaybackState {
    /// Converts a device media playback state to a string for logging, etc.
    #[doc(alias = "DDDeviceMediaPlaybackStateToString")]
    #[inline]
    pub unsafe fn to_string(self: DDDeviceMediaPlaybackState) -> Retained<NSString> {
        extern "C-unwind" {
            fn DDDeviceMediaPlaybackStateToString(
                in_value: DDDeviceMediaPlaybackState,
            ) -> *mut NSString;
        }
        let ret = unsafe { DDDeviceMediaPlaybackStateToString(self) };
        unsafe { Retained::retain_autoreleased(ret) }
            .expect("function was marked as returning non-null, but actually returned NULL")
    }
}

extern_class!(
    /// DeviceDiscoveryExtension device.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/devicediscoveryextension/dddevice?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct DDDevice;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for DDDevice {}
);

impl DDDevice {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        /// Initializes a DD device with display name, category, protocol type, and identifier.
        #[unsafe(method(initWithDisplayName:category:protocolType:identifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDisplayName_category_protocolType_identifier(
            this: Allocated<Self>,
            display_name: &NSString,
            category: DDDeviceCategory,
            protocol_type: &UTType,
            identifier: &NSString,
        ) -> Retained<Self>;

        /// Device supported capabilities.
        #[unsafe(method(deviceSupports))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceSupports(&self) -> DDDeviceSupports;

        /// Setter for [`deviceSupports`][Self::deviceSupports].
        #[unsafe(method(setDeviceSupports:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDeviceSupports(&self, device_supports: DDDeviceSupports);

        /// Identifier to communicate with the device via Bluetooth.
        #[unsafe(method(bluetoothIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn bluetoothIdentifier(&self) -> Option<Retained<NSUUID>>;

        /// Setter for [`bluetoothIdentifier`][Self::bluetoothIdentifier].
        #[unsafe(method(setBluetoothIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBluetoothIdentifier(&self, bluetooth_identifier: Option<&NSUUID>);

        /// Category of the device.
        #[unsafe(method(category))]
        #[unsafe(method_family = none)]
        pub unsafe fn category(&self) -> DDDeviceCategory;

        /// Setter for [`category`][Self::category].
        #[unsafe(method(setCategory:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCategory(&self, category: DDDeviceCategory);

        /// Device's custom asset for product image name in the main App bundle.
        #[unsafe(method(displayImageName))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayImageName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`displayImageName`][Self::displayImageName].
        #[unsafe(method(setDisplayImageName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisplayImageName(&self, display_image_name: Option<&NSString>);

        /// Name of the device. Should be suitable for displaying to a user.
        #[unsafe(method(displayName))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayName(&self) -> Retained<NSString>;

        /// Setter for [`displayName`][Self::displayName].
        #[unsafe(method(setDisplayName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisplayName(&self, display_name: &NSString);

        /// Identifier of the device.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSString>;

        /// Setter for [`identifier`][Self::identifier].
        #[unsafe(method(setIdentifier:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIdentifier(&self, identifier: &NSString);

        /// Current state of media playback on this device.
        #[unsafe(method(mediaPlaybackState))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaPlaybackState(&self) -> DDDeviceMediaPlaybackState;

        /// Setter for [`mediaPlaybackState`][Self::mediaPlaybackState].
        #[unsafe(method(setMediaPlaybackState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMediaPlaybackState(
            &self,
            media_playback_state: DDDeviceMediaPlaybackState,
        );

        /// Title of the media content being played.
        #[unsafe(method(mediaContentTitle))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaContentTitle(&self) -> Option<Retained<NSString>>;

        /// Setter for [`mediaContentTitle`][Self::mediaContentTitle].
        #[unsafe(method(setMediaContentTitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMediaContentTitle(&self, media_content_title: Option<&NSString>);

        /// Subtitle of the media content being played. It can be used to display extra information about the content, such as the name of the artist.
        #[unsafe(method(mediaContentSubtitle))]
        #[unsafe(method_family = none)]
        pub unsafe fn mediaContentSubtitle(&self) -> Option<Retained<NSString>>;

        /// Setter for [`mediaContentSubtitle`][Self::mediaContentSubtitle].
        #[unsafe(method(setMediaContentSubtitle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMediaContentSubtitle(&self, media_content_subtitle: Option<&NSString>);

        /// Protocol of the device.
        #[unsafe(method(protocol))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocol(&self) -> DDDeviceProtocol;

        /// Setter for [`protocol`][Self::protocol].
        #[unsafe(method(setProtocol:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProtocol(&self, protocol: DDDeviceProtocol);

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        /// Uniform Type for the protocol.
        #[unsafe(method(protocolType))]
        #[unsafe(method_family = none)]
        pub unsafe fn protocolType(&self) -> Retained<UTType>;

        #[cfg(feature = "objc2-uniform-type-identifiers")]
        /// Setter for [`protocolType`][Self::protocolType].
        #[unsafe(method(setProtocolType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProtocolType(&self, protocol_type: &UTType);

        /// State of the device.
        #[unsafe(method(state))]
        #[unsafe(method_family = none)]
        pub unsafe fn state(&self) -> DDDeviceState;

        /// Setter for [`state`][Self::state].
        #[unsafe(method(setState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setState(&self, state: DDDeviceState);

        /// Device's WiFi Hotspot SSID.
        #[unsafe(method(SSID))]
        #[unsafe(method_family = none)]
        pub unsafe fn SSID(&self) -> Option<Retained<NSString>>;

        /// Setter for [`SSID`][Self::SSID].
        #[unsafe(method(setSSID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSSID(&self, ssid: Option<&NSString>);

        /// Whether the device supports grouping with other devices with the same protocol.
        #[unsafe(method(supportsGrouping))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportsGrouping(&self) -> bool;

        /// Setter for [`supportsGrouping`][Self::supportsGrouping].
        #[unsafe(method(setSupportsGrouping:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupportsGrouping(&self, supports_grouping: bool);

        /// TXT record of the device.
        #[unsafe(method(txtRecordData))]
        #[unsafe(method_family = none)]
        pub unsafe fn txtRecordData(&self) -> Option<Retained<NSData>>;

        /// Setter for [`txtRecordData`][Self::txtRecordData].
        #[unsafe(method(setTxtRecordData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTxtRecordData(&self, txt_record_data: Option<&NSData>);

        /// URL used for SSDP connection.
        /// The URL must have a valid hostname, no query parameters, and a maximum size of 100 bytes.
        #[unsafe(method(url))]
        #[unsafe(method_family = none)]
        pub unsafe fn url(&self) -> Retained<NSURL>;

        /// Setter for [`url`][Self::url].
        #[unsafe(method(setUrl:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setUrl(&self, url: &NSURL);

        /// Device's Wi-Fi Aware's service name.
        #[unsafe(method(wifiAwareServiceName))]
        #[unsafe(method_family = none)]
        pub unsafe fn wifiAwareServiceName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`wifiAwareServiceName`][Self::wifiAwareServiceName].
        #[unsafe(method(setWifiAwareServiceName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWifiAwareServiceName(&self, wifi_aware_service_name: Option<&NSString>);

        /// Device's Wi-Fi Aware's service. Default is `DDDeviceWiFiAwareServiceRoleSubscriber`
        #[unsafe(method(wifiAwareServiceRole))]
        #[unsafe(method_family = none)]
        pub unsafe fn wifiAwareServiceRole(&self) -> DDDeviceWiFiAwareServiceRole;

        /// Setter for [`wifiAwareServiceRole`][Self::wifiAwareServiceRole].
        #[unsafe(method(setWifiAwareServiceRole:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWifiAwareServiceRole(
            &self,
            wifi_aware_service_role: DDDeviceWiFiAwareServiceRole,
        );

        /// Device's Wi-Fi Aware model name.
        #[unsafe(method(wifiAwareModelName))]
        #[unsafe(method_family = none)]
        pub unsafe fn wifiAwareModelName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`wifiAwareModelName`][Self::wifiAwareModelName].
        #[unsafe(method(setWifiAwareModelName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWifiAwareModelName(&self, wifi_aware_model_name: Option<&NSString>);

        /// Device's Wi-Fi Aware vendor name.
        #[unsafe(method(wifiAwareVendorName))]
        #[unsafe(method_family = none)]
        pub unsafe fn wifiAwareVendorName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`wifiAwareVendorName`][Self::wifiAwareVendorName].
        #[unsafe(method(setWifiAwareVendorName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWifiAwareVendorName(&self, wifi_aware_vendor_name: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl DDDevice {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

#[deprecated = "renamed to `DDDeviceProtocol::to_string`"]
#[inline]
pub unsafe extern "C-unwind" fn DDDeviceProtocolToString(
    in_value: DDDeviceProtocol,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn DDDeviceProtocolToString(in_value: DDDeviceProtocol) -> *mut NSString;
    }
    let ret = unsafe { DDDeviceProtocolToString(in_value) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `DDDeviceCategory::to_string`"]
#[inline]
pub unsafe extern "C-unwind" fn DDDeviceCategoryToString(
    in_value: DDDeviceCategory,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn DDDeviceCategoryToString(in_value: DDDeviceCategory) -> *mut NSString;
    }
    let ret = unsafe { DDDeviceCategoryToString(in_value) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `DDDeviceState::to_string`"]
#[inline]
pub unsafe extern "C-unwind" fn DDDeviceStateToString(
    in_value: DDDeviceState,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn DDDeviceStateToString(in_value: DDDeviceState) -> *mut NSString;
    }
    let ret = unsafe { DDDeviceStateToString(in_value) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `DDDeviceMediaPlaybackState::to_string`"]
#[inline]
pub unsafe extern "C-unwind" fn DDDeviceMediaPlaybackStateToString(
    in_value: DDDeviceMediaPlaybackState,
) -> Retained<NSString> {
    extern "C-unwind" {
        fn DDDeviceMediaPlaybackStateToString(
            in_value: DDDeviceMediaPlaybackState,
        ) -> *mut NSString;
    }
    let ret = unsafe { DDDeviceMediaPlaybackStateToString(in_value) };
    unsafe { Retained::retain_autoreleased(ret) }
        .expect("function was marked as returning non-null, but actually returned NULL")
}
