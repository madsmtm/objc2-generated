//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothl2capchanneleventtype?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOBluetoothL2CAPChannelEventType(pub c_uint);
impl IOBluetoothL2CAPChannelEventType {
    #[doc(alias = "kIOBluetoothL2CAPChannelEventTypeData")]
    pub const Data: Self = Self(0x0001);
    #[doc(alias = "kIOBluetoothL2CAPChannelEventTypeOpenComplete")]
    pub const OpenComplete: Self = Self(0x0002);
    #[doc(alias = "kIOBluetoothL2CAPChannelEventTypeClosed")]
    pub const Closed: Self = Self(0x0003);
    #[doc(alias = "kIOBluetoothL2CAPChannelEventTypeReconfigured")]
    pub const Reconfigured: Self = Self(0x0004);
    #[doc(alias = "kIOBluetoothL2CAPChannelEventTypeWriteComplete")]
    pub const WriteComplete: Self = Self(0x0005);
    #[doc(alias = "kIOBluetoothL2CAPChannelEventTypeQueueSpaceAvailable")]
    pub const QueueSpaceAvailable: Self = Self(0x0006);
}

unsafe impl Encode for IOBluetoothL2CAPChannelEventType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

unsafe impl RefEncode for IOBluetoothL2CAPChannelEventType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothl2capchanneldatablock?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOBluetoothL2CAPChannelDataBlock {
    pub dataPtr: *mut c_void,
    pub dataSize: usize,
}

unsafe impl Encode for IOBluetoothL2CAPChannelDataBlock {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBluetoothL2CAPChannelDataBlock",
        &[<*mut c_void>::ENCODING, <usize>::ENCODING],
    );
}

unsafe impl RefEncode for IOBluetoothL2CAPChannelDataBlock {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[repr(C)]
#[derive(Clone, Copy)]
pub union IOBluetoothL2CAPChannelEvent_u {
    pub data: IOBluetoothL2CAPChannelDataBlock,
    pub writeRefCon: *mut c_void,
    pub padding: [u8; 32],
}

unsafe impl Encode for IOBluetoothL2CAPChannelEvent_u {
    const ENCODING: Encoding = Encoding::Union(
        "?",
        &[
            <IOBluetoothL2CAPChannelDataBlock>::ENCODING,
            <*mut c_void>::ENCODING,
            <[u8; 32]>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for IOBluetoothL2CAPChannelEvent_u {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothl2capchannelevent?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub struct IOBluetoothL2CAPChannelEvent {
    pub eventType: IOBluetoothL2CAPChannelEventType,
    pub u: IOBluetoothL2CAPChannelEvent_u,
    pub status: IOReturn,
}

unsafe impl Encode for IOBluetoothL2CAPChannelEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBluetoothL2CAPChannelEvent",
        &[
            <IOBluetoothL2CAPChannelEventType>::ENCODING,
            <IOBluetoothL2CAPChannelEvent_u>::ENCODING,
            <IOReturn>::ENCODING,
        ],
    );
}

unsafe impl RefEncode for IOBluetoothL2CAPChannelEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothl2capchannelincomingdatalistener?language=objc)
#[cfg(feature = "IOBluetoothUserLib")]
pub type IOBluetoothL2CAPChannelIncomingDataListener = Option<
    unsafe extern "C-unwind" fn(*mut IOBluetoothL2CAPChannelRef, *mut c_void, u16, *mut c_void),
>;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothl2capchannelincomingeventlistener?language=objc)
#[cfg(feature = "IOBluetoothUserLib")]
pub type IOBluetoothL2CAPChannelIncomingEventListener = Option<
    unsafe extern "C-unwind" fn(
        *mut IOBluetoothL2CAPChannelRef,
        *mut c_void,
        *mut IOBluetoothL2CAPChannelEvent,
    ),
>;

extern_class!(
    /// An instance of IOBluetoothL2CAPChannel represents a single open L2CAP channel.
    ///
    /// A client won't create IOBluetoothL2CAPChannel objects directly.  Instead, the IOBluetoothDevice's
    /// L2CAP channel open API is responsible for opening a new L2CAP channel and returning an
    /// IOBluetoothL2CAPChannel instance representing that newly opened channel.  Additionally, the IOBluetooth
    /// notification system will send notifications when new L2CAP channels are open (if requested).
    ///
    /// After a new L2CAP channel is opened, the L2CAP configuration process will not be completed until an
    /// incoming data listener is registered with the IOBluetoothL2CAPChannel object.  The reason for this is
    /// to due to the limited buffering done of incoming L2CAP data.  This way, we avoid the situation where
    /// incoming data is received before the client is ready for it.  Once a client is done with an
    /// IOBluetoothL2CAPChannel that it opened, it should call -closeChannel.  Additionally, if the client
    /// does not intend to use the connection to the remote device any further, it should call -closeConnection
    /// on the IOBluetoothDevice object.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothl2capchannel?language=objc)
    #[unsafe(super(IOBluetoothObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "IOBluetoothObject")]
    pub struct IOBluetoothL2CAPChannel;
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSCopying for IOBluetoothL2CAPChannel {}
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
unsafe impl CopyingHelper for IOBluetoothL2CAPChannel {
    type Result = Self;
}

#[cfg(feature = "IOBluetoothObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for IOBluetoothL2CAPChannel {}
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSPortDelegate for IOBluetoothL2CAPChannel {}
);

#[cfg(feature = "IOBluetoothObject")]
impl IOBluetoothL2CAPChannel {
    extern_methods!(
        #[cfg(feature = "IOBluetoothUserNotification")]
        /// Allows a client to register for L2CAP channel open notifications for any L2CAP channel.
        ///
        /// The given selector will be called on the target object whenever any L2CAP channel is opened.
        /// The selector should accept two arguments.  The first is the user notification object.  The second
        /// is the IOBluetoothL2CAPChannel that was opened.
        ///
        /// Parameter `object`: Target object
        ///
        /// Parameter `selector`: Selector to be called on the target object when a new L2CAP channel is opened.
        ///
        /// Returns: Returns an IOBluetoothUserNotification representing the outstanding L2CAP channel notification.
        /// To unregister the notification, call -unregister on the resulting IOBluetoothUserNotification
        /// object.  If an error is encountered creating the notification, nil is returned.  The returned
        /// IOBluetoothUserNotification will be valid for as long as the notification is registered.  It is
        /// not necessary to retain the result.  Once -unregister is called on it, it will no longer be valid.
        ///
        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `object` might not allow `None`.
        /// - `selector` must be a valid selector.
        #[unsafe(method(registerForChannelOpenNotifications:selector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForChannelOpenNotifications_selector(
            object: Option<&AnyObject>,
            selector: Option<Sel>,
        ) -> Option<Retained<IOBluetoothUserNotification>>;

        #[cfg(all(
            feature = "Bluetooth",
            feature = "IOBluetoothUserLib",
            feature = "IOBluetoothUserNotification"
        ))]
        /// Allows a client to register for L2CAP channel open notifications for certain types of
        /// L2CAP channels.
        ///
        /// The given selector will be called on the target object whenever an L2CAP channel with the given
        /// attributes is opened.  The selector should accept two arguments.  The first is the user
        /// notification object.  The second is the IOBluetoothL2CAPChannel that was opened.
        ///
        /// Parameter `object`: Target object
        ///
        /// Parameter `selector`: Selector to be called on the target object when a new L2CAP channel is opened.
        ///
        /// Parameter `psm`: PSM to match a new L2CAP channel.  If the PSM doesn't matter, 0 may be passed in.
        ///
        /// Parameter `inDirection`: The desired direction of the L2CAP channel - kIOBluetoothUserNotificationChannelDirectionAny
        /// if the direction doesn't matter.
        ///
        /// Returns: Returns an IOBluetoothUserNotification representing the outstanding L2CAP channel notification.
        /// To unregister the notification, call -unregister on the resulting IOBluetoothUserNotification
        /// object.  If an error is encountered creating the notification, nil is returned.  The returned
        /// IOBluetoothUserNotification will be valid for as long as the notification is registered.  It is
        /// not necessary to retain the result.  Once -unregister is called on it, it will no longer be valid.
        ///
        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `object` might not allow `None`.
        /// - `selector` must be a valid selector.
        #[unsafe(method(registerForChannelOpenNotifications:selector:withPSM:direction:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForChannelOpenNotifications_selector_withPSM_direction(
            object: Option<&AnyObject>,
            selector: Option<Sel>,
            psm: BluetoothL2CAPPSM,
            in_direction: IOBluetoothUserNotificationChannelDirection,
        ) -> Option<Retained<IOBluetoothUserNotification>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Returns the IObluetoothL2CAPChannel with the given IOBluetoothObjectID.
        ///
        /// The IOBluetoothObjectID can be used as a global reference for a given IOBluetoothL2CAPChannel.  It allows
        /// two separate applications to refer to the same IOBluetoothL2CAPChannel object.
        ///
        /// Parameter `objectID`: IOBluetoothObjectID of the desired IOBluetoothL2CAPChannel.
        ///
        /// Returns: Returns the IOBluetoothL2CAPChannel that matches the given IOBluetoothObjectID if one exists.
        /// If no matching L2CAP channel exists, nil is returned.
        #[unsafe(method(withObjectID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withObjectID(object_id: IOBluetoothObjectID) -> Option<Retained<Self>>;

        /// Initiates the close process on an open L2CAP channel.
        ///
        /// This method may only be called by the client that opened the channel in the first place.  In the future
        /// asynchronous and synchronous versions will be provided that let the client know when the close process
        /// has been finished.
        ///
        /// Returns: Returns kIOReturnSuccess on success.
        #[unsafe(method(closeChannel))]
        #[unsafe(method_family = none)]
        pub unsafe fn closeChannel(&self) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Returns the current outgoing MTU for the L2CAP channel.
        ///
        /// The outgoing MTU represents the maximum L2CAP packet size for packets being sent to the remote device.
        ///
        /// Returns: Returns the current outgoing MTU for the L2CAP channel.
        #[unsafe(method(outgoingMTU))]
        #[unsafe(method_family = none)]
        pub unsafe fn outgoingMTU(&self) -> BluetoothL2CAPMTU;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getOutgoingMTU))]
        #[unsafe(method_family = none)]
        pub unsafe fn getOutgoingMTU(&self) -> BluetoothL2CAPMTU;

        #[cfg(feature = "Bluetooth")]
        /// Returns the current incoming MTU for the L2CAP channel.
        ///
        /// The incoming MTU represents the maximum L2CAP packet size for packets being sent by the remote device.
        ///
        /// Returns: Returns the current incoming MTU for the L2CAP channel.
        #[unsafe(method(incomingMTU))]
        #[unsafe(method_family = none)]
        pub unsafe fn incomingMTU(&self) -> BluetoothL2CAPMTU;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getIncomingMTU))]
        #[unsafe(method_family = none)]
        pub unsafe fn getIncomingMTU(&self) -> BluetoothL2CAPMTU;

        #[cfg(feature = "Bluetooth")]
        /// Initiates the process to reconfigure the L2CAP channel with a new outgoing MTU.
        ///
        /// Currently, this API does not give an indication that the re-config process has completed.  In
        /// the future additional API will be available to provide that information both synchronously and
        /// asynchronously.
        ///
        /// Parameter `remoteMTU`: The desired outgoing MTU.
        ///
        /// Returns: Returns kIOReturnSuccess if the channel re-configure process was successfully initiated.
        #[unsafe(method(requestRemoteMTU:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestRemoteMTU(&self, remote_mtu: BluetoothL2CAPMTU) -> IOReturn;

        /// Writes the given data over the target L2CAP channel asynchronously to the remote device using
        /// IOConnectTrap4() call.
        ///
        /// The length of the data may not exceed the L2CAP channel's ougoing MTU.  When the data has
        /// been successfully passed to the hardware to be transmitted, the delegate method
        /// -l2capChannelWriteComplete:refcon:status: will be called with the refcon passed
        /// into this method.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Parameter `data`: Pointer to the buffer containing the data to send.
        ///
        /// Parameter `length`: The length of the given data buffer.
        ///
        /// Parameter `refcon`: User supplied value that gets passed to the write callback.
        ///
        /// Returns: Returns kIOReturnSuccess if the data was buffered successfully.
        ///
        /// # Safety
        ///
        /// - `data` must be a valid pointer.
        /// - `refcon` must be a valid pointer.
        #[unsafe(method(writeAsyncTrap:length:refcon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeAsyncTrap_length_refcon(
            &self,
            data: *mut c_void,
            length: u16,
            refcon: *mut c_void,
        ) -> IOReturn;

        /// Writes the given data over the target L2CAP channel asynchronously to the remote device.
        ///
        /// The length of the data may not exceed the L2CAP channel's ougoing MTU.  When the data has
        /// been successfully passed to the hardware to be transmitted, the delegate method
        /// -l2capChannelWriteComplete:refcon:status: will be called with the refcon passed
        /// into this method.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Parameter `data`: Pointer to the buffer containing the data to send.
        ///
        /// Parameter `length`: The length of the given data buffer.
        ///
        /// Parameter `refcon`: User supplied value that gets passed to the write callback.
        ///
        /// Returns: Returns kIOReturnSuccess if the data was buffered successfully.
        ///
        /// # Safety
        ///
        /// - `data` must be a valid pointer.
        /// - `refcon` must be a valid pointer.
        #[unsafe(method(writeAsync:length:refcon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeAsync_length_refcon(
            &self,
            data: *mut c_void,
            length: u16,
            refcon: *mut c_void,
        ) -> IOReturn;

        /// Writes the given data synchronously over the target L2CAP channel to the remote device.
        ///
        /// The length of the data may not exceed the L2CAP channel's ougoing MTU.  This method will
        /// block until the data has been successfully sent to the hardware for transmission (or an error
        /// occurs).
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Parameter `data`: Pointer to the buffer containing the data to send.
        ///
        /// Parameter `length`: The length of the given data buffer.
        ///
        /// Returns: Returns kIOReturnSuccess if the data was written successfully.
        ///
        /// # Safety
        ///
        /// `data` must be a valid pointer.
        #[unsafe(method(writeSync:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeSync_length(&self, data: *mut c_void, length: u16) -> IOReturn;

        /// Allows an object to register itself as client of the L2CAP channel.
        ///
        /// A channel delegate is the object the L2CAP channel uses as target for data and events. The
        /// developer will implement only the the methods he/she is interested in. A list of the
        /// possible methods is at the end of this file in the definition of the informal protocol
        /// IOBluetoothL2CAPChannelDelegate.
        /// A newly opened L2CAP channel will not complete its configuration process until the client
        /// that opened it registers a connectionHandler.  This prevents that case where incoming
        /// data is received before the client is ready.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Parameter `channelDelegate`: the object that will play the role of channel delegate [NOTE the l2cap channel will retain the delegate].
        ///
        /// Returns: Returns kIOReturnSuccess if the delegate is successfully registered.
        ///
        /// # Safety
        ///
        /// - `channel_delegate` should be of the correct type.
        /// - `channel_delegate` might not allow `None`.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, channel_delegate: Option<&AnyObject>) -> IOReturn;

        #[cfg(feature = "objc2-foundation")]
        /// Allows an object to register itself as client of the L2CAP channel.
        ///
        /// A channel delegate is the object the L2CAP channel uses as target for data and events. The
        /// developer will implement only the the methods he/she is interested in. A list of the
        /// possible methods is at the end of this file in the definition of the informal protocol
        /// IOBluetoothL2CAPChannelDelegate.
        /// A newly opened L2CAP channel will not complete its configuration process until the client
        /// that opened it registers a connectionHandler.  This prevents that case where incoming
        /// data is received before the client is ready.
        ///
        /// NOTE: This method is only available in Mac OS X 10.5 (Bluetooth v2.0) or later.
        ///
        /// Parameter `channelDelegate`: the object that will play the role of channel delegate.
        ///
        /// Parameter `channelConfiguration`: the dictionary that describes the initial configuration for
        /// the channel.
        ///
        /// Returns: Returns kIOReturnSuccess if the delegate is successfully registered.
        ///
        /// # Safety
        ///
        /// - `channel_delegate` should be of the correct type.
        /// - `channel_delegate` might not allow `None`.
        /// - `channel_configuration` generic should be of the correct type.
        /// - `channel_configuration` might not allow `None`.
        #[unsafe(method(setDelegate:withConfiguration:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate_withConfiguration(
            &self,
            channel_delegate: Option<&AnyObject>,
            channel_configuration: Option<&NSDictionary>,
        ) -> IOReturn;

        /// Returns the currently assigned delegate
        ///
        /// An incoming channel is one that was initiated by a remote device.
        ///
        /// Returns: Returns the current delegate, or nil if one is not set.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "IOBluetoothDevice")]
        /// Returns the IOBluetoothDevice to which the target L2CAP channel is open.
        ///
        /// Returns: Returns the IOBluetoothDevice to which the target L2CAP channel is open.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        pub unsafe fn device(&self) -> Option<Retained<IOBluetoothDevice>>;

        #[cfg(feature = "IOBluetoothDevice")]
        #[deprecated]
        #[unsafe(method(getDevice))]
        #[unsafe(method_family = none)]
        pub unsafe fn getDevice(&self) -> Option<Retained<IOBluetoothDevice>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Returns the IOBluetoothObjectID of the given IOBluetoothL2CAPChannel.
        ///
        /// The IOBluetoothObjectID can be used as a global reference for a given IOBluetoothL2CAPChannel.  It allows
        /// two separate applications to refer to the same IOBluetoothL2CAPChannel.
        ///
        /// Returns: Returns the IOBluetoothObjectID of the given IOBluetoothL2CAPChannel.
        #[unsafe(method(objectID))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectID(&self) -> IOBluetoothObjectID;

        #[cfg(feature = "IOBluetoothUserLib")]
        #[deprecated]
        #[unsafe(method(getObjectID))]
        #[unsafe(method_family = none)]
        pub unsafe fn getObjectID(&self) -> IOBluetoothObjectID;

        #[cfg(feature = "Bluetooth")]
        /// Returns the PSM for the target L2CAP channel.
        ///
        /// Returns: Returns the PSM for the target L2CAP channel.
        #[unsafe(method(PSM))]
        #[unsafe(method_family = none)]
        pub unsafe fn PSM(&self) -> BluetoothL2CAPPSM;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getPSM))]
        #[unsafe(method_family = none)]
        pub unsafe fn getPSM(&self) -> BluetoothL2CAPPSM;

        #[cfg(feature = "Bluetooth")]
        /// Returns the local L2CAP channel ID for the target L2CAP channel.
        ///
        /// Returns: Returns the local L2CAP channel ID for the target L2CAP channel.
        #[unsafe(method(localChannelID))]
        #[unsafe(method_family = none)]
        pub unsafe fn localChannelID(&self) -> BluetoothL2CAPChannelID;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getLocalChannelID))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLocalChannelID(&self) -> BluetoothL2CAPChannelID;

        #[cfg(feature = "Bluetooth")]
        /// Returns the remote L2CAP channel ID for the target L2CAP channel.
        ///
        /// Returns: Returns the remote L2CAP channel ID for the target L2CAP channel.
        #[unsafe(method(remoteChannelID))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteChannelID(&self) -> BluetoothL2CAPChannelID;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getRemoteChannelID))]
        #[unsafe(method_family = none)]
        pub unsafe fn getRemoteChannelID(&self) -> BluetoothL2CAPChannelID;

        /// Returns TRUE if the channel is an incoming channel.
        ///
        /// An incoming channel is one that was initiated by a remote device.
        ///
        /// Returns: Returns TRUE if the channel is an incoming channel.
        #[unsafe(method(isIncoming))]
        #[unsafe(method_family = none)]
        pub unsafe fn isIncoming(&self) -> bool;

        #[cfg(feature = "IOBluetoothUserNotification")]
        /// Allows a client to register for a channel close notification.
        ///
        /// The given selector will be called on the target observer when the L2CAP channel is closed.
        /// The selector should contain two arguments.  The first is the user notification object. The second
        /// is the IOBluetoothL2CAPChannel that was closed.
        ///
        /// Parameter `observer`: Target observer object
        ///
        /// Parameter `inSelector`: Selector to be sent to the observer when the L2CAP channel is closed.
        ///
        /// Returns: Returns an IOBluetoothUserNotification representing the outstanding L2CAP channel close notification.
        /// To unregister the notification, call -unregister of the returned IOBluetoothUserNotification
        /// object.  If an error is encountered creating the notification, nil is returned.
        ///
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `observer` might not allow `None`.
        /// - `in_selector` must be a valid selector.
        #[unsafe(method(registerForChannelCloseNotification:selector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForChannelCloseNotification_selector(
            &self,
            observer: Option<&AnyObject>,
            in_selector: Option<Sel>,
        ) -> Option<Retained<IOBluetoothUserNotification>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "IOBluetoothObject")]
impl IOBluetoothL2CAPChannel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothl2capchanneldelegate?language=objc)
    pub unsafe trait IOBluetoothL2CAPChannelDelegate {
        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// - `l2cap_channel` might not allow `None`.
        /// - `data_pointer` must be a valid pointer.
        #[optional]
        #[unsafe(method(l2capChannelData:data:length:))]
        #[unsafe(method_family = none)]
        unsafe fn l2capChannelData_data_length(
            &self,
            l2cap_channel: Option<&IOBluetoothL2CAPChannel>,
            data_pointer: *mut c_void,
            data_length: usize,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `l2cap_channel` might not allow `None`.
        #[optional]
        #[unsafe(method(l2capChannelOpenComplete:status:))]
        #[unsafe(method_family = none)]
        unsafe fn l2capChannelOpenComplete_status(
            &self,
            l2cap_channel: Option<&IOBluetoothL2CAPChannel>,
            error: IOReturn,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `l2cap_channel` might not allow `None`.
        #[optional]
        #[unsafe(method(l2capChannelClosed:))]
        #[unsafe(method_family = none)]
        unsafe fn l2capChannelClosed(&self, l2cap_channel: Option<&IOBluetoothL2CAPChannel>);

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `l2cap_channel` might not allow `None`.
        #[optional]
        #[unsafe(method(l2capChannelReconfigured:))]
        #[unsafe(method_family = none)]
        unsafe fn l2capChannelReconfigured(&self, l2cap_channel: Option<&IOBluetoothL2CAPChannel>);

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// - `l2cap_channel` might not allow `None`.
        /// - `refcon` must be a valid pointer.
        #[optional]
        #[unsafe(method(l2capChannelWriteComplete:refcon:status:))]
        #[unsafe(method_family = none)]
        unsafe fn l2capChannelWriteComplete_refcon_status(
            &self,
            l2cap_channel: Option<&IOBluetoothL2CAPChannel>,
            refcon: *mut c_void,
            error: IOReturn,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `l2cap_channel` might not allow `None`.
        #[optional]
        #[unsafe(method(l2capChannelQueueSpaceAvailable:))]
        #[unsafe(method_family = none)]
        unsafe fn l2capChannelQueueSpaceAvailable(
            &self,
            l2cap_channel: Option<&IOBluetoothL2CAPChannel>,
        );
    }
);

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothl2capchannelpublishednotification?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static IOBluetoothL2CAPChannelPublishedNotification: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothl2capchannelterminatednotification?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static IOBluetoothL2CAPChannelTerminatedNotification: Option<&'static NSString>;
}
