//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothobexsession?language=objc)
    #[unsafe(super(OBEXSession, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "OBEXSession")]
    pub struct IOBluetoothOBEXSession;
);

#[cfg(all(feature = "IOBluetoothRFCOMMChannel", feature = "OBEXSession"))]
extern_conformance!(
    unsafe impl IOBluetoothRFCOMMChannelDelegate for IOBluetoothOBEXSession {}
);

#[cfg(feature = "OBEXSession")]
extern_conformance!(
    unsafe impl NSObjectProtocol for IOBluetoothOBEXSession {}
);

#[cfg(feature = "OBEXSession")]
impl IOBluetoothOBEXSession {
    extern_methods!(
        #[cfg(feature = "IOBluetoothSDPServiceRecord")]
        /// Creates a Bluetooth-based OBEX Session using an SDP service record, typically obtained from a device/service
        /// browser window controller.
        ///
        /// Parameter `inSDPServiceRecord`: A valid SDP service record describing the service (and RFCOMM channel) you want to
        /// connect to with Bluetooth/OBEX.
        ///
        /// Returns: An OBEX session representing the device/rfcomm channel found in the service record. nil if we failed.
        ///
        /// Note that this does NOT mean the transport connection was open. It will be opened when OBEXConnect is
        /// invoked on the session object.
        ///
        /// IMPORTANT NOTE*    In Bluetooth framework version 1.0.0, the session returned will NOT be autoreleased as it
        /// should be according to objc convention. This has been changed starting in Bluetooth version
        /// 1.0.1 and later, so it WILL be autoreleased upon return, so you will need to retain
        /// it if you want to reference it later.
        ///
        /// # Safety
        ///
        /// `in_sdp_service_record` might not allow `None`.
        #[unsafe(method(withSDPServiceRecord:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withSDPServiceRecord(
            in_sdp_service_record: Option<&IOBluetoothSDPServiceRecord>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "Bluetooth",
            feature = "IOBluetoothDevice",
            feature = "IOBluetoothObject"
        ))]
        /// Creates a Bluetooth-based OBEX Session using a Bluetooth device and a Bluetooth RFCOMM channel ID.
        ///
        /// Parameter `inDevice`: A valid Bluetooth device describing which device you want to connect to
        /// with Bluetooth/OBEX.
        ///
        /// Parameter `inRFCOMMChannelID`: An RFCOMM Channel ID numbe that is available on the remote device. This channel will
        /// be used when the transport connection is attempted.
        ///
        /// Returns: An OBEX session representing the device/rfcomm channel found in the service record. nil if we failed.
        ///
        /// Note that this does NOT mean the transport connection was open. It will be opened when OBEXConnect is
        /// invoked on the session object.
        ///
        /// IMPORTANT NOTE*    In Bluetooth framework version 1.0.0, the session returned will NOT be autoreleased as it
        /// should be according to objc convention. This has been changed starting in Bluetooth version
        /// 1.0.1 and later, so it WILL be autoreleased upon return, so you will need to retain
        /// it if you want to reference it later.
        ///
        /// # Safety
        ///
        /// `in_device` might not allow `None`.
        #[unsafe(method(withDevice:channelID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withDevice_channelID(
            in_device: Option<&IOBluetoothDevice>,
            in_rfcomm_channel_id: BluetoothRFCOMMChannelID,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "IOBluetoothObject", feature = "IOBluetoothRFCOMMChannel"))]
        /// Creates a Bluetooth-based OBEX Session using an incoming RFCOMM channel.
        ///
        /// Parameter `inChannel`: The channel to use to create a connection to a device.
        ///
        /// Parameter `inEventSelector`: The selector that gets called when an event occurs on the OBEX Session.
        ///
        /// Parameter `inEventSelectorTarget`: The object that is used to call the above selector.
        ///
        /// Parameter `inUserRefCon`: The reference constant. Pass whatever you wish - it will be returned to you in the selector.
        ///
        /// Returns:
        ///
        /// IMPORTANT NOTE*    In Bluetooth framework version 1.0.0, the session returned will NOT be autoreleased as it
        /// should be according to objc convention. This has been changed starting in Bluetooth version
        /// 1.0.1 and later, so it WILL be autoreleased upon return, so you will need to retain
        /// it if you want to reference it later.
        ///
        /// # Safety
        ///
        /// - `in_event_selector` must be a valid selector.
        /// - `in_event_selector_target` should be of the correct type.
        /// - `in_event_selector_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(withIncomingRFCOMMChannel:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withIncomingRFCOMMChannel_eventSelector_selectorTarget_refCon(
            in_channel: Option<&IOBluetoothRFCOMMChannel>,
            in_event_selector: Option<Sel>,
            in_event_selector_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "IOBluetoothSDPServiceRecord")]
        /// Initializes a Bluetooth-based OBEX Session using an SDP service record.
        ///
        /// Parameter `inSDPServiceRecord`:
        /// Returns:
        ///
        /// # Safety
        ///
        /// `in_sdp_service_record` might not allow `None`.
        #[unsafe(method(initWithSDPServiceRecord:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSDPServiceRecord(
            this: Allocated<Self>,
            in_sdp_service_record: Option<&IOBluetoothSDPServiceRecord>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "Bluetooth",
            feature = "IOBluetoothDevice",
            feature = "IOBluetoothObject"
        ))]
        /// Initializes a Bluetooth-based OBEX Session using a Bluetooth device.
        ///
        /// Parameter `inDevice`: The bluetooth device on which to open the OBEXSession.
        ///
        /// Parameter `inChannelID`: The RFCOMM channel ID to use when opening the connection.
        ///
        /// Returns:
        ///
        /// # Safety
        ///
        /// `in_device` might not allow `None`.
        #[unsafe(method(initWithDevice:channelID:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDevice_channelID(
            this: Allocated<Self>,
            in_device: Option<&IOBluetoothDevice>,
            in_channel_id: BluetoothRFCOMMChannelID,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "IOBluetoothObject", feature = "IOBluetoothRFCOMMChannel"))]
        /// Initializes a Bluetooth-based OBEX Session using an incoming RFCOMM channel.
        ///
        /// Parameter `inChannelID`: RFCOMM channel ID of the desired channel to be used.
        ///
        /// Parameter `inEventSelector`: The selector to be called when an event is received.
        ///
        /// Parameter `inEventSelectorTarget`: The target object that get the selector message.
        ///
        /// Parameter `refCon`: caller reference constant, pass whatever you want, it will be returned to you in the selector.
        ///
        /// Returns:
        ///
        /// # Safety
        ///
        /// - `in_event_selector` must be a valid selector.
        /// - `in_event_selector_target` should be of the correct type.
        /// - `in_event_selector_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(initWithIncomingRFCOMMChannel:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIncomingRFCOMMChannel_eventSelector_selectorTarget_refCon(
            this: Allocated<Self>,
            in_channel: Option<&IOBluetoothRFCOMMChannel>,
            in_event_selector: Option<Sel>,
            in_event_selector_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> Option<Retained<Self>>;

        #[cfg(all(feature = "IOBluetoothObject", feature = "IOBluetoothRFCOMMChannel"))]
        /// Get the Bluetooth RFCOMM channel being used by the session object.
        ///
        /// Returns: A IOBluetoothRFCOMMChannel object.
        ///
        /// This could potentially be nil even though you have a valid OBEX session, because the RFCOMM channel is
        /// only valid when the session is connected.
        #[unsafe(method(getRFCOMMChannel))]
        #[unsafe(method_family = none)]
        pub unsafe fn getRFCOMMChannel(&self) -> Option<Retained<IOBluetoothRFCOMMChannel>>;

        #[cfg(all(feature = "IOBluetoothDevice", feature = "IOBluetoothObject"))]
        /// Get the Bluetooth Device being used by the session object.
        ///
        /// Returns: An IOBluetoothDevice object.
        #[unsafe(method(getDevice))]
        #[unsafe(method_family = none)]
        pub unsafe fn getDevice(&self) -> Option<Retained<IOBluetoothDevice>>;

        /// Sends the next block of data trough the rfcomm channel.
        ///
        /// Returns:
        /// Since a send in the rfcomm channel is broken in multiple write calls (this actually is true only if the size is grater
        /// than the rfcomm MTU). Each write call is performed by sendBufferTroughChannel. This should never need to be overwritten.
        #[unsafe(method(sendBufferTroughChannel))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendBufferTroughChannel(&self) -> IOReturn;

        /// If the transmission was stopeed due to the lack of buffers this call restarts it.
        ///
        /// Returns:
        /// If the transmission was stopeed due to the lack of buffers this call restarts it.
        #[unsafe(method(restartTransmission))]
        #[unsafe(method_family = none)]
        pub unsafe fn restartTransmission(&self);

        /// Tells whether the target device is a Mac by checking its service record.
        ///
        /// Returns: TRUE only if device service record has Mac entry, FALSE for all else.
        ///
        /// Tells whether the target device is a Mac by checking its service record.
        #[unsafe(method(isSessionTargetAMac))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSessionTargetAMac(&self) -> bool;

        #[cfg(feature = "OBEX")]
        /// An OBEXSession override. When this is called by the session baseclass, we will attempt to open the
        /// transport connection. In our case, this would be an RFCOMM channel to another Bluetooth device.
        ///
        /// Returns: Success or failure code.
        ///
        /// Your selector should have the following signature:
        ///
        /// -(void)transportConnectionSelector:(id)refcon        status:(OBEXError)status;
        ///
        /// Thus you could use it with openTransportConnection like this:
        ///
        /// OBEXError    error = [anOBEXSession    openTransportConnection:
        /// sel!( transportConnectionSelector:status: )
        /// selectorTarget:self
        /// refCon:anOBEXSession];    // or whatever you want to pass as a refCon...
        ///
        /// Be sure to check the status code! Assume the connection was not opened unless status is kOBEXSuccess.
        ///
        /// # Safety
        ///
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(openTransportConnection:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openTransportConnection_selectorTarget_refCon(
            &self,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        /// An OBEXSession override. When this is called by the session baseclass, we will return whether or not we
        /// have a transport connection established to another OBEX server/client. In our case we will tell whether
        /// or not the RFCOMM channel to a remote device is still open.
        ///
        /// Returns: True or false, whether there is already an open transport connection for this OBEX session.
        #[unsafe(method(hasOpenTransportConnection))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasOpenTransportConnection(&self) -> Boolean;

        #[cfg(feature = "OBEX")]
        /// An OBEXSession override. When this is called by the session baseclass, we will close the transport
        /// connection if it is opened. In our case, it will be the RFCOMM channel that needs closing.
        ///
        /// Returns: Success or failure code, describing whether the call succeeded in closing the transport connection successfully.
        #[unsafe(method(closeTransportConnection))]
        #[unsafe(method_family = none)]
        pub unsafe fn closeTransportConnection(&self) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// An OBEXSession override. When this is called by the session baseclass, we will send the data we are given
        /// over our transport connection. If none is open, we could try to open it, or just return an error. In our
        /// case, it will be sent over the RFCOMM channel.
        ///
        /// Returns: Success or failure code, describing whether the call succeeded in writing the data to the transport.
        ///
        /// # Safety
        ///
        /// `in_data_to_send` must be a valid pointer.
        #[unsafe(method(sendDataToTransport:dataLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDataToTransport_dataLength(
            &self,
            in_data_to_send: *mut c_void,
            in_data_length: usize,
        ) -> OBEXError;

        /// Allows you to set the selector to be used when a transport connection is opened, or fails to open.
        ///
        /// Parameter `inEventSelector`: Selector to call on the target.
        ///
        /// Parameter `inEventSelectorTarget`: Target to be called with the selector.
        ///
        /// Parameter `inUserRefCon`: User's refCon that will get passed to them when their selector is invoked.
        ///
        /// You do not need to call this on the session typically, unless you have subclassed the OBEXSession to
        /// implement a new transport and that transport supports async opening of connections. If it does not support
        /// async open, then using this is pointless.
        ///
        /// # Safety
        ///
        /// - `in_selector` must be a valid selector.
        /// - `in_selector_target` should be of the correct type.
        /// - `in_selector_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(setOpenTransportConnectionAsyncSelector:target:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOpenTransportConnectionAsyncSelector_target_refCon(
            &self,
            in_selector: Option<Sel>,
            in_selector_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        );

        #[cfg(all(feature = "OBEX", feature = "OBEXBluetooth"))]
        /// For C API support. Allows you to set the callback to be invoked when the OBEX connection is actually opened.
        ///
        /// Parameter `inCallback`: function to call on the target.
        ///
        /// Parameter `inUserRefCon`: user's reference constant, will be returned on the callback.
        ///
        /// # Safety
        ///
        /// - `in_callback` must be implemented correctly.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(setOBEXSessionOpenConnectionCallback:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOBEXSessionOpenConnectionCallback_refCon(
            &self,
            in_callback: IOBluetoothOBEXSessionOpenConnectionCallback,
            in_user_ref_con: *mut c_void,
        );
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "OBEXSession")]
impl IOBluetoothOBEXSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
