//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An instance of this class represents a single SDP service record.
    ///
    /// As a service record, an instance of this class has an NSDictionary of service attributes.
    /// It also has a link to the IOBluetoothDevice that the service belongs to.  The service
    /// dictionary is keyed off of the attribute ID of each attribute represented as an NSNumber.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothsdpservicerecord?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct IOBluetoothSDPServiceRecord;
);

#[cfg(feature = "objc2-foundation")]
extern_conformance!(
    unsafe impl NSCoding for IOBluetoothSDPServiceRecord {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for IOBluetoothSDPServiceRecord {}
);

#[cfg(feature = "objc2-foundation")]
extern_conformance!(
    unsafe impl NSSecureCoding for IOBluetoothSDPServiceRecord {}
);

impl IOBluetoothSDPServiceRecord {
    extern_methods!(
        #[cfg(feature = "objc2-foundation")]
        /// Adds a service to the local SDP server.
        ///
        /// Returns: Returns an IOBluetoothSDPServiceRecord * with the attributes specified in the provided dictionary.
        ///
        ///
        /// Each entry in the dictionary representing the service contains the individual attributes.  Each
        /// attribute in the dict is keyed by a string that must begin with a hex number representing the
        /// attribute ID.  The key string may contain additional characters if desired as long as they
        /// follow a space after the ID hex string.  The attribute value must follow the dictionary format
        /// described by IOBluetoothSDPDataElement.  This dictionary format allows a service dict to be
        /// created as a plist file and then loaded into the system rather than built up in code.  See the
        /// example code for an example of how can be done.
        ///
        /// If the service record handle, L2CAP PSM or RFCOMM channel ID specified in the dictionary are in
        /// use, an alternate one will be assigned.
        ///
        /// In addition to attributes that represent the service itself, additional attributes may be specified
        /// that control the local behavior of the service.  To specify these local attributes, an additional
        /// property titled "LocalAttributes" may be added to the root of the service dict.  The value of this
        /// property must be a dictionary that contains the individual local attributes.
        ///
        /// Currently, only two local attributes are supported: "Persistent" and "TargetApplication".
        ///
        /// The "Persistent" local attribute must be either a boolean or number representing whether the service
        /// should be persistent.  A persistent service will be saved off and restored any time the Bluetooth
        /// hardware is present.  It will persist through reboots and can only be removed by calling
        /// IOBluetoothRemoveServiceWithRecordHandle(void).  This attribute is optional.  By default, if no
        /// "Persistent" local property is present,    the service will only exist temporarily.  It will
        /// be removed either when IOBluetoothRemoveServiceWithRecordHandle(void) is called or when the client
        /// application exits.
        ///
        /// The "TargetApplication" local attribute is used to specify an application to be launched when a
        /// remote device attempts to connect to the service (by opening either an L2CAP or RFCOMM channel of
        /// the type specified in the service).  This value must be a string representing the absolute path to
        /// the target executable (not just the .app wrapper - i.e.
        /// /System/Library/CoreServices/OBEXAgent.app/Contents/MacOS/OBEXAgent).  This attribute is optional.
        /// If no "TargetApplication" local attribute is specified, no special action will take place when an
        /// incoming connection to the service is created.  It is up to the client to be monitoring for the
        /// connection and to do the right thing when one appears.
        ///
        /// The "LocalAttributes" property is optional.  If it is not specified, by default the created service
        /// is transient and will be removed when the client exits.
        ///
        /// Additional local attributes to further control incoming services will be added in the future.
        ///
        ///
        /// Parameter `serviceDict`: A dictionary containing the attributes for the new service
        ///
        /// # Safety
        ///
        /// - `service_dict` generic should be of the correct type.
        /// - `service_dict` might not allow `None`.
        #[unsafe(method(publishedServiceRecordWithDictionary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn publishedServiceRecordWithDictionary(
            service_dict: Option<&NSDictionary>,
        ) -> Option<Retained<Self>>;

        /// Removes the service from the local SDP server.
        ///
        /// Returns: Returns kIOReturnSuccess if successful.
        #[unsafe(method(removeServiceRecord))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeServiceRecord(&self) -> IOReturn;

        #[cfg(all(
            feature = "IOBluetoothDevice",
            feature = "IOBluetoothObject",
            feature = "objc2-foundation"
        ))]
        /// Returns an IOBluetoothSDPServiceRecord * with the attributes specified in the provided service dictionary. Provide
        /// a pointer to an IOBlueotothDevice if you wish to associate the record to a specific IOBluetoothDevice.
        ///
        /// Returns: Returns an IOBluetoothSDPServiceRecord * with the attributes specified in the provided dictionary.
        ///
        /// # Safety
        ///
        /// - `service_dict` generic should be of the correct type.
        /// - `service_dict` might not allow `None`.
        /// - `device` might not allow `None`.
        #[unsafe(method(withServiceDictionary:device:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withServiceDictionary_device(
            service_dict: Option<&NSDictionary>,
            device: Option<&IOBluetoothDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(all(
            feature = "IOBluetoothDevice",
            feature = "IOBluetoothObject",
            feature = "objc2-foundation"
        ))]
        /// Returns an initialized IOBluetoothSDPServiceRecord * with the attributes specified in the provided service dictionary. Provide
        /// a pointer to an IOBlueotothDevice if you wish to associate the record to a specific IOBluetoothDevice.
        ///
        /// Returns: Returns an initialized IOBluetoothSDPServiceRecord * with the attributes specified in the provided dictionary.
        ///
        /// # Safety
        ///
        /// - `service_dict` generic should be of the correct type.
        /// - `service_dict` might not allow `None`.
        /// - `device` might not allow `None`.
        #[unsafe(method(initWithServiceDictionary:device:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithServiceDictionary_device(
            this: Allocated<Self>,
            service_dict: Option<&NSDictionary>,
            device: Option<&IOBluetoothDevice>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Method call to convert an IOBluetoothSDPServiceRecordRef into an IOBluetoothSDPServiceRecord *.
        ///
        /// Parameter `sdpServiceRecordRef`: IOBluetoothSDPServiceRecordRef for which an IOBluetoothSDPServiceRecord * is desired.
        ///
        /// Returns: Returns the IOBluetoothSDPServiceRecord * for the given IOBluetoothSDPServiceRecordRef.
        ///
        /// # Safety
        ///
        /// `sdp_service_record_ref` might not allow `None`.
        #[unsafe(method(withSDPServiceRecordRef:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withSDPServiceRecordRef(
            sdp_service_record_ref: Option<&IOBluetoothSDPServiceRecordRef>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Returns an IOBluetoothSDPServiceRecordRef representation of the target IOBluetoothSDPServiceRecord object.
        ///
        /// Returns: Returns an IOBluetoothSDPServiceRecordRef representation of the target IOBluetoothSDPServiceRecord object.
        #[unsafe(method(getSDPServiceRecordRef))]
        #[unsafe(method_family = none)]
        pub unsafe fn getSDPServiceRecordRef(
            &self,
        ) -> Option<Retained<IOBluetoothSDPServiceRecordRef>>;

        #[cfg(all(feature = "IOBluetoothDevice", feature = "IOBluetoothObject"))]
        /// Returns the IOBluetoothDevice that the target service belongs to.
        ///
        /// If the service is a local service (i.e. one the current host is vending out), then nil is returned.
        ///
        /// Returns: Returns the IOBluetoothDevice that the target service belongs to.  If the service is one the local host
        /// is vending, then nil is returned.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        pub unsafe fn device(&self) -> Option<Retained<IOBluetoothDevice>>;

        #[cfg(all(feature = "IOBluetoothDevice", feature = "IOBluetoothObject"))]
        #[deprecated]
        #[unsafe(method(getDevice))]
        #[unsafe(method_family = none)]
        pub unsafe fn getDevice(&self) -> Option<Retained<IOBluetoothDevice>>;

        #[cfg(feature = "objc2-foundation")]
        /// Returns an NSDictionary containing the attributes for the service.
        ///
        /// The attribute dictionary is keyed off of the attribute id represented as an NSNumber.  The values
        /// in the NSDictionary are IOBluetoothSDPDataElement objects representing the data element for the
        /// given attribute.
        ///
        /// Returns: Returns an NSDictionary containing the attributes for the target service.
        #[unsafe(method(attributes))]
        #[unsafe(method_family = none)]
        pub unsafe fn attributes(&self) -> Retained<NSDictionary>;

        #[cfg(feature = "objc2-foundation")]
        #[deprecated]
        #[unsafe(method(getAttributes))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAttributes(&self) -> Option<Retained<NSDictionary>>;

        #[cfg(all(feature = "Bluetooth", feature = "IOBluetoothSDPDataElement"))]
        /// Returns the data element for the given attribute ID in the target service.
        ///
        /// Parameter `attributeID`: The attribute ID of the desired attribute.
        ///
        /// Returns: Returns the data element for the given attribute ID in the target service.  If the service does not
        /// contain an attribute with the given ID, then nil is returned.
        #[unsafe(method(getAttributeDataElement:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAttributeDataElement(
            &self,
            attribute_id: BluetoothSDPServiceAttributeID,
        ) -> Option<Retained<IOBluetoothSDPDataElement>>;

        #[cfg(feature = "objc2-foundation")]
        /// Returns the name of the service.
        ///
        /// This is currently implemented to simply return the attribute with an id of 0x0100.  In
        /// the future, it will be extended to allow name localization based on the user's chosen
        /// language or other languages.
        ///
        /// Returns: Returns the name of the target service.
        #[unsafe(method(getServiceName))]
        #[unsafe(method_family = none)]
        pub unsafe fn getServiceName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "Bluetooth")]
        /// Allows the discovery of the RFCOMM channel ID assigned to the service.
        ///
        /// This method will search through the ProtoclDescriptorList attribute to find an entry
        /// with the RFCOMM UUID (UUID16: 0x0003).  If one is found, it gets the second element of
        /// the data element sequence and sets the rfcommChannelID pointer to it.  The channel ID
        /// only gets set when kIOReturnSuccess is returned.
        ///
        /// Parameter `rfcommChannelID`: A pointer to the location that will get the found RFCOMM channel ID.
        ///
        /// Returns: Returns kIOReturnSuccess if the channel ID is found.
        ///
        /// # Safety
        ///
        /// `rfcomm_channel_id` must be a valid pointer.
        #[unsafe(method(getRFCOMMChannelID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getRFCOMMChannelID(
            &self,
            rfcomm_channel_id: *mut BluetoothRFCOMMChannelID,
        ) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Allows the discovery of the L2CAP PSM assigned to the service.
        ///
        /// This method will search through the ProtoclDescriptorList attribute to find an entry
        /// with the L2CAP UUID (UUID16: 0x0100).  If one is found, it gets the second element of
        /// the data element sequence and sets the outPSM pointer to it.  The PSM value
        /// only gets set when kIOReturnSuccess is returned.
        ///
        /// Parameter `outPSM`: A pointer to the location that will get the found L2CAP PSM.
        ///
        /// Returns: Returns kIOReturnSuccess if the PSM is found.
        ///
        /// # Safety
        ///
        /// `out_psm` must be a valid pointer.
        #[unsafe(method(getL2CAPPSM:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getL2CAPPSM(&self, out_psm: *mut BluetoothL2CAPPSM) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Allows the discovery of the service record handle assigned to the service.
        ///
        /// This method will search through the attributes to find the one representing the
        /// service record handle.  If one is found the outServiceRecordHandle param is set
        /// with the value.  The outServiceRecordHandle value only gets set when kIOReturnSuccess
        /// is returned.
        ///
        /// Parameter `outServiceRecordHandle`: A pointer to the location that will get the found service record handle.
        ///
        /// Returns: Returns kIOReturnSuccess if the service record handle is found.
        ///
        /// # Safety
        ///
        /// `out_service_record_handle` must be a valid pointer.
        #[unsafe(method(getServiceRecordHandle:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getServiceRecordHandle(
            &self,
            out_service_record_handle: *mut BluetoothSDPServiceRecordHandle,
        ) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Returns TRUE the UUID16 is found in the target service.
        ///
        /// NOTE: This method is only available in Mac OS X 10.7 or later.
        ///
        /// Parameter `uuid16`: A BluetoothSDPUUID16 to search for in the target service.
        ///
        /// Returns: Returns TRUE if the UUID16 is present in the service.
        #[unsafe(method(matchesUUID16:))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchesUUID16(&self, uuid16: BluetoothSDPUUID16) -> bool;

        #[cfg(feature = "objc2-foundation")]
        /// Returns TRUE if ALL of the UUIDs in the given array is found in the target service.
        ///
        /// The given array should contain IOBluetoothSDPUUID objects.  It only returns TRUE if all of
        /// the UUIDs are found.  This method is like hasServiceFromArray: except that it requires that
        /// all UUIDs match instead of any of them matching.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
        ///
        /// Parameter `array`: An NSArray of IOBluetoothSDPUUID objects to search for in the target service.
        ///
        /// Returns: Returns TRUE if all of the given UUIDs are present in the service.
        ///
        /// # Safety
        ///
        /// - `uuid_array` generic should be of the correct type.
        /// - `uuid_array` might not allow `None`.
        #[unsafe(method(matchesUUIDArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchesUUIDArray(&self, uuid_array: Option<&NSArray>) -> bool;

        #[cfg(feature = "objc2-foundation")]
        /// Returns TRUE any of the UUID arrays in the search array match the target service.
        ///
        /// The given array should contain NSArray objects.  Each sub-NSArray should contain
        /// IOBluetoothSDPUUID objects.  In turn, each sub-NSArray gets passed to -matchesUUIDArray:
        /// If any of those returns TRUE, then the search stops and TRUE is returned.
        /// Essentially the master NSArray contains the OR operations and each sub-array contains
        /// the AND operations.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
        ///
        /// Parameter `array`: An NSArray of NSArrays of IOBluetoothSDPUUID objects.
        ///
        /// Returns: Returns TRUE if any of the UUID arrays match.
        ///
        /// # Safety
        ///
        /// - `search_array` generic should be of the correct type.
        /// - `search_array` might not allow `None`.
        #[unsafe(method(matchesSearchArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchesSearchArray(&self, search_array: Option<&NSArray>) -> bool;

        #[cfg(feature = "objc2-foundation")]
        /// Returns TRUE if any one of the UUIDs in the given array is found in the target service.
        ///
        /// The given array should contain IOBluetoothSDPUUID objects.  It is currently implemented
        /// such that it returns TRUE if any of the UUIDs are found.  However in the future, it is likely
        /// that this will change to more closely match the functionality in the SDP spec so that it only
        /// returns TRUE if all of the given UUIDs are present.  That way, both AND and OR comparisons
        /// can be implemented.  Please make a note of this potential change.
        ///
        /// Parameter `array`: An NSArray of IOBluetoothSDPUUID objects to search for in the target service.
        ///
        /// Returns: Returns TRUE if any of the given UUIDs are present in the service.
        ///
        /// # Safety
        ///
        /// - `array` generic should be of the correct type.
        /// - `array` might not allow `None`.
        #[unsafe(method(hasServiceFromArray:))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasServiceFromArray(&self, array: Option<&NSArray>) -> bool;

        #[cfg(feature = "objc2-foundation")]
        /// Returns a sorted array of SDP attributes
        ///
        /// This method will walk all the elements of the service record and return an array of
        /// IOBluetoothSDPServiceAttribute objects sorted by attributeID
        ///
        /// Returns: Returns a sorted array of SDP attributes
        #[unsafe(method(sortedAttributes))]
        #[unsafe(method_family = none)]
        pub unsafe fn sortedAttributes(&self) -> Retained<NSArray>;
    );
}

/// Methods declared on superclass `NSObject`.
impl IOBluetoothSDPServiceRecord {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
