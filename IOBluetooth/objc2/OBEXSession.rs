//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
use objc2::__framework_prelude::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/opaqueprivobexsessiondata?language=objc)
#[repr(C)]
#[derive(Debug)]
pub struct OpaquePrivOBEXSessionData {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

unsafe impl RefEncode for OpaquePrivOBEXSessionData {
    const ENCODING_REF: Encoding =
        Encoding::Pointer(&Encoding::Struct("OpaquePrivOBEXSessionData", &[]));
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/privobexsessiondataref?language=objc)
pub type PrivOBEXSessionDataRef = *mut OpaquePrivOBEXSessionData;

/// Pass these types in the OBEXTransportEvent, and then pass the struct on to the session object once you
/// have filled it out. This is how you can communicate with the session when events happen - if data is
/// received, the type will be 'kOBEXTransportEventTypeDataReceived'. if an error has occurred on your transport,
/// like the remote target died, you can send a status event with a non-zero value. Since session objects will
/// receive this status code on their event handlers, you should try to pass a useful status/error code, such as
/// an IOReturn value.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obextransporteventtype?language=objc)
pub type OBEXTransportEventType = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obextransporteventtypes?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXTransportEventTypes(pub c_uint);
impl OBEXTransportEventTypes {
    #[doc(alias = "kOBEXTransportEventTypeDataReceived")]
    pub const DataReceived: Self = Self(0x44617441);
    #[doc(alias = "kOBEXTransportEventTypeStatus")]
    pub const Status: Self = Self(0x53746154);
}

unsafe impl Encode for OBEXTransportEventTypes {
    const ENCODING: Encoding = c_uint::ENCODING;
}

unsafe impl RefEncode for OBEXTransportEventTypes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obextransportevent?language=objc)
#[cfg(feature = "OBEX")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXTransportEvent {
    pub r#type: OBEXTransportEventType,
    pub status: OBEXError,
    pub dataPtr: *mut c_void,
    pub dataLength: usize,
}

#[cfg(feature = "OBEX")]
unsafe impl Encode for OBEXTransportEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXTransportEvent",
        &[
            <OBEXTransportEventType>::ENCODING,
            <OBEXError>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "OBEX")]
unsafe impl RefEncode for OBEXTransportEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsession?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct OBEXSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for OBEXSession {}
);

impl OBEXSession {
    extern_methods!(
        #[cfg(feature = "OBEX")]
        /// Initiate an OBEX connection to a device. Causes underlying transport (Bluetooth, et al) to attempt to connect
        /// to a remote device. After success, an OBEX connect packet is sent to establish the OBEX Connection.
        ///
        /// Parameter `inFlags`: OBEX connect flags. See OBEX.h for possibilities.
        ///
        /// Parameter `inMaxPacketLength`: Maximum packet size you want to support. May be negotiated down, depending on
        /// target device.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use the
        /// provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXConnectHandler:(const OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// transport. You will receive a response to your command on your selector. If you have already established an OBEX
        /// connection and you call this again you will get an 'kOBEXSessionAlreadyConnectedError' as a result.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXConnect:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXConnect_maxPacketLength_optionalHeaders_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_flags: OBEXFlags,
            in_max_packet_length: OBEXMaxPacketLength,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send an OBEX Disconnect command to the session's target. THIS DOES NOT necessarily close the underlying transport
        /// connection. Deleting the session will ensure that closure.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use
        /// the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXDisconnectHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// transport. You will receive a response to your command on your selector.
        /// Be careful not to exceed the max packet length in your optional headers, or your command will be rejected.
        /// It is recommended that you call getMaxPacketLength on your session before issuing this command so
        /// you know how much data the session's target will accept in a single transaction.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXDisconnect:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXDisconnect_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send an OBEX Put command to the session's target.
        ///
        /// Parameter `isFinalChunk`: Specify if this request is complete in one shot - that all the headers you are
        /// supplying will fit in the negotiated max packet length.
        ///
        /// Parameter `inHeadersData`: Can be NULL. Ptr to some data you want to send as your headers, such as Length,
        /// Name, etc. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void)
        /// for convenience.
        ///
        /// Parameter `inHeadersDataLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inBodyData`: Can be NULL. Ptr to some data you want to send as your BODY header. Do not construct a
        /// real OBEX header here, it will be done for you - just pass a pointer to your
        /// data, we'll do the rest. HOWEVER, be aware that some overhead (3 bytes) will be added
        /// to the data in constructing the BODY header for you.
        ///
        /// Parameter `inBodyDataLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXPutHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// transport. You will receive a response to your command on your selector.
        ///
        /// # Safety
        ///
        /// - `in_headers_data` must be a valid pointer.
        /// - `in_body_data` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXPut:headersData:headersDataLength:bodyData:bodyDataLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXPut_headersData_headersDataLength_bodyData_bodyDataLength_eventSelector_selectorTarget_refCon(
            &self,
            is_final_chunk: Boolean,
            in_headers_data: *mut c_void,
            in_headers_data_length: usize,
            in_body_data: *mut c_void,
            in_body_data_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send an OBEX Get command to the session's target.
        ///
        /// Parameter `isFinalChunk`: Specify if this request is complete in one shot - that all the headers you are
        /// supplying will fit in the negotiated max packet length.
        ///
        /// Parameter `inHeadersData`: Can be NULL. Ptr to some data you want to send as your headers, such as Length,
        /// Name, etc. Use the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void)
        /// for your convenience.
        ///
        /// Parameter `inHeadersDataLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXGetHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// transport. You will receive a response to your command on your selector.
        ///
        /// # Safety
        ///
        /// - `in_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXGet:headers:headersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXGet_headers_headersLength_eventSelector_selectorTarget_refCon(
            &self,
            is_final_chunk: Boolean,
            in_headers: *mut c_void,
            in_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send an OBEX Abort command to the session's target.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use
        /// the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXAbortHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// transport. You will receive a response to your command on your selector.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXAbort:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXAbort_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send an OBEX SetPath command to the session's target.
        ///
        /// Parameter `inFlags`: OBEX setpath flags. See OBEX.h for possibilities.
        ///
        /// Parameter `inConstants`: OBEX setpath constants. See OBEX.h for possibilities.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use
        /// the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXSetPathHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// transport. You will receive a response to your command on your selector.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXSetPath:constants:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXSetPath_constants_optionalHeaders_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_flags: OBEXFlags,
            in_constants: OBEXConstants,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send a connect response to a session's target.
        ///
        /// Parameter `inFlags`: OBEX connect flags. See OBEX.h for possibilities.
        ///
        /// Parameter `inConstants`: OBEX connect constants. See OBEX.h for possibilities.
        ///
        /// Parameter `inMaxPacketLength`: Maximum packet size you want your OBEX session to communicate with. This MUST be
        /// lower than the max packet size the client has reported to you in the connect command
        /// you received from it.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use
        /// the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXConnectResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// underlying OBEX transport. You will receive any responses to your command response on your selector.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXConnectResponse:flags:maxPacketLength:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXConnectResponse_flags_maxPacketLength_optionalHeaders_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_response_op_code: OBEXOpCode,
            in_flags: OBEXFlags,
            in_max_packet_length: OBEXMaxPacketLength,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send a disconnect response to a session's target.
        ///
        /// Parameter `inMaxPacketLength`: Maximum packet size you want your OBEX session to communicate with. This MUST be
        /// lower than the max packet size the client has reported to you in the connect command
        /// you received from it.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use
        /// the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXDisconnectResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// underlying OBEX transport. You will receive any responses to your command response on your selector.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXDisconnectResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXDisconnectResponse_optionalHeaders_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_response_op_code: OBEXOpCode,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send a put response to a session's target.
        ///
        /// Parameter `inMaxPacketLength`: Maximum packet size you want your OBEX session to communicate with. This MUST be
        /// lower than the max packet size the client has reported to you in the connect command
        /// you received from it.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use
        /// the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXPutResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// underlying OBEX transport. You will receive any responses to your command response on your selector.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXPutResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXPutResponse_optionalHeaders_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_response_op_code: OBEXOpCode,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send a get response to a session's target.
        ///
        /// Parameter `inMaxPacketLength`: Maximum packet size you want your OBEX session to communicate with. This MUST be
        /// lower than the max packet size the client has reported to you in the connect command
        /// you received from it.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use
        /// the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXGetResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// underlying OBEX transport. You will receive any responses to your command response on your selector.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXGetResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXGetResponse_optionalHeaders_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_response_op_code: OBEXOpCode,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send a abort response to a session's target.
        ///
        /// Parameter `inMaxPacketLength`: Maximum packet size you want your OBEX session to communicate with. This MUST be
        /// lower than the max packet size the client has reported to you in the connect command
        /// you received from it.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use
        /// the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXAbortResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// underlying OBEX transport. You will receive any responses to your command response on your selector.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXAbortResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXAbortResponse_optionalHeaders_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_response_op_code: OBEXOpCode,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Send a set path response to a session's target.
        ///
        /// Parameter `inMaxPacketLength`: Maximum packet size you want your OBEX session to communicate with. This MUST be
        /// lower than the max packet size the client has reported to you in the connect command
        /// you received from it.
        ///
        /// Parameter `inOptionalHeaders`: Can be NULL. Ptr to some data you want to send as your optional headers. Use
        /// the provided header contruction kit in OBEX.h and OBEXHeadersToBytes(void) for convenience.
        ///
        /// Parameter `inOptionalHeadersLength`: Length of data in ptr passed in above.
        ///
        /// Parameter `inSelector`: A VALID selector to be called when something interesting happens due to this call.
        /// Selector in your target object MUST have the following signature, or it
        /// will not be called properly (look for error messages in Console.app):
        ///
        /// - (void)OBEXSetPathResponseHandler:(const  OBEXSessionEvent*)inSessionEvent;
        ///
        ///
        /// Parameter `inTarget`: A VALID target object for the selector.
        ///
        /// Parameter `inUserRefCon`: Whatever you want to pass here. It will be passed back to you in the refCon portion of the
        /// OBEXSessionEvent struct. nil is, of course, OK here.
        ///
        /// Returns: An error code value on failure (see OBEX.h and IOReturn.h for possible return values). 0 (kOBEXSuccess) if successful.
        ///
        /// A NULL selector or target will result in an error. After return, the data passed in will have been sent over the
        /// underlying OBEX transport. You will receive any responses to your command response on your selector.
        ///
        /// # Safety
        ///
        /// - `in_optional_headers` must be a valid pointer.
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(OBEXSetPathResponse:optionalHeaders:optionalHeadersLength:eventSelector:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn OBEXSetPathResponse_optionalHeaders_optionalHeadersLength_eventSelector_selectorTarget_refCon(
            &self,
            in_response_op_code: OBEXOpCode,
            in_optional_headers: *mut c_void,
            in_optional_headers_length: usize,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Determine the maximum amount of data you can send in a particular command as an OBEX client session.
        ///
        /// Parameter `inOpCode`: The opcode you are interested in sending (as a client).
        ///
        /// Returns: The maximum amount of data a particular packet can handle, after accounting for any command overhead.
        ///
        /// Each OBEX Command has a certain amount of overhead. Since the negotiated max packet length does
        /// not indicate what the maximum data amount you can send in a particular command's packet, you can
        /// use this function to determine how much data to provide in optional headers or body data headers.
        #[unsafe(method(getAvailableCommandPayloadLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAvailableCommandPayloadLength(
            &self,
            in_op_code: OBEXOpCode,
        ) -> OBEXMaxPacketLength;

        #[cfg(feature = "OBEX")]
        /// Determine the maximum amount of data you can send in a particular command response as an OBEX server session.
        ///
        /// Parameter `inOpCode`: The opcode you are interested in responding to (as a server).
        ///
        /// Returns: The maximum amount of data a particular packet can handle, after accounting for any command response overhead.
        ///
        /// Each OBEX Command response has a certain amount of overhead. Since the negotiated max packet length does
        /// not indicate what the maximum data amount you can send in a particular response's packet, you can
        /// use this function to determine how much data to provide in optional headers or body data headers.
        #[unsafe(method(getAvailableCommandResponsePayloadLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAvailableCommandResponsePayloadLength(
            &self,
            in_op_code: OBEXOpCode,
        ) -> OBEXMaxPacketLength;

        #[cfg(feature = "OBEX")]
        /// Gets current max packet length.
        ///
        /// Returns: Max packet length.
        ///
        /// This value *could* change before and after a connect command has been sent or a connect
        /// command response has been received, since the recipient could negotiate a lower max packet size.
        #[unsafe(method(getMaxPacketLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn getMaxPacketLength(&self) -> OBEXMaxPacketLength;

        /// Has a successful connect packet been sent and received? This API tells you so.
        ///
        /// Returns: True or false, we are OBEX-connected to another OBEX entity.
        ///
        /// A "transport" connection may exist (such as a Bluetooth baseband connection), but the OBEX connection
        /// may not be established over that transport. If it has been, this function returns true.
        #[unsafe(method(hasOpenOBEXConnection))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasOpenOBEXConnection(&self) -> bool;

        #[cfg(feature = "OBEX")]
        /// Sets the C-API callback used when the session recieves data.
        ///
        /// Parameter `inEventCallback`: Function to callback. Should be non-NULL, unless you are attempting to clear the
        /// callback, but doing that doesn't make much sense.
        ///
        /// This is really not intended for client sessions. Only subclasses would really be interested in using this. They
        /// should set these when their subclass object is created, because otherwise they will have no way of receiving
        /// the initial command data packet. This is a partner to setEventRefCon, described below.
        ///
        /// # Safety
        ///
        /// `in_event_callback` must be implemented correctly.
        #[unsafe(method(setEventCallback:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEventCallback(&self, in_event_callback: OBEXSessionEventCallback);

        /// Sets the C-API callback refCon used when the session recieves data.
        ///
        /// Parameter `inRefCon`: User's refCon that will get passed when their event callback is invoked.
        ///
        /// This is really not intended for client sessions. Only subclasses would really be interested in using this. They
        /// should set these when their subclass object is created, because otherwise they will have no context in their
        /// callback.
        ///
        /// # Safety
        ///
        /// `in_ref_con` must be a valid pointer.
        #[unsafe(method(setEventRefCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEventRefCon(&self, in_ref_con: *mut c_void);

        /// Allow you to set a selector to be called when events occur on the OBEX session.
        ///
        /// Parameter `inEventSelector`: Selector to call on the target.
        ///
        /// Parameter `inEventSelectorTarget`: Target to be called with the selector.
        ///
        /// Parameter `inUserRefCon`: User's refCon that will get passed when their event callback is invoked.
        ///
        /// Really not needed to be used, since the event selector will get set when an OBEX command is sent out.
        ///
        /// # Safety
        ///
        /// - `in_event_selector` must be a valid selector.
        /// - `in_event_selector_target` should be of the correct type.
        /// - `in_event_selector_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(setEventSelector:target:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEventSelector_target_refCon(
            &self,
            in_event_selector: Option<Sel>,
            in_event_selector_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        );

        #[cfg(feature = "OBEX")]
        /// Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is
        /// received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch
        /// the data. If you do not handle this case, your server session will not work, guaranteed.
        ///
        /// Parameter `event`: New event received from the transport.
        ///
        /// Tranport subclasses must call this for OBEX server sessions to work!
        ///
        /// # Safety
        ///
        /// `event` must be a valid pointer.
        #[unsafe(method(serverHandleIncomingData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn serverHandleIncomingData(&self, event: *mut OBEXTransportEvent);

        #[cfg(feature = "OBEX")]
        /// Tranport subclasses need to invoke this from their own data-receive handlers. For example, when data is
        /// received over a Bluetooth RFCOMM channel in the IOBluetoothOBEXSession, it in turn calls this to dispatch
        /// the data. If you do not handle this case, your server session will not work, guaranteed.
        ///
        /// Parameter `event`: New event received from the transport.
        ///
        /// Tranport subclasses must call this for OBEX client sessions to work!
        ///
        /// # Safety
        ///
        /// `event` must be a valid pointer.
        #[unsafe(method(clientHandleIncomingData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn clientHandleIncomingData(&self, event: *mut OBEXTransportEvent);

        #[cfg(feature = "OBEX")]
        /// You must override this to send data over your transport. This does nothing by default, it will
        /// return a kOBEXUnsupportedError.
        ///
        /// Parameter `inDataToSend`: Data to shove over the transport to a remote OBEX session.
        ///
        /// Parameter `inDataLength`: Length of data passed in.
        ///
        /// Returns: Return whether or not the transport could send the  data or not. If you are successful, return kOBEXSuccess,
        /// otherwise an interesting error code.
        ///
        /// Tranport subclasses must override this! When called you should send the data over the transport to
        /// the remote session.
        ///
        /// # Safety
        ///
        /// `in_data_to_send` must be a valid pointer.
        #[unsafe(method(sendDataToTransport:dataLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDataToTransport_dataLength(
            &self,
            in_data_to_send: *mut c_void,
            in_data_length: usize,
        ) -> OBEXError;

        #[cfg(feature = "OBEX")]
        /// Opens a transport connection to a device. A Bluetooth connection is one example of a transport.
        ///
        /// Parameter `inSelector`: Selector to call for success, failure or timeout.
        ///
        /// Parameter `inTarget`: Target on which to call the selector.
        ///
        /// Parameter `inUserRefCon`: Caller's reference constant.
        ///
        /// Returns: Should return kOBEXSuccess ( 0 ) on success, otherwise an error code.
        ///
        /// Tranport subclasses must override this! when called you should attempt to open your transport
        /// connection, and if you are successful, return kOBEXSuccess, otherwise an interesting error code.
        ///
        /// # Safety
        ///
        /// - `in_selector` must be a valid selector.
        /// - `in_target` should be of the correct type.
        /// - `in_target` might not allow `None`.
        /// - `in_user_ref_con` must be a valid pointer.
        #[unsafe(method(openTransportConnection:selectorTarget:refCon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openTransportConnection_selectorTarget_refCon(
            &self,
            in_selector: Option<Sel>,
            in_target: Option<&AnyObject>,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;

        /// You must override this - it will be called periodically to determine if a transport connection is open or not.
        ///
        /// Returns: Return whether or not the transport connection is still open.
        ///
        /// Tranport subclasses must override this! When called you simply return if the transport connection is still
        /// open or not.
        #[unsafe(method(hasOpenTransportConnection))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasOpenTransportConnection(&self) -> Boolean;

        #[cfg(feature = "OBEX")]
        /// You must override this - it will be called when the transport connection should be shutdown.
        ///
        /// Returns: Return whether or not the transport connection was closed successfully or not. Return OBEXSuccess ( 0 ) on
        /// success, otherwise an error code.
        ///
        /// Tranport subclasses must override this! When called you should take whatever steps are necessary to
        /// actually close down the transport connection.
        #[unsafe(method(closeTransportConnection))]
        #[unsafe(method_family = none)]
        pub unsafe fn closeTransportConnection(&self) -> OBEXError;
    );
}

/// Methods declared on superclass `NSObject`.
impl OBEXSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
