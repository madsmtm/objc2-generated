//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;

use crate::*;

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothdeviceasynccallbacks?language=objc)
    pub unsafe trait IOBluetoothDeviceAsyncCallbacks {
        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `device` might not allow `None`.
        #[unsafe(method(remoteNameRequestComplete:status:))]
        #[unsafe(method_family = none)]
        unsafe fn remoteNameRequestComplete_status(
            &self,
            device: Option<&IOBluetoothDevice>,
            status: IOReturn,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `device` might not allow `None`.
        #[unsafe(method(connectionComplete:status:))]
        #[unsafe(method_family = none)]
        unsafe fn connectionComplete_status(
            &self,
            device: Option<&IOBluetoothDevice>,
            status: IOReturn,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `device` might not allow `None`.
        #[unsafe(method(sdpQueryComplete:status:))]
        #[unsafe(method_family = none)]
        unsafe fn sdpQueryComplete_status(
            &self,
            device: Option<&IOBluetoothDevice>,
            status: IOReturn,
        );
    }
);

extern_class!(
    /// An instance of IOBluetoothDevice represents a single remote Bluetooth device.
    ///
    /// An IOBluetoothDevice object may exist independent of the existence of a baseband connection
    /// with the target device.  Using this object, a client can request creation and destruction of baseband
    /// connections, and request the opening of L2CAP and RFCOMM channels on the remote device.  Many of the other
    /// APIs in the IOBluetooth framework will return this object, or it's C counterpart (IOBluetoothDeviceRef).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothdevice?language=objc)
    #[unsafe(super(IOBluetoothObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "IOBluetoothObject")]
    pub struct IOBluetoothDevice;
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSCoding for IOBluetoothDevice {}
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSCopying for IOBluetoothDevice {}
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
unsafe impl CopyingHelper for IOBluetoothDevice {
    type Result = Self;
}

#[cfg(feature = "IOBluetoothObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for IOBluetoothDevice {}
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSSecureCoding for IOBluetoothDevice {}
);

#[cfg(feature = "IOBluetoothObject")]
impl IOBluetoothDevice {
    extern_methods!(
        #[cfg(feature = "IOBluetoothUserNotification")]
        /// Allows a client to register for device connect notifications for any connection.
        ///
        /// The given selector will be called on the target observer whenever any device connection is made.
        /// The selector should accept two arguments.  The first is the user notification object.  The second
        /// is the device that was connected.
        ///
        /// Parameter `observer`: Target observer object
        ///
        /// Parameter `inSelector`: Selector to be sent to the observer when a new connection is made
        ///
        /// Returns: Returns an IOBluetoothUserNotification representing the outstanding device connect notification.
        /// To unregister the notification, call -unregister on the returned IOBluetoothUserNotification
        /// object.  If an error is encountered creating the notification, nil is returned.  The returned
        /// IOBluetoothUserNotification object will be valid for as long as the notification is registered.
        /// It is not necessary to retain the result.  Once -unregister is called on it, it will no longer
        /// be valid.
        ///
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `observer` might not allow `None`.
        /// - `in_selector` must be a valid selector.
        #[unsafe(method(registerForConnectNotifications:selector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForConnectNotifications_selector(
            observer: Option<&AnyObject>,
            in_selector: Option<Sel>,
        ) -> Option<Retained<IOBluetoothUserNotification>>;

        #[cfg(feature = "IOBluetoothUserNotification")]
        /// Allows a client to register for device disconnect notification.
        ///
        /// The given selector will be called on the target observer when the target device's connection is
        /// closed.  The selector should contain two arguments.  The first is the user notification object.  The second
        /// is the IOBluetoothDevice that was disconnected.
        ///
        /// Parameter `observer`: Target observer object
        ///
        /// Parameter `inSelector`: Selector to be sent to the observer when the connection is destroyed
        ///
        /// Returns: Returns an IOBluetoothUserNotification representing the outstanding device disconnect notification.
        /// To unregister the notification, call -unregister of the returned IOBluetoothUserNotification
        /// object.  If an error is encountered creating the notification, nil is returned.
        ///
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `observer` might not allow `None`.
        /// - `in_selector` must be a valid selector.
        #[unsafe(method(registerForDisconnectNotification:selector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForDisconnectNotification_selector(
            &self,
            observer: Option<&AnyObject>,
            in_selector: Option<Sel>,
        ) -> Option<Retained<IOBluetoothUserNotification>>;

        #[cfg(feature = "Bluetooth")]
        /// Returns the IOBluetoothDevice object for the given BluetoothDeviceAddress
        ///
        /// Within a single application, there will be only one instance of IOBluetoothDevice for a
        /// given remote device address.
        ///
        /// Parameter `address`: Pointer to a BluetoothDeviceAddress for which an IOBluetoothDevice instance is desired
        ///
        /// Returns: Returns the IOBluetoothDevice object for the given BluetoothDeviceAddress
        ///
        /// # Safety
        ///
        /// `address` must be a valid pointer.
        #[unsafe(method(deviceWithAddress:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceWithAddress(
            address: *const BluetoothDeviceAddress,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "Bluetooth")]
        /// # Safety
        ///
        /// `address` must be a valid pointer.
        #[deprecated]
        #[unsafe(method(withAddress:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withAddress(address: *const BluetoothDeviceAddress)
            -> Option<Retained<Self>>;

        #[cfg(feature = "objc2-foundation")]
        /// Returns the IOBluetoothDevice object for the given BluetoothDeviceAddress
        ///
        /// Within a single application, there will be only one instance of IOBluetoothDevice for a
        /// given remote device address.
        ///
        /// Parameter `address`: Pointer to an NSString containing the BD_ADDR for which an IOBluetoothDevice instance is desired.  The string should be of the form xx:xx:xx:xx:xx:xx
        ///
        /// Returns: Returns the IOBluetoothDevice object for the given BluetoothDeviceAddress
        ///
        /// # Safety
        ///
        /// `address` might not allow `None`.
        #[unsafe(method(deviceWithAddressString:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceWithAddressString(address: Option<&NSString>)
            -> Option<Retained<Self>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Method call to convert an IOBluetoothDeviceRef into an IOBluetoothDevice *.
        ///
        /// IOBluetoothDeviceRef and it's API are deprecated.  An IOBluetoothDeviceRef can be cast to a IOBluetoothDevice *
        ///
        /// Parameter `deviceRef`: IOBluetoothDeviceRef for which an IOBluetoothDevice * is desired.
        ///
        /// Returns: Returns the IOBluetoothDevice * for the given IOBluetoothDeviceRef.
        ///
        /// # Safety
        ///
        /// `device_ref` might not allow `None`.
        #[deprecated]
        #[unsafe(method(withDeviceRef:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withDeviceRef(
            device_ref: Option<&IOBluetoothDeviceRef>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Returns an IOBluetoothDeviceRef representation of the target IOBluetoothDevice object.
        ///
        /// IOBluetoothDeviceRef and it's API are deprecated.  An IOBluetoothDeviceRef can be cast to a IOBluetoothDevice *
        ///
        /// Returns: Returns an IOBluetoothDeviceRef representation of the target IOBluetoothDevice object.
        #[deprecated]
        #[unsafe(method(getDeviceRef))]
        #[unsafe(method_family = none)]
        pub unsafe fn getDeviceRef(&self) -> Option<Retained<IOBluetoothDeviceRef>>;

        #[cfg(all(feature = "Bluetooth", feature = "IOBluetoothL2CAPChannel"))]
        /// Opens a new L2CAP channel to the target device. Returns only after the channel is opened.
        ///
        /// This method will begin the process of opening a new L2CAP channel to the target device.
        /// The baseband connection to the device will be opened if it is not open already.  The L2CAP
        /// channel open process will not complete until the client has registered an incoming data
        /// listener on the new channel.  This prevents a situation where the channel succeeds
        /// in being configured and opened and receives data before the client is listening and
        /// is ready for it.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Parameter `newChannel`: A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel
        /// requested to be opened.  The newChannel pointer will only be set if
        /// kIOReturnSuccess is returned.
        ///
        /// Parameter `withPSM`: The L2CAP PSM value for the new channel.
        ///
        /// Parameter `channelDelegate`: the object that will play the role of delegate for the channel.
        /// A channel delegate is the object the l2cap uses as target for  data and events. The
        /// developer will implement only the the methods he/she is interested in. A list of the
        /// possible methods is at the end of the file "IOBluetoothL2CAPChannel.h" in the definition
        /// of the protocol IOBluetoothL2CAPChannelDelegate.
        ///
        ///
        /// Returns: Returns kIOReturnSuccess if the open process was successfully started (or if an existing
        /// L2CAP channel was found).
        ///
        /// # Safety
        ///
        /// - `new_channel` might not allow `None`.
        /// - `channel_delegate` should be of the correct type.
        /// - `channel_delegate` might not allow `None`.
        #[unsafe(method(openL2CAPChannelSync:withPSM:delegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openL2CAPChannelSync_withPSM_delegate(
            &self,
            new_channel: Option<&mut Option<Retained<IOBluetoothL2CAPChannel>>>,
            psm: BluetoothL2CAPPSM,
            channel_delegate: Option<&AnyObject>,
        ) -> IOReturn;

        #[cfg(all(feature = "Bluetooth", feature = "IOBluetoothL2CAPChannel"))]
        /// Opens a new L2CAP channel to the target device. Returns immediately after starting the opening process.
        ///
        /// This method will begin the process of opening a new L2CAP channel to the target device.
        /// The baseband connection to the device will be opened if it is not open already.  The L2CAP
        /// channel open process will not complete until the client has registered an incoming data
        /// listener on the new channel.  This prevents a situation where the channel succeeds
        /// in being configured and opened and receives data before the client is listening and
        /// is ready for it.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Parameter `newChannel`: A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel
        /// requested to be opened.  The newChannel pointer will only be set if
        /// kIOReturnSuccess is returned.
        ///
        /// Parameter `psm`: The L2CAP PSM value for the new channel.
        ///
        /// Parameter `channelDelegate`: the object that will play the role of delegate for the channel.
        /// A channel delegate is the object the l2cap uses as target for  data and events. The
        /// developer will implement only the the methods he/she is interested in. A list of the
        /// possible methods is at the end of the file "IOBluetoothL2CAPChannel.h" in the definition
        /// of the protocol IOBluetoothL2CAPChannelDelegate.
        ///
        ///
        /// Returns: Returns kIOReturnSuccess if the open process was successfully started (or if an existing
        /// L2CAP channel was found).
        ///
        /// # Safety
        ///
        /// - `new_channel` might not allow `None`.
        /// - `channel_delegate` should be of the correct type.
        /// - `channel_delegate` might not allow `None`.
        #[unsafe(method(openL2CAPChannelAsync:withPSM:delegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openL2CAPChannelAsync_withPSM_delegate(
            &self,
            new_channel: Option<&mut Option<Retained<IOBluetoothL2CAPChannel>>>,
            psm: BluetoothL2CAPPSM,
            channel_delegate: Option<&AnyObject>,
        ) -> IOReturn;

        #[cfg(all(feature = "Bluetooth", feature = "IOBluetoothL2CAPChannel"))]
        /// Opens a new L2CAP channel to the target device. Returns immedialty after starting the opening process.
        ///
        /// This method will begin the process of opening a new L2CAP channel to the target device.
        /// The baseband connection to the device will be opened if it is not open already.  The L2CAP
        /// channel open process will not complete until the client has registered an incoming data
        /// listener on the new channel.  This prevents a situation where the channel succeeds
        /// in being configured and opened and receives data before the client is listening and
        /// is ready for it.
        ///
        /// Parameter `psm`: The L2CAP PSM value for the new channel.
        ///
        /// Parameter `findExisting`: This value should be set to TRUE if it should look for an existing channel
        /// with the PSM.  Typically this value will be FALSE.  It should be TRUE only
        /// in the case where a single channel is allowed by the spec for the given PSM.
        ///
        /// Parameter `newChannel`: A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel
        /// requested to be opened.  The newChannel pointer will only be set if
        /// kIOReturnSuccess is returned.
        ///
        /// Returns: Returns kIOReturnSuccess if the open process was successfully started (or if an existing
        /// L2CAP channel was found).
        ///
        /// # Safety
        ///
        /// `new_channel` might not allow `None`.
        #[deprecated]
        #[unsafe(method(openL2CAPChannel:findExisting:newChannel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openL2CAPChannel_findExisting_newChannel(
            &self,
            psm: BluetoothL2CAPPSM,
            find_existing: bool,
            new_channel: Option<&mut Option<Retained<IOBluetoothL2CAPChannel>>>,
        ) -> IOReturn;

        /// Send an echo request over the L2CAP connection to a remote device.
        ///
        /// The current implementation returns when the request has been sent, but does not indicate when
        /// a response is received.  Also, the baseband connection must be up for the echo request to be sent.
        /// In the future, this method will also open the connection if necessary.  The API will be updated
        /// to allow the client to be informed when the echo response has been received (both synchronously
        /// and asynchronously).
        ///
        /// Parameter `data`: (void *) - Pointer to buffer to send.
        ///
        /// Parameter `length`: (UInt16) - Length of the buffer to send
        ///
        /// Returns: Returns kIOReturnSuccess if the echo request was able to be sent.
        ///
        /// # Safety
        ///
        /// `data` must be a valid pointer.
        #[unsafe(method(sendL2CAPEchoRequest:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendL2CAPEchoRequest_length(
            &self,
            data: *mut c_void,
            length: u16,
        ) -> IOReturn;

        #[cfg(all(feature = "Bluetooth", feature = "IOBluetoothRFCOMMChannel"))]
        /// Opens a new RFCOMM channel to the target device. Returns only once the channel is open or failed to open.
        ///
        /// This method will begin the process of opening a new RFCOMM channel to the target device.
        /// The baseband connection to the device will be opened if it is not open already.  The RFCOMM
        /// channel open process will not complete until the client has registered an incoming data
        /// listener on the new channel.
        ///
        /// Parameter `channelID`: The RFCOMM channel ID for the new channel.
        ///
        /// Parameter `rfcommChannel`: A pointer to an IOBluetoothRFCOMMChannel object to receive the RFCOMM channel
        /// requested to be opened.  The rfcommChannel pointer will only be set if
        /// kIOReturnSuccess is returned.
        ///
        /// Returns: Returns kIOReturnSuccess if the open process was successfully started (or if an existing
        /// RFCOMM channel was found).
        ///
        /// # Safety
        ///
        /// `rfcomm_channel` might not allow `None`.
        #[deprecated]
        #[unsafe(method(openRFCOMMChannel:channel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openRFCOMMChannel_channel(
            &self,
            channel_id: BluetoothRFCOMMChannelID,
            rfcomm_channel: Option<&mut Option<Retained<IOBluetoothRFCOMMChannel>>>,
        ) -> IOReturn;

        #[cfg(all(feature = "Bluetooth", feature = "IOBluetoothRFCOMMChannel"))]
        /// Opens a new RFCOMM channel to the target device.  Returns only once the channel is open or failed to open.
        ///
        /// This method will begin the process of opening a new RFCOMM channel to the target device.
        /// The baseband connection to the device will be opened if it is not open already.  The RFCOMM
        /// channel open process will not complete until the client has registered an incoming data
        /// listener on the new channel. The RFCOMM channel object is already retained when this function returns success;
        /// the channel must be released when the caller is done with it.
        ///
        /// You should verify that the channel you wish to open exists on the remote device before attempting to open it,
        /// by performing an SDP query. This is recommended because the service might have been removed from the,
        /// remote device or the channel assignments for the service could have changed (this is rare, but it does happen
        /// frequently on some devices). This also works around a bug that existed in early Leopard versions in certain
        /// situations where the method would return an error; in these instances, the desired RFCOMM channel could not
        /// be opened again until the calling app was restarted.
        ///
        /// NOTE:    This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        ///
        /// Parameter `rfcommChannel`: A pointer to an IOBluetoothRFCOMMChannel object to receive the RFCOMM channel
        /// requested to be opened.  The rfcommChannel pointer will only be set if
        /// kIOReturnSuccess is returned.
        ///
        ///
        /// Parameter `channelID`: The RFCOMM channel ID for the new channel.
        ///
        ///
        /// Parameter `channelDelegate`: the object that will play the role of delegate for the channel.
        /// A channel delegate is the object the rfcomm uses as target for  data and events. The
        /// developer will implement only the the methods he/she is interested in. A list of the
        /// possible methods is at the end of the file "IOBluetoothRFCOMMChannel.h" in the definition
        /// of the protocol IOBluetoothRFCOMMChannelDelegate.
        ///
        ///
        /// Returns: Returns kIOReturnSuccess if the open process was successfully started (or if an existing
        /// RFCOMM channel was found). The channel must be released when the caller is done with it.
        ///
        /// # Safety
        ///
        /// - `rfcomm_channel` might not allow `None`.
        /// - `channel_delegate` should be of the correct type.
        /// - `channel_delegate` might not allow `None`.
        #[unsafe(method(openRFCOMMChannelSync:withChannelID:delegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openRFCOMMChannelSync_withChannelID_delegate(
            &self,
            rfcomm_channel: Option<&mut Option<Retained<IOBluetoothRFCOMMChannel>>>,
            channel_id: BluetoothRFCOMMChannelID,
            channel_delegate: Option<&AnyObject>,
        ) -> IOReturn;

        #[cfg(all(feature = "Bluetooth", feature = "IOBluetoothRFCOMMChannel"))]
        /// Opens a new RFCOMM channel to the target device. Returns immediately.
        ///
        /// This method will begin the process of opening a new RFCOMM channel to the target device.
        /// The baseband connection to the device will be opened if it is not open already.  The RFCOMM
        /// channel open process will not complete until the client has registered an incoming data
        /// listener on the new channel. The RFCOMM channel object is already retained when this function returns success;
        /// the channel must be released when the caller is done with it.
        ///
        /// You should verify that the channel you wish to open exists on the remote device before attempting to open it,
        /// by performing an SDP query. This is recommended because the service might have been removed from the,
        /// remote device or the channel assignments for the service could have changed (this is rare, but it does happen
        /// frequently on some devices). This also works around a bug that existed in early Leopard versions in certain
        /// situations where the method would return an error; in these instances, the desired RFCOMM channel could not
        /// be opened again until the calling app was restarted.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        ///
        /// Parameter `rfcommChannel`: A pointer to an IOBluetoothRFCOMMChannel object to receive the RFCOMM channel
        /// requested to be opened.  The rfcommChannel pointer will only be set if
        /// kIOReturnSuccess is returned.
        ///
        ///
        /// Parameter `channelID`: The RFCOMM channel ID for the new channel.
        ///
        ///
        /// Parameter `channelDelegate`: the object that will play the role of delegate for the channel.
        /// A channel delegate is the object the rfcomm uses as target for  data and events. The
        /// developer will implement only the the methods he/she is interested in. A list of the
        /// possible methods is at the end of the file "IOBluetoothRFCOMMChannel.h" in the definition
        /// of the protocol IOBluetoothRFCOMMChannelDelegate.
        ///
        ///
        /// Returns: Returns kIOReturnSuccess if the open process was successfully started (or if an existing
        /// RFCOMM channel was found). The channel must be released when the caller is done with it.
        ///
        /// # Safety
        ///
        /// - `rfcomm_channel` might not allow `None`.
        /// - `channel_delegate` should be of the correct type.
        /// - `channel_delegate` might not allow `None`.
        #[unsafe(method(openRFCOMMChannelAsync:withChannelID:delegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openRFCOMMChannelAsync_withChannelID_delegate(
            &self,
            rfcomm_channel: Option<&mut Option<Retained<IOBluetoothRFCOMMChannel>>>,
            channel_id: BluetoothRFCOMMChannelID,
            channel_delegate: Option<&AnyObject>,
        ) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Gets the full class of device value for the remote device.
        ///
        /// This value is only meaningful if the target device has been seen during an inquiry.  This can be
        /// by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
        /// seen.
        ///
        /// Returns: Returns the class of device for the remote device.
        #[unsafe(method(classOfDevice))]
        #[unsafe(method_family = none)]
        pub unsafe fn classOfDevice(&self) -> BluetoothClassOfDevice;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getClassOfDevice))]
        #[unsafe(method_family = none)]
        pub unsafe fn getClassOfDevice(&self) -> BluetoothClassOfDevice;

        #[cfg(feature = "Bluetooth")]
        /// Get the major service class of the device.
        ///
        /// This value is only meaningful if the target device has been seen during an inquiry.  This can be
        /// by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
        /// seen.
        ///
        /// Returns: Returns the major service class of the device.
        #[unsafe(method(serviceClassMajor))]
        #[unsafe(method_family = none)]
        pub unsafe fn serviceClassMajor(&self) -> BluetoothServiceClassMajor;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getServiceClassMajor))]
        #[unsafe(method_family = none)]
        pub unsafe fn getServiceClassMajor(&self) -> BluetoothServiceClassMajor;

        #[cfg(feature = "Bluetooth")]
        /// Get the major device class of the device.
        ///
        /// This value is only meaningful if the target device has been seen during an inquiry.  This can be
        /// by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
        /// seen.
        ///
        /// Returns: Returns the major device class of the remote device.
        #[unsafe(method(deviceClassMajor))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceClassMajor(&self) -> BluetoothDeviceClassMajor;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getDeviceClassMajor))]
        #[unsafe(method_family = none)]
        pub unsafe fn getDeviceClassMajor(&self) -> BluetoothDeviceClassMajor;

        #[cfg(feature = "Bluetooth")]
        /// Get the minor service class of the device.
        ///
        /// This value is only meaningful if the target device has been seen during an inquiry.  This can be
        /// by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
        /// seen.
        ///
        /// Returns: Returns the minor device class of the remote device.
        #[unsafe(method(deviceClassMinor))]
        #[unsafe(method_family = none)]
        pub unsafe fn deviceClassMinor(&self) -> BluetoothDeviceClassMinor;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getDeviceClassMinor))]
        #[unsafe(method_family = none)]
        pub unsafe fn getDeviceClassMinor(&self) -> BluetoothDeviceClassMinor;

        #[cfg(feature = "objc2-foundation")]
        /// Get the human readable name of the remote device.
        ///
        /// This only returns a value if a remote name request has been performed on the target device.  If a
        /// successful remote name request has not been completed, nil is returned.  To perform a remote
        /// name request, call -remoteNameRequest.  If a remote name request has been successfully completed,
        /// the method -getLastNameUpdate will return the date/time of the last successful request.
        ///
        /// Returns: Returns the name of the remote device name.  This value is an NSString generated from the UTF-8
        /// format of the most recent remote name request.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Retained<NSString>;

        #[cfg(feature = "objc2-foundation")]
        #[deprecated]
        #[unsafe(method(getName))]
        #[unsafe(method_family = none)]
        pub unsafe fn getName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "objc2-foundation")]
        /// Get the human readable name of the remote device.  If the name is not present, it will return a string
        /// containing the device's address.
        ///
        /// If a remote name request has been successfully completed, the device name will be returned.  If not,
        /// a string containg the device address in the format of "XX-XX-XX-XX-XX-XX" will be returned.
        ///
        /// Returns: Returns the device's name or a string containing the device's address.
        #[unsafe(method(nameOrAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn nameOrAddress(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "objc2-foundation")]
        #[deprecated]
        #[unsafe(method(getNameOrAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn getNameOrAddress(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "objc2-foundation")]
        /// Get the date/time of the last successful remote name request.
        ///
        /// Returns: Returns the date/time of the last successful remote name request.  If no remote name request has been
        /// completed on the target device, nil is returned.
        #[unsafe(method(lastNameUpdate))]
        #[unsafe(method_family = none)]
        pub unsafe fn lastNameUpdate(&self) -> Retained<NSDate>;

        #[cfg(feature = "objc2-foundation")]
        #[deprecated]
        #[unsafe(method(getLastNameUpdate))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLastNameUpdate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "Bluetooth")]
        /// Get the Bluetooth device address for the target device.
        ///
        /// Returns: Returns a pointer to the Bluetooth device address of the target device.
        #[unsafe(method(getAddress))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAddress(&self) -> *const BluetoothDeviceAddress;

        #[cfg(feature = "objc2-foundation")]
        /// Get a string representation of the Bluetooth device address for the target device.  The
        /// format of the string is the same as returned by IOBluetoothNSStringFromDeviceAddress(void).
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
        ///
        /// Returns: Returns an NSString containing the Bluetooth device address of the target device.
        #[unsafe(method(addressString))]
        #[unsafe(method_family = none)]
        pub unsafe fn addressString(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "objc2-foundation")]
        #[deprecated]
        #[unsafe(method(getAddressString))]
        #[unsafe(method_family = none)]
        pub unsafe fn getAddressString(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "Bluetooth")]
        /// Get the value of the page scan repetition mode for the device.
        ///
        /// This value is only meaningful if the target device has been seen during an inquiry.  This can be
        /// by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
        /// seen.
        ///
        /// Returns: Returns the page scan repetition mode value for this device.
        #[unsafe(method(getPageScanRepetitionMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn getPageScanRepetitionMode(&self) -> BluetoothPageScanRepetitionMode;

        #[cfg(feature = "Bluetooth")]
        /// Get the value of the page scan period mode for the device.
        ///
        /// This value is only meaningful if the target device has been seen during an inquiry.  This can be
        /// by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
        /// seen.
        ///
        /// Returns: Returns page scan period mode value for the device.
        #[unsafe(method(getPageScanPeriodMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn getPageScanPeriodMode(&self) -> BluetoothPageScanPeriodMode;

        #[cfg(feature = "Bluetooth")]
        /// Get the page scan mode for the device.
        ///
        /// This value is only meaningful if the target device has been seen during an inquiry.  This can be
        /// by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
        /// seen.
        ///
        /// Returns: Returns the value for the page scan mode for the device.
        #[unsafe(method(getPageScanMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn getPageScanMode(&self) -> BluetoothPageScanMode;

        #[cfg(feature = "Bluetooth")]
        /// Get the clock offset value of the device.
        ///
        /// This value is only meaningful if the target device has been seen during an inquiry.  This can be
        /// by checking the result of -getLastInquiryUpdate.  If nil is returned, then the device hasn't been
        /// seen.
        ///
        /// Returns: Returns the clock offset value for the device.
        #[unsafe(method(getClockOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn getClockOffset(&self) -> BluetoothClockOffset;

        #[cfg(feature = "objc2-foundation")]
        /// Get the date/time of the last time the device was returned during an inquiry.
        ///
        /// Returns: Returns the date/time of the last time the device was seen during an inquiry.
        /// If the device has never been seen during an inquiry, nil is returned.
        #[unsafe(method(getLastInquiryUpdate))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLastInquiryUpdate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "Bluetooth")]
        /// Get the RSSI device (if connected), above or below the golden range. If the RSSI is within the golden
        /// range, a value of 0 is returned. For the actual RSSI value, use getRawRSSI. For more information, see
        /// the Bluetooth 4.0 Core Specification.
        ///
        /// Returns: Returns the RSSI of the device. If the value cannot be read (e.g. the device is disconnected), a value
        /// of +127 will be returned.
        #[unsafe(method(RSSI))]
        #[unsafe(method_family = none)]
        pub unsafe fn RSSI(&self) -> BluetoothHCIRSSIValue;

        #[cfg(feature = "Bluetooth")]
        /// Get the raw RSSI device (if connected).
        ///
        /// Returns: Returns the raw RSSI of the device.
        ///
        /// This value is the perceived RSSI value, not relative the the golden range (see getRSSI for that value).
        /// This value will not available on all Bluetooth modules. If the value cannot be read (e.g. the device
        /// is disconnected) or is not available on a module, a value of +127 will be returned.
        #[unsafe(method(rawRSSI))]
        #[unsafe(method_family = none)]
        pub unsafe fn rawRSSI(&self) -> BluetoothHCIRSSIValue;

        /// Indicates whether a baseband connection to the device exists.
        ///
        /// Returns: Returns YES if a baseband connection to the device exists.
        #[unsafe(method(isConnected))]
        #[unsafe(method_family = none)]
        pub unsafe fn isConnected(&self) -> bool;

        /// Create a baseband connection to the device.
        ///
        /// This method is synchronous and will not return until either a connection has been established
        /// or the create connection has failed (perhaps timed out).  This method does the same thing as
        /// calling -openConnection: with a nil target.     This call with proceed without authentication required, and
        /// using the default page timeout value.  If authentication or a non-default page timeout is required the method
        /// -openConnection:withPageTimeout:authenticationRequired: should be used instead.
        ///
        /// As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' with a success result code;
        /// your code must account for the cases where the baseband connection is already open.
        ///
        ///
        /// Returns: Returns kIOReturnSuccess if the connection was successfully created.
        #[unsafe(method(openConnection))]
        #[unsafe(method_family = none)]
        pub unsafe fn openConnection(&self) -> IOReturn;

        /// Create a baseband connection to the device.
        ///
        /// If a target is specified, the open connection call is asynchronous and on completion of the
        /// CREATE_CONNECTION command, the method -connectionComplete:status: will be called on the specified target.
        /// If no target is specified, the call is synchronous and will not return until the connection is open
        /// or the CREATE_CONNECTION call has failed.  This call with proceed without authentication required, and
        /// using the default page timeout value.  If authentication or a non-default page timeout is required the method
        /// -openConnection:withPageTimeout:authenticationRequired: should be used instead.
        ///
        /// As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' with a success result code;
        /// your code must account for the cases where the baseband connection is already open.
        ///
        ///
        /// Returns: Returns kIOReturnSuccess if the connection was successfully created (or if asynchronous, if the
        /// CREATE_CONNECTION command was successfully issued).
        ///
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `target` might not allow `None`.
        #[unsafe(method(openConnection:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openConnection_(&self, target: Option<&AnyObject>) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Create a baseband connection to the device.
        ///
        /// If a target is specified, the open connection call is asynchronous and on completion of the
        /// CREATE_CONNECTION command, the method -connectionComplete:status: will be called on the specified target.
        /// If no target is specified, the call is synchronous and will not return until the connection is open
        /// or the CREATE_CONNECTION call has failed.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.7 (Bluetooth v1.3) or later.
        ///
        /// As of Mac OS X 10.7, this method will no longer mask out "Connection Exists" 'errors' with a success result code;
        /// your code must account for the cases where the baseband connection is already open.
        ///
        ///
        /// Parameter `target`: The target to message when the create connection call is complete
        ///
        /// Parameter `pageTimeoutValue`: The page timeout value to use for this call
        ///
        /// Parameter `authenticationRequired`: BOOL value to indicate whether authentication should be required for the connection
        ///
        /// Returns: Returns kIOReturnSuccess if the connection was successfully created (or if asynchronous, if the
        /// CREATE_CONNECTION command was successfully issued).
        ///
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `target` might not allow `None`.
        #[unsafe(method(openConnection:withPageTimeout:authenticationRequired:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openConnection_withPageTimeout_authenticationRequired(
            &self,
            target: Option<&AnyObject>,
            page_timeout_value: BluetoothHCIPageTimeout,
            authentication_required: bool,
        ) -> IOReturn;

        /// Close down the baseband connection to the device.
        ///
        /// This method is synchronous and will not return until the connection has been closed (or the
        /// command failed).  In the future this API will be changed to allow asynchronous operation.
        ///
        /// Returns: Returns kIOReturnSuccess if the connection has successfully been closed.
        #[unsafe(method(closeConnection))]
        #[unsafe(method_family = none)]
        pub unsafe fn closeConnection(&self) -> IOReturn;

        /// Issues a remote name request to the target device.
        ///
        /// If a target is specified, the request is asynchronous and on completion of the request, the method
        ///
        /// - (void)remoteNameRequestComplete:(IOBluetoothDevice *)device status:(IOReturn)status;
        ///
        /// will be called on the specified target. If no target is specified, the request is made synchronously
        /// and won't return until the request is complete.  This call with operate with the default page
        /// timeout value. If a different page timeout value is desired, the method -remoteNameRequest:withPageTimeout:
        /// should be used instead.
        ///
        /// Parameter `target`: The target to message when the remote name request is complete
        ///
        /// Returns: Returns kIOReturnSuccess if the remote name request was successfully issued (and if synchronous, if
        /// the request completed successfully).
        ///
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `target` might not allow `None`.
        #[unsafe(method(remoteNameRequest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteNameRequest(&self, target: Option<&AnyObject>) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Issues a remote name request to the target device.
        ///
        /// If a target is specified, the request is asynchronous and on completion of the REMOTE_NAME_REQUEST
        /// command, the method -remoteNameRequestComplete:status:name: will be called on the specified target.
        /// If no target is specified, the request is made synchronously and won't return until the request is
        /// complete.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.7 (Bluetooth v1.3) or later.
        ///
        /// Parameter `target`: The target to message when the remote name request is complete
        ///
        /// Parameter `pageTimeoutValue`: The page timeout value to use for this call
        ///
        /// Returns: Returns kIOReturnSuccess if the remote name request was successfully issued (and if synchronous, if
        /// the request completed successfully).
        ///
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `target` might not allow `None`.
        #[unsafe(method(remoteNameRequest:withPageTimeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn remoteNameRequest_withPageTimeout(
            &self,
            target: Option<&AnyObject>,
            page_timeout_value: BluetoothHCIPageTimeout,
        ) -> IOReturn;

        /// Requests that the existing baseband connection be authenticated.
        ///
        /// In order to authenticate a baseband connection, a link key needs to be generated as a result of
        /// the pairing process.  This call will synchronously initiate the pairing process with the target device
        /// and not return until the authentication process is complete.  This API will be updated to allow
        /// for asynchronous operation.
        ///
        /// Returns: Returns kIOReturnSuccess if the connection has been successfully been authenticated.  Returns an error
        /// if authentication fails or no baseband connection exists.
        #[unsafe(method(requestAuthentication))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestAuthentication(&self) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Get the connection handle for the baseband connection.
        ///
        /// This method only returns a valid result if a baseband connection is present (-isConnected returns TRUE).
        ///
        /// Returns: Returns the connection handle for the baseband connection.  If no baseband connection is present,
        /// kBluetoothConnectionHandleNone is returned.
        #[unsafe(method(connectionHandle))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectionHandle(&self) -> BluetoothConnectionHandle;

        #[cfg(feature = "Bluetooth")]
        #[deprecated]
        #[unsafe(method(getConnectionHandle))]
        #[unsafe(method_family = none)]
        pub unsafe fn getConnectionHandle(&self) -> BluetoothConnectionHandle;

        /// Returns TRUE if the device connection was generated by the remote host.
        ///
        /// Returns TRUE if the device connection was generated by the remote host. False if the connection was generated by some other device that connected to the local host.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.7 (Bluetooth v1.3) or later.
        ///
        /// Returns: Returns TRUE if the device connection was generated by the remote host.
        #[unsafe(method(isIncoming))]
        #[unsafe(method_family = none)]
        pub unsafe fn isIncoming(&self) -> bool;

        #[cfg(feature = "Bluetooth")]
        /// Get the link type for the baseband connection.
        ///
        /// This method only returns a valid result if a baseband connection is present (-isConnected returns TRUE).
        ///
        /// Returns: Returns the link type for the baseband connection.  If no baseband connection is present,
        /// kBluetoothLinkTypeNone is returned.
        #[unsafe(method(getLinkType))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLinkType(&self) -> BluetoothLinkType;

        #[cfg(feature = "Bluetooth")]
        /// Get the encryption mode for the baseband connection.
        ///
        /// This method only returns a valid result if a baseband connection is present (-isConnected returns TRUE).
        ///
        /// Returns: Returns the encryption mode for the baseband connection.  If no baseband connection is present,
        /// kEncryptionDisabled is returned.
        #[unsafe(method(getEncryptionMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn getEncryptionMode(&self) -> BluetoothHCIEncryptionMode;

        /// Performs an SDP query on the target device.
        ///
        /// As a result of this call, a baseband connection will be built to the device (if not already connected).
        /// Then, an L2CAP channel will be opened to the SDP server on the device.  At that point, a Service
        /// Search Attribute request will be issued with a UUID of 0x0100 (L2CAP) and an attribute range of
        /// 0x0000 - 0xffff specified.  This will cause the SDP server to return all attributes of all L2CAP-derived
        /// services on the device.  The results essentially encompass all services on the device.
        /// This function is always asynchronous.  If a target is specified, when the SDP query is complete (or
        /// an error is encountered), the method -sdpQueryComplete:status: will be called on the given target.  If no target
        /// is specified, the request is still asynchronous, but no callback will be made.  That can be useful if the client
        /// has    registered for SDP service changed notifications.
        ///
        /// Parameter `target`: The target to message when the SDP query is complete
        ///
        /// Returns: Returns kIOReturnSuccess if the SDP query was successfully started.
        ///
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `target` might not allow `None`.
        #[unsafe(method(performSDPQuery:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performSDPQuery(&self, target: Option<&AnyObject>) -> IOReturn;

        #[cfg(feature = "objc2-foundation")]
        /// Performs an SDP query on the target device with the specified service UUIDs.
        ///
        /// As a result of this call, a baseband connection will be built to the device (if not already connected).
        /// Then, an L2CAP channel will be opened to the SDP server on the device.  At that point, a Service
        /// Search Attribute request will be issued for each service UUID specified in the UUID array.
        ///
        /// This function is always asynchronous.  If a target is specified, when the SDP query is complete (or
        /// an error is encountered), the method -sdpQueryComplete:status: will be called on the given target.  If no target
        /// is specified, the request is still asynchronous, but no callback will be made.  That can be useful if the client
        /// has    registered for SDP service changed notifications.
        ///
        /// Parameter `target`: The target to message when the SDP query is complete
        ///
        /// Parameter `uuidArray`: An array of IOBluetoothSDPUUID objects for each service the caller is interested in
        ///
        ///
        /// Returns: Returns kIOReturnSuccess if the SDP query was successfully started.
        ///
        /// # Safety
        ///
        /// - `target` should be of the correct type.
        /// - `target` might not allow `None`.
        /// - `uuid_array` generic should be of the correct type.
        /// - `uuid_array` might not allow `None`.
        #[unsafe(method(performSDPQuery:uuids:))]
        #[unsafe(method_family = none)]
        pub unsafe fn performSDPQuery_uuids(
            &self,
            target: Option<&AnyObject>,
            uuid_array: Option<&NSArray>,
        ) -> IOReturn;

        #[cfg(feature = "objc2-foundation")]
        /// Gets an array of service records for the device.
        ///
        /// The resulting array contains IOBluetoothSDPServiceRecord objects.  The service records are only
        /// present if an SDP query has been done on the target object.  This can be determined by calling
        /// -getLastServicesUpdate.  It will return the last date/time of the SDP query. To initiate an
        /// SDP query on a device, use -performSDPQuery: as defined above.
        ///
        /// Instead of allowing individual clients to query for different services and service attributes,
        /// the system request all of the device's services and service attributes.
        ///
        /// Returns: Returns an array of service records for the device if an SDP query has been performed.  If no
        /// SDP query has been performed, nil is returned.
        #[unsafe(method(services))]
        #[unsafe(method_family = none)]
        pub unsafe fn services(&self) -> Option<Retained<NSArray>>;

        #[cfg(feature = "objc2-foundation")]
        #[deprecated]
        #[unsafe(method(getServices))]
        #[unsafe(method_family = none)]
        pub unsafe fn getServices(&self) -> Option<Retained<NSArray>>;

        #[cfg(feature = "objc2-foundation")]
        /// Get the date/time of the last SDP query.
        ///
        /// Returns: Returns the date/time of the last SDP query.  If an SDP query has never been performed on the
        /// device, nil is returned.
        #[unsafe(method(getLastServicesUpdate))]
        #[unsafe(method_family = none)]
        pub unsafe fn getLastServicesUpdate(&self) -> Option<Retained<NSDate>>;

        #[cfg(all(
            feature = "IOBluetoothSDPServiceRecord",
            feature = "IOBluetoothSDPUUID",
            feature = "objc2-foundation"
        ))]
        /// Search for a service record containing the given UUID.
        ///
        /// This method searches through the device's services to find a service that contains the given
        /// UUID.  Only the first service record will be returned.  This method only operates on services
        /// that have already been queried.  It will not initiate a new query.  This method should probably
        /// be updated to return an array of service records if more than one contains the UUID.
        ///
        /// Parameter `sdpUUID`: UUID value to search for.
        ///
        /// Returns: Returns the first service record that contains the given uuid.  If no service record is found,
        /// nil is returned.
        ///
        /// # Safety
        ///
        /// `sdp_uuid` might not allow `None`.
        #[unsafe(method(getServiceRecordForUUID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn getServiceRecordForUUID(
            &self,
            sdp_uuid: Option<&IOBluetoothSDPUUID>,
        ) -> Option<Retained<IOBluetoothSDPServiceRecord>>;

        #[cfg(feature = "objc2-foundation")]
        /// Gets an array of the user's favorite devices.
        ///
        /// The resulting array contains IOBluetoothDevice objects.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
        ///
        /// Returns: Returns an array of device objects representing the user's favorite devices.  If the
        /// user has no favorites, nil is returned.
        #[unsafe(method(favoriteDevices))]
        #[unsafe(method_family = none)]
        pub unsafe fn favoriteDevices() -> Option<Retained<NSArray>>;

        /// Reports whether the target device is a favorite for the user.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
        ///
        /// Returns: Returns TRUE if the target device is a favorite for the user, FALSE if not.
        #[unsafe(method(isFavorite))]
        #[unsafe(method_family = none)]
        pub unsafe fn isFavorite(&self) -> bool;

        /// Adds the target device to the user's favorite devices list.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
        ///
        /// Returns: Returns kIOReturnSuccess if the device was successfully added to the user's
        /// list of favorite devices.
        #[unsafe(method(addToFavorites))]
        #[unsafe(method_family = none)]
        pub unsafe fn addToFavorites(&self) -> IOReturn;

        /// Removes the target device from the user's favorite devices list.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
        ///
        /// Returns: Returns kIOReturnSuccess if the device was successfully removed from the user's
        /// list of favorite devices.
        #[unsafe(method(removeFromFavorites))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromFavorites(&self) -> IOReturn;

        #[cfg(feature = "objc2-foundation")]
        /// Gets an array of recently used Bluetooth devices.
        ///
        /// The resulting array contains IOBluetoothDevice objects sorted in reverse chronological order.
        /// The most recently accessed devices are first.  If the numDevices parameter is 0, all devices
        /// accessed by the system are returned.  If numDevices is non-zero, only the most recent devices
        /// are returned.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
        ///
        /// Parameter `numDevices`: The number of devices to return.
        ///
        /// Returns: Returns an array of device objects recently used by the system.  If no devices have been accessed,
        /// nil is returned.
        #[unsafe(method(recentDevices:))]
        #[unsafe(method_family = none)]
        pub unsafe fn recentDevices(num_devices: c_ulong) -> Option<Retained<NSArray>>;

        #[cfg(feature = "objc2-foundation")]
        /// Returns the date/time of the most recent access of the target device.
        ///
        /// This is the date that -recentDevices uses to sort its list of the most recently accessed
        /// devices.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.4 (Bluetooth v1.1) or later.
        ///
        /// Returns: Returns the date/time of the most recent access of the target device.  If the device
        /// has not been accessed, nil is returned.
        #[unsafe(method(recentAccessDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn recentAccessDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "objc2-foundation")]
        /// Gets an array of all of the paired devices on the system.
        ///
        /// The resulting array contains IOBluetoothDevice objects.  The paired devices are currently NOT stored
        /// per user, so this is all devices paired by any user.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Returns: Returns an array of device objects for all of the paired devices on the system.  If there are
        /// no paired devices, nil is returned.
        #[unsafe(method(pairedDevices))]
        #[unsafe(method_family = none)]
        pub unsafe fn pairedDevices() -> Option<Retained<NSArray>>;

        /// Returns whether the target device is paired.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Returns: Returns TRUE if the target device is paired, FALSE if not.
        #[unsafe(method(isPaired))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPaired(&self) -> bool;

        /// Sets the connection supervision timeout.
        ///
        /// NOTE: This method is only available in Mac OS X 10.5 (Bluetooth v2.0) or later.
        ///
        /// Parameter `timeout`: A client-supplied link supervision timeout value to use to monitor the connection. The timeout
        /// value should be specified in slots, so you can use the BluetoothGetSlotsFromSeconds macro to get the proper
        /// value. e.g. BluetoothGetSlotsFromSeconds( 5.0 ) will give yield the proper number of slots (8000) for 5 seconds.
        ///
        /// Returns: Returns kIOReturnSuccess if it was possible to set the connection supervision timeout.
        #[unsafe(method(setSupervisionTimeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSupervisionTimeout(&self, timeout: u16) -> IOReturn;

        #[cfg(all(
            feature = "Bluetooth",
            feature = "IOBluetoothL2CAPChannel",
            feature = "objc2-foundation"
        ))]
        /// Opens a new L2CAP channel to the target device. Returns only after the channel is opened.
        ///
        /// This method will begin the process of opening a new L2CAP channel to the target device.
        /// The baseband connection to the device will be opened if it is not open already.  The L2CAP
        /// channel open process will not complete until the client has registered an incoming data
        /// listener on the new channel.  This prevents a situation where the channel succeeds
        /// in being configured and opened and receives data before the client is listening and
        /// is ready for it. The L2CAP channel object is already retained when this function returns success;
        /// the channel must be released when the caller is done with it.
        ///
        /// NOTE: This method is only available in Mac OS X 10.5 (Bluetooth v2.0) or later.
        ///
        /// Parameter `newChannel`: A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel
        /// requested to be opened.  The newChannel pointer will only be set if
        /// kIOReturnSuccess is returned.
        ///
        /// Parameter `withPSM`: The L2CAP PSM value for the new channel.
        ///
        /// Parameter `channelConfiguration`: the dictionary that describes the initial configuration for
        /// the channel.
        ///
        /// Parameter `channelDelegate`: the object that will play the role of delegate for the channel.
        /// A channel delegate is the object the l2cap uses as target for  data and events. The
        /// developer will implement only the the methods he/she is interested in. A list of the
        /// possible methods is at the end of the file "IOBluetoothL2CAPChannel.h" in the definition
        /// of the protocol IOBluetoothL2CAPChannelDelegate.
        ///
        ///
        /// Returns: Returns kIOReturnSuccess if the open process was successfully started (or if an existing
        /// L2CAP channel was found). The channel must be released when the caller is done with it.
        ///
        /// # Safety
        ///
        /// - `new_channel` might not allow `None`.
        /// - `channel_configuration` generic should be of the correct type.
        /// - `channel_configuration` might not allow `None`.
        /// - `channel_delegate` should be of the correct type.
        /// - `channel_delegate` might not allow `None`.
        #[unsafe(method(openL2CAPChannelSync:withPSM:withConfiguration:delegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openL2CAPChannelSync_withPSM_withConfiguration_delegate(
            &self,
            new_channel: Option<&mut Option<Retained<IOBluetoothL2CAPChannel>>>,
            psm: BluetoothL2CAPPSM,
            channel_configuration: Option<&NSDictionary>,
            channel_delegate: Option<&AnyObject>,
        ) -> IOReturn;

        #[cfg(all(
            feature = "Bluetooth",
            feature = "IOBluetoothL2CAPChannel",
            feature = "objc2-foundation"
        ))]
        /// Opens a new L2CAP channel to the target device. Returns immediately after starting the opening process.
        ///
        /// This method will begin the process of opening a new L2CAP channel to the target device.
        /// The baseband connection to the device will be opened if it is not open already.  The L2CAP
        /// channel open process will not complete until the client has registered an incoming data
        /// listener on the new channel.  This prevents a situation where the channel succeeds
        /// in being configured and opened and receives data before the client is listening and
        /// is ready for it. The L2CAP channel object is already retained when this function returns success;
        /// the channel must be released when the caller is done with it.
        ///
        /// NOTE: This method is only available in Mac OS X 10.5 (Bluetooth v2.0) or later.
        ///
        /// Parameter `newChannel`: A pointer to an IOBluetoothL2CAPChannel object to receive the L2CAP channel
        /// requested to be opened.  The newChannel pointer will only be set if
        /// kIOReturnSuccess is returned.
        ///
        /// Parameter `psm`: The L2CAP PSM value for the new channel.
        ///
        /// Parameter `channelConfiguration`: the dictionary that describes the initial configuration for
        /// the channel.
        ///
        /// Parameter `channelDelegate`: the object that will play the role of delegate for the channel.
        /// A channel delegate is the object the l2cap uses as target for  data and events. The
        /// developer will implement only the the methods he/she is interested in. A list of the
        /// possible methods is at the end of the file "IOBluetoothL2CAPChannel.h" in the definition
        /// of the protocol IOBluetoothL2CAPChannelDelegate.
        ///
        ///
        /// Returns: Returns kIOReturnSuccess if the open process was successfully started (or if an existing
        /// L2CAP channel was found). The channel must be released when the caller is done with it.
        ///
        /// # Safety
        ///
        /// - `new_channel` might not allow `None`.
        /// - `channel_configuration` generic should be of the correct type.
        /// - `channel_configuration` might not allow `None`.
        /// - `channel_delegate` should be of the correct type.
        /// - `channel_delegate` might not allow `None`.
        #[unsafe(method(openL2CAPChannelAsync:withPSM:withConfiguration:delegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn openL2CAPChannelAsync_withPSM_withConfiguration_delegate(
            &self,
            new_channel: Option<&mut Option<Retained<IOBluetoothL2CAPChannel>>>,
            psm: BluetoothL2CAPPSM,
            channel_configuration: Option<&NSDictionary>,
            channel_delegate: Option<&AnyObject>,
        ) -> IOReturn;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "IOBluetoothObject")]
impl IOBluetoothDevice {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
