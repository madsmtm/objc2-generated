//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// This class is a representation of a Bluetooth Host Controller Interface that is present on the
    /// local computer (either plugged in externally or available internally).
    ///
    /// This object can be used to ask a Bluetooth HCI for certain pieces of information, and be used to make
    /// it perform certain functions.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothhostcontroller?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct IOBluetoothHostController;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for IOBluetoothHostController {}
);

impl IOBluetoothHostController {
    extern_methods!(
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        ///
        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `delegate` might not allow `None`.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&AnyObject>);

        /// Gets the default HCI controller object.
        ///
        /// Returns: A (autoreleased) pointer to the created IOBluetoothHostController object.
        #[unsafe(method(defaultController))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultController() -> Option<Retained<Self>>;

        #[cfg(feature = "Bluetooth")]
        /// Gets the controller power state
        ///
        /// Returns: The current controller's power state.  This will be 1 for on, or 0 for off.  Only Apple Bluetooth adapters support power off
        #[unsafe(method(powerState))]
        #[unsafe(method_family = none)]
        pub unsafe fn powerState(&self) -> BluetoothHCIPowerState;

        #[cfg(feature = "Bluetooth")]
        /// Gets the current class of device value.
        ///
        /// Returns: Returns the current class of device value.
        #[unsafe(method(classOfDevice))]
        #[unsafe(method_family = none)]
        pub unsafe fn classOfDevice(&self) -> BluetoothClassOfDevice;

        #[cfg(all(feature = "Bluetooth", feature = "objc2-foundation"))]
        /// Sets the current class of device value, for the specified amount of time. Note that the time interval *must*
        /// be set and valid. The range of acceptable values is 30-120 seconds. Anything above or below will be rounded
        /// up, or down, as appropriate.
        ///
        /// Returns: Returns the whether setting the class of device value was successful. 0 if success, error code otherwise.
        #[unsafe(method(setClassOfDevice:forTimeInterval:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setClassOfDevice_forTimeInterval(
            &self,
            class_of_device: BluetoothClassOfDevice,
            seconds: NSTimeInterval,
        ) -> IOReturn;

        #[cfg(feature = "objc2-foundation")]
        /// Convience routine to get the HCI controller's Bluetooth address as an NSString object.
        ///
        /// Returns: Returns NSString *. nil if the address could not be retrieved.
        #[unsafe(method(addressAsString))]
        #[unsafe(method_family = none)]
        pub unsafe fn addressAsString(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "objc2-foundation")]
        /// Gets the "friendly" name of HCI controller.
        ///
        /// Returns: Returns NSString with the device name, nil if there is not one or it cannot be read.
        #[unsafe(method(nameAsString))]
        #[unsafe(method_family = none)]
        pub unsafe fn nameAsString(&self) -> Option<Retained<NSString>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl IOBluetoothHostController {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

mod private_NSObjectIOBluetoothHostControllerDelegate {
    pub trait Sealed {}
}

/// Category "IOBluetoothHostControllerDelegate" on [`NSObject`].
///
/// This category on NSObject describes the delegate methods for the IOBluetoothHostController object. All
/// methods are optional, but it is highly recommended you implement them all. Do NOT invoke remote name
/// requests on found IOBluetoothDevice objects unless the controller object has been stopped. Doing so may
/// deadlock your process.
#[doc(alias = "IOBluetoothHostControllerDelegate")]
pub unsafe trait NSObjectIOBluetoothHostControllerDelegate:
    ClassType + Sized + private_NSObjectIOBluetoothHostControllerDelegate::Sealed
{
    extern_methods!(
        #[cfg(all(
            feature = "Bluetooth",
            feature = "IOBluetoothDevice",
            feature = "IOBluetoothObject"
        ))]
        /// This delegate gets invoked when an RSSI command complete event occurs. This could occur because you
        /// invoked it by issuing an -readRSSIForDevice: command, or someone else did from another app on the
        /// same controller.
        ///
        /// Parameter `sender`: Controller object that sent this delegate message.
        ///
        /// # Safety
        ///
        /// `info` must be a valid pointer.
        #[unsafe(method(readRSSIForDeviceComplete:device:info:error:))]
        #[unsafe(method_family = none)]
        unsafe fn readRSSIForDeviceComplete_device_info_error(
            &self,
            controller: Option<&AnyObject>,
            device: Option<&IOBluetoothDevice>,
            info: *mut BluetoothHCIRSSIInfo,
            error: IOReturn,
        );

        #[cfg(all(
            feature = "Bluetooth",
            feature = "IOBluetoothDevice",
            feature = "IOBluetoothObject"
        ))]
        /// This delegate gets invoked when an read link quality command complete event occurs. This could occur because you
        /// invoked it by issuing an -readLinkQualityForDevice: command, or someone else did from another app on the
        /// same controller.
        ///
        /// Parameter `sender`: Controller object that sent this delegate message.
        ///
        /// # Safety
        ///
        /// `info` must be a valid pointer.
        #[unsafe(method(readLinkQualityForDeviceComplete:device:info:error:))]
        #[unsafe(method_family = none)]
        unsafe fn readLinkQualityForDeviceComplete_device_info_error(
            &self,
            controller: Option<&AnyObject>,
            device: Option<&IOBluetoothDevice>,
            info: *mut BluetoothHCILinkQualityInfo,
            error: IOReturn,
        );
    );
}

impl private_NSObjectIOBluetoothHostControllerDelegate::Sealed for NSObject {}
unsafe impl NSObjectIOBluetoothHostControllerDelegate for NSObject {}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothhostcontrollerpoweredonnotification?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static IOBluetoothHostControllerPoweredOnNotification: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothhostcontrollerpoweredoffnotification?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static IOBluetoothHostControllerPoweredOffNotification: Option<&'static NSString>;
}
