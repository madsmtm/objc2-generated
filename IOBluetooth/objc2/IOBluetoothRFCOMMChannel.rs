//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// An instance of this class represents an rfcomm channel as defined by the Bluetooth SDP spec..
    ///
    /// An RFCOMM channel object can be obtained by opening an rfcomm channel in a device, or
    /// by requesting a notification when a channel is created (this is commonly used to provide services).
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothrfcommchannel?language=objc)
    #[unsafe(super(IOBluetoothObject, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "IOBluetoothObject")]
    pub struct IOBluetoothRFCOMMChannel;
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSCopying for IOBluetoothRFCOMMChannel {}
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
unsafe impl CopyingHelper for IOBluetoothRFCOMMChannel {
    type Result = Self;
}

#[cfg(feature = "IOBluetoothObject")]
extern_conformance!(
    unsafe impl NSObjectProtocol for IOBluetoothRFCOMMChannel {}
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSPortDelegate for IOBluetoothRFCOMMChannel {}
);

#[cfg(all(feature = "IOBluetoothObject", feature = "objc2-foundation"))]
extern_conformance!(
    unsafe impl NSStreamDelegate for IOBluetoothRFCOMMChannel {}
);

#[cfg(feature = "IOBluetoothObject")]
impl IOBluetoothRFCOMMChannel {
    extern_methods!(
        #[cfg(feature = "IOBluetoothUserNotification")]
        /// Allows a client to register for RFCOMM channel open notifications for any RFCOMM channel.
        ///
        /// The given selector will be called on the target object whenever any RFCOMM channel is opened.
        /// The selector should accept two arguments.  The first is the user notification object.  The second
        /// is the IOBluetoothRFCOMMChannel that was opened.
        ///
        /// Parameter `rfcommChannelRef`: IOBluetoothRFCOMMChannelRef for which an IOBluetoothRFCOMMChannel * is desired.
        ///
        /// Parameter `object`: Target object
        ///
        /// Parameter `selector`: Selector to be called on the target object when a new RFCOMM channel is opened.
        /// the format for the selector is:
        /// -(void) selectorName:(IOBluetoothUserNotification *)inNotification channel:(IOBluetoothRFCOMMChannel *)newChannel
        ///
        /// Returns: Returns an IOBluetoothUserNotification representing the outstanding RFCOMM channel notification.
        /// To unregister the notification, call -unregister on the resulting IOBluetoothUserNotification
        /// object.  If an error is encountered creating the notification, nil is returned.  The returned
        /// IOBluetoothUserNotification will be valid for as long as the notification is registered.  It is
        /// not necessary to retain the result.  Once -unregister is called on it, it will no longer be valid.
        ///
        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `object` might not allow `None`.
        /// - `selector` must be a valid selector.
        #[unsafe(method(registerForChannelOpenNotifications:selector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForChannelOpenNotifications_selector(
            object: Option<&AnyObject>,
            selector: Option<Sel>,
        ) -> Option<Retained<IOBluetoothUserNotification>>;

        #[cfg(all(
            feature = "Bluetooth",
            feature = "IOBluetoothUserLib",
            feature = "IOBluetoothUserNotification"
        ))]
        /// Allows a client to register for RFCOMM channel open notifications for certain types of
        /// RFCOMM channels.
        ///
        /// The given selector will be called on the target object whenever an RFCOMM channel with the given
        /// attributes is opened.  The selector should accept two arguments.  The first is the user
        /// notification object.  The second is the IOBluetoothRFCOMMChannel that was opened.
        ///
        /// Parameter `object`: Target object
        ///
        /// Parameter `selector`: Selector to be called on the target object when a new RFCOMM channel is opened.
        /// the format for the selector is:
        /// -(void) selectorName:(IOBluetoothUserNotification *)inNotification channel:(IOBluetoothRFCOMMChannel *)newChannel
        ///
        /// Parameter `channeLID`: RFCOMM channel ID to match a new RFCOMM channel.  If the channel ID doesn't matter, 0 may be passed in.
        ///
        /// Parameter `inDirection`: The desired direction of the RFCOMM channel - kIOBluetoothUserNotificationChannelDirectionAny
        /// if the direction doesn't matter.
        ///
        /// Returns: Returns an IOBluetoothUserNotification representing the outstanding RFCOMM channel notification.
        /// To unregister the notification, call -unregister on the resulting IOBluetoothUserNotification
        /// object.  If an error is encountered creating the notification, nil is returned.  The returned
        /// IOBluetoothUserNotification will be valid for as long as the notification is registered.  It is
        /// not necessary to retain the result.  Once -unregister is called on it, it will no longer be valid.
        ///
        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `object` might not allow `None`.
        /// - `selector` must be a valid selector.
        #[unsafe(method(registerForChannelOpenNotifications:selector:withChannelID:direction:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForChannelOpenNotifications_selector_withChannelID_direction(
            object: Option<&AnyObject>,
            selector: Option<Sel>,
            channel_id: BluetoothRFCOMMChannelID,
            in_direction: IOBluetoothUserNotificationChannelDirection,
        ) -> Option<Retained<IOBluetoothUserNotification>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Method call to convert an IOBluetoothRFCOMMChannelRef into an IOBluetoothRFCOMMChannel *.
        ///
        /// Parameter `rfcommChannelRef`: IOBluetoothRFCOMMChannelRef for which an IOBluetoothRFCOMMChannel * is desired.
        ///
        /// Returns: Returns the IOBluetoothRFCOMMChannel * for the given IOBluetoothRFCOMMChannelRef.
        ///
        /// # Safety
        ///
        /// `rfcomm_channel_ref` might not allow `None`.
        #[unsafe(method(withRFCOMMChannelRef:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withRFCOMMChannelRef(
            rfcomm_channel_ref: Option<&IOBluetoothRFCOMMChannelRef>,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Returns the IObluetoothRFCOMMChannel with the given IOBluetoothObjectID.
        ///
        /// The IOBluetoothObjectID can be used as a global reference for a given IObluetoothRFCOMMChannel.  It allows
        /// two separate applications to refer to the same IObluetoothRFCOMMChannel object.
        ///
        /// Parameter `objectID`: IOBluetoothObjectID of the desired IObluetoothRFCOMMChannel.
        ///
        /// Returns: Returns the IObluetoothRFCOMMChannel that matches the given IOBluetoothObjectID if one exists.
        /// If no matching RFCOMM channel exists, nil is returned.
        #[unsafe(method(withObjectID:))]
        #[unsafe(method_family = none)]
        pub unsafe fn withObjectID(object_id: IOBluetoothObjectID) -> Option<Retained<Self>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Returns an IOBluetoothRFCOMMChannelRef representation of the target IOBluetoothRFCOMMChannel object.
        ///
        /// Returns: Returns an IOBluetoothRFCOMMChannelRef representation of the target IOBluetoothRFCOMMChannel object.
        #[unsafe(method(getRFCOMMChannelRef))]
        #[unsafe(method_family = none)]
        pub unsafe fn getRFCOMMChannelRef(&self) -> Option<Retained<IOBluetoothRFCOMMChannelRef>>;

        /// Close the channel.
        ///
        /// Returns: An error code value. 0 if successful.
        #[unsafe(method(closeChannel))]
        #[unsafe(method_family = none)]
        pub unsafe fn closeChannel(&self) -> IOReturn;

        /// Returns the state of the channel.
        ///
        /// note that "not open" means closed, opening and closing.
        ///
        /// Returns: TRUE if the channel state is open,  FALSE otherwise.
        #[unsafe(method(isOpen))]
        #[unsafe(method_family = none)]
        pub unsafe fn isOpen(&self) -> bool;

        #[cfg(feature = "Bluetooth")]
        /// Returns the channel maximum transfer unit.
        ///
        /// Returns the length of the largest chunk of data that this channel can carry. If the
        /// caller wishes to use the write:length:sleep: api the length of the data can not be bigger than
        /// the channel MTU (maximum transfer unit).
        ///
        /// Returns: Channel MTU size .
        #[unsafe(method(getMTU))]
        #[unsafe(method_family = none)]
        pub unsafe fn getMTU(&self) -> BluetoothRFCOMMMTU;

        /// Returns TRUE if flow control is off.
        ///
        /// Returns true if the remote device flow control is stopping out transmission. This is
        /// useful because we do not buffer data, we stop the transmitting actor. With this method
        /// the transmitter can check if sending data is going to be successful or is going to block.
        ///
        /// Returns: TRUE if the action of sending data will block the current thread, FALSE otherwise.
        #[unsafe(method(isTransmissionPaused))]
        #[unsafe(method_family = none)]
        pub unsafe fn isTransmissionPaused(&self) -> bool;

        /// Sends a block of data in the channel syncronously.
        ///
        /// ***WARNING*** This method is being deprecated in favor of -writeSync:... and -writeAsync:...
        /// Sends data through the channel. The number of bytes to be sent must not exceed the channel MTU.
        /// If the return value is an error condition none of the data was sent.
        ///
        /// Parameter `data`: is a pointer to the data buffer to be sent.
        ///
        /// Parameter `length`: the length of the buffer to be sent (in bytes).
        ///
        /// Parameter `sleep`: is a boolean if set to TRUE the call will wait until it is possible to send data.
        /// If set to FALSE and it is not possible to send data the method will return immediately with an
        /// error.
        ///
        /// Returns: An error code value. 0 if successful.
        ///
        /// # Safety
        ///
        /// `data` must be a valid pointer.
        #[deprecated]
        #[unsafe(method(write:length:sleep:))]
        #[unsafe(method_family = none)]
        pub unsafe fn write_length_sleep(
            &self,
            data: *mut c_void,
            length: u16,
            sleep: bool,
        ) -> IOReturn;

        /// Sends a block of data in the channel asynchronously.
        ///
        /// The number of bytes to be sent must not exceed the channel MTU.
        /// If the return value is an error condition none of the data was sent.  Once the data
        /// has been successfully passed to the hardware to be transmitted, the delegate method
        /// -rfcommChannelWriteComplete:refcon:status: will be called with the refcon that was passed
        /// to this method.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Parameter `data`: A pointer to the data buffer to be sent.
        ///
        /// Parameter `length`: The length of the buffer to be sent (in bytes).
        ///
        /// Parameter `refcon`: User supplied value that gets passed to the write callback.
        ///
        /// Returns: Returns kIOReturnSuccess if the data was buffered successfully.
        ///
        /// # Safety
        ///
        /// - `data` must be a valid pointer.
        /// - `refcon` must be a valid pointer.
        #[unsafe(method(writeAsync:length:refcon:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeAsync_length_refcon(
            &self,
            data: *mut c_void,
            length: u16,
            refcon: *mut c_void,
        ) -> IOReturn;

        /// Sends a block of data in the channel synchronously.
        ///
        /// Sends data through the channel. The number of bytes to be sent must not exceed the channel MTU.
        /// If the return value is an error condition none of the data was sent.  This method will
        /// block until the data has been successfully sent to the hardware for transmission (or until
        /// an error occurs).
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        ///
        /// Parameter `data`: A pointer to the data buffer to be sent.
        ///
        /// Parameter `length`: The length of the buffer to be sent (in bytes).
        ///
        /// Returns: Returns kIOReturnSuccess if the data was written successfully.
        ///
        /// # Safety
        ///
        /// `data` must be a valid pointer.
        #[unsafe(method(writeSync:length:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeSync_length(&self, data: *mut c_void, length: u16) -> IOReturn;

        /// Sends a block of data in the channel.
        ///
        /// ***WARNING*** This method is being deprecated in favor of -writeSync:... and -writeAsync:...
        /// Sends data through the channel. The number of bytes to be sent is arbitrary. The caller
        /// does not have to worry about the MTU.
        ///
        /// Parameter `data`: a pointer to the data buffer to be sent.
        ///
        /// Parameter `length`: the length of the buffer to be sent (in bytes).
        ///
        /// Parameter `sleep`: a boolean if set to TRUE the call will wait until it is possible to send all the data.
        ///
        /// Parameter `a`: UInt32 pointer in which the caller received the nuber of bytes sent.
        /// If set to FALSE and it is not possible to send part of the data the method will return immediately.
        ///
        /// Returns: An error code value. 0 if successful.
        ///
        /// # Safety
        ///
        /// - `data` must be a valid pointer.
        /// - `num_bytes_sent` must be a valid pointer.
        #[deprecated]
        #[unsafe(method(writeSimple:length:sleep:bytesSent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn writeSimple_length_sleep_bytesSent(
            &self,
            data: *mut c_void,
            length: u16,
            sleep: bool,
            num_bytes_sent: *mut u32,
        ) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Changes the parameters of the serial connection.
        ///
        /// Parameter `speed`: the baudrate.
        ///
        /// Parameter `nBits`: number of data bits.
        ///
        /// Parameter `parity`: the type of parity can be NoParity, OddParity, EvenParity or MaxParity.
        ///
        /// Parameter `bitStop`: number of stop bits.
        ///
        /// Returns: An error code value. 0 if successful.
        #[unsafe(method(setSerialParameters:dataBits:parity:stopBits:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSerialParameters_dataBits_parity_stopBits(
            &self,
            speed: u32,
            n_bits: u8,
            parity: BluetoothRFCOMMParityType,
            bit_stop: u8,
        ) -> IOReturn;

        #[cfg(feature = "Bluetooth")]
        /// Sends an error to the remote side.
        ///
        /// Parameter `lineStatus`: the error type. The error code can be NoError, OverrunError, ParityError or FramingError.
        ///
        /// Returns: An error code value. 0 if successful.
        #[unsafe(method(sendRemoteLineStatus:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendRemoteLineStatus(
            &self,
            line_status: BluetoothRFCOMMLineStatus,
        ) -> IOReturn;

        /// Allows an object to register itself as a client of the RFCOMM channel.
        ///
        /// A channel delegate is the object the RFCOMM channel uses as target for data and events. The
        /// developer will implement only the the methods he/she is interested in. A list of the
        /// possible methods is at the end of this file in the definition of the informal protocol
        /// IOBluetoothRFCOMMChannelDelegate.
        ///
        /// NOTE: This method is only available in Mac OS X 10.2.5 (Bluetooth v1.2) or later.
        /// NOTE: Before Mac OS X 10.6, the delegate was retained.  On 10.6 and later, it is not.
        ///
        /// Parameter `delegate`: The object that will play the role of channel delegate [NOTE the rfcomm channel will reatin the delegate].
        ///
        /// Returns: Returns kIOReturnSuccess if the delegate is successfully registered.
        ///
        /// # Safety
        ///
        /// - `delegate` should be of the correct type.
        /// - `delegate` might not allow `None`.
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&AnyObject>) -> IOReturn;

        /// Returns the object delegate
        ///
        /// Returns: the current delegate, or nil
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<AnyObject>>;

        #[cfg(feature = "Bluetooth")]
        /// Returns the object rfcomm channel ID.
        ///
        /// Returns: the RFCOMM channel number .
        #[unsafe(method(getChannelID))]
        #[unsafe(method_family = none)]
        pub unsafe fn getChannelID(&self) -> BluetoothRFCOMMChannelID;

        /// Returns the direction of the channel.  An incoming channel is one that was opened by the remote
        /// device.
        ///
        /// Returns: Returns TRUE if the channel was opened by the remote device, FALSE if the channel was opened by this object.
        #[unsafe(method(isIncoming))]
        #[unsafe(method_family = none)]
        pub unsafe fn isIncoming(&self) -> bool;

        #[cfg(feature = "IOBluetoothDevice")]
        /// Returns the Bluetooth Device that carries the rfcomm data.
        ///
        /// Returns: the IOBluetoothDevice object .
        #[unsafe(method(getDevice))]
        #[unsafe(method_family = none)]
        pub unsafe fn getDevice(&self) -> Option<Retained<IOBluetoothDevice>>;

        #[cfg(feature = "IOBluetoothUserLib")]
        /// Returns the IOBluetoothObjectID of the given IOBluetoothRFCOMMChannel.
        ///
        /// The IOBluetoothObjectID can be used as a global reference for a given IOBluetoothRFCOMMChannel.  It allows
        /// two separate applications to refer to the same IOBluetoothRFCOMMChannel.
        ///
        /// Returns: Returns the IOBluetoothObjectID of the given IOBluetoothRFCOMMChannel.
        #[unsafe(method(getObjectID))]
        #[unsafe(method_family = none)]
        pub unsafe fn getObjectID(&self) -> IOBluetoothObjectID;

        #[cfg(feature = "IOBluetoothUserNotification")]
        /// Allows a client to register for a channel close notification.
        ///
        /// The given selector will be called on the target observer when the RFCOMM channel is closed.
        /// The selector should contain two arguments.  The first is the user notification object. The second
        /// is the IOBluetoothRFCOMMChannel that was closed.
        ///
        /// Parameter `observer`: Target observer object
        ///
        /// Parameter `inSelector`: Selector to be sent to the observer when the RFCOMM channel is closed.
        ///
        /// Returns: Returns an IOBluetoothUserNotification representing the outstanding RFCOMM channel close notification.
        /// To unregister the notification, call -unregister of the returned IOBluetoothUserNotification
        /// object.  If an error is encountered creating the notification, nil is returned.
        ///
        /// # Safety
        ///
        /// - `observer` should be of the correct type.
        /// - `observer` might not allow `None`.
        /// - `in_selector` must be a valid selector.
        #[unsafe(method(registerForChannelCloseNotification:selector:))]
        #[unsafe(method_family = none)]
        pub unsafe fn registerForChannelCloseNotification_selector(
            &self,
            observer: Option<&AnyObject>,
            in_selector: Option<Sel>,
        ) -> Option<Retained<IOBluetoothUserNotification>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "IOBluetoothObject")]
impl IOBluetoothRFCOMMChannel {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/iobluetoothrfcommchanneldelegate?language=objc)
    pub unsafe trait IOBluetoothRFCOMMChannelDelegate {
        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// - `rfcomm_channel` might not allow `None`.
        /// - `data_pointer` must be a valid pointer.
        #[optional]
        #[unsafe(method(rfcommChannelData:data:length:))]
        #[unsafe(method_family = none)]
        unsafe fn rfcommChannelData_data_length(
            &self,
            rfcomm_channel: Option<&IOBluetoothRFCOMMChannel>,
            data_pointer: *mut c_void,
            data_length: usize,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `rfcomm_channel` might not allow `None`.
        #[optional]
        #[unsafe(method(rfcommChannelOpenComplete:status:))]
        #[unsafe(method_family = none)]
        unsafe fn rfcommChannelOpenComplete_status(
            &self,
            rfcomm_channel: Option<&IOBluetoothRFCOMMChannel>,
            error: IOReturn,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `rfcomm_channel` might not allow `None`.
        #[optional]
        #[unsafe(method(rfcommChannelClosed:))]
        #[unsafe(method_family = none)]
        unsafe fn rfcommChannelClosed(&self, rfcomm_channel: Option<&IOBluetoothRFCOMMChannel>);

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `rfcomm_channel` might not allow `None`.
        #[optional]
        #[unsafe(method(rfcommChannelControlSignalsChanged:))]
        #[unsafe(method_family = none)]
        unsafe fn rfcommChannelControlSignalsChanged(
            &self,
            rfcomm_channel: Option<&IOBluetoothRFCOMMChannel>,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `rfcomm_channel` might not allow `None`.
        #[optional]
        #[unsafe(method(rfcommChannelFlowControlChanged:))]
        #[unsafe(method_family = none)]
        unsafe fn rfcommChannelFlowControlChanged(
            &self,
            rfcomm_channel: Option<&IOBluetoothRFCOMMChannel>,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// - `rfcomm_channel` might not allow `None`.
        /// - `refcon` must be a valid pointer.
        #[optional]
        #[unsafe(method(rfcommChannelWriteComplete:refcon:status:))]
        #[unsafe(method_family = none)]
        unsafe fn rfcommChannelWriteComplete_refcon_status(
            &self,
            rfcomm_channel: Option<&IOBluetoothRFCOMMChannel>,
            refcon: *mut c_void,
            error: IOReturn,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// - `rfcomm_channel` might not allow `None`.
        /// - `refcon` must be a valid pointer.
        #[optional]
        #[unsafe(method(rfcommChannelWriteComplete:refcon:status:bytesWritten:))]
        #[unsafe(method_family = none)]
        unsafe fn rfcommChannelWriteComplete_refcon_status_bytesWritten(
            &self,
            rfcomm_channel: Option<&IOBluetoothRFCOMMChannel>,
            refcon: *mut c_void,
            error: IOReturn,
            length: usize,
        );

        #[cfg(feature = "IOBluetoothObject")]
        /// # Safety
        ///
        /// `rfcomm_channel` might not allow `None`.
        #[optional]
        #[unsafe(method(rfcommChannelQueueSpaceAvailable:))]
        #[unsafe(method_family = none)]
        unsafe fn rfcommChannelQueueSpaceAvailable(
            &self,
            rfcomm_channel: Option<&IOBluetoothRFCOMMChannel>,
        );
    }
);
