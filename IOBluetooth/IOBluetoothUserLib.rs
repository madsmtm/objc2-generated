//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

pub const kIOBluetoothObjectIDNULL: IOBluetoothObjectID = 0;
#[repr(C)]
pub struct IOBluetoothObjectRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2-core-foundation")]
cf_type!(
    unsafe impl IOBluetoothObjectRef {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueIOBluetoothObjectRef"> for IOBluetoothObjectRef {}
);

/// An object that represents a Bluetooth I/O device.
#[repr(C)]
pub struct IOBluetoothDeviceRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2-core-foundation")]
cf_type!(
    unsafe impl IOBluetoothDeviceRef {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueIOBluetoothObjectRef"> for IOBluetoothDeviceRef {}
);

#[repr(C)]
pub struct IOBluetoothL2CAPChannelRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2-core-foundation")]
cf_type!(
    unsafe impl IOBluetoothL2CAPChannelRef {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueIOBluetoothObjectRef"> for IOBluetoothL2CAPChannelRef {}
);

#[repr(C)]
pub struct IOBluetoothRFCOMMChannelRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2-core-foundation")]
cf_type!(
    unsafe impl IOBluetoothRFCOMMChannelRef {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueIOBluetoothObjectRef"> for IOBluetoothRFCOMMChannelRef {}
);

#[repr(C)]
pub struct IOBluetoothSDPServiceRecordRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2-core-foundation")]
cf_type!(
    unsafe impl IOBluetoothSDPServiceRecordRef {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueIOBluetoothObjectRef"> for IOBluetoothSDPServiceRecordRef {}
);

#[repr(C)]
pub struct IOBluetoothSDPUUIDRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2-core-foundation")]
cf_type!(
    unsafe impl IOBluetoothSDPUUIDRef {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueIOBluetoothObjectRef"> for IOBluetoothSDPUUIDRef {}
);

#[repr(C)]
pub struct IOBluetoothSDPDataElementRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2-core-foundation")]
cf_type!(
    unsafe impl IOBluetoothSDPDataElementRef {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueIOBluetoothObjectRef"> for IOBluetoothSDPDataElementRef {}
);

#[repr(C)]
pub struct IOBluetoothUserNotificationRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2-core-foundation")]
cf_type!(
    unsafe impl IOBluetoothUserNotificationRef {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueIOBluetoothObjectRef"> for IOBluetoothUserNotificationRef {}
);

pub type IOBluetoothObjectID = c_ulong;

pub type IOBluetoothDeviceSearchOptions = u32;

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOBluetoothDeviceSearchOptionsBits(pub c_uint);
impl IOBluetoothDeviceSearchOptionsBits {
    #[doc(alias = "kSearchOptionsNone")]
    pub const SearchOptionsNone: Self = Self(0);
    #[doc(alias = "kSearchOptionsAlwaysStartInquiry")]
    pub const SearchOptionsAlwaysStartInquiry: Self = Self(1 << 0);
    #[doc(alias = "kSearchOptionsDiscardCachedResults")]
    pub const SearchOptionsDiscardCachedResults: Self = Self(1 << 1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBluetoothDeviceSearchOptionsBits {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBluetoothDeviceSearchOptionsBits {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Structure used to search for particular devices.
///
/// ## Overview
///
/// You can search for general device classes and service classes, or you can search for a specific device address or name. If you pass NULL as the attribute structure, you will get ALL devices in the vicinity found during a search. Note that passing a zeroed out block of attributes is NOT equivalent to passing in NULL!
///
///
/// Structure used to search for particular devices.
///
/// Make sure you specify all fields! If you do not set deviceClassMajor for example, and the value is
/// 0, that is mapped to kBluetoothDeviceClassMajorMiscellaneous, which is probably not what you want. To
/// search for all device types, you must pass kBluetoothDeviceClassMajorAny and its relatives.
#[cfg(feature = "Bluetooth")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOBluetoothDeviceSearchDeviceAttributes {
    pub address: BluetoothDeviceAddress,
    pub name: BluetoothDeviceName,
    pub serviceClassMajor: BluetoothServiceClassMajor,
    pub deviceClassMajor: BluetoothDeviceClassMajor,
    pub deviceClassMinor: BluetoothDeviceClassMinor,
}

#[cfg(all(feature = "Bluetooth", feature = "objc2"))]
unsafe impl Encode for IOBluetoothDeviceSearchDeviceAttributes {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBluetoothDeviceSearchDeviceAttributes",
        &[
            <BluetoothDeviceAddress>::ENCODING,
            <BluetoothDeviceName>::ENCODING,
            <BluetoothServiceClassMajor>::ENCODING,
            <BluetoothDeviceClassMajor>::ENCODING,
            <BluetoothDeviceClassMinor>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "Bluetooth", feature = "objc2"))]
unsafe impl RefEncode for IOBluetoothDeviceSearchDeviceAttributes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Structure used to search for particular devices.
///
/// ## Overview
///
/// You can search for general device classes and service classes, or you can search for a specific device address or name. If you pass NULL as the attribute structure, you will get ALL devices in the vicinity found during a search. Note that passing a zeroed out block of attributes is NOT equivalent to passing in NULL!
///
///
/// You can search for general device classes and service classes, or you can search for a
/// specific device address or name. If you pass NULL as the attribute structure,
/// you will get ALL devices in the vicinity found during a search. Note that passing a zeroed
/// out block of attributes is NOT equivalent to passing in NULL!
#[cfg(feature = "Bluetooth")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct IOBluetoothDeviceSearchAttributes {
    pub options: IOBluetoothDeviceSearchOptions,
    pub maxResults: IOItemCount,
    pub deviceAttributeCount: IOItemCount,
    pub attributeList: *mut IOBluetoothDeviceSearchDeviceAttributes,
}

#[cfg(all(feature = "Bluetooth", feature = "objc2"))]
unsafe impl Encode for IOBluetoothDeviceSearchAttributes {
    const ENCODING: Encoding = Encoding::Struct(
        "IOBluetoothDeviceSearchAttributes",
        &[
            <IOBluetoothDeviceSearchOptions>::ENCODING,
            <IOItemCount>::ENCODING,
            <IOItemCount>::ENCODING,
            <*mut IOBluetoothDeviceSearchDeviceAttributes>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "Bluetooth", feature = "objc2"))]
unsafe impl RefEncode for IOBluetoothDeviceSearchAttributes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type IOBluetoothDeviceSearchTypes = u32;

/// Bits to determine what Bluetooth devices to search for
///
/// ## Overview
///
/// You can search for general device classes and service classes, or you can search for a specific device address or name. If you pass NULL as the attribute structure, you will get ALL devices in the vicinity found during a search. Note that passing a zeroed out block of attributes is NOT equivalent to passing in NULL!
///
///
/// Bits to determine what Bluetooth devices to search for
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOBluetoothDeviceSearchTypesBits(pub c_uint);
impl IOBluetoothDeviceSearchTypesBits {
    #[doc(alias = "kIOBluetoothDeviceSearchClassic")]
    pub const Classic: Self = Self(1);
    #[doc(alias = "kIOBluetoothDeviceSearchLE")]
    pub const LE: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBluetoothDeviceSearchTypesBits {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBluetoothDeviceSearchTypesBits {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Hints that the macOS Bluetooth software should ignore a HID device that connects up.
    ///
    /// Parameters:
    /// - device: A Bluetooth Device to ignore.
    ///
    /// Hints that the Mac OS X Bluetooth software should ignore a HID device that connects up.
    ///
    /// Parameter `device`: A Bluetooth Device to ignore.
    ///
    /// # Safety
    ///
    /// `device` might not allow `None`.
    pub fn IOBluetoothIgnoreHIDDevice(device: Option<&IOBluetoothDeviceRef>);
}

extern "C-unwind" {
    /// The counterpart to the above IOBluetoothIgnoreHIDDevice() API.
    ///
    /// Parameters:
    /// - device: A Bluetooth Device to “un”ignore.
    ///
    /// The counterpart to the above IOBluetoothIgnoreHIDDevice() API.
    ///
    /// Parameter `device`: A Bluetooth Device to "un"ignore.
    ///
    /// # Safety
    ///
    /// `device` might not allow `None`.
    pub fn IOBluetoothRemoveIgnoredHIDDevice(device: Option<&IOBluetoothDeviceRef>);
}

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOBluetoothUserNotificationChannelDirection(pub c_uint);
impl IOBluetoothUserNotificationChannelDirection {
    #[doc(alias = "kIOBluetoothUserNotificationChannelDirectionAny")]
    pub const Any: Self = Self(0);
    #[doc(alias = "kIOBluetoothUserNotificationChannelDirectionIncoming")]
    pub const Incoming: Self = Self(1);
    #[doc(alias = "kIOBluetoothUserNotificationChannelDirectionOutgoing")]
    pub const Outgoing: Self = Self(2);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOBluetoothUserNotificationChannelDirection {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOBluetoothUserNotificationChannelDirection {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Callback function definition for user notifications.
///
/// Parameters:
/// - userRefCon: (Void *) This user defined parameter was provided during the original call to register the notification.
///
/// - inRef: (IOBluetoothUserNotificationRef) The notification responsible for sending the notification.
///
/// - status: (IOBluetoothObjectRef) The object that originated the notification.
///
///
/// ## Return Value
///
/// None.
///
///
///
/// ## Discussion
///
/// This callback will be invoked when the notification for which it was registered is sent.
///
///
/// Callback function definition for user notifications.
///
/// This callback will be invoked when the notification for which it was registered is sent.
///
/// Parameter `userRefCon`: (void *) This user defined parameter was provided during the original call to register
/// the notification.
///
/// Parameter `inRef`: (IOBluetoothUserNotificationRef) The notification responsible for sending the notification.
///
/// Parameter `objectRef`: (IOBluetoothObjectRef) The object that originated the notification.
pub type IOBluetoothUserNotificationCallback = Option<
    unsafe extern "C-unwind" fn(
        *mut c_void,
        *mut IOBluetoothUserNotificationRef,
        *mut IOBluetoothObjectRef,
    ),
>;

impl IOBluetoothUserNotificationRef {
    /// Unregisters the target notification.
    ///
    /// Parameters:
    /// - notificationRef: The target IOBluetoothUserNotificationRef to be unregistered
    ///
    ///
    /// ## Discussion
    ///
    /// This function will unregister the notification. Once the notification has been unregistered, it will no longer call the callback. Additionally, once this function has been called the target IOBluetoothUserNotificationRef is no longer valid.
    ///
    ///
    /// Unregisters the target notification.
    ///
    /// This function will unregister the notification.  Once the notification has been unregistered,
    /// it will no longer call the callback.  Additionally, once this function has been called the
    /// target IOBluetoothUserNotificationRef is no longer valid.
    ///
    /// Parameter `notificationRef`: The target IOBluetoothUserNotificationRef to be unregistered
    #[doc(alias = "IOBluetoothUserNotificationUnregister")]
    #[inline]
    pub unsafe fn unregister(&self) {
        extern "C-unwind" {
            fn IOBluetoothUserNotificationUnregister(
                notification_ref: &IOBluetoothUserNotificationRef,
            );
        }
        unsafe { IOBluetoothUserNotificationUnregister(self) }
    }
}

impl IOBluetoothL2CAPChannelRef {
    /// Allows a client to register for a channel close notification.
    ///
    /// Parameters:
    /// - channel: The target L2CAP channel
    ///
    /// - callback: Callback to be called when the L2CAP channel is closed.
    ///
    /// - inRefCon: Client-supplied refCon to be passed to the callback.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns an IOBluetoothUserNotificationRef representing the outstanding L2CAP channel close notification. To unregister the notification, call IOBluetoothUserNotificationUnregister() with the returned IOBluetoothUserNotificationRef. If an error is encountered creating the notification, NULL is returned. The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered. It is not necessary to retain the result. Once the notification is unregistered, it will no longer be valid.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The given callback will be called when the L2CAP channel is closed.
    ///
    ///
    /// Allows a client to register for a channel close notification.
    ///
    /// The given callback will be called when the L2CAP channel is closed.
    ///
    /// Parameter `channel`: The target L2CAP channel
    ///
    /// Parameter `callback`: Callback to be called when the L2CAP channel is closed.
    ///
    /// Parameter `inRefCon`: Client-supplied refCon to be passed to the callback.
    ///
    /// Returns: Returns an IOBluetoothUserNotificationRef representing the outstanding L2CAP channel close notification.
    /// To unregister the notification, call IOBluetoothUserNotificationUnregister(void) with the returned
    /// IOBluetoothUserNotificationRef.  If an error is encountered creating the notification, NULL is returned.
    /// The returned IOBluetoothUserNotificationRef will be valid for as long as the notification is registered.
    /// It is not necessary to retain the result.  Once the notification is unregistered, it will no longer
    /// be valid.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `in_ref_con` must be a valid pointer.
    #[doc(alias = "IOBluetoothL2CAPChannelRegisterForChannelCloseNotification")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn register_for_channel_close_notification(
        &self,
        callback: IOBluetoothUserNotificationCallback,
        in_ref_con: *mut c_void,
    ) -> Option<CFRetained<IOBluetoothUserNotificationRef>> {
        extern "C-unwind" {
            fn IOBluetoothL2CAPChannelRegisterForChannelCloseNotification(
                channel: &IOBluetoothL2CAPChannelRef,
                callback: IOBluetoothUserNotificationCallback,
                in_ref_con: *mut c_void,
            ) -> Option<NonNull<IOBluetoothUserNotificationRef>>;
        }
        let ret = unsafe {
            IOBluetoothL2CAPChannelRegisterForChannelCloseNotification(self, callback, in_ref_con)
        };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }
}

extern "C-unwind" {
    /// Creates a persistent audio driver that will route audio data to/from the specified device.
    ///
    /// Parameters:
    /// - device: A paired Bluetooth audio device
    ///
    /// - configDict: Configuration dictionary containing a description of the audio controls to be attached to the driver. Passing NULL will result in default controls
    ///
    ///
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if the audio driver was successfully created, error if hardware does not support SCO or device is not paired.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The Bluetooth device must be paired before it can be added. The Bluetooth hardware must also support SCO connections for devices to be added.
    ///
    /// When a client attempts to use the audio driver, it will automatically open the baseband connection and the SCO connection if necessary. Once they are open, it will route audio data to/from the audio system. The audio driver will continue to exist (even through reboots) until IOBluetoothRemoveAudioDevice is called.
    ///
    /// Currently, the only recognized entry in the configDict is “IOAudioControls”. That entry will be an NSArray of NSDictionary objects where each dictionary represents a single audio control. Following is a description of the mandatory and optional entries in each control dictionary.
    ///
    /// Mandatory entries:
    ///
    /// kIOAudioControlTypeKey = Four-char-code representing the control type (see IOAudioTypes.h) Possible values: kIOAudioControlTypeLevel kIOAudioControlTypeToggle kIOAudioControlTypeSelector kIOAudioControlSubTypeKey = Four-char-code representing the control subtype. The value is dependent on the control type. Following are common subtypes for each control type: kIOAudioControlTypeLevel: kIOAudioLevelControlSubTypeVolume kIOAudioControlTypeToggle: kIOAudioToggleControlSubTypeMute kIOAudioControlTypeSelector: kIOAudioSelectorControlSubTypeOutput kIOAudioSelectorControlSubTypeInput kIOAudioControlUsageKey = Four-char-code representing the usage of the control (i.e. what part of the I/O chain the control affects - input, output, pass-thru, …) (see IOAudioTypes.h) Possible values: kIOAudioControlUsageOutput kIOAudioControlUsageInput kIOAudioControlUsagePassThru kIOAudioControlChannelIDKey = channel ID for the channel(s) the control acts on (see IOAudioControl.h and IOAudioTypes.h for more info) kIOAudioControlChannelNameKey = name for the channel (see IOAudioControl.h and IOAudioDefines.h for more info) kIOAudioControlValueKey = Initial value of the control - as an NSNumber
    ///
    /// Optional entries: kIOAudioControlIDKey = Optional developer-defined ID field used to uniquely identify each control.
    ///
    /// Level control-specific entries (see IOAudioDefines.h) kIOAudioLevelControlMinValueKey = Min value for the range for the level control kIOAudioLevelControlMaxValueKey = Max value for the range for the level control kIOAudioLevelControlMinDBKey = Min value in db for the range for the level control. Value is a fixed-point 16.16 number represented as an integer in an NSNumber. kIOAudioLevelControlMaxDBKey = Max value in db for the range for the level control. Value is a fixed-point 16.16 number represented as an integer in an NSNumber.
    ///
    /// For a more detailed description of these attributes and how IOAudioControls work, see the headerdoc for IOAudioControl, IOAudioLevelControl, IOAudioToggleControl and IOAudioSelectorControl in the Kernel.framework.
    ///
    ///
    /// Creates a persistent audio driver that will route audio data to/from the specified device.
    ///
    /// In 10.9 this is not needed and does nothing.
    ///
    /// Parameter `device`: A paired Bluetooth audio device
    ///
    /// Parameter `configDict`: Configuration dictionary containing a description of the audio controls to be attached to the driver.  Passing NULL will result in default controls
    ///
    /// Returns: Returns kIOReturnSuccess if the audio driver was successfully created, error if hardware does not support SCO or device is not paired. On 10.9 it will always return kIOReturnSuccess.
    ///
    /// # Safety
    ///
    /// - `device` might not allow `None`.
    /// - `config_dict` generic must be of the correct type.
    /// - `config_dict` generic must be of the correct type.
    /// - `config_dict` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated]
    pub fn IOBluetoothAddSCOAudioDevice(
        device: Option<&IOBluetoothDeviceRef>,
        config_dict: Option<&CFDictionary>,
    ) -> IOReturn;
}

extern "C-unwind" {
    /// Removes a persistent audio driver for a device that had already been added using IOBluetoothAddAudioDevice().
    ///
    /// Parameters:
    /// - device: Bluetooth audio device to remove
    ///
    ///
    /// ## Return Value
    ///
    /// Returns kIOReturnSuccess if the audio driver was successfully removed.
    ///
    ///
    /// Removes a persistent audio driver for a device that had already been added using IOBluetoothAddAudioDevice(). In 10.9 this is not needed and does nothing.
    ///
    /// Parameter `device`: Bluetooth audio device to remove
    ///
    /// Returns: Returns kIOReturnSuccess if the audio driver was successfully removed. On 10.9 it will always return kIOReturnSuccess
    ///
    /// # Safety
    ///
    /// `device` might not allow `None`.
    #[deprecated]
    pub fn IOBluetoothRemoveSCOAudioDevice(device: Option<&IOBluetoothDeviceRef>) -> IOReturn;
}

extern "C-unwind" {
    #[deprecated = "renamed to `IOBluetoothUserNotificationRef::unregister`"]
    pub fn IOBluetoothUserNotificationUnregister(notification_ref: &IOBluetoothUserNotificationRef);
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `IOBluetoothL2CAPChannelRef::register_for_channel_close_notification`"]
#[inline]
pub unsafe extern "C-unwind" fn IOBluetoothL2CAPChannelRegisterForChannelCloseNotification(
    channel: &IOBluetoothL2CAPChannelRef,
    callback: IOBluetoothUserNotificationCallback,
    in_ref_con: *mut c_void,
) -> Option<CFRetained<IOBluetoothUserNotificationRef>> {
    extern "C-unwind" {
        fn IOBluetoothL2CAPChannelRegisterForChannelCloseNotification(
            channel: &IOBluetoothL2CAPChannelRef,
            callback: IOBluetoothUserNotificationCallback,
            in_ref_con: *mut c_void,
        ) -> Option<NonNull<IOBluetoothUserNotificationRef>>;
    }
    let ret = unsafe {
        IOBluetoothL2CAPChannelRegisterForChannelCloseNotification(channel, callback, in_ref_con)
    };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}
