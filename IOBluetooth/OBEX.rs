//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

pub const kCharsetStringISO88591: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CHARSET=ISO-8859-1\0") };
pub const kCharsetStringUTF8: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"UTF-8\0") };
pub const kEncodingStringQuotedPrintable: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"QUOTED-PRINTABLE\0") };
pub const kEncodingStringBase64: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BASE-64\0") };
pub const kEncodingString8Bit: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"8BIT\0") };
/// Codes for OBEX errors. If the return value was not in the following range, then it is most likely resulting from kernel code/IOKit, and you should consult IOReturn.h for those codes.
/// Codes for OBEX errors. If the return value was not in the following range, then it is most likely resulting
/// from kernel code/IOKit, and you should consult IOReturn.h for those codes.
pub type OBEXError = i32;

#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OBEXErrorCodes(pub c_int);
impl OBEXErrorCodes {
    ///
    /// ## Discussion
    ///
    /// Minimum value in OBEX error range.
    ///
    ///
    #[doc(alias = "kOBEXErrorRangeMin")]
    pub const ErrorRangeMin: Self = Self(-21850);
    ///
    /// ## Discussion
    ///
    /// Maximum value in OBEX error range.
    ///
    ///
    #[doc(alias = "kOBEXErrorRangeMax")]
    pub const ErrorRangeMax: Self = Self(-21899);
    #[doc(alias = "kOBEXSuccess")]
    pub const Success: Self = Self(0);
    #[doc(alias = "kOBEXGeneralError")]
    pub const GeneralError: Self = Self(-21850);
    #[doc(alias = "kOBEXNoResourcesError")]
    pub const NoResourcesError: Self = Self(-21851);
    #[doc(alias = "kOBEXUnsupportedError")]
    pub const UnsupportedError: Self = Self(-21852);
    #[doc(alias = "kOBEXInternalError")]
    pub const InternalError: Self = Self(-21853);
    #[doc(alias = "kOBEXBadArgumentError")]
    pub const BadArgumentError: Self = Self(-21854);
    #[doc(alias = "kOBEXTimeoutError")]
    pub const TimeoutError: Self = Self(-21855);
    #[doc(alias = "kOBEXBadRequestError")]
    pub const BadRequestError: Self = Self(-21856);
    #[doc(alias = "kOBEXCancelledError")]
    pub const CancelledError: Self = Self(-21857);
    #[doc(alias = "kOBEXForbiddenError")]
    pub const ForbiddenError: Self = Self(-21858);
    #[doc(alias = "kOBEXUnauthorizedError")]
    pub const UnauthorizedError: Self = Self(-21859);
    #[doc(alias = "kOBEXNotAcceptableError")]
    pub const NotAcceptableError: Self = Self(-21860);
    #[doc(alias = "kOBEXConflictError")]
    pub const ConflictError: Self = Self(-21861);
    #[doc(alias = "kOBEXMethodNotAllowedError")]
    pub const MethodNotAllowedError: Self = Self(-21862);
    #[doc(alias = "kOBEXNotFoundError")]
    pub const NotFoundError: Self = Self(-21863);
    #[doc(alias = "kOBEXNotImplementedError")]
    pub const NotImplementedError: Self = Self(-21864);
    #[doc(alias = "kOBEXPreconditionFailedError")]
    pub const PreconditionFailedError: Self = Self(-21865);
    #[doc(alias = "kOBEXSessionBusyError")]
    pub const SessionBusyError: Self = Self(-21875);
    #[doc(alias = "kOBEXSessionNotConnectedError")]
    pub const SessionNotConnectedError: Self = Self(-21876);
    #[doc(alias = "kOBEXSessionBadRequestError")]
    pub const SessionBadRequestError: Self = Self(-21877);
    #[doc(alias = "kOBEXSessionBadResponseError")]
    pub const SessionBadResponseError: Self = Self(-21878);
    #[doc(alias = "kOBEXSessionNoTransportError")]
    pub const SessionNoTransportError: Self = Self(-21879);
    #[doc(alias = "kOBEXSessionTransportDiedError")]
    pub const SessionTransportDiedError: Self = Self(-21880);
    #[doc(alias = "kOBEXSessionTimeoutError")]
    pub const SessionTimeoutError: Self = Self(-21881);
    #[doc(alias = "kOBEXSessionAlreadyConnectedError")]
    pub const SessionAlreadyConnectedError: Self = Self(-21882);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXErrorCodes {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXErrorCodes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Identifiers for OBEX Headers.
/// Identifiers for OBEX Headers.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXHeaderIdentifiers(pub c_uint);
impl OBEXHeaderIdentifiers {
    ///
    /// ## Discussion
    ///
    /// Name of the object. Null terminated unicode text.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDName")]
    pub const IDName: Self = Self(0x01);
    ///
    /// ## Discussion
    ///
    /// Text description of the object. Null terminated unicode text.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDDescription")]
    pub const IDDescription: Self = Self(0x05);
    ///
    /// ## Discussion
    ///
    /// Range includes all combos of the upper 2 bits. Reserved.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDReservedRangeStart")]
    pub const IDReservedRangeStart: Self = Self(0x10);
    ///
    /// ## Discussion
    ///
    /// Range includes all combos of the upper 2 bits. Reserved.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDReservedRangeEnd")]
    pub const IDReservedRangeEnd: Self = Self(0x2F);
    ///
    /// ## Discussion
    ///
    /// Range includes all combos of the upper 2 bits. User defined.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDUserDefinedRangeStart")]
    pub const IDUserDefinedRangeStart: Self = Self(0x30);
    ///
    /// ## Discussion
    ///
    /// Range includes all combos of the upper 2 bits. User defined.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDUserDefinedRangeEnd")]
    pub const IDUserDefinedRangeEnd: Self = Self(0x3F);
    ///
    /// ## Discussion
    ///
    /// Type of object - e.g. text, html, binary, etc. Null terminated ASCII text.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDType")]
    pub const IDType: Self = Self(0x42);
    ///
    /// ## Discussion
    ///
    /// Date/time stamp - ISO8601 version of time. (YYYYMMDDTHHMMSSZ)
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDTimeISO")]
    pub const IDTimeISO: Self = Self(0x44);
    ///
    /// ## Discussion
    ///
    /// Name of service that operation is destined for.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDTarget")]
    pub const IDTarget: Self = Self(0x46);
    ///
    /// ## Discussion
    ///
    /// An HTTP 1.x header.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDHTTP")]
    pub const IDHTTP: Self = Self(0x47);
    ///
    /// ## Discussion
    ///
    /// A Chunk of the object body.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDBody")]
    pub const IDBody: Self = Self(0x48);
    ///
    /// ## Discussion
    ///
    /// The last checking of the object body.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDEndOfBody")]
    pub const IDEndOfBody: Self = Self(0x49);
    ///
    /// ## Discussion
    ///
    /// Identifies the OBEX applications, used to tell if talking to a peer.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDWho")]
    pub const IDWho: Self = Self(0x4A);
    ///
    /// ## Discussion
    ///
    /// Extended application request and resposnse info.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDAppParameters")]
    pub const IDAppParameters: Self = Self(0x4C);
    ///
    /// ## Discussion
    ///
    /// Authentication digest-challenge.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDAuthorizationChallenge")]
    pub const IDAuthorizationChallenge: Self = Self(0x4D);
    ///
    /// ## Discussion
    ///
    /// Authentication digest-reponse.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDAuthorizationResponse")]
    pub const IDAuthorizationResponse: Self = Self(0x4E);
    ///
    /// ## Discussion
    ///
    /// OBEX Object - class of object.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDObjectClass")]
    pub const IDObjectClass: Self = Self(0x4F);
    ///
    /// ## Discussion
    ///
    /// Number of objects (used in Connect command).
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDCount")]
    pub const IDCount: Self = Self(0xC0);
    ///
    /// ## Discussion
    ///
    /// The length of the object in bytes. 4 byte unsigned integer value.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDLength")]
    pub const IDLength: Self = Self(0xC3);
    ///
    /// ## Discussion
    ///
    /// Date/time stamp - 4 byte version for compat. only. Seconds since Jan 1, 1970.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDTime4Byte")]
    pub const IDTime4Byte: Self = Self(0xC4);
    ///
    /// ## Discussion
    ///
    /// An identifier used for OBEX connection multiplexing.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDConnectionID")]
    pub const IDConnectionID: Self = Self(0xCB);
    ///
    /// ## Discussion
    ///
    /// Used to provide state information when layering OBEX over stateless networks. 16byte UUID.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDOBEX13WANUUID")]
    pub const IDOBEX13WANUUID: Self = Self(0x50);
    ///
    /// ## Discussion
    ///
    /// Used to reference the object class and properties. Byte Sequence.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDOBEX13ObjectClass")]
    pub const IDOBEX13ObjectClass: Self = Self(0x51);
    ///
    /// ## Discussion
    ///
    /// Byte sequence required for CreateSession, CloseSession and other OBEX commands.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDOBEX13SessionParameters")]
    pub const IDOBEX13SessionParameters: Self = Self(0x52);
    ///
    /// ## Discussion
    ///
    /// 1-byte quantitied containing the current sequence number.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDOBEX13SessionSequenceNumber")]
    pub const IDOBEX13SessionSequenceNumber: Self = Self(0x93);
    ///
    /// ## Discussion
    ///
    /// 4-byte unsigned integer that identifies the creator of the object.
    ///
    ///
    #[doc(alias = "kOBEXHeaderIDOBEX13CreatorID")]
    pub const IDOBEX13CreatorID: Self = Self(0xCF);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXHeaderIdentifiers {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXHeaderIdentifiers {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Response opCode values.
/// Response opCode values.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OBEXOpCodeResponseValues(pub c_uint);
impl OBEXOpCodeResponseValues {
    #[doc(alias = "kOBEXResponseCodeReservedRangeStart")]
    pub const ResponseCodeReservedRangeStart: Self = Self(0x00);
    #[doc(alias = "kOBEXResponseCodeReservedRangeEnd")]
    pub const ResponseCodeReservedRangeEnd: Self = Self(0x0F);
    #[doc(alias = "kOBEXResponseCodeContinue")]
    pub const ResponseCodeContinue: Self = Self(0x10);
    #[doc(alias = "kOBEXResponseCodeContinueWithFinalBit")]
    pub const ResponseCodeContinueWithFinalBit: Self = Self(0x90);
    #[doc(alias = "kOBEXResponseCodeSuccess")]
    pub const ResponseCodeSuccess: Self = Self(0x20);
    #[doc(alias = "kOBEXResponseCodeSuccessWithFinalBit")]
    pub const ResponseCodeSuccessWithFinalBit: Self = Self(0xA0);
    #[doc(alias = "kOBEXResponseCodeCreated")]
    pub const ResponseCodeCreated: Self = Self(0x21);
    #[doc(alias = "kOBEXResponseCodeCreatedWithFinalBit")]
    pub const ResponseCodeCreatedWithFinalBit: Self = Self(0xA1);
    #[doc(alias = "kOBEXResponseCodeAccepted")]
    pub const ResponseCodeAccepted: Self = Self(0x22);
    #[doc(alias = "kOBEXResponseCodeAcceptedWithFinalBit")]
    pub const ResponseCodeAcceptedWithFinalBit: Self = Self(0xA2);
    #[doc(alias = "kOBEXResponseCodeNonAuthoritativeInfo")]
    pub const ResponseCodeNonAuthoritativeInfo: Self = Self(0x23);
    #[doc(alias = "kOBEXResponseCodeNonAuthoritativeInfoWithFinalBit")]
    pub const ResponseCodeNonAuthoritativeInfoWithFinalBit: Self = Self(0xA3);
    #[doc(alias = "kOBEXResponseCodeNoContent")]
    pub const ResponseCodeNoContent: Self = Self(0x24);
    #[doc(alias = "kOBEXResponseCodeNoContentWithFinalBit")]
    pub const ResponseCodeNoContentWithFinalBit: Self = Self(0xA4);
    #[doc(alias = "kOBEXResponseCodeResetContent")]
    pub const ResponseCodeResetContent: Self = Self(0x25);
    #[doc(alias = "kOBEXResponseCodeResetContentWithFinalBit")]
    pub const ResponseCodeResetContentWithFinalBit: Self = Self(0xA5);
    #[doc(alias = "kOBEXResponseCodePartialContent")]
    pub const ResponseCodePartialContent: Self = Self(0x26);
    #[doc(alias = "kOBEXResponseCodePartialContentWithFinalBit")]
    pub const ResponseCodePartialContentWithFinalBit: Self = Self(0xA6);
    #[doc(alias = "kOBEXResponseCodeMultipleChoices")]
    pub const ResponseCodeMultipleChoices: Self = Self(0x30);
    #[doc(alias = "kOBEXResponseCodeMultipleChoicesWithFinalBit")]
    pub const ResponseCodeMultipleChoicesWithFinalBit: Self = Self(0xB0);
    #[doc(alias = "kOBEXResponseCodeMovedPermanently")]
    pub const ResponseCodeMovedPermanently: Self = Self(0x31);
    #[doc(alias = "kOBEXResponseCodeMovedPermanentlyWithFinalBit")]
    pub const ResponseCodeMovedPermanentlyWithFinalBit: Self = Self(0xB1);
    #[doc(alias = "kOBEXResponseCodeMovedTemporarily")]
    pub const ResponseCodeMovedTemporarily: Self = Self(0x32);
    #[doc(alias = "kOBEXResponseCodeMovedTemporarilyWithFinalBit")]
    pub const ResponseCodeMovedTemporarilyWithFinalBit: Self = Self(0xB2);
    #[doc(alias = "kOBEXResponseCodeSeeOther")]
    pub const ResponseCodeSeeOther: Self = Self(0x33);
    #[doc(alias = "kOBEXResponseCodeSeeOtherWithFinalBit")]
    pub const ResponseCodeSeeOtherWithFinalBit: Self = Self(0xB3);
    #[doc(alias = "kOBEXResponseCodeNotModified")]
    pub const ResponseCodeNotModified: Self = Self(0x34);
    #[doc(alias = "kOBEXResponseCodeNotModifiedWithFinalBit")]
    pub const ResponseCodeNotModifiedWithFinalBit: Self = Self(0xB4);
    #[doc(alias = "kOBEXResponseCodeUseProxy")]
    pub const ResponseCodeUseProxy: Self = Self(0x35);
    #[doc(alias = "kOBEXResponseCodeUseProxyWithFinalBit")]
    pub const ResponseCodeUseProxyWithFinalBit: Self = Self(0xB5);
    #[doc(alias = "kOBEXResponseCodeBadRequest")]
    pub const ResponseCodeBadRequest: Self = Self(0x40);
    #[doc(alias = "kOBEXResponseCodeBadRequestWithFinalBit")]
    pub const ResponseCodeBadRequestWithFinalBit: Self = Self(0xC0);
    #[doc(alias = "kOBEXResponseCodeUnauthorized")]
    pub const ResponseCodeUnauthorized: Self = Self(0x41);
    #[doc(alias = "kOBEXResponseCodeUnauthorizedWithFinalBit")]
    pub const ResponseCodeUnauthorizedWithFinalBit: Self = Self(0xC1);
    #[doc(alias = "kOBEXResponseCodePaymentRequired")]
    pub const ResponseCodePaymentRequired: Self = Self(0x42);
    #[doc(alias = "kOBEXResponseCodePaymentRequiredWithFinalBit")]
    pub const ResponseCodePaymentRequiredWithFinalBit: Self = Self(0xC2);
    #[doc(alias = "kOBEXResponseCodeForbidden")]
    pub const ResponseCodeForbidden: Self = Self(0x43);
    #[doc(alias = "kOBEXResponseCodeForbiddenWithFinalBit")]
    pub const ResponseCodeForbiddenWithFinalBit: Self = Self(0xC3);
    #[doc(alias = "kOBEXResponseCodeNotFound")]
    pub const ResponseCodeNotFound: Self = Self(0x44);
    #[doc(alias = "kOBEXResponseCodeNotFoundWithFinalBit")]
    pub const ResponseCodeNotFoundWithFinalBit: Self = Self(0xC4);
    #[doc(alias = "kOBEXResponseCodeMethodNotAllowed")]
    pub const ResponseCodeMethodNotAllowed: Self = Self(0x45);
    #[doc(alias = "kOBEXResponseCodeMethodNotAllowedWithFinalBit")]
    pub const ResponseCodeMethodNotAllowedWithFinalBit: Self = Self(0xC5);
    #[doc(alias = "kOBEXResponseCodeNotAcceptable")]
    pub const ResponseCodeNotAcceptable: Self = Self(0x46);
    #[doc(alias = "kOBEXResponseCodeNotAcceptableWithFinalBit")]
    pub const ResponseCodeNotAcceptableWithFinalBit: Self = Self(0xC6);
    #[doc(alias = "kOBEXResponseCodeProxyAuthenticationRequired")]
    pub const ResponseCodeProxyAuthenticationRequired: Self = Self(0x47);
    #[doc(alias = "kOBEXResponseCodeProxyAuthenticationRequiredWithFinalBit")]
    pub const ResponseCodeProxyAuthenticationRequiredWithFinalBit: Self = Self(0xC7);
    #[doc(alias = "kOBEXResponseCodeRequestTimeOut")]
    pub const ResponseCodeRequestTimeOut: Self = Self(0x48);
    #[doc(alias = "kOBEXResponseCodeRequestTimeOutWithFinalBit")]
    pub const ResponseCodeRequestTimeOutWithFinalBit: Self = Self(0xC8);
    #[doc(alias = "kOBEXResponseCodeConflict")]
    pub const ResponseCodeConflict: Self = Self(0x49);
    #[doc(alias = "kOBEXResponseCodeConflictWithFinalBit")]
    pub const ResponseCodeConflictWithFinalBit: Self = Self(0xC9);
    #[doc(alias = "kOBEXResponseCodeGone")]
    pub const ResponseCodeGone: Self = Self(0x4A);
    #[doc(alias = "kOBEXResponseCodeGoneWithFinalBit")]
    pub const ResponseCodeGoneWithFinalBit: Self = Self(0xCA);
    #[doc(alias = "kOBEXResponseCodeLengthRequired")]
    pub const ResponseCodeLengthRequired: Self = Self(0x4B);
    #[doc(alias = "kOBEXResponseCodeLengthRequiredFinalBit")]
    pub const ResponseCodeLengthRequiredFinalBit: Self = Self(0xCB);
    #[doc(alias = "kOBEXResponseCodePreconditionFailed")]
    pub const ResponseCodePreconditionFailed: Self = Self(0x4C);
    #[doc(alias = "kOBEXResponseCodePreconditionFailedWithFinalBit")]
    pub const ResponseCodePreconditionFailedWithFinalBit: Self = Self(0xCC);
    #[doc(alias = "kOBEXResponseCodeRequestedEntityTooLarge")]
    pub const ResponseCodeRequestedEntityTooLarge: Self = Self(0x4D);
    #[doc(alias = "kOBEXResponseCodeRequestedEntityTooLargeWithFinalBit")]
    pub const ResponseCodeRequestedEntityTooLargeWithFinalBit: Self = Self(0xCD);
    #[doc(alias = "kOBEXResponseCodeRequestURLTooLarge")]
    pub const ResponseCodeRequestURLTooLarge: Self = Self(0x4E);
    #[doc(alias = "kOBEXResponseCodeRequestURLTooLargeWithFinalBit")]
    pub const ResponseCodeRequestURLTooLargeWithFinalBit: Self = Self(0xCE);
    #[doc(alias = "kOBEXResponseCodeUnsupportedMediaType")]
    pub const ResponseCodeUnsupportedMediaType: Self = Self(0x4F);
    #[doc(alias = "kOBEXResponseCodeUnsupportedMediaTypeWithFinalBit")]
    pub const ResponseCodeUnsupportedMediaTypeWithFinalBit: Self = Self(0xCF);
    #[doc(alias = "kOBEXResponseCodeInternalServerError")]
    pub const ResponseCodeInternalServerError: Self = Self(0x50);
    #[doc(alias = "kOBEXResponseCodeInternalServerErrorWithFinalBit")]
    pub const ResponseCodeInternalServerErrorWithFinalBit: Self = Self(0xD0);
    #[doc(alias = "kOBEXResponseCodeNotImplemented")]
    pub const ResponseCodeNotImplemented: Self = Self(0x51);
    #[doc(alias = "kOBEXResponseCodeNotImplementedWithFinalBit")]
    pub const ResponseCodeNotImplementedWithFinalBit: Self = Self(0xD1);
    #[doc(alias = "kOBEXResponseCodeBadGateway")]
    pub const ResponseCodeBadGateway: Self = Self(0x52);
    #[doc(alias = "kOBEXResponseCodeBadGatewayWithFinalBit")]
    pub const ResponseCodeBadGatewayWithFinalBit: Self = Self(0xD2);
    #[doc(alias = "kOBEXResponseCodeServiceUnavailable")]
    pub const ResponseCodeServiceUnavailable: Self = Self(0x53);
    #[doc(alias = "kOBEXResponseCodeServiceUnavailableWithFinalBit")]
    pub const ResponseCodeServiceUnavailableWithFinalBit: Self = Self(0xD3);
    #[doc(alias = "kOBEXResponseCodeGatewayTimeout")]
    pub const ResponseCodeGatewayTimeout: Self = Self(0x54);
    #[doc(alias = "kOBEXResponseCodeGatewayTimeoutWithFinalBit")]
    pub const ResponseCodeGatewayTimeoutWithFinalBit: Self = Self(0xD4);
    #[doc(alias = "kOBEXResponseCodeHTTPVersionNotSupported")]
    pub const ResponseCodeHTTPVersionNotSupported: Self = Self(0x55);
    #[doc(alias = "kOBEXResponseCodeHTTPVersionNotSupportedWithFinalBit")]
    pub const ResponseCodeHTTPVersionNotSupportedWithFinalBit: Self = Self(0xD5);
    #[doc(alias = "kOBEXResponseCodeDatabaseFull")]
    pub const ResponseCodeDatabaseFull: Self = Self(0x60);
    #[doc(alias = "kOBEXResponseCodeDatabaseFullWithFinalBit")]
    pub const ResponseCodeDatabaseFullWithFinalBit: Self = Self(0xE0);
    #[doc(alias = "kOBEXResponseCodeDatabaseLocked")]
    pub const ResponseCodeDatabaseLocked: Self = Self(0x61);
    #[doc(alias = "kOBEXResponseCodeDatabaseLockedWithFinalBit")]
    pub const ResponseCodeDatabaseLockedWithFinalBit: Self = Self(0xE1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXOpCodeResponseValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXOpCodeResponseValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Operation OpCode values for commands.
/// Operation OpCode values for commands.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXOpCodeCommandValues(pub c_uint);
impl OBEXOpCodeCommandValues {
    #[doc(alias = "kOBEXOpCodeReserved")]
    pub const Reserved: Self = Self(0x04);
    #[doc(alias = "kOBEXOpCodeConnect")]
    pub const Connect: Self = Self(0x80);
    #[doc(alias = "kOBEXOpCodeDisconnect")]
    pub const Disconnect: Self = Self(0x81);
    #[doc(alias = "kOBEXOpCodePut")]
    pub const Put: Self = Self(0x02);
    #[doc(alias = "kOBEXOpCodePutWithHighBitSet")]
    pub const PutWithHighBitSet: Self = Self(0x82);
    #[doc(alias = "kOBEXOpCodeGet")]
    pub const Get: Self = Self(0x03);
    #[doc(alias = "kOBEXOpCodeGetWithHighBitSet")]
    pub const GetWithHighBitSet: Self = Self(0x83);
    #[doc(alias = "kOBEXOpCodeReservedWithHighBitSet")]
    pub const ReservedWithHighBitSet: Self = Self(0x84);
    #[doc(alias = "kOBEXOpCodeSetPath")]
    pub const SetPath: Self = Self(0x85);
    #[doc(alias = "kOBEXOpCodeAbort")]
    pub const Abort: Self = Self(0xFF);
    #[doc(alias = "kOBEXOpCodeReservedRangeStart")]
    pub const ReservedRangeStart: Self = Self(0x06);
    #[doc(alias = "kOBEXOpCodeReservedRangeEnd")]
    pub const ReservedRangeEnd: Self = Self(0x0F);
    #[doc(alias = "kOBEXOpCodeUserDefinedStart")]
    pub const UserDefinedStart: Self = Self(0x10);
    #[doc(alias = "kOBEXOpCodeUserDefinedEnd")]
    pub const UserDefinedEnd: Self = Self(0x1F);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXOpCodeCommandValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXOpCodeCommandValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags for Connect command.
/// Flags for Connect command.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OBEXConnectFlagValues(pub c_uint);
impl OBEXConnectFlagValues {
    #[doc(alias = "kOBEXConnectFlagNone")]
    pub const FlagNone: Self = Self(0 << 0);
    #[doc(alias = "kOBEXConnectFlagSupportMultipleItLMPConnections")]
    pub const FlagSupportMultipleItLMPConnections: Self = Self(1 << 0);
    #[doc(alias = "kOBEXConnectFlag1Reserved")]
    pub const Flag1Reserved: Self = Self(1 << 1);
    #[doc(alias = "kOBEXConnectFlag2Reserved")]
    pub const Flag2Reserved: Self = Self(1 << 2);
    #[doc(alias = "kOBEXConnectFlag3Reserved")]
    pub const Flag3Reserved: Self = Self(1 << 3);
    #[doc(alias = "kOBEXConnectFlag4Reserved")]
    pub const Flag4Reserved: Self = Self(1 << 4);
    #[doc(alias = "kOBEXConnectFlag5Reserved")]
    pub const Flag5Reserved: Self = Self(1 << 5);
    #[doc(alias = "kOBEXConnectFlag6Reserved")]
    pub const Flag6Reserved: Self = Self(1 << 6);
    #[doc(alias = "kOBEXConnectFlag7Reserved")]
    pub const Flag7Reserved: Self = Self(1 << 7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXConnectFlagValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXConnectFlagValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags for SetPath command. Not that these are called "PutFlags". That is a mistake, they are not used
/// with a Put command. We are not changing the names to maintain backwards compatibility.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OBEXPutFlagValues(pub c_uint);
impl OBEXPutFlagValues {
    #[doc(alias = "kOBEXPutFlagNone")]
    pub const FlagNone: Self = Self(0 << 0);
    #[doc(alias = "kOBEXPutFlagGoToParentDirFirst")]
    pub const FlagGoToParentDirFirst: Self = Self(1 << 0);
    #[doc(alias = "kOBEXPutFlagDontCreateDirectory")]
    pub const FlagDontCreateDirectory: Self = Self(1 << 1);
    #[doc(alias = "kOBEXPutFlag2Reserved")]
    pub const Flag2Reserved: Self = Self(1 << 2);
    #[doc(alias = "kOBEXPutFlag3Reserved")]
    pub const Flag3Reserved: Self = Self(1 << 3);
    #[doc(alias = "kOBEXPutFlag4Reserved")]
    pub const Flag4Reserved: Self = Self(1 << 4);
    #[doc(alias = "kOBEXPutFlag5Reserved")]
    pub const Flag5Reserved: Self = Self(1 << 5);
    #[doc(alias = "kOBEXPutFlag6Reserved")]
    pub const Flag6Reserved: Self = Self(1 << 6);
    #[doc(alias = "kOBEXPutFlag7Reserved")]
    pub const Flag7Reserved: Self = Self(1 << 7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXPutFlagValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXPutFlagValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags for Nonce command during digest challenge.
/// Flags for Nonce command during digest challenge.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OBEXNonceFlagValues(pub c_uint);
impl OBEXNonceFlagValues {
    #[doc(alias = "kOBEXNonceFlagNone")]
    pub const FlagNone: Self = Self(0 << 0);
    #[doc(alias = "kOBEXNonceFlagSendUserIDInResponse")]
    pub const FlagSendUserIDInResponse: Self = Self(1 << 0);
    #[doc(alias = "kOBEXNonceFlagAccessModeReadOnly")]
    pub const FlagAccessModeReadOnly: Self = Self(1 << 1);
    #[doc(alias = "kOBEXNonceFlag2Reserved")]
    pub const Flag2Reserved: Self = Self(1 << 2);
    #[doc(alias = "kOBEXNonceFlag3Reserved")]
    pub const Flag3Reserved: Self = Self(1 << 3);
    #[doc(alias = "kOBEXNonceFlag4Reserved")]
    pub const Flag4Reserved: Self = Self(1 << 4);
    #[doc(alias = "kOBEXNonceFlag5Reserved")]
    pub const Flag5Reserved: Self = Self(1 << 5);
    #[doc(alias = "kOBEXNonceFlag6Reserved")]
    pub const Flag6Reserved: Self = Self(1 << 6);
    #[doc(alias = "kOBEXNonceFlag7Reserved")]
    pub const Flag7Reserved: Self = Self(1 << 7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXNonceFlagValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXNonceFlagValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Values for Realm during digest response.
/// Values for Realm during digest response.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OBEXRealmValues(pub c_uint);
impl OBEXRealmValues {
    #[doc(alias = "kOBEXRealmASCII")]
    pub const ASCII: Self = Self(0x00);
    #[doc(alias = "kOBEXRealmISO88591")]
    pub const ISO88591: Self = Self(0x01);
    #[doc(alias = "kOBEXRealmISO88592")]
    pub const ISO88592: Self = Self(0x02);
    #[doc(alias = "kOBEXRealmISO88593")]
    pub const ISO88593: Self = Self(0x03);
    #[doc(alias = "kOBEXRealmISO88594")]
    pub const ISO88594: Self = Self(0x04);
    #[doc(alias = "kOBEXRealmISO88595")]
    pub const ISO88595: Self = Self(0x05);
    #[doc(alias = "kOBEXRealmISO88596")]
    pub const ISO88596: Self = Self(0x06);
    #[doc(alias = "kOBEXRealmISO88597")]
    pub const ISO88597: Self = Self(0x07);
    #[doc(alias = "kOBEXRealmISO88598")]
    pub const ISO88598: Self = Self(0x08);
    #[doc(alias = "kOBEXRealmISO88599")]
    pub const ISO88599: Self = Self(0x09);
    #[doc(alias = "kOBEXRealmUNICODE")]
    pub const UNICODE: Self = Self(0xFF);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXRealmValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXRealmValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Operation OpCode values for sessions. From the OBEX 1.3 specification.
/// Operation OpCode values for sessions. From the OBEX 1.3 specification.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OBEXOpCodeSessionValues(pub c_uint);
impl OBEXOpCodeSessionValues {
    #[doc(alias = "kOBEXOpCodeCreateSession")]
    pub const CreateSession: Self = Self(0x00);
    #[doc(alias = "kOBEXOpCodeCloseSession")]
    pub const CloseSession: Self = Self(0x01);
    #[doc(alias = "kOBEXOpCodeSuspendSession")]
    pub const SuspendSession: Self = Self(0x02);
    #[doc(alias = "kOBEXOpCodeResumeSession")]
    pub const ResumeSession: Self = Self(0x03);
    #[doc(alias = "kOBEXOpCodeSetTimeout")]
    pub const SetTimeout: Self = Self(0x04);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXOpCodeSessionValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXOpCodeSessionValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Tags for SessionParameters.
/// Tags for SessionParameters.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct OBEXSessionParameterTags(pub c_uint);
impl OBEXSessionParameterTags {
    #[doc(alias = "kOBEXSessionParameterTagDeviceAddress")]
    pub const DeviceAddress: Self = Self(0x00);
    #[doc(alias = "kOBEXSessionParameterTagNonce")]
    pub const Nonce: Self = Self(0x01);
    #[doc(alias = "kOBEXSessionParameterTagSessionID")]
    pub const SessionID: Self = Self(0x02);
    #[doc(alias = "kOBEXSessionParameterTagNextSequenceNumber")]
    pub const NextSequenceNumber: Self = Self(0x03);
    #[doc(alias = "kOBEXSessionParameterTagTimeout")]
    pub const Timeout: Self = Self(0x04);
    #[doc(alias = "kOBEXSessionParameterTagSessionOpcode")]
    pub const SessionOpcode: Self = Self(0x05);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSessionParameterTags {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSessionParameterTags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The available/supported OBEX versions.
/// The available/supported OBEX versions.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXVersions(pub c_uint);
impl OBEXVersions {
    #[doc(alias = "kOBEXVersion10")]
    pub const Version10: Self = Self(0x10);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXVersions {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXVersions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type OBEXHeaderIdentifier = u8;

pub type OBEXVersion = u8;

pub type OBEXFlags = u8;

pub type OBEXOpCode = u8;

pub type OBEXConstants = u8;

pub type OBEXMaxPacketLength = u16;

#[repr(C)]
#[derive(Debug)]
pub struct OpaqueOBEXSessionRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OpaqueOBEXSessionRef {
    const ENCODING_REF: Encoding =
        Encoding::Pointer(&Encoding::Struct("OpaqueOBEXSessionRef", &[]));
}

pub type OBEXSessionRef = *mut OpaqueOBEXSessionRef;

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeConnectCommandResponseReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXConnectCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub maxPacketSize: OBEXMaxPacketLength,
    pub version: OBEXVersion,
    pub flags: OBEXFlags,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXConnectCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXConnectCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <OBEXMaxPacketLength>::ENCODING,
            <OBEXVersion>::ENCODING,
            <OBEXFlags>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXConnectCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeDisconnectCommandResponseReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXDisconnectCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXDisconnectCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXDisconnectCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXDisconnectCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypePutCommandResponseReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXPutCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXPutCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXPutCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXPutCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeGetCommandResponseReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXGetCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXGetCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXGetCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXGetCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeSetPathCommandResponseReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXSetPathCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub flags: OBEXFlags,
    pub constants: OBEXConstants,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSetPathCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXSetPathCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <OBEXFlags>::ENCODING,
            <OBEXConstants>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSetPathCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeAbortCommandResponseReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXAbortCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXAbortCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXAbortCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXAbortCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeConnectCommandReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXConnectCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub maxPacketSize: OBEXMaxPacketLength,
    pub version: OBEXVersion,
    pub flags: OBEXFlags,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXConnectCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXConnectCommandData",
        &[
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <OBEXMaxPacketLength>::ENCODING,
            <OBEXVersion>::ENCODING,
            <OBEXFlags>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXConnectCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeDisconnectCommandReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXDisconnectCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXDisconnectCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXDisconnectCommandData",
        &[<*mut c_void>::ENCODING, <usize>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXDisconnectCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypePutCommandReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXPutCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub bodyDataLeftToSend: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXPutCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXPutCommandData",
        &[
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXPutCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeGetCommandReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXGetCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXGetCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXGetCommandData",
        &[<*mut c_void>::ENCODING, <usize>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXGetCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeSetPathCommandReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXSetPathCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub flags: OBEXFlags,
    pub constants: OBEXConstants,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSetPathCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXSetPathCommandData",
        &[
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <OBEXFlags>::ENCODING,
            <OBEXConstants>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSetPathCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeAbortCommandReceived (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXAbortCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXAbortCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXAbortCommandData",
        &[<*mut c_void>::ENCODING, <usize>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXAbortCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Part of the OBEXSessionEvent structure.
///
/// ## Overview
///
/// Is readable when the event is of type kOBEXSessionEventTypeError (see OBEXSessionEventTypes).
///
///
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXErrorData {
    pub error: OBEXError,
    pub dataPtr: *mut c_void,
    pub dataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXErrorData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXErrorData",
        &[
            <OBEXError>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXErrorData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Type identifiers for OBEX sessions.
///
/// ## Overview
///
/// When a new session event occurs, your selector (or C callback) will be given an OBEXSessionEvent pointer, and in it will be a ‘type’ field with one of the following types in it. Based on that type, you can then read the corresponding field in the union to get out interesting data for that event type. For example, if the type of an event is a ‘kOBEXSessionEventTypeConnectCommandResponseReceived’, you should look in the ‘OBEXConnectCommandResponseData’ part of the structure’s union to find more information pased to you in the event. Note that some you will never see, depending on the type of session you are using - a client or server. If you are a client (most likely case), you will never see the “Command” events, but instead you will only receive the “CommandResponse” events since you will be the issuer oft he commands, not the receiver of them. Both types of sessions will receive error type events.
///
///
/// When a new session event occurs, your selector (or C callback) will be given an OBEXSessionEvent pointer,
/// and in it will be a 'type' field with one of the following types in it. Based on that type, you can then
/// read the corresponding field in the union to get out interesting data for that event type. For example,
/// if the type of an event is a 'kOBEXSessionEventTypeConnectCommandResponseReceived', you should look in
/// the 'OBEXConnectCommandResponseData' part of the structure's union to find more information pased to you
/// in the event. Note that some you will never see, depending on the type of session you are using - a client
/// or server. If you are a client (most likely case), you will never see the "Command" events, but instead
/// you will only receive the "CommandResponse" events since you will be the issuer oft he commands, not the
/// receiver of them. Both types of sessions will receive error type events.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXSessionEventTypes(pub c_uint);
impl OBEXSessionEventTypes {
    #[doc(alias = "kOBEXSessionEventTypeConnectCommandResponseReceived")]
    pub const ConnectCommandResponseReceived: Self = Self(0x4f434543);
    #[doc(alias = "kOBEXSessionEventTypeDisconnectCommandResponseReceived")]
    pub const DisconnectCommandResponseReceived: Self = Self(0x4f434544);
    #[doc(alias = "kOBEXSessionEventTypePutCommandResponseReceived")]
    pub const PutCommandResponseReceived: Self = Self(0x4f434550);
    #[doc(alias = "kOBEXSessionEventTypeGetCommandResponseReceived")]
    pub const GetCommandResponseReceived: Self = Self(0x4f434547);
    #[doc(alias = "kOBEXSessionEventTypeSetPathCommandResponseReceived")]
    pub const SetPathCommandResponseReceived: Self = Self(0x4f434553);
    #[doc(alias = "kOBEXSessionEventTypeAbortCommandResponseReceived")]
    pub const AbortCommandResponseReceived: Self = Self(0x4f434541);
    #[doc(alias = "kOBEXSessionEventTypeConnectCommandReceived")]
    pub const ConnectCommandReceived: Self = Self(0x4f534543);
    #[doc(alias = "kOBEXSessionEventTypeDisconnectCommandReceived")]
    pub const DisconnectCommandReceived: Self = Self(0x4f534544);
    #[doc(alias = "kOBEXSessionEventTypePutCommandReceived")]
    pub const PutCommandReceived: Self = Self(0x4f534550);
    #[doc(alias = "kOBEXSessionEventTypeGetCommandReceived")]
    pub const GetCommandReceived: Self = Self(0x4f534547);
    #[doc(alias = "kOBEXSessionEventTypeSetPathCommandReceived")]
    pub const SetPathCommandReceived: Self = Self(0x4f534553);
    #[doc(alias = "kOBEXSessionEventTypeAbortCommandReceived")]
    pub const AbortCommandReceived: Self = Self(0x4f534541);
    #[doc(alias = "kOBEXSessionEventTypeError")]
    pub const Error: Self = Self(0x4f474545);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSessionEventTypes {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSessionEventTypes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type OBEXSessionEventType = u32;

#[repr(C)]
#[derive(Clone, Copy)]
pub union OBEXSessionEvent_u {
    pub connectCommandResponseData: OBEXConnectCommandResponseData,
    pub disconnectCommandResponseData: OBEXDisconnectCommandResponseData,
    pub putCommandResponseData: OBEXPutCommandResponseData,
    pub getCommandResponseData: OBEXGetCommandResponseData,
    pub setPathCommandResponseData: OBEXSetPathCommandResponseData,
    pub abortCommandResponseData: OBEXAbortCommandResponseData,
    pub connectCommandData: OBEXConnectCommandData,
    pub disconnectCommandData: OBEXDisconnectCommandData,
    pub putCommandData: OBEXPutCommandData,
    pub getCommandData: OBEXGetCommandData,
    pub setPathCommandData: OBEXSetPathCommandData,
    pub abortCommandData: OBEXAbortCommandData,
    pub errorData: OBEXErrorData,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSessionEvent_u {
    const ENCODING: Encoding = Encoding::Union(
        "?",
        &[
            <OBEXConnectCommandResponseData>::ENCODING,
            <OBEXDisconnectCommandResponseData>::ENCODING,
            <OBEXPutCommandResponseData>::ENCODING,
            <OBEXGetCommandResponseData>::ENCODING,
            <OBEXSetPathCommandResponseData>::ENCODING,
            <OBEXAbortCommandResponseData>::ENCODING,
            <OBEXConnectCommandData>::ENCODING,
            <OBEXDisconnectCommandData>::ENCODING,
            <OBEXPutCommandData>::ENCODING,
            <OBEXGetCommandData>::ENCODING,
            <OBEXSetPathCommandData>::ENCODING,
            <OBEXAbortCommandData>::ENCODING,
            <OBEXErrorData>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSessionEvent_u {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// When a new session event occurs, your selector (or C callback) will be given an OBEXSessionEvent pointer, and in it will be information you might find interesting so that you can then reply back appropriately. For example, of you receive a kOBEXSessionEventTypeConnectCommandResponseReceived event, you can then parse out the information related to that event, and if all looks well to you, you could them send a “Get” command to get a file off of the OBEX server you just connected to.
///
///
#[repr(C)]
#[derive(Clone, Copy)]
pub struct OBEXSessionEvent {
    pub r#type: OBEXSessionEventType,
    pub session: OBEXSessionRef,
    pub refCon: *mut c_void,
    pub isEndOfEventData: Boolean,
    pub reserved1: *mut c_void,
    pub reserved2: *mut c_void,
    pub u: OBEXSessionEvent_u,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSessionEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXSessionEvent",
        &[
            <OBEXSessionEventType>::ENCODING,
            <OBEXSessionRef>::ENCODING,
            <*mut c_void>::ENCODING,
            <Boolean>::ENCODING,
            <*mut c_void>::ENCODING,
            <*mut c_void>::ENCODING,
            <OBEXSessionEvent_u>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSessionEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

pub type OBEXSessionEventCallback = Option<unsafe extern "C-unwind" fn(*const OBEXSessionEvent)>;

extern "C-unwind" {
    /// Destroy an OBEX session. If connections are open, they will (eventually) be terminated for you.
    ///
    /// Parameters:
    /// - inSessionRef: A valid service reference.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Destroy an OBEX session. If connections are open, they will (eventually) be terminated for you.
    ///
    /// Parameter `inSessionRef`: A valid service reference.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// `in_session_ref` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionDelete(in_session_ref: OBEXSessionRef) -> OBEXError;
}

extern "C-unwind" {
    /// Allows you to test the session for an open OBEX connection for a particular session.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - outIsConnected: A valid ptr to an OBEXSessionRef; will contain the newly created session if return value is kOBEXSuccess.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method will return true only if (a) you are transport-connected to another OBEX target and (b) an OBEX Connect command has been issued and received successfully.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Allows you to test the session for an open OBEX connection for a particular session.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `outIsConnected`: A valid ptr to an OBEXSessionRef; will contain the newly created session if return
    /// value is kOBEXSuccess.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// This method will return true only if (a) you are transport-connected to another OBEX target and
    /// (b) an OBEX Connect command has been issued and received successfully.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `out_is_connected` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionHasOpenOBEXConnection(
        in_session_ref: OBEXSessionRef,
        out_is_connected: *mut Boolean,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Gets current max packet length.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - outLength: Max packet length.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This value _could_ change before and after a connect command has been sent or a connect command response has been received, since the recipient could negotiate a lower max packet size.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Gets current max packet length.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `outLength`: Max packet length.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// This value *could* change before and after a connect command has been sent or a connect
    /// command response has been received, since the recipient could negotiate a lower max packet size.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `out_length` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionGetMaxPacketLength(
        in_session_ref: OBEXSessionRef,
        out_length: *mut OBEXMaxPacketLength,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Gets space available for your data for a particular command response you are trying to send.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inOpCode: A command opcode that you are responding to. For example, if you receiving a Put command, and want to send back a “bad request” response, you should still pass in the Put command opcode for that response.
    ///
    /// - outLength: Space available for your header data in the payload area for a particular command.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Overview
    ///
    /// The OBEXSession takes care of packaging OBEX opcodes and other information into the proper packet format, allowing you to focus on sending the proper OBEX headers in your commands and command responses. This formatting and datas requires a small bit of information that varies depending on what command or response you are sending. Thus, you should call this function to find out how much space will be left for your headers before you send the command, allowing you to properly chop up your headers before sending them. This will guarantee that (a) you use up all the available space in a packet and (b) that you do not get an error trying to send too much information at once.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Gets space available for your data for a particular command you are trying to send.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inOpCode`: An opcode of what command you are trying to send.
    ///
    /// Parameter `outLength`: Space available for your header data in the payload area for a particular command.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// The OBEXSession takes care of packaging OBEX opcodes and other information into the proper packet format,
    /// allowing you to focus on sending the proper OBEX headers in your commands and command responses. This formatting
    /// and datas requires a small bit of information that varies depending on what command or response you are
    /// sending. Thus, you should call this function to find out how much space will be left for your headers
    /// before you send the command, allowing you to properly chop up your headers before sending them. This will
    /// guarantee that (a) you use up all the available space in a packet and (b) that you do not get an error
    /// trying to send too much information at once.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `out_length` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionGetAvailableCommandPayloadLength(
        in_session_ref: OBEXSessionRef,
        in_op_code: OBEXOpCode,
        out_length: *mut OBEXMaxPacketLength,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Gets space available for your data for a particular command response you are trying to send.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inOpCode: A command opcode that you are responding to. For example, if you receiving a Put command, and want to send back a “bad request” response, you should still pass in the Put command opcode for that response.
    ///
    /// - outLength: Space available for your header data in the payload area for a particular command.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The OBEXSession takes care of packaging OBEX opcodes and other information into the proper packet format, allowing you to focus on sending the proper OBEX headers in your commands and command responses. This formatting and datas requires a small bit of information that varies depending on what command or response you are sending. Thus, you should call this function to find out how much space will be left for your headers before you send the command, allowing you to properly chop up your headers before sending them. This will guarantee that (a) you use up all the available space in a packet and (b) that you do not get an error trying to send too much information at once.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Gets space available for your data for a particular command response you are trying to send.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inOpCode`: A command opcode that you are responding to. For example, if you receiving a Put command,
    /// and want to send back a "bad request" response, you should still pass in the Put command
    /// opcode for that response.
    ///
    /// Parameter `outLength`: Space available for your header data in the payload area for a particular command.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// The OBEXSession takes care of packaging OBEX opcodes and other information into the proper packet format,
    /// allowing you to focus on sending the proper OBEX headers in your commands and command responses. This formatting
    /// and datas requires a small bit of information that varies depending on what command or response you are
    /// sending. Thus, you should call this function to find out how much space will be left for your headers
    /// before you send the command, allowing you to properly chop up your headers before sending them. This will
    /// guarantee that (a) you use up all the available space in a packet and (b) that you do not get an error
    /// trying to send too much information at once.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `out_length` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionGetAvailableCommandResponsePayloadLength(
        in_session_ref: OBEXSessionRef,
        in_op_code: OBEXOpCode,
        out_length: *mut OBEXMaxPacketLength,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Establishes an OBEX connection to the target device for the session. If a transport connection is not open yet, it will be opened if possible.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inFlags: Flags, as defined in the OBEX spec for this command.
    ///
    /// - inMaxPacketLength: Maximum packet length you wish to allow. May be negiotiated with host to be less or more than you specify.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback parameter will result in an error. If you have already established an OBEX connection and you call this again you will get an ‘kOBEXSessionAlreadyConnectedError’ as a result.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Establishes an OBEX connection to the target device for the session. If a transport connection is not
    /// open yet, it will be opened if possible.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inFlags`: Flags, as defined in the OBEX spec for this command.
    ///
    /// Parameter `inMaxPacketLength`: Maximum packet length you wish to allow. May be negiotiated with host to be less
    /// or more than you specify.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback parameter will
    /// result in an error. If you have already established an OBEX connection and you call this again you will
    /// get an 'kOBEXSessionAlreadyConnectedError' as a result.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionConnect(
        in_session_ref: OBEXSessionRef,
        in_flags: OBEXFlags,
        in_max_packet_length: OBEXMaxPacketLength,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a disconnect command to a remote OBEX server.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Send a disconnect command to a remote OBEX server.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionDisconnect(
        in_session_ref: OBEXSessionRef,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

/// Send a put command to a remote OBEX server.
///
/// Parameters:
/// - inSessionRef: A valid session reference.
///
/// - inIsFinalChunk: TRUE or FALSE - is this the last chunk of header data for this PUT.
///
/// - inHeadersData: Headers containing data to PUT. Don’t include your body header data here.
///
/// - inHeadersDataLength: Size of header data. Don’t include your body header data here.
///
/// - inBodyData: Data for the BODY header to PUT. DO NOT package your data in an actual BODY header, this will be done for you, based on the finalChunk flag you pass in above (since based on this flag the header ID will be either a BODY or ENDOFBODY header).
///
/// - inBodyDataLength: Size of Data for the BODY header to PUT.
///
/// - inCallback: A valid callback. Will be called for progress, errors and completion.
///
/// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
///
///
/// ## Return Value
///
/// An error code value. 0 if successful.
///
///
///
/// ## Discussion
///
/// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
///
/// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
///
///
/// Send a put command to a remote OBEX server.
///
/// Parameter `inSessionRef`: A valid session reference.
///
/// Parameter `inIsFinalChunk`: TRUE or FALSE - is this the last chunk of header data for this PUT.
///
/// Parameter `inHeadersData`: Headers containing data to PUT. Don't include your body header data here.
///
/// Parameter `inHeadersDataLength`: Size of header data. Don't include your body header data here.
///
/// Parameter `inBodyData`: Data for the BODY header to PUT. DO NOT package your data in an actual BODY header,
/// this will be done for you, based on the finalChunk flag you pass in above (since based on
/// this flag the header ID will be either a BODY or ENDOFBODY header).
///
/// Parameter `inBodyDataLength`: Size of Data for the BODY header to PUT.
///
/// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
///
/// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your callback
/// just as you passed it.
///
/// Returns: An error code value. 0 if successful.
///
/// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
/// result in an error.
///
/// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
/// **        You should transition your code to Objective-C equivalents.
/// **        This API may be removed any time in the future.
///
/// # Safety
///
/// - `in_session_ref` must be a valid pointer.
/// - `in_headers_data` must be a valid pointer.
/// - `in_body_data` must be a valid pointer.
/// - `in_callback` must be implemented correctly.
/// - `in_user_ref_con` must be a valid pointer.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn OBEXSessionPut(
    in_session_ref: OBEXSessionRef,
    in_is_final_chunk: bool,
    in_headers_data: *mut c_void,
    in_headers_data_length: usize,
    in_body_data: *mut c_void,
    in_body_data_length: usize,
    in_callback: OBEXSessionEventCallback,
    in_user_ref_con: *mut c_void,
) -> OBEXError {
    extern "C-unwind" {
        fn OBEXSessionPut(
            in_session_ref: OBEXSessionRef,
            in_is_final_chunk: Boolean,
            in_headers_data: *mut c_void,
            in_headers_data_length: usize,
            in_body_data: *mut c_void,
            in_body_data_length: usize,
            in_callback: OBEXSessionEventCallback,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;
    }
    unsafe {
        OBEXSessionPut(
            in_session_ref,
            in_is_final_chunk as _,
            in_headers_data,
            in_headers_data_length,
            in_body_data,
            in_body_data_length,
            in_callback,
            in_user_ref_con,
        )
    }
}

/// Send a get command to a remote OBEX server.
///
/// Parameters:
/// - inSessionRef: A valid session reference.
///
/// - inIsFinalChunk: TRUE or FALSE - is this the last chunk of header data for this GET.
///
/// - inHeadersData: Headers containing data to GET.
///
/// - inHeadersDataLength: Size of header data.
///
/// - inCallback: A valid callback. Will be called for progress, errors and completion.
///
/// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
///
///
/// ## Return Value
///
/// An error code value. 0 if successful.
///
///
///
/// ## Discussion
///
/// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
///
/// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
///
///
/// Send a get command to a remote OBEX server.
///
/// Parameter `inSessionRef`: A valid session reference.
///
/// Parameter `inIsFinalChunk`: TRUE or FALSE - is this the last chunk of header data for this GET.
///
/// Parameter `inHeadersData`: Headers containing data to GET.
///
/// Parameter `inHeadersDataLength`: Size of header data.
///
/// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
///
/// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your callback
/// just as you passed it.
///
/// Returns: An error code value. 0 if successful.
///
/// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
/// result in an error.
///
/// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
/// **        You should transition your code to Objective-C equivalents.
/// **        This API may be removed any time in the future.
///
/// # Safety
///
/// - `in_session_ref` must be a valid pointer.
/// - `in_headers_data` must be a valid pointer.
/// - `in_callback` must be implemented correctly.
/// - `in_user_ref_con` must be a valid pointer.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn OBEXSessionGet(
    in_session_ref: OBEXSessionRef,
    in_is_final_chunk: bool,
    in_headers_data: *mut c_void,
    in_headers_data_length: usize,
    in_callback: OBEXSessionEventCallback,
    in_user_ref_con: *mut c_void,
) -> OBEXError {
    extern "C-unwind" {
        fn OBEXSessionGet(
            in_session_ref: OBEXSessionRef,
            in_is_final_chunk: Boolean,
            in_headers_data: *mut c_void,
            in_headers_data_length: usize,
            in_callback: OBEXSessionEventCallback,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;
    }
    unsafe {
        OBEXSessionGet(
            in_session_ref,
            in_is_final_chunk as _,
            in_headers_data,
            in_headers_data_length,
            in_callback,
            in_user_ref_con,
        )
    }
}

extern "C-unwind" {
    /// Send an abort command to a remote OBEX server.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Send an abort command to a remote OBEX server.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionAbort(
        in_session_ref: OBEXSessionRef,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a set path command to a remote OBEX server.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inFlags: Flags, as defined in the OBEX spec for this command.
    ///
    /// - inConstants: Constants, as defined in the OBEX spec for this command.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Send a set path command to a remote OBEX server.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inFlags`: Flags, as defined in the OBEX spec for this command.
    ///
    /// Parameter `inConstants`: Constants, as defined in the OBEX spec for this command.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionSetPath(
        in_session_ref: OBEXSessionRef,
        in_flags: OBEXFlags,
        in_constants: OBEXConstants,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a connect command to the remote client.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inResponseOpCode: What response code you want to send to the remote client.
    ///
    /// - inFlags: Flags, as defined in the OBEX spec for this command.
    ///
    /// - inMaxPacketLength: Max packet length you want to support. Must be smaller or equal to the max packet length specified by the remote client.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Send a response to a connect command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inFlags`: Flags, as defined in the OBEX spec for this command.
    ///
    /// Parameter `inMaxPacketLength`: Max packet length you want to support. Must be smaller or equal to the max packet
    /// length specified by the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionConnectResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_flags: OBEXFlags,
        in_max_packet_length: OBEXMaxPacketLength,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a disconnect command to the remote client.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inResponseOpCode: What response code you want to send to the remote client.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Send a response to a disconnect command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionDisconnectResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a get command to the remote client.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inResponseOpCode: What response code you want to send to the remote client.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Send a response to a get command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionGetResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a put command to the remote client.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inResponseOpCode: What response code you want to send to the remote client.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Send a response to a put command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionPutResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a abort command to the remote client.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inResponseOpCode: What response code you want to send to the remote client.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Send a response to a abort command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionAbortResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a set path command to the remote client.
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inResponseOpCode: What response code you want to send to the remote client.
    ///
    /// - inOptionalHeaders: Ptr to optional headers you can supply to the command. DO NOT dispose of this pointer until you callback is called with a success.
    ///
    /// - inOptionalHeadersLength: Size of data at the specified ptr.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will result in an error.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Send a response to a set path command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionSetPathResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    ///
    /// Parameters:
    /// - inSessionRef: A valid session reference.
    ///
    /// - inCallback: A valid callback. Will be called for progress, errors and completion by server sessions only.
    ///
    /// - inUserRefCon: Optional parameter; can contain anything you wish. Will be returned in your callback just as you passed it.
    ///
    ///
    /// ## Return Value
    ///
    /// An error code value. 0 if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Sets callback to be used when an event occurs on an OBEXSession. This is important for OBEX servers, as you will need a way to be called back when the first command is sent to you. So, be sure to set yourself up to listen for events when you are ready to receive them.
    ///
    /// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
    ///
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion by server
    /// sessions only.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// Sets callback to be used when an event occurs on an OBEXSession. This is important for OBEX servers, as you
    /// will need a way to be called back when the first command is sent to you. So, be sure to set yourself
    /// up to listen for events when you are ready to receive them.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionSetServerCallback(
        in_session_ref: OBEXSessionRef,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

/// Creates a formatted vCard, ready to be sent over OBEX or whatever.
///
/// Parameters:
/// - inFirstName: Pointer to data with Person’s first name.
///
/// - inFirstNameLength: Length of Person’s first name passed in above.
///
/// - inLastName: Pointer to data with Person’s last name.
///
/// - inLastNameLength: Length of Person’s last name passed in above.
///
/// - inFriendlyName: Pointer to data with Person’s Friendly name.
///
/// - inFriendlyNameLength: Length of Person’s Friendly name passed in above.
///
/// - inNameCharset: A pointer to the charset data used for the name. Pass in a #defined charset for ease of use.
///
/// - inNameCharsetLength: Length of name charset assed in above.
///
/// - inHomePhone: Pointer to data with Person’s Home phone number.
///
/// - inHomePhoneLength: Length of Person’s Home phone number passed in above.
///
/// - inWorkPhone: Work phone number.
///
/// - inWorkPhoneLength: Length of Person’s Work phone number passed in above.
///
/// - inCellPhone: Cell phone number.
///
/// - inCellPhoneLength: Length of Person’s Cell phone number passed in above.
///
/// - inFaxPhone: Fax phone number.
///
/// - inFaxPhoneLength: Length of Person’s Fax phone number passed in above.
///
/// - inEMailAddress: EMailAddress of person.
///
/// - inEMailAddressLength: Length of Person’s EMailAddress passed in above.
///
/// - inEMailAddressCharset: Charset of EMailAddress of person.
///
/// - inEMailAddressCharsetLength: Length of Person’s EMailAddress charset passed in above.
///
/// - inOrganization: Pointer to Organization/business data.
///
/// - inOrganizationLength: Length of Organization/business data.
///
/// - inOrganizationCharset: Pointer to the charset the Organization/business is in.
///
/// Pointer to the charset the Title is in.
///
/// - inOrganizationCharsetLength: Length of data for the Organization/business charset.
///
/// Length of data for the Title charset.
///
/// - inTitle: Pointer to data with Title of person in biz/org.
///
/// - inTitleLength: Length of Title of person in biz/org.
///
///
/// ## Return Value
///
/// An CFDataRef containing the compiled data. nil if we failed.
///
///
///
/// ## Discussion
///
/// All parameters are optional. The CFDataRef returned to you is NOT retained. Retain it if you want to keep it.
///
/// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
///
///
/// Creates a formatted vCard, ready to be sent over OBEX or whatever.
///
/// Parameter `inNameCharset`: A pointer to the charset data used for the name. Pass in a #defined charset
/// for ease of use.
///
/// Parameter `inNameCharsetLength`: Length of name charset assed in above.
///
/// Parameter `inFirstName`: Pointer to data with Person's first name.
///
/// Parameter `inFirstNameLength`: Length of Person's first name passed in above.
///
/// Parameter `inLastName`: Pointer to data with Person's last name.
///
/// Parameter `inLastNameLength`: Length of Person's last name passed in above.
///
/// Parameter `inFriendlyName`: Pointer to data with Person's Friendly name.
///
/// Parameter `inFriendlyNameLength`: Length of Person's Friendly name passed in above.
///
/// Parameter `inHomePhone`: Pointer to data with Person's Home phone number.
///
/// Parameter `inHomePhoneLength`: Length of Person's Home phone number passed in above.
///
/// Parameter `inWorkPhone`: Work phone number.
///
/// Parameter `inWorkPhoneLength`: Length of Person's Work phone number passed in above.
///
/// Parameter `inCellPhone`: Cell phone number.
///
/// Parameter `inCellPhoneLength`: Length of Person's Cell phone number passed in above.
///
/// Parameter `inFaxPhone`: Fax phone number.
///
/// Parameter `inFaxPhoneLength`: Length of Person's Fax phone number passed in above.
///
/// Parameter `inEMailAddress`: EMailAddress of person.
///
/// Parameter `inEMailAddressLength`: Length of Person's EMailAddress passed in above.
///
/// Parameter `inEMailAddressCharset`: Charset of EMailAddress of person.
///
/// Parameter `inEMailAddressCharsetLength`: Length of Person's EMailAddress charset passed in above.
///
/// Parameter `inOrganization`: Pointer to Organization/business data.
///
/// Parameter `inOrganizationLength`: Length of Organization/business data.
///
/// Parameter `inOrganizationCharset`: Pointer to the charset the Organization/business is in.
///
/// Parameter `inOrganizationCharsetLength`: Length of data for the Organization/business charset.
///
/// Parameter `inTitle`: Pointer to data with Title of person in biz/org.
///
/// Parameter `inTitleLength`: Length of Title of person in biz/org.
///
/// Parameter `inTitleCharset`: Pointer to the charset the Title is in.
///
/// Parameter `inTitleCharsetLength`: Length of data for the Title charset.
///
/// Returns: An CFDataRef containing the compiled data. nil if we failed.
///
/// All parameters are optional. The CFDataRef returned to you is NOT retained. Retain it if you want to keep it.
///
/// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
/// **        You should transition your code to Objective-C equivalents.
/// **        This API may be removed any time in the future.
///
/// # Safety
///
/// - `in_first_name` must be a valid pointer.
/// - `in_last_name` must be a valid pointer.
/// - `in_friendly_name` must be a valid pointer.
/// - `in_name_charset` must be a valid pointer.
/// - `in_home_phone` must be a valid pointer.
/// - `in_work_phone` must be a valid pointer.
/// - `in_cell_phone` must be a valid pointer.
/// - `in_fax_phone` must be a valid pointer.
/// - `in_e_mail_address` must be a valid pointer.
/// - `in_e_mail_address_charset` must be a valid pointer.
/// - `in_organization` must be a valid pointer.
/// - `in_organization_charset` must be a valid pointer.
/// - `in_title` must be a valid pointer.
/// - `in_title_charset` must be a valid pointer.
#[cfg(feature = "objc2-core-foundation")]
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn OBEXCreateVCard(
    in_first_name: *const c_void,
    in_first_name_length: u32,
    in_last_name: *const c_void,
    in_last_name_length: u32,
    in_friendly_name: *const c_void,
    in_friendly_name_length: u32,
    in_name_charset: *const c_void,
    in_name_charset_length: u32,
    in_home_phone: *const c_void,
    in_home_phone_length: u32,
    in_work_phone: *const c_void,
    in_work_phone_length: u32,
    in_cell_phone: *const c_void,
    in_cell_phone_length: u32,
    in_fax_phone: *const c_void,
    in_fax_phone_length: u32,
    in_e_mail_address: *const c_void,
    in_e_mail_address_length: u32,
    in_e_mail_address_charset: *const c_void,
    in_e_mail_address_charset_length: u32,
    in_organization: *const c_void,
    in_organization_length: u32,
    in_organization_charset: *const c_void,
    in_organization_charset_length: u32,
    in_title: *const c_void,
    in_title_length: u32,
    in_title_charset: *const c_void,
    in_title_charset_length: u32,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn OBEXCreateVCard(
            in_first_name: *const c_void,
            in_first_name_length: u32,
            in_last_name: *const c_void,
            in_last_name_length: u32,
            in_friendly_name: *const c_void,
            in_friendly_name_length: u32,
            in_name_charset: *const c_void,
            in_name_charset_length: u32,
            in_home_phone: *const c_void,
            in_home_phone_length: u32,
            in_work_phone: *const c_void,
            in_work_phone_length: u32,
            in_cell_phone: *const c_void,
            in_cell_phone_length: u32,
            in_fax_phone: *const c_void,
            in_fax_phone_length: u32,
            in_e_mail_address: *const c_void,
            in_e_mail_address_length: u32,
            in_e_mail_address_charset: *const c_void,
            in_e_mail_address_charset_length: u32,
            in_organization: *const c_void,
            in_organization_length: u32,
            in_organization_charset: *const c_void,
            in_organization_charset_length: u32,
            in_title: *const c_void,
            in_title_length: u32,
            in_title_charset: *const c_void,
            in_title_charset_length: u32,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe {
        OBEXCreateVCard(
            in_first_name,
            in_first_name_length,
            in_last_name,
            in_last_name_length,
            in_friendly_name,
            in_friendly_name_length,
            in_name_charset,
            in_name_charset_length,
            in_home_phone,
            in_home_phone_length,
            in_work_phone,
            in_work_phone_length,
            in_cell_phone,
            in_cell_phone_length,
            in_fax_phone,
            in_fax_phone_length,
            in_e_mail_address,
            in_e_mail_address_length,
            in_e_mail_address_charset,
            in_e_mail_address_charset_length,
            in_organization,
            in_organization_length,
            in_organization_charset,
            in_organization_charset_length,
            in_title,
            in_title_length,
            in_title_charset,
            in_title_charset_length,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Creates a formatted vEvent, ready to be sent over OBEX or whatever. You probably will embed the output in a vCalendar event.
///
/// Parameters:
/// - inCharset: The Charset the passed data is in. Pass in a #defined charset for ease of use.
///
/// - inCharsetLength: The length of the Charset passed data.
///
/// - inEncoding: The encoding of the summary and location fields.
///
/// - inEventStartDate: Start of event date, in the (ISO8601) format: YYYYMMDDTHHMMSS. e.g. 19960415T083000 = 8:30 am on April 15, 1996. All time values should be in LOCAL time.
///
/// - inEventEndDate: End of event date.
///
/// - inAlarmDate: Date of Alarm for event, in the format: YYYYMMDDTHHMMSS.
///
/// - inCategory: Category of event, such as “MEETING” or “PHONE CALL”.
///
/// - inSummary: Summary of event. Max length is 36 bytes. Longer will result in a bad argument error.
///
/// - inLocation: Summary of event. Max length is 20 bytes. Longer will result in a bad argument error.
///
/// - inXIRMCLUID: The IRMC Local Unique Identifier Label, max length 12 bytes. Longer will result in a bad argument error.
///
///
/// ## Return Value
///
/// A valid CFDataRef - nil if we failed.
///
///
///
/// ## Discussion
///
/// All parameters are optional. The CFDataRef returned to you is NOT retained. Retain it if you want to keep it. Be aware that certain devices such as Ericsson phones MUST have certain fields, such as a start and end date.
///
/// *** DEPRECATED IN BLUETOOTH 2.2 (OS X v10.6) *** You should transition your code to Objective-C equivalents. *** This API may be removed any time in the future.
///
///
/// Creates a formatted vEvent, ready to be sent over OBEX or whatever. You probably will embed the output
/// in a vCalendar event.
///
/// Parameter `inCharset`: The Charset the passed data is in. Pass in a #defined charset for ease of use.
///
/// Parameter `inCharsetLength`: The length of the Charset passed data.
///
/// Parameter `inEncoding`: The encoding of the summary and location fields.
///
/// Parameter `inEncodingLength`: The length of the Charset passed data.
///
/// Parameter `inEventStartDate`: Start of event date, in the (ISO8601) format: YYYYMMDDTHHMMSS. e.g. 19960415T083000 = 8:30 am on April 15, 1996. All time values should be in LOCAL time.
///
/// Parameter `inEventStartDateLength`: The length of the Charset passed data.
///
/// Parameter `inEventEndDate`: End of event date.
///
/// Parameter `inEventEndDateLength`: The length of the Charset passed data.
///
/// Parameter `inAlarmDate`: Date of Alarm for event, in the format: YYYYMMDDTHHMMSS.
///
/// Parameter `inAlarmDateLength`: The length of the Charset passed data.
///
/// Parameter `inCategory`: Category of event, such as "MEETING" or "PHONE CALL".
///
/// Parameter `inCategoryLength`: The length of the Charset passed data.
///
/// Parameter `inSummary`: Summary of event. Max length is 36 bytes. Longer will result in a bad argument error.
///
/// Parameter `inSummaryLength`: The length of the Charset passed data.
///
/// Parameter `inLocation`: Summary of event. Max length is 20 bytes. Longer will result in a bad argument error.
///
/// Parameter `inLocationLength`: The length of the Charset passed data.
///
/// Parameter `inXIRMCLUID`: The IRMC Local Unique Identifier Label, max length 12 bytes. Longer will result in
/// a bad argument error.
///
/// Parameter `inXIRMCLUIDLength`: The length of the Charset passed data.
///
/// Returns: A valid CFDataRef -     nil if we failed.
///
/// All parameters are optional. The CFDataRef returned to you is NOT retained. Retain it if you want to keep it.
/// Be aware that certain devices such as Ericsson phones MUST have certain fields, such as a start and end date.
///
/// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
/// **        You should transition your code to Objective-C equivalents.
/// **        This API may be removed any time in the future.
///
/// # Safety
///
/// - `in_charset` must be a valid pointer.
/// - `in_encoding` must be a valid pointer.
/// - `in_event_start_date` must be a valid pointer.
/// - `in_event_end_date` must be a valid pointer.
/// - `in_alarm_date` must be a valid pointer.
/// - `in_category` must be a valid pointer.
/// - `in_summary` must be a valid pointer.
/// - `in_location` must be a valid pointer.
/// - `in_xirmcluid` must be a valid pointer.
#[cfg(feature = "objc2-core-foundation")]
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn OBEXCreateVEvent(
    in_charset: *const c_char,
    in_charset_length: u32,
    in_encoding: *const c_char,
    in_encoding_length: u32,
    in_event_start_date: *const c_char,
    in_event_start_date_length: u32,
    in_event_end_date: *const c_char,
    in_event_end_date_length: u32,
    in_alarm_date: *const c_char,
    in_alarm_date_length: u32,
    in_category: *const c_char,
    in_category_length: u32,
    in_summary: *const c_char,
    in_summary_length: u32,
    in_location: *const c_char,
    in_location_length: u32,
    in_xirmcluid: *const c_char,
    in_xirmcluid_length: u32,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn OBEXCreateVEvent(
            in_charset: *const c_char,
            in_charset_length: u32,
            in_encoding: *const c_char,
            in_encoding_length: u32,
            in_event_start_date: *const c_char,
            in_event_start_date_length: u32,
            in_event_end_date: *const c_char,
            in_event_end_date_length: u32,
            in_alarm_date: *const c_char,
            in_alarm_date_length: u32,
            in_category: *const c_char,
            in_category_length: u32,
            in_summary: *const c_char,
            in_summary_length: u32,
            in_location: *const c_char,
            in_location_length: u32,
            in_xirmcluid: *const c_char,
            in_xirmcluid_length: u32,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe {
        OBEXCreateVEvent(
            in_charset,
            in_charset_length,
            in_encoding,
            in_encoding_length,
            in_event_start_date,
            in_event_start_date_length,
            in_event_end_date,
            in_event_end_date_length,
            in_alarm_date,
            in_alarm_date_length,
            in_category,
            in_category_length,
            in_summary,
            in_summary_length,
            in_location,
            in_location_length,
            in_xirmcluid,
            in_xirmcluid_length,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyName: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyType: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyDescription: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyTimeISO: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyTime4Byte: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyTarget: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyHTTP: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyBody: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyEndOfBody: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyWho: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyAppParameters: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyAuthorizationChallenge: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyAuthorizationResponse: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyObjectClass: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyCount: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyLength: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyConnectionID: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyByteSequence: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUnknownUnicodeText: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUnknownByteSequence: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUnknown1ByteQuantity: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUnknown4ByteQuantity: Option<&'static CFString>;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUserDefined: Option<&'static CFString>;
}

/// Take a data blob and looks for OBEX headers.
///
/// Parameters:
/// - inData: The data chunk with the headers you are interested in.
///
/// - inDataSize: The size of the buffer you are passing in.
///
///
/// ## Return Value
///
/// A CFDictionary with the headers found in the data blob inside it.
///
///
///
/// ## Discussion
///
/// You should use this when your callback for PUTs, GETs, etc. give you a data chunk and a size. Pass these params to this function and you will receive a dictionary back full of the parse headers. You can use the CFDictionary calls to get objects out of it, based on the header keys defined above. You are responsible for releasing the CFDictionary returned to you. Example usage:
///
/// ```objc
///  
///    CFDictionaryRef   dictionary = OBEXGetHeaders( data, dataLength );
///    if( dictionary )
///    {
///    	if( CFDictionaryGetCountOfKey( dictionary, kOBEXHeaderIDKeyName ) > 0 )
///    	{
///    		CFStringRef theStringRef;
///  
///    		theStringRef = (CFStringRef) CFDictionaryGetValue( dictionary, kOBEXHeaderIDKeyName );
///    		if( theStringRef )
///    		{
///    			// Display it, use it as a filename, whatever.
///    		}
///    	}
///  
///    	if( CFDictionaryGetCountOfKey( dictionary, kOBEXHeaderIDKeyConnectionID ) > 0 )
///    	{
///    		CFDataRef theDataRef;
///  
///    		theDataRef = (CFDataRef) CFDictionaryGetValue( dictionary, kOBEXHeaderIDKeyConnectionID );
///    		if( theDataRef )
///    		{
///    			// now we have data representing the connection ID.
///    		}
///    	}
///  
///    	CFRelease( dictionary );
///    }
///  
/// ```
///
///
/// Take a data blob and looks for OBEX headers.
///
/// Parameter `inData`: The data chunk with the headers you are interested in.
///
/// Parameter `inDataSize`: The size of the buffer you are passing in.
///
/// Returns: A CFDictionary with the headers found in the data blob inside it.
///
/// You should use this when your callback for PUTs, GETs, etc. give you a data chunk
/// and a size. Pass these params to this function and you will receive a dictionary
/// back full of the parse headers. You can use the CFDictionary calls to get objects
/// out of it, based on the header keys defined above. You are responsible for releasing
/// the CFDictionary returned to you.
/// Example usage:
/// <pre>
/// CFDictionaryRef   dictionary = OBEXGetHeaders( data, dataLength );
/// if( dictionary )
/// {
/// if( CFDictionaryGetCountOfKey( dictionary, kOBEXHeaderIDKeyName ) > 0 )
/// {
/// CFStringRef theStringRef;
///
/// theStringRef = (CFStringRef) CFDictionaryGetValue( dictionary, kOBEXHeaderIDKeyName );
/// if( theStringRef )
/// {
/// // Display it, use it as a filename, whatever.
/// }
/// }
///
/// if( CFDictionaryGetCountOfKey( dictionary, kOBEXHeaderIDKeyConnectionID ) > 0 )
/// {
/// CFDataRef theDataRef;
///
/// theDataRef = (CFDataRef) CFDictionaryGetValue( dictionary, kOBEXHeaderIDKeyConnectionID );
/// if( theDataRef )
/// {
/// // now we have data representing the connection ID.
/// }
/// }
///
/// CFRelease( dictionary );
/// }
/// </pre>
///
/// # Safety
///
/// `in_data` must be a valid pointer.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn OBEXGetHeaders(
    in_data: *const c_void,
    in_data_size: usize,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn OBEXGetHeaders(
            in_data: *const c_void,
            in_data_size: usize,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { OBEXGetHeaders(in_data, in_data_size) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Converts a dictionary of headers to a data pointer, from which you can extract as bytes and pass to the OBEX command/response functions.
///
/// Parameters:
/// - dictionaryOfHeaders: Dictionary that you have added headers to with the above OBEXAddXXXHeader functions.
///
///
/// ## Return Value
///
/// Mutable data ref containing the bytes of all headers.
///
///
///
/// ## Discussion
///
/// Returns a CFMutableDataRef containing all the header data found in the dictionary, formatted according to the OBEX/IrMC spec. YOU MUST RELEASE IT when you are finished with it (ie. when the OBEX request is complete). All OBEX-specification defined headers are supported and should be returned to the dictionary. Use the keys defined above to get headers from dictionary. Example usage:
///
/// ```objc
///  
///    Example usage:
///  
///    CFMutableDictionaryRef	dictionary;
///    CFMutableDataRef		mGetHeadersDataRef;
///    uint8_t* 				headerDataPtr;
///    uint32_t 				headerDataLength;
///  
///    dictionary = CFDictionaryCreateMutable( kCFAllocatorDefault, 0, &kCFCopyStringDictionaryKeyCallBacks, &kCFTypeDictionaryValueCallBacks );
///  
///    // Package up desired headers.
///  
///    OBEXAddTypeHeader( CFSTR( "text/x-vCard" ), dictionary );
///  
///    mGetHeadersDataRef = OBEXHeadersToBytes( dictionary );
///  
///    headerDataPtr = CFDataGetBytePtr( mGetHeadersDataRef );
///    headerDataLength = CFDataGetLength( mGetHeadersDataRef );
///  
///    // From here I can pass it to any OBEX command, such as OBEXPut...
///  
/// ```
///
///
/// Converts a dictionary of headers to a data pointer, from which you can extract as bytes and pass to
/// the OBEX command/response functions.
///
/// Parameter `dictionaryOfHeaders`: dictionary that you have added headers to with the above OBEXAddXXXHeader functions.
///
/// Returns: Mutable data ref containing the bytes of all headers.
///
/// Returns a CFMutableDataRef containing all the header data found in the dictionary, formatted according to
/// the OBEX/IrMC spec. YOU MUST RELEASE IT when you are finished with it (ie. when the OBEX request is complete).
/// All OBEX-specification defined headers are supported and should be returned to the dictionary. Use the
/// keys defined above to get headers from dictionary. Example usage:
/// <pre>
/// Example usage:
///
/// CFMutableDictionaryRef    dictionary;
/// CFMutableDataRef        mGetHeadersDataRef;
/// uint8_t*                 headerDataPtr;
/// uint32_t                 headerDataLength;
///
/// dictionary = CFDictionaryCreateMutable( kCFAllocatorDefault, 0,
/// &kCFCopyStringDictionaryKeyCallBacks
/// ,
/// &kCFTypeDictionaryValueCallBacks
/// );
///
/// // Package up desired headers.
///
/// OBEXAddTypeHeader( CFSTR( "text/x-vCard" ), dictionary );
///
/// mGetHeadersDataRef = OBEXHeadersToBytes( dictionary );
///
/// headerDataPtr = CFDataGetBytePtr( mGetHeadersDataRef );
/// headerDataLength = CFDataGetLength( mGetHeadersDataRef );
///
/// // From here I can pass it to any OBEX command, such as OBEXPut...
/// </pre>
///
/// # Safety
///
/// - `dictionary_of_headers` generic must be of the correct type.
/// - `dictionary_of_headers` generic must be of the correct type.
/// - `dictionary_of_headers` might not allow `None`.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn OBEXHeadersToBytes(
    dictionary_of_headers: Option<&CFDictionary>,
) -> Option<CFRetained<CFMutableData>> {
    extern "C-unwind" {
        fn OBEXHeadersToBytes(
            dictionary_of_headers: Option<&CFDictionary>,
        ) -> Option<NonNull<CFMutableData>>;
    }
    let ret = unsafe { OBEXHeadersToBytes(dictionary_of_headers) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - name: Name you want to add to the OBEX header dictionary.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Name header - OBEX Spec, 2.2.2: (2-byte) Null terminated unicode string.
    ///
    ///
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `name`: name you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Name header - OBEX Spec, 2.2.2: (2-byte) Null terminated unicode string.
    ///
    /// # Safety
    ///
    /// - `name` might not allow `None`.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddNameHeader(
        name: Option<&CFString>,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - description: Description you want to add to the OBEX header dictionary.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Description header - OBEX Spec, 2.2.6: (2-byte) Null terminated unicode string.
    ///
    ///
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `description`: Description you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Description header - OBEX Spec, 2.2.6: (2-byte) Null terminated unicode string.
    ///
    /// # Safety
    ///
    /// - `description` might not allow `None`.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddDescriptionHeader(
        description: Option<&CFString>,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - count: Count value you want to add to the OBEX header dictionary.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Count header - OBEX Spec, 2.2.1: 4 byte unsigned integer
    ///
    ///
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `count`: Count value you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Count header - OBEX Spec, 2.2.1: 4 byte unsigned integer
    ///
    /// # Safety
    ///
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddCountHeader(count: u32, dict_ref: Option<&CFMutableDictionary>) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - time4Byte: 4-byte time value you want to add to the OBEX header dictionary.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Time4Byte headers - OBEX Spec, 2.2.5: 4 Bytes
    ///
    ///
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `time4Byte`: 4-byte time value you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Time4Byte headers - OBEX Spec, 2.2.5: 4 Bytes
    ///
    /// # Safety
    ///
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddTime4ByteHeader(
        time4_byte: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - length: Value of Length header you want to add to the OBEX header dictionary.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Length header - OBEX Spec, 2.2.4: 4 byte unsigned integer
    ///
    ///
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `length`: Value of Length header you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Length header - OBEX Spec, 2.2.4: 4 byte unsigned integer
    ///
    /// # Safety
    ///
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddLengthHeader(length: u32, dict_ref: Option<&CFMutableDictionary>) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - type: Description containing the name you want to add to the OBEX header dictionary.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Type header - OBEX Spec, 2.2.3: 1-byte Null terminated ascii string.
    ///
    ///
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `type`: String containing the type of header to add.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Type header - OBEX Spec, 2.2.3: 1-byte Null terminated ascii string.
    ///
    /// # Safety
    ///
    /// - `type` might not allow `None`.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddTypeHeader(
        r#type: Option<&CFString>,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - inHeaderData: Time ISO 8601 header data, local times in format YYYYMMDDTHHMMSS and UTC in the format YYYYMMDDTHHMMSSZ.
    ///
    /// - inHeaderDataLength: Length of header data.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// TimeISO header - OBEX Spec, 2.2.5: Byte Sequence
    ///
    ///
    /// Add bytes to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: Time ISO 8601 header data, local times in format YYYYMMDDTHHMMSS and UTC in the format YYYYMMDDTHHMMSSZ.
    ///
    /// Parameter `inHeaderDataLength`: Length of header data.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// TimeISO header - OBEX Spec, 2.2.5: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddTimeISOHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes of data to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - inHeaderData: Target header data.
    ///
    /// - inHeaderDataLength: Length of Target header data.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Target header - OBEX Spec, 2.2.7: Byte Sequence
    ///
    ///
    /// Add bytes of data to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: Target header data.
    ///
    /// Parameter `inHeaderDataLength`: Length of Target header data.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Target header - OBEX Spec, 2.2.7: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddTargetHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes of data to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - inHeaderData: HTTP header data.
    ///
    /// - inHeaderDataLength: Length of HTTP header data.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// HTTP header - OBEX Spec, 2.2.8: Byte Sequence
    ///
    ///
    /// Add bytes of data to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: HTTP header data.
    ///
    /// Parameter `inHeaderDataLength`: Length of HTTP header data.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// HTTP header - OBEX Spec, 2.2.8: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddHTTPHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

/// Add bytes of data to a dictionary of OBEXheaders.
///
/// Parameters:
/// - inHeaderData: Body header data.
///
/// - inHeaderDataLength: Length of Body header data.
///
/// - isEndOfBody: Set this flag if you want an end of body header instead of a body header.
///
/// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
///
///
/// ## Return Value
///
/// Error code, kOBEXSuccess (0) if success.
///
///
///
/// ## Discussion
///
/// Body,EndOfBody headers - OBEX Spec, 2.2.9: Byte Sequence
///
///
/// Add bytes of data to a dictionary of OBEXheaders.
///
/// Parameter `inHeaderData`: Body header data.
///
/// Parameter `inHeaderDataLength`: Length of Body header data.
///
/// Parameter `isEndOfBody`: Set this flag if you want an end of body header instead of a body header.
///
/// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
///
/// Returns: Error code, kOBEXSuccess (0) if success.
///
/// Body,EndOfBody headers - OBEX Spec, 2.2.9: Byte Sequence
///
/// # Safety
///
/// - `in_header_data` must be a valid pointer.
/// - `dict_ref` generic must be of the correct type.
/// - `dict_ref` generic must be of the correct type.
/// - `dict_ref` might not allow `None`.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn OBEXAddBodyHeader(
    in_header_data: *const c_void,
    in_header_data_length: u32,
    is_end_of_body: bool,
    dict_ref: Option<&CFMutableDictionary>,
) -> OBEXError {
    extern "C-unwind" {
        fn OBEXAddBodyHeader(
            in_header_data: *const c_void,
            in_header_data_length: u32,
            is_end_of_body: Boolean,
            dict_ref: Option<&CFMutableDictionary>,
        ) -> OBEXError;
    }
    unsafe {
        OBEXAddBodyHeader(
            in_header_data,
            in_header_data_length,
            is_end_of_body as _,
            dict_ref,
        )
    }
}

extern "C-unwind" {
    /// Add bytes of data to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - inHeaderData: Who header data.
    ///
    /// - inHeaderDataLength: Length of Who header data.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Who headers - OBEX Spec, 2.2.10: Byte Sequence
    ///
    ///
    /// Add bytes of data to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: Who header data.
    ///
    /// Parameter `inHeaderDataLength`: Length of Who header data.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Who headers - OBEX Spec, 2.2.10: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddWhoHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes representing a connection ID to a dictionary of OBEX headers.
    ///
    /// Parameters:
    /// - inHeaderData: Connection ID data. Should be 4 bytes in length only.
    ///
    /// - inHeaderDataLength: Length of Connection ID data. This should ONLY be set to equal 4.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// ConnectionID headers - OBEX Spec, 2.2.10: Byte Sequence
    ///
    /// *** IMPORTANT NOTE: In bluetooth 1.0, using this function will allow you to pass in any value. You should not pass more than 4 bytes ever. In later releases, if the length passed is not 4, a kOBEXBadArgumentError error will be returned. ***
    ///
    ///
    /// Add bytes representing a connection ID to a dictionary of OBEX headers.
    ///
    /// Parameter `inHeaderData`: Connection ID data. Should be 4 bytes in length only.
    ///
    /// Parameter `inHeaderDataLength`: Length of Connection ID data. This should ONLY be set to equal 4.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// ConnectionID headers - OBEX Spec, 2.2.10: Byte Sequence
    ///
    /// ** IMPORTANT NOTE: In bluetooth 1.0, using this function will allow you to pass in any value.
    /// You should not pass more than 4 bytes ever. In later releases, if the length
    /// passed is not 4, a kOBEXBadArgumentError error will be returned. ***
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddConnectionIDHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes representing an application parameter to a dictionary of OBEX headers.
    ///
    /// Parameters:
    /// - inHeaderData: Application parameter data - should be tag/length/value triplets.
    ///
    /// - inHeaderDataLength: Length of application parameter data.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Application Request/Response Parameter headers - OBEX Spec, 2.2.11: Byte Sequence
    ///
    ///
    /// Add bytes representing an application parameter to a dictionary of OBEX headers.
    ///
    /// Parameter `inHeaderData`: Application parameter data - should be tag/length/value triplets.
    ///
    /// Parameter `inHeaderDataLength`: Length of application parameter data.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Application Request/Response Parameter headers - OBEX Spec, 2.2.11: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddApplicationParameterHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a byte sequence header to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - inHeaderData: Bytes you want to put in the byte sequence header.
    ///
    /// - inHeaderDataLength: Length of the bytes you want to put in the byte sequence header.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Byte Sequence header - OBEX Spec, 2.2.5: Byte sequence. One thing of important note here - since we don’t know what Header Identifier and length you intend to use here, you MUST include your own identifier and length in the data you pass. Thus, your data must be in this format: <1:HI><2:LENGTH><n:()> Also, note that LENGTH = (3 + n), (1 for HI, 2 for the 2 bytes of length information, plus your n bytes of custom data). Be careful here to not mess up these values, as it could adversely affect the ability of the remote-device’s headers parser.
    ///
    ///
    /// Add a byte sequence header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the byte sequence header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in the byte sequence header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Byte Sequence header - OBEX Spec, 2.2.5: Byte sequence. One thing of important note here - since we
    /// don't know what Header Identifier and length you intend to use here, you MUST include your own
    /// identifier and length in the data you pass. Thus, your data must be in this format:
    /// <
    /// 1:HI>
    /// <
    /// 2:LENGTH>
    /// <n
    /// :(
    /// <TAG
    /// >
    /// <LENGTH
    /// >
    /// <VALUE
    /// >)>
    /// Also, note that LENGTH = (3 + n), (1 for HI, 2 for the 2 bytes of length information, plus your n bytes of custom data).
    /// Be careful here to not mess up these values, as it could adversely affect the ability of the remote-device's headers parser.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddByteSequenceHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add an object class header to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - inHeaderData: Bytes you want to put in the object class header.
    ///
    /// - inHeaderDataLength: Length of the bytes you want to put in the object class header.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Object Class header - OBEX Spec, 2.2.15: Byte sequence.
    ///
    ///
    /// Add an object class header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the object class header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in the object class header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Object Class header - OBEX Spec, 2.2.15: Byte sequence.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddObjectClassHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add an authorization challenge header to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - inHeaderData: Bytes you want to put in the authorization challenge header.
    ///
    /// - inHeaderDataLength: Length of the bytes you want to put in authorization challenge header.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Authorization Challenge header - OBEX Spec, 2.2.13: Authorization Challenge.
    ///
    ///
    /// Add an authorization challenge header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the authorization challenge header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in authorization challenge header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Authorization Challenge header - OBEX Spec, 2.2.13: Authorization Challenge.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddAuthorizationChallengeHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add an authorization Response header to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - inHeaderData: Bytes you want to put in the authorization Response header.
    ///
    /// - inHeaderDataLength: Length of the bytes you want to put in authorization Response header.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Authorization Response header - OBEX Spec, 2.2.14: Authorization Response.
    ///
    ///
    /// Add an authorization Response header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the authorization Response header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in authorization Response header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Authorization Response header - OBEX Spec, 2.2.14: Authorization Response.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddAuthorizationResponseHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a user-defined custom header to a dictionary of OBEXheaders.
    ///
    /// Parameters:
    /// - inHeaderData: Bytes you want to put in the user-defined header.
    ///
    /// - inHeaderDataLength: Length of the bytes you want to put in user-defined header.
    ///
    /// - dictRef: Dictionary you have allocated to hold the headers. Make sure it’s mutable.
    ///
    ///
    /// ## Return Value
    ///
    /// Error code, kOBEXSuccess (0) if success.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// User Defined header - OBEX Spec, 2.2.20: User Defined Headers.
    ///
    ///
    /// Add a user-defined custom header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the user-defined header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in user-defined header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// User Defined header - OBEX Spec, 2.2.20: User Defined Headers.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` generic must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddUserDefinedHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}
