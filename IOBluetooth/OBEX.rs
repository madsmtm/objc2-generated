//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kcharsetstringiso88591?language=objc)
pub const kCharsetStringISO88591: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"CHARSET=ISO-8859-1\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kcharsetstringutf8?language=objc)
pub const kCharsetStringUTF8: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"UTF-8\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kencodingstringquotedprintable?language=objc)
pub const kEncodingStringQuotedPrintable: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"QUOTED-PRINTABLE\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kencodingstringbase64?language=objc)
pub const kEncodingStringBase64: &CStr =
    unsafe { CStr::from_bytes_with_nul_unchecked(b"BASE-64\0") };
/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kencodingstring8bit?language=objc)
pub const kEncodingString8Bit: &CStr = unsafe { CStr::from_bytes_with_nul_unchecked(b"8BIT\0") };
/// Codes for OBEX errors. If the return value was not in the following range, then it is most likely resulting
/// from kernel code/IOKit, and you should consult IOReturn.h for those codes.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexerror?language=objc)
pub type OBEXError = i32;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexerrorcodes?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXErrorCodes(pub c_int);
impl OBEXErrorCodes {
    #[doc(alias = "kOBEXErrorRangeMin")]
    pub const ErrorRangeMin: Self = Self(-21850);
    #[doc(alias = "kOBEXErrorRangeMax")]
    pub const ErrorRangeMax: Self = Self(-21899);
    #[doc(alias = "kOBEXSuccess")]
    pub const Success: Self = Self(0);
    #[doc(alias = "kOBEXGeneralError")]
    pub const GeneralError: Self = Self(-21850);
    #[doc(alias = "kOBEXNoResourcesError")]
    pub const NoResourcesError: Self = Self(-21851);
    #[doc(alias = "kOBEXUnsupportedError")]
    pub const UnsupportedError: Self = Self(-21852);
    #[doc(alias = "kOBEXInternalError")]
    pub const InternalError: Self = Self(-21853);
    #[doc(alias = "kOBEXBadArgumentError")]
    pub const BadArgumentError: Self = Self(-21854);
    #[doc(alias = "kOBEXTimeoutError")]
    pub const TimeoutError: Self = Self(-21855);
    #[doc(alias = "kOBEXBadRequestError")]
    pub const BadRequestError: Self = Self(-21856);
    #[doc(alias = "kOBEXCancelledError")]
    pub const CancelledError: Self = Self(-21857);
    #[doc(alias = "kOBEXForbiddenError")]
    pub const ForbiddenError: Self = Self(-21858);
    #[doc(alias = "kOBEXUnauthorizedError")]
    pub const UnauthorizedError: Self = Self(-21859);
    #[doc(alias = "kOBEXNotAcceptableError")]
    pub const NotAcceptableError: Self = Self(-21860);
    #[doc(alias = "kOBEXConflictError")]
    pub const ConflictError: Self = Self(-21861);
    #[doc(alias = "kOBEXMethodNotAllowedError")]
    pub const MethodNotAllowedError: Self = Self(-21862);
    #[doc(alias = "kOBEXNotFoundError")]
    pub const NotFoundError: Self = Self(-21863);
    #[doc(alias = "kOBEXNotImplementedError")]
    pub const NotImplementedError: Self = Self(-21864);
    #[doc(alias = "kOBEXPreconditionFailedError")]
    pub const PreconditionFailedError: Self = Self(-21865);
    #[doc(alias = "kOBEXSessionBusyError")]
    pub const SessionBusyError: Self = Self(-21875);
    #[doc(alias = "kOBEXSessionNotConnectedError")]
    pub const SessionNotConnectedError: Self = Self(-21876);
    #[doc(alias = "kOBEXSessionBadRequestError")]
    pub const SessionBadRequestError: Self = Self(-21877);
    #[doc(alias = "kOBEXSessionBadResponseError")]
    pub const SessionBadResponseError: Self = Self(-21878);
    #[doc(alias = "kOBEXSessionNoTransportError")]
    pub const SessionNoTransportError: Self = Self(-21879);
    #[doc(alias = "kOBEXSessionTransportDiedError")]
    pub const SessionTransportDiedError: Self = Self(-21880);
    #[doc(alias = "kOBEXSessionTimeoutError")]
    pub const SessionTimeoutError: Self = Self(-21881);
    #[doc(alias = "kOBEXSessionAlreadyConnectedError")]
    pub const SessionAlreadyConnectedError: Self = Self(-21882);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXErrorCodes {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXErrorCodes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Identifiers for OBEX Headers.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexheaderidentifiers?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXHeaderIdentifiers(pub c_uint);
impl OBEXHeaderIdentifiers {
    #[doc(alias = "kOBEXHeaderIDName")]
    pub const IDName: Self = Self(0x01);
    #[doc(alias = "kOBEXHeaderIDDescription")]
    pub const IDDescription: Self = Self(0x05);
    #[doc(alias = "kOBEXHeaderIDReservedRangeStart")]
    pub const IDReservedRangeStart: Self = Self(0x10);
    #[doc(alias = "kOBEXHeaderIDReservedRangeEnd")]
    pub const IDReservedRangeEnd: Self = Self(0x2F);
    #[doc(alias = "kOBEXHeaderIDUserDefinedRangeStart")]
    pub const IDUserDefinedRangeStart: Self = Self(0x30);
    #[doc(alias = "kOBEXHeaderIDUserDefinedRangeEnd")]
    pub const IDUserDefinedRangeEnd: Self = Self(0x3F);
    #[doc(alias = "kOBEXHeaderIDType")]
    pub const IDType: Self = Self(0x42);
    #[doc(alias = "kOBEXHeaderIDTimeISO")]
    pub const IDTimeISO: Self = Self(0x44);
    #[doc(alias = "kOBEXHeaderIDTarget")]
    pub const IDTarget: Self = Self(0x46);
    #[doc(alias = "kOBEXHeaderIDHTTP")]
    pub const IDHTTP: Self = Self(0x47);
    #[doc(alias = "kOBEXHeaderIDBody")]
    pub const IDBody: Self = Self(0x48);
    #[doc(alias = "kOBEXHeaderIDEndOfBody")]
    pub const IDEndOfBody: Self = Self(0x49);
    #[doc(alias = "kOBEXHeaderIDWho")]
    pub const IDWho: Self = Self(0x4A);
    #[doc(alias = "kOBEXHeaderIDAppParameters")]
    pub const IDAppParameters: Self = Self(0x4C);
    #[doc(alias = "kOBEXHeaderIDAuthorizationChallenge")]
    pub const IDAuthorizationChallenge: Self = Self(0x4D);
    #[doc(alias = "kOBEXHeaderIDAuthorizationResponse")]
    pub const IDAuthorizationResponse: Self = Self(0x4E);
    #[doc(alias = "kOBEXHeaderIDObjectClass")]
    pub const IDObjectClass: Self = Self(0x4F);
    #[doc(alias = "kOBEXHeaderIDCount")]
    pub const IDCount: Self = Self(0xC0);
    #[doc(alias = "kOBEXHeaderIDLength")]
    pub const IDLength: Self = Self(0xC3);
    #[doc(alias = "kOBEXHeaderIDTime4Byte")]
    pub const IDTime4Byte: Self = Self(0xC4);
    #[doc(alias = "kOBEXHeaderIDConnectionID")]
    pub const IDConnectionID: Self = Self(0xCB);
    #[doc(alias = "kOBEXHeaderIDOBEX13WANUUID")]
    pub const IDOBEX13WANUUID: Self = Self(0x50);
    #[doc(alias = "kOBEXHeaderIDOBEX13ObjectClass")]
    pub const IDOBEX13ObjectClass: Self = Self(0x51);
    #[doc(alias = "kOBEXHeaderIDOBEX13SessionParameters")]
    pub const IDOBEX13SessionParameters: Self = Self(0x52);
    #[doc(alias = "kOBEXHeaderIDOBEX13SessionSequenceNumber")]
    pub const IDOBEX13SessionSequenceNumber: Self = Self(0x93);
    #[doc(alias = "kOBEXHeaderIDOBEX13CreatorID")]
    pub const IDOBEX13CreatorID: Self = Self(0xCF);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXHeaderIdentifiers {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXHeaderIdentifiers {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Response opCode values.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexopcoderesponsevalues?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXOpCodeResponseValues(pub c_uint);
impl OBEXOpCodeResponseValues {
    #[doc(alias = "kOBEXResponseCodeReservedRangeStart")]
    pub const ResponseCodeReservedRangeStart: Self = Self(0x00);
    #[doc(alias = "kOBEXResponseCodeReservedRangeEnd")]
    pub const ResponseCodeReservedRangeEnd: Self = Self(0x0F);
    #[doc(alias = "kOBEXResponseCodeContinue")]
    pub const ResponseCodeContinue: Self = Self(0x10);
    #[doc(alias = "kOBEXResponseCodeContinueWithFinalBit")]
    pub const ResponseCodeContinueWithFinalBit: Self = Self(0x90);
    #[doc(alias = "kOBEXResponseCodeSuccess")]
    pub const ResponseCodeSuccess: Self = Self(0x20);
    #[doc(alias = "kOBEXResponseCodeSuccessWithFinalBit")]
    pub const ResponseCodeSuccessWithFinalBit: Self = Self(0xA0);
    #[doc(alias = "kOBEXResponseCodeCreated")]
    pub const ResponseCodeCreated: Self = Self(0x21);
    #[doc(alias = "kOBEXResponseCodeCreatedWithFinalBit")]
    pub const ResponseCodeCreatedWithFinalBit: Self = Self(0xA1);
    #[doc(alias = "kOBEXResponseCodeAccepted")]
    pub const ResponseCodeAccepted: Self = Self(0x22);
    #[doc(alias = "kOBEXResponseCodeAcceptedWithFinalBit")]
    pub const ResponseCodeAcceptedWithFinalBit: Self = Self(0xA2);
    #[doc(alias = "kOBEXResponseCodeNonAuthoritativeInfo")]
    pub const ResponseCodeNonAuthoritativeInfo: Self = Self(0x23);
    #[doc(alias = "kOBEXResponseCodeNonAuthoritativeInfoWithFinalBit")]
    pub const ResponseCodeNonAuthoritativeInfoWithFinalBit: Self = Self(0xA3);
    #[doc(alias = "kOBEXResponseCodeNoContent")]
    pub const ResponseCodeNoContent: Self = Self(0x24);
    #[doc(alias = "kOBEXResponseCodeNoContentWithFinalBit")]
    pub const ResponseCodeNoContentWithFinalBit: Self = Self(0xA4);
    #[doc(alias = "kOBEXResponseCodeResetContent")]
    pub const ResponseCodeResetContent: Self = Self(0x25);
    #[doc(alias = "kOBEXResponseCodeResetContentWithFinalBit")]
    pub const ResponseCodeResetContentWithFinalBit: Self = Self(0xA5);
    #[doc(alias = "kOBEXResponseCodePartialContent")]
    pub const ResponseCodePartialContent: Self = Self(0x26);
    #[doc(alias = "kOBEXResponseCodePartialContentWithFinalBit")]
    pub const ResponseCodePartialContentWithFinalBit: Self = Self(0xA6);
    #[doc(alias = "kOBEXResponseCodeMultipleChoices")]
    pub const ResponseCodeMultipleChoices: Self = Self(0x30);
    #[doc(alias = "kOBEXResponseCodeMultipleChoicesWithFinalBit")]
    pub const ResponseCodeMultipleChoicesWithFinalBit: Self = Self(0xB0);
    #[doc(alias = "kOBEXResponseCodeMovedPermanently")]
    pub const ResponseCodeMovedPermanently: Self = Self(0x31);
    #[doc(alias = "kOBEXResponseCodeMovedPermanentlyWithFinalBit")]
    pub const ResponseCodeMovedPermanentlyWithFinalBit: Self = Self(0xB1);
    #[doc(alias = "kOBEXResponseCodeMovedTemporarily")]
    pub const ResponseCodeMovedTemporarily: Self = Self(0x32);
    #[doc(alias = "kOBEXResponseCodeMovedTemporarilyWithFinalBit")]
    pub const ResponseCodeMovedTemporarilyWithFinalBit: Self = Self(0xB2);
    #[doc(alias = "kOBEXResponseCodeSeeOther")]
    pub const ResponseCodeSeeOther: Self = Self(0x33);
    #[doc(alias = "kOBEXResponseCodeSeeOtherWithFinalBit")]
    pub const ResponseCodeSeeOtherWithFinalBit: Self = Self(0xB3);
    #[doc(alias = "kOBEXResponseCodeNotModified")]
    pub const ResponseCodeNotModified: Self = Self(0x34);
    #[doc(alias = "kOBEXResponseCodeNotModifiedWithFinalBit")]
    pub const ResponseCodeNotModifiedWithFinalBit: Self = Self(0xB4);
    #[doc(alias = "kOBEXResponseCodeUseProxy")]
    pub const ResponseCodeUseProxy: Self = Self(0x35);
    #[doc(alias = "kOBEXResponseCodeUseProxyWithFinalBit")]
    pub const ResponseCodeUseProxyWithFinalBit: Self = Self(0xB5);
    #[doc(alias = "kOBEXResponseCodeBadRequest")]
    pub const ResponseCodeBadRequest: Self = Self(0x40);
    #[doc(alias = "kOBEXResponseCodeBadRequestWithFinalBit")]
    pub const ResponseCodeBadRequestWithFinalBit: Self = Self(0xC0);
    #[doc(alias = "kOBEXResponseCodeUnauthorized")]
    pub const ResponseCodeUnauthorized: Self = Self(0x41);
    #[doc(alias = "kOBEXResponseCodeUnauthorizedWithFinalBit")]
    pub const ResponseCodeUnauthorizedWithFinalBit: Self = Self(0xC1);
    #[doc(alias = "kOBEXResponseCodePaymentRequired")]
    pub const ResponseCodePaymentRequired: Self = Self(0x42);
    #[doc(alias = "kOBEXResponseCodePaymentRequiredWithFinalBit")]
    pub const ResponseCodePaymentRequiredWithFinalBit: Self = Self(0xC2);
    #[doc(alias = "kOBEXResponseCodeForbidden")]
    pub const ResponseCodeForbidden: Self = Self(0x43);
    #[doc(alias = "kOBEXResponseCodeForbiddenWithFinalBit")]
    pub const ResponseCodeForbiddenWithFinalBit: Self = Self(0xC3);
    #[doc(alias = "kOBEXResponseCodeNotFound")]
    pub const ResponseCodeNotFound: Self = Self(0x44);
    #[doc(alias = "kOBEXResponseCodeNotFoundWithFinalBit")]
    pub const ResponseCodeNotFoundWithFinalBit: Self = Self(0xC4);
    #[doc(alias = "kOBEXResponseCodeMethodNotAllowed")]
    pub const ResponseCodeMethodNotAllowed: Self = Self(0x45);
    #[doc(alias = "kOBEXResponseCodeMethodNotAllowedWithFinalBit")]
    pub const ResponseCodeMethodNotAllowedWithFinalBit: Self = Self(0xC5);
    #[doc(alias = "kOBEXResponseCodeNotAcceptable")]
    pub const ResponseCodeNotAcceptable: Self = Self(0x46);
    #[doc(alias = "kOBEXResponseCodeNotAcceptableWithFinalBit")]
    pub const ResponseCodeNotAcceptableWithFinalBit: Self = Self(0xC6);
    #[doc(alias = "kOBEXResponseCodeProxyAuthenticationRequired")]
    pub const ResponseCodeProxyAuthenticationRequired: Self = Self(0x47);
    #[doc(alias = "kOBEXResponseCodeProxyAuthenticationRequiredWithFinalBit")]
    pub const ResponseCodeProxyAuthenticationRequiredWithFinalBit: Self = Self(0xC7);
    #[doc(alias = "kOBEXResponseCodeRequestTimeOut")]
    pub const ResponseCodeRequestTimeOut: Self = Self(0x48);
    #[doc(alias = "kOBEXResponseCodeRequestTimeOutWithFinalBit")]
    pub const ResponseCodeRequestTimeOutWithFinalBit: Self = Self(0xC8);
    #[doc(alias = "kOBEXResponseCodeConflict")]
    pub const ResponseCodeConflict: Self = Self(0x49);
    #[doc(alias = "kOBEXResponseCodeConflictWithFinalBit")]
    pub const ResponseCodeConflictWithFinalBit: Self = Self(0xC9);
    #[doc(alias = "kOBEXResponseCodeGone")]
    pub const ResponseCodeGone: Self = Self(0x4A);
    #[doc(alias = "kOBEXResponseCodeGoneWithFinalBit")]
    pub const ResponseCodeGoneWithFinalBit: Self = Self(0xCA);
    #[doc(alias = "kOBEXResponseCodeLengthRequired")]
    pub const ResponseCodeLengthRequired: Self = Self(0x4B);
    #[doc(alias = "kOBEXResponseCodeLengthRequiredFinalBit")]
    pub const ResponseCodeLengthRequiredFinalBit: Self = Self(0xCB);
    #[doc(alias = "kOBEXResponseCodePreconditionFailed")]
    pub const ResponseCodePreconditionFailed: Self = Self(0x4C);
    #[doc(alias = "kOBEXResponseCodePreconditionFailedWithFinalBit")]
    pub const ResponseCodePreconditionFailedWithFinalBit: Self = Self(0xCC);
    #[doc(alias = "kOBEXResponseCodeRequestedEntityTooLarge")]
    pub const ResponseCodeRequestedEntityTooLarge: Self = Self(0x4D);
    #[doc(alias = "kOBEXResponseCodeRequestedEntityTooLargeWithFinalBit")]
    pub const ResponseCodeRequestedEntityTooLargeWithFinalBit: Self = Self(0xCD);
    #[doc(alias = "kOBEXResponseCodeRequestURLTooLarge")]
    pub const ResponseCodeRequestURLTooLarge: Self = Self(0x4E);
    #[doc(alias = "kOBEXResponseCodeRequestURLTooLargeWithFinalBit")]
    pub const ResponseCodeRequestURLTooLargeWithFinalBit: Self = Self(0xCE);
    #[doc(alias = "kOBEXResponseCodeUnsupportedMediaType")]
    pub const ResponseCodeUnsupportedMediaType: Self = Self(0x4F);
    #[doc(alias = "kOBEXResponseCodeUnsupportedMediaTypeWithFinalBit")]
    pub const ResponseCodeUnsupportedMediaTypeWithFinalBit: Self = Self(0xCF);
    #[doc(alias = "kOBEXResponseCodeInternalServerError")]
    pub const ResponseCodeInternalServerError: Self = Self(0x50);
    #[doc(alias = "kOBEXResponseCodeInternalServerErrorWithFinalBit")]
    pub const ResponseCodeInternalServerErrorWithFinalBit: Self = Self(0xD0);
    #[doc(alias = "kOBEXResponseCodeNotImplemented")]
    pub const ResponseCodeNotImplemented: Self = Self(0x51);
    #[doc(alias = "kOBEXResponseCodeNotImplementedWithFinalBit")]
    pub const ResponseCodeNotImplementedWithFinalBit: Self = Self(0xD1);
    #[doc(alias = "kOBEXResponseCodeBadGateway")]
    pub const ResponseCodeBadGateway: Self = Self(0x52);
    #[doc(alias = "kOBEXResponseCodeBadGatewayWithFinalBit")]
    pub const ResponseCodeBadGatewayWithFinalBit: Self = Self(0xD2);
    #[doc(alias = "kOBEXResponseCodeServiceUnavailable")]
    pub const ResponseCodeServiceUnavailable: Self = Self(0x53);
    #[doc(alias = "kOBEXResponseCodeServiceUnavailableWithFinalBit")]
    pub const ResponseCodeServiceUnavailableWithFinalBit: Self = Self(0xD3);
    #[doc(alias = "kOBEXResponseCodeGatewayTimeout")]
    pub const ResponseCodeGatewayTimeout: Self = Self(0x54);
    #[doc(alias = "kOBEXResponseCodeGatewayTimeoutWithFinalBit")]
    pub const ResponseCodeGatewayTimeoutWithFinalBit: Self = Self(0xD4);
    #[doc(alias = "kOBEXResponseCodeHTTPVersionNotSupported")]
    pub const ResponseCodeHTTPVersionNotSupported: Self = Self(0x55);
    #[doc(alias = "kOBEXResponseCodeHTTPVersionNotSupportedWithFinalBit")]
    pub const ResponseCodeHTTPVersionNotSupportedWithFinalBit: Self = Self(0xD5);
    #[doc(alias = "kOBEXResponseCodeDatabaseFull")]
    pub const ResponseCodeDatabaseFull: Self = Self(0x60);
    #[doc(alias = "kOBEXResponseCodeDatabaseFullWithFinalBit")]
    pub const ResponseCodeDatabaseFullWithFinalBit: Self = Self(0xE0);
    #[doc(alias = "kOBEXResponseCodeDatabaseLocked")]
    pub const ResponseCodeDatabaseLocked: Self = Self(0x61);
    #[doc(alias = "kOBEXResponseCodeDatabaseLockedWithFinalBit")]
    pub const ResponseCodeDatabaseLockedWithFinalBit: Self = Self(0xE1);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXOpCodeResponseValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXOpCodeResponseValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Operation OpCode values for commands.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexopcodecommandvalues?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXOpCodeCommandValues(pub c_uint);
impl OBEXOpCodeCommandValues {
    #[doc(alias = "kOBEXOpCodeReserved")]
    pub const Reserved: Self = Self(0x04);
    #[doc(alias = "kOBEXOpCodeConnect")]
    pub const Connect: Self = Self(0x80);
    #[doc(alias = "kOBEXOpCodeDisconnect")]
    pub const Disconnect: Self = Self(0x81);
    #[doc(alias = "kOBEXOpCodePut")]
    pub const Put: Self = Self(0x02);
    #[doc(alias = "kOBEXOpCodePutWithHighBitSet")]
    pub const PutWithHighBitSet: Self = Self(0x82);
    #[doc(alias = "kOBEXOpCodeGet")]
    pub const Get: Self = Self(0x03);
    #[doc(alias = "kOBEXOpCodeGetWithHighBitSet")]
    pub const GetWithHighBitSet: Self = Self(0x83);
    #[doc(alias = "kOBEXOpCodeReservedWithHighBitSet")]
    pub const ReservedWithHighBitSet: Self = Self(0x84);
    #[doc(alias = "kOBEXOpCodeSetPath")]
    pub const SetPath: Self = Self(0x85);
    #[doc(alias = "kOBEXOpCodeAbort")]
    pub const Abort: Self = Self(0xFF);
    #[doc(alias = "kOBEXOpCodeReservedRangeStart")]
    pub const ReservedRangeStart: Self = Self(0x06);
    #[doc(alias = "kOBEXOpCodeReservedRangeEnd")]
    pub const ReservedRangeEnd: Self = Self(0x0F);
    #[doc(alias = "kOBEXOpCodeUserDefinedStart")]
    pub const UserDefinedStart: Self = Self(0x10);
    #[doc(alias = "kOBEXOpCodeUserDefinedEnd")]
    pub const UserDefinedEnd: Self = Self(0x1F);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXOpCodeCommandValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXOpCodeCommandValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags for Connect command.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexconnectflagvalues?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXConnectFlagValues(pub c_uint);
impl OBEXConnectFlagValues {
    #[doc(alias = "kOBEXConnectFlagNone")]
    pub const FlagNone: Self = Self(0 << 0);
    #[doc(alias = "kOBEXConnectFlagSupportMultipleItLMPConnections")]
    pub const FlagSupportMultipleItLMPConnections: Self = Self(1 << 0);
    #[doc(alias = "kOBEXConnectFlag1Reserved")]
    pub const Flag1Reserved: Self = Self(1 << 1);
    #[doc(alias = "kOBEXConnectFlag2Reserved")]
    pub const Flag2Reserved: Self = Self(1 << 2);
    #[doc(alias = "kOBEXConnectFlag3Reserved")]
    pub const Flag3Reserved: Self = Self(1 << 3);
    #[doc(alias = "kOBEXConnectFlag4Reserved")]
    pub const Flag4Reserved: Self = Self(1 << 4);
    #[doc(alias = "kOBEXConnectFlag5Reserved")]
    pub const Flag5Reserved: Self = Self(1 << 5);
    #[doc(alias = "kOBEXConnectFlag6Reserved")]
    pub const Flag6Reserved: Self = Self(1 << 6);
    #[doc(alias = "kOBEXConnectFlag7Reserved")]
    pub const Flag7Reserved: Self = Self(1 << 7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXConnectFlagValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXConnectFlagValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags for SetPath command. Not that these are called "PutFlags". That is a mistake, they are not used
/// with a Put command. We are not changing the names to maintain backwards compatibility.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexputflagvalues?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXPutFlagValues(pub c_uint);
impl OBEXPutFlagValues {
    #[doc(alias = "kOBEXPutFlagNone")]
    pub const FlagNone: Self = Self(0 << 0);
    #[doc(alias = "kOBEXPutFlagGoToParentDirFirst")]
    pub const FlagGoToParentDirFirst: Self = Self(1 << 0);
    #[doc(alias = "kOBEXPutFlagDontCreateDirectory")]
    pub const FlagDontCreateDirectory: Self = Self(1 << 1);
    #[doc(alias = "kOBEXPutFlag2Reserved")]
    pub const Flag2Reserved: Self = Self(1 << 2);
    #[doc(alias = "kOBEXPutFlag3Reserved")]
    pub const Flag3Reserved: Self = Self(1 << 3);
    #[doc(alias = "kOBEXPutFlag4Reserved")]
    pub const Flag4Reserved: Self = Self(1 << 4);
    #[doc(alias = "kOBEXPutFlag5Reserved")]
    pub const Flag5Reserved: Self = Self(1 << 5);
    #[doc(alias = "kOBEXPutFlag6Reserved")]
    pub const Flag6Reserved: Self = Self(1 << 6);
    #[doc(alias = "kOBEXPutFlag7Reserved")]
    pub const Flag7Reserved: Self = Self(1 << 7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXPutFlagValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXPutFlagValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Flags for Nonce command during digest challenge.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexnonceflagvalues?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXNonceFlagValues(pub c_uint);
impl OBEXNonceFlagValues {
    #[doc(alias = "kOBEXNonceFlagNone")]
    pub const FlagNone: Self = Self(0 << 0);
    #[doc(alias = "kOBEXNonceFlagSendUserIDInResponse")]
    pub const FlagSendUserIDInResponse: Self = Self(1 << 0);
    #[doc(alias = "kOBEXNonceFlagAccessModeReadOnly")]
    pub const FlagAccessModeReadOnly: Self = Self(1 << 1);
    #[doc(alias = "kOBEXNonceFlag2Reserved")]
    pub const Flag2Reserved: Self = Self(1 << 2);
    #[doc(alias = "kOBEXNonceFlag3Reserved")]
    pub const Flag3Reserved: Self = Self(1 << 3);
    #[doc(alias = "kOBEXNonceFlag4Reserved")]
    pub const Flag4Reserved: Self = Self(1 << 4);
    #[doc(alias = "kOBEXNonceFlag5Reserved")]
    pub const Flag5Reserved: Self = Self(1 << 5);
    #[doc(alias = "kOBEXNonceFlag6Reserved")]
    pub const Flag6Reserved: Self = Self(1 << 6);
    #[doc(alias = "kOBEXNonceFlag7Reserved")]
    pub const Flag7Reserved: Self = Self(1 << 7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXNonceFlagValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXNonceFlagValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Values for Realm during digest response.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexrealmvalues?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXRealmValues(pub c_uint);
impl OBEXRealmValues {
    #[doc(alias = "kOBEXRealmASCII")]
    pub const ASCII: Self = Self(0x00);
    #[doc(alias = "kOBEXRealmISO88591")]
    pub const ISO88591: Self = Self(0x01);
    #[doc(alias = "kOBEXRealmISO88592")]
    pub const ISO88592: Self = Self(0x02);
    #[doc(alias = "kOBEXRealmISO88593")]
    pub const ISO88593: Self = Self(0x03);
    #[doc(alias = "kOBEXRealmISO88594")]
    pub const ISO88594: Self = Self(0x04);
    #[doc(alias = "kOBEXRealmISO88595")]
    pub const ISO88595: Self = Self(0x05);
    #[doc(alias = "kOBEXRealmISO88596")]
    pub const ISO88596: Self = Self(0x06);
    #[doc(alias = "kOBEXRealmISO88597")]
    pub const ISO88597: Self = Self(0x07);
    #[doc(alias = "kOBEXRealmISO88598")]
    pub const ISO88598: Self = Self(0x08);
    #[doc(alias = "kOBEXRealmISO88599")]
    pub const ISO88599: Self = Self(0x09);
    #[doc(alias = "kOBEXRealmUNICODE")]
    pub const UNICODE: Self = Self(0xFF);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXRealmValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXRealmValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Operation OpCode values for sessions. From the OBEX 1.3 specification.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexopcodesessionvalues?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXOpCodeSessionValues(pub c_uint);
impl OBEXOpCodeSessionValues {
    #[doc(alias = "kOBEXOpCodeCreateSession")]
    pub const CreateSession: Self = Self(0x00);
    #[doc(alias = "kOBEXOpCodeCloseSession")]
    pub const CloseSession: Self = Self(0x01);
    #[doc(alias = "kOBEXOpCodeSuspendSession")]
    pub const SuspendSession: Self = Self(0x02);
    #[doc(alias = "kOBEXOpCodeResumeSession")]
    pub const ResumeSession: Self = Self(0x03);
    #[doc(alias = "kOBEXOpCodeSetTimeout")]
    pub const SetTimeout: Self = Self(0x04);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXOpCodeSessionValues {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXOpCodeSessionValues {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Tags for SessionParameters.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsessionparametertags?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXSessionParameterTags(pub c_uint);
impl OBEXSessionParameterTags {
    #[doc(alias = "kOBEXSessionParameterTagDeviceAddress")]
    pub const DeviceAddress: Self = Self(0x00);
    #[doc(alias = "kOBEXSessionParameterTagNonce")]
    pub const Nonce: Self = Self(0x01);
    #[doc(alias = "kOBEXSessionParameterTagSessionID")]
    pub const SessionID: Self = Self(0x02);
    #[doc(alias = "kOBEXSessionParameterTagNextSequenceNumber")]
    pub const NextSequenceNumber: Self = Self(0x03);
    #[doc(alias = "kOBEXSessionParameterTagTimeout")]
    pub const Timeout: Self = Self(0x04);
    #[doc(alias = "kOBEXSessionParameterTagSessionOpcode")]
    pub const SessionOpcode: Self = Self(0x05);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSessionParameterTags {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSessionParameterTags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The available/supported OBEX versions.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexversions?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXVersions(pub c_uint);
impl OBEXVersions {
    #[doc(alias = "kOBEXVersion10")]
    pub const Version10: Self = Self(0x10);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXVersions {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXVersions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexheaderidentifier?language=objc)
pub type OBEXHeaderIdentifier = u8;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexversion?language=objc)
pub type OBEXVersion = u8;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexflags?language=objc)
pub type OBEXFlags = u8;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexopcode?language=objc)
pub type OBEXOpCode = u8;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexconstants?language=objc)
pub type OBEXConstants = u8;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexmaxpacketlength?language=objc)
pub type OBEXMaxPacketLength = u16;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/opaqueobexsessionref?language=objc)
#[repr(C)]
#[derive(Debug)]
pub struct OpaqueOBEXSessionRef {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OpaqueOBEXSessionRef {
    const ENCODING_REF: Encoding =
        Encoding::Pointer(&Encoding::Struct("OpaqueOBEXSessionRef", &[]));
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsessionref?language=objc)
pub type OBEXSessionRef = *mut OpaqueOBEXSessionRef;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexconnectcommandresponsedata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXConnectCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub maxPacketSize: OBEXMaxPacketLength,
    pub version: OBEXVersion,
    pub flags: OBEXFlags,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXConnectCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXConnectCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <OBEXMaxPacketLength>::ENCODING,
            <OBEXVersion>::ENCODING,
            <OBEXFlags>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXConnectCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexdisconnectcommandresponsedata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXDisconnectCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXDisconnectCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXDisconnectCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXDisconnectCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexputcommandresponsedata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXPutCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXPutCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXPutCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXPutCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexgetcommandresponsedata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXGetCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXGetCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXGetCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXGetCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsetpathcommandresponsedata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXSetPathCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub flags: OBEXFlags,
    pub constants: OBEXConstants,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSetPathCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXSetPathCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <OBEXFlags>::ENCODING,
            <OBEXConstants>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSetPathCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexabortcommandresponsedata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXAbortCommandResponseData {
    pub serverResponseOpCode: OBEXOpCode,
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXAbortCommandResponseData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXAbortCommandResponseData",
        &[
            <OBEXOpCode>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXAbortCommandResponseData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexconnectcommanddata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXConnectCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub maxPacketSize: OBEXMaxPacketLength,
    pub version: OBEXVersion,
    pub flags: OBEXFlags,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXConnectCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXConnectCommandData",
        &[
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <OBEXMaxPacketLength>::ENCODING,
            <OBEXVersion>::ENCODING,
            <OBEXFlags>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXConnectCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexdisconnectcommanddata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXDisconnectCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXDisconnectCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXDisconnectCommandData",
        &[<*mut c_void>::ENCODING, <usize>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXDisconnectCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexputcommanddata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXPutCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub bodyDataLeftToSend: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXPutCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXPutCommandData",
        &[
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXPutCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexgetcommanddata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXGetCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXGetCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXGetCommandData",
        &[<*mut c_void>::ENCODING, <usize>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXGetCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsetpathcommanddata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXSetPathCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
    pub flags: OBEXFlags,
    pub constants: OBEXConstants,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSetPathCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXSetPathCommandData",
        &[
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
            <OBEXFlags>::ENCODING,
            <OBEXConstants>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSetPathCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexabortcommanddata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXAbortCommandData {
    pub headerDataPtr: *mut c_void,
    pub headerDataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXAbortCommandData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXAbortCommandData",
        &[<*mut c_void>::ENCODING, <usize>::ENCODING],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXAbortCommandData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexerrordata?language=objc)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct OBEXErrorData {
    pub error: OBEXError,
    pub dataPtr: *mut c_void,
    pub dataLength: usize,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXErrorData {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXErrorData",
        &[
            <OBEXError>::ENCODING,
            <*mut c_void>::ENCODING,
            <usize>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXErrorData {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// When a new session event occurs, your selector (or C callback) will be given an OBEXSessionEvent pointer,
/// and in it will be a 'type' field with one of the following types in it. Based on that type, you can then
/// read the corresponding field in the union to get out interesting data for that event type. For example,
/// if the type of an event is a 'kOBEXSessionEventTypeConnectCommandResponseReceived', you should look in
/// the 'OBEXConnectCommandResponseData' part of the structure's union to find more information pased to you
/// in the event. Note that some you will never see, depending on the type of session you are using - a client
/// or server. If you are a client (most likely case), you will never see the "Command" events, but instead
/// you will only receive the "CommandResponse" events since you will be the issuer oft he commands, not the
/// receiver of them. Both types of sessions will receive error type events.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsessioneventtypes?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct OBEXSessionEventTypes(pub c_uint);
impl OBEXSessionEventTypes {
    #[doc(alias = "kOBEXSessionEventTypeConnectCommandResponseReceived")]
    pub const ConnectCommandResponseReceived: Self = Self(0x4f434543);
    #[doc(alias = "kOBEXSessionEventTypeDisconnectCommandResponseReceived")]
    pub const DisconnectCommandResponseReceived: Self = Self(0x4f434544);
    #[doc(alias = "kOBEXSessionEventTypePutCommandResponseReceived")]
    pub const PutCommandResponseReceived: Self = Self(0x4f434550);
    #[doc(alias = "kOBEXSessionEventTypeGetCommandResponseReceived")]
    pub const GetCommandResponseReceived: Self = Self(0x4f434547);
    #[doc(alias = "kOBEXSessionEventTypeSetPathCommandResponseReceived")]
    pub const SetPathCommandResponseReceived: Self = Self(0x4f434553);
    #[doc(alias = "kOBEXSessionEventTypeAbortCommandResponseReceived")]
    pub const AbortCommandResponseReceived: Self = Self(0x4f434541);
    #[doc(alias = "kOBEXSessionEventTypeConnectCommandReceived")]
    pub const ConnectCommandReceived: Self = Self(0x4f534543);
    #[doc(alias = "kOBEXSessionEventTypeDisconnectCommandReceived")]
    pub const DisconnectCommandReceived: Self = Self(0x4f534544);
    #[doc(alias = "kOBEXSessionEventTypePutCommandReceived")]
    pub const PutCommandReceived: Self = Self(0x4f534550);
    #[doc(alias = "kOBEXSessionEventTypeGetCommandReceived")]
    pub const GetCommandReceived: Self = Self(0x4f534547);
    #[doc(alias = "kOBEXSessionEventTypeSetPathCommandReceived")]
    pub const SetPathCommandReceived: Self = Self(0x4f534553);
    #[doc(alias = "kOBEXSessionEventTypeAbortCommandReceived")]
    pub const AbortCommandReceived: Self = Self(0x4f534541);
    #[doc(alias = "kOBEXSessionEventTypeError")]
    pub const Error: Self = Self(0x4f474545);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSessionEventTypes {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSessionEventTypes {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsessioneventtype?language=objc)
pub type OBEXSessionEventType = u32;

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsessionevent_u?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub union OBEXSessionEvent_u {
    pub connectCommandResponseData: OBEXConnectCommandResponseData,
    pub disconnectCommandResponseData: OBEXDisconnectCommandResponseData,
    pub putCommandResponseData: OBEXPutCommandResponseData,
    pub getCommandResponseData: OBEXGetCommandResponseData,
    pub setPathCommandResponseData: OBEXSetPathCommandResponseData,
    pub abortCommandResponseData: OBEXAbortCommandResponseData,
    pub connectCommandData: OBEXConnectCommandData,
    pub disconnectCommandData: OBEXDisconnectCommandData,
    pub putCommandData: OBEXPutCommandData,
    pub getCommandData: OBEXGetCommandData,
    pub setPathCommandData: OBEXSetPathCommandData,
    pub abortCommandData: OBEXAbortCommandData,
    pub errorData: OBEXErrorData,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSessionEvent_u {
    const ENCODING: Encoding = Encoding::Union(
        "?",
        &[
            <OBEXConnectCommandResponseData>::ENCODING,
            <OBEXDisconnectCommandResponseData>::ENCODING,
            <OBEXPutCommandResponseData>::ENCODING,
            <OBEXGetCommandResponseData>::ENCODING,
            <OBEXSetPathCommandResponseData>::ENCODING,
            <OBEXAbortCommandResponseData>::ENCODING,
            <OBEXConnectCommandData>::ENCODING,
            <OBEXDisconnectCommandData>::ENCODING,
            <OBEXPutCommandData>::ENCODING,
            <OBEXGetCommandData>::ENCODING,
            <OBEXSetPathCommandData>::ENCODING,
            <OBEXAbortCommandData>::ENCODING,
            <OBEXErrorData>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSessionEvent_u {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsessionevent?language=objc)
#[repr(C)]
#[derive(Clone, Copy)]
pub struct OBEXSessionEvent {
    pub r#type: OBEXSessionEventType,
    pub session: OBEXSessionRef,
    pub refCon: *mut c_void,
    pub isEndOfEventData: Boolean,
    pub reserved1: *mut c_void,
    pub reserved2: *mut c_void,
    pub u: OBEXSessionEvent_u,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for OBEXSessionEvent {
    const ENCODING: Encoding = Encoding::Struct(
        "OBEXSessionEvent",
        &[
            <OBEXSessionEventType>::ENCODING,
            <OBEXSessionRef>::ENCODING,
            <*mut c_void>::ENCODING,
            <Boolean>::ENCODING,
            <*mut c_void>::ENCODING,
            <*mut c_void>::ENCODING,
            <OBEXSessionEvent_u>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for OBEXSessionEvent {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/obexsessioneventcallback?language=objc)
pub type OBEXSessionEventCallback = Option<unsafe extern "C-unwind" fn(*const OBEXSessionEvent)>;

extern "C-unwind" {
    /// Destroy an OBEX session. If connections are open, they will (eventually) be terminated for you.
    ///
    /// Parameter `inSessionRef`: A valid service reference.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// `in_session_ref` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionDelete(in_session_ref: OBEXSessionRef) -> OBEXError;
}

extern "C-unwind" {
    /// Allows you to test the session for an open OBEX connection for a particular session.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `outIsConnected`: A valid ptr to an OBEXSessionRef; will contain the newly created session if return
    /// value is kOBEXSuccess.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// This method will return true only if (a) you are transport-connected to another OBEX target and
    /// (b) an OBEX Connect command has been issued and received successfully.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `out_is_connected` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionHasOpenOBEXConnection(
        in_session_ref: OBEXSessionRef,
        out_is_connected: *mut Boolean,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Gets current max packet length.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `outLength`: Max packet length.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// This value *could* change before and after a connect command has been sent or a connect
    /// command response has been received, since the recipient could negotiate a lower max packet size.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `out_length` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionGetMaxPacketLength(
        in_session_ref: OBEXSessionRef,
        out_length: *mut OBEXMaxPacketLength,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Gets space available for your data for a particular command you are trying to send.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inOpCode`: An opcode of what command you are trying to send.
    ///
    /// Parameter `outLength`: Space available for your header data in the payload area for a particular command.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// The OBEXSession takes care of packaging OBEX opcodes and other information into the proper packet format,
    /// allowing you to focus on sending the proper OBEX headers in your commands and command responses. This formatting
    /// and datas requires a small bit of information that varies depending on what command or response you are
    /// sending. Thus, you should call this function to find out how much space will be left for your headers
    /// before you send the command, allowing you to properly chop up your headers before sending them. This will
    /// guarantee that (a) you use up all the available space in a packet and (b) that you do not get an error
    /// trying to send too much information at once.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `out_length` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionGetAvailableCommandPayloadLength(
        in_session_ref: OBEXSessionRef,
        in_op_code: OBEXOpCode,
        out_length: *mut OBEXMaxPacketLength,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Gets space available for your data for a particular command response you are trying to send.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inOpCode`: A command opcode that you are responding to. For example, if you receiving a Put command,
    /// and want to send back a "bad request" response, you should still pass in the Put command
    /// opcode for that response.
    ///
    /// Parameter `outLength`: Space available for your header data in the payload area for a particular command.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// The OBEXSession takes care of packaging OBEX opcodes and other information into the proper packet format,
    /// allowing you to focus on sending the proper OBEX headers in your commands and command responses. This formatting
    /// and datas requires a small bit of information that varies depending on what command or response you are
    /// sending. Thus, you should call this function to find out how much space will be left for your headers
    /// before you send the command, allowing you to properly chop up your headers before sending them. This will
    /// guarantee that (a) you use up all the available space in a packet and (b) that you do not get an error
    /// trying to send too much information at once.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `out_length` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionGetAvailableCommandResponsePayloadLength(
        in_session_ref: OBEXSessionRef,
        in_op_code: OBEXOpCode,
        out_length: *mut OBEXMaxPacketLength,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Establishes an OBEX connection to the target device for the session. If a transport connection is not
    /// open yet, it will be opened if possible.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inFlags`: Flags, as defined in the OBEX spec for this command.
    ///
    /// Parameter `inMaxPacketLength`: Maximum packet length you wish to allow. May be negiotiated with host to be less
    /// or more than you specify.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback parameter will
    /// result in an error. If you have already established an OBEX connection and you call this again you will
    /// get an 'kOBEXSessionAlreadyConnectedError' as a result.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionConnect(
        in_session_ref: OBEXSessionRef,
        in_flags: OBEXFlags,
        in_max_packet_length: OBEXMaxPacketLength,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a disconnect command to a remote OBEX server.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionDisconnect(
        in_session_ref: OBEXSessionRef,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

/// Send a put command to a remote OBEX server.
///
/// Parameter `inSessionRef`: A valid session reference.
///
/// Parameter `inIsFinalChunk`: TRUE or FALSE - is this the last chunk of header data for this PUT.
///
/// Parameter `inHeadersData`: Headers containing data to PUT. Don't include your body header data here.
///
/// Parameter `inHeadersDataLength`: Size of header data. Don't include your body header data here.
///
/// Parameter `inBodyData`: Data for the BODY header to PUT. DO NOT package your data in an actual BODY header,
/// this will be done for you, based on the finalChunk flag you pass in above (since based on
/// this flag the header ID will be either a BODY or ENDOFBODY header).
///
/// Parameter `inBodyDataLength`: Size of Data for the BODY header to PUT.
///
/// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
///
/// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your callback
/// just as you passed it.
///
/// Returns: An error code value. 0 if successful.
///
/// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
/// result in an error.
///
/// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
/// **        You should transition your code to Objective-C equivalents.
/// **        This API may be removed any time in the future.
///
/// # Safety
///
/// - `in_session_ref` must be a valid pointer.
/// - `in_headers_data` must be a valid pointer.
/// - `in_body_data` must be a valid pointer.
/// - `in_callback` must be implemented correctly.
/// - `in_user_ref_con` must be a valid pointer.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn OBEXSessionPut(
    in_session_ref: OBEXSessionRef,
    in_is_final_chunk: bool,
    in_headers_data: *mut c_void,
    in_headers_data_length: usize,
    in_body_data: *mut c_void,
    in_body_data_length: usize,
    in_callback: OBEXSessionEventCallback,
    in_user_ref_con: *mut c_void,
) -> OBEXError {
    extern "C-unwind" {
        fn OBEXSessionPut(
            in_session_ref: OBEXSessionRef,
            in_is_final_chunk: Boolean,
            in_headers_data: *mut c_void,
            in_headers_data_length: usize,
            in_body_data: *mut c_void,
            in_body_data_length: usize,
            in_callback: OBEXSessionEventCallback,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;
    }
    unsafe {
        OBEXSessionPut(
            in_session_ref,
            in_is_final_chunk as _,
            in_headers_data,
            in_headers_data_length,
            in_body_data,
            in_body_data_length,
            in_callback,
            in_user_ref_con,
        )
    }
}

/// Send a get command to a remote OBEX server.
///
/// Parameter `inSessionRef`: A valid session reference.
///
/// Parameter `inIsFinalChunk`: TRUE or FALSE - is this the last chunk of header data for this GET.
///
/// Parameter `inHeadersData`: Headers containing data to GET.
///
/// Parameter `inHeadersDataLength`: Size of header data.
///
/// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
///
/// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your callback
/// just as you passed it.
///
/// Returns: An error code value. 0 if successful.
///
/// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
/// result in an error.
///
/// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
/// **        You should transition your code to Objective-C equivalents.
/// **        This API may be removed any time in the future.
///
/// # Safety
///
/// - `in_session_ref` must be a valid pointer.
/// - `in_headers_data` must be a valid pointer.
/// - `in_callback` must be implemented correctly.
/// - `in_user_ref_con` must be a valid pointer.
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn OBEXSessionGet(
    in_session_ref: OBEXSessionRef,
    in_is_final_chunk: bool,
    in_headers_data: *mut c_void,
    in_headers_data_length: usize,
    in_callback: OBEXSessionEventCallback,
    in_user_ref_con: *mut c_void,
) -> OBEXError {
    extern "C-unwind" {
        fn OBEXSessionGet(
            in_session_ref: OBEXSessionRef,
            in_is_final_chunk: Boolean,
            in_headers_data: *mut c_void,
            in_headers_data_length: usize,
            in_callback: OBEXSessionEventCallback,
            in_user_ref_con: *mut c_void,
        ) -> OBEXError;
    }
    unsafe {
        OBEXSessionGet(
            in_session_ref,
            in_is_final_chunk as _,
            in_headers_data,
            in_headers_data_length,
            in_callback,
            in_user_ref_con,
        )
    }
}

extern "C-unwind" {
    /// Send an abort command to a remote OBEX server.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionAbort(
        in_session_ref: OBEXSessionRef,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a set path command to a remote OBEX server.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inFlags`: Flags, as defined in the OBEX spec for this command.
    ///
    /// Parameter `inConstants`: Constants, as defined in the OBEX spec for this command.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionSetPath(
        in_session_ref: OBEXSessionRef,
        in_flags: OBEXFlags,
        in_constants: OBEXConstants,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a connect command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inFlags`: Flags, as defined in the OBEX spec for this command.
    ///
    /// Parameter `inMaxPacketLength`: Max packet length you want to support. Must be smaller or equal to the max packet
    /// length specified by the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionConnectResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_flags: OBEXFlags,
        in_max_packet_length: OBEXMaxPacketLength,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a disconnect command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionDisconnectResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a get command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionGetResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a put command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionPutResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a abort command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionAbortResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Send a response to a set path command to the remote client.
    ///
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inResponseOpCode`: What response code you want to send to the remote client.
    ///
    /// Parameter `inOptionalHeaders`: Ptr to optional headers you can supply to the command. DO NOT dispose of this
    /// pointer until you callback is called with a success.
    ///
    /// Parameter `inOptionalHeadersLength`: Size of data at the specified ptr.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// As all commands for OBEX sessions, this command is asynchronous only. A NULL callback paramter will
    /// result in an error.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_optional_headers` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionSetPathResponse(
        in_session_ref: OBEXSessionRef,
        in_response_op_code: OBEXOpCode,
        in_optional_headers: *mut c_void,
        in_optional_headers_length: usize,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Parameter `inSessionRef`: A valid session reference.
    ///
    /// Parameter `inCallback`: A valid callback. Will be called for progress, errors and completion by server
    /// sessions only.
    ///
    /// Parameter `inUserRefCon`: Optional parameter; can contain anything you wish. Will be returned in your
    /// callback just as you passed it.
    ///
    /// Returns: An error code value. 0 if successful.
    ///
    /// Sets callback to be used when an event occurs on an OBEXSession. This is important for OBEX servers, as you
    /// will need a way to be called back when the first command is sent to you. So, be sure to set yourself
    /// up to listen for events when you are ready to receive them.
    ///
    /// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
    /// **        You should transition your code to Objective-C equivalents.
    /// **        This API may be removed any time in the future.
    ///
    /// # Safety
    ///
    /// - `in_session_ref` must be a valid pointer.
    /// - `in_callback` must be implemented correctly.
    /// - `in_user_ref_con` must be a valid pointer.
    #[deprecated]
    pub fn OBEXSessionSetServerCallback(
        in_session_ref: OBEXSessionRef,
        in_callback: OBEXSessionEventCallback,
        in_user_ref_con: *mut c_void,
    ) -> OBEXError;
}

/// Creates a formatted vCard, ready to be sent over OBEX or whatever.
///
/// Parameter `inNameCharset`: A pointer to the charset data used for the name. Pass in a #defined charset
/// for ease of use.
///
/// Parameter `inNameCharsetLength`: Length of name charset assed in above.
///
/// Parameter `inFirstName`: Pointer to data with Person's first name.
///
/// Parameter `inFirstNameLength`: Length of Person's first name passed in above.
///
/// Parameter `inLastName`: Pointer to data with Person's last name.
///
/// Parameter `inLastNameLength`: Length of Person's last name passed in above.
///
/// Parameter `inFriendlyName`: Pointer to data with Person's Friendly name.
///
/// Parameter `inFriendlyNameLength`: Length of Person's Friendly name passed in above.
///
/// Parameter `inHomePhone`: Pointer to data with Person's Home phone number.
///
/// Parameter `inHomePhoneLength`: Length of Person's Home phone number passed in above.
///
/// Parameter `inWorkPhone`: Work phone number.
///
/// Parameter `inWorkPhoneLength`: Length of Person's Work phone number passed in above.
///
/// Parameter `inCellPhone`: Cell phone number.
///
/// Parameter `inCellPhoneLength`: Length of Person's Cell phone number passed in above.
///
/// Parameter `inFaxPhone`: Fax phone number.
///
/// Parameter `inFaxPhoneLength`: Length of Person's Fax phone number passed in above.
///
/// Parameter `inEMailAddress`: EMailAddress of person.
///
/// Parameter `inEMailAddressLength`: Length of Person's EMailAddress passed in above.
///
/// Parameter `inEMailAddressCharset`: Charset of EMailAddress of person.
///
/// Parameter `inEMailAddressCharsetLength`: Length of Person's EMailAddress charset passed in above.
///
/// Parameter `inOrganization`: Pointer to Organization/business data.
///
/// Parameter `inOrganizationLength`: Length of Organization/business data.
///
/// Parameter `inOrganizationCharset`: Pointer to the charset the Organization/business is in.
///
/// Parameter `inOrganizationCharsetLength`: Length of data for the Organization/business charset.
///
/// Parameter `inTitle`: Pointer to data with Title of person in biz/org.
///
/// Parameter `inTitleLength`: Length of Title of person in biz/org.
///
/// Parameter `inTitleCharset`: Pointer to the charset the Title is in.
///
/// Parameter `inTitleCharsetLength`: Length of data for the Title charset.
///
/// Returns: An CFDataRef containing the compiled data. nil if we failed.
///
/// All parameters are optional. The CFDataRef returned to you is NOT retained. Retain it if you want to keep it.
///
/// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
/// **        You should transition your code to Objective-C equivalents.
/// **        This API may be removed any time in the future.
///
/// # Safety
///
/// - `in_first_name` must be a valid pointer.
/// - `in_last_name` must be a valid pointer.
/// - `in_friendly_name` must be a valid pointer.
/// - `in_name_charset` must be a valid pointer.
/// - `in_home_phone` must be a valid pointer.
/// - `in_work_phone` must be a valid pointer.
/// - `in_cell_phone` must be a valid pointer.
/// - `in_fax_phone` must be a valid pointer.
/// - `in_e_mail_address` must be a valid pointer.
/// - `in_e_mail_address_charset` must be a valid pointer.
/// - `in_organization` must be a valid pointer.
/// - `in_organization_charset` must be a valid pointer.
/// - `in_title` must be a valid pointer.
/// - `in_title_charset` must be a valid pointer.
#[cfg(feature = "objc2-core-foundation")]
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn OBEXCreateVCard(
    in_first_name: *const c_void,
    in_first_name_length: u32,
    in_last_name: *const c_void,
    in_last_name_length: u32,
    in_friendly_name: *const c_void,
    in_friendly_name_length: u32,
    in_name_charset: *const c_void,
    in_name_charset_length: u32,
    in_home_phone: *const c_void,
    in_home_phone_length: u32,
    in_work_phone: *const c_void,
    in_work_phone_length: u32,
    in_cell_phone: *const c_void,
    in_cell_phone_length: u32,
    in_fax_phone: *const c_void,
    in_fax_phone_length: u32,
    in_e_mail_address: *const c_void,
    in_e_mail_address_length: u32,
    in_e_mail_address_charset: *const c_void,
    in_e_mail_address_charset_length: u32,
    in_organization: *const c_void,
    in_organization_length: u32,
    in_organization_charset: *const c_void,
    in_organization_charset_length: u32,
    in_title: *const c_void,
    in_title_length: u32,
    in_title_charset: *const c_void,
    in_title_charset_length: u32,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn OBEXCreateVCard(
            in_first_name: *const c_void,
            in_first_name_length: u32,
            in_last_name: *const c_void,
            in_last_name_length: u32,
            in_friendly_name: *const c_void,
            in_friendly_name_length: u32,
            in_name_charset: *const c_void,
            in_name_charset_length: u32,
            in_home_phone: *const c_void,
            in_home_phone_length: u32,
            in_work_phone: *const c_void,
            in_work_phone_length: u32,
            in_cell_phone: *const c_void,
            in_cell_phone_length: u32,
            in_fax_phone: *const c_void,
            in_fax_phone_length: u32,
            in_e_mail_address: *const c_void,
            in_e_mail_address_length: u32,
            in_e_mail_address_charset: *const c_void,
            in_e_mail_address_charset_length: u32,
            in_organization: *const c_void,
            in_organization_length: u32,
            in_organization_charset: *const c_void,
            in_organization_charset_length: u32,
            in_title: *const c_void,
            in_title_length: u32,
            in_title_charset: *const c_void,
            in_title_charset_length: u32,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe {
        OBEXCreateVCard(
            in_first_name,
            in_first_name_length,
            in_last_name,
            in_last_name_length,
            in_friendly_name,
            in_friendly_name_length,
            in_name_charset,
            in_name_charset_length,
            in_home_phone,
            in_home_phone_length,
            in_work_phone,
            in_work_phone_length,
            in_cell_phone,
            in_cell_phone_length,
            in_fax_phone,
            in_fax_phone_length,
            in_e_mail_address,
            in_e_mail_address_length,
            in_e_mail_address_charset,
            in_e_mail_address_charset_length,
            in_organization,
            in_organization_length,
            in_organization_charset,
            in_organization_charset_length,
            in_title,
            in_title_length,
            in_title_charset,
            in_title_charset_length,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Creates a formatted vEvent, ready to be sent over OBEX or whatever. You probably will embed the output
/// in a vCalendar event.
///
/// Parameter `inCharset`: The Charset the passed data is in. Pass in a #defined charset for ease of use.
///
/// Parameter `inCharsetLength`: The length of the Charset passed data.
///
/// Parameter `inEncoding`: The encoding of the summary and location fields.
///
/// Parameter `inEncodingLength`: The length of the Charset passed data.
///
/// Parameter `inEventStartDate`: Start of event date, in the (ISO8601) format: YYYYMMDDTHHMMSS. e.g. 19960415T083000 = 8:30 am on April 15, 1996. All time values should be in LOCAL time.
///
/// Parameter `inEventStartDateLength`: The length of the Charset passed data.
///
/// Parameter `inEventEndDate`: End of event date.
///
/// Parameter `inEventEndDateLength`: The length of the Charset passed data.
///
/// Parameter `inAlarmDate`: Date of Alarm for event, in the format: YYYYMMDDTHHMMSS.
///
/// Parameter `inAlarmDateLength`: The length of the Charset passed data.
///
/// Parameter `inCategory`: Category of event, such as "MEETING" or "PHONE CALL".
///
/// Parameter `inCategoryLength`: The length of the Charset passed data.
///
/// Parameter `inSummary`: Summary of event. Max length is 36 bytes. Longer will result in a bad argument error.
///
/// Parameter `inSummaryLength`: The length of the Charset passed data.
///
/// Parameter `inLocation`: Summary of event. Max length is 20 bytes. Longer will result in a bad argument error.
///
/// Parameter `inLocationLength`: The length of the Charset passed data.
///
/// Parameter `inXIRMCLUID`: The IRMC Local Unique Identifier Label, max length 12 bytes. Longer will result in
/// a bad argument error.
///
/// Parameter `inXIRMCLUIDLength`: The length of the Charset passed data.
///
/// Returns: A valid CFDataRef -     nil if we failed.
///
/// All parameters are optional. The CFDataRef returned to you is NOT retained. Retain it if you want to keep it.
/// Be aware that certain devices such as Ericsson phones MUST have certain fields, such as a start and end date.
///
/// **        DEPRECATED IN BLUETOOTH 2.2 (Mac OS X 10.6)
/// **        You should transition your code to Objective-C equivalents.
/// **        This API may be removed any time in the future.
///
/// # Safety
///
/// - `in_charset` must be a valid pointer.
/// - `in_encoding` must be a valid pointer.
/// - `in_event_start_date` must be a valid pointer.
/// - `in_event_end_date` must be a valid pointer.
/// - `in_alarm_date` must be a valid pointer.
/// - `in_category` must be a valid pointer.
/// - `in_summary` must be a valid pointer.
/// - `in_location` must be a valid pointer.
/// - `in_xirmcluid` must be a valid pointer.
#[cfg(feature = "objc2-core-foundation")]
#[deprecated]
#[inline]
pub unsafe extern "C-unwind" fn OBEXCreateVEvent(
    in_charset: *const c_char,
    in_charset_length: u32,
    in_encoding: *const c_char,
    in_encoding_length: u32,
    in_event_start_date: *const c_char,
    in_event_start_date_length: u32,
    in_event_end_date: *const c_char,
    in_event_end_date_length: u32,
    in_alarm_date: *const c_char,
    in_alarm_date_length: u32,
    in_category: *const c_char,
    in_category_length: u32,
    in_summary: *const c_char,
    in_summary_length: u32,
    in_location: *const c_char,
    in_location_length: u32,
    in_xirmcluid: *const c_char,
    in_xirmcluid_length: u32,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn OBEXCreateVEvent(
            in_charset: *const c_char,
            in_charset_length: u32,
            in_encoding: *const c_char,
            in_encoding_length: u32,
            in_event_start_date: *const c_char,
            in_event_start_date_length: u32,
            in_event_end_date: *const c_char,
            in_event_end_date_length: u32,
            in_alarm_date: *const c_char,
            in_alarm_date_length: u32,
            in_category: *const c_char,
            in_category_length: u32,
            in_summary: *const c_char,
            in_summary_length: u32,
            in_location: *const c_char,
            in_location_length: u32,
            in_xirmcluid: *const c_char,
            in_xirmcluid_length: u32,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe {
        OBEXCreateVEvent(
            in_charset,
            in_charset_length,
            in_encoding,
            in_encoding_length,
            in_event_start_date,
            in_event_start_date_length,
            in_event_end_date,
            in_event_end_date_length,
            in_alarm_date,
            in_alarm_date_length,
            in_category,
            in_category_length,
            in_summary,
            in_summary_length,
            in_location,
            in_location_length,
            in_xirmcluid,
            in_xirmcluid_length,
        )
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyname?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyName: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeytype?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyType: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeydescription?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyDescription: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeytimeiso?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyTimeISO: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeytime4byte?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyTime4Byte: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeytarget?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyTarget: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyhttp?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyHTTP: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeybody?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyBody: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyendofbody?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyEndOfBody: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeywho?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyWho: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyappparameters?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyAppParameters: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyauthorizationchallenge?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyAuthorizationChallenge: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyauthorizationresponse?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyAuthorizationResponse: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyobjectclass?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyObjectClass: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeycount?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyCount: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeylength?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyLength: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyconnectionid?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyConnectionID: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeybytesequence?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyByteSequence: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyunknownunicodetext?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUnknownUnicodeText: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyunknownbytesequence?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUnknownByteSequence: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyunknown1bytequantity?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUnknown1ByteQuantity: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyunknown4bytequantity?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUnknown4ByteQuantity: Option<&'static CFString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/iobluetooth/kobexheaderidkeyuserdefined?language=objc)
    #[cfg(feature = "objc2-core-foundation")]
    pub static kOBEXHeaderIDKeyUserDefined: Option<&'static CFString>;
}

/// Take a data blob and looks for OBEX headers.
///
/// Parameter `inData`: The data chunk with the headers you are interested in.
///
/// Parameter `inDataSize`: The size of the buffer you are passing in.
///
/// Returns: A CFDictionary with the headers found in the data blob inside it.
///
/// You should use this when your callback for PUTs, GETs, etc. give you a data chunk
/// and a size. Pass these params to this function and you will receive a dictionary
/// back full of the parse headers. You can use the CFDictionary calls to get objects
/// out of it, based on the header keys defined above. You are responsible for releasing
/// the CFDictionary returned to you.
/// Example usage:
/// <pre>
/// CFDictionaryRef   dictionary = OBEXGetHeaders( data, dataLength );
/// if( dictionary )
/// {
/// if( CFDictionaryGetCountOfKey( dictionary, kOBEXHeaderIDKeyName ) > 0 )
/// {
/// CFStringRef theStringRef;
///
/// theStringRef = (CFStringRef) CFDictionaryGetValue( dictionary, kOBEXHeaderIDKeyName );
/// if( theStringRef )
/// {
/// // Display it, use it as a filename, whatever.
/// }
/// }
///
/// if( CFDictionaryGetCountOfKey( dictionary, kOBEXHeaderIDKeyConnectionID ) > 0 )
/// {
/// CFDataRef theDataRef;
///
/// theDataRef = (CFDataRef) CFDictionaryGetValue( dictionary, kOBEXHeaderIDKeyConnectionID );
/// if( theDataRef )
/// {
/// // now we have data representing the connection ID.
/// }
/// }
///
/// CFRelease( dictionary );
/// }
/// </pre>
///
/// # Safety
///
/// `in_data` must be a valid pointer.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn OBEXGetHeaders(
    in_data: *const c_void,
    in_data_size: usize,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn OBEXGetHeaders(
            in_data: *const c_void,
            in_data_size: usize,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { OBEXGetHeaders(in_data, in_data_size) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

/// Converts a dictionary of headers to a data pointer, from which you can extract as bytes and pass to
/// the OBEX command/response functions.
///
/// Parameter `dictionaryOfHeaders`: dictionary that you have added headers to with the above OBEXAddXXXHeader functions.
///
/// Returns: Mutable data ref containing the bytes of all headers.
///
/// Returns a CFMutableDataRef containing all the header data found in the dictionary, formatted according to
/// the OBEX/IrMC spec. YOU MUST RELEASE IT when you are finished with it (ie. when the OBEX request is complete).
/// All OBEX-specification defined headers are supported and should be returned to the dictionary. Use the
/// keys defined above to get headers from dictionary. Example usage:
/// <pre>
/// Example usage:
///
/// CFMutableDictionaryRef    dictionary;
/// CFMutableDataRef        mGetHeadersDataRef;
/// uint8_t*                 headerDataPtr;
/// uint32_t                 headerDataLength;
///
/// dictionary = CFDictionaryCreateMutable( kCFAllocatorDefault, 0,
/// &kCFCopyStringDictionaryKeyCallBacks
/// ,
/// &kCFTypeDictionaryValueCallBacks
/// );
///
/// // Package up desired headers.
///
/// OBEXAddTypeHeader( CFSTR( "text/x-vCard" ), dictionary );
///
/// mGetHeadersDataRef = OBEXHeadersToBytes( dictionary );
///
/// headerDataPtr = CFDataGetBytePtr( mGetHeadersDataRef );
/// headerDataLength = CFDataGetLength( mGetHeadersDataRef );
///
/// // From here I can pass it to any OBEX command, such as OBEXPut...
/// </pre>
///
/// # Safety
///
/// - `dictionary_of_headers` generics must be of the correct type.
/// - `dictionary_of_headers` might not allow `None`.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn OBEXHeadersToBytes(
    dictionary_of_headers: Option<&CFDictionary>,
) -> Option<CFRetained<CFMutableData>> {
    extern "C-unwind" {
        fn OBEXHeadersToBytes(
            dictionary_of_headers: Option<&CFDictionary>,
        ) -> Option<NonNull<CFMutableData>>;
    }
    let ret = unsafe { OBEXHeadersToBytes(dictionary_of_headers) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `name`: name you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Name header - OBEX Spec, 2.2.2: (2-byte) Null terminated unicode string.
    ///
    /// # Safety
    ///
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddNameHeader(
        name: Option<&CFString>,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `description`: Description you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Description header - OBEX Spec, 2.2.6: (2-byte) Null terminated unicode string.
    ///
    /// # Safety
    ///
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddDescriptionHeader(
        description: Option<&CFString>,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `count`: Count value you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Count header - OBEX Spec, 2.2.1: 4 byte unsigned integer
    ///
    /// # Safety
    ///
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddCountHeader(count: u32, dict_ref: Option<&CFMutableDictionary>) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `time4Byte`: 4-byte time value you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Time4Byte headers - OBEX Spec, 2.2.5: 4 Bytes
    ///
    /// # Safety
    ///
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddTime4ByteHeader(
        time4_byte: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `length`: Value of Length header you want to add to the OBEX header dictionary.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Length header - OBEX Spec, 2.2.4: 4 byte unsigned integer
    ///
    /// # Safety
    ///
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddLengthHeader(length: u32, dict_ref: Option<&CFMutableDictionary>) -> OBEXError;
}

extern "C-unwind" {
    /// Add a CFStringRef to a dictionary of OBEXheaders.
    ///
    /// Parameter `type`: String containing the type of header to add.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Type header - OBEX Spec, 2.2.3: 1-byte Null terminated ascii string.
    ///
    /// # Safety
    ///
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddTypeHeader(
        r#type: Option<&CFString>,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: Time ISO 8601 header data, local times in format YYYYMMDDTHHMMSS and UTC in the format YYYYMMDDTHHMMSSZ.
    ///
    /// Parameter `inHeaderDataLength`: Length of header data.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// TimeISO header - OBEX Spec, 2.2.5: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddTimeISOHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes of data to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: Target header data.
    ///
    /// Parameter `inHeaderDataLength`: Length of Target header data.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Target header - OBEX Spec, 2.2.7: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddTargetHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes of data to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: HTTP header data.
    ///
    /// Parameter `inHeaderDataLength`: Length of HTTP header data.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// HTTP header - OBEX Spec, 2.2.8: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddHTTPHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

/// Add bytes of data to a dictionary of OBEXheaders.
///
/// Parameter `inHeaderData`: Body header data.
///
/// Parameter `inHeaderDataLength`: Length of Body header data.
///
/// Parameter `isEndOfBody`: Set this flag if you want an end of body header instead of a body header.
///
/// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
///
/// Returns: Error code, kOBEXSuccess (0) if success.
///
/// Body,EndOfBody headers - OBEX Spec, 2.2.9: Byte Sequence
///
/// # Safety
///
/// - `in_header_data` must be a valid pointer.
/// - `dict_ref` generics must be of the correct type.
/// - `dict_ref` might not allow `None`.
#[cfg(feature = "objc2-core-foundation")]
#[inline]
pub unsafe extern "C-unwind" fn OBEXAddBodyHeader(
    in_header_data: *const c_void,
    in_header_data_length: u32,
    is_end_of_body: bool,
    dict_ref: Option<&CFMutableDictionary>,
) -> OBEXError {
    extern "C-unwind" {
        fn OBEXAddBodyHeader(
            in_header_data: *const c_void,
            in_header_data_length: u32,
            is_end_of_body: Boolean,
            dict_ref: Option<&CFMutableDictionary>,
        ) -> OBEXError;
    }
    unsafe {
        OBEXAddBodyHeader(
            in_header_data,
            in_header_data_length,
            is_end_of_body as _,
            dict_ref,
        )
    }
}

extern "C-unwind" {
    /// Add bytes of data to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: Who header data.
    ///
    /// Parameter `inHeaderDataLength`: Length of Who header data.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Who headers - OBEX Spec, 2.2.10: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddWhoHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes representing a connection ID to a dictionary of OBEX headers.
    ///
    /// Parameter `inHeaderData`: Connection ID data. Should be 4 bytes in length only.
    ///
    /// Parameter `inHeaderDataLength`: Length of Connection ID data. This should ONLY be set to equal 4.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// ConnectionID headers - OBEX Spec, 2.2.10: Byte Sequence
    ///
    /// ** IMPORTANT NOTE: In bluetooth 1.0, using this function will allow you to pass in any value.
    /// You should not pass more than 4 bytes ever. In later releases, if the length
    /// passed is not 4, a kOBEXBadArgumentError error will be returned. ***
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddConnectionIDHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add bytes representing an application parameter to a dictionary of OBEX headers.
    ///
    /// Parameter `inHeaderData`: Application parameter data - should be tag/length/value triplets.
    ///
    /// Parameter `inHeaderDataLength`: Length of application parameter data.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Application Request/Response Parameter headers - OBEX Spec, 2.2.11: Byte Sequence
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddApplicationParameterHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a byte sequence header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the byte sequence header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in the byte sequence header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Byte Sequence header - OBEX Spec, 2.2.5: Byte sequence. One thing of important note here - since we
    /// don't know what Header Identifier and length you intend to use here, you MUST include your own
    /// identifier and length in the data you pass. Thus, your data must be in this format:
    /// <
    /// 1:HI>
    /// <
    /// 2:LENGTH>
    /// <n
    /// :(
    /// <TAG
    /// >
    /// <LENGTH
    /// >
    /// <VALUE
    /// >)>
    /// Also, note that LENGTH = (3 + n), (1 for HI, 2 for the 2 bytes of length information, plus your n bytes of custom data).
    /// Be careful here to not mess up these values, as it could adversely affect the ability of the remote-device's headers parser.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddByteSequenceHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add an object class header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the object class header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in the object class header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Object Class header - OBEX Spec, 2.2.15: Byte sequence.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddObjectClassHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add an authorization challenge header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the authorization challenge header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in authorization challenge header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Authorization Challenge header - OBEX Spec, 2.2.13: Authorization Challenge.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddAuthorizationChallengeHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add an authorization Response header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the authorization Response header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in authorization Response header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// Authorization Response header - OBEX Spec, 2.2.14: Authorization Response.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddAuthorizationResponseHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}

extern "C-unwind" {
    /// Add a user-defined custom header to a dictionary of OBEXheaders.
    ///
    /// Parameter `inHeaderData`: bytes you want to put in the user-defined header.
    ///
    /// Parameter `inHeaderDataLength`: length of the bytes you want to put in user-defined header.
    ///
    /// Parameter `dictRef`: dictionary you have allocated to hold the headers. Make sure it's mutable.
    ///
    /// Returns: Error code, kOBEXSuccess (0) if success.
    ///
    /// User Defined header - OBEX Spec, 2.2.20: User Defined Headers.
    ///
    /// # Safety
    ///
    /// - `in_header_data` must be a valid pointer.
    /// - `dict_ref` generics must be of the correct type.
    /// - `dict_ref` might not allow `None`.
    #[cfg(feature = "objc2-core-foundation")]
    pub fn OBEXAddUserDefinedHeader(
        in_header_data: *const c_void,
        in_header_data_length: u32,
        dict_ref: Option<&CFMutableDictionary>,
    ) -> OBEXError;
}
