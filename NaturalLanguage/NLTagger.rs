//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Constants for linguistic tagger enumeration specifying which tokens to omit and whether to join names.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NLTaggerOptions(pub NSUInteger);
bitflags::bitflags! {
    impl NLTaggerOptions: NSUInteger {
/// Omit tokens of type [`NLTagWord`](https://developer.apple.com/documentation/naturallanguage/nltag/word) (items considered to be words).
        #[doc(alias = "NLTaggerOmitWords")]
        const OmitWords = 1<<0;
/// Omit tokens of type [`NLTagPunctuation`](https://developer.apple.com/documentation/naturallanguage/nltag/punctuation) (all punctuation).
        #[doc(alias = "NLTaggerOmitPunctuation")]
        const OmitPunctuation = 1<<1;
/// Omit tokens of type [`NLTagWhitespace`](https://developer.apple.com/documentation/naturallanguage/nltag/whitespace) (whitespace of all sorts).
        #[doc(alias = "NLTaggerOmitWhitespace")]
        const OmitWhitespace = 1<<2;
/// Omit tokens of type [`NLTagOther`](https://developer.apple.com/documentation/naturallanguage/nltag/other) (non-linguistic items, such as symbols).
        #[doc(alias = "NLTaggerOmitOther")]
        const OmitOther = 1<<3;
/// Typically, multiple-word names will be returned as multiple tokens, following the standard tokenization practice of the tagger.
///
/// ## Discussion
///
/// If this option is set, then multiple-word names will be joined together and returned as a single token.
///
///
        #[doc(alias = "NLTaggerJoinNames")]
        const JoinNames = 1<<4;
/// Contractions will be returned as one token.
        #[doc(alias = "NLTaggerJoinContractions")]
        const JoinContractions = 1<<5;
    }
}

unsafe impl Encode for NLTaggerOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for NLTaggerOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The response to an asset request.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct NLTaggerAssetsResult(pub NSInteger);
impl NLTaggerAssetsResult {
    /// The asset is now available and loaded onto the device.
    #[doc(alias = "NLTaggerAssetsResultAvailable")]
    pub const Available: Self = Self(0);
    /// The asset is unavailable on the device.
    #[doc(alias = "NLTaggerAssetsResultNotAvailable")]
    pub const NotAvailable: Self = Self(1);
    /// The framework couldn’t load the asset due to an error.
    #[doc(alias = "NLTaggerAssetsResultError")]
    pub const Error: Self = Self(2);
}

unsafe impl Encode for NLTaggerAssetsResult {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for NLTaggerAssetsResult {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A tagger that analyzes natural language text.
    ///
    /// ## Overview
    ///
    /// [`NLTagger`](https://developer.apple.com/documentation/naturallanguage/nltagger) supports many different languages and scripts. Use it to segment natural language text into paragraph, sentence, or word units and to tag each unit with information like part of speech, lexical class, lemma, script, and language.
    ///
    /// When you create a linguistic tagger, you specify what kind of information you’re interested in by passing one or more [`NLTagScheme`](https://developer.apple.com/documentation/naturallanguage/nltagscheme) values. Set the [`string`](https://developer.apple.com/documentation/naturallanguage/nltagger/string) property to the natural language text you want to analyze, and the linguistic tagger processes it according to the specified tag schemes. You can then enumerate over the tags in a specified range, using the methods described in Enumerating linguistic tags, to get the information requested for a given scheme and unit.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Don’t use an instance of [`NLTagger`](https://developer.apple.com/documentation/naturallanguage/nltagger) simultaneously from multiple threads.
    ///
    ///
    ///
    /// </div>
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct NLTagger;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for NLTagger {}
);

impl NLTagger {
    extern_methods!(
        #[cfg(feature = "NLTagScheme")]
        #[unsafe(method(initWithTagSchemes:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithTagSchemes(
            this: Allocated<Self>,
            tag_schemes: &NSArray<NLTagScheme>,
        ) -> Retained<Self>;

        #[cfg(feature = "NLTagScheme")]
        #[unsafe(method(tagSchemes))]
        #[unsafe(method_family = none)]
        pub unsafe fn tagSchemes(&self) -> Retained<NSArray<NLTagScheme>>;

        #[unsafe(method(string))]
        #[unsafe(method_family = none)]
        pub unsafe fn string(&self) -> Option<Retained<NSString>>;

        /// Setter for [`string`][Self::string].
        #[unsafe(method(setString:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setString(&self, string: Option<&NSString>);

        #[cfg(all(
            feature = "NLLanguage",
            feature = "NLTagScheme",
            feature = "NLTokenizer"
        ))]
        #[unsafe(method(availableTagSchemesForUnit:language:))]
        #[unsafe(method_family = none)]
        pub unsafe fn availableTagSchemesForUnit_language(
            unit: NLTokenUnit,
            language: &NLLanguage,
        ) -> Retained<NSArray<NLTagScheme>>;

        #[cfg(feature = "NLTokenizer")]
        #[unsafe(method(tokenRangeAtIndex:unit:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tokenRangeAtIndex_unit(
            &self,
            character_index: NSUInteger,
            unit: NLTokenUnit,
        ) -> NSRange;

        #[cfg(feature = "NLTokenizer")]
        #[unsafe(method(tokenRangeForRange:unit:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tokenRangeForRange_unit(&self, range: NSRange, unit: NLTokenUnit) -> NSRange;

        #[cfg(feature = "NLLanguage")]
        #[unsafe(method(dominantLanguage))]
        #[unsafe(method_family = none)]
        pub unsafe fn dominantLanguage(&self) -> Option<Retained<NLLanguage>>;

        #[cfg(all(feature = "NLTagScheme", feature = "NLTokenizer", feature = "block2"))]
        #[unsafe(method(enumerateTagsInRange:unit:scheme:options:usingBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enumerateTagsInRange_unit_scheme_options_usingBlock(
            &self,
            range: NSRange,
            unit: NLTokenUnit,
            scheme: &NLTagScheme,
            options: NLTaggerOptions,
            block: &block2::DynBlock<dyn Fn(*mut NLTag, NSRange, NonNull<Bool>) + '_>,
        );

        #[cfg(all(feature = "NLTagScheme", feature = "NLTokenizer"))]
        /// # Safety
        ///
        /// `token_range` must be a valid pointer or null.
        #[unsafe(method(tagAtIndex:unit:scheme:tokenRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tagAtIndex_unit_scheme_tokenRange(
            &self,
            character_index: NSUInteger,
            unit: NLTokenUnit,
            scheme: &NLTagScheme,
            token_range: NSRangePointer,
        ) -> Option<Retained<NLTag>>;

        #[cfg(all(feature = "NLTagScheme", feature = "NLTokenizer"))]
        #[unsafe(method(tagsInRange:unit:scheme:options:tokenRanges:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tagsInRange_unit_scheme_options_tokenRanges(
            &self,
            range: NSRange,
            unit: NLTokenUnit,
            scheme: &NLTagScheme,
            options: NLTaggerOptions,
            token_ranges: Option<&mut Option<Retained<NSArray<NSValue>>>>,
        ) -> Retained<NSArray<NLTag>>;

        #[cfg(all(feature = "NLTagScheme", feature = "NLTokenizer"))]
        /// # Safety
        ///
        /// `token_range` must be a valid pointer or null.
        #[unsafe(method(tagHypothesesAtIndex:unit:scheme:maximumCount:tokenRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn tagHypothesesAtIndex_unit_scheme_maximumCount_tokenRange(
            &self,
            character_index: NSUInteger,
            unit: NLTokenUnit,
            scheme: &NLTagScheme,
            maximum_count: NSUInteger,
            token_range: NSRangePointer,
        ) -> Retained<NSDictionary<NLTag, NSNumber>>;

        #[cfg(feature = "NLLanguage")]
        #[unsafe(method(setLanguage:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLanguage_range(&self, language: &NLLanguage, range: NSRange);

        #[unsafe(method(setOrthography:range:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOrthography_range(&self, orthography: &NSOrthography, range: NSRange);

        #[cfg(all(feature = "NLModel", feature = "NLTagScheme"))]
        #[unsafe(method(setModels:forTagScheme:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setModels_forTagScheme(
            &self,
            models: &NSArray<NLModel>,
            tag_scheme: &NLTagScheme,
        );

        #[cfg(all(feature = "NLModel", feature = "NLTagScheme"))]
        #[unsafe(method(modelsForTagScheme:))]
        #[unsafe(method_family = none)]
        pub unsafe fn modelsForTagScheme(
            &self,
            tag_scheme: &NLTagScheme,
        ) -> Retained<NSArray<NLModel>>;

        #[cfg(all(feature = "NLGazetteer", feature = "NLTagScheme"))]
        #[unsafe(method(setGazetteers:forTagScheme:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGazetteers_forTagScheme(
            &self,
            gazetteers: &NSArray<NLGazetteer>,
            tag_scheme: &NLTagScheme,
        );

        #[cfg(all(feature = "NLGazetteer", feature = "NLTagScheme"))]
        #[unsafe(method(gazetteersForTagScheme:))]
        #[unsafe(method_family = none)]
        pub unsafe fn gazetteersForTagScheme(
            &self,
            tag_scheme: &NLTagScheme,
        ) -> Retained<NSArray<NLGazetteer>>;

        #[cfg(all(feature = "NLLanguage", feature = "NLTagScheme", feature = "block2"))]
        #[unsafe(method(requestAssetsForLanguage:tagScheme:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn requestAssetsForLanguage_tagScheme_completionHandler(
            language: &NLLanguage,
            tag_scheme: &NLTagScheme,
            completion_handler: &block2::DynBlock<dyn Fn(NLTaggerAssetsResult, *mut NSError)>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl NLTagger {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
