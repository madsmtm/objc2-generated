//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// The maximum timescale.
pub const kCMTimeMaxTimescale: c_uint = 0x7fffffff;
/// An integer time value.
/// Numerator of rational CMTime.
pub type CMTimeValue = i64;

/// An integer timescale.
///
/// ## Discussion
///
/// Timescales must be positive.
///
///
/// Denominator of rational CMTime.
///
/// Timescales must be positive.
/// Note: kCMTimeMaxTimescale is NOT a good choice of timescale for movie files.
/// (Recommended timescales for movie files range from 600 to 90000.)
pub type CMTimeScale = i32;

/// An epoch for a time.
///
/// ## Discussion
///
/// The epoch is typically `0`, but you can use a different value — for example to denote a particular iteration of a loop.
///
///
/// Epoch (eg, loop number) to which a CMTime refers.
pub type CMTimeEpoch = i64;

/// A structure that defines the flags for a time value.
/// Flag bits for a CMTime.
///
/// Allows simple clearing (eg. with calloc or memset) for initialization
/// of arrays of CMTime structs to "invalid". This flag must be set, even
/// if other flags are set as well.
///
///
///
///
/// "Implied value" flag (other struct fields are ignored).
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CMTimeFlags(pub u32);
bitflags::bitflags! {
    impl CMTimeFlags: u32 {
/// A flag that indicates a time is valid.
        #[doc(alias = "kCMTimeFlags_Valid")]
        const Valid = 1<<0;
/// A flag that indicates a previous time calculation rounded the result.
        #[doc(alias = "kCMTimeFlags_HasBeenRounded")]
        const HasBeenRounded = 1<<1;
/// A flag that indicates the time is positive infinity.
        #[doc(alias = "kCMTimeFlags_PositiveInfinity")]
        const PositiveInfinity = 1<<2;
/// A flag that indicates the time is negative infinity.
        #[doc(alias = "kCMTimeFlags_NegativeInfinity")]
        const NegativeInfinity = 1<<3;
/// A flag that indicates the time is indefinite.
        #[doc(alias = "kCMTimeFlags_Indefinite")]
        const Indefinite = 1<<4;
/// A flag that indicates the time is positive or negative infinity, or indefinite.
        #[doc(alias = "kCMTimeFlags_ImpliedValueFlagsMask")]
        const ImpliedValueFlagsMask = CMTimeFlags::PositiveInfinity.0|CMTimeFlags::NegativeInfinity.0|CMTimeFlags::Indefinite.0;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTimeFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTimeFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A structure that represents time.
///
/// ## Overview
///
/// Core Media represents time as a rational value, with a time value as the numerator and timescale as the denominator. The structure can represent a specific numeric time in the media timeline, and can also represent nonnumeric values like invalid and indefinite times or positive and negative infinity.
///
///
/// Rational time value represented as int64/int32.
#[repr(C, packed(4))]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CMTime {
    /// The value of the CMTime. value/timescale = seconds
    pub value: CMTimeValue,
    /// The timescale of the CMTime. value/timescale = seconds.
    pub timescale: CMTimeScale,
    /// The flags, eg. kCMTimeFlags_Valid, kCMTimeFlags_PositiveInfinity, etc.
    pub flags: CMTimeFlags,
    /// Differentiates between equal timestamps that are actually different because
    /// of looping, multi-item sequencing, etc.
    /// Will be used during comparison: greater epochs happen after lesser ones.
    /// Additions/subtraction is only possible within a single epoch,
    /// however, since epoch length may be unknown/variable
    pub epoch: CMTimeEpoch,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTime {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <CMTimeValue>::ENCODING,
            <CMTimeScale>::ENCODING,
            <CMTimeFlags>::ENCODING,
            <CMTimeEpoch>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTime {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A value that represents an invalid time.
    ///
    /// ## Discussion
    ///
    /// An invalid time has all of its fields set to `0`.
    ///
    /// Don’t test a time against this constant using (time == [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid)) because there are many times that are also invalid. Use [`CMTIME_IS_INVALID(_:)`](https://developer.apple.com/documentation/coremedia/cmtime_is_invalid(_:)) instead.
    ///
    ///
    pub static kCMTimeInvalid: CMTime;
}

extern "C" {
    /// A value that represents an indefinite time.
    ///
    /// ## Discussion
    ///
    /// Don’t test a time against this constant using (`time ==` [`kCMTimeIndefinite`](https://developer.apple.com/documentation/coremedia/cmtime/indefinite)) because there are many that are also indefinite. Use [`CMTIME_IS_INDEFINITE(_:)`](https://developer.apple.com/documentation/coremedia/cmtime_is_indefinite(_:)) instead.
    ///
    ///
    pub static kCMTimeIndefinite: CMTime;
}

extern "C" {
    /// A value that represents positive infinity.
    ///
    /// ## Discussion
    ///
    /// Don’t test a time against this constant using (time == [`kCMTimePositiveInfinity`](https://developer.apple.com/documentation/coremedia/cmtime/positiveinfinity)) because there are many times that are also positive infinity. Use [`CMTIME_IS_POSITIVEINFINITY(_:)`](https://developer.apple.com/documentation/coremedia/cmtime_is_positiveinfinity(_:)) instead.
    ///
    ///
    pub static kCMTimePositiveInfinity: CMTime;
}

extern "C" {
    /// A value that represents negative infinity.
    ///
    /// ## Discussion
    ///
    /// Don’t test a time against this constant using (time == [`kCMTimeNegativeInfinity`](https://developer.apple.com/documentation/coremedia/cmtime/negativeinfinity)) because there are many times that are also negative infinity. Use [`CMTIME_IS_NEGATIVEINFINITY(_:)`](https://developer.apple.com/documentation/coremedia/cmtime_is_negativeinfinity(_:)) instead.
    ///
    ///
    pub static kCMTimeNegativeInfinity: CMTime;
}

extern "C" {
    /// A value that represents time zero.
    ///
    /// ## Discussion
    ///
    /// Don’t test a time against this constant using (time == [`kCMTimeZero`](https://developer.apple.com/documentation/coremedia/cmtime/zero)) because there are many times that are also `0`. Use [`CMTimeCompare`](https://developer.apple.com/documentation/coremedia/cmtimecompare(_:_:)) instead.
    ///
    ///
    pub static kCMTimeZero: CMTime;
}

impl CMTime {
    /// Creates a time with a value and timescale.
    ///
    /// Parameters:
    /// - value: An integer time value.
    ///
    /// - timescale: An integer timescale.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure.
    ///
    ///
    /// Make a valid CMTime with value and timescale.  Epoch is implied to be 0.
    ///
    /// Returns: The resulting CMTime.
    #[doc(alias = "CMTimeMake")]
    #[inline]
    pub unsafe fn new(value: i64, timescale: i32) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMake(value: i64, timescale: i32) -> CMTime;
        }
        unsafe { CMTimeMake(value, timescale) }
    }

    /// Creates a time with a value, timescale, and epoch.
    ///
    /// Parameters:
    /// - value: An integer time value.
    ///
    /// - timescale: An integer timescale value.
    ///
    /// - epoch: An integer epoch value.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure.
    ///
    ///
    /// Make a valid CMTime with value, scale and epoch.
    ///
    /// Returns: The resulting CMTime.
    #[doc(alias = "CMTimeMakeWithEpoch")]
    #[inline]
    pub unsafe fn with_epoch(value: i64, timescale: i32, epoch: i64) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMakeWithEpoch(value: i64, timescale: i32, epoch: i64) -> CMTime;
        }
        unsafe { CMTimeMakeWithEpoch(value, timescale, epoch) }
    }

    /// Creates a time that represents a number of seconds in a preferred timescale.
    ///
    /// Parameters:
    /// - seconds: The number of seconds to represent.
    ///
    /// - preferredTimescale: The preferred timescale of the time.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Specify a positive preferred timescale value, or the resulting time is [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid).
    ///
    /// If you specify a value that causes an overflow, the system repeatedly halves the value until the overflow goes away or the timescale equals `1`. If the value still overflows at that point, the system sets the value to positive or negative infinity.
    ///
    /// Query the [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) property value to determine whether the value, when converted back to seconds, precisely matches the original seconds value.
    ///
    ///
    /// Make a CMTime from a Float64 number of seconds, and a preferred timescale.
    ///
    /// The epoch of the result will be zero.  If preferredTimescale is
    /// <
    /// = 0, the result
    /// will be an invalid CMTime.  If the preferred timescale will cause an overflow, the
    /// timescale will be halved repeatedly until the overflow goes away, or the timescale
    /// is 1.  If it still overflows at that point, the result will be +/- infinity.  The
    /// kCMTimeFlags_HasBeenRounded flag will be set if the result, when converted back to
    /// seconds, is not exactly equal to the original seconds value.
    ///
    /// Returns: The resulting CMTime.
    #[doc(alias = "CMTimeMakeWithSeconds")]
    #[inline]
    pub unsafe fn with_seconds(seconds: f64, preferred_timescale: i32) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMakeWithSeconds(seconds: f64, preferred_timescale: i32) -> CMTime;
        }
        unsafe { CMTimeMakeWithSeconds(seconds, preferred_timescale) }
    }

    /// Returns a representation of the time in seconds.
    ///
    /// Parameters:
    /// - time: A time value for which to retrieve seconds.
    ///
    ///
    /// ## Return Value
    ///
    /// The time in seconds.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the time is [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid) or [`kCMTimeIndefinite`](https://developer.apple.com/documentation/coremedia/cmtime/indefinite), the result is [`nan`](https://developer.apple.com/documentation/swift/double/nan).
    ///
    /// If the time is infinite, the result is positive or negative infinity.
    ///
    /// If the time is numeric, it ignores the epoch, and returns the result of `time.value / time.timescale`. It performs the division in `Float64`, so the fraction isn’t lost in the returned result.
    ///
    ///
    /// Converts a CMTime to seconds.
    ///
    /// If the CMTime is invalid or indefinite, NAN is returned.  If the CMTime is infinite, +/- __inf()
    /// is returned.  If the CMTime is numeric, epoch is ignored, and time.value / time.timescale is
    /// returned.  The division is done in Float64, so the fraction is not lost in the returned result.
    ///
    /// Returns: The resulting Float64 number of seconds.
    #[doc(alias = "CMTimeGetSeconds")]
    #[inline]
    pub unsafe fn seconds(self) -> f64 {
        extern "C-unwind" {
            fn CMTimeGetSeconds(time: CMTime) -> f64;
        }
        unsafe { CMTimeGetSeconds(self) }
    }
}

/// An enumeration of rounding methods to use when performing time calculations.
/// Rounding method to use when computing time.value during timescale conversions.
///
/// away from 0 if abs(fraction) is >= 0.5.
///
///
///
///
/// from larger to smaller scale (ie. from more precision to
/// less precision), but use
/// kCMTimeRoundingMethod_RoundAwayFromZero if converting
/// from smaller to larger scale (ie. from less precision to
/// more precision). Also, never round a negative number down
/// to 0; always return the smallest magnitude negative
/// CMTime in this case (-1/newTimescale).
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CMTimeRoundingMethod(pub u32);
impl CMTimeRoundingMethod {
    /// Rounds half away from zero.
    ///
    /// ## Discussion
    ///
    /// This method rounds toward zero if the absolute value is less than `0.5`, and away from `0` if it’s greater than or equal to `0.5`.
    ///
    /// This is the default rounding method.
    ///
    ///
    #[doc(alias = "kCMTimeRoundingMethod_RoundHalfAwayFromZero")]
    pub const RoundHalfAwayFromZero: Self = Self(1);
    /// Rounds toward zero.
    ///
    /// ## Discussion
    ///
    /// This method rounds toward zero if the fraction isn’t equal to `0`.
    ///
    ///
    #[doc(alias = "kCMTimeRoundingMethod_RoundTowardZero")]
    pub const RoundTowardZero: Self = Self(2);
    /// Rounds away from zero.
    ///
    /// ## Discussion
    ///
    /// This method rounds away from zero if the absolute value of the fraction is greater than `0`.
    ///
    ///
    #[doc(alias = "kCMTimeRoundingMethod_RoundAwayFromZero")]
    pub const RoundAwayFromZero: Self = Self(3);
    /// Rounds using the QuickTime method.
    ///
    /// ## Discussion
    ///
    /// This method uses [`kCMTimeRoundingMethod_RoundTowardZero`](https://developer.apple.com/documentation/coremedia/cmtimeroundingmethod/roundtowardzero) if converting from larger to smaller scale (more precision to less precision), but uses [`kCMTimeRoundingMethod_RoundAwayFromZero`](https://developer.apple.com/documentation/coremedia/cmtimeroundingmethod/roundawayfromzero) if converting from smaller to larger scale (less precision to more precision).
    ///
    /// This method never rounds a negative number down to `0`, but instead returns the smallest magnitude negative time (`-1 / newTimescale`).
    ///
    ///
    #[doc(alias = "kCMTimeRoundingMethod_QuickTime")]
    pub const QuickTime: Self = Self(4);
    /// Rounds toward positive infinity.
    ///
    /// ## Discussion
    ///
    /// This method rounds toward [`kCMTimePositiveInfinity`](https://developer.apple.com/documentation/coremedia/cmtime/positiveinfinity) if the fraction isn’t equal to `0`.
    ///
    ///
    #[doc(alias = "kCMTimeRoundingMethod_RoundTowardPositiveInfinity")]
    pub const RoundTowardPositiveInfinity: Self = Self(5);
    /// Rounds toward negative infinity.
    ///
    /// ## Discussion
    ///
    /// This method rounds toward [`kCMTimeNegativeInfinity`](https://developer.apple.com/documentation/coremedia/cmtime/negativeinfinity) if the fraction isn’t equal to `0`.
    ///
    ///
    #[doc(alias = "kCMTimeRoundingMethod_RoundTowardNegativeInfinity")]
    pub const RoundTowardNegativeInfinity: Self = Self(6);
    /// The default rounding method.
    ///
    /// ## Discussion
    ///
    /// This value is equal to [`kCMTimeRoundingMethod_RoundHalfAwayFromZero`](https://developer.apple.com/documentation/coremedia/cmtimeroundingmethod/roundhalfawayfromzero).
    ///
    ///
    #[doc(alias = "kCMTimeRoundingMethod_Default")]
    pub const Default: Self = Self(CMTimeRoundingMethod::RoundHalfAwayFromZero.0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTimeRoundingMethod {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTimeRoundingMethod {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CMTime {
    /// Converts the source time to a new timescale using the specified rounding method.
    ///
    /// Parameters:
    /// - time: The time to convert.
    ///
    /// - newTimescale: The timescale to use for the converted time.
    ///
    /// - method: The rounding method to apply.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure that represents the time in a new timescale.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If this operation needs to round the value, it sets the resulting time’s [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) flag. If the source time is nonnumeric (infinite, indefinite, or invalid), the result is also nonnumeric.
    ///
    ///
    /// Returns a new CMTime containing the source CMTime converted to a new timescale (rounding as requested).
    ///
    /// If the value needs to be rounded, the kCMTimeFlags_HasBeenRounded flag will be set.
    /// See definition of CMTimeRoundingMethod for a discussion of the various rounding methods available. If
    /// the source time is non-numeric (ie. infinite, indefinite, invalid), the result will be similarly non-numeric.
    ///
    /// Returns: The converted result CMTime.
    #[doc(alias = "CMTimeConvertScale")]
    #[inline]
    pub unsafe fn convert_scale(self, new_timescale: i32, method: CMTimeRoundingMethod) -> CMTime {
        extern "C-unwind" {
            fn CMTimeConvertScale(
                time: CMTime,
                new_timescale: i32,
                method: CMTimeRoundingMethod,
            ) -> CMTime;
        }
        unsafe { CMTimeConvertScale(self, new_timescale, method) }
    }

    /// Returns the sum of two times.
    ///
    /// Parameters:
    /// - lhs: A time value.
    ///
    /// - rhs: A second time value.
    ///
    ///
    /// ## Return Value
    ///
    /// A time value that represents the result of the operation.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If both operands have the same timescale, the timescale of the result is the same. If the operands have different timescales, the timescale of the result is the least common multiple of the operands’ timescales. If that value is greater than [`kCMTimeMaxTimescale`](https://developer.apple.com/documentation/coremedia/kcmtimemaxtimescale), the system sets the timescale to [`kCMTimeMaxTimescale`](https://developer.apple.com/documentation/coremedia/kcmtimemaxtimescale) and uses the default rounding method to convert the result to this timescale.
    ///
    /// If the value of the result overflows, the system repeatedly halves its timescale until it no longer overflows, and uses the default rounding to convert the result to this timescale. If the result’s value still overflows when its timescale is `1`, the system sets the result’s timescale to positive or negative infinity, depending on the direction of the overflow. If any rounding occurs, or if either operand has its [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) flag set, the system sets the result’s [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) flag.
    ///
    /// If either of the operands is [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid), the result is [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid).
    ///
    /// If the operands are valid, but one is infinite, the result is infinite. If the operands are valid, and both are infinite, the results are as follows:
    ///
    /// - +infinity + +infinity == +infinity
    ///
    /// - -infinity + -infinity == -infinity
    ///
    /// - +infinity + -infinity == invalid
    ///
    /// - -infinity + +infinity == invalid
    ///
    /// If the operands are valid, not infinite, and either or both is [`kCMTimeIndefinite`](https://developer.apple.com/documentation/coremedia/cmtime/indefinite), the result is [`kCMTimeIndefinite`](https://developer.apple.com/documentation/coremedia/cmtime/indefinite).
    ///
    /// If the two operands are numeric, but have different nonzero epochs, the result is [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid). If both have the same nonzero epoch, the result is epoch zero. You can’t add or subtract times that have different epochs, because the epoch length is unknown. The system considers times in epoch zero to be durations, so you can add them to times in other epochs. You can compare times in different epochs, however, because numerically greater epochs always occur after numerically lesser epochs.
    ///
    ///
    /// Returns the sum of two CMTimes.
    ///
    /// If the operands both have the same timescale, the timescale of the result will be the same as
    /// the operands' timescale.  If the operands have different timescales, the timescale of the result
    /// will be the least common multiple of the operands' timescales.  If that LCM timescale is
    /// greater than kCMTimeMaxTimescale, the result timescale will be kCMTimeMaxTimescale,
    /// and default rounding will be applied when converting the result to this timescale.
    ///
    /// If the result value overflows, the result timescale will be repeatedly halved until the result
    /// value no longer overflows.  Again, default rounding will be applied when converting the
    /// result to this timescale.  If the result value still overflows when timescale == 1, then the
    /// result will be either positive or negative infinity, depending on the direction of the
    /// overflow.
    ///
    /// If any rounding occurs for any reason, the result's kCMTimeFlags_HasBeenRounded flag will be
    /// set.  This flag will also be set if either of the operands has kCMTimeFlags_HasBeenRounded set.
    ///
    /// If either of the operands is invalid, the result will be invalid.
    ///
    /// If the operands are valid, but just one operand is infinite, the result will be similarly
    /// infinite. If the operands are valid, and both are infinite, the results will be as follows:
    /// <ul>
    /// +infinity + +infinity == +infinity
    /// <li>
    /// -infinity + -infinity == -infinity
    /// <li>
    /// +infinity + -infinity == invalid
    /// <li>
    /// -infinity + +infinity == invalid
    /// </ul>
    /// If the operands are valid, not infinite, and either or both is indefinite, the result
    /// will be indefinite.
    ///
    /// If the two operands are numeric (ie. valid, not infinite, not indefinite), but have
    /// different nonzero epochs, the result will be invalid.  If they have the same nonzero
    /// epoch, the result will have epoch zero (a duration).  Times in different epochs
    /// cannot be added or subtracted, because epoch length is unknown.  Times in epoch zero
    /// are considered to be durations and can be added to times in other epochs.
    /// Times in different epochs can be compared, however, because numerically greater
    /// epochs always occur after numerically lesser epochs.
    ///
    /// Returns: The sum of the two CMTimes (lhs + rhs).
    #[doc(alias = "CMTimeAdd")]
    #[inline]
    pub unsafe fn add(self, rhs: CMTime) -> CMTime {
        extern "C-unwind" {
            fn CMTimeAdd(lhs: CMTime, rhs: CMTime) -> CMTime;
        }
        unsafe { CMTimeAdd(self, rhs) }
    }

    /// Returns the difference between two times.
    ///
    /// Parameters:
    /// - lhs: A time value.
    ///
    /// - rhs: A time value to subtract from the minuend.
    ///
    ///
    /// ## Return Value
    ///
    /// A time value that represents the result of the operation.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the operands have the same timescale, the timescale of the result is the same as the operands’ timescale. If the operands have different timescales, the timescale of the result is the least common multiple of the operands’ timescales. If that LCM timescale is greater than [`kCMTimeMaxTimescale`](https://developer.apple.com/documentation/coremedia/kcmtimemaxtimescale), the result timescale is [`kCMTimeMaxTimescale`](https://developer.apple.com/documentation/coremedia/kcmtimemaxtimescale), and the system applies the default rounding when it converts the result to this timescale.
    ///
    /// If the value of the result overflows, the system repeatedly halves its timescale until it no longer overflows, and uses the default rounding to convert the result to this timescale. If the result’s value still overflows when its timescale is `1`, the system sets the result’s timescale to positive or negative infinity, depending on the direction of the overflow. If any rounding occurs, or if either operand has its [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) flag set, the system sets the result’s [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) flag.
    ///
    /// If either operand is invalid, the result is invalid. If the operands are valid, but one is infinite, the result is infinite. If the operands are valid, and both are infinite, the results are as follows:
    ///
    /// - +infinity - +infinity == invalid
    ///
    /// - -infinity - -infinity == invalid
    ///
    /// - +infinity - -infinity == +infinity
    ///
    /// - -infinity + +infinity == invalid
    ///
    /// If the operands are valid, not infinite, and either or both is [`kCMTimeIndefinite`](https://developer.apple.com/documentation/coremedia/cmtime/indefinite), the result is [`kCMTimeIndefinite`](https://developer.apple.com/documentation/coremedia/cmtime/indefinite).
    ///
    /// If the two operands are numeric, but have different nonzero epochs, the result is [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid). If both have the same nonzero epoch, the result is epoch zero. You can’t add or subtract times that have different epochs, because the epoch length is unknown. The system considers times in epoch zero to be durations, so you can add them to times in other epochs. You can compare times in different epochs, however, because numerically greater epochs always occur after numerically lesser epochs.
    ///
    ///
    /// Returns the difference of two CMTimes.
    ///
    /// If the operands both have the same timescale, the timescale of the result will be the same as
    /// the operands' timescale.  If the operands have different timescales, the timescale of the result
    /// will be the least common multiple of the operands' timescales.  If that LCM timescale is
    /// greater than kCMTimeMaxTimescale, the result timescale will be kCMTimeMaxTimescale,
    /// and default rounding will be applied when converting the result to this timescale.
    ///
    /// If the result value overflows, the result timescale will be repeatedly halved until the result
    /// value no longer overflows.  Again, default rounding will be applied when converting the
    /// result to this timescale.  If the result value still overflows when timescale == 1, then the
    /// result will be either positive or negative infinity, depending on the direction of the
    /// overflow.
    ///
    /// If any rounding occurs for any reason, the result's kCMTimeFlags_HasBeenRounded flag will be
    /// set.  This flag will also be set if either of the operands has kCMTimeFlags_HasBeenRounded set.
    ///
    /// If either of the operands is invalid, the result will be invalid.
    ///
    /// If the operands are valid, but just one operand is infinite, the result will be similarly
    /// infinite. If the operands are valid, and both are infinite, the results will be as follows:
    /// <ul>
    /// +infinity - +infinity == invalid
    /// <li>
    /// -infinity - -infinity == invalid
    /// <li>
    /// +infinity - -infinity == +infinity
    /// <li>
    /// -infinity - +infinity == -infinity
    /// </ul>
    /// If the operands are valid, not infinite, and either or both is indefinite, the result
    /// will be indefinite.
    ///
    /// If the two operands are numeric (ie. valid, not infinite, not indefinite), but have
    /// different nonzero epochs, the result will be invalid.  If they have the same nonzero
    /// epoch, the result will have epoch zero (a duration).  Times in different epochs
    /// cannot be added or subtracted, because epoch length is unknown.  Times in epoch zero
    /// are considered to be durations and can be subtracted from times in other epochs.
    /// Times in different epochs can be compared, however, because numerically greater
    /// epochs always occur after numerically lesser epochs.
    ///
    /// Returns: The difference of the two CMTimes (lhs - rhs).
    #[doc(alias = "CMTimeSubtract")]
    #[inline]
    pub unsafe fn subtract(self, rhs: CMTime) -> CMTime {
        extern "C-unwind" {
            fn CMTimeSubtract(lhs: CMTime, rhs: CMTime) -> CMTime;
        }
        unsafe { CMTimeSubtract(self, rhs) }
    }

    /// Returns the result of multiplying a time by an integer multiplier.
    ///
    /// Parameters:
    /// - time: A time value to multiply.
    ///
    /// - multiplier: A 32-bit integer multiplier value.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure that represents the product of the multiplied time.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The result has the same timescale as the time argument. If the result overflows, the system repeatedly halves the result until no overflow occurs. The system applies the default rounding method when converting the result to this timescale. If the result’s value still overflows when its timescale is `1`, then the result is positive or negative infinity, depending on the direction of the overflow. If rounding occurs for any reason, the system sets the result’s [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) flag. It also sets this flag if the time argument has [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) set. If the `time` operand is invalid, the result is invalid. If the time operand is valid but infinite, the result is infinite and of an appropriate sign, based on the signs of both operands. If the time operand is valid, but indefinite, the result is indefinite.
    ///
    ///
    /// Returns the product of a CMTime and a 32-bit integer.
    ///
    /// The result will have the same timescale as the CMTime operand. If the result value overflows,
    /// the result timescale will be repeatedly halved until the result value no longer overflows.
    /// Again, default rounding will be applied when converting the result to this timescale.  If the
    /// result value still overflows when timescale == 1, then the result will be either positive or
    /// negative infinity, depending on the direction of the overflow.
    ///
    /// If any rounding occurs for any reason, the result's kCMTimeFlags_HasBeenRounded flag will be
    /// set.  This flag will also be set if the CMTime operand has kCMTimeFlags_HasBeenRounded set.
    ///
    /// If the CMTime operand is invalid, the result will be invalid.
    ///
    /// If the CMTime operand is valid, but infinite, the result will be infinite, and of an appropriate sign, given
    /// the signs of both operands.
    ///
    /// If the CMTime operand is valid, but indefinite, the result will be indefinite.
    ///
    ///
    /// Returns: The product of the CMTime and the 32-bit integer.
    #[doc(alias = "CMTimeMultiply")]
    #[inline]
    pub unsafe fn multiply(self, multiplier: i32) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMultiply(time: CMTime, multiplier: i32) -> CMTime;
        }
        unsafe { CMTimeMultiply(self, multiplier) }
    }

    /// Returns the result of multiplying a time by a floating-point multiplier.
    ///
    /// Parameters:
    /// - time: A time value to multiply.
    ///
    /// - multiplier: A 64-bit floating-point multiplier value.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure that represents the product of the multiplied time.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The result has the same timescale as the passed time argument. If the result’s timescale is less than `65536`, the system repeatedly doubles it until it’s at least that value. If the result overflows, the system repeatedly halves the result until no overflow occurs. The system applies the default rounding method when converting the result to this timescale. If the result’s value still overflows when its timescale is `1`, then the result is positive or negative infinity, depending on the direction of the overflow. If rounding occurs for any reason, the system sets the result’s [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) flag. It also sets this flag if the time argument has [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) set. If the `time` operand is invalid, the result is invalid. If the time operand is valid but infinite, the result is infinite and of an appropriate sign, based on the signs of both operands. If the time operand is valid, but indefinite, the result is indefinite.
    ///
    ///
    /// Returns the product of a CMTime and a 64-bit float.
    ///
    /// The result will initially have the same timescale as the CMTime operand.
    /// If the result timescale is less than 65536, it will be repeatedly doubled until it is at least 65536.
    /// If the result value overflows, the result timescale will be repeatedly halved until the
    /// result value no longer overflows.
    /// Again, default rounding will be applied when converting the result to this timescale.  If the
    /// result value still overflows when timescale == 1, then the result will be either positive or
    /// negative infinity, depending on the direction of the overflow.
    ///
    /// If any rounding occurs for any reason, the result's kCMTimeFlags_HasBeenRounded flag will be
    /// set.  This flag will also be set if the CMTime operand has kCMTimeFlags_HasBeenRounded set.
    ///
    /// If the CMTime operand is invalid, the result will be invalid.
    ///
    /// If the CMTime operand is valid, but infinite, the result will be infinite, and of an appropriate sign, given
    /// the signs of both operands.
    ///
    /// If the CMTime operand is valid, but indefinite, the result will be indefinite.
    ///
    ///
    /// Returns: The product of the CMTime and the 64-bit float.
    #[doc(alias = "CMTimeMultiplyByFloat64")]
    #[inline]
    pub unsafe fn multiply_by_float64(self, multiplier: f64) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMultiplyByFloat64(time: CMTime, multiplier: f64) -> CMTime;
        }
        unsafe { CMTimeMultiplyByFloat64(self, multiplier) }
    }

    /// Returns the result of multiplying a time by an integer multiplier, and then dividing the result by the divisor.
    ///
    /// Parameters:
    /// - time: A time value to multiple by a ratio.
    ///
    /// - multiplier: The value by which to multiply.
    ///
    /// - divisor: The value by which to divide.
    ///
    ///
    /// ## Return Value
    ///
    /// A value equal to `(time * multiplier) / divisor`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method preserves the exact rational value, unless it causes an overflow. If an overflow occurs, the system chooses a new timescale to minimize the rounding error and applies the default rounding method when converting the result to this timescale. If the result’s value still overflows when its timescale is `1`, the system sets the result to positive or negative infinity, depending on the direction of the overflow.
    ///
    /// If rounding occurs for any reason, the system sets the result’s [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) flag. It also sets this flag if the time argument has its [`kCMTimeFlags_HasBeenRounded`](https://developer.apple.com/documentation/coremedia/cmtimeflags/hasbeenrounded) flag set.
    ///
    /// If the time value or timescale is zero, the result is [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid). If only the timescale is zero, the result is positive or negative infinity, depending on the signs of the other arguments.
    ///
    /// If time is invalid, the result is [`kCMTimeInvalid`](https://developer.apple.com/documentation/coremedia/cmtime/invalid). If time is infinite, the result is similarly infinite. If time is indefinite, the result is indefinite.
    ///
    ///
    /// Returns the result of multiplying a CMTime by an integer, then dividing by another integer.
    ///
    /// The exact rational value will be preserved, if possible without overflow.  If an overflow
    /// would occur, a new timescale will be chosen so as to minimize the rounding error.
    /// Default rounding will be applied when converting the result to this timescale.  If the
    /// result value still overflows when timescale == 1, then the result will be either positive
    /// or negative infinity, depending on the direction of the overflow.
    ///
    /// If any rounding occurs for any reason, the result's kCMTimeFlags_HasBeenRounded flag will be
    /// set.  This flag will also be set if the CMTime operand has kCMTimeFlags_HasBeenRounded set.
    ///
    /// If the denominator, and either the time or the numerator, are zero, the result will be
    /// kCMTimeInvalid.  If only the denominator is zero, the result will be either kCMTimePositiveInfinity
    /// or kCMTimeNegativeInfinity, depending on the signs of the other arguments.
    ///
    /// If time is invalid, the result will be invalid. If time is infinite, the result will be
    /// similarly infinite. If time is indefinite, the result will be indefinite.
    ///
    ///
    /// Returns: (time * multiplier) / divisor
    #[doc(alias = "CMTimeMultiplyByRatio")]
    #[inline]
    pub unsafe fn multiply_by_ratio(self, multiplier: i32, divisor: i32) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMultiplyByRatio(time: CMTime, multiplier: i32, divisor: i32) -> CMTime;
        }
        unsafe { CMTimeMultiplyByRatio(self, multiplier, divisor) }
    }

    /// Returns the numerical relationship of two times.
    ///
    /// Parameters:
    /// - time1: A time to compare.
    ///
    /// - time2: Another time to compare.
    ///
    ///
    /// ## Return Value
    ///
    /// A numeric value that indicates the relative order of the times.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This method returns the following values depending on the relationship of the time values:
    ///
    /// - If `time1` is less than `time2`, it returns `-1`.
    ///
    /// - If `time1` is greater than `time2`, it returns `1`.
    ///
    /// - If `time1` and `time2` are equal, it returns `0`.
    ///
    /// To sort numeric and nonnumeric times consistently, this call uses the following sort rules:
    ///
    /// `-infinity < all finite values < indefinite < +infinity < invalid`
    ///
    /// Times with numerically larger epochs are greater than those with smaller epochs. ``
    ///
    /// <div class="warning">
    ///
    /// ### Tip
    ///  You can also use the [`CMTIME_COMPARE_INLINE`](https://developer.apple.com/documentation/coremedia/cmtime_compare_inline) macro to compare times. This macro results in a more readable expression because it puts the comparison operator between the operands.
    ///
    ///
    ///
    /// </div>
    ///
    /// Returns the numerical relationship (-1 = less than, 1 = greater than, 0 = equal) of two CMTimes.
    ///
    /// If the two CMTimes are numeric (ie. not invalid, infinite, or indefinite), and have
    /// different epochs, it is considered that times in numerically larger epochs are always
    /// greater than times in numerically smaller epochs.
    ///
    /// Since this routine will be used to sort lists by time, it needs to give all values
    /// (even invalid and indefinite ones) a strict ordering to guarantee that sort algorithms
    /// terminate safely. The order chosen is somewhat arbitrary:
    ///
    /// -infinity
    /// <
    /// all finite values
    /// <
    /// indefinite
    /// <
    /// +infinity
    /// <
    /// invalid
    ///
    /// Invalid CMTimes are considered to be equal to other invalid CMTimes, and greater than
    /// any other CMTime. Positive infinity is considered to be less than any invalid CMTime,
    /// equal to itself, and greater than any other CMTime. An indefinite CMTime is considered
    /// to be less than any invalid CMTime, less than positive infinity, equal to itself,
    /// and greater than any other CMTime.  Negative infinity is considered to be equal to itself,
    /// and less than any other CMTime.
    ///
    /// -1 is returned if time1 is less than time2. 0 is returned if they
    /// are equal. 1 is returned if time1 is greater than time2.
    ///
    /// Returns: The numerical relationship of the two CMTimes (-1 = less than, 1 = greater than, 0 = equal).
    #[doc(alias = "CMTimeCompare")]
    #[inline]
    pub unsafe fn compare(self, time2: CMTime) -> i32 {
        extern "C-unwind" {
            fn CMTimeCompare(time1: CMTime, time2: CMTime) -> i32;
        }
        unsafe { CMTimeCompare(self, time2) }
    }

    /// Returns the lesser of two time values.
    ///
    /// Parameters:
    /// - time1: A time value.
    ///
    /// - time2: Another time value.
    ///
    ///
    /// ## Return Value
    ///
    /// The lesser of the two times.
    ///
    ///
    /// Returns the lesser of two CMTimes (as defined by CMTimeCompare).
    ///
    /// Returns: The lesser of the two CMTimes.
    #[doc(alias = "CMTimeMinimum")]
    #[inline]
    pub unsafe fn minimum(self, time2: CMTime) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMinimum(time1: CMTime, time2: CMTime) -> CMTime;
        }
        unsafe { CMTimeMinimum(self, time2) }
    }

    /// Returns the greater of two time values.
    ///
    /// Parameters:
    /// - time1: A time value.
    ///
    /// - time2: Another time value.
    ///
    ///
    /// ## Return Value
    ///
    /// The greater of the two times.
    ///
    ///
    /// Returns the greater of two CMTimes (as defined by CMTimeCompare).
    ///
    /// Returns: The greater of the two CMTimes.
    #[doc(alias = "CMTimeMaximum")]
    #[inline]
    pub unsafe fn maximum(self, time2: CMTime) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMaximum(time1: CMTime, time2: CMTime) -> CMTime;
        }
        unsafe { CMTimeMaximum(self, time2) }
    }

    /// Returns the absolute value of a time.
    ///
    /// Parameters:
    /// - time: A time structure.
    ///
    ///
    /// ## Return Value
    ///
    /// The time value, but with its sign inverted, if necessary.
    ///
    ///
    /// Returns the absolute value of a CMTime.
    ///
    /// Returns: Same as the argument time, with sign inverted if negative.
    #[doc(alias = "CMTimeAbsoluteValue")]
    #[inline]
    pub unsafe fn absolute_value(self) -> CMTime {
        extern "C-unwind" {
            fn CMTimeAbsoluteValue(time: CMTime) -> CMTime;
        }
        unsafe { CMTimeAbsoluteValue(self) }
    }

    /// Creates a dictionary representation of the time.
    ///
    /// Parameters:
    /// - time: A time from which to create a dictionary.
    ///
    /// - allocator: An allocator with which to create the dictionary. Pass [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the default allocator.
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary representation of the time.
    ///
    ///
    /// Returns a CFDictionary version of a CMTime.
    ///
    /// This is useful when putting CMTimes in CF container types.
    ///
    /// Returns: A CFDictionary version of the CMTime.
    #[doc(alias = "CMTimeCopyAsDictionary")]
    #[inline]
    pub unsafe fn as_dictionary(
        self,
        allocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CMTimeCopyAsDictionary(
                time: CMTime,
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CMTimeCopyAsDictionary(self, allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a time from a dictionary representation of its fields.
    ///
    /// Parameters:
    /// - dictionaryRepresentation: A dictionary created from a call to [`CMTimeCopyAsDictionary`](https://developer.apple.com/documentation/coremedia/cmtimecopyasdictionary(_:allocator:)).
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For keys in the dictionary, see [Dictionary Keys](https://developer.apple.com/documentation/coremedia/cmtime-dictionary-keys).
    ///
    ///
    /// Reconstitutes a CMTime struct from a CFDictionary previously created by CMTimeCopyAsDictionary.
    ///
    /// This is useful when getting CMTimes from CF container types.  If the CFDictionary does not
    /// have the requisite keyed values, an invalid time is returned.
    ///
    /// Returns: The created CMTime.
    ///
    /// # Safety
    ///
    /// - `dictionary_representation` generic must be of the correct type.
    /// - `dictionary_representation` generic must be of the correct type.
    #[doc(alias = "CMTimeMakeFromDictionary")]
    #[inline]
    pub unsafe fn from_dictionary(dictionary_representation: Option<&CFDictionary>) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMakeFromDictionary(dictionary_representation: Option<&CFDictionary>)
                -> CMTime;
        }
        unsafe { CMTimeMakeFromDictionary(dictionary_representation) }
    }
}

extern "C" {
    /// A dictionary key for a time value.
    /// CFDictionary key for value field of CMTime (CFNumber containing int64_t)
    pub static kCMTimeValueKey: &'static CFString;
}

extern "C" {
    /// A dictionary key for a timescale.
    /// CFDictionary key for timescale field of CMTime (CFNumber containing int32_t)
    pub static kCMTimeScaleKey: &'static CFString;
}

extern "C" {
    /// A dictionary key for a time epoch.
    /// CFDictionary key for epoch field of CMTime (CFNumber containing int64_t)
    pub static kCMTimeEpochKey: &'static CFString;
}

extern "C" {
    /// A dictionary key for time flags.
    /// CFDictionary key for flags field of CMTime (CFNumber containing uint32_t)
    pub static kCMTimeFlagsKey: &'static CFString;
}

impl CMTime {
    /// Creates a string representation of the time.
    ///
    /// Parameters:
    /// - allocator: An allocator with which to create the description. Pass [`kCFAllocatorDefault`](https://developer.apple.com/documentation/corefoundation/kcfallocatordefault) to use the default allocator.
    ///
    /// - time: The time to describe.
    ///
    ///
    /// ## Return Value
    ///
    /// A string representation of the time.
    ///
    ///
    /// Creates a CFString with a description of a CMTime (just like CFCopyDescription).
    ///
    /// This is used from within CFShow on an object that contains CMTime fields. It is
    /// also useful from other client debugging code.  The caller owns the returned
    /// CFString, and is responsible for releasing it.
    ///
    /// Returns: The created CFString description.
    #[doc(alias = "CMTimeCopyDescription")]
    #[inline]
    pub unsafe fn description(
        allocator: Option<&CFAllocator>,
        time: CMTime,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CMTimeCopyDescription(
                allocator: Option<&CFAllocator>,
                time: CMTime,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CMTimeCopyDescription(allocator, time) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Prints a description of the time to the console.
    ///
    /// Parameters:
    /// - time: A time to show.
    ///
    ///
    /// ## Discussion
    ///
    /// This function is most appropriate to use for debugging purposes.
    ///
    ///
    /// Prints a description of the CMTime (just like CFShow).
    ///
    /// This is most useful from within gdb.
    #[doc(alias = "CMTimeShow")]
    #[inline]
    pub unsafe fn show(self) {
        extern "C-unwind" {
            fn CMTimeShow(time: CMTime);
        }
        unsafe { CMTimeShow(self) }
    }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::new`"]
    pub fn CMTimeMake(value: i64, timescale: i32) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::with_epoch`"]
    pub fn CMTimeMakeWithEpoch(value: i64, timescale: i32, epoch: i64) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::with_seconds`"]
    pub fn CMTimeMakeWithSeconds(seconds: f64, preferred_timescale: i32) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::seconds`"]
    pub fn CMTimeGetSeconds(time: CMTime) -> f64;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::convert_scale`"]
    pub fn CMTimeConvertScale(
        time: CMTime,
        new_timescale: i32,
        method: CMTimeRoundingMethod,
    ) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::add`"]
    pub fn CMTimeAdd(lhs: CMTime, rhs: CMTime) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::subtract`"]
    pub fn CMTimeSubtract(lhs: CMTime, rhs: CMTime) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::multiply`"]
    pub fn CMTimeMultiply(time: CMTime, multiplier: i32) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::multiply_by_float64`"]
    pub fn CMTimeMultiplyByFloat64(time: CMTime, multiplier: f64) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::multiply_by_ratio`"]
    pub fn CMTimeMultiplyByRatio(time: CMTime, multiplier: i32, divisor: i32) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::compare`"]
    pub fn CMTimeCompare(time1: CMTime, time2: CMTime) -> i32;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::minimum`"]
    pub fn CMTimeMinimum(time1: CMTime, time2: CMTime) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::maximum`"]
    pub fn CMTimeMaximum(time1: CMTime, time2: CMTime) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::absolute_value`"]
    pub fn CMTimeAbsoluteValue(time: CMTime) -> CMTime;
}

#[deprecated = "renamed to `CMTime::as_dictionary`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimeCopyAsDictionary(
    time: CMTime,
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CMTimeCopyAsDictionary(
            time: CMTime,
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CMTimeCopyAsDictionary(time, allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::from_dictionary`"]
    pub fn CMTimeMakeFromDictionary(dictionary_representation: Option<&CFDictionary>) -> CMTime;
}

#[deprecated = "renamed to `CMTime::description`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimeCopyDescription(
    allocator: Option<&CFAllocator>,
    time: CMTime,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CMTimeCopyDescription(
            allocator: Option<&CFAllocator>,
            time: CMTime,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CMTimeCopyDescription(allocator, time) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTime::show`"]
    pub fn CMTimeShow(time: CMTime);
}
