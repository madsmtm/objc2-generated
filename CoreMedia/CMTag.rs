//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// Core media tagging errors reported by the framework.
/// The OSStatus errors returned from the CMTag routines.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CMTagError(pub OSStatus);
impl CMTagError {
    /// An error where input or output parameters didn’t match the requirements of Core Media.
    #[doc(alias = "kCMTagError_ParamErr")]
    pub const ParamErr: Self = Self(-15730);
    /// An error where the system can’t allocate enough memory for the tag.
    #[doc(alias = "kCMTagError_AllocationFailed")]
    pub const AllocationFailed: Self = Self(-15731);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTagError {
    const ENCODING: Encoding = OSStatus::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTagError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A 64-bit representation of a tag’s category.
/// An enum indicating the available CMTagCategory identifiers that can be used to distinguish the tag from other kinds.
///
/// Different kinds of CMTags may be defined or registered. Each will be associated with a category. CMTags with the same CMTagCategory will have the same kinds of values. The category serves as a namespace.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CMTagCategory(pub FourCharCode);
impl CMTagCategory {
    /// An unknown or undefined tag category.
    #[doc(alias = "kCMTagCategory_Undefined")]
    pub const Undefined: Self = Self(0);
    /// A category used for tagging media type metadata.
    #[doc(alias = "kCMTagCategory_MediaType")]
    pub const MediaType: Self = Self(0x6d646961);
    /// A category used for tagging media subtype metadata.
    #[doc(alias = "kCMTagCategory_MediaSubType")]
    pub const MediaSubType: Self = Self(0x6d737562);
    /// A category used for tagging a track ID.
    #[doc(alias = "kCMTagCategory_TrackID")]
    pub const TrackID: Self = Self(0x7472616b);
    /// A category used for tagging a channel ID.
    #[doc(alias = "kCMTagCategory_ChannelID")]
    pub const ChannelID: Self = Self(0x7663686e);
    /// A category used for tagging a video layer ID.
    #[doc(alias = "kCMTagCategory_VideoLayerID")]
    pub const VideoLayerID: Self = Self(0x766c6179);
    /// A category used for tagging pixel format information.
    #[doc(alias = "kCMTagCategory_PixelFormat")]
    pub const PixelFormat: Self = Self(0x70697866);
    /// A category used for tagging frame-packing information.
    #[doc(alias = "kCMTagCategory_PackingType")]
    pub const PackingType: Self = Self(0x7061636b);
    /// A category used for tagging projection surface information.
    #[doc(alias = "kCMTagCategory_ProjectionType")]
    pub const ProjectionType: Self = Self(0x70726f6a);
    /// A category used for tagging eye information for 3D video.
    #[doc(alias = "kCMTagCategory_StereoView")]
    pub const StereoView: Self = Self(0x65796573);
    /// A category used for tagging how to interpret stereo view metadata.
    #[doc(alias = "kCMTagCategory_StereoViewInterpretation")]
    pub const StereoViewInterpretation: Self = Self(0x65796970);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTagCategory {
    const ENCODING: Encoding = FourCharCode::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTagCategory {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The data type of a tag’s value.
///
/// ## Overview
///
/// Use methods from Inspecting Tags to determine a tag’s data type.
///
///
/// The data type for the value of the CMTag.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CMTagDataType(pub u32);
impl CMTagDataType {
    /// The tag value isn’t associated with any known data type.
    ///
    /// ## Discussion
    ///
    /// Avoid retrieving values from tags with this data type.
    ///
    ///
    #[doc(alias = "kCMTagDataType_Invalid")]
    pub const Invalid: Self = Self(0);
    /// The tag value is a signed 64-bit integer.
    #[doc(alias = "kCMTagDataType_SInt64")]
    pub const SInt64: Self = Self(2);
    /// The tag value is a 64-bit floating point number.
    #[doc(alias = "kCMTagDataType_Float64")]
    pub const Float64: Self = Self(3);
    /// The tag value is a 64-bit identifier used by the operating system.
    #[doc(alias = "kCMTagDataType_OSType")]
    pub const OSType: Self = Self(5);
    /// The tag value is a 64-bit wide bitflag field.
    #[doc(alias = "kCMTagDataType_Flags")]
    pub const Flags: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTagDataType {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTagDataType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The type used to represent tag values.
/// 64-bit value interpreted within the context of the CMTagCategory.
///
/// The 64-bit value can be one of several data types fitting within that range and holding a category-specific value. Data types include numeric and non-numeric types. Examples of numeric include a signed 64-bit integer and a 64-bit floating point value. Non-numeric types include a single OSType and an OSType pair. The value may hold values including discrete values, bit flags, enums representable as a signed 64-bit integer or float and values encoding any of these.
pub type CMTagValue = u64;

/// A tag representing additional metadata on tagged media buffers.
///
/// ## Overview
///
/// The Core Media framework uses tags to describe the properties of media channels. Each tag consists of a category and a value, both of which are 64 bits in size.
///
/// <div class="warning">
///
/// ### Important
/// Tag data can only contain values that can be safely stored on disk. This restriction means `CMTag` structs can’t contain a pointer as their value. If you need to refer to another media element or in-memory data as part of a tag, use a buffer index or other constant.
///
///
///
/// </div>
///
/// An efficient structure used to label something about a resource or other media construct.
///
/// A structure holding a CMTagCategory, CMTagDataType, and a CMTagValue serving to represent a particular tag that might be assigned to or associated with another resource. There is only one of each of the category, the dataType and the value so any notion of "has" is about the respective singular element.  CMTags are a value type. No lifetime management such as allocation or retain and release semantics are needed. CMTags can be passed by value, returned by value and stored in other structures or arrays or on the stack.  CMTags carry a single value that can be carried in 64 bits. This can include data types such as signed 64-bit integers, floating point values fitting in 64 bits, up to 64 bit of flags, and other data types fitting within 64 bits. Signaling of the data type is carried in the CMTagDataType. The data types can be extended through registration with the CoreMedia team.  A CMTag value should not be used to carry pointers. If such a reference is needed, it is okay to carry an index into an out-of-band data structure that itself has a memory reference or an object reference.
/// Field: category CMTagCategory for the tag.
/// Field: dataType CMTagDataType for the tag indicating the data type of the value.
/// Field: value CMTagValue for the value of the CMTag (e.g., a signed 64-bit integer.)
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CMTag {
    pub category: CMTagCategory,
    pub dataType: CMTagDataType,
    pub value: CMTagValue,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTag {
    const ENCODING: Encoding = Encoding::Struct(
        "CMTag",
        &[
            <CMTagCategory>::ENCODING,
            <CMTagDataType>::ENCODING,
            <CMTagValue>::ENCODING,
        ],
    );
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTag {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CMTag {
    // TODO: pub fn CMTagIsValid(tag: CMTag,) -> Boolean;

    /// Retrieves the data type of a tag.
    ///
    /// Parameters:
    /// - tag: The tag to retrieve a data type from.
    ///
    /// Returns the dataType field of the CMTag.
    ///
    /// Parameter `tag`: CMTag from which to extract the data type.
    ///
    /// Returns: kCMTagDataType_* value.
    #[doc(alias = "CMTagGetValueDataType")]
    #[inline]
    pub unsafe fn value_data_type(self) -> CMTagDataType {
        extern "C-unwind" {
            fn CMTagGetValueDataType(tag: CMTag) -> CMTagDataType;
        }
        unsafe { CMTagGetValueDataType(self) }
    }
}

extern "C" {
    /// A constant representing an invalid tag.
    /// CMTag with an unspecified or "null" value.
    pub static kCMTagInvalid: CMTag;
}

extern "C" {
    /// A value for associating a tag’s media type with video.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_MediaType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_mediatype) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_MediaType and the value kCMMediaType_Video (OSType).
    pub static kCMTagMediaTypeVideo: CMTag;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_MediaSubType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_mediasubtype) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_MediaType and the value kCMMetadataFormatType_Boxed (OSType).
    pub static kCMTagMediaSubTypeMebx: CMTag;
}

extern "C" {
    /// A value for associating a tag’s media type with audio.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_MediaType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_mediatype) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_MediaType and the value kCMMediaType_Audio (OSType).
    pub static kCMTagMediaTypeAudio: CMTag;
}

extern "C" {
    /// A value for associating a tag’s media type with metadata.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_MediaType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_mediatype) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_MediaType and the value kCMMediaType_Metadata (OSType).
    pub static kCMTagMediaTypeMetadata: CMTag;
}

/// Constants describing the stereo views contained within a buffer or channel.
///
/// ## Overview
///
/// When no stereo view components are available on a video track, even if it’s encoded for multiview video, any video content in the associated data is single-track 2D.
///
///
/// Flags used with kCMTagCategory_StereoView tags to signal the nature of the stereo views carried in a buffer or channel.
///
/// A "stereo eye" is either for the left eye or for the right eye. A CMTag signaling of stereo views can indicate the presence of one "stereo eye", both stereo eyes or no stereo eyes. A CMTag having a CMTagCategory of kCMTagCategory_StereoView has a value that is a set of kCMTagStereoViewComponent_* flags (see CMTagMakeWithFlagsValue()) that can be set to indicate the stereo eyes carried.  If neither the left nor the right stereo eye is signaled, this can be interpreted to mean that this is not stereo view related and is instead monoscopic video. If it is not stereo related, a kCMTagCategory_StereoView CMTag need not be associated with the buffer or channel.  kCMTagCategory_StereoView does not prescribe how the stereo views are carried. It might be contained in some kind of multiview carriage or might be frame packed in some way. The kCMTagCategory_PackingType will typically be available if frame packing of stereo views is used. The presence of a CMTag with kCMTagCategory_StereoView alone is insufficient to imply if there is some kind of packing or other mechanism required. Additional CMTags with other CMTagCategories may be necessary.  One or more kCMTagCategory_StereoView tags may be present in a collection. When considering which stereo eyes are represented by the collection, the same semantic can be expressed in more than one way in the collection. Specifying the same CMTag more than once has no meaning as the first occurrence indicates the stereo eye or stereo eyes are present.
/// Here are compatible semantics expressed by one or more CMTags:
/// - a single CMTag with kCMTagStereoViewsOption_LeftEye bitwise ORed with kCMTagStereoViewsOption_RightEye.
/// - two kCMTagCategory_StereoView CMTags with one CMTag having the value kCMTagStereoViewsOption_LeftEye and the other CMTag having the value kCMTagStereoViewsOption_RightEye.
/// - three or more CMTags made up of a CMTag with kCMTagStereoViewsOption_LeftEye bitwise ORed with kCMTagStereoViewsOption_RightEye and both a CMTag with only kCMTagStereoViewsOption_LeftEye and a CMTag with kCMTagStereoViewsOption_RightEye.
/// Likewise, if a collection contains only one or more CMTags with one stereo eye (e.g., kCMTagStereoViewsOption_LeftEye), only that stereo eye should be considered present.  The absence of a kCMTagCategory_StereoView CMTag is meant to indicate there is no stereo view present. If this signaling of no stereo eyes is associated with a buffer or channel that carries stereo eye views, the buffer or channel should be configured to present only a monoscopic view. This might be in the form of some fallback to a default view corresponding to a stereo eye or even to some other view it includes or can synthesize.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CMStereoViewComponents(pub u64);
bitflags::bitflags! {
    impl CMStereoViewComponents: u64 {
/// A constant for video metadata to have no available stereo frames.
        #[doc(alias = "kCMStereoView_None")]
        const None = 0;
/// The stereo video track includes a left eye layer.
        #[doc(alias = "kCMStereoView_LeftEye")]
        const LeftEye = 1<<0;
/// The stereo video track includes a right eye layer.
        #[doc(alias = "kCMStereoView_RightEye")]
        const RightEye = 1<<1;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMStereoViewComponents {
    const ENCODING: Encoding = u64::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMStereoViewComponents {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A value for a stereo tag indicating the video track has a left eye layer.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_StereoView`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_stereoview) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_StereoView and the value kCMTagStereoViewComponent_LeftEye (Flags).
    pub static kCMTagStereoLeftEye: CMTag;
}

extern "C" {
    /// A value for a stereo tag indicating the video track has a right eye layer.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_StereoView`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_stereoview) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_StereoView and the value kCMTagStereoViewComponent_RightEye (Flags).
    pub static kCMTagStereoRightEye: CMTag;
}

extern "C" {
    /// A value for a stereo tag indicating the video track has left and right eye layers.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_StereoView`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_stereoview) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_StereoView and the value of the bitwise OR of kCMTagStereoViewComponent_LeftEye and kCMTagStereoViewComponent_RightEye (Flags).
    pub static kCMTagStereoLeftAndRightEye: CMTag;
}

extern "C" {
    /// A value for a stereo tag indicating the video track has no eye layer data.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_StereoView`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_stereoview) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_StereoView and the value of kCMTagStereoViewComponent_None. (Flags)
    pub static kCMTagStereoNone: CMTag;
}

/// Create a set of stereo view interpretation options from a constant.
/// Flags used with kCMTagCategory_StereoViewInterpretation tags to signal additional information that may be important to the interpretation of stereo views carried in a buffer or channel.
///
/// A buffer or channel may carry one or more stereo eye views. The signaling of the presence of individual stereo eye views can be done using CMTags with a kCMTagCategory_StereoView category and correspondng kCMTagStereoViewComponent_* constants. There may however be additional signaling that is valuable beyond the presence of a stereo eye. The kCMTagCategory_StereoViewInterpretation category allows additional signaling that may be relevant for interpretation of storage, ordering or other details regarding the stereo views.  A CMTag having a CMTagCategory of kCMTagCategory_StereoViewInterpretation has a value that is a set of kCMStereoViewInterpretation_* flags (see CMTagMakeWithFlagsValue()) that can be set to indicate additional aspects of the stereo view or stereo views. The absence of a flag indicates the default interpretation of that feature or aspect should occur. If a flag is set, the semantic of that feature and only that feature should be inferred.  Two stereo view interpretations are currently defined.  One is that the order of stereo views is the reverse of the default of left then right. Here, order can be the geometric order such as in frame packed video or in something such as storage order.  The second is that buffers or channels contain views other than the left stereo eye view and the right stereo eye view. Such a view might be used as an alternative when perhaps monoscopic view is to be used instead of selecting the left or right stereo view or synthesizing something based upon the left and right stereo eye views.  The absence of a kCMTagCategory_StereoViewInterpretation CMTag is meant to indicate defaults are used.  Specifying kCMStereoViewInterpretation_Default is equivalent to the absence of a CMTag with category kCMTagCategory_StereoViewInterpretation.
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CMStereoViewInterpretationOptions(pub u64);
bitflags::bitflags! {
    impl CMStereoViewInterpretationOptions: u64 {
/// The default options for stereo video views.
///
/// ## Discussion
///
/// Uses the default left-to-right eye ordering for geometry and storage, and allows for the presence of at most two video views in the data, representing the left and right eye.
///
///
        #[doc(alias = "kCMStereoViewInterpretation_Default")]
        const Default = 0;
/// Changes the default ordering of eye data, switching it from left-to-right to right-to-left.
///
/// ## Discussion
///
/// Setting the [`kCMStereoViewInterpretation_StereoOrderReversed`](https://developer.apple.com/documentation/coremedia/cmstereoviewinterpretationoptions/stereoorderreversed) flag changes interpretations of geometry and affects internal storage.
///
///
        #[doc(alias = "kCMStereoViewInterpretation_StereoOrderReversed")]
        const StereoOrderReversed = 1<<0;
/// A flag indicating that the video content contains additional views beyond the left or right eye.
        #[doc(alias = "kCMStereoViewInterpretation_AdditionalViews")]
        const AdditionalViews = 1<<1;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMStereoViewInterpretationOptions {
    const ENCODING: Encoding = u64::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMStereoViewInterpretationOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A value for a stereo interpretation tag indicating the video data for the left and right eyes are reversed.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_StereoViewInterpretation`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_stereoviewinterpretation) category. This constant changes interpretations of geometry and affects internal storage by placing right eye data before left eye data.
    ///
    ///
    /// A CMTag of category kCMTagCategory_StereoViewInterpretation and the value of kCMStereoViewInterpretation_StereoOrderReversed (Flags).
    pub static kCMTagStereoInterpretationOrderReversed: CMTag;
}

/// Constants describing the projection surface information in a 3D video buffer or channel.
/// Constants used with kCMTagCategory_ProjectionType to signal the nature of a video projection carried in a buffer or channel.
///
/// A video projection can be one of several types. Examples include 360 degree equirectangular, 180 degree half equirectangular, or a fisheye.  A CMTag having a CMTagCategory of kCMTagCategory_ProjectionType has a value that is an OSType indicating the kind of projection using a kCMProjectionType_* constant.  The kCMProjectionType_Rectangular projection type can signal that there is no projection other than the default 2D view. This is provided so it is possible to still signal a kCMTagCategory_ProjectionType CMTag but indicates it has no effect.     The kCMProjectionType_ParametricImmersive projection type indicates a projection described mathematically by a model of camera lens calibration parameters. Parameters may be found in lens calibration metadata in kCMFormatDescriptionExtension_CameraCalibrationDataLensCollection with algorithm_kind parametric. If a kCMTagCategory_ProjectionType CMTag is not signaled, a rectangular projection is implied.  The kCMTagCategory_ProjectionType tag may be associated with other tags if projection related parameters are also signaled. What is carried will be defined for the specific type of projection.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CMProjectionType(pub u64);
impl CMProjectionType {
    /// Video content displays on a flat, rectangular 2D surface.
    ///
    /// ## Discussion
    ///
    /// Rectangular projection is equivalent to displaying as a 2D texture in the world.
    ///
    /// Rectangular projection is the default for 3D video when a channel or buffer has no projection metadata.
    ///
    ///
    #[doc(alias = "kCMProjectionType_Rectangular")]
    pub const Rectangular: Self = Self(0x72656374);
    /// Video content displays as a 360 degree equirectangular projection.
    ///
    /// ## Discussion
    ///
    /// The video frames map onto the interior of a 3D sphere projection.
    ///
    ///
    #[doc(alias = "kCMProjectionType_Equirectangular")]
    pub const Equirectangular: Self = Self(0x65717569);
    /// Video content displays as a 180 degree equirectangular projection.
    ///
    /// ## Discussion
    ///
    /// The video frames map onto the interior of a 3D half-sphere projection.
    ///
    ///
    #[doc(alias = "kCMProjectionType_HalfEquirectangular")]
    pub const HalfEquirectangular: Self = Self(0x68657175);
    /// Video content displays as a fisheye projection.
    #[doc(alias = "kCMProjectionType_Fisheye")]
    pub const Fisheye: Self = Self(0x66697368);
    #[doc(alias = "kCMProjectionType_ParametricImmersive")]
    pub const ParametricImmersive: Self = Self(0x7072696d);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMProjectionType {
    const ENCODING: Encoding = u64::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMProjectionType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A value for projection tags indicating that display is on a flat rectangular surface.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_ProjectionType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_projectiontype) category. Rectangular projection is equivalent to displaying as a 2D texture in the world.
    ///
    /// Rectangular projection is the default for 3D video when a channel or buffer has no projection metadata.
    ///
    ///
    /// A CMTag of category kCMTagCategory_ProjectionType and the value kCMTagProjectionType_Rectangular (OSType).
    pub static kCMTagProjectionTypeRectangular: CMTag;
}

extern "C" {
    /// A value for projection tags indicating that display is on a 360 degree equirectangular projection.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_ProjectionType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_projectiontype) category. The video frames map onto the interior of a 3D sphere projection.
    ///
    ///
    /// A CMTag of category kCMTagCategory_ProjectionType and the value kCMTagProjectionType_Equirectangular (OSType).
    pub static kCMTagProjectionTypeEquirectangular: CMTag;
}

extern "C" {
    /// A CMTag of category kCMTagCategory_ProjectionType and the value kCMProjectionType_HalfEquirectangular (OSType).
    pub static kCMTagProjectionTypeHalfEquirectangular: CMTag;
}

extern "C" {
    /// Video content displays as a fisheye projection.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_ProjectionType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_projectiontype) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_ProjectionType and the value kCMTagProjectionType_Fisheye (OSType).
    pub static kCMTagProjectionTypeFisheye: CMTag;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// A CMTag of category kCMTagCategory_ProjectionType and the value kCMTagProjectionType_ParametricImmersive (OSType).
    ///
    ///
    /// A CMTag of category kCMTagCategory_ProjectionType and the value kCMTagProjectionType_ParametricImmersive (OSType).
    pub static kCMTagProjectionTypeParametricImmersive: CMTag;
}

/// The type of packing within each video frame, if any.
///
/// ## Overview
///
/// Frame-packed video contains both the left and right eye images on a single video track. With frame-packed video, use the appropriate Frame Arrangement.
///
///
/// Constants used with kCMTagCategory_PackingType to signal the nature of any packing applied in a buffer or channel.
///
/// A video packing can be one of several types including frame-packing for stereo views or texture atlasing. A CMTag having a CMTagCategory of kCMTagCategory_PackingType has a value that is an OSType indicating the kind of packing using a kCMPackingType_* constant.  Examples of frame-packing include side-by-side and over-under packing, There may be related CMTags if a kind of packing requires additional parameters. The requirements will be documented with the specific kind of packing.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CMPackingType(pub u64);
impl CMPackingType {
    /// Each frame contains only a single image, and isn’t frame-packed.
    ///
    /// ## Discussion
    ///
    /// This is the default frame-packing type for 3D video.
    ///
    ///
    #[doc(alias = "kCMPackingType_None")]
    pub const None: Self = Self(0x6e6f6e65);
    /// The video contains packed frames that have a left eye image on the left and right eye image on the right.
    ///
    /// ## Discussion
    ///
    /// For side-by-side packed frames, the width of a frame in video data is twice as wide as the video displayed.
    ///
    ///
    #[doc(alias = "kCMPackingType_SideBySide")]
    pub const SideBySide: Self = Self(0x73696465);
    /// The video contains packed frames that have a left eye image on the top and right eye image on the bottom.
    ///
    /// ## Discussion
    ///
    /// For over-under packed frames, the height of a frame in video data is twice as high as the video displayed.
    ///
    ///
    #[doc(alias = "kCMPackingType_OverUnder")]
    pub const OverUnder: Self = Self(0x6f766572);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMPackingType {
    const ENCODING: Encoding = u64::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMPackingType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A frame-packing tag value for video without packed frames.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_PackingType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_packingtype) category.
    ///
    ///
    /// A CMTag of category kCMTagCategory_PackingType and the value kCMTagPackingType_None (OStype).
    pub static kCMTagPackingTypeNone: CMTag;
}

extern "C" {
    /// A tag stating that associated video has packed frames with a left eye image on the left and right eye image on the right.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_PackingType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_packingtype) category. For side-by-side packed frames, the width of a frame in video data is twice as wide as the video displayed.
    ///
    ///
    /// A CMTag of category kCMTagCategory_PackingType and the value kCMTagPackingType_SideBySide (OStype).
    pub static kCMTagPackingTypeSideBySide: CMTag;
}

extern "C" {
    /// A tag stating that associated video has packed frames with a left eye image on the top and right eye image on the bottom.
    ///
    /// ## Discussion
    ///
    /// This value is for use in tags with the [`kCMTagCategory_PackingType`](https://developer.apple.com/documentation/coremedia/cmtagcategory/kcmtagcategory_packingtype) category. For over-under packed frames, the height of a frame in video data is twice as high as the video displayed.
    ///
    ///
    /// A CMTag of category kCMTagCategory_PackingType and the value kCMTagPackingType_OverUnder (OStype).
    pub static kCMTagPackingTypeOverUnder: CMTag;
}

impl CMTag {
    // TODO: pub fn CMTagGetCategory(tag: CMTag,) -> CMTagCategory;
}

impl CMTagCategory {
    // TODO: pub fn CMTagCategoryEqualToTagCategory(tag1: CMTag,tag2: CMTag,) -> Boolean;
}

impl CMTag {
    // TODO: pub fn CMTagGetValue(tag: CMTag,) -> CMTagValue;

    // TODO: pub fn CMTagHasCategory(tag: CMTag,category: CMTagCategory,) -> Boolean;

    /// Whether a given tag contains a value for a signed 64-bit integer.
    ///
    /// Parameters:
    /// - tag: The tag to inspect.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `YES` if the tag represents an integer.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Prefer using this method over directly comparing a tag’s data type to [`kCMTagDataType_SInt64`](https://developer.apple.com/documentation/coremedia/cmtagdatatype/kcmtagdatatype_sint64).
    ///
    ///
    /// Checks if the tag represents a signed 64-bit value.
    ///
    /// Parameter `tag`: CMTag to evaluate.
    ///
    /// Returns: Returns true if the CMTag carries a signed 64-bit value indicated by a data type of kCMTagDataType_SInt64, false otherwise.
    #[doc(alias = "CMTagHasSInt64Value")]
    #[inline]
    pub unsafe fn has_s_int64_value(self) -> bool {
        extern "C-unwind" {
            fn CMTagHasSInt64Value(tag: CMTag) -> Boolean;
        }
        let ret = unsafe { CMTagHasSInt64Value(self) };
        ret != 0
    }

    /// Retrieves a tag’s value as a signed 64-bit integer.
    ///
    /// Parameters:
    /// - tag: The tag to get the value from.
    ///
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Before retrieving a tag’s value with this function, call [`CMTagHasSInt64Value`](https://developer.apple.com/documentation/coremedia/cmtaghassint64value) to ensure it has the correct type.
    ///
    ///
    ///
    /// </div>
    ///
    /// Returns the signed 64-bit value carried by the CMTag.
    ///
    /// This should only be called on a CMTag with a data type of kCMTagDataType_SInt64. Calling it with a CMTag having another data type is undefined.
    ///
    /// Parameter `tag`: CMTag to evaluate.
    ///
    /// Returns: Signed 64-bit integer.
    #[doc(alias = "CMTagGetSInt64Value")]
    #[inline]
    pub unsafe fn s_int64_value(self) -> i64 {
        extern "C-unwind" {
            fn CMTagGetSInt64Value(tag: CMTag) -> i64;
        }
        unsafe { CMTagGetSInt64Value(self) }
    }

    /// Whether a given tag contains a value for a 64-bit floating point number.
    ///
    /// Parameters:
    /// - tag: The tag to inspect.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `YES` if the tag represents a floating point number.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Prefer using this method over directly comparing a tag’s data type to [`kCMTagDataType_Float64`](https://developer.apple.com/documentation/coremedia/cmtagdatatype/kcmtagdatatype_float64).
    ///
    ///
    /// Checks if the tag represents a 64-bit float value.
    ///
    /// Parameter `tag`: CMTag to evaluate.
    ///
    /// Returns: Returns true if the CMTag carries a 64-bit float indicated by a data type of kCMTagDataType_Float64, false otherwise.
    #[doc(alias = "CMTagHasFloat64Value")]
    #[inline]
    pub unsafe fn has_float64_value(self) -> bool {
        extern "C-unwind" {
            fn CMTagHasFloat64Value(tag: CMTag) -> Boolean;
        }
        let ret = unsafe { CMTagHasFloat64Value(self) };
        ret != 0
    }

    /// Retrieves a tag’s value as a 64-bit floating point number.
    ///
    /// Parameters:
    /// - tag: The tag to get the value from.
    ///
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Before retrieving a tag’s value with this function, call [`CMTagHasFloat64Value`](https://developer.apple.com/documentation/coremedia/cmtaghasfloat64value) to ensure it has the correct type.
    ///
    ///
    ///
    /// </div>
    ///
    /// Returns the 64-bit floating point value carried by the CMTag.
    ///
    /// This should only be called on a CMTag with a data type of kCMTagDataType_Float64. Calling it with a CMTag having another data type is undefined.
    ///
    /// Parameter `tag`: CMTag to evaluate.
    ///
    /// Returns: 64-bit float.
    #[doc(alias = "CMTagGetFloat64Value")]
    #[inline]
    pub unsafe fn float64_value(self) -> f64 {
        extern "C-unwind" {
            fn CMTagGetFloat64Value(tag: CMTag) -> f64;
        }
        unsafe { CMTagGetFloat64Value(self) }
    }

    /// Whether a given tag contains a value for use by the operating system.
    ///
    /// Parameters:
    /// - tag: The tag to inspect.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `YES` if the tag represents an [`OSType`](https://developer.apple.com/documentation/kernel/ostype).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Prefer using this method over directly comparing a tag’s data type to [`kCMTagDataType_OSType`](https://developer.apple.com/documentation/coremedia/cmtagdatatype/kcmtagdatatype_ostype).
    ///
    ///
    /// Checks if the tag represents an OSType value.
    ///
    /// Parameter `tag`: CMTag to evaluate.
    ///
    /// Returns: Returns true if the CMTag carries an OSType indicated by a data type of kCMTagDataType_OSType, false otherwise.
    #[doc(alias = "CMTagHasOSTypeValue")]
    #[inline]
    pub unsafe fn has_os_type_value(self) -> bool {
        extern "C-unwind" {
            fn CMTagHasOSTypeValue(tag: CMTag) -> Boolean;
        }
        let ret = unsafe { CMTagHasOSTypeValue(self) };
        ret != 0
    }

    /// Retrieves a tag’s value for use by the operating system.
    ///
    /// Parameters:
    /// - tag: The tag to get the value from.
    ///
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Before retrieving a tag’s value with this function, call [`CMTagHasOSTypeValue`](https://developer.apple.com/documentation/coremedia/cmtaghasostypevalue) to ensure it has the correct type.
    ///
    ///
    ///
    /// </div>
    ///
    /// Returns the single OSType value carried by the CMTag.
    ///
    /// This should only be called on a CMTag with a data type of kCMTagDataType_OSType. Calling it with a CMTag having another data type is undefined.
    ///
    /// Parameter `tag`: CMTag to evaluate.
    ///
    /// Returns: OSType.
    #[doc(alias = "CMTagGetOSTypeValue")]
    #[inline]
    pub unsafe fn os_type_value(self) -> OSType {
        extern "C-unwind" {
            fn CMTagGetOSTypeValue(tag: CMTag) -> OSType;
        }
        unsafe { CMTagGetOSTypeValue(self) }
    }

    /// Whether a given tag contains a value for a 64-bit flag field.
    ///
    /// Parameters:
    /// - tag: The tag to inspect.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `YES` if the tag represents a flag field.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Prefer using this method over directly comparing a tag’s data type to [`kCMTagDataType_Flags`](https://developer.apple.com/documentation/coremedia/cmtagdatatype/kcmtagdatatype_flags).
    ///
    ///
    /// Checks if the tag represents an flags value.
    ///
    /// Parameter `tag`: CMTag to evaluate.
    ///
    /// Returns: Returns true if the CMTag carries 64 bits of flags indicated by a data type of kCMTagDataType_Flags, false otherwise.
    #[doc(alias = "CMTagHasFlagsValue")]
    #[inline]
    pub unsafe fn has_flags_value(self) -> bool {
        extern "C-unwind" {
            fn CMTagHasFlagsValue(tag: CMTag) -> Boolean;
        }
        let ret = unsafe { CMTagHasFlagsValue(self) };
        ret != 0
    }

    /// Retrieves a tag’s value as a 64-bit field flag.
    ///
    /// Parameters:
    /// - tag: The tag to get the value from.
    ///
    ///
    /// ## Discussion
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Before retrieving a tag’s value with this function, call [`CMTagHasFlagsValue`](https://developer.apple.com/documentation/coremedia/cmtaghasflagsvalue) to ensure it has the correct type.
    ///
    ///
    ///
    /// </div>
    ///
    /// Returns the 64 bits of flags as an unsigned 64-bit integer carried by the CMTag.
    ///
    /// This should only be called on a CMTag with a data type of kCMTagDataType_Flags. Calling it with a CMTag having another data type is undefined.
    ///
    /// Parameter `tag`: CMTag to evaluate.
    ///
    /// Returns: Unsigned 64-bit integer holding the flags value.
    #[doc(alias = "CMTagGetFlagsValue")]
    #[inline]
    pub unsafe fn flags_value(self) -> u64 {
        extern "C-unwind" {
            fn CMTagGetFlagsValue(tag: CMTag) -> u64;
        }
        unsafe { CMTagGetFlagsValue(self) }
    }

    /// Creates a new tag with a given category and a 64-bit signed integer.
    ///
    /// Parameters:
    /// - category: The category of the new tag. For available categories, see Tag Category Constants.
    ///
    /// - value: The value of the new tag.
    ///
    ///
    /// ## Return Value
    ///
    /// A new tag with the assigned category containing a signed 64-bit integer, or [`kCMTagInvalid`](https://developer.apple.com/documentation/coremedia/kcmtaginvalid) if no tag could be created.
    ///
    ///
    /// Create a CMTag holding a signed 64-bit integer.
    ///
    /// This function creates a valid CMTag with the data type kCMTagDataType_SInt64 and have a signed 64-bit integer value.
    ///
    /// Parameter `category`: CMTagCategory for the created CMTag.
    ///
    /// Parameter `value`: A signed 64-bit integer to encode in the returned CMTag.
    ///
    /// Returns: A CMTag.
    #[doc(alias = "CMTagMakeWithSInt64Value")]
    #[inline]
    pub unsafe fn with_s_int64_value(category: CMTagCategory, value: i64) -> CMTag {
        extern "C-unwind" {
            fn CMTagMakeWithSInt64Value(category: CMTagCategory, value: i64) -> CMTag;
        }
        unsafe { CMTagMakeWithSInt64Value(category, value) }
    }

    /// Creates a new tag with a given category and a 64-bit floating point value.
    ///
    /// Parameters:
    /// - category: The category of the new tag. For available categories, see Tag Category Constants.
    ///
    /// - value: The value of the new tag.
    ///
    ///
    /// ## Return Value
    ///
    /// A new tag with the assigned category containing a 64-bit floating point number, or [`kCMTagInvalid`](https://developer.apple.com/documentation/coremedia/kcmtaginvalid) if no tag could be created.
    ///
    ///
    /// Create a CMTag holding a 64-bit float.
    ///
    /// This function creates a valid CMTag with the data type kCMTagDataType_Float64 and have a 64-bit floating point value.
    ///
    /// Parameter `category`: CMTagCategory for the created CMTag.
    ///
    /// Parameter `value`: A 64-bit float to encode in the returned CMTag.
    ///
    /// Returns: A CMTag.
    #[doc(alias = "CMTagMakeWithFloat64Value")]
    #[inline]
    pub unsafe fn with_float64_value(category: CMTagCategory, value: f64) -> CMTag {
        extern "C-unwind" {
            fn CMTagMakeWithFloat64Value(category: CMTagCategory, value: f64) -> CMTag;
        }
        unsafe { CMTagMakeWithFloat64Value(category, value) }
    }

    /// Creates a new tag with a given category and a 64-bit value for use by the framework.
    ///
    /// Parameters:
    /// - category: The category of the new tag. For available categories, see Tag Category Constants.
    ///
    /// - value: The value of the new tag.
    ///
    ///
    /// ## Return Value
    ///
    /// A new tag with the assigned category containing an [`OSType`](https://developer.apple.com/documentation/kernel/ostype), or [`kCMTagInvalid`](https://developer.apple.com/documentation/coremedia/kcmtaginvalid) if no tag could be created.
    ///
    ///
    /// Create a CMTag holding an OSType.
    ///
    /// This function creates a valid CMTag with the data type kCMTagDataType_OSType and have an OSType value.
    ///
    /// Parameter `category`: CMTagCategory for the created CMTag.
    ///
    /// Parameter `value`: An OSType to encode in the returned CMTag.
    ///
    /// Returns: A CMTag.
    #[doc(alias = "CMTagMakeWithOSTypeValue")]
    #[inline]
    pub unsafe fn with_os_type_value(category: CMTagCategory, value: OSType) -> CMTag {
        extern "C-unwind" {
            fn CMTagMakeWithOSTypeValue(category: CMTagCategory, value: OSType) -> CMTag;
        }
        unsafe { CMTagMakeWithOSTypeValue(category, value) }
    }

    /// Creates a new tag with a given category and a value interpreted as a 64-bit flag field.
    ///
    /// Parameters:
    /// - category: The category of the new tag. For available categories, see Tag Category Constants.
    ///
    /// - flagsForTag: The bitfield to set as the new tag’s value.
    ///
    ///
    /// ## Return Value
    ///
    /// A new tag with the assigned category containing flags as its value, or [`kCMTagInvalid`](https://developer.apple.com/documentation/coremedia/kcmtaginvalid) if no tag could be created.
    ///
    ///
    /// Create a CMTag holding a 64 bits of flags.
    ///
    /// This function creates a valid CMTag with the data type kCMTagDataType_Flags and has an unsigned 64-bit integer value holding the flags.
    ///
    /// Parameter `category`: CMTagCategory for the created CMTag.
    ///
    /// Parameter `flagsForTag`: An unsigned 64-bit integer to encode in the returned CMTag.
    ///
    /// Returns: A CMTag.
    #[doc(alias = "CMTagMakeWithFlagsValue")]
    #[inline]
    pub unsafe fn with_flags_value(category: CMTagCategory, flags_for_tag: u64) -> CMTag {
        extern "C-unwind" {
            fn CMTagMakeWithFlagsValue(category: CMTagCategory, flags_for_tag: u64) -> CMTag;
        }
        unsafe { CMTagMakeWithFlagsValue(category, flags_for_tag) }
    }

    /// Compares two tags for strict equality.
    /// Tests if two CMTags are equal.
    ///
    /// Function evaluates if two tags are structurally equivalent. It performs a field by field comparison.
    ///
    /// Parameter `tag1`: First CMTag to test for equality.
    ///
    /// Parameter `tag2`: Second CMTag to test for equality.
    ///
    /// Returns: Returns true if the two tags are equal, false otherwise.
    #[doc(alias = "CMTagEqualToTag")]
    #[inline]
    pub unsafe fn equal_to_tag(self, tag2: CMTag) -> bool {
        extern "C-unwind" {
            fn CMTagEqualToTag(tag1: CMTag, tag2: CMTag) -> Boolean;
        }
        let ret = unsafe { CMTagEqualToTag(self, tag2) };
        ret != 0
    }

    /// Compares two tags in terms of partial equality.
    /// Compares two CMTags in an ordered fashion returning a CFComparisonResult based upon the ordering of the tags.
    ///
    /// The entirety of a CMTag can be compared against a second CMTag in an ordered way.  The details of how the comparison is performed is an internal implementation detail. The comparison is performed as tag1 COMPARISON tag2 where COMPARISON is the ordering operation.  The ordering will be stable under a release of the framework but may change in the future. Therefore, an ordered CMTag array serialized in one version of the framework should not be assumed to be ordered the same in another version of the framework. This is best handled by retrieving the original array of CMTags and then reinserting with the new order.
    ///
    /// Parameter `tag1`: First CMTag to compare in ordered fashion.
    ///
    /// Parameter `tag2`: Second CMTag to compare in ordered fashion.
    ///
    /// Returns: The CFComparisonResult indicating the order of tag1 compared to tag2.
    #[doc(alias = "CMTagCompare")]
    #[inline]
    pub unsafe fn compare(self, tag2: CMTag) -> CFComparisonResult {
        extern "C-unwind" {
            fn CMTagCompare(tag1: CMTag, tag2: CMTag) -> CFComparisonResult;
        }
        unsafe { CMTagCompare(self, tag2) }
    }
}

impl CMTagCategory {
    // TODO: pub fn CMTagCategoryValueEqualToValue(tag1: CMTag,tag2: CMTag,) -> Boolean;
}

impl CMTag {
    /// Generates a hash identifier for a tag.
    /// Calculates a hash code for the CMTag.
    ///
    /// Parameter `tag`: CMTag to hash.
    ///
    /// Returns: The created CFHashCode.
    #[doc(alias = "CMTagHash")]
    #[inline]
    pub unsafe fn hash(self) -> CFHashCode {
        extern "C-unwind" {
            fn CMTagHash(tag: CMTag) -> CFHashCode;
        }
        unsafe { CMTagHash(self) }
    }

    /// Copies the description of a tag to a new string.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for creating a new string. Pass `kCFAllocatorDefault` to use the default global allocator.
    ///
    /// - tag: The tag to copy the description from.
    ///
    ///
    /// ## Return Value
    ///
    /// A reference to a newly allocated [`CFString`](https://developer.apple.com/documentation/corefoundation/cfstring), or `NULL` if the copy failed.
    ///
    ///
    /// Creates a CFString with a description of a CMTag (just like CFCopyDescription).
    ///
    /// This can be used from within CFShow on an object that contains CMTag fields. It is also useful from other client debugging code.  The caller owns the returned CFString, and is responsible for releasing it.  Descriptions are not localized so are likely suitable only for debugging.
    ///
    /// Parameter `allocator`: CFAllocator to use in creating the description string.  Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// Parameter `tag`: CMTag to describe.
    ///
    /// Returns: The created CFString description.
    #[doc(alias = "CMTagCopyDescription")]
    #[inline]
    pub unsafe fn description(
        allocator: Option<&CFAllocator>,
        tag: CMTag,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CMTagCopyDescription(
                allocator: Option<&CFAllocator>,
                tag: CMTag,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CMTagCopyDescription(allocator, tag) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Copies an existing tag to a new dictionary object.
    ///
    /// Parameters:
    /// - tag: The tag to create a new dictionary from.
    ///
    /// - allocator: The allocator to use for creating a new dictionary. Pass `kCFAllocatorDefault` to use the default global allocator.
    ///
    ///
    /// ## Return Value
    ///
    /// A reference to a new [`CFDictionary`](https://developer.apple.com/documentation/corefoundation/cfdictionary), or `NULL` if no dictionary could be created.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The created dictionary contains values for the keys [`kCMTagCategoryKey`](https://developer.apple.com/documentation/coremedia/kcmtagcategorykey), [`kCMTagDataTypeKey`](https://developer.apple.com/documentation/coremedia/kcmtagdatatypekey), and [`kCMTagValueKey`](https://developer.apple.com/documentation/coremedia/kcmtagvaluekey).
    ///
    ///
    /// Returns a CFDictionary version of a CMTag.
    ///
    /// This is useful when putting CMTag in CF container types.  The caller owns the returned CFDictionary, and is responsible for releasing it.
    ///
    /// Parameter `tag`: The CMTag from which to create the dictionary.
    ///
    /// Parameter `allocator`: CFAllocator with which to create a dictionary. Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// Returns: A CFDictionary version of the CMTag.
    #[doc(alias = "CMTagCopyAsDictionary")]
    #[inline]
    pub unsafe fn as_dictionary(
        self,
        allocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CMTagCopyAsDictionary(
                tag: CMTag,
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CMTagCopyAsDictionary(self, allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Create a new tag from a dictionary object.
    ///
    /// Parameters:
    /// - dict: The dictionary containing information used to populate the new tag.
    ///
    ///
    /// ## Return Value
    ///
    /// A new tag defined by the dictionary values, or [`kCMTagInvalid`](https://developer.apple.com/documentation/coremedia/kcmtaginvalid) if no tag could be created.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// To create a new tag, the dictionary should have values for the [`kCMTagCategoryKey`](https://developer.apple.com/documentation/coremedia/kcmtagcategorykey), [`kCMTagDataTypeKey`](https://developer.apple.com/documentation/coremedia/kcmtagdatatypekey), and [`kCMTagValueKey`](https://developer.apple.com/documentation/coremedia/kcmtagvaluekey) keys.
    ///
    ///
    /// Reconstitutes a CMTag struct from a CFDictionary previously created by CMTagCopyAsDictionary.
    ///
    /// This is useful when getting CMTag from CF container types.  If the CFDictionary does not have the requisite keyed values, kCMTagInvalid is returned.
    ///
    /// Parameter `dict`: A CFDictionary from which to create a CMTag.
    ///
    /// Returns: The created CMTag.
    ///
    /// # Safety
    ///
    /// - `dict` generic must be of the correct type.
    /// - `dict` generic must be of the correct type.
    #[doc(alias = "CMTagMakeFromDictionary")]
    #[inline]
    pub unsafe fn from_dictionary(dict: &CFDictionary) -> CMTag {
        extern "C-unwind" {
            fn CMTagMakeFromDictionary(dict: &CFDictionary) -> CMTag;
        }
        unsafe { CMTagMakeFromDictionary(dict) }
    }
}

extern "C" {
    /// A constant for use as a key during tag creation from a dictionary, whose value is the tag’s contained value.
    ///
    /// ## Discussion
    ///
    /// Values for this key are of the type held by the [`kCMTagDataTypeKey`](https://developer.apple.com/documentation/coremedia/kcmtagdatatypekey) key of the enclosing dictionary. Ensure that your value can be safely cast to the appropriate type.
    ///
    ///
    /// CFDictionary key for value field of a CMTag.
    pub static kCMTagValueKey: &'static CFString;
}

extern "C" {
    /// A constant for use as a key during tag creation from a dictionary, whose value is the tag’s category.
    ///
    /// ## Discussion
    ///
    /// For values allowed with [`kCMTagCategoryKey`](https://developer.apple.com/documentation/coremedia/kcmtagcategorykey), see Tag Category Constants.
    ///
    ///
    /// CFDictionary key for category field of a CMTag.
    pub static kCMTagCategoryKey: &'static CFString;
}

extern "C" {
    /// A constant for use as a key during tag creation from a dictionary, whose value is the tag’s data type.
    ///
    /// ## Discussion
    ///
    /// For values allowed with kCMTagDataTypeKey, see Tag Value Types.
    ///
    ///
    /// CFDictionary key for dataType field of a CMTag.
    pub static kCMTagDataTypeKey: &'static CFString;
}

impl CMTag {
    // TODO: pub fn CMTagGetCategory(tag: CMTag,) -> CMTagCategory;

    // TODO: pub fn CMTagGetValue(tag: CMTag,) -> CMTagValue;

    // TODO: pub fn CMTagHasCategory(tag: CMTag,category: CMTagCategory,) -> Boolean;
}

impl CMTagCategory {
    // TODO: pub fn CMTagCategoryEqualToTagCategory(tag1: CMTag,tag2: CMTag,) -> Boolean;
}

impl CMTag {
    // TODO: pub fn CMTagIsValid(tag: CMTag,) -> Boolean;
}

impl CMTagCategory {
    // TODO: pub fn CMTagCategoryValueEqualToValue(tag1: CMTag,tag2: CMTag,) -> Boolean;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::value_data_type`"]
    pub fn CMTagGetValueDataType(tag: CMTag) -> CMTagDataType;
}

#[deprecated = "renamed to `CMTag::has_s_int64_value`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTagHasSInt64Value(tag: CMTag) -> bool {
    extern "C-unwind" {
        fn CMTagHasSInt64Value(tag: CMTag) -> Boolean;
    }
    let ret = unsafe { CMTagHasSInt64Value(tag) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::s_int64_value`"]
    pub fn CMTagGetSInt64Value(tag: CMTag) -> i64;
}

#[deprecated = "renamed to `CMTag::has_float64_value`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTagHasFloat64Value(tag: CMTag) -> bool {
    extern "C-unwind" {
        fn CMTagHasFloat64Value(tag: CMTag) -> Boolean;
    }
    let ret = unsafe { CMTagHasFloat64Value(tag) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::float64_value`"]
    pub fn CMTagGetFloat64Value(tag: CMTag) -> f64;
}

#[deprecated = "renamed to `CMTag::has_os_type_value`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTagHasOSTypeValue(tag: CMTag) -> bool {
    extern "C-unwind" {
        fn CMTagHasOSTypeValue(tag: CMTag) -> Boolean;
    }
    let ret = unsafe { CMTagHasOSTypeValue(tag) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::os_type_value`"]
    pub fn CMTagGetOSTypeValue(tag: CMTag) -> OSType;
}

#[deprecated = "renamed to `CMTag::has_flags_value`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTagHasFlagsValue(tag: CMTag) -> bool {
    extern "C-unwind" {
        fn CMTagHasFlagsValue(tag: CMTag) -> Boolean;
    }
    let ret = unsafe { CMTagHasFlagsValue(tag) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::flags_value`"]
    pub fn CMTagGetFlagsValue(tag: CMTag) -> u64;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::with_s_int64_value`"]
    pub fn CMTagMakeWithSInt64Value(category: CMTagCategory, value: i64) -> CMTag;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::with_float64_value`"]
    pub fn CMTagMakeWithFloat64Value(category: CMTagCategory, value: f64) -> CMTag;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::with_os_type_value`"]
    pub fn CMTagMakeWithOSTypeValue(category: CMTagCategory, value: OSType) -> CMTag;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::with_flags_value`"]
    pub fn CMTagMakeWithFlagsValue(category: CMTagCategory, flags_for_tag: u64) -> CMTag;
}

#[deprecated = "renamed to `CMTag::equal_to_tag`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTagEqualToTag(tag1: CMTag, tag2: CMTag) -> bool {
    extern "C-unwind" {
        fn CMTagEqualToTag(tag1: CMTag, tag2: CMTag) -> Boolean;
    }
    let ret = unsafe { CMTagEqualToTag(tag1, tag2) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::compare`"]
    pub fn CMTagCompare(tag1: CMTag, tag2: CMTag) -> CFComparisonResult;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::hash`"]
    pub fn CMTagHash(tag: CMTag) -> CFHashCode;
}

#[deprecated = "renamed to `CMTag::description`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTagCopyDescription(
    allocator: Option<&CFAllocator>,
    tag: CMTag,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CMTagCopyDescription(
            allocator: Option<&CFAllocator>,
            tag: CMTag,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CMTagCopyDescription(allocator, tag) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CMTag::as_dictionary`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTagCopyAsDictionary(
    tag: CMTag,
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CMTagCopyAsDictionary(
            tag: CMTag,
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CMTagCopyAsDictionary(tag, allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTag::from_dictionary`"]
    pub fn CMTagMakeFromDictionary(dict: &CFDictionary) -> CMTag;
}
