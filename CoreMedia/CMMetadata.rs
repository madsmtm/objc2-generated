//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

/// An error that indicates an allocation fails.
pub const kCMMetadataIdentifierError_AllocationFailed: OSStatus = -16300;
/// An error that indicates a parameter the function requires is empty.
pub const kCMMetadataIdentifierError_RequiredParameterMissing: OSStatus = -16301;
/// An error that indicates a key isn’t valid.
pub const kCMMetadataIdentifierError_BadKey: OSStatus = -16302;
/// An error that indicates that a key doesn’t have the correct length.
pub const kCMMetadataIdentifierError_BadKeyLength: OSStatus = -16303;
/// An error that indicates a key has a bad type.
pub const kCMMetadataIdentifierError_BadKeyType: OSStatus = -16304;
/// An error that indicates the number for a key isn’t valid.
pub const kCMMetadataIdentifierError_BadNumberKey: OSStatus = -16305;
/// An error that indicates the keyspace isn’t valid.
pub const kCMMetadataIdentifierError_BadKeySpace: OSStatus = -16306;
/// An error that indicates the identifier isn’t valid.
pub const kCMMetadataIdentifierError_BadIdentifier: OSStatus = -16307;
/// An error that indicates a request for a key value in the anonymous keyspace.
pub const kCMMetadataIdentifierError_NoKeyValueAvailable: OSStatus = -16308;

/// An error that indicates the allocation fails.
pub const kCMMetadataDataTypeRegistryError_AllocationFailed: OSStatus = -16310;
/// An error that indicates a parameter the function requires is empty.
pub const kCMMetadataDataTypeRegistryError_RequiredParameterMissing: OSStatus = -16311;
/// An error that indicates a bad datatype identifier.
pub const kCMMetadataDataTypeRegistryError_BadDataTypeIdentifier: OSStatus = -16312;
/// An error that indicates the datatype is in a registered state.
pub const kCMMetadataDataTypeRegistryError_DataTypeAlreadyRegistered: OSStatus = -16313;
/// An error that indicates the data type you specify requires a conforming data type that resolves to a base data type.
pub const kCMMetadataDataTypeRegistryError_RequiresConformingBaseType: OSStatus = -16314;
/// An error that indicates that type you provide has more than one base data type.
pub const kCMMetadataDataTypeRegistryError_MultipleConformingBaseTypes: OSStatus = -16315;

extern "C" {
    /// Metadata keyspace for QuickTime User Data keys.
    ///
    /// ## Discussion
    ///
    /// This keyspace defines its key values to be expressed as `OSType`s (a.k.a. `FourCharCode`s). As such, keys must be four bytes in length.
    ///
    ///
    /// Metadata keyspace for QuickTime User Data keys.
    ///
    /// Metadata keyspace for MPEG-4 User Data keys.
    ///
    /// Metadata keyspace for QuickTime Metadata keys.
    ///
    /// Metadata keyspace for iTunes keys.
    ///
    /// Metadata keyspace for ID3 keys.
    ///
    /// Metadata keyspace for ShoutCast keys.
    ///
    /// Metadata keyspace for HLS DateRange tags.
    pub static kCMMetadataKeySpace_QuickTimeUserData: &'static CFString;
}

extern "C" {
    /// Metadata keyspace for MPEG-4 User Data keys.
    ///
    /// ## Discussion
    ///
    /// This keyspace defines its key values to be expressed as `OSType`s (a.k.a. `FourCharCode`s). As such, keys must be four bytes in length.
    ///
    ///
    pub static kCMMetadataKeySpace_ISOUserData: &'static CFString;
}

extern "C" {
    /// Metadata keyspace for QuickTime Metadata keys.
    ///
    /// ## Discussion
    ///
    /// This keyspace defines its key values to be expressed as reverse-DNS strings, which allows third parties to define their own keys in a well established way that avoids collisions.
    ///
    ///
    pub static kCMMetadataKeySpace_QuickTimeMetadata: &'static CFString;
}

extern "C" {
    /// Metadata keyspace for iTunes keys.
    ///
    /// ## Discussion
    ///
    /// This keyspace defines its key values to be expressed as `OSType`s (a.k.a. `FourCharCode`s). As such, keys must be four bytes in length.
    ///
    ///
    pub static kCMMetadataKeySpace_iTunes: &'static CFString;
}

extern "C" {
    /// Metadata keyspace for ID3 keys.
    ///
    /// ## Discussion
    ///
    /// This keyspace defines its key values to be expressed as `OSType`s (a.k.a. `FourCharCode`s). As such, keys must be four bytes in length.
    ///
    ///
    pub static kCMMetadataKeySpace_ID3: &'static CFString;
}

extern "C" {
    /// Metadata keyspace for ShoutCast keys.
    pub static kCMMetadataKeySpace_Icy: &'static CFString;
}

extern "C" {
    /// Metadata keyspace for HLS DateRange tags.
    pub static kCMMetadataKeySpace_HLSDateRange: &'static CFString;
}

extern "C" {
    /// Location information in ISO-6709 format.
    /// Location information in ISO-6709 format.
    ///
    /// Direction the observer is facing.
    pub static kCMMetadataIdentifier_QuickTimeMetadataLocation_ISO6709: &'static CFString;
}

extern "C" {
    /// Direction the observer is facing.
    pub static kCMMetadataIdentifier_QuickTimeMetadataDirection_Facing: &'static CFString;
}

extern "C" {
    /// An affine transform to be applied to a video track.
    ///
    /// ## Discussion
    ///
    /// This affine transform can be used in place of a track matrix for displaying a video track to better reflect the current orientation of a video camera with respect to a scene. For example, if the camera is rotated after a recording has started, the presence of this metadata will allow a player to adjust its rendering at the time the rotation occurred.
    ///
    ///
    /// An affine transform that can be used in place of a track matrix for
    /// displaying a video track, to better reflect the current orientation
    /// of a video camera with respect to a scene.  For example, if the camera
    /// is rotated after a recording has started, the presence of this metadata
    /// will allow a player to adjust its rendering at the time the rotation occurred.
    pub static kCMMetadataIdentifier_QuickTimeMetadataPreferredAffineTransform: &'static CFString;
}

extern "C" {
    /// Video orientation as defined by TIFF/EXIF.
    ///
    /// ## Discussion
    ///
    /// For possible values and their meanings, see [`kCGImagePropertyOrientation`](https://developer.apple.com/documentation/imageio/kcgimagepropertyorientation).
    ///
    ///
    /// Video orientation as defined by TIFF/EXIF, which is enumerated by CGImagePropertyOrientation
    /// (see
    /// <ImageIO
    /// /CGImageProperties.h>).
    pub static kCMMetadataIdentifier_QuickTimeMetadataVideoOrientation: &'static CFString;
}

extern "C" {
    /// A perspective transform you use to adjust a Live Photo still image to match the Live Photo movie.
    /// A perspective transform that can be used to adjust a Live Photo still image to match the Live Photo movie.
    /// Expected data type is kCMMetadataBaseDataType_PerspectiveTransformF64.
    pub static kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransform:
        &'static CFString;
}

extern "C" {
    /// The dimensions of the live photo still image.
    /// The dimensions of the image used to generate kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransform.
    /// Expected data type is kCMMetadataBaseDataType_DimensionsF32.
    pub static kCMMetadataIdentifier_QuickTimeMetadataLivePhotoStillImageTransformReferenceDimensions:
        &'static CFString;
}

extern "C" {
    /// A segment identifier, used to support movies where pause/resume has been used.
    /// Expected data type is kCMMetadataDataType_QuickTimeMetadataUUID.
    pub static kCMMetadataIdentifier_QuickTimeMetadataSegmentIdentifier: &'static CFString;
}

extern "C" {
    /// Scene illuminance measured in units of Lux.
    /// Expected data type is kCMMetadataDataType_QuickTimeMetadataMilliLux.
    pub static kCMMetadataIdentifier_QuickTimeMetadataSceneIlluminance: &'static CFString;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// ```text
    /// Data associated with a Spatial Audio capture that contains an analysis of a First Order Ambisonics audio stream which is used for playback.
    /// ```
    ///
    ///
    /// Data associated with a Spatial Audio capture that contains an analysis of a First Order Ambisonics audio stream which is used for playback.
    pub static kCMMetadataIdentifier_QuickTimeMetadataSpatialAudioMix: &'static CFString;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// ```text
    ///     Display mask rectangle for monoscopic video
    ///     Expected data type is kCMMetadataBaseDataType_RasterRectangleValue.
    /// ```
    ///
    ///
    /// Display mask rectangle for monoscopic video
    /// Expected data type is kCMMetadataBaseDataType_RasterRectangleValue.
    pub static kCMMetadataIdentifier_QuickTimeMetadataDisplayMaskRectangleMono: &'static CFString;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// ```text
    ///     Display mask rectangle for stereoscopic video's left eye view
    ///     Expected data type is kCMMetadataBaseDataType_RasterRectangleValue or kCMMetadataBaseDataType_ExtendedRasterRectangleValue.
    /// ```
    ///
    ///
    /// Display mask rectangle for stereoscopic video's left eye view
    /// Expected data type is kCMMetadataBaseDataType_RasterRectangleValue or kCMMetadataBaseDataType_ExtendedRasterRectangleValue.
    pub static kCMMetadataIdentifier_QuickTimeMetadataDisplayMaskRectangleStereoLeft:
        &'static CFString;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// ```text
    ///     Display mask rectangle for stereoscopic video's right eye view
    ///     Expected data type is kCMMetadataBaseDataType_RasterRectangleValue or kCMMetadataBaseDataType_ExtendedRasterRectangleValue.
    /// ```
    ///
    ///
    /// Display mask rectangle for stereoscopic video's right eye view
    /// Expected data type is kCMMetadataBaseDataType_RasterRectangleValue or kCMMetadataBaseDataType_ExtendedRasterRectangleValue.
    pub static kCMMetadataIdentifier_QuickTimeMetadataDisplayMaskRectangleStereoRight:
        &'static CFString;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Presentation data associated with Apple Immersive Video’s video frames. Data is a JSON-encoding of ImmersiveMediaSupport framework’s PresentationDescriptor object. Expected data type is kCMMetadataBaseDataType_RawData.
    ///
    ///
    /// Presentation data associated with Apple Immersive Video's video frames. Data is a JSON-encoding of ImmersiveMediaSupport framework's PresentationDescriptor object.
    /// Expected data type is kCMMetadataBaseDataType_RawData.
    pub static kCMMetadataIdentifier_QuickTimeMetadataPresentationImmersiveMedia: &'static CFString;
}

extern "C-unwind" {
    /// Creates a URL-like string identifier that represents a key or keyspace tuple.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for creating the identifier.
    ///
    /// - key: Key data; may be `CFString`, `CFNumber`, or `CFData`.
    ///
    /// - keySpace: Keyspace; must be string of one to four printable ASCII characters.
    ///
    /// - identifierOut: Upon return, a pointer to the created identifier.
    ///
    ///
    /// ## Return Value
    ///
    /// If successful, a nonzero result code. See [Metadata Identifier Error Codes](https://developer.apple.com/documentation/coremedia/metadata-identifier-errors).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Metadata entities are identified by a key whose interpretation is defined by its keyspace. When writing metadata to a QuickTime Movie, this tuple is part of the track’s format description.
    ///
    /// See [Metadata Identifier Keyspaces](https://developer.apple.com/documentation/coremedia/metadata-identifier-keyspaces) for the current list of supported keyspaces and the requirements for key values in each keyspace.
    ///
    /// As a matter of convenience, known keyspaces allow for a key to be passed in using a variety of `CFType`s. Note that what is returned by [`CMMetadataCreateKeyFromIdentifier`](https://developer.apple.com/documentation/coremedia/cmmetadatacreatekeyfromidentifier(allocator:identifier:keyout:)) depends upon the keyspace, and may be a different `CFType` than what is passed to this routine (see the discussion below for what `CFType`s are returned for known keyspaces). To get a key represented as `CFData`, call [`CMMetadataCreateKeyFromIdentifierAsCFData`](https://developer.apple.com/documentation/coremedia/cmmetadatacreatekeyfromidentifierascfdata(allocator:identifier:keyout:)).
    ///
    /// Some keyspaces use `OSType`s (a.k.a. `FourCharCode`s) to define their keys, and as such their keys are four bytes in length. For these keyspaces, a key may be passed as a `CFNumber`, a `CFString`, or a `CFData`. A key passed as a `CFNumber` will have its value retrieved as [`kCFNumberSInt32Type`](https://developer.apple.com/documentation/corefoundation/cfnumbertype/sint32type) comprising the four bytes of the key’s numeric value in big-endian byte order. A key passed as a `CFString` must be a valid ASCII string of four characters. A key passed as a `CFData` must be comprised of the four bytes of the key’s numeric value in big-endian byte order.
    ///
    /// All other keyspaces allow the key to be passed as a `CFString` or `CFData`. In both cases, the key will be interpreted as an ASCII string for the purposes of identifier encoding.
    ///
    ///
    /// Creates a URL-like string identifier that represents a key/keyspace tuple.
    ///
    /// Metadata entities are identified by a key whose interpretation
    /// is defined by its keyspace.  When writing metadata to a QuickTime
    /// Movie, this tuple is part of the track's format description.
    ///
    /// The following constants make up the current list of supported keyspaces,
    /// which are documented elsewhere in this file:
    /// <ul>
    /// kCMMetadataKeySpace_QuickTimeUserData
    /// <li>
    /// kCMMetadataKeySpace_ISOUserData
    /// <li>
    /// kCMMetadataKeySpace_iTunes
    /// <li>
    /// kCMMetadataKeySpace_ID3
    /// <li>
    /// kCMMetadataKeySpace_QuickTimeMetadata
    /// <li>
    /// kCMMetadataKeySpace_Icy
    /// </ul>
    /// Some keyspaces use OSTypes (a.k.a. FourCharCodes) to define their
    /// keys, and as such their keys are four bytes in length. The keyspaces
    /// that fall into this category are: kCMMetadataKeySpace_QuickTimeUserData,
    /// kCMMetadataKeySpace_ISOUserData, kCMMetadataKeySpace_iTunes, and
    /// kCMMetadataKeySpace_ID3.
    ///
    /// The keyspace kCMMetadataKeySpace_QuickTimeMetadata defines its
    /// key values to be expressed as reverse-DNS strings, which allows
    /// third parties to define their own keys in a well established way
    /// that avoids collisions.
    ///
    /// As a matter of convenience, known keyspaces allow for a key
    /// to be passed in using a variety of CFTypes.  Note that what
    /// is returned by CMMetadataCreateKeyFromIdentifier depends upon the
    /// keyspace, and may be a different CFType than what is passed
    /// to this routine (see the discussion below for what CFTypes are
    /// returned for known keyspaces).  To get a key represented as
    /// CFData, call CMMetadataCreateKeyFromIdentifierAsCFData.
    ///
    /// For OSType keyspaces, a key may be passed as a CFNumber,
    /// a CFString, or a CFData. A key passed as a CFNumber will have
    /// its value retrieved as kCFNumberSInt32Type comprising the four
    /// bytes of the key’s numeric value in big-endian byte order.
    /// A key passed as a CFString must be a valid ASCII string of four
    /// characters. A key passed as a CFData must be comprised of the
    /// four bytes of the key’s numeric value in big-endian byte order.
    ///
    /// All other keyspaces allow the key to be passed as a CFString
    /// or CFData. In both cases, the key will be interpreted as an
    /// ASCII string for the purposes of identifier encoding.
    ///
    /// # Safety
    ///
    /// - `key` should be of the correct type.
    /// - `identifier_out` must be a valid pointer.
    pub fn CMMetadataCreateIdentifierForKeyAndKeySpace(
        allocator: Option<&CFAllocator>,
        key: &CFType,
        key_space: &CFString,
        identifier_out: NonNull<*const CFString>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a copy of the key by using an identifier.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for creating the identifier.
    ///
    /// - identifier: The identifier to be inspected.
    ///
    /// - keyOut: Upon return, a pointer to the key data that was used to create the identifier.
    ///
    ///
    /// ## Return Value
    ///
    /// If successful, a nonzero result code. See [Metadata Identifier Error Codes](https://developer.apple.com/documentation/coremedia/metadata-identifier-errors).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The returned `CFType` is based on the keyspace encoded in the identifier.
    ///
    /// For `OSType` keyspaces, the key will be returned as a `CFNumber`, where a big endian interpretation of its [`kCFNumberSInt32Type`](https://developer.apple.com/documentation/corefoundation/cfnumbertype/sint32type) value represents the four bytes of the key’s numeric value.
    ///
    /// For the keyspaces [`kCMMetadataKeySpace_QuickTimeMetadata`](https://developer.apple.com/documentation/coremedia/kcmmetadatakeyspace_quicktimemetadata) and [`kCMMetadataKeySpace_Icy`](https://developer.apple.com/documentation/coremedia/kcmmetadatakeyspace_icy), the key will be returned as a `CFString`.
    ///
    /// All other keyspaces will have the function return the key as a `CFData`.
    ///
    ///
    /// Creates a copy of the key encoded in the identifier as a CFType.
    ///
    /// The returned CFType is based on the keyspace encoded in the identifier.
    ///
    /// For OSType keyspaces, the key will be returned as a CFNumber,
    /// where a big endian interpretation of its kCFNumberSInt32Type value
    /// represents the four bytes of the key's numeric value.
    ///
    /// For the keyspaces kCMMetadataKeySpace_QuickTimeMetadata and
    /// kCMMetadataKeySpace_Icy, the key will be returned as a CFString.
    ///
    /// All other keyspaces will have the function return the key as a CFData.
    ///
    /// # Safety
    ///
    /// `key_out` must be a valid pointer.
    pub fn CMMetadataCreateKeyFromIdentifier(
        allocator: Option<&CFAllocator>,
        identifier: &CFString,
        key_out: NonNull<*const CFType>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a copy of the key by using an identifier, and results in a core foundation data object.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for creating the identifier.
    ///
    /// - identifier: The identifier to be inspected.
    ///
    /// - keyOut: Upon return, a pointer to the key data that was used to create the identifier.
    ///
    ///
    /// ## Return Value
    ///
    /// If successful, a nonzero result code. See [Metadata Identifier Error Codes](https://developer.apple.com/documentation/coremedia/metadata-identifier-errors).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The bytes in the `CFData` correspond to how they are serialized in the file.
    ///
    ///
    /// Creates a copy of the key value that was encoded in the identifier as CFData.
    /// The bytes in the CFData correpsond to how they are serialized in the file.
    ///
    /// # Safety
    ///
    /// `key_out` must be a valid pointer.
    pub fn CMMetadataCreateKeyFromIdentifierAsCFData(
        allocator: Option<&CFAllocator>,
        identifier: &CFString,
        key_out: NonNull<*const CFData>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a copy of the keyspace by using an identifier.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for creating the identifier.
    ///
    /// - identifier: The identifier to be inspected.
    ///
    /// - keySpaceOut: Upon return, a pointer to the keyspace that was used to create the identifier.
    ///
    ///
    /// ## Return Value
    ///
    /// If successful, a nonzero result code. See [Metadata Identifier Error Codes](https://developer.apple.com/documentation/coremedia/metadata-identifier-errors).
    ///
    ///
    /// Creates a copy of the key value that was encoded in the identifier as CFData.
    ///
    /// # Safety
    ///
    /// `key_space_out` must be a valid pointer.
    pub fn CMMetadataCreateKeySpaceFromIdentifier(
        allocator: Option<&CFAllocator>,
        identifier: &CFString,
        key_space_out: NonNull<*const CFString>,
    ) -> OSStatus;
}

extern "C" {
    /// A sequence of bytes whose interpretation based upon an agreement between the reader and the writer.
    /// A sequence of bytes whose interpretation based upon an agreement between
    /// the reader and the writer.
    ///
    /// UTF-8 string.
    ///
    /// UTF-16 string.
    ///
    /// GIF image.
    ///
    /// JPEG image.
    ///
    /// PNG image.
    ///
    /// BMP image.
    ///
    /// 32-bit big endian floating point number.
    ///
    /// 64-bit big endian floating point number.
    ///
    /// 8-bit signed integer.
    ///
    /// 16-bit big endian signed integer.
    ///
    /// 32-bit big endian signed integer.
    ///
    /// 64-bit big endian signed integer.
    ///
    /// 8-bit unsigned integer.
    ///
    /// 16-bit big endian unsigned integer.
    ///
    /// 32-bit big endian unsigned integer.
    ///
    /// 64-bit big endian unsigned integer.
    ///
    /// Consists of two 32-bit big endian floating point values, the x and y values, respectively.
    ///
    /// Consists of a 32-bit big endian floating point x value followed by a 32-bit floating point y value.
    ///
    /// Consists of four 32-bit big endian floating point values, the origin's x, origin's y, width and height values, respectively.
    /// May also be interpreted as a 32-bit floating point origin followed by a 32-bit floating point dimension.
    ///
    /// A 3x3 matrix of 64-bit big endian floating point numbers stored in row-major order that specify an affine transform.
    ///
    /// Three or more pairs of 32-bit floating point numbers (x and y values) that define the verticies of a polygon.
    ///
    /// Two or more pairs of 32-bit floating point numbers (x and y values) that define a multi-segmented line.
    ///
    /// UTF-8 encoded JSON data.
    ///
    /// A 3x3 matrix of 64-bit big endian floating point numbers stored in row-major order that specify a perspective transform.
    ///
    /// Consists of six 16-bit big endian unsigned integer values of RasterRectangleValue in the following order: raster width, raster height, left, width, top, height.
    /// Rectangle origin and dimension are normalized to raster rectangle coordinates to be pixel accurate but still retain the relative semantics when scaled.
    ///
    /// Consists of at least six 16-bit big endian unsigned integer values for RasterRectangleValue in the same order as kCMMetadataBaseDataType_RasterRectangleValue and then two 4-bit values for the number of left and right edge adjustment points. If edge adustment points are 2 or more, points would be pairs of 16-bit big endian unsigned integers alternating between x and y with left edge points first and right edge points afterwards.
    /// Rectangle origin and dimension are normalized to raster rectangle coordinates to be pixel accurate but still retain the relative semantics when scaled.
    pub static kCMMetadataBaseDataType_RawData: &'static CFString;
}

extern "C" {
    /// UTF-8 string.
    pub static kCMMetadataBaseDataType_UTF8: &'static CFString;
}

extern "C" {
    /// UTF-16 string.
    pub static kCMMetadataBaseDataType_UTF16: &'static CFString;
}

extern "C" {
    /// GIF image.
    pub static kCMMetadataBaseDataType_GIF: &'static CFString;
}

extern "C" {
    /// JPEG image.
    pub static kCMMetadataBaseDataType_JPEG: &'static CFString;
}

extern "C" {
    /// PNG image.
    pub static kCMMetadataBaseDataType_PNG: &'static CFString;
}

extern "C" {
    /// BMP image.
    pub static kCMMetadataBaseDataType_BMP: &'static CFString;
}

extern "C" {
    /// 32-bit big endian floating point number.
    pub static kCMMetadataBaseDataType_Float32: &'static CFString;
}

extern "C" {
    /// 64-bit big endian floating point number.
    pub static kCMMetadataBaseDataType_Float64: &'static CFString;
}

extern "C" {
    /// 8-bit signed integer.
    pub static kCMMetadataBaseDataType_SInt8: &'static CFString;
}

extern "C" {
    /// 16-bit big endian signed integer.
    pub static kCMMetadataBaseDataType_SInt16: &'static CFString;
}

extern "C" {
    /// 32-bit big endian signed integer.
    pub static kCMMetadataBaseDataType_SInt32: &'static CFString;
}

extern "C" {
    /// 64-bit big endian signed integer.
    pub static kCMMetadataBaseDataType_SInt64: &'static CFString;
}

extern "C" {
    /// 8-bit unsigned integer.
    pub static kCMMetadataBaseDataType_UInt8: &'static CFString;
}

extern "C" {
    /// 16-bit big endian unsigned integer.
    pub static kCMMetadataBaseDataType_UInt16: &'static CFString;
}

extern "C" {
    /// 32-bit big endian unsigned integer.
    pub static kCMMetadataBaseDataType_UInt32: &'static CFString;
}

extern "C" {
    /// 64-bit big endian unsigned integer.
    pub static kCMMetadataBaseDataType_UInt64: &'static CFString;
}

extern "C" {
    /// Consists of two 32-bit big endian floating point values, the x and y values, respectively.
    pub static kCMMetadataBaseDataType_PointF32: &'static CFString;
}

extern "C" {
    /// Consists of a 32-bit big endian floating point x value followed by a 32-bit floating point y value.
    pub static kCMMetadataBaseDataType_DimensionsF32: &'static CFString;
}

extern "C" {
    /// Consists of four 32-bit big endian floating point values, the origin’s x, origin’s y, width and height values, respectively. May also be interpreted as a 32-bit floating point origin followed by a 32-bit floating point dimension.
    pub static kCMMetadataBaseDataType_RectF32: &'static CFString;
}

extern "C" {
    /// A type that identifies a 3x3 matrix of 64-bit big endian floating point numbers in a row-major order that specify an affine transform.
    pub static kCMMetadataBaseDataType_AffineTransformF64: &'static CFString;
}

extern "C" {
    /// Three or more pairs of 32-bit floating point numbers (x and y values) that define the vertices of a polygon.
    pub static kCMMetadataBaseDataType_PolygonF32: &'static CFString;
}

extern "C" {
    /// Two or more pairs of 32-bit floating point numbers (x and y values) that define a multi-segmented line.
    pub static kCMMetadataBaseDataType_PolylineF32: &'static CFString;
}

extern "C" {
    /// UTF-8 encoded JSON data.
    pub static kCMMetadataBaseDataType_JSON: &'static CFString;
}

extern "C" {
    /// A 3x3 matrix of 64-bit big endian floating point numbers the system stores in row-major order that specify a perspective transform.
    pub static kCMMetadataBaseDataType_PerspectiveTransformF64: &'static CFString;
}

extern "C" {
    pub static kCMMetadataBaseDataType_RasterRectangleValue: &'static CFString;
}

extern "C" {
    pub static kCMMetadataBaseDataType_ExtendedRasterRectangleValue: &'static CFString;
}

extern "C" {
    /// A string supplying location information in ISO-6709 format.
    ///
    /// ## Discussion
    ///
    /// Conforms to [`kCMMetadataBaseDataType_UTF8`](https://developer.apple.com/documentation/coremedia/kcmmetadatabasedatatype_utf8).
    ///
    ///
    /// A string supplying location information in ISO-6709 format.  Conforms to
    /// kCMMetadataBaseDataType_UTF8.
    ///
    /// A string supplying degrees offset from magnetic North.  Conforms to
    /// kCMMetadataBaseDataType_UTF8.
    pub static kCMMetadataDataType_QuickTimeMetadataLocation_ISO6709: &'static CFString;
}

extern "C" {
    /// A string supplying degrees offset from magnetic North.
    ///
    /// ## Discussion
    ///
    /// Conforms to [`kCMMetadataBaseDataType_UTF8`](https://developer.apple.com/documentation/coremedia/kcmmetadatabasedatatype_utf8).
    ///
    ///
    pub static kCMMetadataDataType_QuickTimeMetadataDirection: &'static CFString;
}

extern "C" {
    /// A string supplying a universally unique identifier.  Conforms to
    /// kCMMetadataBaseDataType_UTF8.
    pub static kCMMetadataDataType_QuickTimeMetadataUUID: &'static CFString;
}

extern "C" {
    /// 1/1000 of a Lux.  An unsigned value between 0 - 100,000,000.  Conforms to
    /// kCMMetadataBaseDataType_UInt32.
    pub static kCMMetadataDataType_QuickTimeMetadataMilliLux: &'static CFString;
}

extern "C-unwind" {
    /// Register a data type with the data type registry.
    ///
    /// Parameters:
    /// - dataType: Identifier of data type being registered.
    ///
    /// - description: Human-readable description of data type being registered (for aiding debugging operations).
    ///
    /// - conformingDataTypes: Data types that this data type conforms to.
    ///
    ///
    /// ## Return Value
    ///
    /// If successful, a nonzero result code. See [Metadata Registry Error Codes](https://developer.apple.com/documentation/coremedia/metadata-registry-errors).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This routine is called by clients to register a data type with the data type registry. The list of conforming data type identifiers must include a base data type. If the data type has already been registered, then it is not considered an error to re-register it as long as the list of conforming data type identifiers has the same entries as the original; otherwise an error will be returned.
    ///
    ///
    /// Register a data type with the data type registry.
    ///
    /// This routine is called by clients to register a data type with
    /// the data type registry.  The list of conforming data type identifiers
    /// must include a base data type.  If the data type has already
    /// been registered, then it is not considered an error to re-register it
    /// as long as the list of conforming data type identifiers has the same
    /// entries as the original;  otherwise an error will be returned.
    ///
    /// # Safety
    ///
    /// `conforming_data_types` generic must be of the correct type.
    pub fn CMMetadataDataTypeRegistryRegisterDataType(
        data_type: &CFString,
        description: &CFString,
        conforming_data_types: &CFArray,
    ) -> OSStatus;
}

/// Returns a Boolean value that indicates the registration status of a data type identifier.
///
/// Parameters:
/// - dataType: Identifier of the data type to be checked.
///
///
/// ## Return Value
///
/// [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) if the data type has been registered; [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) otherwise.
///
///
/// Tests a data type identifier to see if it has been registered.
#[inline]
pub unsafe extern "C-unwind" fn CMMetadataDataTypeRegistryDataTypeIsRegistered(
    data_type: &CFString,
) -> bool {
    extern "C-unwind" {
        fn CMMetadataDataTypeRegistryDataTypeIsRegistered(data_type: &CFString) -> Boolean;
    }
    let ret = unsafe { CMMetadataDataTypeRegistryDataTypeIsRegistered(data_type) };
    ret != 0
}

/// Returns the data type description if it exists.
///
/// Parameters:
/// - dataType: Identifier of the data type to be queried.
///
///
/// ## Return Value
///
/// The description of the requested data type.
///
///
/// Returns the data type's description (if any was provided when it was registered).
#[inline]
pub unsafe extern "C-unwind" fn CMMetadataDataTypeRegistryGetDataTypeDescription(
    data_type: &CFString,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn CMMetadataDataTypeRegistryGetDataTypeDescription(
            data_type: &CFString,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CMMetadataDataTypeRegistryGetDataTypeDescription(data_type) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

/// Returns the conforming data types for the data type, if any.
///
/// Parameters:
/// - dataType: Identifier of the data type to be queried.
///
///
/// ## Return Value
///
/// List of conforming data types registered for the given data type, or `NULL` if the data type has not been registered.
///
///
/// Returns the data type's conforming data types (if any were
/// provided when it was registered).
///
/// Returns: List of conforming data types registered for the given data type.
/// NULL is returned if the data type has not been registered.
#[inline]
pub unsafe extern "C-unwind" fn CMMetadataDataTypeRegistryGetConformingDataTypes(
    data_type: &CFString,
) -> CFRetained<CFArray> {
    extern "C-unwind" {
        fn CMMetadataDataTypeRegistryGetConformingDataTypes(
            data_type: &CFString,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CMMetadataDataTypeRegistryGetConformingDataTypes(data_type) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

/// Returns a Boolean value that indicates whether a data type conforms to another data type.
///
/// Parameters:
/// - dataType: Identifier of the data type to be tested.
///
/// - conformsToDataType: Identifier of the data type against which to test for conformance.
///
///
/// ## Return Value
///
/// [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) if first data type conforms to the second data type; [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) otherwise.
///
///
///
/// ## Discussion
///
/// A given data type will conform to a second data type if any of the following are true:
///
/// 1. The data type identifiers are the same.
///
/// 2. The first data type identifier’s conformance list contains the second data type identifier.
///
/// 3. A recursive search of the conforming data types for each element in the first data type’s conformance list yields the second data type identifier.
///
///
/// Checks to see if a data type conforms to another data type.
///
/// A given data type will conform to a second data type if any of
/// the following are true:
/// <ul>
/// 1. The data type identifiers are the same.
/// <li>
/// 2. The first data type identifier's conformance list contains the second data type identifier.
/// <li>
/// 3. A recursive search of the conforming data types for each element in the first
/// <li>
/// data type's conformance list yields the second data type identifer.
/// </ul>
///
/// Returns: True if the first data type conforms to the second data type.
#[inline]
pub unsafe extern "C-unwind" fn CMMetadataDataTypeRegistryDataTypeConformsToDataType(
    data_type: &CFString,
    conforms_to_data_type: &CFString,
) -> bool {
    extern "C-unwind" {
        fn CMMetadataDataTypeRegistryDataTypeConformsToDataType(
            data_type: &CFString,
            conforms_to_data_type: &CFString,
        ) -> Boolean;
    }
    let ret = unsafe {
        CMMetadataDataTypeRegistryDataTypeConformsToDataType(data_type, conforms_to_data_type)
    };
    ret != 0
}

/// Returns an array of base data type identifiers.
///
/// ## Return Value
///
/// An array of the base data types to which all others must conform.
///
///
///
/// ## Discussion
///
/// There are a set of base data types that seed the data type registry. All valid data types will have their conformance search end with a base data type.
///
///
/// Returns an array of base data type identifiers.
///
/// There are a set of base data types that seed the data type
/// registry.  All valid data types will have their conformance search
/// end with a base data type.
#[inline]
pub unsafe extern "C-unwind" fn CMMetadataDataTypeRegistryGetBaseDataTypes(
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CMMetadataDataTypeRegistryGetBaseDataTypes() -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CMMetadataDataTypeRegistryGetBaseDataTypes() };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

/// Returns a Boolean value that indicates whether a data type identifier represents a base data type.
///
/// Parameters:
/// - dataType: Identifier of the data type to be queried.
///
///
/// ## Return Value
///
/// [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) if first data type conforms to the second data type; [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) otherwise.
///
///
///
/// ## Discussion
///
/// This is simply a convenience method to test to see if a given data type identifier is in the array returned by [`CMMetadataDataTypeRegistryGetBaseDataTypes`](https://developer.apple.com/documentation/coremedia/cmmetadatadatatyperegistrygetbasedatatypes()).
///
///
/// Tests a data type identifier to see if it represents a base data type.
///
/// This is simply a convenience method to test to see if a given
/// data type identifier is in the array returned by
/// CMMetadataDataTypeRegistryGetBaseDataTypes.
#[inline]
pub unsafe extern "C-unwind" fn CMMetadataDataTypeRegistryDataTypeIsBaseDataType(
    data_type: &CFString,
) -> bool {
    extern "C-unwind" {
        fn CMMetadataDataTypeRegistryDataTypeIsBaseDataType(data_type: &CFString) -> Boolean;
    }
    let ret = unsafe { CMMetadataDataTypeRegistryDataTypeIsBaseDataType(data_type) };
    ret != 0
}

/// Returns the base data type identifier that a data type conforms to.
///
/// Parameters:
/// - dataType: Identifier of the data type to be queried.
///
///
/// ## Return Value
///
/// Identifier of the base data type to which the given data type conforms.
///
///
///
/// ## Discussion
///
/// There are a set of base data types that seed the data type registry. All valid data types will have their conformance search end with a base data type.
///
///
/// Returns the base data type identifier that the given data type
/// conforms to.
///
/// There are a set of base data types that seed the data type
/// registry.  All valid data types will have their conformance search
/// end with a base data type.
#[inline]
pub unsafe extern "C-unwind" fn CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(
    data_type: &CFString,
) -> CFRetained<CFString> {
    extern "C-unwind" {
        fn CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(
            data_type: &CFString,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CMMetadataDataTypeRegistryGetBaseDataTypeForConformingDataType(data_type) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}
