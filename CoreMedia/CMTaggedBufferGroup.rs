//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-video")]
use objc2_core_video::*;

use crate::*;

/// Error codes returned by Core Media when working with tagged buffer groups.
/// The OSStatus errors returned from the CMTaggedBufferGroup routines.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CMTaggedBufferGroupError(pub OSStatus);
impl CMTaggedBufferGroupError {
    /// Indicates a parameter to a function was of the wrong type or didn’t meet a necessary condition.
    #[doc(alias = "kCMTaggedBufferGroupError_ParamErr")]
    pub const ParamErr: Self = Self(-15780);
    /// Indicates an internal allocation failed.
    #[doc(alias = "kCMTaggedBufferGroupError_AllocationFailed")]
    pub const AllocationFailed: Self = Self(-15781);
    /// Indicates an error occurred inside of the Core Media framework.
    #[doc(alias = "kCMTaggedBufferGroupError_InternalError")]
    pub const InternalError: Self = Self(-15782);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTaggedBufferGroupError {
    const ENCODING: Encoding = OSStatus::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTaggedBufferGroupError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A reference to a tagged buffer group instance.
/// An object gathering zero or more buffers (CMSampleBuffer, CVPixelBuffer) each with a CMTagCollection.
#[doc(alias = "CMTaggedBufferGroupRef")]
#[repr(C)]
pub struct CMTaggedBufferGroup {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CMTaggedBufferGroup {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueCMTaggedBufferGroup"> for CMTaggedBufferGroup {}
);

unsafe impl ConcreteType for CMTaggedBufferGroup {
    /// Gets the internal type ID for a tagged buffer group.
    #[doc(alias = "CMTaggedBufferGroupGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetTypeID() -> CFTypeID;
        }
        unsafe { CMTaggedBufferGroupGetTypeID() }
    }
}

impl CMTaggedBufferGroup {
    /// Creates a new tagged buffer group from a pair of buffers and the tags to associate with them.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for the new tag collection. Pass `kCFAllocatorDefault` to use the default global allocator.
    ///
    /// - tagCollections: The tag collections to apply to each buffer, in order.
    ///
    /// - buffers: An array of buffer instances to place in the tagged buffer group.
    ///
    /// - groupOut: The output destination for the new tagged buffer group.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `0` on success and a value from Tagged Buffer Group Error Codes on failure.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Buffers strongly retain their references when creating a new tagged buffer group, rather than performing a copy. The number of elements in `tagCollections` and `buffers` must be the same.
    ///
    ///
    /// Creates a new tagged buffer group.
    ///
    /// Parameter `allocator`: The CFAllocator to use for allocating this buffer group.  May be NULL.
    ///
    /// Parameter `tagCollections`: A CFArray of CMTagCollections for the buffers.
    ///
    /// Parameter `buffers`: A CFArray of buffers, each of type CMSampleBuffer or CVPixelBuffer.  The group will retain these sample buffers and pixel buffers.
    /// The number of tagCollections must match the number of buffers.
    ///
    /// Parameter `groupOut`: The newly created group will be placed here.  The caller has a responsibility to call CFRelease on it.
    ///
    /// Returns: Returns noErr on success.
    ///
    /// # Safety
    ///
    /// - `tag_collections` generic must be of the correct type.
    /// - `buffers` generic must be of the correct type.
    /// - `group_out` must be a valid pointer.
    #[doc(alias = "CMTaggedBufferGroupCreate")]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        tag_collections: &CFArray,
        buffers: &CFArray,
        group_out: NonNull<*mut CMTaggedBufferGroup>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTaggedBufferGroupCreate(
                allocator: Option<&CFAllocator>,
                tag_collections: &CFArray,
                buffers: &CFArray,
                group_out: NonNull<*mut CMTaggedBufferGroup>,
            ) -> OSStatus;
        }
        unsafe { CMTaggedBufferGroupCreate(allocator, tag_collections, buffers, group_out) }
    }

    /// Creates a new tagged buffer group from an array of existing tagged buffer groups.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for the new tag collection. Pass `kCFAllocatorDefault` to use the default global allocator.
    ///
    /// - taggedBufferGroups: An array of tagged buffer groups to combine into the new, single buffer group.
    ///
    /// - groupOut: The output destination for the new tagged buffer group.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `0` on success and a value from Tagged Buffer Group Error Codes on failure.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Buffers strongly retain their references when creating a new tagged buffer group, rather than performing a copy.
    ///
    ///
    /// Creates a new tagged buffer group by combining all the tagged buffer groups in an array.
    ///
    /// Parameter `allocator`: The CFAllocator to use for allocating this buffer group.  May be NULL.
    ///
    /// Parameter `taggedBufferGroups`: A CFArray of CMTaggedBufferGroups.
    ///
    /// Parameter `groupOut`: The newly created group will be placed here.  The caller has a responsibility to call CFRelease on it.
    ///
    /// Returns: Returns noErr on success.
    ///
    /// # Safety
    ///
    /// - `tagged_buffer_groups` generic must be of the correct type.
    /// - `group_out` must be a valid pointer.
    #[doc(alias = "CMTaggedBufferGroupCreateCombined")]
    #[inline]
    pub unsafe fn create_combined(
        allocator: Option<&CFAllocator>,
        tagged_buffer_groups: &CFArray,
        group_out: NonNull<*mut CMTaggedBufferGroup>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTaggedBufferGroupCreateCombined(
                allocator: Option<&CFAllocator>,
                tagged_buffer_groups: &CFArray,
                group_out: NonNull<*mut CMTaggedBufferGroup>,
            ) -> OSStatus;
        }
        unsafe { CMTaggedBufferGroupCreateCombined(allocator, tagged_buffer_groups, group_out) }
    }

    /// Gets the number of buffers contained within a tagged buffer group.
    /// Returns the number of buffers in a CMTaggedBufferGroup.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the count from.
    ///
    /// Returns: Returns the number of buffers, or 0 on failure or if the group is empty.
    #[doc(alias = "CMTaggedBufferGroupGetCount")]
    #[cfg(feature = "CMBase")]
    #[inline]
    pub unsafe fn count(&self) -> CMItemCount {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCount(group: &CMTaggedBufferGroup) -> CMItemCount;
        }
        unsafe { CMTaggedBufferGroupGetCount(self) }
    }

    /// Gets the collection of tags for a buffer at a given index in the group.
    /// Returns a CMTagCollection from a CMTaggedBufferGroup by sequential indexing.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the tag collection from.
    ///
    /// Parameter `index`: An index from 0 to count-1.
    ///
    /// Returns: Returns the tag collection, or NULL on failure.
    #[doc(alias = "CMTaggedBufferGroupGetTagCollectionAtIndex")]
    #[cfg(feature = "CMTagCollection")]
    #[inline]
    pub unsafe fn tag_collection_at_index(
        &self,
        index: CFIndex,
    ) -> Option<CFRetained<CMTagCollection>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetTagCollectionAtIndex(
                group: &CMTaggedBufferGroup,
                index: CFIndex,
            ) -> Option<NonNull<CMTagCollection>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetTagCollectionAtIndex(self, index) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Gets the pixel buffer at a given index in the buffer group.
    ///
    /// ## Return Value
    ///
    /// Returns the sample buffer at index, or `NULL` if the index is out of bounds or points to a sample buffer.
    ///
    ///
    /// Returns a CVPixelBuffer from a CMTaggedBufferGroup by sequential indexing.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CVPixelBuffer from.
    ///
    /// Parameter `index`: An index from 0 to count-1.
    ///
    /// Returns: Returns the CVPixelBuffer, or NULL on failure (including if the buffer at this index is not a CVPixelBuffer).
    #[doc(alias = "CMTaggedBufferGroupGetCVPixelBufferAtIndex")]
    #[cfg(feature = "objc2-core-video")]
    #[inline]
    pub unsafe fn cv_pixel_buffer_at_index(
        &self,
        index: CFIndex,
    ) -> Option<CFRetained<CVPixelBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCVPixelBufferAtIndex(
                group: &CMTaggedBufferGroup,
                index: CFIndex,
            ) -> Option<NonNull<CVPixelBuffer>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetCVPixelBufferAtIndex(self, index) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Gets the single pixel buffer in a group which contains a given tag, if present.
    ///
    /// Parameters:
    /// - group: The tagged buffer group to inspect.
    ///
    /// - tag: The tag to match in the buffer group.
    ///
    /// - indexOut: A pointer to the index of the retrieved pixel buffer. The value of indexOut is `NULL` when the function returns `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the unique pixel buffer associated with tag, or `NULL` if there were multiple pixel buffers or no pixel buffer could be found.
    ///
    ///
    /// Returns a CVPixelBuffer from a CMTaggedBufferGroup by looking for a unique match for the provided tag.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CVPixelBuffer from.
    ///
    /// Parameter `tag`: The tag to look up.  If more than one buffer's tag collection includes this tag, the lookup will fail.
    ///
    /// Parameter `indexOut`: On success, index of the returned CVPixelBuffer.  May be NULL.
    ///
    /// Returns: Returns the CVPixelBuffer, or NULL on failure (including if the buffer at this index is not a CVPixelBuffer).
    ///
    /// # Safety
    ///
    /// `index_out` must be a valid pointer or null.
    #[doc(alias = "CMTaggedBufferGroupGetCVPixelBufferForTag")]
    #[cfg(all(feature = "CMTag", feature = "objc2-core-video"))]
    #[inline]
    pub unsafe fn cv_pixel_buffer_for_tag(
        &self,
        tag: CMTag,
        index_out: *mut CFIndex,
    ) -> Option<CFRetained<CVPixelBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCVPixelBufferForTag(
                group: &CMTaggedBufferGroup,
                tag: CMTag,
                index_out: *mut CFIndex,
            ) -> Option<NonNull<CVPixelBuffer>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetCVPixelBufferForTag(self, tag, index_out) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Gets the single pixel buffer in a group which contains a given tag collection, if present.
    ///
    /// Parameters:
    /// - group: The tagged buffer group to inspect.
    ///
    /// - tagCollection: The tag collection to match in the buffer group.
    ///
    /// - indexOut: A pointer to the index of the retrieved pixel buffer. The value of indexOut is `NULL` when the function returns `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the unique pixel buffer associated with `tagCollection`, or `NULL` if there were multiple pixel buffers or no pixel buffer could be found.
    ///
    ///
    /// Returns a CVPixelBuffer from a CMTaggedBufferGroup by looking for a unique match for the provided tag collection.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CVPixelBuffer from.
    ///
    /// Parameter `tagCollection`: The tag collection to look up.  If more than one buffer's tag collection includes this tag collection, the lookup will fail.
    ///
    /// Parameter `indexOut`: On success, index of the returned CVPixelBuffer.  May be NULL.
    ///
    /// Returns: Returns the CVPixelBuffer, or NULL on failure (including if the buffer at this index is not a CVPixelBuffer).
    ///
    /// # Safety
    ///
    /// `index_out` must be a valid pointer or null.
    #[doc(alias = "CMTaggedBufferGroupGetCVPixelBufferForTagCollection")]
    #[cfg(all(feature = "CMTagCollection", feature = "objc2-core-video"))]
    #[inline]
    pub unsafe fn cv_pixel_buffer_for_tag_collection(
        &self,
        tag_collection: &CMTagCollection,
        index_out: *mut CFIndex,
    ) -> Option<CFRetained<CVPixelBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCVPixelBufferForTagCollection(
                group: &CMTaggedBufferGroup,
                tag_collection: &CMTagCollection,
                index_out: *mut CFIndex,
            ) -> Option<NonNull<CVPixelBuffer>>;
        }
        let ret = unsafe {
            CMTaggedBufferGroupGetCVPixelBufferForTagCollection(self, tag_collection, index_out)
        };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Gets the sample buffer at a given index in the buffer group.
    ///
    /// ## Return Value
    ///
    /// Returns the sample buffer at index, or `NULL` if the index is out of bounds or points to a pixel buffer.
    ///
    ///
    /// Returns a CMSampleBuffer from a CMTaggedBufferGroup by sequential indexing.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CMSampleBuffer from.
    ///
    /// Parameter `index`: An index from 0 to count-1.
    ///
    /// Returns: Returns the CMSampleBuffer, or NULL on failure (including if the buffer at this index is not a CMSampleBuffer).
    #[doc(alias = "CMTaggedBufferGroupGetCMSampleBufferAtIndex")]
    #[cfg(feature = "CMSampleBuffer")]
    #[inline]
    pub unsafe fn cm_sample_buffer_at_index(
        &self,
        index: CFIndex,
    ) -> Option<CFRetained<CMSampleBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCMSampleBufferAtIndex(
                group: &CMTaggedBufferGroup,
                index: CFIndex,
            ) -> Option<NonNull<CMSampleBuffer>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetCMSampleBufferAtIndex(self, index) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Gets the single sample buffer in a group which contains a given tag, if present.
    ///
    /// Parameters:
    /// - group: The tagged buffer group to inspect.
    ///
    /// - tag: The tag to match in the buffer group.
    ///
    /// - indexOut: A pointer to the index of the retrieved sample buffer. The value of indexOut is `NULL` when the function returns `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the unique sample buffer associated with tag, or `NULL` if there were multiple sample buffers or no sample buffer could be found.
    ///
    ///
    /// Returns a CMSampleBuffer from a CMTaggedBufferGroup by looking for a unique match for the provided tag.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CMSampleBuffer from.
    ///
    /// Parameter `tag`: The tag to look up.  If more than one buffer's tag collection includes this tag, the lookup will fail.
    ///
    /// Parameter `indexOut`: On success, index of the returned CMSampleBuffer.  May be NULL.
    ///
    /// Returns: Returns the CMSampleBuffer, or NULL on failure (including if the buffer at this index is not a CMSampleBuffer).
    ///
    /// # Safety
    ///
    /// `index_out` must be a valid pointer or null.
    #[doc(alias = "CMTaggedBufferGroupGetCMSampleBufferForTag")]
    #[cfg(all(feature = "CMSampleBuffer", feature = "CMTag"))]
    #[inline]
    pub unsafe fn cm_sample_buffer_for_tag(
        &self,
        tag: CMTag,
        index_out: *mut CFIndex,
    ) -> Option<CFRetained<CMSampleBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCMSampleBufferForTag(
                group: &CMTaggedBufferGroup,
                tag: CMTag,
                index_out: *mut CFIndex,
            ) -> Option<NonNull<CMSampleBuffer>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetCMSampleBufferForTag(self, tag, index_out) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Gets the single sample buffer in a group which contains a given tag collection, if present.
    ///
    /// Parameters:
    /// - group: The tagged buffer group to inspect.
    ///
    /// - tagCollection: The tag collection to match in the buffer group.
    ///
    /// - indexOut: A pointer to the index of the retrieved sample buffer. The value of indexOut is `NULL` when the function returns `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the unique sample buffer associated with `tagCollection`, or `NULL` if there were multiple sample buffers or no sample buffer could be found.
    ///
    ///
    /// Returns a CMSampleBuffer from a CMTaggedBufferGroup by looking for a unique match for the provided tag collection.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CMSampleBuffer from.
    ///
    /// Parameter `tagCollection`: The tag collection to look up.  If more than one buffer's tag collection includes this tag collection, the lookup will fail.
    ///
    /// Parameter `indexOut`: On success, index of the returned CMSampleBuffer.  May be NULL.
    ///
    /// Returns: Returns the CMSampleBuffer, or NULL on failure (including if the buffer at this index is not a CMSampleBuffer).
    ///
    /// # Safety
    ///
    /// `index_out` must be a valid pointer or null.
    #[doc(alias = "CMTaggedBufferGroupGetCMSampleBufferForTagCollection")]
    #[cfg(all(feature = "CMSampleBuffer", feature = "CMTagCollection"))]
    #[inline]
    pub unsafe fn cm_sample_buffer_for_tag_collection(
        &self,
        tag_collection: &CMTagCollection,
        index_out: *mut CFIndex,
    ) -> Option<CFRetained<CMSampleBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCMSampleBufferForTagCollection(
                group: &CMTaggedBufferGroup,
                tag_collection: &CMTagCollection,
                index_out: *mut CFIndex,
            ) -> Option<NonNull<CMSampleBuffer>>;
        }
        let ret = unsafe {
            CMTaggedBufferGroupGetCMSampleBufferForTagCollection(self, tag_collection, index_out)
        };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Gets the number of buffers in the group associated with a given tag collection.
    ///
    /// Parameters:
    /// - group: The tagged buffer group to inspect.
    ///
    /// - tagCollection: The collection of tags to search the buffer group for.
    ///
    ///
    /// ## Discussion
    ///
    /// When this function returns a value other than `1`, avoid using the `tagCollection` to retrieve a buffer from this group. The results of retrieving a buffer with `tagCollection` is `NULL`, since either the group doesn’t contain those tags or the match is ambiguous.
    ///
    ///
    /// Returns the number of matches that a tag collection has in a CMTaggedBufferGroup.
    ///
    /// If the returned count is less than or greater than 1, buffer lookups using this tag collection will fail and return NULL, since the lookups must be unique and unambiguous.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to examine.
    ///
    /// Parameter `tagCollection`: The tag collection to look up.
    ///
    /// Returns: Returns the number of entries in the CMTaggedBufferGroup that match tagCollection.
    #[doc(alias = "CMTaggedBufferGroupGetNumberOfMatchesForTagCollection")]
    #[cfg(all(feature = "CMBase", feature = "CMTagCollection"))]
    #[inline]
    pub unsafe fn number_of_matches_for_tag_collection(
        &self,
        tag_collection: &CMTagCollection,
    ) -> CMItemCount {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetNumberOfMatchesForTagCollection(
                group: &CMTaggedBufferGroup,
                tag_collection: &CMTagCollection,
            ) -> CMItemCount;
        }
        unsafe { CMTaggedBufferGroupGetNumberOfMatchesForTagCollection(self, tag_collection) }
    }

    /// Creates a new format description for a tagged buffer group.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for the format description. Pass `kCFAllocatorDefault` to use the default global allocator.
    ///
    /// - taggedBufferGroup: The tagged buffer group to inspect.
    ///
    /// - formatDescriptionOut: The output destination for the new format description.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `0` on success and a value from Tagged Buffer Group Error Codes on failure.
    ///
    ///
    /// Creates a format description for a CMTaggedBufferGroup.
    ///
    /// Parameter `allocator`: CFAllocator to be used when creating the CMFormatDescription. Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// Parameter `taggedBufferGroup`: The tagged buffer group for which we are creating the format description.
    ///
    /// Parameter `formatDescriptionOut`: Returned newly-created tagged buffer group CMFormatDescription
    ///
    /// The returned CMTaggedBufferGroupFormatDescription could be used to create a CMSampleBuffer
    /// wrapping the CMTaggedBufferGroup using CMSampleBufferCreateForTaggedBufferGroup.
    /// If you are going to call CMSampleBufferCreateForTaggedBufferGroup on a series of matching
    /// CMTaggedBufferGroups, it is more efficient to create the CMTaggedBufferGroupFormatDescription
    /// once and use it for all of the CMSampleBuffers.
    /// The caller owns the returned CMFormatDescription, and must release it when done with it.
    ///
    /// # Safety
    ///
    /// `format_description_out` must be a valid pointer.
    #[doc(alias = "CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup")]
    #[cfg(feature = "CMFormatDescription")]
    #[inline]
    pub unsafe fn format_description_create_for_tagged_buffer_group(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup(
                allocator: Option<&CFAllocator>,
                tagged_buffer_group: &CMTaggedBufferGroup,
                format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
            ) -> OSStatus;
        }
        unsafe {
            CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup(
                allocator,
                tagged_buffer_group,
                format_description_out,
            )
        }
    }

    ///
    /// Parameters:
    /// - allocator: CFAllocator to be used when creating the CMFormatDescription. Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// - taggedBufferGroup: The tagged buffer group for which we are creating the format description.
    ///
    /// - extensions: Dictionary of extension key/value pairs.  Keys are always CFStrings. Values are always property list objects (ie. CFData, CFString, CFArray, CFDictionary, CFDate, CFBoolean, or CFNumber). Can be NULL.
    ///
    /// - formatDescriptionOut: Returned newly-created tagged buffer group CMFormatDescription
    ///
    ///
    /// ## Discussion
    ///
    /// Creates a format description for a CMTaggedBufferGroup with extensions.
    ///
    /// The returned CMTaggedBufferGroupFormatDescription could be used to create a CMSampleBuffer wrapping the CMTaggedBufferGroup using CMSampleBufferCreateForTaggedBufferGroup. If you are going to call CMSampleBufferCreateForTaggedBufferGroup on a series of matching CMTaggedBufferGroups, it is more efficient to create the CMTaggedBufferGroupFormatDescription once and use it for all of the CMSampleBuffers. The caller owns the returned CMFormatDescription, and must release it when done with it. All input parameters are copied (the extensions are deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    ///
    /// Creates a format description for a CMTaggedBufferGroup with extensions.
    ///
    /// Parameter `allocator`: CFAllocator to be used when creating the CMFormatDescription. Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// Parameter `taggedBufferGroup`: The tagged buffer group for which we are creating the format description.
    ///
    /// Parameter `extensions`: Dictionary of extension key/value pairs.  Keys are always CFStrings. Values are always property list objects (ie. CFData, CFString, CFArray, CFDictionary, CFDate, CFBoolean, or CFNumber). Can be NULL.
    ///
    /// Parameter `formatDescriptionOut`: Returned newly-created tagged buffer group CMFormatDescription
    ///
    /// The returned CMTaggedBufferGroupFormatDescription could be used to create a CMSampleBuffer
    /// wrapping the CMTaggedBufferGroup using CMSampleBufferCreateForTaggedBufferGroup.
    /// If you are going to call CMSampleBufferCreateForTaggedBufferGroup on a series of matching
    /// CMTaggedBufferGroups, it is more efficient to create the CMTaggedBufferGroupFormatDescription
    /// once and use it for all of the CMSampleBuffers.
    /// The caller owns the returned CMFormatDescription, and must release it when done with it.
    /// All input parameters are copied (the extensions are deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    /// # Safety
    ///
    /// - `extensions` generic must be of the correct type.
    /// - `extensions` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    #[doc(alias = "CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroupWithExtensions")]
    #[cfg(feature = "CMFormatDescription")]
    #[inline]
    pub unsafe fn format_description_create_for_tagged_buffer_group_with_extensions(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroupWithExtensions(
                allocator: Option<&CFAllocator>,
                tagged_buffer_group: &CMTaggedBufferGroup,
                extensions: Option<&CFDictionary>,
                format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
            ) -> OSStatus;
        }
        unsafe {
            CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroupWithExtensions(
                allocator,
                tagged_buffer_group,
                extensions,
                format_description_out,
            )
        }
    }

    /// Checks to see if a tagged buffer group’s format matches an existing format description.
    ///
    /// Parameters:
    /// - desc: A tagged buffer format description, created by [`CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup`](https://developer.apple.com/documentation/coremedia/cmtaggedbuffergroupformatdescriptioncreatefortaggedbuffergroup).
    ///
    /// - taggedBufferGroup: The tagged buffer group to inspect the format of.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `YES` when the format description of `taggedBufferGroup` is equal to the description `desc`.
    ///
    ///
    /// Checks to see if a given format description matches a tagged buffer group.
    ///
    /// Parameter `desc`: The format description to validate.
    ///
    /// Parameter `taggedBufferGroup`: The tagged buffer group to validate against.
    ///
    /// Returns true if the CMTaggedBufferGroupFormatDescription could be used to create a
    /// CMSampleBuffer wrapping the CMTaggedBufferGroup using CMSampleBufferCreateForTaggedBufferGroup.
    #[doc(alias = "CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup")]
    #[cfg(feature = "CMFormatDescription")]
    #[inline]
    pub unsafe fn format_description_matches_tagged_buffer_group(
        desc: &CMTaggedBufferGroupFormatDescription,
        tagged_buffer_group: &CMTaggedBufferGroup,
    ) -> bool {
        extern "C-unwind" {
            fn CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(
                desc: &CMTaggedBufferGroupFormatDescription,
                tagged_buffer_group: &CMTaggedBufferGroup,
            ) -> Boolean;
        }
        let ret = unsafe {
            CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(desc, tagged_buffer_group)
        };
        ret != 0
    }
}

extern "C-unwind" {
    /// Creates a new sample buffer from a tagged buffer group.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for the new tag collection. Pass `kCFAllocatorDefault` to use the default global allocator.
    ///
    /// - taggedBufferGroup: The tagged buffer group to create a new sample buffer from.
    ///
    /// - sbufPTS: The presentation time, in seconds, for the sample buffer.
    ///
    /// - sbufDuration: The duration, in seconds, of the sample buffer.
    ///
    /// - formatDescription: The format description for the tagged buffer group.
    ///
    /// - sBufOut: The output destination for the new sample buffer.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns `0` on success and a value from [Sample Buffer Error Codes](https://developer.apple.com/documentation/coremedia/sample-buffer-errors) on failure.
    ///
    ///
    /// Creates a new CMSampleBuffer object with the specified CMTaggedBufferGroup.
    ///
    /// Parameter `allocator`: CFAllocator with which to create the CMSampleBuffer object. Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// Parameter `taggedBufferGroup`: The CMTaggedBufferGroup to be stored in the sample buffer. The CMSampleBuffer will retain the CMTaggedBufferGroup internally.
    ///
    /// Parameter `sbufPTS`: Media time PTS of the sample buffer.
    ///
    /// Parameter `sbufDuration`: Media time duration of the sample buffer. Can be kCMTimeInvalid if not known or not defined.
    ///
    /// Parameter `formatDescription`: A CMTaggedBufferGroupFormatDescription describing the CMTaggedBufferGroup.
    /// You may create this with CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup.
    /// If you are creating a lot of CMSampleBuffers containing matching CMTaggedBufferGroups,
    /// it is more efficient to create the CMTaggedBufferGroupFormatDescription once and use it
    /// for all of the CMSampleBuffers.
    /// You may call CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup to confirm that
    /// a reused CMTaggedBufferGroupFormatDescription matches a new CMTaggedBufferGroup.
    ///
    /// Parameter `sBufOut`: Returned newly created CMSampleBuffer.
    ///
    /// Returns: OSStatus with error or noErr if successful.
    ///
    /// # Safety
    ///
    /// `s_buf_out` must be a valid pointer.
    #[cfg(all(
        feature = "CMFormatDescription",
        feature = "CMSampleBuffer",
        feature = "CMTime"
    ))]
    pub fn CMSampleBufferCreateForTaggedBufferGroup(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        sbuf_pts: CMTime,
        sbuf_duration: CMTime,
        format_description: &CMTaggedBufferGroupFormatDescription,
        s_buf_out: NonNull<*mut CMSampleBuffer>,
    ) -> OSStatus;
}

#[cfg(feature = "CMSampleBuffer")]
impl CMSampleBuffer {
    /// Gets the tagged buffer group of a sample buffer.
    ///
    /// ## Return Value
    ///
    /// The sample buffer’s tagged buffer group, or `NULL` if the sample buffer doesn’t belong to a tagged buffer group.
    ///
    ///
    /// Returns a CMSampleBuffer's TaggedBufferGroup of media data.
    ///
    /// Parameter `sbuf`: CMSampleBuffer being interrogated.
    ///
    /// The caller does not own the returned CMTaggedBufferGroup, and must retain it explicitly if the caller needs to maintain a reference to it.
    ///
    /// Returns: CMTaggedBufferGroup of media data. The result will be NULL if the CMSampleBuffer does not contain a CMTaggedBufferGroup, or if there is some other error.
    #[doc(alias = "CMSampleBufferGetTaggedBufferGroup")]
    #[cfg(feature = "CMSampleBuffer")]
    #[inline]
    pub unsafe fn tagged_buffer_group(&self) -> Option<CFRetained<CMTaggedBufferGroup>> {
        extern "C-unwind" {
            fn CMSampleBufferGetTaggedBufferGroup(
                sbuf: &CMSampleBuffer,
            ) -> Option<NonNull<CMTaggedBufferGroup>>;
        }
        let ret = unsafe { CMSampleBufferGetTaggedBufferGroup(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTaggedBufferGroup::create`"]
    pub fn CMTaggedBufferGroupCreate(
        allocator: Option<&CFAllocator>,
        tag_collections: &CFArray,
        buffers: &CFArray,
        group_out: NonNull<*mut CMTaggedBufferGroup>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTaggedBufferGroup::create_combined`"]
    pub fn CMTaggedBufferGroupCreateCombined(
        allocator: Option<&CFAllocator>,
        tagged_buffer_groups: &CFArray,
        group_out: NonNull<*mut CMTaggedBufferGroup>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMBase")]
    #[deprecated = "renamed to `CMTaggedBufferGroup::count`"]
    pub fn CMTaggedBufferGroupGetCount(group: &CMTaggedBufferGroup) -> CMItemCount;
}

#[cfg(feature = "CMTagCollection")]
#[deprecated = "renamed to `CMTaggedBufferGroup::tag_collection_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetTagCollectionAtIndex(
    group: &CMTaggedBufferGroup,
    index: CFIndex,
) -> Option<CFRetained<CMTagCollection>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetTagCollectionAtIndex(
            group: &CMTaggedBufferGroup,
            index: CFIndex,
        ) -> Option<NonNull<CMTagCollection>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetTagCollectionAtIndex(group, index) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "objc2-core-video")]
#[deprecated = "renamed to `CMTaggedBufferGroup::cv_pixel_buffer_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCVPixelBufferAtIndex(
    group: &CMTaggedBufferGroup,
    index: CFIndex,
) -> Option<CFRetained<CVPixelBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCVPixelBufferAtIndex(
            group: &CMTaggedBufferGroup,
            index: CFIndex,
        ) -> Option<NonNull<CVPixelBuffer>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetCVPixelBufferAtIndex(group, index) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CMTag", feature = "objc2-core-video"))]
#[deprecated = "renamed to `CMTaggedBufferGroup::cv_pixel_buffer_for_tag`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCVPixelBufferForTag(
    group: &CMTaggedBufferGroup,
    tag: CMTag,
    index_out: *mut CFIndex,
) -> Option<CFRetained<CVPixelBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCVPixelBufferForTag(
            group: &CMTaggedBufferGroup,
            tag: CMTag,
            index_out: *mut CFIndex,
        ) -> Option<NonNull<CVPixelBuffer>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetCVPixelBufferForTag(group, tag, index_out) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CMTagCollection", feature = "objc2-core-video"))]
#[deprecated = "renamed to `CMTaggedBufferGroup::cv_pixel_buffer_for_tag_collection`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCVPixelBufferForTagCollection(
    group: &CMTaggedBufferGroup,
    tag_collection: &CMTagCollection,
    index_out: *mut CFIndex,
) -> Option<CFRetained<CVPixelBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCVPixelBufferForTagCollection(
            group: &CMTaggedBufferGroup,
            tag_collection: &CMTagCollection,
            index_out: *mut CFIndex,
        ) -> Option<NonNull<CVPixelBuffer>>;
    }
    let ret = unsafe {
        CMTaggedBufferGroupGetCVPixelBufferForTagCollection(group, tag_collection, index_out)
    };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "CMSampleBuffer")]
#[deprecated = "renamed to `CMTaggedBufferGroup::cm_sample_buffer_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCMSampleBufferAtIndex(
    group: &CMTaggedBufferGroup,
    index: CFIndex,
) -> Option<CFRetained<CMSampleBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCMSampleBufferAtIndex(
            group: &CMTaggedBufferGroup,
            index: CFIndex,
        ) -> Option<NonNull<CMSampleBuffer>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetCMSampleBufferAtIndex(group, index) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CMSampleBuffer", feature = "CMTag"))]
#[deprecated = "renamed to `CMTaggedBufferGroup::cm_sample_buffer_for_tag`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCMSampleBufferForTag(
    group: &CMTaggedBufferGroup,
    tag: CMTag,
    index_out: *mut CFIndex,
) -> Option<CFRetained<CMSampleBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCMSampleBufferForTag(
            group: &CMTaggedBufferGroup,
            tag: CMTag,
            index_out: *mut CFIndex,
        ) -> Option<NonNull<CMSampleBuffer>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetCMSampleBufferForTag(group, tag, index_out) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CMSampleBuffer", feature = "CMTagCollection"))]
#[deprecated = "renamed to `CMTaggedBufferGroup::cm_sample_buffer_for_tag_collection`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCMSampleBufferForTagCollection(
    group: &CMTaggedBufferGroup,
    tag_collection: &CMTagCollection,
    index_out: *mut CFIndex,
) -> Option<CFRetained<CMSampleBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCMSampleBufferForTagCollection(
            group: &CMTaggedBufferGroup,
            tag_collection: &CMTagCollection,
            index_out: *mut CFIndex,
        ) -> Option<NonNull<CMSampleBuffer>>;
    }
    let ret = unsafe {
        CMTaggedBufferGroupGetCMSampleBufferForTagCollection(group, tag_collection, index_out)
    };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[cfg(all(feature = "CMBase", feature = "CMTagCollection"))]
    #[deprecated = "renamed to `CMTaggedBufferGroup::number_of_matches_for_tag_collection`"]
    pub fn CMTaggedBufferGroupGetNumberOfMatchesForTagCollection(
        group: &CMTaggedBufferGroup,
        tag_collection: &CMTagCollection,
    ) -> CMItemCount;
}

extern "C-unwind" {
    #[cfg(feature = "CMFormatDescription")]
    #[deprecated = "renamed to `CMTaggedBufferGroup::format_description_create_for_tagged_buffer_group`"]
    pub fn CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMFormatDescription")]
    #[deprecated = "renamed to `CMTaggedBufferGroup::format_description_create_for_tagged_buffer_group_with_extensions`"]
    pub fn CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroupWithExtensions(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
    ) -> OSStatus;
}

#[cfg(feature = "CMFormatDescription")]
#[deprecated = "renamed to `CMTaggedBufferGroup::format_description_matches_tagged_buffer_group`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(
    desc: &CMTaggedBufferGroupFormatDescription,
    tagged_buffer_group: &CMTaggedBufferGroup,
) -> bool {
    extern "C-unwind" {
        fn CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(
            desc: &CMTaggedBufferGroupFormatDescription,
            tagged_buffer_group: &CMTaggedBufferGroup,
        ) -> Boolean;
    }
    let ret = unsafe {
        CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(desc, tagged_buffer_group)
    };
    ret != 0
}

#[cfg(feature = "CMSampleBuffer")]
#[deprecated = "renamed to `CMSampleBuffer::tagged_buffer_group`"]
#[inline]
pub unsafe extern "C-unwind" fn CMSampleBufferGetTaggedBufferGroup(
    sbuf: &CMSampleBuffer,
) -> Option<CFRetained<CMTaggedBufferGroup>> {
    extern "C-unwind" {
        fn CMSampleBufferGetTaggedBufferGroup(
            sbuf: &CMSampleBuffer,
        ) -> Option<NonNull<CMTaggedBufferGroup>>;
    }
    let ret = unsafe { CMSampleBufferGetTaggedBufferGroup(sbuf) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}
