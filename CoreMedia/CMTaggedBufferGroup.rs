//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-video")]
use objc2_core_video::*;

use crate::*;

/// The OSStatus errors returned from the CMTaggedBufferGroup routines.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmtaggedbuffergrouperror?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CMTaggedBufferGroupError(pub OSStatus);
impl CMTaggedBufferGroupError {
    #[doc(alias = "kCMTaggedBufferGroupError_ParamErr")]
    pub const ParamErr: Self = Self(-15780);
    #[doc(alias = "kCMTaggedBufferGroupError_AllocationFailed")]
    pub const AllocationFailed: Self = Self(-15781);
    #[doc(alias = "kCMTaggedBufferGroupError_InternalError")]
    pub const InternalError: Self = Self(-15782);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMTaggedBufferGroupError {
    const ENCODING: Encoding = OSStatus::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMTaggedBufferGroupError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// An object gathering zero or more buffers (CMSampleBuffer, CVPixelBuffer) each with a CMTagCollection.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmtaggedbuffergroup?language=objc)
#[doc(alias = "CMTaggedBufferGroupRef")]
#[repr(C)]
pub struct CMTaggedBufferGroup {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CMTaggedBufferGroup {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueCMTaggedBufferGroup"> for CMTaggedBufferGroup {}
);

unsafe impl ConcreteType for CMTaggedBufferGroup {
    #[doc(alias = "CMTaggedBufferGroupGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetTypeID() -> CFTypeID;
        }
        unsafe { CMTaggedBufferGroupGetTypeID() }
    }
}

impl CMTaggedBufferGroup {
    /// Creates a new tagged buffer group.
    ///
    /// Parameter `allocator`: The CFAllocator to use for allocating this buffer group.  May be NULL.
    ///
    /// Parameter `tagCollections`: A CFArray of CMTagCollections for the buffers.
    ///
    /// Parameter `buffers`: A CFArray of buffers, each of type CMSampleBuffer or CVPixelBuffer.  The group will retain these sample buffers and pixel buffers.
    /// The number of tagCollections must match the number of buffers.
    ///
    /// Parameter `groupOut`: The newly created group will be placed here.  The caller has a responsibility to call CFRelease on it.
    ///
    /// Returns: Returns noErr on success.
    ///
    /// # Safety
    ///
    /// - `tag_collections` generic must be of the correct type.
    /// - `buffers` generic must be of the correct type.
    /// - `group_out` must be a valid pointer.
    #[doc(alias = "CMTaggedBufferGroupCreate")]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        tag_collections: &CFArray,
        buffers: &CFArray,
        group_out: NonNull<*mut CMTaggedBufferGroup>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTaggedBufferGroupCreate(
                allocator: Option<&CFAllocator>,
                tag_collections: &CFArray,
                buffers: &CFArray,
                group_out: NonNull<*mut CMTaggedBufferGroup>,
            ) -> OSStatus;
        }
        unsafe { CMTaggedBufferGroupCreate(allocator, tag_collections, buffers, group_out) }
    }

    /// Creates a new tagged buffer group by combining all the tagged buffer groups in an array.
    ///
    /// Parameter `allocator`: The CFAllocator to use for allocating this buffer group.  May be NULL.
    ///
    /// Parameter `taggedBufferGroups`: A CFArray of CMTaggedBufferGroups.
    ///
    /// Parameter `groupOut`: The newly created group will be placed here.  The caller has a responsibility to call CFRelease on it.
    ///
    /// Returns: Returns noErr on success.
    ///
    /// # Safety
    ///
    /// - `tagged_buffer_groups` generic must be of the correct type.
    /// - `group_out` must be a valid pointer.
    #[doc(alias = "CMTaggedBufferGroupCreateCombined")]
    #[inline]
    pub unsafe fn create_combined(
        allocator: Option<&CFAllocator>,
        tagged_buffer_groups: &CFArray,
        group_out: NonNull<*mut CMTaggedBufferGroup>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTaggedBufferGroupCreateCombined(
                allocator: Option<&CFAllocator>,
                tagged_buffer_groups: &CFArray,
                group_out: NonNull<*mut CMTaggedBufferGroup>,
            ) -> OSStatus;
        }
        unsafe { CMTaggedBufferGroupCreateCombined(allocator, tagged_buffer_groups, group_out) }
    }

    /// Returns the number of buffers in a CMTaggedBufferGroup.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the count from.
    ///
    /// Returns: Returns the number of buffers, or 0 on failure or if the group is empty.
    #[doc(alias = "CMTaggedBufferGroupGetCount")]
    #[cfg(feature = "CMBase")]
    #[inline]
    pub unsafe fn count(&self) -> CMItemCount {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCount(group: &CMTaggedBufferGroup) -> CMItemCount;
        }
        unsafe { CMTaggedBufferGroupGetCount(self) }
    }

    /// Returns a CMTagCollection from a CMTaggedBufferGroup by sequential indexing.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the tag collection from.
    ///
    /// Parameter `index`: An index from 0 to count-1.
    ///
    /// Returns: Returns the tag collection, or NULL on failure.
    #[doc(alias = "CMTaggedBufferGroupGetTagCollectionAtIndex")]
    #[cfg(feature = "CMTagCollection")]
    #[inline]
    pub unsafe fn tag_collection_at_index(
        &self,
        index: CFIndex,
    ) -> Option<CFRetained<CMTagCollection>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetTagCollectionAtIndex(
                group: &CMTaggedBufferGroup,
                index: CFIndex,
            ) -> Option<NonNull<CMTagCollection>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetTagCollectionAtIndex(self, index) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns a CVPixelBuffer from a CMTaggedBufferGroup by sequential indexing.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CVPixelBuffer from.
    ///
    /// Parameter `index`: An index from 0 to count-1.
    ///
    /// Returns: Returns the CVPixelBuffer, or NULL on failure (including if the buffer at this index is not a CVPixelBuffer).
    #[doc(alias = "CMTaggedBufferGroupGetCVPixelBufferAtIndex")]
    #[cfg(feature = "objc2-core-video")]
    #[inline]
    pub unsafe fn cv_pixel_buffer_at_index(
        &self,
        index: CFIndex,
    ) -> Option<CFRetained<CVPixelBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCVPixelBufferAtIndex(
                group: &CMTaggedBufferGroup,
                index: CFIndex,
            ) -> Option<NonNull<CVPixelBuffer>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetCVPixelBufferAtIndex(self, index) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns a CVPixelBuffer from a CMTaggedBufferGroup by looking for a unique match for the provided tag.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CVPixelBuffer from.
    ///
    /// Parameter `tag`: The tag to look up.  If more than one buffer's tag collection includes this tag, the lookup will fail.
    ///
    /// Parameter `indexOut`: On success, index of the returned CVPixelBuffer.  May be NULL.
    ///
    /// Returns: Returns the CVPixelBuffer, or NULL on failure (including if the buffer at this index is not a CVPixelBuffer).
    ///
    /// # Safety
    ///
    /// `index_out` must be a valid pointer or null.
    #[doc(alias = "CMTaggedBufferGroupGetCVPixelBufferForTag")]
    #[cfg(all(feature = "CMTag", feature = "objc2-core-video"))]
    #[inline]
    pub unsafe fn cv_pixel_buffer_for_tag(
        &self,
        tag: CMTag,
        index_out: *mut CFIndex,
    ) -> Option<CFRetained<CVPixelBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCVPixelBufferForTag(
                group: &CMTaggedBufferGroup,
                tag: CMTag,
                index_out: *mut CFIndex,
            ) -> Option<NonNull<CVPixelBuffer>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetCVPixelBufferForTag(self, tag, index_out) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns a CVPixelBuffer from a CMTaggedBufferGroup by looking for a unique match for the provided tag collection.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CVPixelBuffer from.
    ///
    /// Parameter `tagCollection`: The tag collection to look up.  If more than one buffer's tag collection includes this tag collection, the lookup will fail.
    ///
    /// Parameter `indexOut`: On success, index of the returned CVPixelBuffer.  May be NULL.
    ///
    /// Returns: Returns the CVPixelBuffer, or NULL on failure (including if the buffer at this index is not a CVPixelBuffer).
    ///
    /// # Safety
    ///
    /// `index_out` must be a valid pointer or null.
    #[doc(alias = "CMTaggedBufferGroupGetCVPixelBufferForTagCollection")]
    #[cfg(all(feature = "CMTagCollection", feature = "objc2-core-video"))]
    #[inline]
    pub unsafe fn cv_pixel_buffer_for_tag_collection(
        &self,
        tag_collection: &CMTagCollection,
        index_out: *mut CFIndex,
    ) -> Option<CFRetained<CVPixelBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCVPixelBufferForTagCollection(
                group: &CMTaggedBufferGroup,
                tag_collection: &CMTagCollection,
                index_out: *mut CFIndex,
            ) -> Option<NonNull<CVPixelBuffer>>;
        }
        let ret = unsafe {
            CMTaggedBufferGroupGetCVPixelBufferForTagCollection(self, tag_collection, index_out)
        };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns a CMSampleBuffer from a CMTaggedBufferGroup by sequential indexing.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CMSampleBuffer from.
    ///
    /// Parameter `index`: An index from 0 to count-1.
    ///
    /// Returns: Returns the CMSampleBuffer, or NULL on failure (including if the buffer at this index is not a CMSampleBuffer).
    #[doc(alias = "CMTaggedBufferGroupGetCMSampleBufferAtIndex")]
    #[cfg(feature = "CMSampleBuffer")]
    #[inline]
    pub unsafe fn cm_sample_buffer_at_index(
        &self,
        index: CFIndex,
    ) -> Option<CFRetained<CMSampleBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCMSampleBufferAtIndex(
                group: &CMTaggedBufferGroup,
                index: CFIndex,
            ) -> Option<NonNull<CMSampleBuffer>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetCMSampleBufferAtIndex(self, index) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns a CMSampleBuffer from a CMTaggedBufferGroup by looking for a unique match for the provided tag.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CMSampleBuffer from.
    ///
    /// Parameter `tag`: The tag to look up.  If more than one buffer's tag collection includes this tag, the lookup will fail.
    ///
    /// Parameter `indexOut`: On success, index of the returned CMSampleBuffer.  May be NULL.
    ///
    /// Returns: Returns the CMSampleBuffer, or NULL on failure (including if the buffer at this index is not a CMSampleBuffer).
    ///
    /// # Safety
    ///
    /// `index_out` must be a valid pointer or null.
    #[doc(alias = "CMTaggedBufferGroupGetCMSampleBufferForTag")]
    #[cfg(all(feature = "CMSampleBuffer", feature = "CMTag"))]
    #[inline]
    pub unsafe fn cm_sample_buffer_for_tag(
        &self,
        tag: CMTag,
        index_out: *mut CFIndex,
    ) -> Option<CFRetained<CMSampleBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCMSampleBufferForTag(
                group: &CMTaggedBufferGroup,
                tag: CMTag,
                index_out: *mut CFIndex,
            ) -> Option<NonNull<CMSampleBuffer>>;
        }
        let ret = unsafe { CMTaggedBufferGroupGetCMSampleBufferForTag(self, tag, index_out) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns a CMSampleBuffer from a CMTaggedBufferGroup by looking for a unique match for the provided tag collection.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to retrieve the CMSampleBuffer from.
    ///
    /// Parameter `tagCollection`: The tag collection to look up.  If more than one buffer's tag collection includes this tag collection, the lookup will fail.
    ///
    /// Parameter `indexOut`: On success, index of the returned CMSampleBuffer.  May be NULL.
    ///
    /// Returns: Returns the CMSampleBuffer, or NULL on failure (including if the buffer at this index is not a CMSampleBuffer).
    ///
    /// # Safety
    ///
    /// `index_out` must be a valid pointer or null.
    #[doc(alias = "CMTaggedBufferGroupGetCMSampleBufferForTagCollection")]
    #[cfg(all(feature = "CMSampleBuffer", feature = "CMTagCollection"))]
    #[inline]
    pub unsafe fn cm_sample_buffer_for_tag_collection(
        &self,
        tag_collection: &CMTagCollection,
        index_out: *mut CFIndex,
    ) -> Option<CFRetained<CMSampleBuffer>> {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetCMSampleBufferForTagCollection(
                group: &CMTaggedBufferGroup,
                tag_collection: &CMTagCollection,
                index_out: *mut CFIndex,
            ) -> Option<NonNull<CMSampleBuffer>>;
        }
        let ret = unsafe {
            CMTaggedBufferGroupGetCMSampleBufferForTagCollection(self, tag_collection, index_out)
        };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the number of matches that a tag collection has in a CMTaggedBufferGroup.
    ///
    /// If the returned count is less than or greater than 1, buffer lookups using this tag collection will fail and return NULL, since the lookups must be unique and unambiguous.
    ///
    /// Parameter `group`: The CMTaggedBufferGroupRef to examine.
    ///
    /// Parameter `tagCollection`: The tag collection to look up.
    ///
    /// Returns: Returns the number of entries in the CMTaggedBufferGroup that match tagCollection.
    #[doc(alias = "CMTaggedBufferGroupGetNumberOfMatchesForTagCollection")]
    #[cfg(all(feature = "CMBase", feature = "CMTagCollection"))]
    #[inline]
    pub unsafe fn number_of_matches_for_tag_collection(
        &self,
        tag_collection: &CMTagCollection,
    ) -> CMItemCount {
        extern "C-unwind" {
            fn CMTaggedBufferGroupGetNumberOfMatchesForTagCollection(
                group: &CMTaggedBufferGroup,
                tag_collection: &CMTagCollection,
            ) -> CMItemCount;
        }
        unsafe { CMTaggedBufferGroupGetNumberOfMatchesForTagCollection(self, tag_collection) }
    }

    /// Creates a format description for a CMTaggedBufferGroup.
    ///
    /// Parameter `allocator`: CFAllocator to be used when creating the CMFormatDescription. Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// Parameter `taggedBufferGroup`: The tagged buffer group for which we are creating the format description.
    ///
    /// Parameter `formatDescriptionOut`: Returned newly-created tagged buffer group CMFormatDescription
    ///
    /// The returned CMTaggedBufferGroupFormatDescription could be used to create a CMSampleBuffer
    /// wrapping the CMTaggedBufferGroup using CMSampleBufferCreateForTaggedBufferGroup.
    /// If you are going to call CMSampleBufferCreateForTaggedBufferGroup on a series of matching
    /// CMTaggedBufferGroups, it is more efficient to create the CMTaggedBufferGroupFormatDescription
    /// once and use it for all of the CMSampleBuffers.
    /// The caller owns the returned CMFormatDescription, and must release it when done with it.
    ///
    /// # Safety
    ///
    /// `format_description_out` must be a valid pointer.
    #[doc(alias = "CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup")]
    #[cfg(feature = "CMFormatDescription")]
    #[inline]
    pub unsafe fn format_description_create_for_tagged_buffer_group(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup(
                allocator: Option<&CFAllocator>,
                tagged_buffer_group: &CMTaggedBufferGroup,
                format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
            ) -> OSStatus;
        }
        unsafe {
            CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup(
                allocator,
                tagged_buffer_group,
                format_description_out,
            )
        }
    }

    /// Creates a format description for a CMTaggedBufferGroup with extensions.
    ///
    /// Parameter `allocator`: CFAllocator to be used when creating the CMFormatDescription. Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// Parameter `taggedBufferGroup`: The tagged buffer group for which we are creating the format description.
    ///
    /// Parameter `extensions`: Dictionary of extension key/value pairs.  Keys are always CFStrings. Values are always property list objects (ie. CFData, CFString, CFArray, CFDictionary, CFDate, CFBoolean, or CFNumber). Can be NULL.
    ///
    /// Parameter `formatDescriptionOut`: Returned newly-created tagged buffer group CMFormatDescription
    ///
    /// The returned CMTaggedBufferGroupFormatDescription could be used to create a CMSampleBuffer
    /// wrapping the CMTaggedBufferGroup using CMSampleBufferCreateForTaggedBufferGroup.
    /// If you are going to call CMSampleBufferCreateForTaggedBufferGroup on a series of matching
    /// CMTaggedBufferGroups, it is more efficient to create the CMTaggedBufferGroupFormatDescription
    /// once and use it for all of the CMSampleBuffers.
    /// The caller owns the returned CMFormatDescription, and must release it when done with it.
    /// All input parameters are copied (the extensions are deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    /// # Safety
    ///
    /// - `extensions` generics must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    #[doc(alias = "CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroupWithExtensions")]
    #[cfg(feature = "CMFormatDescription")]
    #[inline]
    pub unsafe fn format_description_create_for_tagged_buffer_group_with_extensions(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroupWithExtensions(
                allocator: Option<&CFAllocator>,
                tagged_buffer_group: &CMTaggedBufferGroup,
                extensions: Option<&CFDictionary>,
                format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
            ) -> OSStatus;
        }
        unsafe {
            CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroupWithExtensions(
                allocator,
                tagged_buffer_group,
                extensions,
                format_description_out,
            )
        }
    }

    /// Checks to see if a given format description matches a tagged buffer group.
    ///
    /// Parameter `desc`: The format description to validate.
    ///
    /// Parameter `taggedBufferGroup`: The tagged buffer group to validate against.
    ///
    /// Returns true if the CMTaggedBufferGroupFormatDescription could be used to create a
    /// CMSampleBuffer wrapping the CMTaggedBufferGroup using CMSampleBufferCreateForTaggedBufferGroup.
    #[doc(alias = "CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup")]
    #[cfg(feature = "CMFormatDescription")]
    #[inline]
    pub unsafe fn format_description_matches_tagged_buffer_group(
        desc: &CMTaggedBufferGroupFormatDescription,
        tagged_buffer_group: &CMTaggedBufferGroup,
    ) -> bool {
        extern "C-unwind" {
            fn CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(
                desc: &CMTaggedBufferGroupFormatDescription,
                tagged_buffer_group: &CMTaggedBufferGroup,
            ) -> Boolean;
        }
        let ret = unsafe {
            CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(desc, tagged_buffer_group)
        };
        ret != 0
    }
}

extern "C-unwind" {
    /// Creates a new CMSampleBuffer object with the specified CMTaggedBufferGroup.
    ///
    /// Parameter `allocator`: CFAllocator with which to create the CMSampleBuffer object. Pass kCFAllocatorDefault to use the default allocator.
    ///
    /// Parameter `taggedBufferGroup`: The CMTaggedBufferGroup to be stored in the sample buffer. The CMSampleBuffer will retain the CMTaggedBufferGroup internally.
    ///
    /// Parameter `sbufPTS`: Media time PTS of the sample buffer.
    ///
    /// Parameter `sbufDuration`: Media time duration of the sample buffer. Can be kCMTimeInvalid if not known or not defined.
    ///
    /// Parameter `formatDescription`: A CMTaggedBufferGroupFormatDescription describing the CMTaggedBufferGroup.
    /// You may create this with CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup.
    /// If you are creating a lot of CMSampleBuffers containing matching CMTaggedBufferGroups,
    /// it is more efficient to create the CMTaggedBufferGroupFormatDescription once and use it
    /// for all of the CMSampleBuffers.
    /// You may call CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup to confirm that
    /// a reused CMTaggedBufferGroupFormatDescription matches a new CMTaggedBufferGroup.
    ///
    /// Parameter `sBufOut`: Returned newly created CMSampleBuffer.
    ///
    /// Returns: OSStatus with error or noErr if successful.
    ///
    /// # Safety
    ///
    /// `s_buf_out` must be a valid pointer.
    #[cfg(all(
        feature = "CMFormatDescription",
        feature = "CMSampleBuffer",
        feature = "CMTime"
    ))]
    pub fn CMSampleBufferCreateForTaggedBufferGroup(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        sbuf_pts: CMTime,
        sbuf_duration: CMTime,
        format_description: &CMTaggedBufferGroupFormatDescription,
        s_buf_out: NonNull<*mut CMSampleBuffer>,
    ) -> OSStatus;
}

#[cfg(feature = "CMSampleBuffer")]
impl CMSampleBuffer {
    /// Returns a CMSampleBuffer's TaggedBufferGroup of media data.
    ///
    /// Parameter `sbuf`: CMSampleBuffer being interrogated.
    ///
    /// The caller does not own the returned CMTaggedBufferGroup, and must retain it explicitly if the caller needs to maintain a reference to it.
    ///
    /// Returns: CMTaggedBufferGroup of media data. The result will be NULL if the CMSampleBuffer does not contain a CMTaggedBufferGroup, or if there is some other error.
    #[doc(alias = "CMSampleBufferGetTaggedBufferGroup")]
    #[cfg(feature = "CMSampleBuffer")]
    #[inline]
    pub unsafe fn tagged_buffer_group(&self) -> Option<CFRetained<CMTaggedBufferGroup>> {
        extern "C-unwind" {
            fn CMSampleBufferGetTaggedBufferGroup(
                sbuf: &CMSampleBuffer,
            ) -> Option<NonNull<CMTaggedBufferGroup>>;
        }
        let ret = unsafe { CMSampleBufferGetTaggedBufferGroup(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTaggedBufferGroup::create`"]
    pub fn CMTaggedBufferGroupCreate(
        allocator: Option<&CFAllocator>,
        tag_collections: &CFArray,
        buffers: &CFArray,
        group_out: NonNull<*mut CMTaggedBufferGroup>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTaggedBufferGroup::create_combined`"]
    pub fn CMTaggedBufferGroupCreateCombined(
        allocator: Option<&CFAllocator>,
        tagged_buffer_groups: &CFArray,
        group_out: NonNull<*mut CMTaggedBufferGroup>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMBase")]
    #[deprecated = "renamed to `CMTaggedBufferGroup::count`"]
    pub fn CMTaggedBufferGroupGetCount(group: &CMTaggedBufferGroup) -> CMItemCount;
}

#[cfg(feature = "CMTagCollection")]
#[deprecated = "renamed to `CMTaggedBufferGroup::tag_collection_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetTagCollectionAtIndex(
    group: &CMTaggedBufferGroup,
    index: CFIndex,
) -> Option<CFRetained<CMTagCollection>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetTagCollectionAtIndex(
            group: &CMTaggedBufferGroup,
            index: CFIndex,
        ) -> Option<NonNull<CMTagCollection>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetTagCollectionAtIndex(group, index) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "objc2-core-video")]
#[deprecated = "renamed to `CMTaggedBufferGroup::cv_pixel_buffer_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCVPixelBufferAtIndex(
    group: &CMTaggedBufferGroup,
    index: CFIndex,
) -> Option<CFRetained<CVPixelBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCVPixelBufferAtIndex(
            group: &CMTaggedBufferGroup,
            index: CFIndex,
        ) -> Option<NonNull<CVPixelBuffer>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetCVPixelBufferAtIndex(group, index) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CMTag", feature = "objc2-core-video"))]
#[deprecated = "renamed to `CMTaggedBufferGroup::cv_pixel_buffer_for_tag`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCVPixelBufferForTag(
    group: &CMTaggedBufferGroup,
    tag: CMTag,
    index_out: *mut CFIndex,
) -> Option<CFRetained<CVPixelBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCVPixelBufferForTag(
            group: &CMTaggedBufferGroup,
            tag: CMTag,
            index_out: *mut CFIndex,
        ) -> Option<NonNull<CVPixelBuffer>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetCVPixelBufferForTag(group, tag, index_out) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CMTagCollection", feature = "objc2-core-video"))]
#[deprecated = "renamed to `CMTaggedBufferGroup::cv_pixel_buffer_for_tag_collection`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCVPixelBufferForTagCollection(
    group: &CMTaggedBufferGroup,
    tag_collection: &CMTagCollection,
    index_out: *mut CFIndex,
) -> Option<CFRetained<CVPixelBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCVPixelBufferForTagCollection(
            group: &CMTaggedBufferGroup,
            tag_collection: &CMTagCollection,
            index_out: *mut CFIndex,
        ) -> Option<NonNull<CVPixelBuffer>>;
    }
    let ret = unsafe {
        CMTaggedBufferGroupGetCVPixelBufferForTagCollection(group, tag_collection, index_out)
    };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(feature = "CMSampleBuffer")]
#[deprecated = "renamed to `CMTaggedBufferGroup::cm_sample_buffer_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCMSampleBufferAtIndex(
    group: &CMTaggedBufferGroup,
    index: CFIndex,
) -> Option<CFRetained<CMSampleBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCMSampleBufferAtIndex(
            group: &CMTaggedBufferGroup,
            index: CFIndex,
        ) -> Option<NonNull<CMSampleBuffer>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetCMSampleBufferAtIndex(group, index) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CMSampleBuffer", feature = "CMTag"))]
#[deprecated = "renamed to `CMTaggedBufferGroup::cm_sample_buffer_for_tag`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCMSampleBufferForTag(
    group: &CMTaggedBufferGroup,
    tag: CMTag,
    index_out: *mut CFIndex,
) -> Option<CFRetained<CMSampleBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCMSampleBufferForTag(
            group: &CMTaggedBufferGroup,
            tag: CMTag,
            index_out: *mut CFIndex,
        ) -> Option<NonNull<CMSampleBuffer>>;
    }
    let ret = unsafe { CMTaggedBufferGroupGetCMSampleBufferForTag(group, tag, index_out) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[cfg(all(feature = "CMSampleBuffer", feature = "CMTagCollection"))]
#[deprecated = "renamed to `CMTaggedBufferGroup::cm_sample_buffer_for_tag_collection`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupGetCMSampleBufferForTagCollection(
    group: &CMTaggedBufferGroup,
    tag_collection: &CMTagCollection,
    index_out: *mut CFIndex,
) -> Option<CFRetained<CMSampleBuffer>> {
    extern "C-unwind" {
        fn CMTaggedBufferGroupGetCMSampleBufferForTagCollection(
            group: &CMTaggedBufferGroup,
            tag_collection: &CMTagCollection,
            index_out: *mut CFIndex,
        ) -> Option<NonNull<CMSampleBuffer>>;
    }
    let ret = unsafe {
        CMTaggedBufferGroupGetCMSampleBufferForTagCollection(group, tag_collection, index_out)
    };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[cfg(all(feature = "CMBase", feature = "CMTagCollection"))]
    #[deprecated = "renamed to `CMTaggedBufferGroup::number_of_matches_for_tag_collection`"]
    pub fn CMTaggedBufferGroupGetNumberOfMatchesForTagCollection(
        group: &CMTaggedBufferGroup,
        tag_collection: &CMTagCollection,
    ) -> CMItemCount;
}

extern "C-unwind" {
    #[cfg(feature = "CMFormatDescription")]
    #[deprecated = "renamed to `CMTaggedBufferGroup::format_description_create_for_tagged_buffer_group`"]
    pub fn CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroup(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMFormatDescription")]
    #[deprecated = "renamed to `CMTaggedBufferGroup::format_description_create_for_tagged_buffer_group_with_extensions`"]
    pub fn CMTaggedBufferGroupFormatDescriptionCreateForTaggedBufferGroupWithExtensions(
        allocator: Option<&CFAllocator>,
        tagged_buffer_group: &CMTaggedBufferGroup,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMTaggedBufferGroupFormatDescription>,
    ) -> OSStatus;
}

#[cfg(feature = "CMFormatDescription")]
#[deprecated = "renamed to `CMTaggedBufferGroup::format_description_matches_tagged_buffer_group`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(
    desc: &CMTaggedBufferGroupFormatDescription,
    tagged_buffer_group: &CMTaggedBufferGroup,
) -> bool {
    extern "C-unwind" {
        fn CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(
            desc: &CMTaggedBufferGroupFormatDescription,
            tagged_buffer_group: &CMTaggedBufferGroup,
        ) -> Boolean;
    }
    let ret = unsafe {
        CMTaggedBufferGroupFormatDescriptionMatchesTaggedBufferGroup(desc, tagged_buffer_group)
    };
    ret != 0
}

#[cfg(feature = "CMSampleBuffer")]
#[deprecated = "renamed to `CMSampleBuffer::tagged_buffer_group`"]
#[inline]
pub unsafe extern "C-unwind" fn CMSampleBufferGetTaggedBufferGroup(
    sbuf: &CMSampleBuffer,
) -> Option<CFRetained<CMTaggedBufferGroup>> {
    extern "C-unwind" {
        fn CMSampleBufferGetTaggedBufferGroup(
            sbuf: &CMSampleBuffer,
        ) -> Option<NonNull<CMTaggedBufferGroup>>;
    }
    let ret = unsafe { CMSampleBufferGetTaggedBufferGroup(sbuf) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}
