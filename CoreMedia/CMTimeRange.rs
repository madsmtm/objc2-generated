//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// A structure that represents a time range.
/// A time range represented as two CMTime structures.
#[cfg(feature = "CMTime")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CMTimeRange {
    /// The start time of the time range.
    pub start: CMTime,
    /// The duration of the time range.
    pub duration: CMTime,
}

#[cfg(all(feature = "CMTime", feature = "objc2"))]
unsafe impl Encode for CMTimeRange {
    const ENCODING: Encoding = Encoding::Struct("?", &[<CMTime>::ENCODING, <CMTime>::ENCODING]);
}

#[cfg(all(feature = "CMTime", feature = "objc2"))]
unsafe impl RefEncode for CMTimeRange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// A constant for generating an empty time range at zero.
    #[cfg(feature = "CMTime")]
    pub static kCMTimeRangeZero: CMTimeRange;
}

extern "C" {
    /// A constant for generating an invalid time range.
    #[cfg(feature = "CMTime")]
    pub static kCMTimeRangeInvalid: CMTimeRange;
}

#[cfg(feature = "CMTime")]
impl CMTimeRange {
    /// Creates a valid time range with a start time and duration.
    ///
    /// Parameters:
    /// - start: The start of the time range.
    ///
    /// - duration: The duration of the time range.
    ///
    ///
    /// ## Return Value
    ///
    /// A valid time range structure, or an invalid time range if the duration’s epoch isn’t `0`.
    ///
    ///
    /// Make a valid CMTimeRange with start and duration.
    ///
    /// Returns: The resulting CMTimeRange.
    ///
    /// The duration parameter must have an epoch of 0; otherwise an invalid time range will be returned.
    #[doc(alias = "CMTimeRangeMake")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn new(start: CMTime, duration: CMTime) -> CMTimeRange {
        extern "C-unwind" {
            fn CMTimeRangeMake(start: CMTime, duration: CMTime) -> CMTimeRange;
        }
        unsafe { CMTimeRangeMake(start, duration) }
    }

    /// Returns a new time range with the time elements of the input.
    ///
    /// Parameters:
    /// - range: The first time range.
    ///
    /// - otherRange: The second time range.
    ///
    ///
    /// ## Return Value
    ///
    /// A time range with the unique time elements of the input.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The return value contains the smallest range that includes all times that are in either range.
    ///
    ///
    /// Returns the union of two CMTimeRanges.
    ///
    /// This function returns a CMTimeRange structure that represents the union of the time ranges specified by the
    /// <i>
    /// range
    /// </i>
    /// and
    /// <i>
    /// otherRange
    /// </i>
    /// parameters.
    /// This is the smallest range that includes all times that are in either range.
    ///
    /// Returns: The union of the two CMTimeRanges.
    #[doc(alias = "CMTimeRangeGetUnion")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn union(self, other_range: CMTimeRange) -> CMTimeRange {
        extern "C-unwind" {
            fn CMTimeRangeGetUnion(range: CMTimeRange, other_range: CMTimeRange) -> CMTimeRange;
        }
        unsafe { CMTimeRangeGetUnion(self, other_range) }
    }

    /// Returns a new time range with the time elements that are common between the input.
    ///
    /// Parameters:
    /// - range: The first time range to intersect.
    ///
    /// - otherRange: The second time range to intersect.
    ///
    ///
    /// ## Return Value
    ///
    /// A time range that represents the largest intersection of the input.
    ///
    ///
    /// Returns the intersection of two CMTimeRanges.
    ///
    /// This function returns a CMTimeRange structure that represents the intersection of the time ranges specified by the
    /// <i>
    /// range
    /// </i>
    /// and
    /// <i>
    /// otherRange
    /// </i>
    /// parameters.
    /// This is the largest range that both ranges include.
    ///
    /// Returns: The intersection of the two CMTimeRanges.
    #[doc(alias = "CMTimeRangeGetIntersection")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn intersection(self, other_range: CMTimeRange) -> CMTimeRange {
        extern "C-unwind" {
            fn CMTimeRangeGetIntersection(
                range: CMTimeRange,
                other_range: CMTimeRange,
            ) -> CMTimeRange;
        }
        unsafe { CMTimeRangeGetIntersection(self, other_range) }
    }

    /// Returns a Boolean value that indicates whether two time ranges are equal.
    ///
    /// Parameters:
    /// - range1: The first time range to compare.
    ///
    /// - range2: The second time range to compare.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the two time ranges are equal; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Returns a Boolean value that indicates whether two CMTimeRanges are identical.
    ///
    /// This function returns a Boolean value that indicates whether the time ranges specified by the
    /// <i>
    /// range1
    /// </i>
    /// and
    /// <i>
    /// range2
    /// </i>
    /// parameters are identical.
    ///
    /// Returns: Returns true if the two time ranges are identical, false if they differ.
    #[doc(alias = "CMTimeRangeEqual")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn equal(self, range2: CMTimeRange) -> bool {
        extern "C-unwind" {
            fn CMTimeRangeEqual(range1: CMTimeRange, range2: CMTimeRange) -> Boolean;
        }
        let ret = unsafe { CMTimeRangeEqual(self, range2) };
        ret != 0
    }

    /// Returns a Boolean value that indicates whether a time range contains a time.
    ///
    /// Parameters:
    /// - range: A time range.
    ///
    /// - time: A time value to test for in the time range.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if `range` contains the `time` value; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Indicates whether a time is contained within a time range.
    ///
    /// This function returns a Boolean value that indicates whether the time specified by the
    /// <i>
    /// time
    /// </i>
    /// parameter
    /// is contained within the range specified by the
    /// <i>
    /// range
    /// </i>
    /// parameter.
    ///
    /// Returns: Returns true if the specified time is contained within the specified time range, false if it is not.
    #[doc(alias = "CMTimeRangeContainsTime")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn contains_time(self, time: CMTime) -> bool {
        extern "C-unwind" {
            fn CMTimeRangeContainsTime(range: CMTimeRange, time: CMTime) -> Boolean;
        }
        let ret = unsafe { CMTimeRangeContainsTime(self, time) };
        ret != 0
    }

    /// Returns a Boolean value that indicates whether a time range contains another time range.
    ///
    /// Parameters:
    /// - range: The first time range to compare.
    ///
    /// - otherRange: The second time range to test for inclusion.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if `range1` contains `range2`; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Indicates whether a time range is contained within a time range.
    ///
    /// This function returns a Boolean value that indicates whether the time range specified by the
    /// <i>
    /// range
    /// </i>
    /// parameter
    /// contains the range specified by the
    /// <i>
    /// otherRange
    /// </i>
    /// parameter.
    ///
    /// Returns: Returns true if the second time range is contained within the first time range, false if it is not.
    #[doc(alias = "CMTimeRangeContainsTimeRange")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn contains_time_range(self, other_range: CMTimeRange) -> bool {
        extern "C-unwind" {
            fn CMTimeRangeContainsTimeRange(
                range: CMTimeRange,
                other_range: CMTimeRange,
            ) -> Boolean;
        }
        let ret = unsafe { CMTimeRangeContainsTimeRange(self, other_range) };
        ret != 0
    }

    /// Returns a time value that represents the end of a time range.
    ///
    /// Parameters:
    /// - range: The time range from which to find the end of the time range.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure.
    ///
    ///
    /// Returns a CMTime structure representing the end of a time range.
    ///
    /// Returns: A CMTime structure representing the end of the specified time range.
    ///
    /// This function returns a CMTime structure that indicates the end of the time range specified by the
    /// <i>
    /// range
    /// </i>
    /// parameter.
    /// CMTimeRangeContainsTime(range, CMTimeRangeGetEnd(range)) is always false.
    #[doc(alias = "CMTimeRangeGetEnd")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn end(self) -> CMTime {
        extern "C-unwind" {
            fn CMTimeRangeGetEnd(range: CMTimeRange) -> CMTime;
        }
        unsafe { CMTimeRangeGetEnd(self) }
    }
}

#[cfg(feature = "CMTime")]
impl CMTime {
    /// Translates a time through a mapping from two time ranges.
    ///
    /// Parameters:
    /// - t: The time value to translate.
    ///
    /// - fromRange: The time range from which the function translates the time range.
    ///
    /// - toRange: The time range to which the function maps the time value.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure that represents the translated time.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The start and end time of `fromRange` maps to the start and end time of `toRange` respectively. The function maps other times linearly using the formula:
    ///
    /// ```objc
    /// result = (t-fromRange.start)*(toRange.duration/fromRange.duration)+toRange.start
    /// ```
    ///
    /// If either `CMTimeRange` argument is empty, the function returns an invalid `CMTime`. If `t` doesn’t have the same epoch as `fromRange.start`, the function returns an invalid `CMTime`. If both `fromRange` and `toRange` have duration `kCMTimePositiveInfinity`, the function offsets `t` relative to the differences between their starts, but not scaled.
    ///
    ///
    /// Translates a time through a mapping from CMTimeRange to CMTimeRange.
    ///
    /// Returns: A CMTime structure representing the translated time.
    ///
    /// The start and end time of fromRange will be mapped to the start and end time of toRange respectively.
    /// Other times will be mapped linearly, using the formula:
    /// result = (t-fromRange.start)*(toRange.duration/fromRange.duration)+toRange.start
    /// If either CMTimeRange argument is empty, an invalid CMTime will be returned.
    /// If t does not have the same epoch as fromRange.start, an invalid CMTime will be returned.
    /// If both fromRange and toRange have duration kCMTimePositiveInfinity,
    /// t will be offset relative to the differences between their starts, but not scaled.
    #[doc(alias = "CMTimeMapTimeFromRangeToRange")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn map_time_from_range_to_range(
        self,
        from_range: CMTimeRange,
        to_range: CMTimeRange,
    ) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMapTimeFromRangeToRange(
                t: CMTime,
                from_range: CMTimeRange,
                to_range: CMTimeRange,
            ) -> CMTime;
        }
        unsafe { CMTimeMapTimeFromRangeToRange(self, from_range, to_range) }
    }

    /// Returns the nearest time value inside the time range.
    ///
    /// Parameters:
    /// - time: The time to clamp.
    ///
    /// - range: The time range to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure inside the time range.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The function returns the times inside the range you specify unmodified. Times before the start and after the end time of the time range return the start and end time of the range. If the `CMTimeRange` argument is empty, this function returns an invalid `CMTime`. If the given `CMTime` is invalid, the function returns an invalid `CMTime`.
    ///
    ///
    /// For a given CMTime and CMTimeRange, returns the nearest CMTime inside that time range.
    ///
    /// Returns: A CMTime structure inside the given time range.
    ///
    /// Times inside the given time range will be returned unmodified.
    /// Times before the start and after the end time of the time range will return the start and end time of
    /// the range respectively.
    /// If the CMTimeRange argument is empty, an invalid CMTime will be returned.
    /// If the given CMTime is invalid, the returned CMTime will be invalid,
    #[doc(alias = "CMTimeClampToRange")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn clamp_to_range(self, range: CMTimeRange) -> CMTime {
        extern "C-unwind" {
            fn CMTimeClampToRange(time: CMTime, range: CMTimeRange) -> CMTime;
        }
        unsafe { CMTimeClampToRange(self, range) }
    }

    /// Translates a duration through a mapping from two time ranges.
    ///
    /// Parameters:
    /// - dur: The duration to translate.
    ///
    /// - fromRange: The time range from which the function translates the duration.
    ///
    /// - toRange: The time range to which the function maps the duration.
    ///
    ///
    /// ## Return Value
    ///
    /// A time structure that represents the translated duration.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The function scales the duration in proportion to the ratio between the ranges’ durations:
    ///
    /// ```objc
    /// result = dur*(toRange.duration/fromRange.duration)
    /// ```
    ///
    /// If `dur` doesn’t have the epoch `0`, the function returns an invalid `CMTime`.
    ///
    ///
    /// Translates a duration through a mapping from CMTimeRange to CMTimeRange.
    ///
    /// Returns: A CMTime structure representing the translated duration.
    ///
    /// The duration will be scaled in proportion to the ratio between the ranges' durations:
    /// result = dur*(toRange.duration/fromRange.duration)
    /// If dur does not have the epoch zero, an invalid CMTime will be returned.
    #[doc(alias = "CMTimeMapDurationFromRangeToRange")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn map_duration_from_range_to_range(
        self,
        from_range: CMTimeRange,
        to_range: CMTimeRange,
    ) -> CMTime {
        extern "C-unwind" {
            fn CMTimeMapDurationFromRangeToRange(
                dur: CMTime,
                from_range: CMTimeRange,
                to_range: CMTimeRange,
            ) -> CMTime;
        }
        unsafe { CMTimeMapDurationFromRangeToRange(self, from_range, to_range) }
    }

    /// Folds a time into a time range.
    ///
    /// Parameters:
    /// - time: The time to fold.
    ///
    /// - foldRange: The time range into which to fold the time.
    ///
    ///
    /// ## Return Value
    ///
    /// A time that represents the translated duration.
    ///
    ///
    /// Folds a time into the given range.  This can be used in looping time calculations.
    ///
    /// Returns: A CMTime structure representing the translated duration.
    ///
    /// Note that for certain types of looping, you may want to NOT fold times that are prior
    /// to the loop range.  That's up to the client.
    #[doc(alias = "CMTimeFoldIntoRange")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn fold_into_range(self, fold_range: CMTimeRange) -> CMTime {
        extern "C-unwind" {
            fn CMTimeFoldIntoRange(time: CMTime, fold_range: CMTimeRange) -> CMTime;
        }
        unsafe { CMTimeFoldIntoRange(self, fold_range) }
    }
}

#[cfg(feature = "CMTime")]
impl CMTimeRange {
    /// Creates a valid time range from a start and end time.
    ///
    /// Parameters:
    /// - start: The start time of the range.
    ///
    /// - end: The end time of the range.
    ///
    ///
    /// ## Return Value
    ///
    /// A valid time range structure.
    ///
    ///
    /// Make a valid CMTimeRange with the given starting and ending times.
    ///
    /// Returns: The resulting CMTimeRange.
    #[doc(alias = "CMTimeRangeFromTimeToTime")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn from_time_to_time(start: CMTime, end: CMTime) -> CMTimeRange {
        extern "C-unwind" {
            fn CMTimeRangeFromTimeToTime(start: CMTime, end: CMTime) -> CMTimeRange;
        }
        unsafe { CMTimeRangeFromTimeToTime(start, end) }
    }

    /// Returns a dictionary representation of a time range.
    ///
    /// Parameters:
    /// - range: The time range from which to create a dictionary.
    ///
    /// - allocator: The allocator with which to create a dictionary.
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary that represents the time range.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This is useful when putting `CMTimeRanges` in Core Foundation container types. Pass `kCFAllocatorDefault` to use the default allocator.
    ///
    /// For keys in the dictionary, see [Dictionary Keys](https://developer.apple.com/documentation/coremedia/cmtimerange-dictionary-keys).
    ///
    ///
    /// Returns a CFDictionary version of a CMTimeRange.
    ///
    /// This is useful when putting CMTimeRanges in CF container types.
    ///
    /// Returns: A CFDictionary version of the CMTimeRange.
    #[doc(alias = "CMTimeRangeCopyAsDictionary")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn as_dictionary(
        self,
        allocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CMTimeRangeCopyAsDictionary(
                range: CMTimeRange,
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CMTimeRangeCopyAsDictionary(self, allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a time range from a dictionary representation of its fields.
    ///
    /// Parameters:
    /// - dictionaryRepresentation: A dictionary from which to create the time range.
    ///
    ///
    /// ## Return Value
    ///
    /// A valid time range structure, or an invalid time range if `dict` doesn’t have the necessary values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This is useful when getting Core Media time ranges from Core Foundation container types. For keys in the dictionary, see [Dictionary Keys](https://developer.apple.com/documentation/coremedia/cmtimerange-dictionary-keys).
    ///
    ///
    /// Reconstitutes a CMTimeRange struct from a CFDictionary previously created by CMTimeRangeCopyAsDictionary.
    ///
    /// This is useful when getting CMTimeRanges from CF container types.  If the CFDictionary does not
    /// have the requisite keyed values, an invalid time range is returned.
    ///
    /// Returns: The created CMTimeRange.
    ///
    /// # Safety
    ///
    /// - `dictionary_representation` generic must be of the correct type.
    /// - `dictionary_representation` generic must be of the correct type.
    #[doc(alias = "CMTimeRangeMakeFromDictionary")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn from_dictionary(dictionary_representation: &CFDictionary) -> CMTimeRange {
        extern "C-unwind" {
            fn CMTimeRangeMakeFromDictionary(
                dictionary_representation: &CFDictionary,
            ) -> CMTimeRange;
        }
        unsafe { CMTimeRangeMakeFromDictionary(dictionary_representation) }
    }
}

extern "C" {
    /// The key for the start field of a time range.
    /// CFDictionary key for start field of a CMTimeRange (CMTime)
    pub static kCMTimeRangeStartKey: &'static CFString;
}

extern "C" {
    /// The key for the timescale of a time range.
    /// CFDictionary key for timescale field of a CMTimeRange (CMTime)
    pub static kCMTimeRangeDurationKey: &'static CFString;
}

#[cfg(feature = "CMTime")]
impl CMTimeRange {
    /// Returns a string with a description of a time range.
    ///
    /// Parameters:
    /// - allocator: The allocator the function uses when allocating memory for the description.
    ///
    /// - range: The time range to describe.
    ///
    ///
    /// ## Return Value
    ///
    /// A string description.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You use this from within `CFShow` on an object that contains `CMTimeRange` fields. It is also useful from other client debugging code.  The caller owns the `CFString` this function returns and is responsible for releasing it. Pass `kCFAllocatorDefault` to use the default allocator.
    ///
    ///
    /// Creates a CFString with a description of a CMTimeRange (just like CFCopyDescription).
    ///
    /// This is used from within CFShow on an object that contains CMTimeRange fields. It is
    /// also useful from other client debugging code.  The caller owns the returned CFString and is responsible for releasing it.
    ///
    /// Returns: The created CFString description.
    #[doc(alias = "CMTimeRangeCopyDescription")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn description(
        allocator: Option<&CFAllocator>,
        range: CMTimeRange,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CMTimeRangeCopyDescription(
                allocator: Option<&CFAllocator>,
                range: CMTimeRange,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CMTimeRangeCopyDescription(allocator, range) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Prints a description of the time range to standard error.
    ///
    /// Parameters:
    /// - range: The time range to print.
    ///
    ///
    /// ## Discussion
    ///
    /// This is most useful from within LLDB.
    ///
    ///
    /// Prints a description of the CMTimeRange (just like CFShow).
    ///
    /// This is most useful from within gdb.
    #[doc(alias = "CMTimeRangeShow")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn show(self) {
        extern "C-unwind" {
            fn CMTimeRangeShow(range: CMTimeRange);
        }
        unsafe { CMTimeRangeShow(self) }
    }
}

/// A structure that maps a segment of a source time range to a target time range.
/// A CMTimeMapping specifies the mapping of a segment of one time line (called "source") into another time line (called "target").
///
/// When used for movie edit lists, the source time line is the media and the target time line is the track/movie.
/// Field: source
/// The time range on the source time line.
/// For an empty edit, source.start is an invalid CMTime, in which case source.duration shall be ignored.
/// Otherwise, source.start is the starting time within the source, and source.duration is the duration
/// of the source timeline to be mapped to the target time range.
/// Field: target
/// The time range on the target time line.
/// If target.duration and source.duration are different, then the source segment should
/// be played at rate source.duration/target.duration to fit.
#[cfg(feature = "CMTime")]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CMTimeMapping {
    pub source: CMTimeRange,
    pub target: CMTimeRange,
}

#[cfg(all(feature = "CMTime", feature = "objc2"))]
unsafe impl Encode for CMTimeMapping {
    const ENCODING: Encoding =
        Encoding::Struct("?", &[<CMTimeRange>::ENCODING, <CMTimeRange>::ENCODING]);
}

#[cfg(all(feature = "CMTime", feature = "objc2"))]
unsafe impl RefEncode for CMTimeMapping {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// An invalid time mapping.
    #[cfg(feature = "CMTime")]
    pub static kCMTimeMappingInvalid: CMTimeMapping;
}

#[cfg(feature = "CMTime")]
impl CMTimeMapping {
    /// Creates a time mapping with a source and target time range.
    ///
    /// Parameters:
    /// - source: A time range on the source timeline.
    ///
    /// - target: A time range on the target timeline.
    ///
    ///
    /// ## Return Value
    ///
    /// A new time mapping.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The source and target parameters must have durations whose epoch is `0`, otherwise the system returns an invalid time mapping.
    ///
    ///
    /// Make a valid CMTimeMapping with source and target.
    ///
    /// Returns: The resulting CMTimeMapping.
    ///
    /// The source and target parameters must have durations whose epoch is 0; otherwise an invalid time mapping will be returned.
    #[doc(alias = "CMTimeMappingMake")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn new(source: CMTimeRange, target: CMTimeRange) -> CMTimeMapping {
        extern "C-unwind" {
            fn CMTimeMappingMake(source: CMTimeRange, target: CMTimeRange) -> CMTimeMapping;
        }
        unsafe { CMTimeMappingMake(source, target) }
    }

    /// Creates a valid time mapping with an empty source.
    ///
    /// Parameters:
    /// - target: A time range on the target timeline.
    ///
    ///
    /// ## Return Value
    ///
    /// A new time mapping.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The target time range must have a duration whose epoch is `0`, otherwise the system returns an invalid time mapping.
    ///
    ///
    /// Make a valid CMTimeMapping with an empty source.
    ///
    /// Returns: The resulting CMTimeMapping.
    ///
    /// The target parameter must have a duration whose epoch is 0; otherwise an invalid time mapping will be returned.
    #[doc(alias = "CMTimeMappingMakeEmpty")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn empty(target: CMTimeRange) -> CMTimeMapping {
        extern "C-unwind" {
            fn CMTimeMappingMakeEmpty(target: CMTimeRange) -> CMTimeMapping;
        }
        unsafe { CMTimeMappingMakeEmpty(target) }
    }

    /// Returns a dictionary representation of a time mapping.
    ///
    /// Parameters:
    /// - mapping: The time mapping for which to create a dictionary representation.
    ///
    /// - allocator: An allocator to use to create a dictionary. Pass `kCFAllocatorDefault` to use the default allocator.
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary representation of a time mapping.
    ///
    ///
    /// Returns a CFDictionary version of a CMTimeMapping.
    ///
    /// This is useful when putting CMTimeMappings in CF container types.
    ///
    /// Returns: A CFDictionary version of the CMTimeMapping.
    #[doc(alias = "CMTimeMappingCopyAsDictionary")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn as_dictionary(
        self,
        allocator: Option<&CFAllocator>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CMTimeMappingCopyAsDictionary(
                mapping: CMTimeMapping,
                allocator: Option<&CFAllocator>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CMTimeMappingCopyAsDictionary(self, allocator) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a time mapping from a dictionary representation.
    ///
    /// Parameters:
    /// - dictionaryRepresentation: A dictionary representation of a time mapping that you previously created by calling the [`CMTimeMappingCopyAsDictionary`](https://developer.apple.com/documentation/coremedia/cmtimemappingcopyasdictionary(_:allocator:)) function.
    ///
    ///
    /// ## Return Value
    ///
    /// A new time mapping.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the dictionary you provide doesn’t have the requisite keyed values, the system returns an invalid time mapping.
    ///
    ///
    /// Reconstitutes a CMTimeMapping struct from a CFDictionary previously created by CMTimeMappingCopyAsDictionary.
    ///
    /// This is useful when getting CMTimeMappings from CF container types.  If the CFDictionary does not
    /// have the requisite keyed values, an invalid time mapping is returned.
    ///
    /// Returns: The created CMTimeMapping.
    ///
    /// # Safety
    ///
    /// - `dictionary_representation` generic must be of the correct type.
    /// - `dictionary_representation` generic must be of the correct type.
    #[doc(alias = "CMTimeMappingMakeFromDictionary")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn from_dictionary(dictionary_representation: &CFDictionary) -> CMTimeMapping {
        extern "C-unwind" {
            fn CMTimeMappingMakeFromDictionary(
                dictionary_representation: &CFDictionary,
            ) -> CMTimeMapping;
        }
        unsafe { CMTimeMappingMakeFromDictionary(dictionary_representation) }
    }
}

extern "C" {
    /// A dictionary key for a source time range.
    /// CFDictionary key for source field of a CMTimeMapping (CMTimeRange)
    pub static kCMTimeMappingSourceKey: &'static CFString;
}

extern "C" {
    /// A dictionary key for a target time range.
    /// CFDictionary key for target field of a CMTimeMapping (CMTimeRange)
    pub static kCMTimeMappingTargetKey: &'static CFString;
}

#[cfg(feature = "CMTime")]
impl CMTimeMapping {
    /// Copies a string description of a time mapping.
    ///
    /// Parameters:
    /// - allocator: An allocator to use to create a dictionary. Pass `kCFAllocatorDefault` to use the default allocator.
    ///
    /// - mapping: The time mapping from which to copy a description.
    ///
    ///
    /// ## Return Value
    ///
    /// A string description of a time mapping.
    ///
    ///
    /// Creates a CFString with a description of a CMTimeMapping (just like CFCopyDescription).
    ///
    /// This is used from within CFShow on an object that contains CMTimeMapping fields. It is
    /// also useful from other client debugging code.  The caller owns the returned CFString and is responsible for releasing it.
    ///
    /// Returns: The created CFString description.
    #[doc(alias = "CMTimeMappingCopyDescription")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn description(
        allocator: Option<&CFAllocator>,
        mapping: CMTimeMapping,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CMTimeMappingCopyDescription(
                allocator: Option<&CFAllocator>,
                mapping: CMTimeMapping,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CMTimeMappingCopyDescription(allocator, mapping) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Prints a description of a time mapping to standard output.
    ///
    /// Parameters:
    /// - mapping: The time mapping to show.
    ///
    ///
    /// ## Discussion
    ///
    /// You typically use this function for debugging purposes.
    ///
    ///
    /// Prints a description of a CMTimeMapping (just like CFShow).
    ///
    /// This is most useful from within gdb.
    #[doc(alias = "CMTimeMappingShow")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn show(self) {
        extern "C-unwind" {
            fn CMTimeMappingShow(mapping: CMTimeMapping);
        }
        unsafe { CMTimeMappingShow(self) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeRange::new`"]
    pub fn CMTimeRangeMake(start: CMTime, duration: CMTime) -> CMTimeRange;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeRange::union`"]
    pub fn CMTimeRangeGetUnion(range: CMTimeRange, other_range: CMTimeRange) -> CMTimeRange;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeRange::intersection`"]
    pub fn CMTimeRangeGetIntersection(range: CMTimeRange, other_range: CMTimeRange) -> CMTimeRange;
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMTimeRange::equal`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimeRangeEqual(range1: CMTimeRange, range2: CMTimeRange) -> bool {
    extern "C-unwind" {
        fn CMTimeRangeEqual(range1: CMTimeRange, range2: CMTimeRange) -> Boolean;
    }
    let ret = unsafe { CMTimeRangeEqual(range1, range2) };
    ret != 0
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMTimeRange::contains_time`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimeRangeContainsTime(range: CMTimeRange, time: CMTime) -> bool {
    extern "C-unwind" {
        fn CMTimeRangeContainsTime(range: CMTimeRange, time: CMTime) -> Boolean;
    }
    let ret = unsafe { CMTimeRangeContainsTime(range, time) };
    ret != 0
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMTimeRange::contains_time_range`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimeRangeContainsTimeRange(
    range: CMTimeRange,
    other_range: CMTimeRange,
) -> bool {
    extern "C-unwind" {
        fn CMTimeRangeContainsTimeRange(range: CMTimeRange, other_range: CMTimeRange) -> Boolean;
    }
    let ret = unsafe { CMTimeRangeContainsTimeRange(range, other_range) };
    ret != 0
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeRange::end`"]
    pub fn CMTimeRangeGetEnd(range: CMTimeRange) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTime::map_time_from_range_to_range`"]
    pub fn CMTimeMapTimeFromRangeToRange(
        t: CMTime,
        from_range: CMTimeRange,
        to_range: CMTimeRange,
    ) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTime::clamp_to_range`"]
    pub fn CMTimeClampToRange(time: CMTime, range: CMTimeRange) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTime::map_duration_from_range_to_range`"]
    pub fn CMTimeMapDurationFromRangeToRange(
        dur: CMTime,
        from_range: CMTimeRange,
        to_range: CMTimeRange,
    ) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTime::fold_into_range`"]
    pub fn CMTimeFoldIntoRange(time: CMTime, fold_range: CMTimeRange) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeRange::from_time_to_time`"]
    pub fn CMTimeRangeFromTimeToTime(start: CMTime, end: CMTime) -> CMTimeRange;
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMTimeRange::as_dictionary`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimeRangeCopyAsDictionary(
    range: CMTimeRange,
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CMTimeRangeCopyAsDictionary(
            range: CMTimeRange,
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CMTimeRangeCopyAsDictionary(range, allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeRange::from_dictionary`"]
    pub fn CMTimeRangeMakeFromDictionary(dictionary_representation: &CFDictionary) -> CMTimeRange;
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMTimeRange::description`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimeRangeCopyDescription(
    allocator: Option<&CFAllocator>,
    range: CMTimeRange,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CMTimeRangeCopyDescription(
            allocator: Option<&CFAllocator>,
            range: CMTimeRange,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CMTimeRangeCopyDescription(allocator, range) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeRange::show`"]
    pub fn CMTimeRangeShow(range: CMTimeRange);
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeMapping::new`"]
    pub fn CMTimeMappingMake(source: CMTimeRange, target: CMTimeRange) -> CMTimeMapping;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeMapping::empty`"]
    pub fn CMTimeMappingMakeEmpty(target: CMTimeRange) -> CMTimeMapping;
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMTimeMapping::as_dictionary`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimeMappingCopyAsDictionary(
    mapping: CMTimeMapping,
    allocator: Option<&CFAllocator>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CMTimeMappingCopyAsDictionary(
            mapping: CMTimeMapping,
            allocator: Option<&CFAllocator>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CMTimeMappingCopyAsDictionary(mapping, allocator) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeMapping::from_dictionary`"]
    pub fn CMTimeMappingMakeFromDictionary(
        dictionary_representation: &CFDictionary,
    ) -> CMTimeMapping;
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMTimeMapping::description`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimeMappingCopyDescription(
    allocator: Option<&CFAllocator>,
    mapping: CMTimeMapping,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CMTimeMappingCopyDescription(
            allocator: Option<&CFAllocator>,
            mapping: CMTimeMapping,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CMTimeMappingCopyDescription(allocator, mapping) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimeMapping::show`"]
    pub fn CMTimeMappingShow(mapping: CMTimeMapping);
}
