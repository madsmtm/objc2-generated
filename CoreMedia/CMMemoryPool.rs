//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// CMMemoryPool.h
///
/// Memory pool for optimizing repeated large block allocation.
///
/// CMMemoryPool is a memory allocation service that holds onto a pool of
/// recently deallocated memory so as to speed up subsequent allocations of the same size.
/// It's intended for cases where large memory blocks need to be repeatedly allocated --
/// for example, the compressed data output by a video encoder.
///
/// All of its allocations are on the granularity of page sizes; it does not suballocate
/// memory within pages, so it is a poor choice for allocating tiny blocks.
/// For example, it's appropriate to use as the blockAllocator argument to
/// CMBlockBufferCreateWithMemoryBlock, but not the structureAllocator argument --
/// use kCFAllocatorDefault instead.
///
/// When you no longer need to allocate memory from the pool, call CMMemoryPoolInvalidate
/// and CFRelease.  Calling CMMemoryPoolInvalidate tells the pool to stop holding onto
/// memory for reuse.  Note that the pool's CFAllocator can outlive the pool, owing
/// to the way that CoreFoundation is designed: CFAllocators are themselves CF objects,
/// and every object allocated with a CFAllocator implicitly retains the CFAllocator
/// until it is finalized.  After the CMMemoryPool is invalidated or finalized,
/// its CFAllocator allocates and deallocates with no pooling behavior.
///
/// CMMemoryPool deallocates memory if it has not been recycled in 0.5 second,
/// so that short-term peak usage does not cause persistent bloat.
/// (This period may be overridden by specifying kCMMemoryPoolOption_AgeOutPeriod.)
/// Such "aging out" is done during the pool's CFAllocatorAllocate and
/// CFAllocatorDeallocate methods.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmmemorypool?language=objc)
#[doc(alias = "CMMemoryPoolRef")]
#[repr(C)]
pub struct CMMemoryPool {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CMMemoryPool {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueCMMemoryPool"> for CMMemoryPool {}
);

unsafe impl Send for CMMemoryPool {}

unsafe impl Sync for CMMemoryPool {}

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmmemorypoolerror_allocationfailed?language=objc)
pub const kCMMemoryPoolError_AllocationFailed: OSStatus = -15490;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmmemorypoolerror_invalidparameter?language=objc)
pub const kCMMemoryPoolError_InvalidParameter: OSStatus = -15491;

unsafe impl ConcreteType for CMMemoryPool {
    #[doc(alias = "CMMemoryPoolGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMMemoryPoolGetTypeID() -> CFTypeID;
        }
        unsafe { CMMemoryPoolGetTypeID() }
    }
}

extern "C" {
    /// Specifies how long memory should be allowed to hang out in the pool before being deallocated.
    ///
    /// Pass this in the options dictionary to CMMemoryPoolCreate.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmmemorypooloption_ageoutperiod?language=objc)
    pub static kCMMemoryPoolOption_AgeOutPeriod: &'static CFString;
}

impl CMMemoryPool {
    /// Creates a new CMMemoryPool.
    ///
    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CMMemoryPoolCreate")]
    #[inline]
    pub unsafe fn new(options: Option<&CFDictionary>) -> CFRetained<CMMemoryPool> {
        extern "C-unwind" {
            fn CMMemoryPoolCreate(options: Option<&CFDictionary>) -> Option<NonNull<CMMemoryPool>>;
        }
        let ret = unsafe { CMMemoryPoolCreate(options) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Returns the pool's CFAllocator.
    #[doc(alias = "CMMemoryPoolGetAllocator")]
    #[inline]
    pub unsafe fn allocator(&self) -> CFRetained<CFAllocator> {
        extern "C-unwind" {
            fn CMMemoryPoolGetAllocator(pool: &CMMemoryPool) -> Option<NonNull<CFAllocator>>;
        }
        let ret = unsafe { CMMemoryPoolGetAllocator(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Deallocates all memory the pool was holding for recycling.
    #[doc(alias = "CMMemoryPoolFlush")]
    #[inline]
    pub unsafe fn flush(&self) {
        extern "C-unwind" {
            fn CMMemoryPoolFlush(pool: &CMMemoryPool);
        }
        unsafe { CMMemoryPoolFlush(self) }
    }

    /// Stops the pool from recycling.
    ///
    /// When CMMemoryPoolInvalidate is called the pool's allocator stops recycling memory.
    /// The pool deallocates any memory it was holding for recycling.
    /// This also happens when the retain count of the CMMemoryPool drops to zero,
    /// except that under GC it may be delayed.
    #[doc(alias = "CMMemoryPoolInvalidate")]
    #[inline]
    pub unsafe fn invalidate(&self) {
        extern "C-unwind" {
            fn CMMemoryPoolInvalidate(pool: &CMMemoryPool);
        }
        unsafe { CMMemoryPoolInvalidate(self) }
    }
}

#[deprecated = "renamed to `CMMemoryPool::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CMMemoryPoolCreate(
    options: Option<&CFDictionary>,
) -> CFRetained<CMMemoryPool> {
    extern "C-unwind" {
        fn CMMemoryPoolCreate(options: Option<&CFDictionary>) -> Option<NonNull<CMMemoryPool>>;
    }
    let ret = unsafe { CMMemoryPoolCreate(options) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CMMemoryPool::allocator`"]
#[inline]
pub unsafe extern "C-unwind" fn CMMemoryPoolGetAllocator(
    pool: &CMMemoryPool,
) -> CFRetained<CFAllocator> {
    extern "C-unwind" {
        fn CMMemoryPoolGetAllocator(pool: &CMMemoryPool) -> Option<NonNull<CFAllocator>>;
    }
    let ret = unsafe { CMMemoryPoolGetAllocator(pool) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMMemoryPool::flush`"]
    pub fn CMMemoryPoolFlush(pool: &CMMemoryPool);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMMemoryPool::invalidate`"]
    pub fn CMMemoryPoolInvalidate(pool: &CMMemoryPool);
}
