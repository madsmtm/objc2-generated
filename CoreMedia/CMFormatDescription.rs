//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-audio-types")]
use objc2_core_audio_types::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-video")]
use objc2_core_video::*;

use crate::*;

/// An error that indicates that the function recieves an empty value for a parameter it requires.
pub const kCMFormatDescriptionError_InvalidParameter: OSStatus = -12710;
/// An error that indicates when an allocation fails.
pub const kCMFormatDescriptionError_AllocationFailed: OSStatus = -12711;
/// An error that indicates the format description doesn’t contain the value you request.
pub const kCMFormatDescriptionError_ValueNotAvailable: OSStatus = -12718;

/// An object that describes a media format descriptor.
///
/// ## Overview
///
/// A `CMFormatDescription` object is an object that describes media types (audio, video, muxed, and so on).
///
///
/// A reference to a CMFormatDescription, a CF object describing media of a particular type (audio, video, muxed, etc).
#[doc(alias = "CMFormatDescriptionRef")]
#[repr(C)]
pub struct CMFormatDescription {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CMFormatDescription {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"opaqueCMFormatDescription"> for CMFormatDescription {}
);

unsafe impl Send for CMFormatDescription {}

unsafe impl Sync for CMFormatDescription {}

/// Constants that represent media types.
/// The type of media described by a CMFormatDescription.
pub type CMMediaType = FourCharCode;

/// Video media.
pub const kCMMediaType_Video: CMMediaType = 0x76696465;
/// Audio media.
pub const kCMMediaType_Audio: CMMediaType = 0x736f756e;
/// Muxed media.
pub const kCMMediaType_Muxed: CMMediaType = 0x6d757878;
/// Text media.
pub const kCMMediaType_Text: CMMediaType = 0x74657874;
/// Closed-caption media.
pub const kCMMediaType_ClosedCaption: CMMediaType = 0x636c6370;
/// Subtitle media.
pub const kCMMediaType_Subtitle: CMMediaType = 0x7362746c;
/// Time code media.
pub const kCMMediaType_TimeCode: CMMediaType = 0x746d6364;
/// Meta data.
pub const kCMMediaType_Metadata: CMMediaType = 0x6d657461;
/// Media containing a tagged buffer group.
pub const kCMMediaType_TaggedBufferGroup: CMMediaType = 0x74626772;

pub const kCMMediaType_AuxiliaryPicture: CMMediaType = 0x61757876;

impl CMFormatDescription {
    /// Creates a format description for general use.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for creating the `CMFormatDescription`.
    ///
    /// - mediaType: The type that identifies the media.
    ///
    /// - mediaSubType: The type that identifies the subtype of the media.
    ///
    /// - extensions: A dictionary of extensions to attach to the description. May be `NULL`.
    ///
    /// - formatDescriptionOut: Receives the `CMFormatDescription` the function creates.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The system uses the default allocator if you don’t specify one. Use this to create any `CMFormatDescription` that is composed solely of extensions, and for which `CFEqual`() of the extensions dictionaries is a valid test for Format Description equality.
    ///
    /// Don’t call this method for media types that have specific create functions, such as [`CMAudioFormatDescriptionCreate`](https://developer.apple.com/documentation/coremedia/cmaudioformatdescriptioncreate(allocator:asbd:layoutsize:layout:magiccookiesize:magiccookie:extensions:formatdescriptionout:)) and [`CMVideoFormatDescriptionCreate`](https://developer.apple.com/documentation/coremedia/cmvideoformatdescriptioncreate(allocator:codectype:width:height:extensions:formatdescriptionout:)).
    ///
    ///
    /// Creates a generic CMFormatDescription object.
    ///
    /// Use this call to create any CMFormatDescription that is composed solely of extensions, and for which
    /// CFEqual() of a the extensions dictionaries is a valid test for Format Description equality.  Note that
    /// for some media types using this routine may result in creating a format description that is not fully
    /// specified for the purpose of media processing. Whenever possible, use media-specific format description
    /// creations routines such as CMVideoFormatDescriptionCreate, CMAudioFormatDescriptionCreate, etc.
    ///
    /// Returns: A new CMFormatDescription object.
    ///
    /// # Safety
    ///
    /// - `extensions` generic must be of the correct type.
    /// - `extensions` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    #[doc(alias = "CMFormatDescriptionCreate")]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        media_type: CMMediaType,
        media_sub_type: FourCharCode,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMFormatDescription>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMFormatDescriptionCreate(
                allocator: Option<&CFAllocator>,
                media_type: CMMediaType,
                media_sub_type: FourCharCode,
                extensions: Option<&CFDictionary>,
                format_description_out: NonNull<*const CMFormatDescription>,
            ) -> OSStatus;
        }
        unsafe {
            CMFormatDescriptionCreate(
                allocator,
                media_type,
                media_sub_type,
                extensions,
                format_description_out,
            )
        }
    }
}

unsafe impl ConcreteType for CMFormatDescription {
    /// Returns the Core Foundation type identifier that identifies format description objects.
    ///
    /// ## Discussion
    ///
    /// You can check if a `CFTypeRef` object is a `CMFormatDescription` by comparing CFGetTypeID(object) with `CMFormatDescriptionGetTypeID`().
    ///
    ///
    /// Returns the CFTypeID of CMFormatDescription objects.
    ///
    /// You can check if a CFTypeRef object is actually a CMFormatDescription
    /// by comparing CFGetTypeID(object) with CMFormatDescriptionGetTypeID().
    #[doc(alias = "CMFormatDescriptionGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMFormatDescriptionGetTypeID() -> CFTypeID;
        }
        unsafe { CMFormatDescriptionGetTypeID() }
    }
}

impl CMFormatDescription {
    /// Returns a Boolean value that indicates whether two format descriptions are equal.
    ///
    /// Parameters:
    /// - formatDescription: The first description to compare.
    ///
    /// - otherFormatDescription: The second description to compare.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the two descriptions are equal; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This calls `CFEqual` on the provided `CMFormatDescription` objects. In contrast to the Core Foundation call it is `NULL` safe.
    ///
    ///
    /// Compares two CMFormatDescription objects for equality.
    ///
    /// This calls CFEqual on the provided CMFormatDescription objects.
    /// In contrast to the CF call it is NULL safe.
    #[doc(alias = "CMFormatDescriptionEqual")]
    #[inline]
    pub unsafe fn equal(
        format_description: Option<&CMFormatDescription>,
        other_format_description: Option<&CMFormatDescription>,
    ) -> bool {
        extern "C-unwind" {
            fn CMFormatDescriptionEqual(
                format_description: Option<&CMFormatDescription>,
                other_format_description: Option<&CMFormatDescription>,
            ) -> Boolean;
        }
        let ret = unsafe { CMFormatDescriptionEqual(format_description, other_format_description) };
        ret != 0
    }

    /// Returns a Boolean value that indicates whether two format descriptions are equal, ignoring differences in the extension keys you specify.
    ///
    /// Parameters:
    /// - formatDescription: The first description to compare.
    ///
    /// - otherFormatDescription: The second description to compare.
    ///
    /// - formatDescriptionExtensionKeysToIgnore: A single format description extension key (`CFString`) or an array (`CFArray`) of keys.
    ///
    /// - sampleDescriptionExtensionAtomKeysToIgnore: A single sample description extension atom key (four-character `CFString`) or an array (`CFArray`) of such keys.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the two descriptions are equal; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// When you specify any keys, the function ignores `kCMFormatDescriptionExtension_VerbatimSampleDescription` and `kCMFormatDescriptionExtension_VerbatimISOSampleEntry` for the purpose of comparison.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This function is `NULL` safe.
    ///
    ///
    ///
    /// </div>
    /// For extension atom keys, see [`kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms`](https://developer.apple.com/documentation/coremedia/kcmformatdescriptionextension_sampledescriptionextensionatoms).
    ///
    ///
    /// Compares two CMFormatDescription objects for equality, ignoring differences in specified lists of format description extension keys and sample description extension keys.
    ///
    /// This function is NULL safe.
    /// If any keys are passed, kCMFormatDescriptionExtension_VerbatimSampleDescription
    /// and kCMFormatDescriptionExtension_VerbatimISOSampleEntry will also be automatically
    /// ignored for the purpose of comparison.
    ///
    /// Parameter `formatDescriptionExtensionKeysToIgnore`: Either a single format description extension key (CFString)
    /// or a CFArray of such keys.
    ///
    /// Parameter `sampleDescriptionExtensionAtomKeysToIgnore`: Either a single sample description extension atom key (four-character CFString)
    /// or a CFArray of such keys.
    /// See kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms.
    ///
    /// # Safety
    ///
    /// - `format_description_extension_keys_to_ignore` should be of the correct type.
    /// - `sample_description_extension_atom_keys_to_ignore` should be of the correct type.
    #[doc(alias = "CMFormatDescriptionEqualIgnoringExtensionKeys")]
    #[inline]
    pub unsafe fn equal_ignoring_extension_keys(
        format_description: Option<&CMFormatDescription>,
        other_format_description: Option<&CMFormatDescription>,
        format_description_extension_keys_to_ignore: Option<&CFType>,
        sample_description_extension_atom_keys_to_ignore: Option<&CFType>,
    ) -> bool {
        extern "C-unwind" {
            fn CMFormatDescriptionEqualIgnoringExtensionKeys(
                format_description: Option<&CMFormatDescription>,
                other_format_description: Option<&CMFormatDescription>,
                format_description_extension_keys_to_ignore: Option<&CFType>,
                sample_description_extension_atom_keys_to_ignore: Option<&CFType>,
            ) -> Boolean;
        }
        let ret = unsafe {
            CMFormatDescriptionEqualIgnoringExtensionKeys(
                format_description,
                other_format_description,
                format_description_extension_keys_to_ignore,
                sample_description_extension_atom_keys_to_ignore,
            )
        };
        ret != 0
    }

    /// Returns the media type of a format description.
    ///
    /// Parameters:
    /// - desc: A `CMFormatDescription` to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A media type that identifies the format description.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For example, this function returns [`kCMMediaType_Audio`](https://developer.apple.com/documentation/coremedia/kcmmediatype_audio) for a description of an audio stream.
    ///
    ///
    /// Returns the media type of a CMFormatDescription.
    ///
    /// For example, returns kCMMediaType_Audio for a description of an audio stream.
    ///
    /// Returns: The media type of the CMFormatDescription.
    #[doc(alias = "CMFormatDescriptionGetMediaType")]
    #[inline]
    pub unsafe fn media_type(&self) -> CMMediaType {
        extern "C-unwind" {
            fn CMFormatDescriptionGetMediaType(desc: &CMFormatDescription) -> CMMediaType;
        }
        unsafe { CMFormatDescriptionGetMediaType(self) }
    }

    /// Returns the media subtype of a format description.
    ///
    /// Parameters:
    /// - desc: The `CMFormatDescription` to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// A media type that identifies the subtype of the `CMFormatDescription`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For audio streams, the media subtype is the `asbd.mFormatID`. For video streams, the media subtype is the video codec type. For muxed streams, it’s the format of the muxed stream.
    ///
    /// For example, the function returns `aac` for a description of an AAC audio stream, `avc1` for a description of an H.264 video stream, and `mp2t` for a description of an MPEG-2 transport (muxed) stream.  If a media stream doesn’t have subtypes, this API may return `0`.
    ///
    ///
    /// Returns the media subtype of a CMFormatDescription.
    ///
    /// The media subtype is defined in a media-specific way.
    /// For audio streams, the media subtype is the asbd.mFormatID.
    /// For video streams, the media subtype is the video codec type.
    /// For muxed streams, it is the format of the muxed stream.
    /// For example, 'aac ' is returned for a description of an AAC audio
    /// stream, 'avc1' is returned for a description of an H.264 video
    /// stream, and 'mp2t' is returned for a description of an MPEG-2
    /// transport (muxed) stream.  If a particular type of media stream
    /// does not have subtypes, this API may return 0.
    ///
    /// Returns: The media subtype of the CMFormatDescription.
    #[doc(alias = "CMFormatDescriptionGetMediaSubType")]
    #[inline]
    pub unsafe fn media_sub_type(&self) -> FourCharCode {
        extern "C-unwind" {
            fn CMFormatDescriptionGetMediaSubType(desc: &CMFormatDescription) -> FourCharCode;
        }
        unsafe { CMFormatDescriptionGetMediaSubType(self) }
    }

    /// Returns all of the extensions for a format description.
    ///
    /// Parameters:
    /// - desc: The `CMFormatDescription` to examine.
    ///
    ///
    /// ## Return Value
    ///
    /// An immutable dictionary that contains all the extensions of the `CMFormatDescription`.  May be `NULL`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If there are no extensions, the function returns `NULL`. Extensions dictionaries are valid property list objects.  This means that dictionary keys are all `CFStrings`, and the values are all either `CFNumber`, `CFString`, `CFBoolean`, `CFArray`, `CFDictionary`, `CFDate`, or `CFData`. The returned dictionary is not retained by this call, so clients are required to retain it if they need to keep it longer.
    ///
    ///
    /// Returns an immutable dictionary containing all the extensions of a CMFormatDescription.
    ///
    /// If there are no extensions, NULL is returned. Extensions dictionaries are valid property list
    /// objects.  This means that dictionary keys are all CFStrings, and the values are all either
    /// CFNumber, CFString, CFBoolean, CFArray, CFDictionary, CFDate, or CFData. The returned
    /// dictionary is not retained by this call, so clients are required to retain it if they
    /// need to keep it longer.
    ///
    /// Returns: An immutable dictionary containing all the extensions of the CMFormatDescription.  May be NULL.
    #[doc(alias = "CMFormatDescriptionGetExtensions")]
    #[inline]
    pub unsafe fn extensions(&self) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CMFormatDescriptionGetExtensions(
                desc: &CMFormatDescription,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CMFormatDescriptionGetExtensions(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }
}

extern "C" {
    /// kCMFormatDescriptionExtension_OriginalCompressionSettings
    ///
    /// This extension contains a media-type-specific dictionary of settings used to produce a compressed media buffer.
    ///
    /// This extension is valid for format descriptions of all media types, but the contents of the dictionary are defined
    /// in a media-specific way.  The dictionary and its contents are valid property list objects. This means that
    /// dictionary keys are all CFStrings, and the values are all either CFNumber, CFString, CFBoolean, CFArray,
    /// CFDictionary, CFDate, or CFData.
    pub static kCMFormatDescriptionExtension_OriginalCompressionSettings: &'static CFString;
}

extern "C" {
    /// kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms
    ///
    /// Sample description extension atoms that were not translated into other entries in the extensions dictionary.
    ///
    /// This key is used by sample description bridges to hold sample description
    /// extension atoms that they do not recognize.
    /// The extension is a CFDictionary mapping CFStrings of the four-char-code atom types
    /// to either CFDatas containing the atom payload or (to represent multiple atoms of a
    /// specific type) to CFArrays of CFData containing those payloads.
    pub static kCMFormatDescriptionExtension_SampleDescriptionExtensionAtoms: &'static CFString;
}

extern "C" {
    /// kCMFormatDescriptionExtension_VerbatimSampleDescription
    ///
    /// Preserves the original SampleDescription data.
    ///
    /// This extension is used to ensure that roundtrips from sample descriptions
    /// to CMFormatDescriptions back to sample descriptions preserve the exact original
    /// sample descriptions.
    /// IMPORTANT: If you make a modified clone of a CMFormatDescription, you must
    /// delete this extension from the clone, or your modifications could be lost.
    pub static kCMFormatDescriptionExtension_VerbatimSampleDescription: &'static CFString;
}

extern "C" {
    /// kCMFormatDescriptionExtension_VerbatimISOSampleEntry
    ///
    /// Preserves the original ISOSampleEntry data.
    ///
    /// This extension is used to ensure that roundtrips from ISO Sample Entry (ie. AudioSampleEntry or VisualSampleEntry)
    /// to CMFormatDescriptions back to ISO Sample Entry preserve the exact original
    /// sample descriptions.
    /// IMPORTANT: If you make a modified clone of a CMFormatDescription, you must
    /// delete this extension from the clone, or your modifications could be lost.
    pub static kCMFormatDescriptionExtension_VerbatimISOSampleEntry: &'static CFString;
}

impl CMFormatDescription {
    /// Returns an extension from the format description by using an extension key.
    ///
    /// Parameters:
    /// - desc: The `CMFormatDescription` to examine.
    ///
    /// - extensionKey: The key of the extension to return. May not be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// An extension, or `NULL` if it doesn’t exist.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The extension is always a valid property list object. This means that it will be either a `CFNumber`, `CFString`, `CFBoolean`, `CFArray`, `CFDictionary`, `CFDate`, or `CFData`. If it’s a `CFDictionary`, the keys will all be `CFStrings`. The extension this function returns is not retained by this call, so it’s only valid as long as the `CMFormatDescription` is valid — retain it to keep it longer.
    ///
    ///
    /// Returns the specified extension of a CMFormatDescription.
    ///
    /// If the named extension does not exist, NULL is returned. The extension is always a valid
    /// property list object. This means that it will be either a CFNumber, CFString, CFBoolean,
    /// CFArray, CFDictionary, CFDate, or CFData. If it is a CFDictionary, the keys will all be
    /// CFStrings. The returned extension is not retained by this call, so it is only valid as
    /// long as the CMFormatDescription is valid. Clients are required to retain it if they
    /// need to keep it longer.
    ///
    /// Returns: The specified extension of the CMFormatDescription.  May be NULL.
    #[doc(alias = "CMFormatDescriptionGetExtension")]
    #[inline]
    pub unsafe fn extension(&self, extension_key: &CFString) -> Option<CFRetained<CFPropertyList>> {
        extern "C-unwind" {
            fn CMFormatDescriptionGetExtension(
                desc: &CMFormatDescription,
                extension_key: &CFString,
            ) -> Option<NonNull<CFPropertyList>>;
        }
        let ret = unsafe { CMFormatDescriptionGetExtension(self, extension_key) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }
}

/// An audio codec type.
///
/// ## Discussion
///
/// Certain codec types are also audio formats.
///
///
/// Four-character codes identifying the code type. Certain codec types are also audio formats.
pub type CMAudioCodecType = FourCharCode;

/// iTMS protected low-complexity AAC.
pub const kCMAudioCodecType_AAC_LCProtected: CMAudioCodecType = 0x70616163;
/// Audible’s protected AAC.
pub const kCMAudioCodecType_AAC_AudibleProtected: CMAudioCodecType = 0x61616163;

/// A type you use to interact with audio format descriptions.
/// SYnonym type used for manipulating audio CMFormatDescriptions
#[doc(alias = "CMAudioFormatDescriptionRef")]
pub type CMAudioFormatDescription = CMFormatDescription;

extern "C-unwind" {
    /// Creates a format description for an audio media stream.
    ///
    /// Parameters:
    /// - allocator: `CFAllocator` to be used. Pass `kCFAllocatorDefault` or `NULL` to use the default allocator.
    ///
    /// - asbd: Audio format description (see `CoreAudioTypes.h`). This information is required.
    ///
    /// - layoutSize: Size, in bytes, of audio channel layout. 0 if layout is `NULL`.
    ///
    /// - layout: Audio channel layout (see CoreAudioTypes.h). Can be `NULL`.
    ///
    /// - magicCookieSize: Size, in bytes, of magic cookie. 0 if `magicCookie` is `NULL`.
    ///
    /// - magicCookie: Magic cookie. This information is required for some formats, and must be `NULL` for all others.
    ///
    /// - extensions: Dictionary of extension key/value pairs.  Keys are always `CFStrings`.                                                                            Values are always property list objects (ie. `CFData`, `CFString`, `CFArray`, `CFDictionary`, `CFDate`, `CFBoolean`, or `CFNumber`). Can be `NULL`.
    ///
    /// - formatDescriptionOut: On output, returns the newly created audio `CMFormatDescription`.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The `absd` is required, the channel layout is optional, and the magic cookie is required  for some compression formats (and must be NULL for all others). The caller owns the returned `CMFormatDescription`, and must release it when done with it.  The `ASBD`, magic cookie, channel layout, and extensions are all copied (the extensions are deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    ///
    /// Creates a format description for an audio media stream.
    ///
    /// The ASBD is required, the channel layout is optional, and the magic cookie is required
    /// for some compression formats (and must be NULL for all others). The caller owns the
    /// returned CMFormatDescription, and must release it when done with it.  The ASBD,
    /// magic cookie, channel layout, and extensions are all copied (the extensions are
    /// deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    /// # Safety
    ///
    /// - `asbd` must be a valid pointer.
    /// - `layout` must be a valid pointer or null.
    /// - `magic_cookie` must be a valid pointer or null.
    /// - `extensions` generic must be of the correct type.
    /// - `extensions` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn CMAudioFormatDescriptionCreate(
        allocator: Option<&CFAllocator>,
        asbd: NonNull<AudioStreamBasicDescription>,
        layout_size: usize,
        layout: *const AudioChannelLayout,
        magic_cookie_size: usize,
        magic_cookie: *const c_void,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMAudioFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Returns a read-only pointer to the audio stream description in an audio format description.
    ///
    /// Parameters:
    /// - desc: `CMFormatDescription` being interrogated.
    ///
    ///
    /// ## Discussion
    ///
    /// This API is specific to audio format descriptions, and returns `NULL` if used with a non-audio format descriptions.
    ///
    ///
    /// Returns a read-only pointer to the AudioStreamBasicDescription inside an audio CMFormatDescription.
    ///
    /// See CoreAudioTypes.h for the definition of AudioStreamBasicDescription.
    /// This API is specific to audio format descriptions, and will return NULL if
    /// used with a non-audio format descriptions.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn CMAudioFormatDescriptionGetStreamBasicDescription(
        desc: &CMAudioFormatDescription,
    ) -> *const AudioStreamBasicDescription;
}

extern "C-unwind" {
    /// Returns a read-only pointer to, and size of, the magic cookie in an audio format description.
    ///
    /// Parameters:
    /// - desc: `CMFormatDescription` being interrogated.
    ///
    /// - sizeOut: Pointer to variable that will be written with the size of the cookie. Can be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// A read-only pointer to the magic cookie inside the audio format description.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The magic cookie is a completely opaque piece of data, written and read only by the codec itself. A magic cookie is only present for codecs that require it;  this API will return `NULL` if one does not exist. This API is specific to audio format descriptions, and will return `NULL` if called with a non-audio format description.
    ///
    ///
    /// Returns a read-only pointer to (and size of) the magic cookie inside an audio CMFormatDescription.
    ///
    /// The magic cookie is a completely opaque piece of data, written and read only by
    /// the codec itself. A magic cookie is only present for codecs that require it;
    /// this API will return NULL if one does not exist. This API is specific to audio
    /// format descriptions, and will return NULL if called with a non-audio format
    /// description.
    ///
    /// Returns: A read-only pointer to the magic cookie inside the audio format description.
    ///
    /// # Safety
    ///
    /// `size_out` must be a valid pointer or null.
    pub fn CMAudioFormatDescriptionGetMagicCookie(
        desc: &CMAudioFormatDescription,
        size_out: *mut usize,
    ) -> *const c_void;
}

extern "C-unwind" {
    /// Returns a read-only pointer to, and the size of, the audio channel layout inside an audio format description.
    ///
    /// Parameters:
    /// - desc: `CMFormatDescription` being interrogated.
    ///
    /// - sizeOut: Pointer to variable that will be written with the size of the layout. Can be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// A read-only pointer to the `AudioChannelLayout` inside the audio format description.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// AudioChannelLayouts are optional; this API returns `NULL` if one doesn’t exist. This API is specific to audio format descriptions, and returns `NULL` if called with a non-audio format description.
    ///
    ///
    /// Returns a read-only pointer to (and size of) the AudioChannelLayout inside an audio CMFormatDescription.
    ///
    /// See CoreAudioTypes.h for the definition of AudioChannelLayout.
    /// AudioChannelLayouts are optional; this API will return NULL if
    /// one does not exist. This API is specific to audio format
    /// descriptions, and will return NULL if called with a non-audio
    /// format description.
    ///
    /// Returns: A read-only pointer to the AudioChannelLayout inside the audio format description.
    ///
    /// # Safety
    ///
    /// `size_out` must be a valid pointer or null.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn CMAudioFormatDescriptionGetChannelLayout(
        desc: &CMAudioFormatDescription,
        size_out: *mut usize,
    ) -> *const AudioChannelLayout;
}

extern "C-unwind" {
    /// Returns a read-only pointer to, and size of, the array of audio format list item structures in an audio format description.
    ///
    /// Parameters:
    /// - desc: `CMFormatDescription` being interrogated.
    ///
    /// - sizeOut: Pointer to variable that will be written with the size of the `formatList`.
    ///
    ///
    /// ## Return Value
    ///
    /// A read-only pointer to the array of `AudioFormatListItem` structs inside the audio format description.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This property is analogous to `kAudioFormatProperty_FormatList` and follows its conventions. Namely, the API returns formats in order from the most to least useful, with channel count taking the highest precedence followed by sample rate. This API is specific to audio format descriptions, and returns `NULL` if called with a non-audio format description.
    ///
    ///
    /// Returns a read-only pointer to (and size of) the array of AudioFormatListItem structs inside an audio CMFormatDescription.
    ///
    /// This property is analogous to kAudioFormatProperty_FormatList (See AudioFormat.h) and follows
    /// its conventions.  Namely, formats are returned in order from the most to least 'rich', with
    /// channel count taking the highest precedence followed by sample rate.
    /// This API is specific to audio format descriptions, and will return NULL if called with a non-audio
    /// format description.
    ///
    /// Returns: A read-only pointer to the array of AudioFormatListItem structs inside the audio format description.
    ///
    /// # Safety
    ///
    /// `size_out` must be a valid pointer or null.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn CMAudioFormatDescriptionGetFormatList(
        desc: &CMAudioFormatDescription,
        size_out: *mut usize,
    ) -> *const AudioFormatListItem;
}

extern "C-unwind" {
    /// Returns a read-only pointer to the appropriate audio format list item in an audio format description.
    ///
    /// Parameters:
    /// - desc: CMFormatDescription being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// A read-only pointer to the appropriate `AudioFormatListItem` inside the audio format description.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This property performs validation on the formats represented by the audio in the description.  It finds the first `AudioFormatListItem` for which the current system has a valid decoder. This API is specific to audio format descriptions, and will return `NULL` if called with a non-audio format description.  It may also return `NULL` if there is no suitable decoder available on the current system for this audio format.
    ///
    ///
    /// Returns a read-only pointer to the appropriate AudioFormatListItem inside an audio CMFormatDescription.
    ///
    /// This property performs validation on the formats represented by the audio in the description.  It
    /// finds the first AudioFormatListItem for which the current system has a valid decoder.
    /// This API is specific to audio format descriptions, and will return NULL if called with a non-audio
    /// format description.  It may also return NULL if there is no suitable decoder available on the
    /// current system for this audio format.
    ///
    /// Returns: A read-only pointer to the appropriate AudioFormatListItem inside the audio format description.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn CMAudioFormatDescriptionGetRichestDecodableFormat(
        desc: &CMAudioFormatDescription,
    ) -> *const AudioFormatListItem;
}

extern "C-unwind" {
    /// Returns a read-only pointer to the appropriate audio format list item in an audio format description.
    ///
    /// Parameters:
    /// - desc: `CMFormatDescription` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// A read-only pointer to the appropriate `AudioFormatListItem` inside the audio format description.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This property returns a pointer to the most compatible `AudioFormatListItem` in the `kAudioFormatProperty_FormatList`. This API is specific to audio format descriptions, and returns `NULL` if called with a non-audio format description.
    ///
    ///
    /// Returns a read-only pointer to the appropriate AudioFormatListItem inside an audio CMFormatDescription.
    ///
    /// This property returns a pointer to the last AudioFormatListItem in the kAudioFormatProperty_FormatList
    /// (see AudioFormat.h).  This API is specific to audio format descriptions, and will return NULL if called
    /// with a non-audio format description.
    ///
    /// Returns: A read-only pointer to the appropriate AudioFormatListItem inside the audio format description.
    #[cfg(feature = "objc2-core-audio-types")]
    pub fn CMAudioFormatDescriptionGetMostCompatibleFormat(
        desc: &CMAudioFormatDescription,
    ) -> *const AudioFormatListItem;
}

extern "C-unwind" {
    /// Creates a summary audio format description from an array of descriptions.
    ///
    /// Parameters:
    /// - allocator: The allocator to use. Pass `kCFAllocatorDefault` or `NULL` to use the default allocator.
    ///
    /// - formatDescriptionArray: The array of format descriptions to summarize.
    ///
    /// - flags: Pass 0.
    ///
    /// - formatDescriptionOut: On output, returns the newly created audio format description.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// To `kCFAllocatorDefault` or `NULL` to use the default allocator.
    ///
    /// The summary format description will be canonical LPCM and deep enough in sample rate, channel layout and channel count to sensibly contain the result of decoding and mixing the constituent format descriptions.
    ///
    ///
    /// Creates a summary audio format description from an array of audio format descriptions.
    ///
    /// The summary format description will be canonical LPCM and deep enough in
    /// sample rate, channel layout and channel count to sensibly contain the result of decoding
    /// and mixing the constituent format descriptions.
    ///
    /// # Safety
    ///
    /// - `format_description_array` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    pub fn CMAudioFormatDescriptionCreateSummary(
        allocator: Option<&CFAllocator>,
        format_description_array: &CFArray,
        flags: u32,
        format_description_out: NonNull<*const CMAudioFormatDescription>,
    ) -> OSStatus;
}

/// A type for mask bits that represent parts of an audio format description.
/// Mask bits passed to (and returned from) CMAudioFormatDescriptionEqual,
/// representing various parts of an audio format description.
pub type CMAudioFormatDescriptionMask = u32;

/// A mask that represents the audio stream description.
pub const kCMAudioFormatDescriptionMask_StreamBasicDescription: CMAudioFormatDescriptionMask =
    1 << 0;
/// A mask that represents the magic cookie.
pub const kCMAudioFormatDescriptionMask_MagicCookie: CMAudioFormatDescriptionMask = 1 << 1;
/// A mask that represents the audio channel layout.
pub const kCMAudioFormatDescriptionMask_ChannelLayout: CMAudioFormatDescriptionMask = 1 << 2;
/// A mask that represents the format description extensions.
pub const kCMAudioFormatDescriptionMask_Extensions: CMAudioFormatDescriptionMask = 1 << 3;
/// A mask that represents all parts of an audio format description.
pub const kCMAudioFormatDescriptionMask_All: CMAudioFormatDescriptionMask =
    kCMAudioFormatDescriptionMask_StreamBasicDescription
        | kCMAudioFormatDescriptionMask_MagicCookie
        | kCMAudioFormatDescriptionMask_ChannelLayout
        | kCMAudioFormatDescriptionMask_Extensions;

/// Returns a Boolean value that indicates whether the two audio format descriptions are equal.
///
/// Parameters:
/// - formatDescription: The `CMAudioFormatDescription` being compared.
///
/// - otherFormatDescription: The `CMAudioFormatDescription` to which it is being compared.
///
/// - equalityMask: Mask specifying which parts of the descriptions to compare.
///
/// - equalityMaskOut: Pointer to variable that will be written with the results that represent the parts that are equal. Can be `nil`.
///
///
/// ## Return Value
///
/// The result of the comparison.  True if all parts in which the caller is interested are equal. False if any of the parts in which the caller is interested are not equal.
///
///
///
/// ## Discussion
///
/// Bits in `equalityMask` specify the caller’s interest in the equality of various parts of the descriptions. Bits set and returned in `equalityMaskOut` represent the subset of those parts that are equal. If there is any sort of error that prevents the comparison from occurring, false will be returned, and all bits in `equalityMaskOut` will be cleared. If you pass [`kCMAudioFormatDescriptionMask_All`](https://developer.apple.com/documentation/coremedia/kcmaudioformatdescriptionmask_all) in equalityMask, and `nil` for `equalityMaskOut`, this function is equivalent to `CFEqual(formatDescription, otherFormatDescription)`.
///
///
/// Evaluates equality for the specified parts of two audio format descriptions.
///
/// Bits in equalityMask specify the caller's interest in the equality of various parts of the descriptions.
/// Bits set and returned in equalityMaskOut represent the subset of those parts that are equal.
/// If there is any sort of error that prevents the comparison from occurring, false will be returned, and
/// all bits in equalityMaskOut will be cleared. If you pass kCMAudioFormatDescriptionMask_All in equalityMask,
/// and NULL for equalityMaskOut, this API is equivalent to CFEqual(desc1, desc2).
///
/// On releases up to macOS 12, iOS 15, tvOS 15 and watchOS 8, the kCMAudioFormatDescriptionMask_Extensions
/// flag was ignored in equalityMask. So this API always treated two audio format descriptions as equal even
/// when they had different extensions.
///
/// Starting with macOS 13, iOS 16, tvOS 16 and watchOS 9, kCMAudioFormatDescriptionMask_Extensions is correctly
/// accounted for when determining equality of two audio format descriptions. This also affects CFEqual(desc1, desc2)
/// as it will return false when two audio format descriptions have different extensions.
///
///
/// Returns: The result of the comparison.  True if all parts in which the caller is interested are equal.
/// False if any of the parts in which the caller is interested are not equal.
///
/// # Safety
///
/// `equality_mask_out` must be a valid pointer or null.
#[inline]
pub unsafe extern "C-unwind" fn CMAudioFormatDescriptionEqual(
    format_description: &CMAudioFormatDescription,
    other_format_description: &CMAudioFormatDescription,
    equality_mask: CMAudioFormatDescriptionMask,
    equality_mask_out: *mut CMAudioFormatDescriptionMask,
) -> bool {
    extern "C-unwind" {
        fn CMAudioFormatDescriptionEqual(
            format_description: &CMAudioFormatDescription,
            other_format_description: &CMAudioFormatDescription,
            equality_mask: CMAudioFormatDescriptionMask,
            equality_mask_out: *mut CMAudioFormatDescriptionMask,
        ) -> Boolean;
    }
    let ret = unsafe {
        CMAudioFormatDescriptionEqual(
            format_description,
            other_format_description,
            equality_mask,
            equality_mask_out,
        )
    };
    ret != 0
}

/// A type you use to interact with video format descriptions.
/// Synonym type used for manipulating video CMFormatDescriptions
#[doc(alias = "CMVideoFormatDescriptionRef")]
pub type CMVideoFormatDescription = CMFormatDescription;

/// A pixel format type.
///
/// ## Discussion
///
/// Only some codec types are pixel formats.
///
///
/// Four-character codes identifying the pixel format. Only some codec types are pixel formats.
/// In general, CoreVideo CVPixelFormatType constants may be used too.
pub type CMPixelFormatType = FourCharCode;

/// A type that describes 32-bit ARGB.
pub const kCMPixelFormat_32ARGB: CMPixelFormatType = 32;
/// A type that describes 32-bit BGRA.
pub const kCMPixelFormat_32BGRA: CMPixelFormatType = 0x42475241;
/// A type that describes 24-bit RGB.
pub const kCMPixelFormat_24RGB: CMPixelFormatType = 24;
/// A type that describes 16-bit big-endian 5-5-5.
pub const kCMPixelFormat_16BE555: CMPixelFormatType = 16;
/// A type that describes 16-bit big-endian 5-6-5.
pub const kCMPixelFormat_16BE565: CMPixelFormatType = 0x42353635;
/// A type that describes 16-bit little-endian 5-5-5.
pub const kCMPixelFormat_16LE555: CMPixelFormatType = 0x4c353535;
/// A type that describes 16-bit little-endian 5-6-5.
pub const kCMPixelFormat_16LE565: CMPixelFormatType = 0x4c353635;
/// A type that describes 16-bit little-endian 5-5-5-1.
pub const kCMPixelFormat_16LE5551: CMPixelFormatType = 0x35353531;
/// A type that describes component Y’CbCr 8-bit 4:2:2 ordered Cb Y’0 Cr Y’1.
pub const kCMPixelFormat_422YpCbCr8: CMPixelFormatType = 0x32767579;
/// A type that describes component Y’CbCr 8-bit 4:2:2 ordered Y’0 Cb Y’1 Cr.
pub const kCMPixelFormat_422YpCbCr8_yuvs: CMPixelFormatType = 0x79757673;
/// A type that describes component Y’CbCr 8-bit 4:4:4.
pub const kCMPixelFormat_444YpCbCr8: CMPixelFormatType = 0x76333038;
/// A type that describes component Y’CbCrA 8-bit 4:4:4:4.
pub const kCMPixelFormat_4444YpCbCrA8: CMPixelFormatType = 0x76343038;
/// A type that describes component Y’CbCr 10,12,14,16-bit 4:2:2.
pub const kCMPixelFormat_422YpCbCr16: CMPixelFormatType = 0x76323136;
/// A type that describes component Y’CbCr 10-bit 4:2:2.
pub const kCMPixelFormat_422YpCbCr10: CMPixelFormatType = 0x76323130;
/// A type that describes component Y’CbCr 10-bit 4:4:4
pub const kCMPixelFormat_444YpCbCr10: CMPixelFormatType = 0x76343130;
/// A type that describes 8-bit indexed gray, white is zero.
pub const kCMPixelFormat_8IndexedGray_WhiteIsZero: CMPixelFormatType = 0x00000028;

/// A video codec type.
///
/// ## Discussion
///
/// Certain codec types are also pixel formats.
///
/// There is no “kCMVideoCodecType_Raw”; you should use the appropriate pixel format type as the codec type.
///
///
/// Four-character codes identifying the video codec. Certain codec types are also pixel formats.
/// Note: There is no kCMVideoCodecType_Raw -- use the appropriate pixel format type as the codec type.
///
///
///
///
///
///
///
///
///
///
///
///
/// IMPORTANT NOTE: this constant is used to select the appropriate encoder, but is NOT used on the encoded content,
/// which is backwards compatible and hence uses 'hvc1' as its codec type.
pub type CMVideoCodecType = FourCharCode;

/// A type that identifies a component with the format of Y’CbCr 8-bit 4:2:2 ordered Cb Y’0 Cr Y’1.
pub const kCMVideoCodecType_422YpCbCr8: CMVideoCodecType = kCMPixelFormat_422YpCbCr8;
/// A type that identifies the apple animation format.
pub const kCMVideoCodecType_Animation: CMVideoCodecType = 0x726c6520;
/// A type that identifies the cinepak format.
pub const kCMVideoCodecType_Cinepak: CMVideoCodecType = 0x63766964;
/// A type that identifies the Joint Photographic Experts Group (JPEG) format.
pub const kCMVideoCodecType_JPEG: CMVideoCodecType = 0x6a706567;
/// A type that identifies the JPEG format with Open-DML extensions.
pub const kCMVideoCodecType_JPEG_OpenDML: CMVideoCodecType = 0x646d6231;
pub const kCMVideoCodecType_JPEG_XL: CMVideoCodecType = 0x6a786c63;
/// A type that identifies the sorenson video format.
pub const kCMVideoCodecType_SorensonVideo: CMVideoCodecType = 0x53565131;
/// A type that identifies the sorenson 3 video format.
pub const kCMVideoCodecType_SorensonVideo3: CMVideoCodecType = 0x53565133;
/// A type that identifies the ITU-T H.263 format.
pub const kCMVideoCodecType_H263: CMVideoCodecType = 0x68323633;
/// A type that identifies the ITU-T H.264 format.
pub const kCMVideoCodecType_H264: CMVideoCodecType = 0x61766331;
/// A type that identifies the ITU-T HEVC format.
pub const kCMVideoCodecType_HEVC: CMVideoCodecType = 0x68766331;
/// A type that identifies the HEVC format with alpha support.
pub const kCMVideoCodecType_HEVCWithAlpha: CMVideoCodecType = 0x6d757861;
/// A type that identifies the Dolby Vision HEVC format.
pub const kCMVideoCodecType_DolbyVisionHEVC: CMVideoCodecType = 0x64766831;
/// A type that identifies the Moving Picture Experts Group (MPEG) MPEG-4 Part 2 video format.
pub const kCMVideoCodecType_MPEG4Video: CMVideoCodecType = 0x6d703476;
/// A type that identifies the MPEG-2 video format.
pub const kCMVideoCodecType_MPEG2Video: CMVideoCodecType = 0x6d703276;
/// A type that identifies the MPEG-1 video format.
pub const kCMVideoCodecType_MPEG1Video: CMVideoCodecType = 0x6d703176;
/// A type that identifies the VP9 format.
pub const kCMVideoCodecType_VP9: CMVideoCodecType = 0x76703039;
/// A type that identifies the DV NTSC format.
pub const kCMVideoCodecType_DVCNTSC: CMVideoCodecType = 0x64766320;
/// A type that identifies the DV PAL format.
pub const kCMVideoCodecType_DVCPAL: CMVideoCodecType = 0x64766370;
/// A type that identifies the Panasonic DVCPro PAL format.
pub const kCMVideoCodecType_DVCProPAL: CMVideoCodecType = 0x64767070;
/// A type that identifies the Panasonic DVCPro-50 NTSC format.
pub const kCMVideoCodecType_DVCPro50NTSC: CMVideoCodecType = 0x6476356e;
/// A type that identifies the Panasonic DVCPro-50 PAL format.
pub const kCMVideoCodecType_DVCPro50PAL: CMVideoCodecType = 0x64763570;
/// A type that identifies the Panasonic DVCPro-HD 720p60 format.
pub const kCMVideoCodecType_DVCPROHD720p60: CMVideoCodecType = 0x64766870;
/// A type that identifies the Panasonic DVCPro-HD 720p50 format.
pub const kCMVideoCodecType_DVCPROHD720p50: CMVideoCodecType = 0x64766871;
/// A type that identifies the Panasonic DVCPro-HD 1080i60 format.
pub const kCMVideoCodecType_DVCPROHD1080i60: CMVideoCodecType = 0x64766836;
/// A type that identifies the Panasonic DVCPro-HD 1080i50 format.
pub const kCMVideoCodecType_DVCPROHD1080i50: CMVideoCodecType = 0x64766835;
/// A type that identifies the Panasonic DVCPro-HD 1080p30 format.
pub const kCMVideoCodecType_DVCPROHD1080p30: CMVideoCodecType = 0x64766833;
/// A type that identifies the Panasonic DVCPro-HD 1080p25 format.
pub const kCMVideoCodecType_DVCPROHD1080p25: CMVideoCodecType = 0x64766832;
/// A type that identifies the Apple ProRes 4444 XQ format.
pub const kCMVideoCodecType_AppleProRes4444XQ: CMVideoCodecType = 0x61703478;
/// A type that identifies the Apple ProRes 4444 format.
pub const kCMVideoCodecType_AppleProRes4444: CMVideoCodecType = 0x61703468;
/// A type that identifies the Apple ProRes 422 HQ format.
pub const kCMVideoCodecType_AppleProRes422HQ: CMVideoCodecType = 0x61706368;
/// A type that identifies the Apple ProRes 422 format.
pub const kCMVideoCodecType_AppleProRes422: CMVideoCodecType = 0x6170636e;
/// A type that identifies the Apple ProRes 422 LT format.
pub const kCMVideoCodecType_AppleProRes422LT: CMVideoCodecType = 0x61706373;
/// A type that identifies the Apple ProRes 422 proxy format.
pub const kCMVideoCodecType_AppleProRes422Proxy: CMVideoCodecType = 0x6170636f;
/// A type that identifies the Apple ProRes RAW format.
pub const kCMVideoCodecType_AppleProResRAW: CMVideoCodecType = 0x6170726e;
/// A type that identifies the Apple ProRes RAW HQ format.
pub const kCMVideoCodecType_AppleProResRAWHQ: CMVideoCodecType = 0x61707268;
/// A type that identifies the disparity HEVC format.
pub const kCMVideoCodecType_DisparityHEVC: CMVideoCodecType = 0x64697368;
/// A type that identifies the depth HEVC format.
pub const kCMVideoCodecType_DepthHEVC: CMVideoCodecType = 0x64657068;
pub const kCMVideoCodecType_AV1: CMVideoCodecType = 0x61763031;

/// A structure that represents video dimensions.
///
/// ## Overview
///
/// The units are pixels.
///
///
/// Type used for video dimensions, units are pixels
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq, Default)]
pub struct CMVideoDimensions {
    pub width: i32,
    pub height: i32,
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CMVideoDimensions {
    const ENCODING: Encoding = Encoding::Struct("?", &[<i32>::ENCODING, <i32>::ENCODING]);
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CMVideoDimensions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    pub static kCMFormatDescriptionExtension_FormatName: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_Depth: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_CleanAperture: &'static CFString;
}

extern "C" {
    /// A key that identifies the clean aperture width value.
    pub static kCMFormatDescriptionKey_CleanApertureWidth: &'static CFString;
}

extern "C" {
    /// A key that identifies the clean aperture height value.
    pub static kCMFormatDescriptionKey_CleanApertureHeight: &'static CFString;
}

extern "C" {
    /// A key that describes the clean aperture height horizontal offset value.
    pub static kCMFormatDescriptionKey_CleanApertureHorizontalOffset: &'static CFString;
}

extern "C" {
    /// A key that identifies the clean aperture vertical offset value.
    pub static kCMFormatDescriptionKey_CleanApertureVerticalOffset: &'static CFString;
}

extern "C" {
    /// A key that identifies the clean aperture width rational value.
    pub static kCMFormatDescriptionKey_CleanApertureWidthRational: &'static CFString;
}

extern "C" {
    /// A key that identifies the clean aperture height rational value.
    pub static kCMFormatDescriptionKey_CleanApertureHeightRational: &'static CFString;
}

extern "C" {
    /// A key that identifies the clean aperture horizontal offset rational value.
    pub static kCMFormatDescriptionKey_CleanApertureHorizontalOffsetRational: &'static CFString;
}

extern "C" {
    /// A key that identifies the clean aperture vertical offset rational value.
    pub static kCMFormatDescriptionKey_CleanApertureVerticalOffsetRational: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_FieldCount: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_FieldDetail: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionFieldDetail_TemporalTopFirst: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionFieldDetail_TemporalBottomFirst: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionFieldDetail_SpatialFirstLineEarly: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionFieldDetail_SpatialFirstLineLate: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_PixelAspectRatio: &'static CFString;
}

extern "C" {
    /// A key that identifies the horizontal spacing of the pixel aspect ratio.
    pub static kCMFormatDescriptionKey_PixelAspectRatioHorizontalSpacing: &'static CFString;
}

extern "C" {
    /// A key that identifies the vertical spacing of the pixel aspect ratio.
    pub static kCMFormatDescriptionKey_PixelAspectRatioVerticalSpacing: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_ColorPrimaries: &'static CFString;
}

extern "C" {
    /// A format that describes the ITU R 709 2 color primary.
    pub static kCMFormatDescriptionColorPrimaries_ITU_R_709_2: &'static CFString;
}

extern "C" {
    /// A format that describes the EBU 3213 color primary.
    pub static kCMFormatDescriptionColorPrimaries_EBU_3213: &'static CFString;
}

extern "C" {
    /// A format that describes the SMPTE C color primary.
    pub static kCMFormatDescriptionColorPrimaries_SMPTE_C: &'static CFString;
}

extern "C" {
    /// A format that describes the DCI P3 color primary.
    pub static kCMFormatDescriptionColorPrimaries_DCI_P3: &'static CFString;
}

extern "C" {
    /// A format that describes the P3 D65 color primary.
    pub static kCMFormatDescriptionColorPrimaries_P3_D65: &'static CFString;
}

extern "C" {
    /// A format that describes the ITU R 2020 color primary.
    pub static kCMFormatDescriptionColorPrimaries_ITU_R_2020: &'static CFString;
}

extern "C" {
    /// A format that describes the P22 color primary.
    pub static kCMFormatDescriptionColorPrimaries_P22: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_TransferFunction: &'static CFString;
}

extern "C" {
    /// A constant that describes the ITU R 709 2 transfer function format.
    pub static kCMFormatDescriptionTransferFunction_ITU_R_709_2: &'static CFString;
}

extern "C" {
    /// A constant that describes the SMPTE 240M 1995 transfer function format.
    pub static kCMFormatDescriptionTransferFunction_SMPTE_240M_1995: &'static CFString;
}

extern "C" {
    /// A constant that describes the gamma transfer function format.
    pub static kCMFormatDescriptionTransferFunction_UseGamma: &'static CFString;
}

extern "C" {
    /// A constant that describes the ITU R 2020 transfer function format.
    pub static kCMFormatDescriptionTransferFunction_ITU_R_2020: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionTransferFunction_SMPTE_ST_428_1: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionTransferFunction_SMPTE_ST_2084_PQ: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionTransferFunction_ITU_R_2100_HLG: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionTransferFunction_Linear: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionTransferFunction_sRGB: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_GammaLevel: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_YCbCrMatrix: &'static CFString;
}

extern "C" {
    /// A constant describing the YCbCrMatrix ITU R 709 2 format.
    pub static kCMFormatDescriptionYCbCrMatrix_ITU_R_709_2: &'static CFString;
}

extern "C" {
    /// A constant describing the YCbCrMatrix ITU R 601 4 format.
    pub static kCMFormatDescriptionYCbCrMatrix_ITU_R_601_4: &'static CFString;
}

extern "C" {
    /// A constant describing the YCbCrMatrix SMPTE 240M 1995 format.
    pub static kCMFormatDescriptionYCbCrMatrix_SMPTE_240M_1995: &'static CFString;
}

extern "C" {
    /// A constant describing the YCbCrMatrix ITU R 2020 format.
    pub static kCMFormatDescriptionYCbCrMatrix_ITU_R_2020: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_FullRangeVideo: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_ICCProfile: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_BytesPerRow: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_ChromaLocationTopField: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_ChromaLocationBottomField: &'static CFString;
}

extern "C" {
    /// The chroma sample is horizontally co-sited with the left column of the luma samples, but centered vertically.
    pub static kCMFormatDescriptionChromaLocation_Left: &'static CFString;
}

extern "C" {
    /// The chroma sample is fully centered.
    pub static kCMFormatDescriptionChromaLocation_Center: &'static CFString;
}

extern "C" {
    /// The chroma sample is co-sited with the top-left luma sample.
    pub static kCMFormatDescriptionChromaLocation_TopLeft: &'static CFString;
}

extern "C" {
    /// The chroma sample is horizontally centered, but co-sited with the top row of the luma samples.
    pub static kCMFormatDescriptionChromaLocation_Top: &'static CFString;
}

extern "C" {
    /// The chroma sample is co-sited with the bottom-left luma sample.
    pub static kCMFormatDescriptionChromaLocation_BottomLeft: &'static CFString;
}

extern "C" {
    /// The chroma sample is horizontally centered, but co-sited with the bottom row of the luma samples.
    pub static kCMFormatDescriptionChromaLocation_Bottom: &'static CFString;
}

extern "C" {
    /// The Cr and Cb samples are alternately co-sited with the left luma samples of the same field.
    pub static kCMFormatDescriptionChromaLocation_DV420: &'static CFString;
}

extern "C" {
    /// The value is a number that specifies the MPEG2 video profile.
    pub static kCMFormatDescriptionConformsToMPEG2VideoProfile: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_ProtectedContentOriginalFormat: &'static CFString;
}

/// A profile that represents the Apple Intermediate Codec HDV 720p30 format.
pub const kCMMPEG2VideoProfile_HDV_720p30: i32 = 0x68647631;
/// A profile that represents the Apple Intermediate Codec HDV 1080i60 format.
pub const kCMMPEG2VideoProfile_HDV_1080i60: i32 = 0x68647632;
/// A profile that represents the Apple Intermediate Codec HDV 1080i50 format.
pub const kCMMPEG2VideoProfile_HDV_1080i50: i32 = 0x68647633;
/// A profile that represents the HDV 720p24 format.
pub const kCMMPEG2VideoProfile_HDV_720p24: i32 = 0x68647634;
/// A profile that represents the HDV_720p25 format.
pub const kCMMPEG2VideoProfile_HDV_720p25: i32 = 0x68647635;
/// A profile that represents the Apple ProRes 422 codec HDV 1080p24 format.
pub const kCMMPEG2VideoProfile_HDV_1080p24: i32 = 0x68647636;
/// A profile that represents the HDV 1080p25 format.
pub const kCMMPEG2VideoProfile_HDV_1080p25: i32 = 0x68647637;
/// A profile that represents the HDV 1080p30 format.
pub const kCMMPEG2VideoProfile_HDV_1080p30: i32 = 0x68647638;
/// A profile that represents the HDV 720p60 format.
pub const kCMMPEG2VideoProfile_HDV_720p60: i32 = 0x68647639;
/// A profile that represents the HDV 720p50 format.
pub const kCMMPEG2VideoProfile_HDV_720p50: i32 = 0x68647661;
/// A profile that represents the XDCAM HD 1080i60 video HQ format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD_1080i60_VBR35: i32 = 0x78647632;
/// A profile that represents the XDCAM HD 1080i50 video HQ format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD_1080i50_VBR35: i32 = 0x78647633;
/// A profile that represents the XDCAM HD 1080p24 video HQ format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD_1080p24_VBR35: i32 = 0x78647636;
/// A profile that represents the XDCAM HD 1080p25 video HQ format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD_1080p25_VBR35: i32 = 0x78647637;
/// A profile that represents the DCAM HD 1080p30 video HQ format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD_1080p30_VBR35: i32 = 0x78647638;
/// A profile that represents the XDCAM EX 720p24 video HQ format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_EX_720p24_VBR35: i32 = 0x78647634;
/// A profile that represents the XDCAM EX 720p25 video HQ format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_EX_720p25_VBR35: i32 = 0x78647635;
/// A profile that represents the XDCAM EX 720p30 video HQ format with 35 Mbps bit rate .
pub const kCMMPEG2VideoProfile_XDCAM_EX_720p30_VBR35: i32 = 0x78647631;
/// A profile that represents the XDCAM EX 720p50 HQ video format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_EX_720p50_VBR35: i32 = 0x78647661;
/// A profile that represents the XDCAM EX 720p60 HQ video format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_EX_720p60_VBR35: i32 = 0x78647639;
/// A profile that represents the XDCAM EX 1080i60 HQ video format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_EX_1080i60_VBR35: i32 = 0x78647662;
/// A profile that represents the XDCAM EX 1080i50 HQ video format with HQ 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_EX_1080i50_VBR35: i32 = 0x78647663;
/// A profile that represents the XDCAM EX 1080p24 HQ video format with HQ 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_EX_1080p24_VBR35: i32 = 0x78647664;
/// A profile that represents the XDCAM EX 1080p25 HQ video format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_EX_1080p25_VBR35: i32 = 0x78647665;
/// A profile that represents the XDCAM EX 1080p30 HQ video format with 35 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_EX_1080p30_VBR35: i32 = 0x78647666;
/// A profile that represents the XDCAM HD422 720p50 video format with 50 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_720p50_CBR50: i32 = 0x78643561;
/// A profile that represents the XDCAM HD422 720p60 video format with 50 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_720p60_CBR50: i32 = 0x78643539;
/// A profile that represents the XDCAM HD422 1080i60 video format with 50 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_1080i60_CBR50: i32 = 0x78643562;
/// A profile that represents the XDCAM HD422 1080i50 video format with 50 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_1080i50_CBR50: i32 = 0x78643563;
/// A profile that represents the XDCAM HD422 1080p24 video format with 50 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_1080p24_CBR50: i32 = 0x78643564;
/// A profile that represents the XDCAM HD422 1080p25 video format with 50 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_1080p25_CBR50: i32 = 0x78643565;
/// A profile that represents the XDCAM HD422 1080p30 video format with 50 Mbps bit rate.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_1080p30_CBR50: i32 = 0x78643566;
/// A profile that represents the XDCAM HD 540p video format.
pub const kCMMPEG2VideoProfile_XDCAM_HD_540p: i32 = 0x78646864;
/// A profile that represents the XDCAM HD422 540 video format.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_540p: i32 = 0x78646832;
/// A profile that represents the XDCAM HD 422 720p24 video format.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_720p24_CBR50: i32 = 0x78643534;
/// A profile that represents the XDCAM HD 422 720p25 video format.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_720p25_CBR50: i32 = 0x78643535;
/// A profile that represents the XDCAM HD 422 720p30 video format.
pub const kCMMPEG2VideoProfile_XDCAM_HD422_720p30_CBR50: i32 = 0x78643531;
/// A profile that represents the XF video format.
pub const kCMMPEG2VideoProfile_XF: i32 = 0x78667a31;

extern "C" {
    /// The value is a number.
    pub static kCMFormatDescriptionExtension_TemporalQuality: &'static CFString;
}

extern "C" {
    /// The value is a number.
    pub static kCMFormatDescriptionExtension_SpatialQuality: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_VerbatimImageDescription: &'static CFString;
}

extern "C" {
    /// The value is a number.
    pub static kCMFormatDescriptionExtension_Version: &'static CFString;
}

extern "C" {
    /// The value is a number.
    pub static kCMFormatDescriptionExtension_RevisionLevel: &'static CFString;
}

extern "C" {
    /// The value is a string of four character codes.
    pub static kCMFormatDescriptionExtension_Vendor: &'static CFString;
}

extern "C" {
    /// A string that speicifies Apple as the vendor.
    pub static kCMFormatDescriptionVendor_Apple: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_MasteringDisplayColorVolume: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_ContentLightLevelInfo: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_ContentColorVolume: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_AlternativeTransferCharacteristics: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_AuxiliaryTypeInfo: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_AlphaChannelMode: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionAlphaChannelMode_StraightAlpha: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionAlphaChannelMode_PremultipliedAlpha: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_ContainsAlphaChannel: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_BitsPerComponent: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_HorizontalFieldOfView: &'static CFString;
}

extern "C" {
    /// Indicates that the transfer function or gamma of the content is a log format and identifies the specific log curve.
    ///
    /// The value is a CFString holding fully specified reverse DNS identifier.
    /// Content captured in Apple Log will have this key set to kCMFormatDescriptionLogTransferFunction_AppleLog.
    ///
    /// Indicates the Apple Log identifier.
    ///
    /// You can download the Apple Log Profile White Paper from the Apple Developer Downloads website.
    pub static kCMFormatDescriptionExtension_LogTransferFunction: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionLogTransferFunction_AppleLog: &'static CFString;
}

extern "C" {
    /// Indicates which of the two eyes should be used as the primary when rendering in 2D. It is usually perpendicular to the target image surface.
    ///
    /// Indicates the left eye is the hero eye.
    ///
    /// Indicates the right eye is the hero eye.
    ///
    /// The value is a CFString holding one of the kCMFormatDescriptionHeroEye_* constants.
    pub static kCMFormatDescriptionExtension_HeroEye: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionHeroEye_Left: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionHeroEye_Right: &'static CFString;
}

extern "C" {
    /// Indicates the distance between centers of the lenses of the camera system.
    ///
    /// The value is a CFNumber holding an unsigned 32-bit integer that is interpreted in micrometers or thousandths of a millimeter (e.g., 63123 is 63.123 millimeters).
    /// This property is optional and should only be specified if the distance is known.
    pub static kCMFormatDescriptionExtension_StereoCameraBaseline: &'static CFString;
}

extern "C" {
    /// Indicates a relative shift of the left and right images, which changes the zero parallax plane.
    ///
    /// The value encoded in normalized image space is a CFNumber holding a signed 32-bit integer measured over the range of -10000 to 10000 mapping to the uniform range [-1.0...1.0]. The interval of 0.0 to 1.0 or 0 to 10000 maps onto the stereo eye view image width. The negative interval 0.0 to -1.0 or 0 to -10000 similarly map onto the stereo eye view image width.
    /// The default value of 0 is interpreted if this property is not set. If the property is not set, NULL may be set and retrieved. The NULL value should be interpreted as meaning 0.
    /// This property is optional and should only be specified if a disparity adjustment including 0 is known.
    pub static kCMFormatDescriptionExtension_HorizontalDisparityAdjustment: &'static CFString;
}

extern "C" {
    /// Indicates the stereo left eye is present in video frames.
    ///
    /// The value is a CFBoolean holding presence of left eye view in the stream.
    pub static kCMFormatDescriptionExtension_HasLeftStereoEyeView: &'static CFString;
}

extern "C" {
    /// Indicates the stereo right eye is present in video frames.
    ///
    /// The value is a CFBoolean holding presence of right eye view in the stream.
    pub static kCMFormatDescriptionExtension_HasRightStereoEyeView: &'static CFString;
}

extern "C" {
    /// Indicates that one or more additional views may be present beyond stereo left and stereo right eyes (e.g,. a “centerline” view).
    ///
    /// The value is a CFBoolean holding presence of additional eye views in the stream.
    pub static kCMFormatDescriptionExtension_HasAdditionalViews: &'static CFString;
}

extern "C" {
    /// Indicates the projection that should be applied to presented decoded video frames.
    ///
    /// Indicates rectilinear projection. Generally less than 90 degree field of view with no barrel distortion.
    ///
    /// Indicates equirectangular projection of a 360 degree sphere to a rectangular plane, where longitude and latitude of the sphere are mapped linearly to the x,y axes of the plane.
    ///
    /// Indicates half equirectangular projection of a 180 degree hemisphere to a rectangular plane, where longitude and latitude of the sphere are mapped linearly to the x,y axes of the plane
    ///
    /// Indicates a projection described mathematically by a model of camera lens calibration parameters. Parameters may be found in lens calibration metadata in kCMFormatDescriptionExtension_CameraCalibrationDataLensCollection with algorithm_kind being parametric lens
    ///
    /// Indicates a proprietary projection used for Apple Immersive Video.
    ///
    /// The value is a CFString holding one of the kCMFormatDescriptionProjectionKind_* constants.
    pub static kCMFormatDescriptionExtension_ProjectionKind: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionProjectionKind_Rectilinear: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionProjectionKind_Equirectangular: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionProjectionKind_HalfEquirectangular: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionProjectionKind_ParametricImmersive: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionProjectionKind_AppleImmersiveVideo: &'static CFString;
}

extern "C" {
    /// Indicates the packing type of stereoscopic video frames.
    ///
    /// Indicates that frames are packed side-by-side.
    ///
    /// Indicates that frames are packed over under.
    ///
    /// The value is a CFString holding one of the kCMFormatDescriptionViewPackingKind_* constants.
    pub static kCMFormatDescriptionExtension_ViewPackingKind: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionViewPackingKind_SideBySide: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionViewPackingKind_OverUnder: &'static CFString;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Specifies intrinsic and extrinsic parameters for single or multiple lenses.
    ///
    /// The property value is an array of dictionaries describing the camera calibration data for each lens. The camera calibration data includes intrinsics and extrinics with other parameters. For a stereoscopic camera system, the left and right lens signaling can be done with the kCMFormatDescriptionCameraCalibration_LensRole key and its value.
    ///
    ///
    /// Specifies intrinsic and extrinsic parameters for single or multiple lenses.
    ///
    /// The property value is an array of dictionaries describing the camera calibration data for each lens. The camera calibration data includes intrinsics and extrinics with other parameters.
    /// For a stereoscopic camera system, the left and right lens signaling can be done with the kCMFormatDescriptionCameraCalibration_LensRole key and its value.
    pub static kCMFormatDescriptionExtension_CameraCalibrationDataLensCollection: &'static CFString;
}

extern "C" {
    /// The following keys are required in each kCMFormatDescriptionExtension_CameraCalibrationDataLensCollection dictionary.
    ///
    /// ## Discussion
    ///
    /// Specifies the camera calibration methodology.
    ///
    /// If the algorithm kind is ParametricLens, the camera lens collection requires camera intrinsic and extrinsic parameters.
    ///
    /// Specifies the kind of lens (e.g., color).
    ///
    /// Specifies a unique number associated with a lens.
    ///
    /// Specifies the particular use of the lens in the camera system (e.g., left or right for a stereo system).
    ///
    /// For a stereoscopic camera system, one lens should have the left role and another should have the right role.
    ///
    /// Specifies the first and second radial distortion coefficients(k1 and k2) used to correct the distortion that appeared as curved lines for straight lines and the first and second tangential distortion coefficients(p1 and p2) used to correct the distortion caused by a lens’s improper alignment of physical elements.
    ///
    /// The values are in a CFArray of four CFNumbers in k1, k2, p1 and p2 order.
    ///
    /// Specifies a three element polynomial for mapping x axis UV parameters with an adjustment using the equation `x' = polynomialX[0] + polynomialX[1]*x + polynomialX[2]*x^3`.
    ///
    /// The values are in a CFArray of three CFNumbers(float) in the order polynomialX[0], polynomialX[1] & polynomialX[2]. The polynomial transform origin is at the center of the frame. The default values of elements of polynomialX[] are [0.0, 1.0, 0.0].
    ///
    /// Specifies a three element polynomial for mapping y axis UV parameters with an adjustment using the equation `y' = polynomialY[0] + polynomialY[1]*y + polynomialY[2]*y^3`.
    ///
    /// The values are in a CFArray of three CFNumbers(float) in the order polynomialY[0], polynomialY[1] & polynomialY[2]. The polynomial transform origin is at the center of the frame. The default values of elements of polynomialY[] are [0.0, 1.0, 0.0].
    ///
    /// Specifies the outer limit of the calibration validity in degrees of angle eccentric from the optical axis.
    ///
    /// The value is linked to radial distortion corrections with k1 and k2.
    ///
    /// Specifies the 3x3 camera intrinsic matrix for camera calibration.
    ///
    /// Camera intrinsic matrix is a CFData containing a matrix_float3x3, which is column-major. Each element is in IEEE754 native-endian 32-bit floating point. It has the following contents: fx	s	cx 0	fy	cy 0	0	1 fx and fy are the focal length in pixels. For square pixels, they will have the same value. cx and cy are the coordinates of the principal point. The origin is the upper left of the frame. s is an optional skew factor.
    ///
    /// Specifies the offset of the point of perspective relative to the rectilinear projection.
    ///
    /// Specifies the image dimensions to which the camera’s intrinsic matrix values are relative.
    ///
    /// Values are width and height in a CFDictionary. Dictionary keys are compatible with CGSize dictionary, namely “Width” and “Height”.
    ///
    /// Identifies how the origin of the camera system’s extrinsics are determined.
    ///
    /// The ‘blin’ value indicates the center of transform is determined by the point mid way along the dimensions indicated by the StereoCameraSystemBaselineBox held in the StereoCameraSystemBox. Each left and right lens within a stereoscopic camera system is equidistant from this point, so the ‘blin’ value is halved when associated with the respective left and right lenses.
    ///
    /// The values are in a CFArray of three CFNumbers in ix, iy, and iz order.
    ///
    ///
    /// The following keys are required in each kCMFormatDescriptionExtension_CameraCalibrationDataLensCollection dictionary.
    ///
    ///
    ///
    /// Specifies the camera calibration methodology.
    ///
    /// If the algorithm kind is ParametricLens, the camera lens collection requires camera intrinsic and extrinsic parameters.
    ///
    ///
    ///
    /// Specifies the kind of lens (e.g., color).
    ///
    ///
    ///
    /// Specifies a unique number associated with a lens.
    ///
    ///
    ///
    /// Specifies the particular use of the lens in the camera system (e.g., left or right for a stereo system).
    ///
    /// For a stereoscopic camera system, one lens should have the left role and another should have the right role.
    ///
    ///
    ///
    /// Specifies the first and second radial distortion coefficients(k1 and k2) used to correct the distortion that appeared as curved lines for straight lines and the first and second tangential distortion coefficients(p1 and p2) used to correct the distortion caused by a lens's improper alignment of physical elements.
    ///
    /// The values are in a CFArray of four CFNumbers in k1, k2, p1 and p2 order.
    ///
    ///
    ///
    /// Specifies a three element polynomial for mapping x axis UV parameters with an adjustment using the equation `x' = polynomialX[0] + polynomialX[1]*x + polynomialX[2]*x^3`.
    ///
    /// The values are in a CFArray of three CFNumbers(float) in the order polynomialX[0], polynomialX[1]
    /// &
    /// polynomialX[2].
    /// The polynomial transform origin is at the center of the frame. The default values of elements of polynomialX[] are [0.0, 1.0, 0.0].
    ///
    ///
    ///
    /// Specifies a three element polynomial for mapping y axis UV parameters with an adjustment using the equation `y' = polynomialY[0] + polynomialY[1]*y + polynomialY[2]*y^3`.
    ///
    /// The values are in a CFArray of three CFNumbers(float) in the order polynomialY[0], polynomialY[1]
    /// &
    /// polynomialY[2].
    /// The polynomial transform origin is at the center of the frame. The default values of elements of polynomialY[] are [0.0, 1.0, 0.0].
    ///
    ///
    ///
    /// Specifies the outer limit of the calibration validity in degrees of angle eccentric from the optical axis.
    ///
    /// The value is linked to radial distortion corrections with k1 and k2.
    ///
    ///
    ///
    /// Specifies the 3x3 camera intrinsic matrix for camera calibration.
    ///
    /// Camera intrinsic matrix is a CFData containing a matrix_float3x3, which is column-major. Each element is in IEEE754 native-endian 32-bit floating point. It has the following contents:
    /// fx    s    cx
    /// 0    fy    cy
    /// 0    0    1
    /// fx and fy are the focal length in pixels. For square pixels, they will have the same value.
    /// cx and cy are the coordinates of the principal point. The origin is the upper left of the frame.
    /// s is an optional skew factor.
    ///
    ///
    ///
    /// Specifies the offset of the point of perspective relative to the rectilinear projection.
    ///
    ///
    ///
    /// Specifies the image dimensions to which the camera’s intrinsic matrix values are relative.
    ///
    /// Values are width and height in a CFDictionary. Dictionary keys are compatible with CGSize dictionary, namely "Width" and "Height".
    ///
    ///
    ///
    /// Identifies how the origin of the camera system's extrinsics are determined.
    ///
    /// The 'blin' value indicates the center of transform is determined by the point mid way along the dimensions indicated by the StereoCameraSystemBaselineBox held in the StereoCameraSystemBox.
    /// Each left and right lens within a stereoscopic camera system is equidistant from this point, so the 'blin' value is halved when associated with the respective left and right lenses.
    ///
    ///
    ///
    /// Specifies a camera’s orientation to a world or scene coordinate system. The orientation value is a unit quaternion(ix, iy, and iz) instead of the classical 3x3 matrix.
    ///
    /// The values are in a CFArray of three CFNumbers in ix, iy, and iz order.
    pub static kCMFormatDescriptionCameraCalibration_LensAlgorithmKind: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibrationLensAlgorithmKind_ParametricLens:
        &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_LensDomain: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibrationLensDomain_Color: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_LensIdentifier: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_LensRole: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibrationLensRole_Mono: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibrationLensRole_Left: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibrationLensRole_Right: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_LensDistortions: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_LensFrameAdjustmentsPolynomialX:
        &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_LensFrameAdjustmentsPolynomialY:
        &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_RadialAngleLimit: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_IntrinsicMatrix: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_IntrinsicMatrixProjectionOffset:
        &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_IntrinsicMatrixReferenceDimensions:
        &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_ExtrinsicOriginSource: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibrationExtrinsicOriginSource_StereoCameraSystemBaseline:
        &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionCameraCalibration_ExtrinsicOrientationQuaternion:
        &'static CFString;
}

extern "C" {
    ///
    /// ## Discussion
    ///
    /// Indicates that the image description contains projected media data converted from an external format
    ///
    /// This format description extension is included if boxes containing external stereoscopic or spherical projection information were parsed.
    ///
    ///
    /// Indicates that the image description contains projected media data converted from an external format
    ///
    /// This format description extension is included if boxes containing external stereoscopic or spherical projection information were parsed.
    pub static kCMFormatDescriptionExtension_ConvertedFromExternalSphericalTags: &'static CFString;
}

extern "C-unwind" {
    /// Creates a format description for a video media stream.
    ///
    /// Parameters:
    /// - allocator: CFAllocator to be used. Pass `kCFAllocatorDefault` or NULL to use the default allocator.
    ///
    /// - codecType: The type of video compression.
    ///
    /// - width: The width of encoded video.
    ///
    /// - height: The height of encoded video.
    ///
    /// - extensions: Dictionary of extension key/value pairs. Keys are always `CFString`.                                                                    Values are always property list objects (ie. `CFData`, `CFString`, `CFArray`,                                                                    `CFDictionary`, `CFDate`, `CFBoolean`, or `CFNumber`). Can be `NULL`.
    ///
    /// - formatDescriptionOut: On output, returns newly created video `CMFormatDescription`
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. Returns `noErr` if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The caller owns the returned `CMFormatDescription`, and must release it when done with it. All input parameters are copied (the extensions are deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    ///
    /// Creates a format description for a video media stream.
    ///
    /// The caller owns the returned CMFormatDescription, and must release it when done with it. All input parameters
    /// are copied (the extensions are deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    /// # Safety
    ///
    /// - `extensions` generic must be of the correct type.
    /// - `extensions` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    pub fn CMVideoFormatDescriptionCreate(
        allocator: Option<&CFAllocator>,
        codec_type: CMVideoCodecType,
        width: i32,
        height: i32,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMVideoFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a format description for a video media stream by using an image buffer.
    ///
    /// Parameters:
    /// - allocator: `CFAllocator` to be used when creating the `CMFormatDescription`. Pass `NULL` to use the default allocator.
    ///
    /// - imageBuffer: Image buffer for which we are creating the format description.
    ///
    /// - formatDescriptionOut: On output, returns newly created video `CMFormatDescription`.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. Returns `noErr` if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This convenience function is equivalent to:
    ///
    /// ```objc
    /// CMVideoFormatDescriptionCreate ( allocator, ( CVPixelBufferGetTypeID() == CFGetTypeID( imageBuffer ) ? CVPixelBufferGetPixelFormatType( imageBuffer ) : 0,  width of image,  height of image, extensions );
    ///                                                 
    /// ```
    ///
    /// `extensions` is a `CFDictionary` of attachments to image buffer with keys specified by `CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers`, and also `kCMFormatDescriptionExtension_BytesPerRow` if applicable.
    ///
    ///
    /// Creates a format description for a video media stream contained in CVImageBuffers of the type provided.
    ///
    /// This convenience function is equivalent to:
    ///
    /// CMVideoFormatDescriptionCreate( allocator,
    /// ( CVPixelBufferGetTypeID() == CFGetTypeID( imageBuffer ) ? CVPixelBufferGetPixelFormatType( imageBuffer ) : 0,
    /// width of image,
    /// height of image,
    /// extensions );
    ///
    /// where extensions is a CFDictionary of attachments to image buffer with keys specified by
    /// CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers, and also
    /// kCMFormatDescriptionExtension_BytesPerRow if applicable.
    ///
    /// # Safety
    ///
    /// `format_description_out` must be a valid pointer.
    #[cfg(feature = "objc2-core-video")]
    pub fn CMVideoFormatDescriptionCreateForImageBuffer(
        allocator: Option<&CFAllocator>,
        image_buffer: &CVImageBuffer,
        format_description_out: NonNull<*const CMVideoFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a format description for a video media stream that the parameter set describes.
    ///
    /// Parameters:
    /// - allocator: CFAllocator to be used when creating the CMFormatDescription. Pass NULL to use the default allocator.
    ///
    /// - parameterSetCount: The number of parameter sets to include in the format description. This parameter must be at least 2.
    ///
    /// - parameterSetPointers: Points to a C array containing parameterSetCount pointers to parameter sets.
    ///
    /// - parameterSetSizes: Points to a C array containing the size, in bytes, of each of the parameter sets.
    ///
    /// - NALUnitHeaderLength: Size, in bytes, of the NALUnitLength field in an AVC video sample or AVC parameter set sample. Pass 1, 2, or 4.
    ///
    /// - formatDescriptionOut: Returned newly created video CMFormatDescription.
    ///
    ///
    /// ## Discussion
    ///
    /// This function parses the dimensions provided by the parameter sets and creates a format description suitable for a raw H.264 stream. The parameter sets’ data can come from raw NAL units and must have any emulation prevention bytes needed.The supported NAL unit types to be included in the format description are 7 (sequence parameter set), 8 (picture parameter set) and 13 (sequence parameter set extension). At least one sequence parameter set and one picture parameter set must be provided.
    ///
    ///
    /// Creates a format description for a video media stream described by H.264 parameter set NAL units.
    ///
    /// This function parses the dimensions provided by the parameter sets and creates a format description suitable for a raw H.264 stream.
    /// The parameter sets' data can come from raw NAL units and must have any emulation prevention bytes needed.
    /// The supported NAL unit types to be included in the format description are 7 (sequence parameter set), 8 (picture parameter set) and 13 (sequence parameter set extension). At least one sequence parameter set and one picture parameter set must be provided.
    ///
    /// # Safety
    ///
    /// - `parameter_set_pointers` must be a valid pointer.
    /// - `parameter_set_sizes` must be a valid pointer.
    /// - `format_description_out` must be a valid pointer.
    pub fn CMVideoFormatDescriptionCreateFromH264ParameterSets(
        allocator: Option<&CFAllocator>,
        parameter_set_count: usize,
        parameter_set_pointers: NonNull<NonNull<u8>>,
        parameter_set_sizes: NonNull<usize>,
        nal_unit_header_length: c_int,
        format_description_out: NonNull<*const CMFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a format description for a video media stream using HEVC (H.265) parameter set NAL units.
    ///
    /// Parameters:
    /// - allocator: The `CFAllocator` for creating the format description, or pass `nil` to use the default allocator.
    ///
    /// - parameterSetCount: The number of parameter sets to include in the format description, which needs to be at least `2`.
    ///
    /// - parameterSetPointers: Points to a C array containing `parameterSetCount` pointers to parameter sets.
    ///
    /// - parameterSetSizes: Points to a C array containing the size, in bytes, of each of the parameter sets.
    ///
    /// - NALUnitHeaderLength: The size, in bytes, of the `NALUnitLength` field in an AVC video sample or an AVC parameter set sample. Pass `1`, `2`, or `4`.
    ///
    /// - extensions: An optional dictionary of extension key-value pairs. Keys are [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) and values are property list objects, such as [`CFDataRef`](https://developer.apple.com/documentation/corefoundation/cfdata), [`CFBooleanRef`](https://developer.apple.com/documentation/corefoundation/cfboolean), [`CFNumberRef`](https://developer.apple.com/documentation/corefoundation/cfnumber), [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring), [`CFDateRef`](https://developer.apple.com/documentation/corefoundation/cfdate), [`CFArrayRef`](https://developer.apple.com/documentation/corefoundation/cfarray), and [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary).
    ///
    /// - formatDescriptionOut: The newly created video format description.
    ///
    ///
    /// ## Discussion
    ///
    /// This method parses the dimensions from the parameter sets and creates a format description suitable for an HEVC (H.265) stream. The parameter sets’ data can come from raw NAL units and needs to include emulation prevention bytes as necessary.
    ///
    /// The supported NAL unit types to include in the format description are:
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "7" }] }], [Paragraph { inline_content: [Text { text: "Sequence parameter set" }] }]], [[Paragraph { inline_content: [Text { text: "8" }] }], [Paragraph { inline_content: [Text { text: "Picture parameter set" }] }]], [[Paragraph { inline_content: [Text { text: "13" }] }], [Paragraph { inline_content: [Text { text: "Sequence parameter set extension" }] }]]], alignments: None, metadata: None })
    /// <div class="warning">
    ///
    /// ### Important
    ///  You need to provide at least one sequence parameter set and one picture parameter set.
    ///
    ///
    ///
    /// </div>
    ///
    /// Creates a format description for a video media stream described by HEVC (H.265) parameter set NAL units.
    ///
    /// This function parses the dimensions provided by the parameter sets and creates a format description suitable for a raw H.265 stream.
    /// The parameter sets' data can come from raw NAL units and must have any emulation prevention bytes needed.
    /// The supported NAL unit types to be included in the format description are 32 (video parameter set), 33 (sequence parameter set), 34 (picture parameter set), 39 (prefix SEI) and 40 (suffix SEI). At least one of each parameter set must be provided.
    ///
    /// # Safety
    ///
    /// - `parameter_set_pointers` must be a valid pointer.
    /// - `parameter_set_sizes` must be a valid pointer.
    /// - `extensions` generic must be of the correct type.
    /// - `extensions` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    pub fn CMVideoFormatDescriptionCreateFromHEVCParameterSets(
        allocator: Option<&CFAllocator>,
        parameter_set_count: usize,
        parameter_set_pointers: NonNull<NonNull<u8>>,
        parameter_set_sizes: NonNull<usize>,
        nal_unit_header_length: c_int,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Returns a parameter set that an H.264 format description contains.
    ///
    /// Parameters:
    /// - videoDesc: The format description being interrogated.
    ///
    /// - parameterSetIndex: Index of the parameter set to be returned in parameterSetPointerOut and parameterSetSizeOut. This parameter is ignored if both parameterSetPointerOut and parameterSetSizeOut are NULL.
    ///
    /// - parameterSetPointerOut: Points to a pointer to receive the parameter set. Pass NULL if you do not want this information.
    ///
    /// - parameterSetSizeOut: Points to a size_t to receive the size in bytes of the parameter set. Pass NULL if you do not want this information.
    ///
    /// - parameterSetCountOut: Number of parameter sets in the AVC decoder configuration record contained in videoDesc. Pass NULL if you do not want this information.
    ///
    /// - NALUnitHeaderLengthOut: Points to an int to receive the size, in bytes, of the NALUnitLength field in an AVC video sample or AVC parameter set sample. Pass NULL if you do not want this information.
    ///
    ///
    /// ## Discussion
    ///
    /// This function parses the AVC decoder configuration record contained in a H.264 video format description and returns the parameter set NAL unit at the given index from it.Both parameterSetPointerOut and parameterSetSizeOut may be NULL, parameterSetCountOut will return the total number of parameter set NAL units contained in the AVC decoder configuration record.The parameter set NAL units returned will already have any emulation prevention bytes needed.The pointer returned in parameterSetPointerOut points to internal memory of videoDesc, and may only be accessed as long as a retain on videoDesc is held.
    ///
    ///
    /// Returns a parameter set contained in a H.264 format description.
    ///
    /// This function parses the AVC decoder configuration record contained in a H.264 video format description and returns the NAL unit at the given index from it.  These NAL units are typically parameter sets (e.g. SPS, PPS), but may contain others as specified by ISO/IEC 14496-15 (e.g. user-data SEI).
    /// Both parameterSetPointerOut and parameterSetSizeOut may be NULL, parameterSetCountOut will return the total number of parameter set NAL units contained in the AVC decoder configuration record.
    /// The parameter set NAL units returned will already have any emulation prevention bytes needed.
    /// The pointer returned in parameterSetPointerOut points to internal memory of videoDesc, and may only be accessed as long as a retain on videoDesc is held.
    ///
    /// # Safety
    ///
    /// - `parameter_set_pointer_out` must be a valid pointer or null.
    /// - `parameter_set_size_out` must be a valid pointer or null.
    /// - `parameter_set_count_out` must be a valid pointer or null.
    /// - `nal_unit_header_length_out` must be a valid pointer or null.
    pub fn CMVideoFormatDescriptionGetH264ParameterSetAtIndex(
        video_desc: &CMFormatDescription,
        parameter_set_index: usize,
        parameter_set_pointer_out: *mut *const u8,
        parameter_set_size_out: *mut usize,
        parameter_set_count_out: *mut usize,
        nal_unit_header_length_out: *mut c_int,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Returns a parameter set contained in an HEVC (H.265) format description.
    /// Returns a parameter set contained in a HEVC (H.265) format description.
    ///
    /// This function parses the HEVC decoder configuration record contained in a H.265 video format description and returns the NAL unit at the given index from it.  These NAL units are typically parameter sets (e.g. VPS, SPS, PPS), but may contain others as specified by ISO/IEC 14496-15 (e.g. user-data SEI).
    /// Both parameterSetPointerOut and parameterSetSizeOut may be NULL, parameterSetCountOut will return the total number of parameter set NAL units contained in the HEVC decoder configuration record.
    /// The parameter set NAL units returned will already have any emulation prevention bytes needed.
    /// The pointer returned in parameterSetPointerOut points to internal memory of videoDesc, and may only be accessed as long as a retain on videoDesc is held.
    ///
    /// # Safety
    ///
    /// - `parameter_set_pointer_out` must be a valid pointer or null.
    /// - `parameter_set_size_out` must be a valid pointer or null.
    /// - `parameter_set_count_out` must be a valid pointer or null.
    /// - `nal_unit_header_length_out` must be a valid pointer or null.
    pub fn CMVideoFormatDescriptionGetHEVCParameterSetAtIndex(
        video_desc: &CMFormatDescription,
        parameter_set_index: usize,
        parameter_set_pointer_out: *mut *const u8,
        parameter_set_size_out: *mut usize,
        parameter_set_count_out: *mut usize,
        nal_unit_header_length_out: *mut c_int,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Returns the video dimensions, in encoded pixels.
    ///
    /// Parameters:
    /// - videoDesc: `CMVideoFormatDescription` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// The video dimensions of the given video format.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This does not take into account pixel aspect ratio or clean aperture tags.
    ///
    ///
    /// Returns the dimensions (in encoded pixels)
    ///
    /// This does not take into account pixel aspect ratio or clean aperture tags.
    pub fn CMVideoFormatDescriptionGetDimensions(
        video_desc: &CMVideoFormatDescription,
    ) -> CMVideoDimensions;
}

/// Returns the dimensions after taking the pixel aspect ratio and clean aperture into account.
///
/// Parameters:
/// - videoDesc: `CMVideoFormatDescription` being interrogated.
///
/// - usePixelAspectRatio: Compute the dimensions maintaining pixel aspect ratio.
///
/// - useCleanAperture: Compute the dimensions using the clean aperture.
///
///
/// ## Discussion
///
/// Pixel aspect ratio is used to adjust the width, leaving the height alone.
///
///
/// Returns the dimensions, adjusted to take pixel aspect ratio and/or clean aperture into account.
///
/// Pixel aspect ratio is used to adjust the width, leaving the height alone.
#[inline]
pub unsafe extern "C-unwind" fn CMVideoFormatDescriptionGetPresentationDimensions(
    video_desc: &CMVideoFormatDescription,
    use_pixel_aspect_ratio: bool,
    use_clean_aperture: bool,
) -> CGSize {
    extern "C-unwind" {
        fn CMVideoFormatDescriptionGetPresentationDimensions(
            video_desc: &CMVideoFormatDescription,
            use_pixel_aspect_ratio: Boolean,
            use_clean_aperture: Boolean,
        ) -> CGSize;
    }
    unsafe {
        CMVideoFormatDescriptionGetPresentationDimensions(
            video_desc,
            use_pixel_aspect_ratio as _,
            use_clean_aperture as _,
        )
    }
}

/// Returns a rectangle that defines the portion of the encoded pixel dimensions that represent the image data that’s valid for displaying.
///
/// Parameters:
/// - videoDesc: `CMVideoFormatDescription` being interrogated.
///
/// - originIsAtTopLeft: Pass true if the CGRect will be used in an environment where (0,0) is at the top-left corner of an enclosing rectangle and y coordinates increase as you go down. Pass false if the `CGRect` will be used in an environment where (0,0) is at the bottom-left corner of an enclosing rectangle and y coordinates increase as you go up.
///
/// Returns the clean aperture.
///
/// The clean aperture is a rectangle that defines the portion of the encoded pixel dimensions
/// that represents image data valid for display.
#[inline]
pub unsafe extern "C-unwind" fn CMVideoFormatDescriptionGetCleanAperture(
    video_desc: &CMVideoFormatDescription,
    origin_is_at_top_left: bool,
) -> CGRect {
    extern "C-unwind" {
        fn CMVideoFormatDescriptionGetCleanAperture(
            video_desc: &CMVideoFormatDescription,
            origin_is_at_top_left: Boolean,
        ) -> CGRect;
    }
    unsafe { CMVideoFormatDescriptionGetCleanAperture(video_desc, origin_is_at_top_left as _) }
}

/// Returns an array of keys that you use for video format description extensions, image buffer attachments, and attributes.
///
/// ## Discussion
///
/// When specifying a `CMFormatDescription` for a `CMSampleBuffer`, the format description must be consistent with formatting information attached to the `CVImageBuffer`. The width, height, and codecType must match (for `CVPixelBuffers` the codec type is given by `CVPixelBufferGetPixelFormatType`(pixelBuffer); for other `CVImageBuffers`, the codecType must be 0). The format description extensions must match the image buffer attachments for all the keys in the list returned by this function (if absent in either they must be absent in both). Currently, the list is:
///
/// - kCMFormatDescriptionExtension_CleanAperture
///
/// - kCMFormatDescriptionExtension_FieldCount
///
/// - kCMFormatDescriptionExtension_FieldDetail
///
/// - kCMFormatDescriptionExtension_PixelAspectRatio
///
/// - kCMFormatDescriptionExtension_ColorPrimaries
///
/// - kCMFormatDescriptionExtension_TransferFunction
///
/// - kCMFormatDescriptionExtension_GammaLevel
///
/// - kCMFormatDescriptionExtension_YCbCrMatrix
///
/// - kCMFormatDescriptionExtension_ICCProfile
///
/// - kCMFormatDescriptionExtension_ChromaLocationTopField
///
/// - kCMFormatDescriptionExtension_ChromaLocationBottomField
///
///
/// Returns an array of the keys that are used both as CMVideoFormatDescription extensions
/// and CVImageBuffer attachments and attributes.
///
/// When specifying a CMFormatDescription for a CMSampleBuffer, the format description must
/// be consistent with formatting information attached to the CVImageBuffer. The width, height,
/// and codecType must match (for CVPixelBuffers the codec type is given by
/// CVPixelBufferGetPixelFormatType(pixelBuffer); for other CVImageBuffers, the codecType must be 0).
/// The format description extensions must match the image buffer attachments for all the keys in the
/// list returned by this function (if absent in either they must be absent in both).
///
/// Currently, the list is:
///
/// kCMFormatDescriptionExtension_CleanAperture
/// kCMFormatDescriptionExtension_FieldCount
/// kCMFormatDescriptionExtension_FieldDetail
/// kCMFormatDescriptionExtension_PixelAspectRatio
/// kCMFormatDescriptionExtension_ColorPrimaries
/// kCMFormatDescriptionExtension_TransferFunction
/// kCMFormatDescriptionExtension_GammaLevel
/// kCMFormatDescriptionExtension_YCbCrMatrix
/// kCMFormatDescriptionExtension_ICCProfile
/// kCMFormatDescriptionExtension_ChromaLocationTopField
/// kCMFormatDescriptionExtension_ChromaLocationBottomField
/// kCMFormatDescriptionExtension_MasteringDisplayColorVolume
/// kCMFormatDescriptionExtension_ContentLightLevelInfo
#[inline]
pub unsafe extern "C-unwind" fn CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers(
) -> CFRetained<CFArray> {
    extern "C-unwind" {
        fn CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers(
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

/// Returns a Boolean value that indicates whether a format description matches an image buffer.
///
/// Parameters:
/// - desc: CMVideoFormatDescription to validate.
///
/// - imageBuffer: Image buffer to validate against.
///
///
/// ## Return Value
///
/// A Boolean indicating whether the format description matches the image buffer.
///
///
///
/// ## Discussion
///
/// This function uses the keys returned by `CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers` to compare the extensions of the given format description to the attachments of the given image buffer (if an attachment is absent in either it must be absent in both). It also checks `kCMFormatDescriptionExtension_BytesPerRow` against `CVPixelBufferGetBytesPerRow`, if applicable.
///
///
/// Checks to see if a given format description matches an image buffer.
///
/// This function uses the keys returned by CMVideoFormatDescriptionGetExtensionKeysCommonWithImageBuffers
/// to compares the extensions of the given format description to the attachments of the
/// given image buffer (if an attachment is absent in either it must be absent in both).
/// It also checks kCMFormatDescriptionExtension_BytesPerRow against CVPixelBufferGetBytesPerRow, if applicable.
#[cfg(feature = "objc2-core-video")]
#[inline]
pub unsafe extern "C-unwind" fn CMVideoFormatDescriptionMatchesImageBuffer(
    desc: &CMVideoFormatDescription,
    image_buffer: &CVImageBuffer,
) -> bool {
    extern "C-unwind" {
        fn CMVideoFormatDescriptionMatchesImageBuffer(
            desc: &CMVideoFormatDescription,
            image_buffer: &CVImageBuffer,
        ) -> Boolean;
    }
    let ret = unsafe { CMVideoFormatDescriptionMatchesImageBuffer(desc, image_buffer) };
    ret != 0
}

extern "C-unwind" {
    /// Copies the multi-image encoding properties as an array of CMTagCollections.
    ///
    /// Parameters:
    /// - formatDescription: The format description to extract tag collections from.
    ///
    /// - tagCollectionsOut: A pointer to a CFArrayRef result containing the categories of present tags. If the copy fails, `tagCollectionsOut` is `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns 0 on success or a value from
    ///
    ///
    /// Copies the multi-image encoding properties as an array of CMTagCollections.
    ///
    /// Parameter `formatDescription`: CMVideoFormatDescription being interrogated.
    ///
    /// Parameter `tagCollectionsOut`: Returned TagCollections with CMTags such as kCMTagCategory_VideoLayerID and kCMTagCategory_StereoViewType.
    ///
    /// On return, the caller owns the returned CFArrayRef and must release it when done with it.
    /// This function copies the VideoLayerIDs and LeftAndRightViewIDs from hvcC and 3D Reference Displays Info SEI in the formatDescription.
    /// The returned values can be used to enable the multi-image decoding with kVTDecompressionPropertyKey_RequestedMVHEVCVideoLayerIDs.
    /// It also gives the eye mapping information for the pixel buffers of the decoded CMTaggedBufferGroups.
    ///
    /// Returns: Array of CMTagCollections. The result will be NULL if the CMVideoFormatDescription does not contain multi-image encoding parameters, or if there is some other error.
    ///
    /// # Safety
    ///
    /// `tag_collections_out` must be a valid pointer or null.
    pub fn CMVideoFormatDescriptionCopyTagCollectionArray(
        format_description: &CMVideoFormatDescription,
        tag_collections_out: *mut *const CFArray,
    ) -> OSStatus;
}

/// A type for tagged buffer format descriptions.
/// Synonym type used for manipulating CMTaggedBufferGroup media CMFormatDescriptions
#[doc(alias = "CMTaggedBufferGroupFormatDescriptionRef")]
pub type CMTaggedBufferGroupFormatDescription = CMFormatDescription;

/// A type for tagged buffer format information.
/// The subtypes of CMTaggedBufferGroup media type.
pub type CMTaggedBufferGroupFormatType = FourCharCode;

pub const kCMTaggedBufferGroupFormatType_TaggedBufferGroup: CMTaggedBufferGroupFormatType =
    0x74626772;

/// A type you use to interact with muxed format descriptions.
/// Synonym type used for manipulating muxed media CMFormatDescriptions
#[doc(alias = "CMMuxedFormatDescriptionRef")]
pub type CMMuxedFormatDescription = CMFormatDescription;

/// A datatype that represents a muxed stream of data.
/// Muxed media format/subtype.
///
///
///
///
///
///
/// Contains interleaved sample buffers from multiple media types. The receiver should query the media type of each CMSampleBuffer’s format description to discover if it’s video or audio, and process it accordingly.
pub type CMMuxedStreamType = FourCharCode;

/// MPEG-1 System stream.
pub const kCMMuxedStreamType_MPEG1System: CMMuxedStreamType = 0x6d703173;
/// MPEG-2 Transport stream.
pub const kCMMuxedStreamType_MPEG2Transport: CMMuxedStreamType = 0x6d703274;
/// MPEG-2 Program stream.
pub const kCMMuxedStreamType_MPEG2Program: CMMuxedStreamType = 0x6d703270;
/// DV stream.
pub const kCMMuxedStreamType_DV: CMMuxedStreamType = 0x64762020;
pub const kCMMuxedStreamType_EmbeddedDeviceScreenRecording: CMMuxedStreamType = 0x69737220;

extern "C-unwind" {
    /// Creates a format description for a muxed media stream.
    ///
    /// Parameters:
    /// - allocator: `CFAllocator` to be used. Pass `NULL` or `kCFAllocatorDefault` to use the default allocator.
    ///
    /// - muxType: Type of the muxed stream (e.g. `kCMMuxedStreamType_MPEG2Transport` for MPEG-2 transport stream). This is the media subtype, and will be returned if you subsequently call `CMFormatDescriptionGetMediaSubType` (or `CMMuxedFormatDescriptionGetStreamType`).
    ///
    /// - extensions: Dictionary of extension key/value pairs. Keys are always of type `CFString`. Values are always property list objects (i.e.. `CFData`, `CFString`, `CFArray`, `CFDictionary`, `CFDate`, `CFBoolean`, or `CFNumber`). Can be `NULL`.
    ///
    /// - formatDescriptionOut: On output, returns newly created muxed `CMFormatDescription`
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. Returns `noErr` if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A muxed format description does not know the formats of the sub-streams within the muxed stream. That information will only be discoverable by the demuxer software (or other software which understands the details of the muxed bitstream) which will need to produce separate format descriptions for each of its output streams. The caller owns the returned `CMFormatDescription`, and must release it when done with it. All input parameters are copied (the extensions are deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    ///
    /// Creates a format description for a muxed media stream.
    ///
    /// A muxed format description does not know what the formats are of the substreams within the muxed stream.
    /// That information will only be discoverable by the demuxer software (or other software which understands
    /// the details of the muxed bitstream) which will need to produce separate format descriptions for each of
    /// its output streams. The caller owns the returned CMFormatDescription, and must release it when done
    /// with it. All input parameters are copied (the extensions are deep-copied).  The caller can deallocate
    /// them or re-use them after making this call.
    ///
    /// # Safety
    ///
    /// - `extensions` generic must be of the correct type.
    /// - `extensions` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    pub fn CMMuxedFormatDescriptionCreate(
        allocator: Option<&CFAllocator>,
        mux_type: CMMuxedStreamType,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMMuxedFormatDescription>,
    ) -> OSStatus;
}

/// A type you use to interact with closed caption format descriptions.
/// Synonym type used for manipulating closed-caption media CMFormatDescriptions
#[doc(alias = "CMClosedCaptionFormatDescriptionRef")]
pub type CMClosedCaptionFormatDescription = CMFormatDescription;

/// A closed caption format type.
/// Closed-caption media format/subtype.
/// Note:  use CMFormatDescriptionCreate to create a CMClosedCaptionFormatDescriptionRef.
pub type CMClosedCaptionFormatType = FourCharCode;

/// A type that describes CEA 608-compliant samples.
pub const kCMClosedCaptionFormatType_CEA608: CMClosedCaptionFormatType = 0x63363038;
/// A type that describes CEA 708-compliant samples.
pub const kCMClosedCaptionFormatType_CEA708: CMClosedCaptionFormatType = 0x63373038;
/// A type that describes ATSC-compliant samples.
pub const kCMClosedCaptionFormatType_ATSC: CMClosedCaptionFormatType = 0x61746363;

/// A type you use to interact with text format descriptions.
/// Synonym type used for manipulating Text media CMFormatDescriptions
#[doc(alias = "CMTextFormatDescriptionRef")]
pub type CMTextFormatDescription = CMFormatDescription;

/// A text format type.
/// Text media format/subtype.
pub type CMTextFormatType = FourCharCode;

/// A type that describes QuickTime text media.
pub const kCMTextFormatType_QTText: CMTextFormatType = 0x74657874;
/// A type that describes 3GPP text media.
pub const kCMTextFormatType_3GText: CMTextFormatType = 0x74783367;

/// An integer value that describes the display mode flags for text media.
/// Display mode flags for text media.
pub type CMTextDisplayFlags = u32;

/// A flag that describes the text scrolls into the display region.
pub const kCMTextDisplayFlag_scrollIn: CMTextDisplayFlags = 0x00000020;
/// A flag that describes the text scrolls out of the display region.
pub const kCMTextDisplayFlag_scrollOut: CMTextDisplayFlags = 0x00000040;
/// A flag that describes the scrolling direction is set by a two-bit field, obtained from displayFlags using kCMTextDisplayFlag_scrollDirectionMask.
pub const kCMTextDisplayFlag_scrollDirectionMask: CMTextDisplayFlags = 0x00000180;
/// A flag that describes the text is vertically scrolled up (“credits style”), entering from the bottom and leaving towards the top.
pub const kCMTextDisplayFlag_scrollDirection_bottomToTop: CMTextDisplayFlags = 0x00000000;
/// A flag that describes the text is horizontally scrolled (“marquee style”), entering from the right and leaving towards the left.
pub const kCMTextDisplayFlag_scrollDirection_rightToLeft: CMTextDisplayFlags = 0x00000080;
/// A flag that describes the text is vertically scrolled down, entering from the top and leaving towards the bottom.
pub const kCMTextDisplayFlag_scrollDirection_topToBottom: CMTextDisplayFlags = 0x00000100;
/// A flag that describes the text is horizontally scrolled, entering from the left and leaving towards the right.
pub const kCMTextDisplayFlag_scrollDirection_leftToRight: CMTextDisplayFlags = 0x00000180;
/// A flag that describes enabling the continuous karaoke mode where the range of karaoke highlighting extends to include additional ranges rather than the highlighting moves onto the next range.
pub const kCMTextDisplayFlag_continuousKaraoke: CMTextDisplayFlags = 0x00000800;
/// A flag that describes the text renders vertically.
pub const kCMTextDisplayFlag_writeTextVertically: CMTextDisplayFlags = 0x00020000;
/// A flag that describes the subtitle display bounds are to be filled with the color specified by `kCMTextFormatDescriptionExtension_BackgroundColor`.
pub const kCMTextDisplayFlag_fillTextRegion: CMTextDisplayFlags = 0x00040000;
/// A flag that describes using the subtitle display bounds to determine if the system places the subtitltes near the top or bottom of the video.
pub const kCMTextDisplayFlag_obeySubtitleFormatting: CMTextDisplayFlags = 0x20000000;
/// A flag that describes forcing subtitles are present, for example, a subtitle which only displays during foreign language sections of the video. Check individual samples to determine what type of subtitle is contained.
pub const kCMTextDisplayFlag_forcedSubtitlesPresent: CMTextDisplayFlags = 0x40000000;
/// A flag that describes treating all subtitle samples as if they contain forced subtitles.
pub const kCMTextDisplayFlag_allSubtitlesForced: CMTextDisplayFlags = 0x80000000;

/// An integer value that describes the justification modes for text media.
/// Justification modes for text media. Used when specifying either horizontal or vertical justification.
pub type CMTextJustificationValue = i8;

/// A type that describes left justification when specified for horizontal justification, top justification for vertical justification.
pub const kCMTextJustification_left_top: CMTextJustificationValue = 0;
/// A type that describes center justification (both horizontal and vertical justification).
pub const kCMTextJustification_centered: CMTextJustificationValue = 1;
/// A type that describes bottom justification when specified for vertical justification, right justification for horizontal justification.
pub const kCMTextJustification_bottom_right: CMTextJustificationValue = -1;

extern "C" {
    /// The extension flag that represents the display flags.
    ///
    /// ## Discussion
    ///
    /// The value needs to be a value as a number an `SInt32` that holds [`CMTextDisplayFlags`](https://developer.apple.com/documentation/coremedia/cmtextdisplayflags).
    ///
    ///
    pub static kCMTextFormatDescriptionExtension_DisplayFlags: &'static CFString;
}

extern "C" {
    /// The extension flag that represents the background color.
    ///
    /// ## Discussion
    ///
    /// The value needs to be a [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary).
    ///
    ///
    pub static kCMTextFormatDescriptionExtension_BackgroundColor: &'static CFString;
}

extern "C" {
    /// The color value for red is a number.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt8` for 3G or `SInt16` for QuickTime.
    ///
    ///
    pub static kCMTextFormatDescriptionColor_Red: &'static CFString;
}

extern "C" {
    /// The color value for green is a number.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt8` for 3G or `SInt16` for QuickTime.
    ///
    ///
    pub static kCMTextFormatDescriptionColor_Green: &'static CFString;
}

extern "C" {
    /// The color value for blue is a number.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt8` for 3G or `SInt16` for QuickTime.
    ///
    ///
    pub static kCMTextFormatDescriptionColor_Blue: &'static CFString;
}

extern "C" {
    /// The color value for the alpha is a number.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt8` for 3G and is not applicable for QuickTime text.
    ///
    ///
    pub static kCMTextFormatDescriptionColor_Alpha: &'static CFString;
}

extern "C" {
    /// The extension flag that represents the default text box.
    ///
    /// ## Discussion
    ///
    /// The value needs to be a [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary).
    ///
    ///
    pub static kCMTextFormatDescriptionExtension_DefaultTextBox: &'static CFString;
}

extern "C" {
    /// The top value for the rect as a 16-bit number.
    pub static kCMTextFormatDescriptionRect_Top: &'static CFString;
}

extern "C" {
    /// The left value for the rect as a 16-bit number.
    pub static kCMTextFormatDescriptionRect_Left: &'static CFString;
}

extern "C" {
    /// The bottom value for the rect as a 16-bit number.
    pub static kCMTextFormatDescriptionRect_Bottom: &'static CFString;
}

extern "C" {
    /// The right value for the rect as a 16-bit number.
    pub static kCMTextFormatDescriptionRect_Right: &'static CFString;
}

extern "C" {
    /// The extension flag that represents the default style.
    ///
    /// ## Discussion
    ///
    /// The value needs to be a [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary).
    ///
    ///
    pub static kCMTextFormatDescriptionExtension_DefaultStyle: &'static CFString;
}

extern "C" {
    /// The style value for the starting character.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt16` for 3G or `SInt32` for QuickTime.
    ///
    ///
    pub static kCMTextFormatDescriptionStyle_StartChar: &'static CFString;
}

extern "C" {
    /// The style value for font.
    ///
    /// ## Discussion
    ///
    /// The value needs to be a `SInt16`.
    ///
    ///
    pub static kCMTextFormatDescriptionStyle_Font: &'static CFString;
}

extern "C" {
    /// The style value for font face.
    ///
    /// ## Discussion
    ///
    /// The value needs to be a `SInt8`.
    ///
    ///
    pub static kCMTextFormatDescriptionStyle_FontFace: &'static CFString;
}

extern "C" {
    /// The style value for foreground color.
    ///
    /// ## Discussion
    ///
    /// The dictionary contains values for `kCMTextFormatDescriptionColor_Red`, `kCMTextFormatDescriptionColor_Green`, and so on.
    ///
    ///
    pub static kCMTextFormatDescriptionStyle_ForegroundColor: &'static CFString;
}

extern "C" {
    /// The style value for the font size.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt8` for 3G or `SInt16` for QuickTime.
    ///
    ///
    pub static kCMTextFormatDescriptionStyle_FontSize: &'static CFString;
}

extern "C" {
    /// The extension flag that represents the horizontal justification.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt8` and contains a [`CMTextJustificationValue`](https://developer.apple.com/documentation/coremedia/cmtextjustificationvalue).
    ///
    ///
    pub static kCMTextFormatDescriptionExtension_HorizontalJustification: &'static CFString;
}

extern "C" {
    /// The extension flag that represents the vertical justification.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt8` and contains a [`CMTextJustificationValue`](https://developer.apple.com/documentation/coremedia/cmtextjustificationvalue).
    ///
    ///
    pub static kCMTextFormatDescriptionExtension_VerticalJustification: &'static CFString;
}

extern "C" {
    /// The style value for the ending character.
    ///
    /// ## Discussion
    ///
    /// The value needs to be a `SInt16`.
    ///
    ///
    pub static kCMTextFormatDescriptionStyle_EndChar: &'static CFString;
}

extern "C" {
    /// The extension flag that represents the font table.
    ///
    /// ## Discussion
    ///
    /// The value needs to be a [`CFDictionaryRef`](https://developer.apple.com/documentation/corefoundation/cfdictionary).
    ///
    ///
    pub static kCMTextFormatDescriptionExtension_FontTable: &'static CFString;
}

extern "C" {
    /// The extension flag that represents the text justification.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt8` and containing a [`CMTextJustificationValue`](https://developer.apple.com/documentation/coremedia/cmtextjustificationvalue).
    ///
    ///
    pub static kCMTextFormatDescriptionExtension_TextJustification: &'static CFString;
}

extern "C" {
    /// The style value for the height.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt16`.
    ///
    ///
    pub static kCMTextFormatDescriptionStyle_Height: &'static CFString;
}

extern "C" {
    /// The style value for the ascent.
    ///
    /// ## Discussion
    ///
    /// The value needs to be `SInt16`.
    ///
    ///
    pub static kCMTextFormatDescriptionStyle_Ascent: &'static CFString;
}

extern "C" {
    /// The extension flag that represents the default font name.
    pub static kCMTextFormatDescriptionExtension_DefaultFontName: &'static CFString;
}

extern "C" {
    pub static kCMFormatDescriptionExtension_AmbientViewingEnvironment: &'static CFString;
}

extern "C-unwind" {
    /// Returns the display flags.
    ///
    /// Parameters:
    /// - desc: `CMFormatDescription` being interrogated.
    ///
    /// - displayFlagsOut: On output, receives the display flags.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. Returns `noErr` if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// These are the flags that control how the text appears.
    ///
    ///
    /// Returns the displayFlags.
    ///
    /// These are the flags that control how the text appears. The function can return kCMFormatDescriptionError_ValueNotAvailable for formats without display flags.
    ///
    /// # Safety
    ///
    /// `display_flags_out` must be a valid pointer.
    pub fn CMTextFormatDescriptionGetDisplayFlags(
        desc: &CMFormatDescription,
        display_flags_out: NonNull<CMTextDisplayFlags>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Returns the horizontal and vertical justification.
    ///
    /// Parameters:
    /// - desc: `CMFormatDescription` being interrogated.
    ///
    /// - horizontaJustificationlOut: Horizontal justification mode. May be `NULL`.
    ///
    /// - verticalJustificationOut: Vertical justification mode. May be `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. Returns `noErr` if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For possible values see [`CMTextJustificationValue`](https://developer.apple.com/documentation/coremedia/cmtextjustificationvalue).
    ///
    ///
    /// Returns horizontal and vertical justification.
    ///
    /// Values are kCMTextJustification_* constants. The function returns kCMFormatDescriptionError_ValueNotAvailable for format descriptions that do not carry text justification.
    ///
    /// # Safety
    ///
    /// - `horizonta_justificationl_out` must be a valid pointer or null.
    /// - `vertical_justification_out` must be a valid pointer or null.
    pub fn CMTextFormatDescriptionGetJustification(
        desc: &CMFormatDescription,
        horizonta_justificationl_out: *mut CMTextJustificationValue,
        vertical_justification_out: *mut CMTextJustificationValue,
    ) -> OSStatus;
}

/// Returns the default text box.
///
/// Parameters:
/// - desc: FormatDescription being interrogated.
///
/// - originIsAtTopLeft: Pass true if the `CGRect` will be used in an environment where (0,0) is at the top-left corner of an enclosing rectangle and y coordinates increase as you go down.
///
/// Pass false if the `CGRect` will be used in an environment where (0,0) is at the bottom-left corner of an enclosing rectangle and y coordinates increase as you go up.
///
/// - heightOfTextTrack: If `originIsAtTopLeft` is false, pass the height of the enclosing text track or destination.                                    This value will be used to properly compute the default text box for the given origin. Ignored if `originIsAtTopLeft` is true.
///
/// - defaultTextBoxOut: On output, receives the default text box.
///
///
/// ## Return Value
///
/// A result code. Returns `noErr` if successful.
///
///
///
/// ## Discussion
///
/// Within a text track, text is rendered within a text box.  There is a default text box set, which can be over-ridden by a sample.
///
///
/// Returns the default text box.
///
/// Within a text track, text is rendered within a text box.  There is a default text box set, which can be over-ridden by a sample. The function can return kCMFormatDescriptionError_ValueNotAvailable for format descriptions that do not carry a default text box.
///
/// # Safety
///
/// `default_text_box_out` must be a valid pointer.
#[inline]
pub unsafe extern "C-unwind" fn CMTextFormatDescriptionGetDefaultTextBox(
    desc: &CMFormatDescription,
    origin_is_at_top_left: bool,
    height_of_text_track: CGFloat,
    default_text_box_out: NonNull<CGRect>,
) -> OSStatus {
    extern "C-unwind" {
        fn CMTextFormatDescriptionGetDefaultTextBox(
            desc: &CMFormatDescription,
            origin_is_at_top_left: Boolean,
            height_of_text_track: CGFloat,
            default_text_box_out: NonNull<CGRect>,
        ) -> OSStatus;
    }
    unsafe {
        CMTextFormatDescriptionGetDefaultTextBox(
            desc,
            origin_is_at_top_left as _,
            height_of_text_track,
            default_text_box_out,
        )
    }
}

extern "C-unwind" {
    /// Returns a font name for a local font identifier.
    ///
    /// Parameters:
    /// - desc: `CMFormatDescription` being interrogated.
    ///
    /// - localFontID: Font number, local to the FormatDescription.
    ///
    /// - fontNameOut: On output, returns name of the font. The returned font is not retained by this call, so clients are required to retain it if they need to keep it longer.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. Returns `noErr` if successful.
    ///
    ///
    /// Returns the font name for a local font ID.
    ///
    /// Some format descriptions carry a mapping from local font IDs to font names. The function returns kCMFormatDescriptionError_ValueNotAvailable for format descriptions that do not carry such a font mapping table.
    ///
    /// # Safety
    ///
    /// `font_name_out` must be a valid pointer.
    pub fn CMTextFormatDescriptionGetFontName(
        desc: &CMFormatDescription,
        local_font_id: u16,
        font_name_out: NonNull<*const CFString>,
    ) -> OSStatus;
}

/// A type that represents a text subtitle format.
pub type CMSubtitleFormatType = FourCharCode;

pub const kCMSubtitleFormatType_3GText: CMSubtitleFormatType = 0x74783367;
pub const kCMSubtitleFormatType_WebVTT: CMSubtitleFormatType = 0x77767474;

/// A type you use to interact with time code format descriptions.
/// SYnonym type used for manipulating TimeCode media CMFormatDescriptions
#[doc(alias = "CMTimeCodeFormatDescriptionRef")]
pub type CMTimeCodeFormatDescription = CMFormatDescription;

/// A time code format type.
/// The types of TimeCode.
pub type CMTimeCodeFormatType = FourCharCode;

/// 32-bit time code sample.
pub const kCMTimeCodeFormatType_TimeCode32: CMTimeCodeFormatType = 0x746d6364;
/// 64-bit time code sample.
pub const kCMTimeCodeFormatType_TimeCode64: CMTimeCodeFormatType = 0x74633634;
/// 32-bit counter-mode sample.
pub const kCMTimeCodeFormatType_Counter32: CMTimeCodeFormatType = 0x636e3332;
/// 64-bit counter-mode sample.
pub const kCMTimeCodeFormatType_Counter64: CMTimeCodeFormatType = 0x636e3634;

/// A type that describes timecodes are to be rendered in drop-frame format.
pub const kCMTimeCodeFlag_DropFrame: u32 = 1 << 0;
/// A type that describes timecode rolls over every 24 hours.
pub const kCMTimeCodeFlag_24HourMax: u32 = 1 << 1;
/// A type that describes that the track may contain negative timecodes.
pub const kCMTimeCodeFlag_NegTimesOK: u32 = 1 << 2;

extern "C-unwind" {
    /// Creates a format description for time code media.
    ///
    /// Parameters:
    /// - allocator: Allocator to be used for creating the `CMFormatDescription` object.
    ///
    /// - timeCodeFormatType: One of the [`CMTimeCodeFormatType`](https://developer.apple.com/documentation/coremedia/cmtimecodeformattype).
    ///
    /// - frameDuration: Duration of each frame (e.g. `100/2997`).
    ///
    /// - frameQuanta: Frames/sec for timecode (e.g. 30) OR frames/tick for counter mode.
    ///
    /// - flags: `kCMTimeCodeFlag_DropFrame`, `kCMTimeCodeFlag_24HourMax`, `kCMTimeCodeFlag_NegTimesOK`. For possible values, see [Video Profile Constants](https://developer.apple.com/documentation/coremedia/video-profile-constants).
    ///
    /// - extensions: Keys are always `CFStrings`. Values are always property list objects (i.e. `CFData`). May be NULL.
    ///
    /// - formatDescriptionOut: Receives the newly-created `CMFormatDescription`.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. Returns `noErr` if successful.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The caller owns the returned `CMFormatDescription`, and must release it when done with it. All input parameters are copied (the extensions are deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    ///
    /// Creates a format description for a timecode media.
    ///
    /// The caller owns the returned CMFormatDescription, and must release it when done with it. All input parameters
    /// are copied (the extensions are deep-copied).  The caller can deallocate them or re-use them after making this call.
    ///
    /// # Safety
    ///
    /// - `extensions` generic must be of the correct type.
    /// - `extensions` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    #[cfg(feature = "CMTime")]
    pub fn CMTimeCodeFormatDescriptionCreate(
        allocator: Option<&CFAllocator>,
        time_code_format_type: CMTimeCodeFormatType,
        frame_duration: CMTime,
        frame_quanta: u32,
        flags: u32,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMTimeCodeFormatDescription>,
    ) -> OSStatus;
}

#[cfg(feature = "CMTime")]
impl CMTime {
    /// Returns the duration of each frame.
    ///
    /// Parameters:
    /// - timeCodeFormatDescription: `CMTimeCodeFormatDescription` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// The duration of each frame represented in `CMTime` format.
    ///
    ///
    /// Returns the duration of each frame (eg. 100/2997)
    #[doc(alias = "CMTimeCodeFormatDescriptionGetFrameDuration")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn code_format_description_get_frame_duration(
        time_code_format_description: &CMTimeCodeFormatDescription,
    ) -> CMTime {
        extern "C-unwind" {
            fn CMTimeCodeFormatDescriptionGetFrameDuration(
                time_code_format_description: &CMTimeCodeFormatDescription,
            ) -> CMTime;
        }
        unsafe { CMTimeCodeFormatDescriptionGetFrameDuration(time_code_format_description) }
    }
}

extern "C-unwind" {
    /// Returns the frames per second for a time code, or frames per tick in counter mode.
    ///
    /// Parameters:
    /// - timeCodeFormatDescription: [`CMTimeCodeFormatDescriptionRef`](https://developer.apple.com/documentation/coremedia/cmtimecodeformatdescription) being interrogated.
    ///
    /// Returns the frames/sec for timecode (eg. 30) OR frames/tick for counter mode
    pub fn CMTimeCodeFormatDescriptionGetFrameQuanta(
        time_code_format_description: &CMTimeCodeFormatDescription,
    ) -> u32;
}

extern "C-unwind" {
    /// Returns time code flags.
    ///
    /// Parameters:
    /// - desc: `CMTimeCodeFormatDescription` being interrogated.
    ///
    ///
    /// ## Discussion
    ///
    /// For possible time code flags see [Time Code Flags](https://developer.apple.com/documentation/coremedia/time-code-flags).
    ///
    ///
    /// Returns the flags for kCMTimeCodeFlag_DropFrame, kCMTimeCodeFlag_24HourMax, kCMTimeCodeFlag_NegTimesOK
    pub fn CMTimeCodeFormatDescriptionGetTimeCodeFlags(desc: &CMTimeCodeFormatDescription) -> u32;
}

extern "C" {
    /// An extension that describes the source reference name.
    pub static kCMTimeCodeFormatDescriptionExtension_SourceReferenceName: &'static CFString;
}

extern "C" {
    /// A key that describes the value.
    pub static kCMTimeCodeFormatDescriptionKey_Value: &'static CFString;
}

extern "C" {
    /// A key that describes the language code.
    pub static kCMTimeCodeFormatDescriptionKey_LangCode: &'static CFString;
}

/// A type you use to interact with metadata format descriptions.
/// SYnonym type used for manipulating Metadata media CMFormatDescriptions
#[doc(alias = "CMMetadataFormatDescriptionRef")]
pub type CMMetadataFormatDescription = CMFormatDescription;

/// A metadata format type.
/// The subtypes of Metadata media type.
pub type CMMetadataFormatType = FourCharCode;

/// SHOUTCast format.
pub const kCMMetadataFormatType_ICY: CMMetadataFormatType = 0x69637920;
/// ID3 format.
pub const kCMMetadataFormatType_ID3: CMMetadataFormatType = 0x69643320;
/// CoreMedia boxed format.
pub const kCMMetadataFormatType_Boxed: CMMetadataFormatType = 0x6d656278;
pub const kCMMetadataFormatType_EMSG: CMMetadataFormatType = 0x656d7367;

extern "C" {
    pub static kCMFormatDescriptionExtensionKey_MetadataKeyTable: &'static CFString;
}

extern "C" {
    /// A key that identifies the namespace.
    pub static kCMMetadataFormatDescriptionKey_Namespace: &'static CFString;
}

extern "C" {
    /// A key that identifies the value.
    pub static kCMMetadataFormatDescriptionKey_Value: &'static CFString;
}

extern "C" {
    /// A key that identifies the local identifier.
    pub static kCMMetadataFormatDescriptionKey_LocalID: &'static CFString;
}

extern "C" {
    /// A key that identifies the data type.
    pub static kCMMetadataFormatDescriptionKey_DataType: &'static CFString;
}

extern "C" {
    /// A key that identifies the data type namespace.
    pub static kCMMetadataFormatDescriptionKey_DataTypeNamespace: &'static CFString;
}

extern "C" {
    /// A key that identifies the conforming data types.
    pub static kCMMetadataFormatDescriptionKey_ConformingDataTypes: &'static CFString;
}

extern "C" {
    /// A key that identifies the language tag.
    pub static kCMMetadataFormatDescriptionKey_LanguageTag: &'static CFString;
}

extern "C" {
    /// A key that identifies the structural dependency.
    pub static kCMMetadataFormatDescriptionKey_StructuralDependency: &'static CFString;
}

extern "C" {
    /// A key that identifies setup data.
    pub static kCMMetadataFormatDescriptionKey_SetupData: &'static CFString;
}

extern "C" {
    /// A specification key that identifies the depencency isn’t valid.
    pub static kCMMetadataFormatDescription_StructuralDependencyKey_DependencyIsInvalidFlag:
        &'static CFString;
}

extern "C" {
    /// A specification key that identifies the identifier.
    pub static kCMMetadataFormatDescriptionMetadataSpecificationKey_Identifier: &'static CFString;
}

extern "C" {
    /// A specification key that identifies the data type.
    pub static kCMMetadataFormatDescriptionMetadataSpecificationKey_DataType: &'static CFString;
}

extern "C" {
    /// A specification key that identifies the extended language tag.
    pub static kCMMetadataFormatDescriptionMetadataSpecificationKey_ExtendedLanguageTag:
        &'static CFString;
}

extern "C" {
    /// A specification key that identifies dependencies.
    pub static kCMMetadataFormatDescriptionMetadataSpecificationKey_StructuralDependency:
        &'static CFString;
}

extern "C" {
    /// A specification key that identifies the setup data.
    pub static kCMMetadataFormatDescriptionMetadataSpecificationKey_SetupData: &'static CFString;
}

extern "C-unwind" {
    /// Creates a metadata format description with the metadata keys you specify.
    ///
    /// Parameters:
    /// - allocator: `CFAllocator` to be used. Pass `NULL` or `kCFAllocatorDefault` to use the default allocator.
    ///
    /// - metadataType: The type of metadata (kCMMetadataFormatType_Boxed).
    ///
    /// - keys: Array of metadata keys. Each key is a dictionary of key properties. The required properties are:
    ///
    /// - `kCMMetadataFormatDescriptionKey_Namespace`
    ///
    /// - `kCMMetadataFormatDescriptionKey_Value`
    ///
    /// - `kCMMetadataFormatDescriptionKey_LocalID`
    ///
    /// - formatDescriptionOut: Returns newly created metadata `CMFormatDescription`.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. Returns `noErr` if successful.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `keys` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    pub fn CMMetadataFormatDescriptionCreateWithKeys(
        allocator: Option<&CFAllocator>,
        metadata_type: CMMetadataFormatType,
        keys: Option<&CFArray>,
        format_description_out: NonNull<*const CMMetadataFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a metadata format description with the specifications you specify.
    ///
    /// Parameters:
    /// - allocator: CFAllocator to be used. kCFAllocatorDefault if you don’t care.
    ///
    /// - metadataType: Currently the type must be kCMMetadataFormatType_Boxed.
    ///
    /// - metadataSpecifications: An array of dictionaries, each dictionary supplies a metadata identifier, a datatype, and an optional language tag.
    ///
    /// - formatDescriptionOut: Returned newly created metadata CMFormatDescription
    ///
    ///
    /// # Safety
    ///
    /// - `metadata_specifications` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    pub fn CMMetadataFormatDescriptionCreateWithMetadataSpecifications(
        allocator: Option<&CFAllocator>,
        metadata_type: CMMetadataFormatType,
        metadata_specifications: &CFArray,
        format_description_out: NonNull<*const CMMetadataFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a metadata format description by extending an existing description with the values you specify.
    ///
    /// Parameters:
    /// - allocator: CFAllocator to be used. kCFAllocatorDefault if you don’t care.
    ///
    /// - sourceDescription: Source metadata format description being extended
    ///
    /// - metadataSpecifications: An array of dictionaries, each dictionary supplies a metadata identifier, a datatype, and an optional language tag.
    ///
    /// - formatDescriptionOut: Returned newly created metadata CMFormatDescription
    ///
    ///
    /// # Safety
    ///
    /// - `metadata_specifications` generic must be of the correct type.
    /// - `format_description_out` must be a valid pointer.
    pub fn CMMetadataFormatDescriptionCreateWithMetadataFormatDescriptionAndMetadataSpecifications(
        allocator: Option<&CFAllocator>,
        source_description: &CMMetadataFormatDescription,
        metadata_specifications: &CFArray,
        format_description_out: NonNull<*const CMMetadataFormatDescription>,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Creates a metadata format description object by merging with another description.
    ///
    /// Parameters:
    /// - allocator: Allocator to use for allocating the CMBlockBuffer object. May be NULL.
    ///
    /// - sourceDescription: The metadata format description to merge.
    ///
    /// - otherSourceDescription: Another metadata format description to merged
    ///
    /// - formatDescriptionOut: Returns newly created metadata `CMFormatDescription`.
    ///
    ///
    /// # Safety
    ///
    /// `format_description_out` must be a valid pointer.
    pub fn CMMetadataFormatDescriptionCreateByMergingMetadataFormatDescriptions(
        allocator: Option<&CFAllocator>,
        source_description: &CMMetadataFormatDescription,
        other_source_description: &CMMetadataFormatDescription,
        format_description_out: NonNull<*const CMMetadataFormatDescription>,
    ) -> OSStatus;
}

/// Returns the key for the local identifier.
///
/// Parameters:
/// - desc: Format description being interrogated.
///
/// - localKeyID: Local Id identifying the key associated with the metadata description.
///
///
/// ## Return Value
///
/// A new dictionary containing the key specified by the localKeyID, or `NULL` if there is no key corresponding to the localKeyID.
///
///
///
/// ## Discussion
///
/// When writing a metadata track to a QuickTime movie, you can store many different kinds of metadata in one track. The format description for the track describes all of the kinds of metadata that might be present in that track.  And each kind of metadata has an id assigned to it which is unique from the others in the group.  So when individual samples of metadata are written (or read back later), they don’t contain their full description, instead they just contain the unique id (called the local id) that was assigned to them.  For instance, GPS might be local id 1, and face data might be local id 2. When someone pulls such a sample from a movie and wants to do a reverse lookup, they can call `CMMetadataFormatDescriptionGetKeyWithLocalID`, using the local id they’ve got, to get the Key associated with this metadata.
///
///
#[inline]
pub unsafe extern "C-unwind" fn CMMetadataFormatDescriptionGetKeyWithLocalID(
    desc: &CMMetadataFormatDescription,
    local_key_id: OSType,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CMMetadataFormatDescriptionGetKeyWithLocalID(
            desc: &CMMetadataFormatDescription,
            local_key_id: OSType,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CMMetadataFormatDescriptionGetKeyWithLocalID(desc, local_key_id) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

/// Returns an array of metadata identifiers from a metadata format description.
///
/// Parameters:
/// - desc: The format description to inspect.
///
#[inline]
pub unsafe extern "C-unwind" fn CMMetadataFormatDescriptionGetIdentifiers(
    desc: &CMMetadataFormatDescription,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CMMetadataFormatDescriptionGetIdentifiers(
            desc: &CMMetadataFormatDescription,
        ) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CMMetadataFormatDescriptionGetIdentifiers(desc) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMFormatDescription::create`"]
    pub fn CMFormatDescriptionCreate(
        allocator: Option<&CFAllocator>,
        media_type: CMMediaType,
        media_sub_type: FourCharCode,
        extensions: Option<&CFDictionary>,
        format_description_out: NonNull<*const CMFormatDescription>,
    ) -> OSStatus;
}

#[deprecated = "renamed to `CMFormatDescription::equal`"]
#[inline]
pub unsafe extern "C-unwind" fn CMFormatDescriptionEqual(
    format_description: Option<&CMFormatDescription>,
    other_format_description: Option<&CMFormatDescription>,
) -> bool {
    extern "C-unwind" {
        fn CMFormatDescriptionEqual(
            format_description: Option<&CMFormatDescription>,
            other_format_description: Option<&CMFormatDescription>,
        ) -> Boolean;
    }
    let ret = unsafe { CMFormatDescriptionEqual(format_description, other_format_description) };
    ret != 0
}

#[deprecated = "renamed to `CMFormatDescription::equal_ignoring_extension_keys`"]
#[inline]
pub unsafe extern "C-unwind" fn CMFormatDescriptionEqualIgnoringExtensionKeys(
    format_description: Option<&CMFormatDescription>,
    other_format_description: Option<&CMFormatDescription>,
    format_description_extension_keys_to_ignore: Option<&CFType>,
    sample_description_extension_atom_keys_to_ignore: Option<&CFType>,
) -> bool {
    extern "C-unwind" {
        fn CMFormatDescriptionEqualIgnoringExtensionKeys(
            format_description: Option<&CMFormatDescription>,
            other_format_description: Option<&CMFormatDescription>,
            format_description_extension_keys_to_ignore: Option<&CFType>,
            sample_description_extension_atom_keys_to_ignore: Option<&CFType>,
        ) -> Boolean;
    }
    let ret = unsafe {
        CMFormatDescriptionEqualIgnoringExtensionKeys(
            format_description,
            other_format_description,
            format_description_extension_keys_to_ignore,
            sample_description_extension_atom_keys_to_ignore,
        )
    };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMFormatDescription::media_type`"]
    pub fn CMFormatDescriptionGetMediaType(desc: &CMFormatDescription) -> CMMediaType;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMFormatDescription::media_sub_type`"]
    pub fn CMFormatDescriptionGetMediaSubType(desc: &CMFormatDescription) -> FourCharCode;
}

#[deprecated = "renamed to `CMFormatDescription::extensions`"]
#[inline]
pub unsafe extern "C-unwind" fn CMFormatDescriptionGetExtensions(
    desc: &CMFormatDescription,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CMFormatDescriptionGetExtensions(
            desc: &CMFormatDescription,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CMFormatDescriptionGetExtensions(desc) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CMFormatDescription::extension`"]
#[inline]
pub unsafe extern "C-unwind" fn CMFormatDescriptionGetExtension(
    desc: &CMFormatDescription,
    extension_key: &CFString,
) -> Option<CFRetained<CFPropertyList>> {
    extern "C-unwind" {
        fn CMFormatDescriptionGetExtension(
            desc: &CMFormatDescription,
            extension_key: &CFString,
        ) -> Option<NonNull<CFPropertyList>>;
    }
    let ret = unsafe { CMFormatDescriptionGetExtension(desc, extension_key) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTime::code_format_description_get_frame_duration`"]
    pub fn CMTimeCodeFormatDescriptionGetFrameDuration(
        time_code_format_description: &CMTimeCodeFormatDescription,
    ) -> CMTime;
}
