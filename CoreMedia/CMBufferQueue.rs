//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// The system failed to allocate memory.
pub const kCMBufferQueueError_AllocationFailed: OSStatus = -12760;
/// You failed to provide a valid value for a required parameter.
pub const kCMBufferQueueError_RequiredParameterMissing: OSStatus = -12761;
/// The format of a callbacks structure isn’t correct.
///
/// ## Discussion
///
/// Indicates that the [`version`](https://developer.apple.com/documentation/coremedia/cmbuffercallbacks/version) isn’t `0`, or getDuration is NULL.
///
///
pub const kCMBufferQueueError_InvalidCMBufferCallbacksStruct: OSStatus = -12762;
/// You attempted to enqueue a buffer on a queue that disallows it.
pub const kCMBufferQueueError_EnqueueAfterEndOfData: OSStatus = -12763;
/// You attempted to enqueue a buffer on a queue that’s full.
pub const kCMBufferQueueError_QueueIsFull: OSStatus = -12764;
/// You specified an invalid trigger duration.
///
/// ## Discussion
///
/// The trigger duration must be numeric, and epoch must be zero (non-zero epoch is only for timestamps, not durations).
///
///
pub const kCMBufferQueueError_BadTriggerDuration: OSStatus = -12765;
/// A trigger callback attempted to modify a queue.
pub const kCMBufferQueueError_CannotModifyQueueFromTriggerCallback: OSStatus = -12766;
/// You specified an invalid trigger condition.
///
/// ## Discussion
///
/// Indicates that a trigger condition isn’t a value from the CMBufferQueueTriggerCondition enum, or the trigger condition isn’t supported by a buffer queue.
///
///
pub const kCMBufferQueueError_InvalidTriggerCondition: OSStatus = -12767;
/// You specified a trigger token that isn’t a trigger currently associated with this queue.
pub const kCMBufferQueueError_InvalidTriggerToken: OSStatus = -12768;
/// A buffer validation callback rejected the buffer.
pub const kCMBufferQueueError_InvalidBuffer: OSStatus = -12769;

/// A reference to a buffer queue instance.
///
/// ## Overview
///
/// A `CMBufferQueue` is a queue of timed buffers backed by a Core Foundation object.
///
///
/// A reference to a CMBufferQueue, a CF object that implements a queue of timed buffers.
#[doc(alias = "CMBufferQueueRef")]
#[repr(C)]
pub struct CMBufferQueue {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CMBufferQueue {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"opaqueCMBufferQueue"> for CMBufferQueue {}
);

/// A reference to a buffer object.
///
/// ## Discussion
///
/// A `CMBuffer` can be an instance of any Core Foundation type, as long as a `getDuration` callback can be provided. Commonly used types are `CMSampleBuffer` and `CVPixelBuffer`.
///
///
/// A reference to a CMBuffer.
///
/// A CMBuffer can be any CFTypeRef, as long as a getDuration callback can be provided.  Commonly used
/// types are CMSampleBufferRef and CVPixelBufferRef.
#[doc(alias = "CMBufferRef")]
pub type CMBuffer = CFType;

/// Callback that returns a `CMTime` from a `CMBuffer`.
///
/// ## Discussion
///
/// There are three callbacks of this type that can be provided to `Creating Buffer Queues`: getDuration (required), getDecodeTimeStamp (optional), and getPresentationTimeStamp (optional).
///
/// ### Callback Parameters
///
/// - buf: The buffer being interrogated.
///
/// - refcon: The contextual data from the client (which may be `NULL`).
///
///
/// Client callback that returns a CMTime from a CMBufferRef
///
/// There are three callbacks of this type that can be provided to CMBufferQueueCreate: getDuration (required),
/// getDecodeTimeStamp (optional), and getPresentationTimeStamp (optional).
#[cfg(feature = "CMTime")]
pub type CMBufferGetTimeCallback =
    Option<unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> CMTime>;

/// Client block that returns a CMTime from a CMBufferRef
///
/// There are three blocks of this type that can be provided to CMBufferQueueCreate: getDuration (required),
/// getDecodeTimeStamp (optional), and getPresentationTimeStamp (optional).
#[cfg(all(feature = "CMTime", feature = "block2"))]
pub type CMBufferGetTimeHandler = *mut block2::DynBlock<dyn Fn(NonNull<CMBuffer>) -> CMTime>;

/// Callback that returns a Boolean value from a `CMBuffer`.
///
/// ## Discussion
///
/// There is one callback of this type that can be provided to `Creating Buffer Queues`: `isDataReady` (optional).
///
/// ### Callback Parameters
///
/// - buf: The buffer being interrogated.
///
/// - refcon: The contextual data from the client (which may be `NULL`).
///
///
/// Client callback that returns a Boolean from a CMBufferRef
///
/// There is one callback of this type that can be provided to CMBufferQueueCreate: isDataReady (optional).
pub type CMBufferGetBooleanCallback =
    Option<unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> Boolean>;

/// Client block that returns a Boolean from a CMBufferRef
///
/// There is one callback of this type that can be provided to CMBufferQueueCreate: isDataReady (optional).
#[cfg(feature = "block2")]
pub type CMBufferGetBooleanHandler = *mut block2::DynBlock<dyn Fn(NonNull<CMBuffer>) -> Boolean>;

/// Callback that compares one `CMBuffer` with another.
///
/// ## Discussion
///
/// You can use a `CFComparatorFunction` as a callback.
///
/// ### Callback parameters
///
/// - buf1: The first buffer being compared.
///
/// - buf2: The second buffer being compared.
///
/// - refcon: The contextual data from the client (which may be `NULL`).
///
///
/// Client callback that compares one CMBufferRef with another.
///
/// Note that a CFComparatorFunction can be used here.
pub type CMBufferCompareCallback = Option<
    unsafe extern "C-unwind" fn(
        NonNull<CMBuffer>,
        NonNull<CMBuffer>,
        *mut c_void,
    ) -> CFComparisonResult,
>;

/// Client block that compares one CMBufferRef with another.
#[cfg(feature = "block2")]
pub type CMBufferCompareHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<CMBuffer>, NonNull<CMBuffer>) -> CFComparisonResult>;

/// A client callback that returns a size.
///
/// Parameters:
/// - buf: The buffer being interrogated.
///
/// - refcon: The client refcon. Can be `NULL`.
///
/// Client callback that returns a size_t from a CMBufferRef
///
/// There is one callback of this type that can be provided to CMBufferQueueCreate: getTotalSize.
pub type CMBufferGetSizeCallback =
    Option<unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> usize>;

/// Client block that returns a size_t from a CMBufferRef
///
/// There is one block of this type that can be provided to CMBufferQueueCreate: getTotalSize.
#[cfg(feature = "block2")]
pub type CMBufferGetSizeHandler = *mut block2::DynBlock<dyn Fn(NonNull<CMBuffer>) -> usize>;

/// A structure that stores the callbacks that perform buffer operations.
///
/// ## Overview
///
/// With the exception of `isDataReady`, all these callbacks must always return the same result for the same arguments.
///
/// A buffer’s duration, timestamps, or position relative to other buffers must not appear to change while it is in the queue. Once `isDataReady` has returned true for a given `CMBuffer`, it must always return true for that `CMBuffer`.
///
/// Durations must always be positive.
///
///
/// Callbacks provided to CMBufferQueueCreate, for use by the queue in interrogating the buffers that it will see.
///
/// With the exception of isDataReady, all these callbacks must always return the same result for the same arguments.
/// A buffer's duration, timestamps, or position relative to other buffers must not appear to change while it is in
/// the queue.  Once isDataReady has returned true for a given CMBuffer, it must always return true for that
/// CMBuffer.  Durations must always be positive.
#[cfg(feature = "CMTime")]
#[repr(C, packed(4))]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CMBufferCallbacks {
    /// Must be 0 or 1.
    pub version: u32,
    /// Client refcon to be passed to all callbacks (can be NULL,
    /// if the callbacks don't require it).
    pub refcon: *mut c_void,
    /// This callback is called from CMBufferQueueGetFirstDecodeTimeStamp (once),
    /// and from CMBufferQueueGetMinDecodeTimeStamp (multiple times).  It should
    /// return the decode timestamp of the buffer.  If there are multiple samples
    /// in the buffer, this callback should return the minimum decode timestamp
    /// in the buffer. Can be NULL (CMBufferQueueGetFirstDecodeTimeStamp and
    /// CMBufferQueueGetMinDecodeTimeStamp will return kCMTimeInvalid).
    pub getDecodeTimeStamp: CMBufferGetTimeCallback,
    /// This callback is called from CMBufferQueueGetFirstPresentationTimeStamp
    /// (once) and from CMBufferQueueGetMinPresentationTimeStamp (multiple times).
    /// It should return the presentation timestamp of the buffer.  If there are
    /// multiple samples in the buffer, this callback should return the minimum
    /// presentation timestamp in the buffer. Can be NULL
    /// (CMBufferQueueGetFirstPresentationTimeStamp and
    /// CMBufferQueueGetMinPresentationTimeStamp will return kCMTimeInvalid).
    pub getPresentationTimeStamp: CMBufferGetTimeCallback,
    /// This callback is called (once) during enqueue and dequeue operations to
    /// update the total duration of the queue.  Must not be NULL.
    pub getDuration: CMBufferGetTimeCallback,
    /// This callback is called from CMBufferQueueDequeueIfDataReadyAndRetain, to
    /// ask if the buffer that is about to be dequeued is ready.  Can be NULL
    /// (data will be assumed to be ready).
    pub isDataReady: CMBufferGetBooleanCallback,
    /// This callback is called (multiple times) from CMBufferQueueEnqueue, to
    /// perform an insertion sort. Can be NULL (queue will be FIFO).
    pub compare: CMBufferCompareCallback,
    /// If triggers of type kCMBufferQueueTrigger_WhenDataBecomesReady are installed,
    /// the queue will listen for this notification on the head buffer.
    /// Can be NULL (then the queue won't listen for it).
    pub dataBecameReadyNotification: *const CFString,
    /// This callback is called (once) during enqueue and dequeue operation to
    /// update the total size of the queue. Can be NULL.  Ignored if version
    /// <
    /// 1.
    pub getSize: CMBufferGetSizeCallback,
}

#[cfg(all(feature = "CMTime", feature = "objc2"))]
unsafe impl Encode for CMBufferCallbacks {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <*mut c_void>::ENCODING,
            <CMBufferGetTimeCallback>::ENCODING,
            <CMBufferGetTimeCallback>::ENCODING,
            <CMBufferGetTimeCallback>::ENCODING,
            <CMBufferGetBooleanCallback>::ENCODING,
            <CMBufferCompareCallback>::ENCODING,
            <*const CFString>::ENCODING,
            <CMBufferGetSizeCallback>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CMTime", feature = "objc2"))]
unsafe impl RefEncode for CMBufferCallbacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A structure that stores the handlers that perform buffer operations.
#[cfg(all(feature = "CMTime", feature = "block2"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CMBufferHandlers {
    /// Must be 1.
    pub version: usize,
    /// This block is called from CMBufferQueueGetFirstDecodeTimeStamp (once),
    /// and from CMBufferQueueGetMinDecodeTimeStamp (multiple times).  It should
    /// return the decode timestamp of the buffer.  If there are multiple samples
    /// in the buffer, this block should return the minimum decode timestamp
    /// in the buffer. Can be NULL (CMBufferQueueGetFirstDecodeTimeStamp and
    /// CMBufferQueueGetMinDecodeTimeStamp will return kCMTimeInvalid).
    pub getDecodeTimeStamp: CMBufferGetTimeHandler,
    /// This block is called from CMBufferQueueGetFirstPresentationTimeStamp
    /// (once) and from CMBufferQueueGetMinPresentationTimeStamp (multiple times).
    /// It should return the presentation timestamp of the buffer.  If there are
    /// multiple samples in the buffer, this block should return the minimum
    /// presentation timestamp in the buffer. Can be NULL
    /// (CMBufferQueueGetFirstPresentationTimeStamp and
    /// CMBufferQueueGetMinPresentationTimeStamp will return kCMTimeInvalid).
    pub getPresentationTimeStamp: CMBufferGetTimeHandler,
    /// This block is called (once) during enqueue and dequeue operations to
    /// update the total duration of the queue.  Must not be NULL.
    pub getDuration: CMBufferGetTimeHandler,
    /// This block is called from CMBufferQueueDequeueIfDataReadyAndRetain, to
    /// ask if the buffer that is about to be dequeued is ready.  Can be NULL
    /// (data will be assumed to be ready).
    pub isDataReady: CMBufferGetBooleanHandler,
    /// This block is called (multiple times) from CMBufferQueueEnqueue, to
    /// perform an insertion sort. Can be NULL (queue will be FIFO).
    pub compare: CMBufferCompareHandler,
    /// If triggers of type kCMBufferQueueTrigger_WhenDataBecomesReady are installed,
    /// the queue will listen for this notification on the head buffer.
    /// Can be NULL (then the queue won't listen for it).
    pub dataBecameReadyNotification: *const CFString,
    /// This block is called (once) during enqueue and dequeue operation to
    /// update the total size of the queue. Can be NULL.
    pub getSize: CMBufferGetSizeHandler,
}

#[cfg(all(feature = "CMTime", feature = "block2", feature = "objc2"))]
unsafe impl Encode for CMBufferHandlers {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <usize>::ENCODING,
            <CMBufferGetTimeHandler>::ENCODING,
            <CMBufferGetTimeHandler>::ENCODING,
            <CMBufferGetTimeHandler>::ENCODING,
            <CMBufferGetBooleanHandler>::ENCODING,
            <CMBufferCompareHandler>::ENCODING,
            <*const CFString>::ENCODING,
            <CMBufferGetSizeHandler>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CMTime", feature = "block2", feature = "objc2"))]
unsafe impl RefEncode for CMBufferHandlers {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CMBufferQueue {
    /// Returns a pointer to a callback structure for unsorted sample buffers.
    /// Returns a pointer to a callback struct for unsorted CMSampleBuffers, provided as a convenience.
    #[doc(alias = "CMBufferQueueGetCallbacksForUnsortedSampleBuffers")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn callbacks_for_unsorted_sample_buffers() -> NonNull<CMBufferCallbacks> {
        extern "C-unwind" {
            fn CMBufferQueueGetCallbacksForUnsortedSampleBuffers(
            ) -> Option<NonNull<CMBufferCallbacks>>;
        }
        let ret = unsafe { CMBufferQueueGetCallbacksForUnsortedSampleBuffers() };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns a pointer to a structure that contains callbacks to sort sample buffers by output presentation timestamp.
    /// Returns a pointer to a callback struct for CMSampleBuffers sorted by output presentation timestamp, provided as a convenience.
    #[doc(alias = "CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn callbacks_for_sample_buffers_sorted_by_output_pts() -> NonNull<CMBufferCallbacks>
    {
        extern "C-unwind" {
            fn CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(
            ) -> Option<NonNull<CMBufferCallbacks>>;
        }
        let ret = unsafe { CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS() };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Creates a buffer queue with callbacks to inspect buffers.
    ///
    /// Parameters:
    /// - allocator: The allocator to use for allocating the `CMBufferQueue` object. Pass `kCFAllocatorDefault` to use the default allocator.
    ///
    /// - capacity: Maximum number of buffers in the queue.  Pass 0 to create a queue that will grow as needed.
    ///
    /// - callbacks: Callbacks the queue should use to interrogate the buffer objects.  This struct is copied internally, so the client can pass a pointer to a temporary struct on the stack.
    ///
    /// - queueOut: On Output, the newly created `CMBufferQueue`.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// On return, the caller owns the returned `CMBufferQueue`, and must release it when done with it.
    ///
    ///
    /// Creates a CMBufferQueue object.
    ///
    /// On return, the caller owns the returned CMBufferQueue, and must release it when done with it.
    ///
    /// # Safety
    ///
    /// - `callbacks` must be a valid pointer.
    /// - `queue_out` must be a valid pointer.
    #[doc(alias = "CMBufferQueueCreate")]
    #[cfg(all(feature = "CMBase", feature = "CMTime"))]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        capacity: CMItemCount,
        callbacks: NonNull<CMBufferCallbacks>,
        queue_out: NonNull<*mut CMBufferQueue>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueCreate(
                allocator: Option<&CFAllocator>,
                capacity: CMItemCount,
                callbacks: NonNull<CMBufferCallbacks>,
                queue_out: NonNull<*mut CMBufferQueue>,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueCreate(allocator, capacity, callbacks, queue_out) }
    }

    /// Creates a buffer queue with handlers to inspect buffers.
    /// Creates a CMBufferQueue object.
    ///
    /// On return, the caller owns the returned CMBufferQueue, and must release it when done with it.
    ///
    /// # Safety
    ///
    /// - `handlers` must be a valid pointer.
    /// - `queue_out` must be a valid pointer.
    #[doc(alias = "CMBufferQueueCreateWithHandlers")]
    #[cfg(all(feature = "CMBase", feature = "CMTime", feature = "block2"))]
    #[inline]
    pub unsafe fn create_with_handlers(
        allocator: Option<&CFAllocator>,
        capacity: CMItemCount,
        handlers: NonNull<CMBufferHandlers>,
        queue_out: NonNull<*mut CMBufferQueue>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueCreateWithHandlers(
                allocator: Option<&CFAllocator>,
                capacity: CMItemCount,
                handlers: NonNull<CMBufferHandlers>,
                queue_out: NonNull<*mut CMBufferQueue>,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueCreateWithHandlers(allocator, capacity, handlers, queue_out) }
    }
}

unsafe impl ConcreteType for CMBufferQueue {
    /// Returns the type identifier of buffer queue objects.
    ///
    /// ## Return Value
    ///
    /// CFTypeID of `CMBufferQueue` objects.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// You can check if a `CFTypeRef` object is actually a `CMBufferQueue` by comparing [`CFGetTypeID`](https://developer.apple.com/documentation/corefoundation/cfgettypeid(_:))(object) with [`CMBufferQueueGetTypeID`](https://developer.apple.com/documentation/coremedia/cmbufferqueuegettypeid())().
    ///
    ///
    /// Returns the CFTypeID of CMBufferQueue objects.
    ///
    /// You can check if a CFTypeRef object is actually a CMBufferQueue by comparing CFGetTypeID(object) with CMBufferQueueGetTypeID().
    ///
    /// Returns: CFTypeID of CMBufferQueue objects.
    #[doc(alias = "CMBufferQueueGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMBufferQueueGetTypeID() -> CFTypeID;
        }
        unsafe { CMBufferQueueGetTypeID() }
    }
}

impl CMBufferQueue {
    /// Enqueues a buffer onto a queue.
    ///
    /// Parameters:
    /// - queue: The `CMBufferQueue` on which to enqueue the buffer.
    ///
    /// - buf: The buffer to enqueue.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Result Codes`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The buffer is retained by the queue, so the client can safely release the buffer if it has no further use for it. If the compare callback is non-`NULL`, this API performs an insertion sort using that compare operation. If the validation callback is non-`NULL`, this API calls it; if it returns a nonzero `OSStatus`, the buffer will not be enqueued and this API will return the same error `OSStatus`.
    ///
    ///
    /// Enqueues a buffer onto a CMBufferQueue.
    ///
    /// The buffer is retained by the queue, so the client can safely release the buffer if it has no further use for it.
    /// If the compare callback is non-NULL, this API performs an insertion sort using that compare operation.
    /// If the validation callback is non-NULL, this API calls it; if it returns a nonzero OSStatus,
    /// the buffer will not be enqueued and this API will return the same error OSStatus.
    ///
    /// # Safety
    ///
    /// `buf` should be of the correct type.
    #[doc(alias = "CMBufferQueueEnqueue")]
    #[inline]
    pub unsafe fn enqueue(&self, buf: &CMBuffer) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueEnqueue(queue: &CMBufferQueue, buf: &CMBuffer) -> OSStatus;
        }
        unsafe { CMBufferQueueEnqueue(self, buf) }
    }

    /// Dequeues a buffer from a queue.
    ///
    /// Parameters:
    /// - queue: The `CMBufferQueue` from which to dequeue a buffer.
    ///
    ///
    /// ## Return Value
    ///
    /// The dequeued buffer.  Will be `NULL` if the queue is empty.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The buffer is released by the queue, but it is also retained for the client. Buffer ownership is thereby transferred from queue to client.  The client need not retain the buffer, but is responsible to release it when done with it.
    ///
    ///
    /// Dequeues a buffer from a CMBufferQueue.
    ///
    /// The buffer is released by the queue, but it is also retained for the client. Buffer ownership is thereby
    /// transferred from queue to client.  The client need not retain the buffer, but is responsible to release
    /// it when done with it.
    ///
    /// Returns: The dequeued buffer.  Will be NULL if the queue is empty.
    #[doc(alias = "CMBufferQueueDequeueAndRetain")]
    #[inline]
    pub unsafe fn dequeue_and_retain(&self) -> Option<CFRetained<CMBuffer>> {
        extern "C-unwind" {
            fn CMBufferQueueDequeueAndRetain(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
        }
        let ret = unsafe { CMBufferQueueDequeueAndRetain(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Dequeues a buffer from a queue, if it’s ready.
    ///
    /// Parameters:
    /// - queue: The `CMBufferQueue` from which to dequeue a buffer (if the buffer is ready).
    ///
    ///
    /// ## Return Value
    ///
    /// The dequeued buffer.  Will be `NULL` if the queue is empty, or if the buffer to be dequeued is not yet ready.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The buffer is released by the queue, but it is also retained for the client. Buffer ownership is thereby transferred from queue to client.  The client need not retain the buffer, but is responsible to release it when done with it.
    ///
    ///
    /// Dequeues a buffer from a CMBufferQueue if it is ready.
    ///
    /// The buffer is released by the queue, but it is also retained for the client. Buffer ownership is thereby
    /// transferred from queue to client.  The client need not retain the buffer, but is responsible to release
    /// it when done with it.
    ///
    /// Returns: The dequeued buffer.  Will be NULL if the queue is empty, or if the buffer to be dequeued is not yet ready.
    #[doc(alias = "CMBufferQueueDequeueIfDataReadyAndRetain")]
    #[inline]
    pub unsafe fn dequeue_if_data_ready_and_retain(&self) -> Option<CFRetained<CMBuffer>> {
        extern "C-unwind" {
            fn CMBufferQueueDequeueIfDataReadyAndRetain(
                queue: &CMBufferQueue,
            ) -> Option<NonNull<CMBuffer>>;
        }
        let ret = unsafe { CMBufferQueueDequeueIfDataReadyAndRetain(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves the next buffer from a queue, but doesn’t remove it.
    ///
    /// Parameters:
    /// - queue: The CMBufferQueue from which to retrieve a buffer.
    ///
    ///
    /// ## Return Value
    ///
    /// The buffer. Will be `NULL` if the queue is empty.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This follows Core Foundation “Get” semantics – it does not retain the returned buffer. Note that with non-FIFO queues it’s not guaranteed that the next dequeue will return this particular buffer (if an intervening Enqueue adds a buffer that will dequeue next).
    ///
    ///
    /// Retrieves the next-to-dequeue buffer from a CMBufferQueue but leaves it in the queue.
    ///
    /// This follows CF "Get" semantics -- it does not retain the returned buffer.
    /// Note that with non-FIFO queues it's not guaranteed that the next dequeue will return
    /// this particular buffer (if an intervening Enqueue adds a buffer that will dequeue next).
    /// This function is deprecated in favor of CMBufferQueueCopyHead() which returns a
    /// retained buffer. When adopting CMBufferQueueCopyHead(), existing CFRetain() call
    /// on the buffer returned from this function must be removed.
    ///
    /// Returns: The buffer.  Will be NULL if the queue is empty.
    #[doc(alias = "CMBufferQueueGetHead")]
    #[deprecated]
    #[inline]
    pub unsafe fn get_head(&self) -> Option<CFRetained<CMBuffer>> {
        extern "C-unwind" {
            fn CMBufferQueueGetHead(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
        }
        let ret = unsafe { CMBufferQueueGetHead(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Retrieves
    /// &
    /// retains the next-to-dequeue buffer from a CMBufferQueue but leaves it in the queue.
    ///
    /// This follows CF "Copy" semantics -- it retains the returned buffer.
    /// Note that with non-FIFO queues it's not guaranteed that the next dequeue will return
    /// this particular buffer (if an intervening Enqueue adds a buffer that will dequeue next).
    ///
    /// Returns: The retained buffer.  Will be NULL if the queue is empty.
    #[doc(alias = "CMBufferQueueCopyHead")]
    #[inline]
    pub unsafe fn head(&self) -> Option<CFRetained<CMBuffer>> {
        extern "C-unwind" {
            fn CMBufferQueueCopyHead(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
        }
        let ret = unsafe { CMBufferQueueCopyHead(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a Boolean value that indicates whether a buffer queue is empty.
    ///
    /// Parameters:
    /// - queue: The `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean indicating whether the `CMBufferQueue` is empty. If queue is `NULL`, true is returned.
    ///
    ///
    /// Returns whether or not a CMBufferQueue is empty.
    ///
    /// Returns: Whether or not the CMBufferQueue is empty. If queue is NULL, true is returned.
    #[doc(alias = "CMBufferQueueIsEmpty")]
    #[inline]
    pub unsafe fn is_empty(&self) -> bool {
        extern "C-unwind" {
            fn CMBufferQueueIsEmpty(queue: &CMBufferQueue) -> Boolean;
        }
        let ret = unsafe { CMBufferQueueIsEmpty(self) };
        ret != 0
    }

    /// Sets a marker to indicate this queue doesn’t allow enqueuing new buffers.
    ///
    /// Parameters:
    /// - queue: The `CMBufferQueue` being marked.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Result Codes`
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// All subsequent Enqueues will be rejected until [`CMBufferQueueReset`](https://developer.apple.com/documentation/coremedia/cmbufferqueuereset(_:)) is called. Subsequent Dequeues will succeed as long as the queue is not empty.
    ///
    ///
    /// Marks a CMBufferQueue with EOD.
    ///
    /// All subsequent Enqueues will be rejected until CMBufferQueueReset is called.
    /// Subsequent Dequeues will succeed as long as the queue is not empty.
    #[doc(alias = "CMBufferQueueMarkEndOfData")]
    #[inline]
    pub unsafe fn mark_end_of_data(&self) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueMarkEndOfData(queue: &CMBufferQueue) -> OSStatus;
        }
        unsafe { CMBufferQueueMarkEndOfData(self) }
    }

    /// Returns a Boolean value that indicates whether a buffer queue has its end-of-data marker set.
    ///
    /// Parameters:
    /// - queue: CMBufferQueue being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean indicating whether `CMBufferQueue` has been marked with `EndOfData`.
    ///
    ///
    /// Returns whether or not a CMBufferQueue has been marked with EOD.
    ///
    /// Returns: Whether or not the CMBufferQueue has been marked with EOD.
    /// If queue is NULL, true is returned (a NULL queue is considered to
    /// be empty, and permanently at EOD).
    #[doc(alias = "CMBufferQueueContainsEndOfData")]
    #[inline]
    pub unsafe fn contains_end_of_data(&self) -> bool {
        extern "C-unwind" {
            fn CMBufferQueueContainsEndOfData(queue: &CMBufferQueue) -> Boolean;
        }
        let ret = unsafe { CMBufferQueueContainsEndOfData(self) };
        ret != 0
    }

    /// Returns a Boolean value that indicates whether a buffer queue has its end-of-data marker set, and is now empty.
    ///
    /// Parameters:
    /// - queue: The `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean indicating whether the `CMBufferQueue` has been marked with EndOfData, and is now empty.If queue is `NULL`, true is returned (a NULL queue is considered to be empty, and permanently at EndOfData).
    ///
    ///
    /// Returns whether or not a CMBufferQueue has been marked with EOD, and is now empty.
    ///
    /// Returns: Whether or not the CMBufferQueue has been marked with EOD, and is now empty.
    /// If queue is NULL, true is returned (a NULL queue is considered to
    /// be empty, and permanently at EOD).
    #[doc(alias = "CMBufferQueueIsAtEndOfData")]
    #[inline]
    pub unsafe fn is_at_end_of_data(&self) -> bool {
        extern "C-unwind" {
            fn CMBufferQueueIsAtEndOfData(queue: &CMBufferQueue) -> Boolean;
        }
        let ret = unsafe { CMBufferQueueIsAtEndOfData(self) };
        ret != 0
    }

    /// Resets a buffer queue, which allows it to enqueue new buffers.
    ///
    /// Parameters:
    /// - queue: The `CMBufferQueue` being reset.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Result Codes`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// All buffers in the queue are released.  Triggers are not removed, however, and will be called appropriately as the queue duration goes to zero.
    ///
    ///
    /// Resets a CMBufferQueue. Empties the queue, and clears any EOD mark.
    ///
    /// All buffers in the queue are released.  Triggers are not removed, however,
    /// and will be called appropriately as the queue duration goes to zero.
    #[doc(alias = "CMBufferQueueReset")]
    #[inline]
    pub unsafe fn reset(&self) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueReset(queue: &CMBufferQueue) -> OSStatus;
        }
        unsafe { CMBufferQueueReset(self) }
    }

    /// A callback that invokes a function for every buffer in a queue and then resets the queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` being reset, that may contain multiple buffers.
    ///
    /// - callback: Function to be called for each buffer.  The callback should not make other calls to the buffer queue.
    ///
    /// - refcon: Reference constant to be passed to the callback function.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Result Codes`.
    ///
    ///
    /// Calls a function for every buffer in a queue, then resets the queue.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueResetWithCallback")]
    #[inline]
    pub unsafe fn reset_with_callback(
        &self,
        callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void),
        refcon: *mut c_void,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueResetWithCallback(
                queue: &CMBufferQueue,
                callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void),
                refcon: *mut c_void,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueResetWithCallback(self, callback, refcon) }
    }

    /// Gets the number of buffers in the queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the number of buffers in the `CMBufferQueue`.
    ///
    ///
    /// Gets the number of buffers in the queue.
    #[doc(alias = "CMBufferQueueGetBufferCount")]
    #[cfg(feature = "CMBase")]
    #[inline]
    pub unsafe fn buffer_count(&self) -> CMItemCount {
        extern "C-unwind" {
            fn CMBufferQueueGetBufferCount(queue: &CMBufferQueue) -> CMItemCount;
        }
        unsafe { CMBufferQueueGetBufferCount(self) }
    }

    /// Gets the duration of a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns sum of all the individual buffer durations in the `CMBufferQueue`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The duration of the `CMBufferQueue` is the sum of all the individual                buffer durations, as reported by the `getDuration` callback (provided to                `Creating Buffer Queues`).  If there are no buffers in the queue,                `kCMTimeZero` will be returned.
    ///
    ///
    /// Gets the duration of a CMBufferQueue.
    ///
    /// The duration of the CMBufferQueue is the sum of all the individual
    /// buffer durations, as reported by the getDuration callback (provided to
    /// CMBufferQueueCreate).  If there are no buffers in the queue,
    /// kCMTimeZero will be returned.
    #[doc(alias = "CMBufferQueueGetDuration")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn duration(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetDuration(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetDuration(self) }
    }

    /// Gets the earliest decode timestamp of a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// The earliest decode timestamp of the interrogated `CMBufferQueue`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The search for earliest decode timstamp is performed in this API.                If you know your queue is in decode order, `Accessing CMBufferQueue`                is a faster alternative.  If the `getDecodeTimeStamp` callback is                `NULL`, `kCMTimeInvalid` will be returned.
    ///
    ///
    /// Gets the earliest decode timestamp of a CMBufferQueue.
    ///
    /// The search for earliest decode timstamp is performed in this API.
    /// If you know your queue is in decode order, GetFirstDecodeTimeStamp
    /// is a faster alternative.  If the getDecodeTimeStamp callback is
    /// NULL, kCMTimeInvalid will be returned.
    #[doc(alias = "CMBufferQueueGetMinDecodeTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn min_decode_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetMinDecodeTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetMinDecodeTimeStamp(self) }
    }

    /// Gets the decode timestamp of the first buffer in a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// The decode timestamp of the first buffer in the interrogated `CMBufferQueue`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This API is is a faster alternative to [`CMBufferQueueIsEmpty`](https://developer.apple.com/documentation/coremedia/cmbufferqueueisempty(_:)),                but only gives the same answer if your queue is in decode order.                If the `getDecodeTimeStamp` callback is `NULL`, `kCMTimeInvalid` will                be returned.
    ///
    ///
    /// Gets the decode timestamp of the first buffer in a CMBufferQueue.
    ///
    /// This API is is a faster alternative to GetMinDecodeTimeStamp,
    /// but only gives the same answer if your queue is in decode order.
    /// If the getDecodeTimeStamp callback is NULL, kCMTimeInvalid will
    /// be returned.
    #[doc(alias = "CMBufferQueueGetFirstDecodeTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn first_decode_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetFirstDecodeTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetFirstDecodeTimeStamp(self) }
    }

    /// Gets the earliest presentation timestamp of a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// The earliest presentation timestamp of the interrogated `CMBufferQueue`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The search for earliest presentation timstamp is performed in                this API. If you know your queue is sorted by presentation time,                [`CMBufferQueueGetBufferCount`](https://developer.apple.com/documentation/coremedia/cmbufferqueuegetbuffercount(_:)) is a faster alternative. If the                `getPresentationTimeStamp` callback is `NULL`, kCMTimeInvalid will                be returned.
    ///
    ///
    /// Gets the earliest presentation timestamp of a CMBufferQueue.
    ///
    /// The search for earliest presentation timstamp is performed in
    /// this API. If you know your queue is sorted by presentation time,
    /// GetFirstPresentationTimeStamp is a faster alternative. If the
    /// getPresentationTimeStamp callback is NULL, kCMTimeInvalid will
    /// be returned.
    #[doc(alias = "CMBufferQueueGetMinPresentationTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn min_presentation_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetMinPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetMinPresentationTimeStamp(self) }
    }

    /// Gets the presentation timestamp of the first buffer in a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// The presentation timestamp of the first buffer in the interrogated `CMBufferQueue`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This API is is a faster alternative to [`CMBufferQueueTestTrigger`](https://developer.apple.com/documentation/coremedia/cmbufferqueuetesttrigger(_:triggertoken:)),                but only works if you know your queue is sorted by presentation                timestamp. If the `getPresentationTimeStamp` callback is `NULL`,                `kCMTimeInvalid` will be returned.
    ///
    ///
    /// Gets the presentation timestamp of the first buffer in a CMBufferQueue.
    ///
    /// This API is is a faster alternative to GetMinPresentationTimeStamp,
    /// but only works if you know your queue is sorted by presentation
    /// timestamp. If the getPresentationTimeStamp callback is NULL,
    /// kCMTimeInvalid will be returned.
    #[doc(alias = "CMBufferQueueGetFirstPresentationTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn first_presentation_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetFirstPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetFirstPresentationTimeStamp(self) }
    }

    /// Gets the greatest presentation timestamp of a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// The greatest presentation timestamp of the interrogated `CMBufferQueue`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the `getPresentationTimeStamp` callback is `NULL`, `kCMTimeInvalid` will be returned.
    ///
    ///
    /// Gets the greatest presentation timestamp of a CMBufferQueue.
    ///
    /// If the getPresentationTimeStamp callback is NULL, kCMTimeInvalid will
    /// be returned.
    #[doc(alias = "CMBufferQueueGetMaxPresentationTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn max_presentation_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetMaxPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetMaxPresentationTimeStamp(self) }
    }

    /// Gets the greatest end presentation timestamp of a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` being interrogated.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the sum of `PresentationTimeStamp` and the individual buffer durations.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This is the maximum end time (PTS + duration) of buffers in the queue.                If the `getPresentationTimeStamp` callback is `NULL`, `kCMTimeInvalid` will                be returned.
    ///
    ///
    /// Gets the greatest end presentation timestamp of a CMBufferQueue.
    ///
    /// This is the maximum end time (PTS + duration) of buffers in the queue.
    /// If the getPresentationTimeStamp callback is NULL, kCMTimeInvalid will
    /// be returned.
    #[doc(alias = "CMBufferQueueGetEndPresentationTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn end_presentation_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetEndPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetEndPresentationTimeStamp(self) }
    }

    /// Gets the total size of all sample buffers of a buffer queue.
    ///
    /// ## Discussion
    ///
    /// The total size of the `CMBufferQueue` is the sum of all the individual buffer sizes, as reported by the `getTotalSize` callback (provided to [`CMBufferQueueCreate`](https://developer.apple.com/documentation/coremedia/cmbufferqueuecreate(allocator:capacity:callbacks:queueout:))).
    ///
    /// This function returns 0 if there are no buffers in the queue.
    ///
    ///
    /// Gets the total size of all sample buffers of a CMBufferQueue.
    ///
    /// The total size of the CMBufferQueue is the sum of all the individual
    /// buffer sizes, as reported by the getTotalSize callback (provided to
    /// CMBufferQueueCreate).  If there are no buffers in the queue,
    /// 0 will be returned.
    #[doc(alias = "CMBufferQueueGetTotalSize")]
    #[inline]
    pub unsafe fn total_size(&self) -> usize {
        extern "C-unwind" {
            fn CMBufferQueueGetTotalSize(queue: &CMBufferQueue) -> usize;
        }
        unsafe { CMBufferQueueGetTotalSize(self) }
    }
}

#[repr(C)]
#[derive(Debug)]
pub struct opaqueCMBufferQueueTriggerToken {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for opaqueCMBufferQueueTriggerToken {
    const ENCODING_REF: Encoding =
        Encoding::Pointer(&Encoding::Struct("opaqueCMBufferQueueTriggerToken", &[]));
}

/// A type alias for a trigger token.
///
/// ## Discussion
///
/// The CMBufferQueueTriggerToken is returned from [`CMBufferQueueInstallTrigger`](https://developer.apple.com/documentation/coremedia/cmbufferqueueinstalltrigger(_:callback:refcon:condition:time:triggertokenout:)), so you can remove it later if necessary.  Triggers will automatically be removed when the queue is finalized. Note that if more than one module has access to a queue, it may be hard for an individual module to know when the queue is finalized since other modules may retain it.  To address this concern, modules should remove their triggers before they themselves are finalized.
///
/// ### Special Considerations
///
/// A `CMBufferQueueTrigger` is not a Core Foundation object; you must not `CFRetain` or `CFRelease` it.
///
///
/// A reference to a CMBufferQueueTrigger object.  It is not a CF type; do not CFRetain or CFRelease it.
///
/// A trigger is a callback function that the queue calls every time the triggering condition becomes true.
/// Trigger conditions include things like queue duration, queue buffer count, etc.
/// Trigger callbacks are called from within CMBufferQueue routines that modify the trigger condition
/// (eg. Enqueue/Dequeue/Reset).
///
/// Trigger callbacks cannot modify the queue that called them; they can, however, interrogate it.
/// Trigger callbacks should not block waiting for other threads to modify or interrogate the queue either.
/// In fact, trigger callbacks should perform as little processing as possible, preferably arranging
/// for processing to occur by signalling a semaphore, rescheduling a runloop timer, calling dispatch_async(), etc.
///
/// Clients can install as many triggers as they like.  The order in which they are called is non-deterministic.
///
/// Triggers with a NULL callback are valid, since even though no trigger callback will be called, the
/// trigger condition can still be explicitly tested.
///
/// The CMBufferQueueTriggerToken is returned from CMBufferQueueInstallTrigger, so clients can remove
/// it later if necessary.  Triggers will automatically be removed when the queue is finalized.  Note
/// that if more than one module has access to a queue, it may be hard for an individual module to know
/// when the queue is finalized since other modules may retain it.  To address this concern, modules
/// should remove their triggers before they themselves are finalized.
pub type CMBufferQueueTriggerToken = *mut opaqueCMBufferQueueTriggerToken;

/// A callback for the system to invoke when a trigger condition becomes true.
///
/// ### Callback Parameters
///
/// - triggerRefcon: The contextual data.
///
/// - triggerToken: The trigger whose condition became true.
///
///
/// A callback to be called when a CMBufferQueue trigger condition becomes true.
pub type CMBufferQueueTriggerCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, CMBufferQueueTriggerToken)>;

/// A type alias for a trigger handler.
#[cfg(feature = "block2")]
pub type CMBufferQueueTriggerHandler = *mut block2::DynBlock<dyn Fn(CMBufferQueueTriggerToken)>;

/// A type to specify conditions to associate with a buffer queue trigger.
///
/// ## Discussion
///
/// For possible values, see [Buffer Trigger Conditions](https://developer.apple.com/documentation/coremedia/buffer-trigger-conditions).
///
///
/// A condition to be associated with a CMBufferQueueTrigger.
pub type CMBufferQueueTriggerCondition = i32;

/// Trigger fires when queue duration becomes less than the specified duration.
pub const kCMBufferQueueTrigger_WhenDurationBecomesLessThan: CMBufferQueueTriggerCondition = 1;
/// Trigger fires when queue duration becomes less than or equal to the specified duration.
pub const kCMBufferQueueTrigger_WhenDurationBecomesLessThanOrEqualTo:
    CMBufferQueueTriggerCondition = 2;
/// Trigger fires when queue duration becomes greater than the specified duration.
pub const kCMBufferQueueTrigger_WhenDurationBecomesGreaterThan: CMBufferQueueTriggerCondition = 3;
/// Trigger fires when queue duration becomes greater than or equal to the specified duration.
pub const kCMBufferQueueTrigger_WhenDurationBecomesGreaterThanOrEqualTo:
    CMBufferQueueTriggerCondition = 4;
/// Trigger fires when the minimum presentation timestamp changes (triggerDuration is ignored).
pub const kCMBufferQueueTrigger_WhenMinPresentationTimeStampChanges: CMBufferQueueTriggerCondition =
    5;
/// Trigger fires when the maximum presentation timestamp changes (triggerDuration is ignored).
pub const kCMBufferQueueTrigger_WhenMaxPresentationTimeStampChanges: CMBufferQueueTriggerCondition =
    6;
/// Trigger fires when next dequeueable buffer becomes ready (that is, [`CMBufferQueueDequeueIfDataReadyAndRetain`](https://developer.apple.com/documentation/coremedia/cmbufferqueuedequeueifdataready(_:)) will now succeed).  (triggerDuration is ignored.)
pub const kCMBufferQueueTrigger_WhenDataBecomesReady: CMBufferQueueTriggerCondition = 7;
/// Trigger fires when CMBufferQueueIsAtEndOfData’s condition becomes true.  (triggerDuration is ignored.)
pub const kCMBufferQueueTrigger_WhenEndOfDataReached: CMBufferQueueTriggerCondition = 8;
/// Trigger fires when CMBufferQueueReset called.  (triggerDuration is ignored.)
pub const kCMBufferQueueTrigger_WhenReset: CMBufferQueueTriggerCondition = 9;
/// Trigger fires when buffer count becomes less than the specified threshold number.
pub const kCMBufferQueueTrigger_WhenBufferCountBecomesLessThan: CMBufferQueueTriggerCondition = 10;
/// Trigger fires when buffer count becomes > the specified threshold number.
pub const kCMBufferQueueTrigger_WhenBufferCountBecomesGreaterThan: CMBufferQueueTriggerCondition =
    11;
pub const kCMBufferQueueTrigger_WhenDurationBecomesGreaterThanOrEqualToAndBufferCountBecomesGreaterThan: CMBufferQueueTriggerCondition = 12;

impl CMBufferQueue {
    /// Installs a trigger with a callback on a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` on which the trigger is being set.
    ///
    /// - callback: Callback to be called when the trigger condition becomes true. Can be `NULL`, if client intends only to explicitly test the condition.  if `triggerTokenOut` is `NULL` this parameter cannot be `NULL` otherwise the trigger would be meaningless.
    ///
    /// - refcon: Refcon to be passed to the triggerCallback. Can be `NULL` if the callback doesn’t need it, or is                                                            itself `NULL`.
    ///
    /// - condition: The condition to be tested when evaluating the trigger.
    ///
    /// - time: The time value to compare against when evaluating the trigger. Must be numeric (ie. not invalid, indefinite, or infinite), except for certain trigger conditions which ignores it (eg, kCMBufferQueueTrigger_WhenMinPresentationTimeStampChanges).
    ///
    /// - triggerTokenOut: Address where created trigger token will be written. Can be `NULL`, if client has no need to explicitly test or remove the trigger. Cannot be `NULL` when triggerCallback is `NULL`,  since the trigger would be meaningless then.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Result Codes`
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The returned trigger token can be passed to `CMBufferQueueTestTrigger` and `CMBufferQueueRemoveTrigger`. The `triggerTokenOut` parameter can be `NULL` (client doesn’t need to test or remove trigger), and the `triggerCallback` parameter can be `NULL` (client doesn’t need callbacks, but rather will explicitly test the trigger).  One of these two parameters must be non-NULL, however, since an untestable trigger that does not perform a callback is meaningless.  If the trigger condition is already true,  `CMBufferQueueInstallTrigger` will call the triggerCallback and will first write the trigger token to *triggerTokenOut.
    ///
    ///
    /// Installs a trigger on a CMBufferQueue.
    ///
    /// The returned trigger token can be passed to CMBufferQueueTestTrigger and CMBufferQueueRemoveTrigger.
    /// The triggerTokenOut parameter can be NULL (client doesn't need to test or remove trigger), and the
    /// callback parameter can be NULL (client doesn't need callbacks, but rather will explicitly
    /// test the trigger).  One of these two parameters must be non-NULL, however, since an untestable
    /// trigger that does not perform a callback is meaningless.  If the trigger condition is already true,
    /// CMBufferQueueInstallTrigger will call the callback.  If it does this, it will first write
    /// the trigger token to *triggerTokenOut.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    /// - `trigger_token_out` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueInstallTrigger")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn install_trigger(
        &self,
        callback: CMBufferQueueTriggerCallback,
        refcon: *mut c_void,
        condition: CMBufferQueueTriggerCondition,
        time: CMTime,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueInstallTrigger(
                queue: &CMBufferQueue,
                callback: CMBufferQueueTriggerCallback,
                refcon: *mut c_void,
                condition: CMBufferQueueTriggerCondition,
                time: CMTime,
                trigger_token_out: *mut CMBufferQueueTriggerToken,
            ) -> OSStatus;
        }
        unsafe {
            CMBufferQueueInstallTrigger(self, callback, refcon, condition, time, trigger_token_out)
        }
    }

    /// Installs a trigger with a callback and threshold on a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` on which the trigger is being set.
    ///
    /// - callback: Callback to be called when the trigger condition becomes true. Can be `NULL`, if client intends only to explicitly test the condition.  Cannot be `NULL` if triggerTokenOut is NULL, otherwise the trigger would be meaningless.
    ///
    /// - refcon: Refcon to be passed to the triggerCallback. Can be `NULL` if the callback doesn’t need it, or is                                    itself `NULL`.``
    ///
    /// - condition: The condition to be tested when evaluating the trigger. Must be a valid condition for an integer threshold.
    ///
    /// - threshold: The integer value to compare against when evaluating the trigger.
    ///
    /// - triggerTokenOut: Address where created trigger token will be written. Can be `NULL`, if client has no need to explicitly test or remove the trigger. Cannot be `NULL` if triggerCallback is NULL, since the trigger would be meaningless then.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Result Codes`
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function behaves the same way as [`CMBufferQueueInstallTrigger`](https://developer.apple.com/documentation/coremedia/cmbufferqueueinstalltrigger(_:callback:refcon:condition:time:triggertokenout:)) except the trigger is evaluated against the integer value rather than the time value.
    ///
    ///
    /// Installs a trigger on a CMBufferQueue.
    ///
    /// This function behaves the same way as CMBufferQueueInstallTrigger() except the trigger is evaluated against
    /// the integer value rather than the time value.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    /// - `trigger_token_out` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueInstallTriggerWithIntegerThreshold")]
    #[cfg(feature = "CMBase")]
    #[inline]
    pub unsafe fn install_trigger_with_integer_threshold(
        &self,
        callback: CMBufferQueueTriggerCallback,
        refcon: *mut c_void,
        condition: CMBufferQueueTriggerCondition,
        threshold: CMItemCount,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueInstallTriggerWithIntegerThreshold(
                queue: &CMBufferQueue,
                callback: CMBufferQueueTriggerCallback,
                refcon: *mut c_void,
                condition: CMBufferQueueTriggerCondition,
                threshold: CMItemCount,
                trigger_token_out: *mut CMBufferQueueTriggerToken,
            ) -> OSStatus;
        }
        unsafe {
            CMBufferQueueInstallTriggerWithIntegerThreshold(
                self,
                callback,
                refcon,
                condition,
                threshold,
                trigger_token_out,
            )
        }
    }

    /// Installs a trigger with a handler on a buffer queue.
    /// Installs a trigger on a CMBufferQueue.
    ///
    /// The returned trigger token can be passed to CMBufferQueueTestTrigger and CMBufferQueueRemoveTrigger.
    /// The triggerTokenOut parameter can be NULL (client doesn't need to test or remove trigger), and the
    /// handler parameter can be NULL (client doesn't need callbacks, but rather will explicitly
    /// test the trigger).  One of these two parameters must be non-NULL, however, since an untestable
    /// trigger that does not perform a callback is meaningless.  If the trigger condition is already true,
    /// CMBufferQueueInstallTrigger will call the handler.  If it does this, it will first write
    /// the trigger token to *triggerTokenOut.
    ///
    /// # Safety
    ///
    /// - `trigger_token_out` must be a valid pointer or null.
    /// - `handler` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueInstallTriggerHandler")]
    #[cfg(all(feature = "CMTime", feature = "block2"))]
    #[inline]
    pub unsafe fn install_trigger_handler(
        &self,
        condition: CMBufferQueueTriggerCondition,
        time: CMTime,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
        handler: CMBufferQueueTriggerHandler,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueInstallTriggerHandler(
                queue: &CMBufferQueue,
                condition: CMBufferQueueTriggerCondition,
                time: CMTime,
                trigger_token_out: *mut CMBufferQueueTriggerToken,
                handler: CMBufferQueueTriggerHandler,
            ) -> OSStatus;
        }
        unsafe {
            CMBufferQueueInstallTriggerHandler(self, condition, time, trigger_token_out, handler)
        }
    }

    /// Installs a trigger with a handler and threshold on a buffer queue.
    /// Installs a trigger on a CMBufferQueue.
    ///
    /// This function behaves the same way as CMBufferQueueInstallTriggerHandler() except the trigger is evaluated against
    /// the integer value rather than the time value.
    ///
    /// # Safety
    ///
    /// - `trigger_token_out` must be a valid pointer or null.
    /// - `handler` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueInstallTriggerHandlerWithIntegerThreshold")]
    #[cfg(all(feature = "CMBase", feature = "block2"))]
    #[inline]
    pub unsafe fn install_trigger_handler_with_integer_threshold(
        &self,
        condition: CMBufferQueueTriggerCondition,
        threshold: CMItemCount,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
        handler: CMBufferQueueTriggerHandler,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(
                queue: &CMBufferQueue,
                condition: CMBufferQueueTriggerCondition,
                threshold: CMItemCount,
                trigger_token_out: *mut CMBufferQueueTriggerToken,
                handler: CMBufferQueueTriggerHandler,
            ) -> OSStatus;
        }
        unsafe {
            CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(
                self,
                condition,
                threshold,
                trigger_token_out,
                handler,
            )
        }
    }

    /// Removes a previously installed trigger from a buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` from which the trigger is to be removed.
    ///
    /// - triggerToken: Trigger to remove from the queue.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Result Codes`
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Triggers will automatically be removed when a queue is finalized.  However, if more than one module has access to a queue, it may be hard for an individual module to know when the queue is finalized since other modules may retain it.  To address this concern, modules should remove their triggers before they themselves are finalized.
    ///
    ///
    /// Removes a previously installed trigger from a CMBufferQueue.
    ///
    /// Triggers will automatically be removed when a queue is finalized.  However, if more
    /// than one module has access to a queue, it may be hard for an individual module to know
    /// when the queue is finalized since other modules may retain it.  To address this concern,
    /// modules should remove their triggers before they themselves are finalized.
    ///
    /// # Safety
    ///
    /// `trigger_token` must be a valid pointer.
    #[doc(alias = "CMBufferQueueRemoveTrigger")]
    #[inline]
    pub unsafe fn remove_trigger(&self, trigger_token: CMBufferQueueTriggerToken) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueRemoveTrigger(
                queue: &CMBufferQueue,
                trigger_token: CMBufferQueueTriggerToken,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueRemoveTrigger(self, trigger_token) }
    }

    /// Tests whether the trigger condition is true for the specified buffer queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` on which the trigger is tested.
    ///
    /// - triggerToken: Trigger to test.
    ///
    ///
    /// ## Return Value
    ///
    /// A Boolean indicating whether the trigger condition is True.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// [CMBufferQueue](https://developer.apple.com/documentation/coremedia/cmbufferqueue-api) always returns the condition’s current status. The trigger callback will only be called when the condition goes from false to true. The `triggerToken` must be one that has been installed on this queue.
    ///
    ///
    /// Tests whether the trigger condition is true.
    ///
    /// Whereas the trigger callback will only be called when the condition goes from false
    /// to true, CMBufferQueueTestTrigger always returns the condition's current status.
    /// The triggerToken must be one that has been installed on this queue.
    ///
    /// # Safety
    ///
    /// `trigger_token` must be a valid pointer.
    #[doc(alias = "CMBufferQueueTestTrigger")]
    #[inline]
    pub unsafe fn test_trigger(&self, trigger_token: CMBufferQueueTriggerToken) -> bool {
        extern "C-unwind" {
            fn CMBufferQueueTestTrigger(
                queue: &CMBufferQueue,
                trigger_token: CMBufferQueueTriggerToken,
            ) -> Boolean;
        }
        let ret = unsafe { CMBufferQueueTestTrigger(self, trigger_token) };
        ret != 0
    }

    /// Calls a function for every buffer in a queue.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` that may contain multiple buffers.
    ///
    /// - callback: Function to be called for each buffer. The callback may modify buffer attachments but should not modify sort-affecting properties (eg, timestamps). The callback should not make other calls to the buffer queue.
    ///
    /// - refcon: Reference constant supplied to the callback function.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See [Sample Buffer Error Codes](https://developer.apple.com/documentation/coremedia/sample-buffer-errors).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the callback function returns an error, iteration will stop immediately and the error will be returned.
    ///
    ///
    /// Calls a function for every buffer in a queue.
    ///
    /// If the callback function returns an error, iteration will stop immediately
    /// and the error will be returned.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueCallForEachBuffer")]
    #[inline]
    pub unsafe fn call_for_each_buffer(
        &self,
        callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> OSStatus,
        refcon: *mut c_void,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueCallForEachBuffer(
                queue: &CMBufferQueue,
                callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> OSStatus,
                refcon: *mut c_void,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueCallForEachBuffer(self, callback, refcon) }
    }
}

/// A type alias for a callback that tests whether a buffer is in a valid state to add to a queue.
///
/// ## Discussion
///
/// [`CMBufferQueueEnqueue`](https://developer.apple.com/documentation/coremedia/cmbufferqueueenqueue(_:buffer:)) will call this function to validate buffers.
///
/// Return `noErr` if the buffer is in a valid state to add.
///
/// Return a nonzero error code if the buffer should be rejected; [`CMBufferQueueEnqueue`](https://developer.apple.com/documentation/coremedia/cmbufferqueueenqueue(_:buffer:)) will return this error to the caller. If you do not have a more descriptive error code, use `kCMBufferQueueError_InvalidBuffer`.
///
/// ### Callback Parameters
///
/// - buf: The buffer about to be added.
///
/// - queue: The queue requesting validation.
///
/// - validationRefCon: Contextual data.
///
///
/// Tests whether a buffer is OK to add to a queue.
///
/// CMBufferQueueEnqueue will call this function to validate buffers.
/// Return noErr if the buffer is OK to add.
/// Return a nonzero error code if the buffer should be rejected;
/// CMBufferQueueEnqueue will return this error to the caller.
/// If you do not have a more descriptive error code, use kCMBufferQueueError_InvalidBuffer.
pub type CMBufferValidationCallback = Option<
    unsafe extern "C-unwind" fn(NonNull<CMBufferQueue>, NonNull<CMBuffer>, *mut c_void) -> OSStatus,
>;

/// A type alias for a handler that tests whether a buffer is in a valid state to add to a queue.
/// Tests whether a buffer is OK to add to a queue.
///
/// CMBufferQueueEnqueue will call this block to validate buffers.
/// Return noErr if the buffer is OK to add.
/// Return a nonzero error code if the buffer should be rejected;
/// CMBufferQueueEnqueue will return this error to the caller.
/// If you do not have a more descriptive error code, use kCMBufferQueueError_InvalidBuffer.
#[cfg(feature = "block2")]
pub type CMBufferValidationHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<CMBufferQueue>, NonNull<CMBuffer>) -> OSStatus>;

impl CMBufferQueue {
    /// A validation callback for the queue to call before enqueuing buffers.
    ///
    /// Parameters:
    /// - queue: `CMBufferQueue` that will use the validation callback.
    ///
    /// - callback: Callback that will validate each buffer enqueued.
    ///
    /// - refcon: Context refcon for validation callback.
    ///
    ///
    /// ## Return Value
    ///
    /// A result code. See `Result Codes`.
    ///
    ///
    /// Sets a function that CMBufferQueueEnqueue will call to validate buffers before adding them to the queue.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueSetValidationCallback")]
    #[inline]
    pub unsafe fn set_validation_callback(
        &self,
        callback: CMBufferValidationCallback,
        refcon: *mut c_void,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueSetValidationCallback(
                queue: &CMBufferQueue,
                callback: CMBufferValidationCallback,
                refcon: *mut c_void,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueSetValidationCallback(self, callback, refcon) }
    }

    /// A validation handler for the queue to call before enqueuing buffers.
    /// Sets a block that CMBufferQueueEnqueue will call to validate buffers before adding them to the queue.
    ///
    /// Both a validation callback and a validation handler can be set at the
    /// same time, in which case they will both be called when enqueueing
    /// buffers. They both need to return noErr for the buffer to be enqueued.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer.
    #[doc(alias = "CMBufferQueueSetValidationHandler")]
    #[cfg(feature = "block2")]
    #[inline]
    pub unsafe fn set_validation_handler(&self, handler: CMBufferValidationHandler) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueSetValidationHandler(
                queue: &CMBufferQueue,
                handler: CMBufferValidationHandler,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueSetValidationHandler(self, handler) }
    }
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMBufferQueue::callbacks_for_unsorted_sample_buffers`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueGetCallbacksForUnsortedSampleBuffers(
) -> NonNull<CMBufferCallbacks> {
    extern "C-unwind" {
        fn CMBufferQueueGetCallbacksForUnsortedSampleBuffers() -> Option<NonNull<CMBufferCallbacks>>;
    }
    let ret = unsafe { CMBufferQueueGetCallbacksForUnsortedSampleBuffers() };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMBufferQueue::callbacks_for_sample_buffers_sorted_by_output_pts`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(
) -> NonNull<CMBufferCallbacks> {
    extern "C-unwind" {
        fn CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(
        ) -> Option<NonNull<CMBufferCallbacks>>;
    }
    let ret = unsafe { CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS() };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    #[cfg(all(feature = "CMBase", feature = "CMTime"))]
    #[deprecated = "renamed to `CMBufferQueue::create`"]
    pub fn CMBufferQueueCreate(
        allocator: Option<&CFAllocator>,
        capacity: CMItemCount,
        callbacks: NonNull<CMBufferCallbacks>,
        queue_out: NonNull<*mut CMBufferQueue>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "CMBase", feature = "CMTime", feature = "block2"))]
    #[deprecated = "renamed to `CMBufferQueue::create_with_handlers`"]
    pub fn CMBufferQueueCreateWithHandlers(
        allocator: Option<&CFAllocator>,
        capacity: CMItemCount,
        handlers: NonNull<CMBufferHandlers>,
        queue_out: NonNull<*mut CMBufferQueue>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::enqueue`"]
    pub fn CMBufferQueueEnqueue(queue: &CMBufferQueue, buf: &CMBuffer) -> OSStatus;
}

#[deprecated = "renamed to `CMBufferQueue::dequeue_and_retain`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueDequeueAndRetain(
    queue: &CMBufferQueue,
) -> Option<CFRetained<CMBuffer>> {
    extern "C-unwind" {
        fn CMBufferQueueDequeueAndRetain(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
    }
    let ret = unsafe { CMBufferQueueDequeueAndRetain(queue) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CMBufferQueue::dequeue_if_data_ready_and_retain`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueDequeueIfDataReadyAndRetain(
    queue: &CMBufferQueue,
) -> Option<CFRetained<CMBuffer>> {
    extern "C-unwind" {
        fn CMBufferQueueDequeueIfDataReadyAndRetain(
            queue: &CMBufferQueue,
        ) -> Option<NonNull<CMBuffer>>;
    }
    let ret = unsafe { CMBufferQueueDequeueIfDataReadyAndRetain(queue) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CMBufferQueue::get_head`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueGetHead(
    queue: &CMBufferQueue,
) -> Option<CFRetained<CMBuffer>> {
    extern "C-unwind" {
        fn CMBufferQueueGetHead(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
    }
    let ret = unsafe { CMBufferQueueGetHead(queue) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CMBufferQueue::head`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueCopyHead(
    queue: &CMBufferQueue,
) -> Option<CFRetained<CMBuffer>> {
    extern "C-unwind" {
        fn CMBufferQueueCopyHead(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
    }
    let ret = unsafe { CMBufferQueueCopyHead(queue) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CMBufferQueue::is_empty`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueIsEmpty(queue: &CMBufferQueue) -> bool {
    extern "C-unwind" {
        fn CMBufferQueueIsEmpty(queue: &CMBufferQueue) -> Boolean;
    }
    let ret = unsafe { CMBufferQueueIsEmpty(queue) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::mark_end_of_data`"]
    pub fn CMBufferQueueMarkEndOfData(queue: &CMBufferQueue) -> OSStatus;
}

#[deprecated = "renamed to `CMBufferQueue::contains_end_of_data`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueContainsEndOfData(queue: &CMBufferQueue) -> bool {
    extern "C-unwind" {
        fn CMBufferQueueContainsEndOfData(queue: &CMBufferQueue) -> Boolean;
    }
    let ret = unsafe { CMBufferQueueContainsEndOfData(queue) };
    ret != 0
}

#[deprecated = "renamed to `CMBufferQueue::is_at_end_of_data`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueIsAtEndOfData(queue: &CMBufferQueue) -> bool {
    extern "C-unwind" {
        fn CMBufferQueueIsAtEndOfData(queue: &CMBufferQueue) -> Boolean;
    }
    let ret = unsafe { CMBufferQueueIsAtEndOfData(queue) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::reset`"]
    pub fn CMBufferQueueReset(queue: &CMBufferQueue) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::reset_with_callback`"]
    pub fn CMBufferQueueResetWithCallback(
        queue: &CMBufferQueue,
        callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void),
        refcon: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMBase")]
    #[deprecated = "renamed to `CMBufferQueue::buffer_count`"]
    pub fn CMBufferQueueGetBufferCount(queue: &CMBufferQueue) -> CMItemCount;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::duration`"]
    pub fn CMBufferQueueGetDuration(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::min_decode_time_stamp`"]
    pub fn CMBufferQueueGetMinDecodeTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::first_decode_time_stamp`"]
    pub fn CMBufferQueueGetFirstDecodeTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::min_presentation_time_stamp`"]
    pub fn CMBufferQueueGetMinPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::first_presentation_time_stamp`"]
    pub fn CMBufferQueueGetFirstPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::max_presentation_time_stamp`"]
    pub fn CMBufferQueueGetMaxPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::end_presentation_time_stamp`"]
    pub fn CMBufferQueueGetEndPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::total_size`"]
    pub fn CMBufferQueueGetTotalSize(queue: &CMBufferQueue) -> usize;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::install_trigger`"]
    pub fn CMBufferQueueInstallTrigger(
        queue: &CMBufferQueue,
        callback: CMBufferQueueTriggerCallback,
        refcon: *mut c_void,
        condition: CMBufferQueueTriggerCondition,
        time: CMTime,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMBase")]
    #[deprecated = "renamed to `CMBufferQueue::install_trigger_with_integer_threshold`"]
    pub fn CMBufferQueueInstallTriggerWithIntegerThreshold(
        queue: &CMBufferQueue,
        callback: CMBufferQueueTriggerCallback,
        refcon: *mut c_void,
        condition: CMBufferQueueTriggerCondition,
        threshold: CMItemCount,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "CMTime", feature = "block2"))]
    #[deprecated = "renamed to `CMBufferQueue::install_trigger_handler`"]
    pub fn CMBufferQueueInstallTriggerHandler(
        queue: &CMBufferQueue,
        condition: CMBufferQueueTriggerCondition,
        time: CMTime,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
        handler: CMBufferQueueTriggerHandler,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "CMBase", feature = "block2"))]
    #[deprecated = "renamed to `CMBufferQueue::install_trigger_handler_with_integer_threshold`"]
    pub fn CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(
        queue: &CMBufferQueue,
        condition: CMBufferQueueTriggerCondition,
        threshold: CMItemCount,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
        handler: CMBufferQueueTriggerHandler,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::remove_trigger`"]
    pub fn CMBufferQueueRemoveTrigger(
        queue: &CMBufferQueue,
        trigger_token: CMBufferQueueTriggerToken,
    ) -> OSStatus;
}

#[deprecated = "renamed to `CMBufferQueue::test_trigger`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueTestTrigger(
    queue: &CMBufferQueue,
    trigger_token: CMBufferQueueTriggerToken,
) -> bool {
    extern "C-unwind" {
        fn CMBufferQueueTestTrigger(
            queue: &CMBufferQueue,
            trigger_token: CMBufferQueueTriggerToken,
        ) -> Boolean;
    }
    let ret = unsafe { CMBufferQueueTestTrigger(queue, trigger_token) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::call_for_each_buffer`"]
    pub fn CMBufferQueueCallForEachBuffer(
        queue: &CMBufferQueue,
        callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> OSStatus,
        refcon: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::set_validation_callback`"]
    pub fn CMBufferQueueSetValidationCallback(
        queue: &CMBufferQueue,
        callback: CMBufferValidationCallback,
        refcon: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "block2")]
    #[deprecated = "renamed to `CMBufferQueue::set_validation_handler`"]
    pub fn CMBufferQueueSetValidationHandler(
        queue: &CMBufferQueue,
        handler: CMBufferValidationHandler,
    ) -> OSStatus;
}
