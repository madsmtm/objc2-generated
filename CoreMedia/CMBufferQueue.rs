//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_allocationfailed?language=objc)
pub const kCMBufferQueueError_AllocationFailed: OSStatus = -12760;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_requiredparametermissing?language=objc)
pub const kCMBufferQueueError_RequiredParameterMissing: OSStatus = -12761;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_invalidcmbuffercallbacksstruct?language=objc)
pub const kCMBufferQueueError_InvalidCMBufferCallbacksStruct: OSStatus = -12762;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_enqueueafterendofdata?language=objc)
pub const kCMBufferQueueError_EnqueueAfterEndOfData: OSStatus = -12763;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_queueisfull?language=objc)
pub const kCMBufferQueueError_QueueIsFull: OSStatus = -12764;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_badtriggerduration?language=objc)
pub const kCMBufferQueueError_BadTriggerDuration: OSStatus = -12765;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_cannotmodifyqueuefromtriggercallback?language=objc)
pub const kCMBufferQueueError_CannotModifyQueueFromTriggerCallback: OSStatus = -12766;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_invalidtriggercondition?language=objc)
pub const kCMBufferQueueError_InvalidTriggerCondition: OSStatus = -12767;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_invalidtriggertoken?language=objc)
pub const kCMBufferQueueError_InvalidTriggerToken: OSStatus = -12768;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueueerror_invalidbuffer?language=objc)
pub const kCMBufferQueueError_InvalidBuffer: OSStatus = -12769;

/// A reference to a CMBufferQueue, a CF object that implements a queue of timed buffers.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbufferqueue?language=objc)
#[doc(alias = "CMBufferQueueRef")]
#[repr(C)]
pub struct CMBufferQueue {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CMBufferQueue {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"opaqueCMBufferQueue"> for CMBufferQueue {}
);

/// A reference to a CMBuffer.
///
/// A CMBuffer can be any CFTypeRef, as long as a getDuration callback can be provided.  Commonly used
/// types are CMSampleBufferRef and CVPixelBufferRef.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffer?language=objc)
#[doc(alias = "CMBufferRef")]
pub type CMBuffer = CFType;

/// Client callback that returns a CMTime from a CMBufferRef
///
/// There are three callbacks of this type that can be provided to CMBufferQueueCreate: getDuration (required),
/// getDecodeTimeStamp (optional), and getPresentationTimeStamp (optional).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffergettimecallback?language=objc)
#[cfg(feature = "CMTime")]
pub type CMBufferGetTimeCallback =
    Option<unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> CMTime>;

/// Client block that returns a CMTime from a CMBufferRef
///
/// There are three blocks of this type that can be provided to CMBufferQueueCreate: getDuration (required),
/// getDecodeTimeStamp (optional), and getPresentationTimeStamp (optional).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffergettimehandler?language=objc)
#[cfg(all(feature = "CMTime", feature = "block2"))]
pub type CMBufferGetTimeHandler = *mut block2::DynBlock<dyn Fn(NonNull<CMBuffer>) -> CMTime>;

/// Client callback that returns a Boolean from a CMBufferRef
///
/// There is one callback of this type that can be provided to CMBufferQueueCreate: isDataReady (optional).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffergetbooleancallback?language=objc)
pub type CMBufferGetBooleanCallback =
    Option<unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> Boolean>;

/// Client block that returns a Boolean from a CMBufferRef
///
/// There is one callback of this type that can be provided to CMBufferQueueCreate: isDataReady (optional).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffergetbooleanhandler?language=objc)
#[cfg(feature = "block2")]
pub type CMBufferGetBooleanHandler = *mut block2::DynBlock<dyn Fn(NonNull<CMBuffer>) -> Boolean>;

/// Client callback that compares one CMBufferRef with another.
///
/// Note that a CFComparatorFunction can be used here.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffercomparecallback?language=objc)
pub type CMBufferCompareCallback = Option<
    unsafe extern "C-unwind" fn(
        NonNull<CMBuffer>,
        NonNull<CMBuffer>,
        *mut c_void,
    ) -> CFComparisonResult,
>;

/// Client block that compares one CMBufferRef with another.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffercomparehandler?language=objc)
#[cfg(feature = "block2")]
pub type CMBufferCompareHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<CMBuffer>, NonNull<CMBuffer>) -> CFComparisonResult>;

/// Client callback that returns a size_t from a CMBufferRef
///
/// There is one callback of this type that can be provided to CMBufferQueueCreate: getTotalSize.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffergetsizecallback?language=objc)
pub type CMBufferGetSizeCallback =
    Option<unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> usize>;

/// Client block that returns a size_t from a CMBufferRef
///
/// There is one block of this type that can be provided to CMBufferQueueCreate: getTotalSize.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffergetsizehandler?language=objc)
#[cfg(feature = "block2")]
pub type CMBufferGetSizeHandler = *mut block2::DynBlock<dyn Fn(NonNull<CMBuffer>) -> usize>;

/// Callbacks provided to CMBufferQueueCreate, for use by the queue in interrogating the buffers that it will see.
///
/// With the exception of isDataReady, all these callbacks must always return the same result for the same arguments.
/// A buffer's duration, timestamps, or position relative to other buffers must not appear to change while it is in
/// the queue.  Once isDataReady has returned true for a given CMBuffer, it must always return true for that
/// CMBuffer.  Durations must always be positive.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffercallbacks?language=objc)
#[cfg(feature = "CMTime")]
#[repr(C, packed(4))]
#[allow(unpredictable_function_pointer_comparisons)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CMBufferCallbacks {
    /// Must be 0 or 1.
    pub version: u32,
    /// Client refcon to be passed to all callbacks (can be NULL,
    /// if the callbacks don't require it).
    pub refcon: *mut c_void,
    /// This callback is called from CMBufferQueueGetFirstDecodeTimeStamp (once),
    /// and from CMBufferQueueGetMinDecodeTimeStamp (multiple times).  It should
    /// return the decode timestamp of the buffer.  If there are multiple samples
    /// in the buffer, this callback should return the minimum decode timestamp
    /// in the buffer. Can be NULL (CMBufferQueueGetFirstDecodeTimeStamp and
    /// CMBufferQueueGetMinDecodeTimeStamp will return kCMTimeInvalid).
    pub getDecodeTimeStamp: CMBufferGetTimeCallback,
    /// This callback is called from CMBufferQueueGetFirstPresentationTimeStamp
    /// (once) and from CMBufferQueueGetMinPresentationTimeStamp (multiple times).
    /// It should return the presentation timestamp of the buffer.  If there are
    /// multiple samples in the buffer, this callback should return the minimum
    /// presentation timestamp in the buffer. Can be NULL
    /// (CMBufferQueueGetFirstPresentationTimeStamp and
    /// CMBufferQueueGetMinPresentationTimeStamp will return kCMTimeInvalid).
    pub getPresentationTimeStamp: CMBufferGetTimeCallback,
    /// This callback is called (once) during enqueue and dequeue operations to
    /// update the total duration of the queue.  Must not be NULL.
    pub getDuration: CMBufferGetTimeCallback,
    /// This callback is called from CMBufferQueueDequeueIfDataReadyAndRetain, to
    /// ask if the buffer that is about to be dequeued is ready.  Can be NULL
    /// (data will be assumed to be ready).
    pub isDataReady: CMBufferGetBooleanCallback,
    /// This callback is called (multiple times) from CMBufferQueueEnqueue, to
    /// perform an insertion sort. Can be NULL (queue will be FIFO).
    pub compare: CMBufferCompareCallback,
    /// If triggers of type kCMBufferQueueTrigger_WhenDataBecomesReady are installed,
    /// the queue will listen for this notification on the head buffer.
    /// Can be NULL (then the queue won't listen for it).
    pub dataBecameReadyNotification: *const CFString,
    /// This callback is called (once) during enqueue and dequeue operation to
    /// update the total size of the queue. Can be NULL.  Ignored if version
    /// <
    /// 1.
    pub getSize: CMBufferGetSizeCallback,
}

#[cfg(all(feature = "CMTime", feature = "objc2"))]
unsafe impl Encode for CMBufferCallbacks {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <u32>::ENCODING,
            <*mut c_void>::ENCODING,
            <CMBufferGetTimeCallback>::ENCODING,
            <CMBufferGetTimeCallback>::ENCODING,
            <CMBufferGetTimeCallback>::ENCODING,
            <CMBufferGetBooleanCallback>::ENCODING,
            <CMBufferCompareCallback>::ENCODING,
            <*const CFString>::ENCODING,
            <CMBufferGetSizeCallback>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CMTime", feature = "objc2"))]
unsafe impl RefEncode for CMBufferCallbacks {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbufferhandlers?language=objc)
#[cfg(all(feature = "CMTime", feature = "block2"))]
#[repr(C)]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct CMBufferHandlers {
    /// Must be 1.
    pub version: usize,
    /// This block is called from CMBufferQueueGetFirstDecodeTimeStamp (once),
    /// and from CMBufferQueueGetMinDecodeTimeStamp (multiple times).  It should
    /// return the decode timestamp of the buffer.  If there are multiple samples
    /// in the buffer, this block should return the minimum decode timestamp
    /// in the buffer. Can be NULL (CMBufferQueueGetFirstDecodeTimeStamp and
    /// CMBufferQueueGetMinDecodeTimeStamp will return kCMTimeInvalid).
    pub getDecodeTimeStamp: CMBufferGetTimeHandler,
    /// This block is called from CMBufferQueueGetFirstPresentationTimeStamp
    /// (once) and from CMBufferQueueGetMinPresentationTimeStamp (multiple times).
    /// It should return the presentation timestamp of the buffer.  If there are
    /// multiple samples in the buffer, this block should return the minimum
    /// presentation timestamp in the buffer. Can be NULL
    /// (CMBufferQueueGetFirstPresentationTimeStamp and
    /// CMBufferQueueGetMinPresentationTimeStamp will return kCMTimeInvalid).
    pub getPresentationTimeStamp: CMBufferGetTimeHandler,
    /// This block is called (once) during enqueue and dequeue operations to
    /// update the total duration of the queue.  Must not be NULL.
    pub getDuration: CMBufferGetTimeHandler,
    /// This block is called from CMBufferQueueDequeueIfDataReadyAndRetain, to
    /// ask if the buffer that is about to be dequeued is ready.  Can be NULL
    /// (data will be assumed to be ready).
    pub isDataReady: CMBufferGetBooleanHandler,
    /// This block is called (multiple times) from CMBufferQueueEnqueue, to
    /// perform an insertion sort. Can be NULL (queue will be FIFO).
    pub compare: CMBufferCompareHandler,
    /// If triggers of type kCMBufferQueueTrigger_WhenDataBecomesReady are installed,
    /// the queue will listen for this notification on the head buffer.
    /// Can be NULL (then the queue won't listen for it).
    pub dataBecameReadyNotification: *const CFString,
    /// This block is called (once) during enqueue and dequeue operation to
    /// update the total size of the queue. Can be NULL.
    pub getSize: CMBufferGetSizeHandler,
}

#[cfg(all(feature = "CMTime", feature = "block2", feature = "objc2"))]
unsafe impl Encode for CMBufferHandlers {
    const ENCODING: Encoding = Encoding::Struct(
        "?",
        &[
            <usize>::ENCODING,
            <CMBufferGetTimeHandler>::ENCODING,
            <CMBufferGetTimeHandler>::ENCODING,
            <CMBufferGetTimeHandler>::ENCODING,
            <CMBufferGetBooleanHandler>::ENCODING,
            <CMBufferCompareHandler>::ENCODING,
            <*const CFString>::ENCODING,
            <CMBufferGetSizeHandler>::ENCODING,
        ],
    );
}

#[cfg(all(feature = "CMTime", feature = "block2", feature = "objc2"))]
unsafe impl RefEncode for CMBufferHandlers {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CMBufferQueue {
    /// Returns a pointer to a callback struct for unsorted CMSampleBuffers, provided as a convenience.
    #[doc(alias = "CMBufferQueueGetCallbacksForUnsortedSampleBuffers")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn callbacks_for_unsorted_sample_buffers() -> NonNull<CMBufferCallbacks> {
        extern "C-unwind" {
            fn CMBufferQueueGetCallbacksForUnsortedSampleBuffers(
            ) -> Option<NonNull<CMBufferCallbacks>>;
        }
        let ret = unsafe { CMBufferQueueGetCallbacksForUnsortedSampleBuffers() };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns a pointer to a callback struct for CMSampleBuffers sorted by output presentation timestamp, provided as a convenience.
    #[doc(alias = "CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn callbacks_for_sample_buffers_sorted_by_output_pts() -> NonNull<CMBufferCallbacks>
    {
        extern "C-unwind" {
            fn CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(
            ) -> Option<NonNull<CMBufferCallbacks>>;
        }
        let ret = unsafe { CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS() };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Creates a CMBufferQueue object.
    ///
    /// On return, the caller owns the returned CMBufferQueue, and must release it when done with it.
    ///
    /// # Safety
    ///
    /// - `callbacks` must be a valid pointer.
    /// - `queue_out` must be a valid pointer.
    #[doc(alias = "CMBufferQueueCreate")]
    #[cfg(all(feature = "CMBase", feature = "CMTime"))]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        capacity: CMItemCount,
        callbacks: NonNull<CMBufferCallbacks>,
        queue_out: NonNull<*mut CMBufferQueue>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueCreate(
                allocator: Option<&CFAllocator>,
                capacity: CMItemCount,
                callbacks: NonNull<CMBufferCallbacks>,
                queue_out: NonNull<*mut CMBufferQueue>,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueCreate(allocator, capacity, callbacks, queue_out) }
    }

    /// Creates a CMBufferQueue object.
    ///
    /// On return, the caller owns the returned CMBufferQueue, and must release it when done with it.
    ///
    /// # Safety
    ///
    /// - `handlers` must be a valid pointer.
    /// - `queue_out` must be a valid pointer.
    #[doc(alias = "CMBufferQueueCreateWithHandlers")]
    #[cfg(all(feature = "CMBase", feature = "CMTime", feature = "block2"))]
    #[inline]
    pub unsafe fn create_with_handlers(
        allocator: Option<&CFAllocator>,
        capacity: CMItemCount,
        handlers: NonNull<CMBufferHandlers>,
        queue_out: NonNull<*mut CMBufferQueue>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueCreateWithHandlers(
                allocator: Option<&CFAllocator>,
                capacity: CMItemCount,
                handlers: NonNull<CMBufferHandlers>,
                queue_out: NonNull<*mut CMBufferQueue>,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueCreateWithHandlers(allocator, capacity, handlers, queue_out) }
    }
}

unsafe impl ConcreteType for CMBufferQueue {
    /// Returns the CFTypeID of CMBufferQueue objects.
    ///
    /// You can check if a CFTypeRef object is actually a CMBufferQueue by comparing CFGetTypeID(object) with CMBufferQueueGetTypeID().
    ///
    /// Returns: CFTypeID of CMBufferQueue objects.
    #[doc(alias = "CMBufferQueueGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMBufferQueueGetTypeID() -> CFTypeID;
        }
        unsafe { CMBufferQueueGetTypeID() }
    }
}

impl CMBufferQueue {
    /// Enqueues a buffer onto a CMBufferQueue.
    ///
    /// The buffer is retained by the queue, so the client can safely release the buffer if it has no further use for it.
    /// If the compare callback is non-NULL, this API performs an insertion sort using that compare operation.
    /// If the validation callback is non-NULL, this API calls it; if it returns a nonzero OSStatus,
    /// the buffer will not be enqueued and this API will return the same error OSStatus.
    ///
    /// # Safety
    ///
    /// `buf` should be of the correct type.
    #[doc(alias = "CMBufferQueueEnqueue")]
    #[inline]
    pub unsafe fn enqueue(&self, buf: &CMBuffer) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueEnqueue(queue: &CMBufferQueue, buf: &CMBuffer) -> OSStatus;
        }
        unsafe { CMBufferQueueEnqueue(self, buf) }
    }

    /// Dequeues a buffer from a CMBufferQueue.
    ///
    /// The buffer is released by the queue, but it is also retained for the client. Buffer ownership is thereby
    /// transferred from queue to client.  The client need not retain the buffer, but is responsible to release
    /// it when done with it.
    ///
    /// Returns: The dequeued buffer.  Will be NULL if the queue is empty.
    #[doc(alias = "CMBufferQueueDequeueAndRetain")]
    #[inline]
    pub unsafe fn dequeue_and_retain(&self) -> Option<CFRetained<CMBuffer>> {
        extern "C-unwind" {
            fn CMBufferQueueDequeueAndRetain(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
        }
        let ret = unsafe { CMBufferQueueDequeueAndRetain(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Dequeues a buffer from a CMBufferQueue if it is ready.
    ///
    /// The buffer is released by the queue, but it is also retained for the client. Buffer ownership is thereby
    /// transferred from queue to client.  The client need not retain the buffer, but is responsible to release
    /// it when done with it.
    ///
    /// Returns: The dequeued buffer.  Will be NULL if the queue is empty, or if the buffer to be dequeued is not yet ready.
    #[doc(alias = "CMBufferQueueDequeueIfDataReadyAndRetain")]
    #[inline]
    pub unsafe fn dequeue_if_data_ready_and_retain(&self) -> Option<CFRetained<CMBuffer>> {
        extern "C-unwind" {
            fn CMBufferQueueDequeueIfDataReadyAndRetain(
                queue: &CMBufferQueue,
            ) -> Option<NonNull<CMBuffer>>;
        }
        let ret = unsafe { CMBufferQueueDequeueIfDataReadyAndRetain(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves the next-to-dequeue buffer from a CMBufferQueue but leaves it in the queue.
    ///
    /// This follows CF "Get" semantics -- it does not retain the returned buffer.
    /// Note that with non-FIFO queues it's not guaranteed that the next dequeue will return
    /// this particular buffer (if an intervening Enqueue adds a buffer that will dequeue next).
    /// This function is deprecated in favor of CMBufferQueueCopyHead() which returns a
    /// retained buffer. When adopting CMBufferQueueCopyHead(), existing CFRetain() call
    /// on the buffer returned from this function must be removed.
    ///
    /// Returns: The buffer.  Will be NULL if the queue is empty.
    #[doc(alias = "CMBufferQueueGetHead")]
    #[deprecated]
    #[inline]
    pub unsafe fn get_head(&self) -> Option<CFRetained<CMBuffer>> {
        extern "C-unwind" {
            fn CMBufferQueueGetHead(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
        }
        let ret = unsafe { CMBufferQueueGetHead(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Retrieves
    /// &
    /// retains the next-to-dequeue buffer from a CMBufferQueue but leaves it in the queue.
    ///
    /// This follows CF "Copy" semantics -- it retains the returned buffer.
    /// Note that with non-FIFO queues it's not guaranteed that the next dequeue will return
    /// this particular buffer (if an intervening Enqueue adds a buffer that will dequeue next).
    ///
    /// Returns: The retained buffer.  Will be NULL if the queue is empty.
    #[doc(alias = "CMBufferQueueCopyHead")]
    #[inline]
    pub unsafe fn head(&self) -> Option<CFRetained<CMBuffer>> {
        extern "C-unwind" {
            fn CMBufferQueueCopyHead(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
        }
        let ret = unsafe { CMBufferQueueCopyHead(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns whether or not a CMBufferQueue is empty.
    ///
    /// Returns: Whether or not the CMBufferQueue is empty. If queue is NULL, true is returned.
    #[doc(alias = "CMBufferQueueIsEmpty")]
    #[inline]
    pub unsafe fn is_empty(&self) -> bool {
        extern "C-unwind" {
            fn CMBufferQueueIsEmpty(queue: &CMBufferQueue) -> Boolean;
        }
        let ret = unsafe { CMBufferQueueIsEmpty(self) };
        ret != 0
    }

    /// Marks a CMBufferQueue with EOD.
    ///
    /// All subsequent Enqueues will be rejected until CMBufferQueueReset is called.
    /// Subsequent Dequeues will succeed as long as the queue is not empty.
    #[doc(alias = "CMBufferQueueMarkEndOfData")]
    #[inline]
    pub unsafe fn mark_end_of_data(&self) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueMarkEndOfData(queue: &CMBufferQueue) -> OSStatus;
        }
        unsafe { CMBufferQueueMarkEndOfData(self) }
    }

    /// Returns whether or not a CMBufferQueue has been marked with EOD.
    ///
    /// Returns: Whether or not the CMBufferQueue has been marked with EOD.
    /// If queue is NULL, true is returned (a NULL queue is considered to
    /// be empty, and permanently at EOD).
    #[doc(alias = "CMBufferQueueContainsEndOfData")]
    #[inline]
    pub unsafe fn contains_end_of_data(&self) -> bool {
        extern "C-unwind" {
            fn CMBufferQueueContainsEndOfData(queue: &CMBufferQueue) -> Boolean;
        }
        let ret = unsafe { CMBufferQueueContainsEndOfData(self) };
        ret != 0
    }

    /// Returns whether or not a CMBufferQueue has been marked with EOD, and is now empty.
    ///
    /// Returns: Whether or not the CMBufferQueue has been marked with EOD, and is now empty.
    /// If queue is NULL, true is returned (a NULL queue is considered to
    /// be empty, and permanently at EOD).
    #[doc(alias = "CMBufferQueueIsAtEndOfData")]
    #[inline]
    pub unsafe fn is_at_end_of_data(&self) -> bool {
        extern "C-unwind" {
            fn CMBufferQueueIsAtEndOfData(queue: &CMBufferQueue) -> Boolean;
        }
        let ret = unsafe { CMBufferQueueIsAtEndOfData(self) };
        ret != 0
    }

    /// Resets a CMBufferQueue. Empties the queue, and clears any EOD mark.
    ///
    /// All buffers in the queue are released.  Triggers are not removed, however,
    /// and will be called appropriately as the queue duration goes to zero.
    #[doc(alias = "CMBufferQueueReset")]
    #[inline]
    pub unsafe fn reset(&self) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueReset(queue: &CMBufferQueue) -> OSStatus;
        }
        unsafe { CMBufferQueueReset(self) }
    }

    /// Calls a function for every buffer in a queue, then resets the queue.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueResetWithCallback")]
    #[inline]
    pub unsafe fn reset_with_callback(
        &self,
        callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void),
        refcon: *mut c_void,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueResetWithCallback(
                queue: &CMBufferQueue,
                callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void),
                refcon: *mut c_void,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueResetWithCallback(self, callback, refcon) }
    }

    /// Gets the number of buffers in the queue.
    #[doc(alias = "CMBufferQueueGetBufferCount")]
    #[cfg(feature = "CMBase")]
    #[inline]
    pub unsafe fn buffer_count(&self) -> CMItemCount {
        extern "C-unwind" {
            fn CMBufferQueueGetBufferCount(queue: &CMBufferQueue) -> CMItemCount;
        }
        unsafe { CMBufferQueueGetBufferCount(self) }
    }

    /// Gets the duration of a CMBufferQueue.
    ///
    /// The duration of the CMBufferQueue is the sum of all the individual
    /// buffer durations, as reported by the getDuration callback (provided to
    /// CMBufferQueueCreate).  If there are no buffers in the queue,
    /// kCMTimeZero will be returned.
    #[doc(alias = "CMBufferQueueGetDuration")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn duration(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetDuration(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetDuration(self) }
    }

    /// Gets the earliest decode timestamp of a CMBufferQueue.
    ///
    /// The search for earliest decode timstamp is performed in this API.
    /// If you know your queue is in decode order, GetFirstDecodeTimeStamp
    /// is a faster alternative.  If the getDecodeTimeStamp callback is
    /// NULL, kCMTimeInvalid will be returned.
    #[doc(alias = "CMBufferQueueGetMinDecodeTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn min_decode_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetMinDecodeTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetMinDecodeTimeStamp(self) }
    }

    /// Gets the decode timestamp of the first buffer in a CMBufferQueue.
    ///
    /// This API is is a faster alternative to GetMinDecodeTimeStamp,
    /// but only gives the same answer if your queue is in decode order.
    /// If the getDecodeTimeStamp callback is NULL, kCMTimeInvalid will
    /// be returned.
    #[doc(alias = "CMBufferQueueGetFirstDecodeTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn first_decode_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetFirstDecodeTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetFirstDecodeTimeStamp(self) }
    }

    /// Gets the earliest presentation timestamp of a CMBufferQueue.
    ///
    /// The search for earliest presentation timstamp is performed in
    /// this API. If you know your queue is sorted by presentation time,
    /// GetFirstPresentationTimeStamp is a faster alternative. If the
    /// getPresentationTimeStamp callback is NULL, kCMTimeInvalid will
    /// be returned.
    #[doc(alias = "CMBufferQueueGetMinPresentationTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn min_presentation_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetMinPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetMinPresentationTimeStamp(self) }
    }

    /// Gets the presentation timestamp of the first buffer in a CMBufferQueue.
    ///
    /// This API is is a faster alternative to GetMinPresentationTimeStamp,
    /// but only works if you know your queue is sorted by presentation
    /// timestamp. If the getPresentationTimeStamp callback is NULL,
    /// kCMTimeInvalid will be returned.
    #[doc(alias = "CMBufferQueueGetFirstPresentationTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn first_presentation_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetFirstPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetFirstPresentationTimeStamp(self) }
    }

    /// Gets the greatest presentation timestamp of a CMBufferQueue.
    ///
    /// If the getPresentationTimeStamp callback is NULL, kCMTimeInvalid will
    /// be returned.
    #[doc(alias = "CMBufferQueueGetMaxPresentationTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn max_presentation_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetMaxPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetMaxPresentationTimeStamp(self) }
    }

    /// Gets the greatest end presentation timestamp of a CMBufferQueue.
    ///
    /// This is the maximum end time (PTS + duration) of buffers in the queue.
    /// If the getPresentationTimeStamp callback is NULL, kCMTimeInvalid will
    /// be returned.
    #[doc(alias = "CMBufferQueueGetEndPresentationTimeStamp")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn end_presentation_time_stamp(&self) -> CMTime {
        extern "C-unwind" {
            fn CMBufferQueueGetEndPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
        }
        unsafe { CMBufferQueueGetEndPresentationTimeStamp(self) }
    }

    /// Gets the total size of all sample buffers of a CMBufferQueue.
    ///
    /// The total size of the CMBufferQueue is the sum of all the individual
    /// buffer sizes, as reported by the getTotalSize callback (provided to
    /// CMBufferQueueCreate).  If there are no buffers in the queue,
    /// 0 will be returned.
    #[doc(alias = "CMBufferQueueGetTotalSize")]
    #[inline]
    pub unsafe fn total_size(&self) -> usize {
        extern "C-unwind" {
            fn CMBufferQueueGetTotalSize(queue: &CMBufferQueue) -> usize;
        }
        unsafe { CMBufferQueueGetTotalSize(self) }
    }
}

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/opaquecmbufferqueuetriggertoken?language=objc)
#[repr(C)]
#[derive(Debug)]
pub struct opaqueCMBufferQueueTriggerToken {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for opaqueCMBufferQueueTriggerToken {
    const ENCODING_REF: Encoding =
        Encoding::Pointer(&Encoding::Struct("opaqueCMBufferQueueTriggerToken", &[]));
}

/// A reference to a CMBufferQueueTrigger object.  It is not a CF type; do not CFRetain or CFRelease it.
///
/// A trigger is a callback function that the queue calls every time the triggering condition becomes true.
/// Trigger conditions include things like queue duration, queue buffer count, etc.
/// Trigger callbacks are called from within CMBufferQueue routines that modify the trigger condition
/// (eg. Enqueue/Dequeue/Reset).
///
/// Trigger callbacks cannot modify the queue that called them; they can, however, interrogate it.
/// Trigger callbacks should not block waiting for other threads to modify or interrogate the queue either.
/// In fact, trigger callbacks should perform as little processing as possible, preferably arranging
/// for processing to occur by signalling a semaphore, rescheduling a runloop timer, calling dispatch_async(), etc.
///
/// Clients can install as many triggers as they like.  The order in which they are called is non-deterministic.
///
/// Triggers with a NULL callback are valid, since even though no trigger callback will be called, the
/// trigger condition can still be explicitly tested.
///
/// The CMBufferQueueTriggerToken is returned from CMBufferQueueInstallTrigger, so clients can remove
/// it later if necessary.  Triggers will automatically be removed when the queue is finalized.  Note
/// that if more than one module has access to a queue, it may be hard for an individual module to know
/// when the queue is finalized since other modules may retain it.  To address this concern, modules
/// should remove their triggers before they themselves are finalized.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbufferqueuetriggertoken?language=objc)
pub type CMBufferQueueTriggerToken = *mut opaqueCMBufferQueueTriggerToken;

/// A callback to be called when a CMBufferQueue trigger condition becomes true.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbufferqueuetriggercallback?language=objc)
pub type CMBufferQueueTriggerCallback =
    Option<unsafe extern "C-unwind" fn(*mut c_void, CMBufferQueueTriggerToken)>;

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbufferqueuetriggerhandler?language=objc)
#[cfg(feature = "block2")]
pub type CMBufferQueueTriggerHandler = *mut block2::DynBlock<dyn Fn(CMBufferQueueTriggerToken)>;

/// A condition to be associated with a CMBufferQueueTrigger.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbufferqueuetriggercondition?language=objc)
pub type CMBufferQueueTriggerCondition = i32;

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whendurationbecomeslessthan?language=objc)
pub const kCMBufferQueueTrigger_WhenDurationBecomesLessThan: CMBufferQueueTriggerCondition = 1;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whendurationbecomeslessthanorequalto?language=objc)
pub const kCMBufferQueueTrigger_WhenDurationBecomesLessThanOrEqualTo:
    CMBufferQueueTriggerCondition = 2;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whendurationbecomesgreaterthan?language=objc)
pub const kCMBufferQueueTrigger_WhenDurationBecomesGreaterThan: CMBufferQueueTriggerCondition = 3;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whendurationbecomesgreaterthanorequalto?language=objc)
pub const kCMBufferQueueTrigger_WhenDurationBecomesGreaterThanOrEqualTo:
    CMBufferQueueTriggerCondition = 4;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whenminpresentationtimestampchanges?language=objc)
pub const kCMBufferQueueTrigger_WhenMinPresentationTimeStampChanges: CMBufferQueueTriggerCondition =
    5;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whenmaxpresentationtimestampchanges?language=objc)
pub const kCMBufferQueueTrigger_WhenMaxPresentationTimeStampChanges: CMBufferQueueTriggerCondition =
    6;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whendatabecomesready?language=objc)
pub const kCMBufferQueueTrigger_WhenDataBecomesReady: CMBufferQueueTriggerCondition = 7;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whenendofdatareached?language=objc)
pub const kCMBufferQueueTrigger_WhenEndOfDataReached: CMBufferQueueTriggerCondition = 8;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whenreset?language=objc)
pub const kCMBufferQueueTrigger_WhenReset: CMBufferQueueTriggerCondition = 9;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whenbuffercountbecomeslessthan?language=objc)
pub const kCMBufferQueueTrigger_WhenBufferCountBecomesLessThan: CMBufferQueueTriggerCondition = 10;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whenbuffercountbecomesgreaterthan?language=objc)
pub const kCMBufferQueueTrigger_WhenBufferCountBecomesGreaterThan: CMBufferQueueTriggerCondition =
    11;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmbufferqueuetrigger_whendurationbecomesgreaterthanorequaltoandbuffercountbecomesgreaterthan?language=objc)
pub const kCMBufferQueueTrigger_WhenDurationBecomesGreaterThanOrEqualToAndBufferCountBecomesGreaterThan: CMBufferQueueTriggerCondition = 12;

impl CMBufferQueue {
    /// Installs a trigger on a CMBufferQueue.
    ///
    /// The returned trigger token can be passed to CMBufferQueueTestTrigger and CMBufferQueueRemoveTrigger.
    /// The triggerTokenOut parameter can be NULL (client doesn't need to test or remove trigger), and the
    /// callback parameter can be NULL (client doesn't need callbacks, but rather will explicitly
    /// test the trigger).  One of these two parameters must be non-NULL, however, since an untestable
    /// trigger that does not perform a callback is meaningless.  If the trigger condition is already true,
    /// CMBufferQueueInstallTrigger will call the callback.  If it does this, it will first write
    /// the trigger token to *triggerTokenOut.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    /// - `trigger_token_out` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueInstallTrigger")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn install_trigger(
        &self,
        callback: CMBufferQueueTriggerCallback,
        refcon: *mut c_void,
        condition: CMBufferQueueTriggerCondition,
        time: CMTime,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueInstallTrigger(
                queue: &CMBufferQueue,
                callback: CMBufferQueueTriggerCallback,
                refcon: *mut c_void,
                condition: CMBufferQueueTriggerCondition,
                time: CMTime,
                trigger_token_out: *mut CMBufferQueueTriggerToken,
            ) -> OSStatus;
        }
        unsafe {
            CMBufferQueueInstallTrigger(self, callback, refcon, condition, time, trigger_token_out)
        }
    }

    /// Installs a trigger on a CMBufferQueue.
    ///
    /// This function behaves the same way as CMBufferQueueInstallTrigger() except the trigger is evaluated against
    /// the integer value rather than the time value.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    /// - `trigger_token_out` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueInstallTriggerWithIntegerThreshold")]
    #[cfg(feature = "CMBase")]
    #[inline]
    pub unsafe fn install_trigger_with_integer_threshold(
        &self,
        callback: CMBufferQueueTriggerCallback,
        refcon: *mut c_void,
        condition: CMBufferQueueTriggerCondition,
        threshold: CMItemCount,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueInstallTriggerWithIntegerThreshold(
                queue: &CMBufferQueue,
                callback: CMBufferQueueTriggerCallback,
                refcon: *mut c_void,
                condition: CMBufferQueueTriggerCondition,
                threshold: CMItemCount,
                trigger_token_out: *mut CMBufferQueueTriggerToken,
            ) -> OSStatus;
        }
        unsafe {
            CMBufferQueueInstallTriggerWithIntegerThreshold(
                self,
                callback,
                refcon,
                condition,
                threshold,
                trigger_token_out,
            )
        }
    }

    /// Installs a trigger on a CMBufferQueue.
    ///
    /// The returned trigger token can be passed to CMBufferQueueTestTrigger and CMBufferQueueRemoveTrigger.
    /// The triggerTokenOut parameter can be NULL (client doesn't need to test or remove trigger), and the
    /// handler parameter can be NULL (client doesn't need callbacks, but rather will explicitly
    /// test the trigger).  One of these two parameters must be non-NULL, however, since an untestable
    /// trigger that does not perform a callback is meaningless.  If the trigger condition is already true,
    /// CMBufferQueueInstallTrigger will call the handler.  If it does this, it will first write
    /// the trigger token to *triggerTokenOut.
    ///
    /// # Safety
    ///
    /// - `trigger_token_out` must be a valid pointer or null.
    /// - `handler` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueInstallTriggerHandler")]
    #[cfg(all(feature = "CMTime", feature = "block2"))]
    #[inline]
    pub unsafe fn install_trigger_handler(
        &self,
        condition: CMBufferQueueTriggerCondition,
        time: CMTime,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
        handler: CMBufferQueueTriggerHandler,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueInstallTriggerHandler(
                queue: &CMBufferQueue,
                condition: CMBufferQueueTriggerCondition,
                time: CMTime,
                trigger_token_out: *mut CMBufferQueueTriggerToken,
                handler: CMBufferQueueTriggerHandler,
            ) -> OSStatus;
        }
        unsafe {
            CMBufferQueueInstallTriggerHandler(self, condition, time, trigger_token_out, handler)
        }
    }

    /// Installs a trigger on a CMBufferQueue.
    ///
    /// This function behaves the same way as CMBufferQueueInstallTriggerHandler() except the trigger is evaluated against
    /// the integer value rather than the time value.
    ///
    /// # Safety
    ///
    /// - `trigger_token_out` must be a valid pointer or null.
    /// - `handler` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueInstallTriggerHandlerWithIntegerThreshold")]
    #[cfg(all(feature = "CMBase", feature = "block2"))]
    #[inline]
    pub unsafe fn install_trigger_handler_with_integer_threshold(
        &self,
        condition: CMBufferQueueTriggerCondition,
        threshold: CMItemCount,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
        handler: CMBufferQueueTriggerHandler,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(
                queue: &CMBufferQueue,
                condition: CMBufferQueueTriggerCondition,
                threshold: CMItemCount,
                trigger_token_out: *mut CMBufferQueueTriggerToken,
                handler: CMBufferQueueTriggerHandler,
            ) -> OSStatus;
        }
        unsafe {
            CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(
                self,
                condition,
                threshold,
                trigger_token_out,
                handler,
            )
        }
    }

    /// Removes a previously installed trigger from a CMBufferQueue.
    ///
    /// Triggers will automatically be removed when a queue is finalized.  However, if more
    /// than one module has access to a queue, it may be hard for an individual module to know
    /// when the queue is finalized since other modules may retain it.  To address this concern,
    /// modules should remove their triggers before they themselves are finalized.
    ///
    /// # Safety
    ///
    /// `trigger_token` must be a valid pointer.
    #[doc(alias = "CMBufferQueueRemoveTrigger")]
    #[inline]
    pub unsafe fn remove_trigger(&self, trigger_token: CMBufferQueueTriggerToken) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueRemoveTrigger(
                queue: &CMBufferQueue,
                trigger_token: CMBufferQueueTriggerToken,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueRemoveTrigger(self, trigger_token) }
    }

    /// Tests whether the trigger condition is true.
    ///
    /// Whereas the trigger callback will only be called when the condition goes from false
    /// to true, CMBufferQueueTestTrigger always returns the condition's current status.
    /// The triggerToken must be one that has been installed on this queue.
    ///
    /// # Safety
    ///
    /// `trigger_token` must be a valid pointer.
    #[doc(alias = "CMBufferQueueTestTrigger")]
    #[inline]
    pub unsafe fn test_trigger(&self, trigger_token: CMBufferQueueTriggerToken) -> bool {
        extern "C-unwind" {
            fn CMBufferQueueTestTrigger(
                queue: &CMBufferQueue,
                trigger_token: CMBufferQueueTriggerToken,
            ) -> Boolean;
        }
        let ret = unsafe { CMBufferQueueTestTrigger(self, trigger_token) };
        ret != 0
    }

    /// Calls a function for every buffer in a queue.
    ///
    /// If the callback function returns an error, iteration will stop immediately
    /// and the error will be returned.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueCallForEachBuffer")]
    #[inline]
    pub unsafe fn call_for_each_buffer(
        &self,
        callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> OSStatus,
        refcon: *mut c_void,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueCallForEachBuffer(
                queue: &CMBufferQueue,
                callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> OSStatus,
                refcon: *mut c_void,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueCallForEachBuffer(self, callback, refcon) }
    }
}

/// Tests whether a buffer is OK to add to a queue.
///
/// CMBufferQueueEnqueue will call this function to validate buffers.
/// Return noErr if the buffer is OK to add.
/// Return a nonzero error code if the buffer should be rejected;
/// CMBufferQueueEnqueue will return this error to the caller.
/// If you do not have a more descriptive error code, use kCMBufferQueueError_InvalidBuffer.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffervalidationcallback?language=objc)
pub type CMBufferValidationCallback = Option<
    unsafe extern "C-unwind" fn(NonNull<CMBufferQueue>, NonNull<CMBuffer>, *mut c_void) -> OSStatus,
>;

/// Tests whether a buffer is OK to add to a queue.
///
/// CMBufferQueueEnqueue will call this block to validate buffers.
/// Return noErr if the buffer is OK to add.
/// Return a nonzero error code if the buffer should be rejected;
/// CMBufferQueueEnqueue will return this error to the caller.
/// If you do not have a more descriptive error code, use kCMBufferQueueError_InvalidBuffer.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmbuffervalidationhandler?language=objc)
#[cfg(feature = "block2")]
pub type CMBufferValidationHandler =
    *mut block2::DynBlock<dyn Fn(NonNull<CMBufferQueue>, NonNull<CMBuffer>) -> OSStatus>;

impl CMBufferQueue {
    /// Sets a function that CMBufferQueueEnqueue will call to validate buffers before adding them to the queue.
    ///
    /// # Safety
    ///
    /// - `callback` must be implemented correctly.
    /// - `refcon` must be a valid pointer or null.
    #[doc(alias = "CMBufferQueueSetValidationCallback")]
    #[inline]
    pub unsafe fn set_validation_callback(
        &self,
        callback: CMBufferValidationCallback,
        refcon: *mut c_void,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueSetValidationCallback(
                queue: &CMBufferQueue,
                callback: CMBufferValidationCallback,
                refcon: *mut c_void,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueSetValidationCallback(self, callback, refcon) }
    }

    /// Sets a block that CMBufferQueueEnqueue will call to validate buffers before adding them to the queue.
    ///
    /// Both a validation callback and a validation handler can be set at the
    /// same time, in which case they will both be called when enqueueing
    /// buffers. They both need to return noErr for the buffer to be enqueued.
    ///
    /// # Safety
    ///
    /// `handler` must be a valid pointer.
    #[doc(alias = "CMBufferQueueSetValidationHandler")]
    #[cfg(feature = "block2")]
    #[inline]
    pub unsafe fn set_validation_handler(&self, handler: CMBufferValidationHandler) -> OSStatus {
        extern "C-unwind" {
            fn CMBufferQueueSetValidationHandler(
                queue: &CMBufferQueue,
                handler: CMBufferValidationHandler,
            ) -> OSStatus;
        }
        unsafe { CMBufferQueueSetValidationHandler(self, handler) }
    }
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMBufferQueue::callbacks_for_unsorted_sample_buffers`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueGetCallbacksForUnsortedSampleBuffers(
) -> NonNull<CMBufferCallbacks> {
    extern "C-unwind" {
        fn CMBufferQueueGetCallbacksForUnsortedSampleBuffers() -> Option<NonNull<CMBufferCallbacks>>;
    }
    let ret = unsafe { CMBufferQueueGetCallbacksForUnsortedSampleBuffers() };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[cfg(feature = "CMTime")]
#[deprecated = "renamed to `CMBufferQueue::callbacks_for_sample_buffers_sorted_by_output_pts`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(
) -> NonNull<CMBufferCallbacks> {
    extern "C-unwind" {
        fn CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS(
        ) -> Option<NonNull<CMBufferCallbacks>>;
    }
    let ret = unsafe { CMBufferQueueGetCallbacksForSampleBuffersSortedByOutputPTS() };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

extern "C-unwind" {
    #[cfg(all(feature = "CMBase", feature = "CMTime"))]
    #[deprecated = "renamed to `CMBufferQueue::create`"]
    pub fn CMBufferQueueCreate(
        allocator: Option<&CFAllocator>,
        capacity: CMItemCount,
        callbacks: NonNull<CMBufferCallbacks>,
        queue_out: NonNull<*mut CMBufferQueue>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "CMBase", feature = "CMTime", feature = "block2"))]
    #[deprecated = "renamed to `CMBufferQueue::create_with_handlers`"]
    pub fn CMBufferQueueCreateWithHandlers(
        allocator: Option<&CFAllocator>,
        capacity: CMItemCount,
        handlers: NonNull<CMBufferHandlers>,
        queue_out: NonNull<*mut CMBufferQueue>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::enqueue`"]
    pub fn CMBufferQueueEnqueue(queue: &CMBufferQueue, buf: &CMBuffer) -> OSStatus;
}

#[deprecated = "renamed to `CMBufferQueue::dequeue_and_retain`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueDequeueAndRetain(
    queue: &CMBufferQueue,
) -> Option<CFRetained<CMBuffer>> {
    extern "C-unwind" {
        fn CMBufferQueueDequeueAndRetain(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
    }
    let ret = unsafe { CMBufferQueueDequeueAndRetain(queue) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CMBufferQueue::dequeue_if_data_ready_and_retain`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueDequeueIfDataReadyAndRetain(
    queue: &CMBufferQueue,
) -> Option<CFRetained<CMBuffer>> {
    extern "C-unwind" {
        fn CMBufferQueueDequeueIfDataReadyAndRetain(
            queue: &CMBufferQueue,
        ) -> Option<NonNull<CMBuffer>>;
    }
    let ret = unsafe { CMBufferQueueDequeueIfDataReadyAndRetain(queue) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CMBufferQueue::get_head`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueGetHead(
    queue: &CMBufferQueue,
) -> Option<CFRetained<CMBuffer>> {
    extern "C-unwind" {
        fn CMBufferQueueGetHead(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
    }
    let ret = unsafe { CMBufferQueueGetHead(queue) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CMBufferQueue::head`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueCopyHead(
    queue: &CMBufferQueue,
) -> Option<CFRetained<CMBuffer>> {
    extern "C-unwind" {
        fn CMBufferQueueCopyHead(queue: &CMBufferQueue) -> Option<NonNull<CMBuffer>>;
    }
    let ret = unsafe { CMBufferQueueCopyHead(queue) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CMBufferQueue::is_empty`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueIsEmpty(queue: &CMBufferQueue) -> bool {
    extern "C-unwind" {
        fn CMBufferQueueIsEmpty(queue: &CMBufferQueue) -> Boolean;
    }
    let ret = unsafe { CMBufferQueueIsEmpty(queue) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::mark_end_of_data`"]
    pub fn CMBufferQueueMarkEndOfData(queue: &CMBufferQueue) -> OSStatus;
}

#[deprecated = "renamed to `CMBufferQueue::contains_end_of_data`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueContainsEndOfData(queue: &CMBufferQueue) -> bool {
    extern "C-unwind" {
        fn CMBufferQueueContainsEndOfData(queue: &CMBufferQueue) -> Boolean;
    }
    let ret = unsafe { CMBufferQueueContainsEndOfData(queue) };
    ret != 0
}

#[deprecated = "renamed to `CMBufferQueue::is_at_end_of_data`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueIsAtEndOfData(queue: &CMBufferQueue) -> bool {
    extern "C-unwind" {
        fn CMBufferQueueIsAtEndOfData(queue: &CMBufferQueue) -> Boolean;
    }
    let ret = unsafe { CMBufferQueueIsAtEndOfData(queue) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::reset`"]
    pub fn CMBufferQueueReset(queue: &CMBufferQueue) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::reset_with_callback`"]
    pub fn CMBufferQueueResetWithCallback(
        queue: &CMBufferQueue,
        callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void),
        refcon: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMBase")]
    #[deprecated = "renamed to `CMBufferQueue::buffer_count`"]
    pub fn CMBufferQueueGetBufferCount(queue: &CMBufferQueue) -> CMItemCount;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::duration`"]
    pub fn CMBufferQueueGetDuration(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::min_decode_time_stamp`"]
    pub fn CMBufferQueueGetMinDecodeTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::first_decode_time_stamp`"]
    pub fn CMBufferQueueGetFirstDecodeTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::min_presentation_time_stamp`"]
    pub fn CMBufferQueueGetMinPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::first_presentation_time_stamp`"]
    pub fn CMBufferQueueGetFirstPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::max_presentation_time_stamp`"]
    pub fn CMBufferQueueGetMaxPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::end_presentation_time_stamp`"]
    pub fn CMBufferQueueGetEndPresentationTimeStamp(queue: &CMBufferQueue) -> CMTime;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::total_size`"]
    pub fn CMBufferQueueGetTotalSize(queue: &CMBufferQueue) -> usize;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMBufferQueue::install_trigger`"]
    pub fn CMBufferQueueInstallTrigger(
        queue: &CMBufferQueue,
        callback: CMBufferQueueTriggerCallback,
        refcon: *mut c_void,
        condition: CMBufferQueueTriggerCondition,
        time: CMTime,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMBase")]
    #[deprecated = "renamed to `CMBufferQueue::install_trigger_with_integer_threshold`"]
    pub fn CMBufferQueueInstallTriggerWithIntegerThreshold(
        queue: &CMBufferQueue,
        callback: CMBufferQueueTriggerCallback,
        refcon: *mut c_void,
        condition: CMBufferQueueTriggerCondition,
        threshold: CMItemCount,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "CMTime", feature = "block2"))]
    #[deprecated = "renamed to `CMBufferQueue::install_trigger_handler`"]
    pub fn CMBufferQueueInstallTriggerHandler(
        queue: &CMBufferQueue,
        condition: CMBufferQueueTriggerCondition,
        time: CMTime,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
        handler: CMBufferQueueTriggerHandler,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "CMBase", feature = "block2"))]
    #[deprecated = "renamed to `CMBufferQueue::install_trigger_handler_with_integer_threshold`"]
    pub fn CMBufferQueueInstallTriggerHandlerWithIntegerThreshold(
        queue: &CMBufferQueue,
        condition: CMBufferQueueTriggerCondition,
        threshold: CMItemCount,
        trigger_token_out: *mut CMBufferQueueTriggerToken,
        handler: CMBufferQueueTriggerHandler,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::remove_trigger`"]
    pub fn CMBufferQueueRemoveTrigger(
        queue: &CMBufferQueue,
        trigger_token: CMBufferQueueTriggerToken,
    ) -> OSStatus;
}

#[deprecated = "renamed to `CMBufferQueue::test_trigger`"]
#[inline]
pub unsafe extern "C-unwind" fn CMBufferQueueTestTrigger(
    queue: &CMBufferQueue,
    trigger_token: CMBufferQueueTriggerToken,
) -> bool {
    extern "C-unwind" {
        fn CMBufferQueueTestTrigger(
            queue: &CMBufferQueue,
            trigger_token: CMBufferQueueTriggerToken,
        ) -> Boolean;
    }
    let ret = unsafe { CMBufferQueueTestTrigger(queue, trigger_token) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::call_for_each_buffer`"]
    pub fn CMBufferQueueCallForEachBuffer(
        queue: &CMBufferQueue,
        callback: unsafe extern "C-unwind" fn(NonNull<CMBuffer>, *mut c_void) -> OSStatus,
        refcon: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMBufferQueue::set_validation_callback`"]
    pub fn CMBufferQueueSetValidationCallback(
        queue: &CMBufferQueue,
        callback: CMBufferValidationCallback,
        refcon: *mut c_void,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "block2")]
    #[deprecated = "renamed to `CMBufferQueue::set_validation_handler`"]
    pub fn CMBufferQueueSetValidationHandler(
        queue: &CMBufferQueue,
        handler: CMBufferValidationHandler,
    ) -> OSStatus;
}
