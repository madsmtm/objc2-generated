//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmsimplequeueerror_allocationfailed?language=objc)
pub const kCMSimpleQueueError_AllocationFailed: OSStatus = -12770;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmsimplequeueerror_requiredparametermissing?language=objc)
pub const kCMSimpleQueueError_RequiredParameterMissing: OSStatus = -12771;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmsimplequeueerror_parameteroutofrange?language=objc)
pub const kCMSimpleQueueError_ParameterOutOfRange: OSStatus = -12772;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmsimplequeueerror_queueisfull?language=objc)
pub const kCMSimpleQueueError_QueueIsFull: OSStatus = -12773;

/// A reference to a CMSimpleQueue, a CF object that implements a simple lockless queue of (void *) elements.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmsimplequeue?language=objc)
#[doc(alias = "CMSimpleQueueRef")]
#[repr(C)]
pub struct CMSimpleQueue {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CMSimpleQueue {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"opaqueCMSimpleQueue"> for CMSimpleQueue {}
);

unsafe impl ConcreteType for CMSimpleQueue {
    /// Returns the CFTypeID of CMSimpleQueue objects.
    ///
    /// You can check if a CFTypeRef object is actually a CMSimpleQueue by comparing CFGetTypeID(object)
    /// with CMSimpleQueueGetTypeID().
    ///
    /// Returns: CFTypeID of CMSimpleQueue objects.
    #[doc(alias = "CMSimpleQueueGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMSimpleQueueGetTypeID() -> CFTypeID;
        }
        unsafe { CMSimpleQueueGetTypeID() }
    }
}

impl CMSimpleQueue {
    /// Creates a CMSimpleQueue.
    ///
    /// On return, the caller owns the returned CMSimpleQueue, and must release it when done with it.
    ///
    /// Returns: Returns noErr if the call succeeds.  Returns kCMSimpleQueueError_ParameterOutOfRange if
    /// capacity is negative.
    ///
    /// # Safety
    ///
    /// `queue_out` must be a valid pointer.
    #[doc(alias = "CMSimpleQueueCreate")]
    #[inline]
    pub unsafe fn create(
        allocator: Option<&CFAllocator>,
        capacity: i32,
        queue_out: NonNull<*mut CMSimpleQueue>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMSimpleQueueCreate(
                allocator: Option<&CFAllocator>,
                capacity: i32,
                queue_out: NonNull<*mut CMSimpleQueue>,
            ) -> OSStatus;
        }
        unsafe { CMSimpleQueueCreate(allocator, capacity, queue_out) }
    }

    /// Enqueues an element on the queue.
    ///
    /// If the queue is full, this operation will fail.
    ///
    /// Returns: Returns noErr if the call succeeds, kCMSimpleQueueError_QueueIsFull if the queue is full.
    ///
    /// # Safety
    ///
    /// `element` must be a valid pointer.
    #[doc(alias = "CMSimpleQueueEnqueue")]
    #[inline]
    pub unsafe fn enqueue(&self, element: NonNull<c_void>) -> OSStatus {
        extern "C-unwind" {
            fn CMSimpleQueueEnqueue(queue: &CMSimpleQueue, element: NonNull<c_void>) -> OSStatus;
        }
        unsafe { CMSimpleQueueEnqueue(self, element) }
    }

    /// Dequeues an element from the queue.
    ///
    /// If the queue is empty, NULL will be returned.
    ///
    /// Returns: The dequeued element.  NULL if the queue was empty, or if there was some other error.
    #[doc(alias = "CMSimpleQueueDequeue")]
    #[inline]
    pub unsafe fn dequeue(&self) -> *const c_void {
        extern "C-unwind" {
            fn CMSimpleQueueDequeue(queue: &CMSimpleQueue) -> *const c_void;
        }
        unsafe { CMSimpleQueueDequeue(self) }
    }

    /// Returns the element at the head of the queue.
    ///
    /// If the queue is empty, NULL will be returned.
    ///
    /// Returns: The head element.  NULL if the queue was empty, or if there was some other error.
    #[doc(alias = "CMSimpleQueueGetHead")]
    #[inline]
    pub unsafe fn head(&self) -> *const c_void {
        extern "C-unwind" {
            fn CMSimpleQueueGetHead(queue: &CMSimpleQueue) -> *const c_void;
        }
        unsafe { CMSimpleQueueGetHead(self) }
    }

    /// Resets the queue.
    ///
    /// This function resets the queue to its empty state;  all values
    /// in the queue prior to reset are lost.   Note that CMSimpleQueueReset
    /// is not synchronized in any way, so the reader thread and writer thread
    /// must be held off by the client during this operation.
    ///
    /// Returns: Returns noErr if the call succeeds.
    #[doc(alias = "CMSimpleQueueReset")]
    #[inline]
    pub unsafe fn reset(&self) -> OSStatus {
        extern "C-unwind" {
            fn CMSimpleQueueReset(queue: &CMSimpleQueue) -> OSStatus;
        }
        unsafe { CMSimpleQueueReset(self) }
    }

    /// Returns the number of elements that can be held in the queue.
    ///
    /// Returns: The number of elements that can be held in the queue.  Returns
    /// 0 if there is an error.
    #[doc(alias = "CMSimpleQueueGetCapacity")]
    #[inline]
    pub unsafe fn capacity(&self) -> i32 {
        extern "C-unwind" {
            fn CMSimpleQueueGetCapacity(queue: &CMSimpleQueue) -> i32;
        }
        unsafe { CMSimpleQueueGetCapacity(self) }
    }

    /// Returns the number of elements currently on the queue.
    ///
    /// Returns: The number of elements currently in the queue. Returns 0 if there is an error.
    #[doc(alias = "CMSimpleQueueGetCount")]
    #[inline]
    pub unsafe fn count(&self) -> i32 {
        extern "C-unwind" {
            fn CMSimpleQueueGetCount(queue: &CMSimpleQueue) -> i32;
        }
        unsafe { CMSimpleQueueGetCount(self) }
    }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMSimpleQueue::create`"]
    pub fn CMSimpleQueueCreate(
        allocator: Option<&CFAllocator>,
        capacity: i32,
        queue_out: NonNull<*mut CMSimpleQueue>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMSimpleQueue::enqueue`"]
    pub fn CMSimpleQueueEnqueue(queue: &CMSimpleQueue, element: NonNull<c_void>) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMSimpleQueue::dequeue`"]
    pub fn CMSimpleQueueDequeue(queue: &CMSimpleQueue) -> *const c_void;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMSimpleQueue::head`"]
    pub fn CMSimpleQueueGetHead(queue: &CMSimpleQueue) -> *const c_void;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMSimpleQueue::reset`"]
    pub fn CMSimpleQueueReset(queue: &CMSimpleQueue) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMSimpleQueue::capacity`"]
    pub fn CMSimpleQueueGetCapacity(queue: &CMSimpleQueue) -> i32;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMSimpleQueue::count`"]
    pub fn CMSimpleQueueGetCount(queue: &CMSimpleQueue) -> i32;
}
