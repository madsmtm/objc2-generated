//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// A foreground color for the text.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a `CFArray` of four `CFNumber`s representing alpha, red, green, and blue fields with values between `0.0` and `1.0`. The system interprets the red, green, and blue components in the sRGB color space. The alpha indicates the opacity from `0.0` for transparent to `1.0` for 100 percent opaque.
    ///
    ///
    /// The foreground color for text.
    ///
    ///
    /// Value must be a CFArray of 4 CFNumbers representing alpha, red, green, and blue fields with values between 0.0 and 1.0. The
    /// red, green and blue components are interpreted in the sRGB color space. The alpha indicates the opacity from 0.0 for transparent to
    /// 1.0 for 100% opaque.
    pub static kCMTextMarkupAttribute_ForegroundColorARGB: &'static CFString;
}

extern "C" {
    /// A background color for the text.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a `CFArray` of four `CFNumber`s representing alpha, red, green, and blue fields with values between `0.0` and `1.0`. The system interprets the red, green, and blue components in the sRGB color space. The alpha indicates the opacity from `0.0` for transparent to `1.0` for 100 percent opaque.
    ///
    /// The color applies to the geometry (for example, a box) containing the text. The container’s background color may have an alpha of `0` so the system doesn’t display it even though the system displays the text. You can optionally control the color behind individual characters with the [`kCMTextMarkupAttribute_CharacterBackgroundColorARGB`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupattribute_characterbackgroundcolorargb) attribute.
    ///
    /// If you use this attribute, apply it to the entire attributed string.
    ///
    ///
    /// The background color for the shape holding the text.
    ///
    ///
    /// Value must be a CFArray of 4 CFNumbers representing alpha, red, green, and blue fields with values between 0.0 and 1.0. The
    /// red, green and blue components are interpreted in the sRGB color space. The alpha indicates the opacity from 0.0 for transparent to
    /// 1.0 for 100% opaque.
    ///
    /// The color applies to the geometry (e.g., a box) containing the text. The container's background color may have an
    /// alpha of 0 so it is not displayed even though the text is displayed. The color behind individual characters
    /// is optionally controllable with the kCMTextMarkupAttribute_CharacterBackgroundColorARGB attribute.
    ///
    /// If used, this attribute must be applied to the entire attributed string (i.e.,
    /// CFRangeMake(0, CFAttributedStringGetLength(...))).
    pub static kCMTextMarkupAttribute_BackgroundColorARGB: &'static CFString;
}

extern "C" {
    /// A background color for individual text characters.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a `CFArray` of four `CFNumber`s representing alpha, red, green, and blue fields with values between `0.0` and `1.0`. The system interprets the red, green, and blue components in the sRGB color space. The alpha indicates the opacity from `0.0` for transparent to `1.0` for 100 percent opaque.
    ///
    ///
    /// The background color behind individual text characters.
    ///
    ///
    /// Value must be a CFArray of 4 CFNumbers representing alpha, red, green, and blue fields with values between 0.0 and 1.0. The
    /// red, green and blue components are interpreted in the sRGB color space. The alpha indicates the opacity from 0.0 for transparent to
    /// 1.0 for 100% opaque.
    pub static kCMTextMarkupAttribute_CharacterBackgroundColorARGB: &'static CFString;
}

extern "C" {
    /// A bold font style.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a `CFBoolean`. The default is `kCFBooleanFalse`. If this attribute is `kCFBooleanTrue`, the system renders the text with a bold style in addition to other styles you use.
    ///
    ///
    /// Allows the setting of a bold style to be applied.
    ///
    ///
    /// Value must be a CFBoolean. The default is kCFBooleanFalse.
    /// If this attribute is kCFBooleanTrue, the text will be drawn
    /// with a bold style. Other styles such as italic may or may
    /// not be used as well.
    pub static kCMTextMarkupAttribute_BoldStyle: &'static CFString;
}

extern "C" {
    /// An italic font style.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a `CFBoolean`. The default is `kCFBooleanFalse`. If this attribute is `kCFBooleanTrue`, the system renders the text with an italic style in addition to other styles you use.
    ///
    ///
    /// Allows the setting of an italic style to be applied.
    ///
    ///
    /// Value must be a CFBoolean. The default is kCFBooleanFalse.
    /// If this attribute is kCFBooleanTrue, the text will be rendered
    /// with an italic style. Other styles such as bold may or may not
    /// be used as well.
    pub static kCMTextMarkupAttribute_ItalicStyle: &'static CFString;
}

extern "C" {
    /// An underline font style.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a `CFBoolean`. The default is `kCFBooleanFalse`. If this attribute is `kCFBooleanTrue`, the system renders the text with an underline style in addition to other styles you use.
    ///
    ///
    /// Allows the setting of an underline to be applied at render
    /// time.
    ///
    ///
    /// Value must be a CFBoolean. The default is kCFBooleanFalse.
    /// If this attribute is kCFBooleanTrue, the text will be rendered
    /// with an underline. Other styles such as bold may or may not
    /// be used as well.
    pub static kCMTextMarkupAttribute_UnderlineStyle: &'static CFString;
}

extern "C" {
    /// A name of a font family.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a `CFString` that holds the family name of an installed font (for example, “Helvetica”) that the system uses to render and/or measure text.
    ///
    /// When the system specifies legible output, an attributed string has at most one of [`kCMTextMarkupAttribute_FontFamilyName`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupattribute_fontfamilyname) or [`kCMTextMarkupAttribute_GenericFontFamilyName`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupattribute_genericfontfamilyname) associated with each character.
    ///
    ///
    /// The name of the font.
    ///
    ///
    /// Value must be a CFString holding the family name of an installed font
    /// (e.g., "Helvetica") that is used to render and/or measure text.
    ///
    /// When vended by legible output, an attributed string will have at most one of kCMTextMarkupAttribute_FontFamilyName or
    /// kCMTextMarkupAttribute_GenericFontFamilyName associated with each character.
    pub static kCMTextMarkupAttribute_FontFamilyName: &'static CFString;
}

extern "C" {
    /// The array of font name(s) and if that name is a generic or a platform name.
    ///
    ///
    /// Value must be a CFArray holding CFDictionaries that are used to render and/or measure text. Each dictionary entry has a font family name and a font kind value.
    /// The font kind value can be either 0 for generic font family or 1 for platform font family corresponding to the font family name.
    /// The CFArray value can hold multiple font names as a fallback where the author prefers specific fonts. If the renderer does not support the first font entry, it tries the following.
    /// For example, the array includes InexistantFont and Times New Roman font names, it is expected the renderer to select the "Times New Roman" font for drawing caption.
    pub static kCMTextMarkupAttribute_FontFamilyNameList: &'static CFString;
}

extern "C" {
    /// A generic font family name identifier.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be one of the constants listed below. You need to map generic fonts to the family name of an installed font before rendering and/or measuring text (see [`Media Accessibility`](https://developer.apple.com/documentation/mediaaccessibility)).
    ///
    /// When the system specifies legible output, an attributed string has at most one of [`kCMTextMarkupAttribute_FontFamilyName`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupattribute_fontfamilyname) or [`kCMTextMarkupAttribute_GenericFontFamilyName`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupattribute_genericfontfamilyname) associated with each character.
    ///
    ///
    /// The attribute holding a generic font family identifier.
    ///
    ///
    /// Value must be a CFString holding a generic font family name that is one of the kCMTextMarkupGenericFontName_* constants.
    /// Generic fonts must be mapped to the family name of an installed font (e.g., kCMTextMarkupGenericFontName_SansSerif -> "Helvetica")
    /// before rendering and/or measuring text.
    ///
    /// When vended by legible output, an attributed string will have at most one of kCMTextMarkupAttribute_FontFamilyName or
    /// kCMTextMarkupAttribute_GenericFontFamilyName associated with each character.
    ///
    /// Overview of Generic Font Family Names
    /// =====================================
    /// Some media formats allow the specification of font family names to be used to style text they carry. Sometimes, an
    /// external specification (e.g., CSS) may be used to style the text carried by the media format. In either case, the
    /// specification may be concrete, indicating an installed platform font (e.g., "Times New Roman", Helvetica). It may be
    /// abstract, indicating a category of font to use (e.g., serif, sans-serif). This abstract designation is often termed
    /// a "generic font family".
    ///
    /// CSS for example allows a 'font-family' property specification such as this:
    ///
    /// font-family: Helvetica, sans-serif;
    ///
    /// This uses both the concrete family name "Helvetica" and the generic family name "sans-serif".
    ///
    /// Generic font families may be common across media formats (e.g., both CSS and 3GPP timed text allow "sans-serif" and "serif").
    /// Other formats may have generic font identifiers that do not align exactly (e.g., TTML allows "monospaceSerif and "monospaceSansSerif" in
    /// addition to "monospace"). Some formats might not carry names but have numeric values mapping to a generic font identifier.
    /// Simply put, different formats use different ways to express their generic fonts.
    ///
    /// The use of generic font families is also important for media accessibility. The Media Accessibility framework can map eight categories
    /// of abstract fonts to an installed font. Users may choose to override each of these categories to a different installed font. This
    /// remapping should work if the content or external styling indicates a generic font. It should not however try to remap a concrete font like "Helvetica".
    /// Consequently, it is important to distinguish between the generic and concrete fonts expressed by the author.
    ///
    /// To accommodate what is expressible in media formats and to support media accessibility overrides, generic font families can be
    /// specified with the kCMTextMarkupAttribute_GenericFontFamilyName attribute which carries the identifier for one of the various
    /// generic font specification forms supported across media formats. These generic font identifiers are the kCMTextMarkupGenericFontName_*
    /// prefixed constants also defined here. New identifers may be added in the future.
    ///
    /// Concrete fonts are specified using the kCMTextMarkupAttribute_FontFamilyName attribute also defined in this header.
    pub static kCMTextMarkupAttribute_GenericFontFamilyName: &'static CFString;
}

extern "C" {
    /// The default font.
    /// Values for kCMTextMarkupAttribute_GenericFontFamilyName.
    ///
    ///
    /// The generic font name indicating the default font. The default font may also be chosen if no font family is
    /// specified (i.e., no kCMTextMarkupAttribute_FontFamilyName or kCMTextMarkupAttribute_GenericFontFamilyName is specified).
    ///
    ///
    /// The generic font name indicating a font with serifs. The font may be proportional or monospaced. E.g., Times New Roman
    ///
    ///
    /// The generic font name indicating a font without serifs. The font may be proportional or monospaced. E.g., Helvetica
    ///
    ///
    /// The generic font name indicating a monospaced font, with or without serifs. E.g., Courier
    ///
    ///
    /// The generic font name indicating a proportional font with serifs.
    ///
    ///
    /// The generic font name indicating a proportional font without serifs.
    ///
    ///
    /// The generic font name indicating a monospaced font with serifs.
    ///
    ///
    /// The generic font name indicating a monospaced font without serifs.
    ///
    ///
    /// The generic font name indicating a "casual" font. E.g., Dom or Impress
    ///
    ///
    /// The generic font name indicating a cursive font. E.g., Coronet or Marigold
    ///
    ///
    /// The generic font name indicating a "fantasy" font.
    ///
    ///
    /// The generic font name indicating a font with lowercase letters set as small capitals. E.g., Engravers Gothic
    pub static kCMTextMarkupGenericFontName_Default: &'static CFString;
}

extern "C" {
    /// A font with serifs.
    ///
    /// ## Discussion
    ///
    /// The font may be proportional or monospaced.
    ///
    ///
    pub static kCMTextMarkupGenericFontName_Serif: &'static CFString;
}

extern "C" {
    /// A font without serifs.
    ///
    /// ## Discussion
    ///
    /// The font may be proportional or monospaced.
    ///
    ///
    pub static kCMTextMarkupGenericFontName_SansSerif: &'static CFString;
}

extern "C" {
    /// A monospaced font with or without serifs.
    pub static kCMTextMarkupGenericFontName_Monospace: &'static CFString;
}

extern "C" {
    /// A proportional font with serifs.
    pub static kCMTextMarkupGenericFontName_ProportionalSerif: &'static CFString;
}

extern "C" {
    /// A proportional font without serifs.
    pub static kCMTextMarkupGenericFontName_ProportionalSansSerif: &'static CFString;
}

extern "C" {
    /// A monospaced font with serifs.
    pub static kCMTextMarkupGenericFontName_MonospaceSerif: &'static CFString;
}

extern "C" {
    /// A monospaced font without serifs.
    pub static kCMTextMarkupGenericFontName_MonospaceSansSerif: &'static CFString;
}

extern "C" {
    /// A casual font.
    pub static kCMTextMarkupGenericFontName_Casual: &'static CFString;
}

extern "C" {
    /// A cursive font.
    pub static kCMTextMarkupGenericFontName_Cursive: &'static CFString;
}

extern "C" {
    /// A fantasy font.
    pub static kCMTextMarkupGenericFontName_Fantasy: &'static CFString;
}

extern "C" {
    /// A font with lowercase letters set as small capital letters.
    pub static kCMTextMarkupGenericFontName_SmallCapital: &'static CFString;
}

extern "C" {
    /// A base font size as a percentage of the video height.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a non-negative `CFNumber`. This is a number holding a percentage of the height of the video frame. For example, a value of `5` indicates that the base font size should be 5% of the height of the video.
    ///
    ///
    /// The base font size expressed as a percentage of the video height.
    ///
    ///
    /// Value must be a non-negative CFNumber.  This is a number holding a percentage of the height of the video frame.  For example, a value of 5 indicates that the base font size should be 5% of the height of the video.
    pub static kCMTextMarkupAttribute_BaseFontSizePercentageRelativeToVideoHeight:
        &'static CFString;
}

extern "C" {
    /// A font size as a percentage of the current default font size.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a non-negative `CFNumber`. This is a number holding a percentage of the size of the calculated default font size. A value of `120` indicates 20% larger than the default font size. A value of `80` indicates 80% of the default font size. The default value of `100` indicates no size difference.
    ///
    ///
    /// The font size expressed as a percentage of the current default font size.
    ///
    ///
    /// Value must be a non-negative CFNumber. This is a number holding a percentage
    /// of the size of the calculated default font size.  A value
    /// of 120 indicates 20% larger than the default font size. A value of 80
    /// indicates 80% of the default font size.  The value 100 indicates no size
    /// difference and is the default.
    pub static kCMTextMarkupAttribute_RelativeFontSize: &'static CFString;
}

extern "C" {
    /// The vertical layout of a text block.
    ///
    /// ## Discussion
    ///
    /// Specifying this attribute indicates that the writing direction is vertical instead of horizontal. You can set the associated value to [`kCMTextVerticalLayout_LeftToRight`](https://developer.apple.com/documentation/coremedia/kcmtextverticallayout_lefttoright) or [`kCMTextVerticalLayout_RightToLeft`](https://developer.apple.com/documentation/coremedia/kcmtextverticallayout_righttoleft) to indicate the progression direction for new vertical lines of text.
    ///
    ///
    /// The kind of vertical layout of the text block.
    ///
    ///
    /// Value must be a CFString.
    /// A CFString holding one of several values indicating the progression direction for new vertical
    /// lines of text. If this attribute is present, it indicates the writing direction is vertical. The
    /// attribute value indicates whether new vertical text lines are added from left to right or from
    /// right to left. If this attribute is missing, the writing direction is horizontal.
    ///
    /// If used, this attribute must be applied to the entire attributed string (i.e.,
    /// CFRangeMake(0, CFAttributedStringGetLength(...))).
    pub static kCMTextMarkupAttribute_VerticalLayout: &'static CFString;
}

extern "C" {
    /// Add new vertical lines from left to right.
    /// Values for kCMTextMarkupAttribute_VerticalLayout.
    ///
    ///
    /// Newly added vertical lines are added from the left toward the right.
    ///
    ///
    /// Newly added vertical lines are added from the right toward the left.
    pub static kCMTextVerticalLayout_LeftToRight: &'static CFString;
}

extern "C" {
    /// Add new vertical lines from right to left.
    pub static kCMTextVerticalLayout_RightToLeft: &'static CFString;
}

extern "C" {
    /// The text alignment in the writing direction of the first line of text.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be one of the constants listed below that indicate the alignment in the writing direction of the first line of text of the cue. The value (or absence) of the [`kCMTextMarkupAttribute_VerticalLayout`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupattribute_verticallayout) attribute indicates the writing direction. The default value of this attribute is [`kCMTextMarkupAlignmentType_Middle`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupalignmenttype_middle).
    ///
    /// If you use this attribute, apply it to the entire attributed string.
    ///
    ///
    /// The alignment of text in the writing direction of the first line of text.
    ///
    ///
    /// Value must be a CFString.
    /// A CFString holding one of several values indicating the alignment
    /// in the writing direction of the first line of text of the cue.
    /// The writing direction is indicated by the value (or absence) of
    /// the kCMTextMarkupAttribute_VerticalLayout.
    ///
    /// If this attribute is missing, the kCMTextMarkupAlignmentType_Middle value should
    /// be used as the default.
    ///
    /// If used, this attribute must be applied to the entire attributed string (i.e.,
    /// CFRangeMake(0, CFAttributedStringGetLength(...))).
    pub static kCMTextMarkupAttribute_Alignment: &'static CFString;
}

extern "C" {
    /// An alignment type that visually aligns the text at its starting side.
    ///
    /// ## Discussion
    ///
    /// For horizontally written text, the alignment is left for left-to-right text and right for right-to-left text. For vertical text, alignment is always at the top.
    ///
    ///
    /// Values for kCMTextMarkupAttribute_Alignment.
    ///
    ///
    /// The text is visually aligned at its starting side. For horizontally written text, the alignment is left for
    /// left-to-right text and right for right-to-left text. For vertical text, alignment is always at the top.
    ///
    ///
    /// The text is visually center-aligned (i.e., aligned between its starting and ending sides).
    ///
    ///
    /// The text is visually aligned at its ending side. For horizontally written text, the alignment is right for
    /// left-to-right text and left for right-to-left text. For vertical text, alignment is always at the bottom.
    ///
    ///
    /// For horizontally written text, the text alignment is always visually left-aligned (i.e., left-to-right and right-to-left
    /// are treated uniformly). For vertical text, this is equivalent to kCMTextMarkupAlignmentType_Start. While readers
    /// should be prepared to account for kCMTextMarkupAlignmentType_Left being equivalent to
    /// kCMTextMarkupAlignmentType_Start for vertical text, authors are discouraged from using kCMTextMarkupAlignmentType_Left
    /// for vertical text.
    ///
    ///
    /// For horizontally written text, the text alignment is always visually right-aligned (i.e., left-to-right and right-to-left
    /// are treated uniformly). For vertical text, this is equivalent to kCMTextMarkupAlignmentType_End. While readers
    /// should be prepared to account for kCMTextMarkupAlignmentType_Right being equivalent to
    /// kCMTextMarkupAlignmentType_End for vertical text, authors are discouraged from using kCMTextMarkupAlignmentType_Right
    /// for vertical text.
    pub static kCMTextMarkupAlignmentType_Start: &'static CFString;
}

extern "C" {
    /// An alignment type that visually aligns text in the center between its starting and ending sides.
    pub static kCMTextMarkupAlignmentType_Middle: &'static CFString;
}

extern "C" {
    /// An alignment type that visually aligns the text at its ending side.
    ///
    /// ## Discussion
    ///
    /// For horizontally written text, the alignment is right for left-to-right text and left for right-to-left text. For vertical text, alignment is always at the bottom.
    ///
    ///
    pub static kCMTextMarkupAlignmentType_End: &'static CFString;
}

extern "C" {
    /// An alignment type that visually aligns text from left-to-right.
    ///
    /// ## Discussion
    ///
    /// For horizontally written text, the text alignment is always visually left-aligned (the system uniformly treats left-to-right and right-to-left). For vertical text, [`kCMTextMarkupAlignmentType_Left`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupalignmenttype_left) is equivalent to [`kCMTextMarkupAlignmentType_Start`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupalignmenttype_start).
    ///
    ///
    pub static kCMTextMarkupAlignmentType_Left: &'static CFString;
}

extern "C" {
    /// An alignment type that visually aligns text from right-to-left.
    ///
    /// ## Discussion
    ///
    /// For horizontally written text, the text alignment is always visually right-aligned (the system uniformly treats left-to-right and right-to-left). For vertical text, [`kCMTextMarkupAlignmentType_Right`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupalignmenttype_right) is equivalent to [`kCMTextMarkupAlignmentType_End`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupalignmenttype_end).
    ///
    ///
    pub static kCMTextMarkupAlignmentType_Right: &'static CFString;
}

extern "C" {
    /// The placement of the block of text as a percentage in the writing direction.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a non-negative `CFNumber` that expresses the position of the center of the text in the writing direction as a percentage of the video dimensions in the writing direction. For horizontal cues, this is the horizontal position. For vertical, it’s the vertical position. The system calculates the percentage from the edge of the frame where the text begins (for left-to-right English, it’s the left edge).
    ///
    /// If you use this attribute, apply it to the entire attributed string.
    ///
    ///
    /// The placement of the block of text specified as a percentage in the writing direction.
    ///
    ///
    /// Value must be a non-negative CFNumber.
    /// A CFNumber expressing the position of the
    /// center of the text in the writing direction as a percentage of the video dimensions in
    /// the writing direction. For horizontal cues, this is the horizontal position.
    /// For vertical, it is the vertical position. The percentage is calculated
    /// from the edge of the frame where the text begins (so for left-to-right
    /// English, it is the left edge).
    ///
    /// If used, this attribute must be applied to the entire attributed string (i.e.,
    /// CFRangeMake(0, CFAttributedStringGetLength(...))).
    pub static kCMTextMarkupAttribute_TextPositionPercentageRelativeToWritingDirection:
        &'static CFString;
}

extern "C" {
    /// The placement of the first line in a block of text as a percentage in the direction orthogonal to the writing direction.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a non-negative `CFNumber` that expresses the position of the center of the cue relative to the writing direction. The line position is orthogonal (or perpendicular) to the writing direction — that is, for a horizontal writing direction it’s vertical, and for a vertical writing direction, it’s horizontal. This attribute expresses the line position as a percentage of the dimensions of the video frame in the relevant direction. For example, 0 percent is the top of the video frame and 100 percent is the bottom of the video frame for horizontal writing layout.
    ///
    /// If you use this attribute, apply it to the entire attributed string.
    ///
    ///
    /// The placement of the block of text's first line specified as a percentage in the
    /// direction orthogonal to the writing direction.
    ///
    ///
    /// Value must be a non-negative CFNumber.
    /// A CFNumber expressing the position of the center of the
    /// cue relative to the writing direction. The line
    /// position is orthogonal (or perpendicular) to the writing direction (i.e.,
    /// for a horizontal writing direction, it is vertical and for a vertical writing
    /// direction, is is horizontal). This attribute expresses the line position as
    /// a percentage of the dimensions of the video frame in the relevant direction.
    /// For example, 0% is the top of the video frame and 100% is the bottom of the
    /// video frame for horizontal writing layout.
    ///
    /// If used, this attribute must be applied to the entire attributed string (i.e.,
    /// CFRangeMake(0, CFAttributedStringGetLength(...))).
    pub static kCMTextMarkupAttribute_OrthogonalLinePositionPercentageRelativeToWritingDirection:
        &'static CFString;
}

extern "C" {
    /// The width or height as a percentage of the bounding box that contains the text.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be a non-negative `CFNumber` that expresses the width of the bounding box for text layout as a percentage of the video frame’s dimension in the writing direction. For a horizontal writing direction, it’s the width. For a vertical writing direction, it’s the height.
    ///
    /// If you use this attribute, apply it to the entire attributed string.
    ///
    ///
    /// The dimension (e.g., width) of the bounding box containing the text expressed as a percentage.
    ///
    ///
    /// Value must be a non-negative CFNumber.
    /// A CFNumber expressing the width of the
    /// bounding box for text layout as a percentage of the video frame's dimension
    /// in the writing direction.
    /// For a horizontal writing direction, it is the width. For a vertical writing
    /// direction, it is the horizontal writing direction.
    ///
    /// If used, this attribute must be applied to the entire attributed string (i.e.,
    /// CFRangeMake(0, CFAttributedStringGetLength(...))).
    pub static kCMTextMarkupAttribute_WritingDirectionSizePercentage: &'static CFString;
}

extern "C" {
    /// A style for character edges.
    ///
    /// ## Discussion
    ///
    /// This attribute’s value must be one of the constants listed below that control the shape of the edges of drawn characters. The default value is [`kCMTextMarkupCharacterEdgeStyle_None`](https://developer.apple.com/documentation/coremedia/kcmtextmarkupcharacteredgestyle_none).
    ///
    ///
    /// Allows the setting of the style of character edges at render time.
    ///
    ///
    /// Value must be a CFString. This controls the shape of the edges of
    /// drawn characters. Set a value of something other than kCMTextMarkupEdgeStyle_None
    /// to draw using an alternative shape for edges of characters from the set of constants
    /// prefixed with "kCMTextMarkupEdgeStyle_". These correspond to text edge styles available
    /// with Media Accessibility preferences (see
    /// <MediaAccessibility
    /// /MACaptionAppearance.h>)
    /// although the values are not enumerated integers here.
    ///
    /// The absence of this attribute should be treated as though kCMTextMarkupCharacterEdgeStyle_None
    /// is specified.
    pub static kCMTextMarkupAttribute_CharacterEdgeStyle: &'static CFString;
}

extern "C" {
    /// No edge style.
    /// Values for kCMTextMarkupAttribute_CharacterEdgeStyle.
    ///
    ///
    /// The character edge style indicating no edge style.
    ///
    ///
    /// The character edge style indicating a raised edge style should be drawn.
    ///
    ///
    /// The character edge style indicating a depressed edge style should be drawn.
    ///
    ///
    /// The character edge style indicating a uniform border around the character should be drawn.
    ///
    ///
    /// The character edge style indicating a drop shadow should be drawn.
    pub static kCMTextMarkupCharacterEdgeStyle_None: &'static CFString;
}

extern "C" {
    /// A raised edge style.
    pub static kCMTextMarkupCharacterEdgeStyle_Raised: &'static CFString;
}

extern "C" {
    /// A depressed edge style.
    pub static kCMTextMarkupCharacterEdgeStyle_Depressed: &'static CFString;
}

extern "C" {
    /// A uniform border style.
    pub static kCMTextMarkupCharacterEdgeStyle_Uniform: &'static CFString;
}

extern "C" {
    /// A drop shadow style.
    pub static kCMTextMarkupCharacterEdgeStyle_DropShadow: &'static CFString;
}
