//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// A timing source object.
///
/// A clock represents a source of time information: generally, a piece of hardware that measures the passage of time.
/// One example of a clock is the host time clock, accessible via CMClockGetHostTimeClock().
/// It measures time using the CPU system clock, which on Mac OS X is mach_absolute_time().
/// Every audio device can also be considered a clock since the audio samples that it outputs or inputs each have a
/// defined duration (eg, 1/48000 of a second for 48 kHz audio).
///
/// CMClocks are read-only: they cannot be stopped or started, and the current time cannot be set.
/// A CMClock has one primary function, CMClockGetTime, which tells what time it is now.
/// Additionally, the CMSync infrastructure monitors relative drift between CMClocks.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmclock?language=objc)
#[doc(alias = "CMClockRef")]
#[repr(C)]
pub struct CMClock {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CMClock {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueCMClock"> for CMClock {}
);

unsafe impl Send for CMClock {}

unsafe impl Sync for CMClock {}

/// Models a timeline under application control.
///
/// A timebase represents a timeline that clients can control by setting the rate and time.
/// Each timebase has either a source clock or a source timebase (previously referred to as a master clock or master timebase).
/// The rate of the timebase is expressed relative to its source.
/// When a timebase has rate 0.0, its time is fixed and does not change as its source's time changes.
/// When a timebase has rate 1.0, its time increases one second as its source's time increases by one second.
/// When a timebase has rate 2.0, its time increases two seconds as its source's time increases by one second.
/// When a timebase has rate -1.0, its time decreases one second as its source's time increases by one second.
///
/// If a timebase has a source timebase, the source timebase's rate is a factor in determining the timebase's effective rate.
/// In fact, a timebase's effective rate is defined as the product of its rate, its source timebase's rate,
/// its source timebase's source timebase's rate, and so on up to the ultimate source clock.  This is the rate at which
/// the timebase's time changes relative to the ultimate source clock.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmtimebase?language=objc)
#[doc(alias = "CMTimebaseRef")]
#[repr(C)]
pub struct CMTimebase {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CMTimebase {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"OpaqueCMTimebase"> for CMTimebase {}
);

unsafe impl Send for CMTimebase {}

unsafe impl Sync for CMTimebase {}

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/cmclockortimebase?language=objc)
#[doc(alias = "CMClockOrTimebaseRef")]
pub type CMClockOrTimebase = CFType;

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmclockerror_missingrequiredparameter?language=objc)
pub const kCMClockError_MissingRequiredParameter: OSStatus = -12745;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmclockerror_invalidparameter?language=objc)
pub const kCMClockError_InvalidParameter: OSStatus = -12746;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmclockerror_allocationfailed?language=objc)
pub const kCMClockError_AllocationFailed: OSStatus = -12747;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmclockerror_unsupportedoperation?language=objc)
pub const kCMClockError_UnsupportedOperation: OSStatus = -12756;

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmtimebaseerror_missingrequiredparameter?language=objc)
pub const kCMTimebaseError_MissingRequiredParameter: OSStatus = -12748;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmtimebaseerror_invalidparameter?language=objc)
pub const kCMTimebaseError_InvalidParameter: OSStatus = -12749;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmtimebaseerror_allocationfailed?language=objc)
pub const kCMTimebaseError_AllocationFailed: OSStatus = -12750;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmtimebaseerror_timerintervaltooshort?language=objc)
pub const kCMTimebaseError_TimerIntervalTooShort: OSStatus = -12751;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmtimebaseerror_readonly?language=objc)
pub const kCMTimebaseError_ReadOnly: OSStatus = -12757;

/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmsyncerror_missingrequiredparameter?language=objc)
pub const kCMSyncError_MissingRequiredParameter: OSStatus = -12752;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmsyncerror_invalidparameter?language=objc)
pub const kCMSyncError_InvalidParameter: OSStatus = -12753;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmsyncerror_allocationfailed?language=objc)
pub const kCMSyncError_AllocationFailed: OSStatus = -12754;
/// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmsyncerror_ratemustbenonzero?language=objc)
pub const kCMSyncError_RateMustBeNonZero: OSStatus = -12755;

unsafe impl ConcreteType for CMClock {
    /// Returns the CFTypeID for CMClock.
    #[doc(alias = "CMClockGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMClockGetTypeID() -> CFTypeID;
        }
        unsafe { CMClockGetTypeID() }
    }
}

impl CMClock {
    /// Returns a reference to the singleton clock logically identified with host time.
    ///
    /// On Mac OS X, the host time clock uses mach_absolute_time but returns a value
    /// with a large integer timescale (eg, nanoseconds).
    #[doc(alias = "CMClockGetHostTimeClock")]
    #[inline]
    pub unsafe fn host_time_clock() -> CFRetained<CMClock> {
        extern "C-unwind" {
            fn CMClockGetHostTimeClock() -> Option<NonNull<CMClock>>;
        }
        let ret = unsafe { CMClockGetHostTimeClock() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::retain(ret) }
    }

    /// Converts a host time from CMTime to the host time's native units.
    ///
    /// This function performs a scale conversion, not a clock conversion.
    /// It can be more accurate than CMTimeConvertScale because the system units may
    /// have a non-integer timescale.
    /// On Mac OS X, this function converts to the units of mach_absolute_time.
    #[doc(alias = "CMClockConvertHostTimeToSystemUnits")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn convert_host_time_to_system_units(host_time: CMTime) -> u64 {
        extern "C-unwind" {
            fn CMClockConvertHostTimeToSystemUnits(host_time: CMTime) -> u64;
        }
        unsafe { CMClockConvertHostTimeToSystemUnits(host_time) }
    }

    /// Converts a host time from native units to CMTime.
    ///
    /// The returned value will have a large integer timescale (eg, nanoseconds).
    /// This function handles situations where host time's native units use a
    /// non-integer timescale.
    /// On Mac OS X, this function converts from the units of mach_absolute_time.
    #[doc(alias = "CMClockMakeHostTimeFromSystemUnits")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn make_host_time_from_system_units(host_time: u64) -> CMTime {
        extern "C-unwind" {
            fn CMClockMakeHostTimeFromSystemUnits(host_time: u64) -> CMTime;
        }
        unsafe { CMClockMakeHostTimeFromSystemUnits(host_time) }
    }

    /// Retrieves the current time from a clock.
    #[doc(alias = "CMClockGetTime")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn time(&self) -> CMTime {
        extern "C-unwind" {
            fn CMClockGetTime(clock: &CMClock) -> CMTime;
        }
        unsafe { CMClockGetTime(self) }
    }

    /// Retrieves the current time from a clock and also the matching time from the clock's reference clock.
    ///
    /// To make practical use of this, you may need to know what the clock's reference clock is.
    ///
    /// # Safety
    ///
    /// - `clock_time_out` must be a valid pointer.
    /// - `reference_clock_time_out` must be a valid pointer.
    #[doc(alias = "CMClockGetAnchorTime")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn anchor_time(
        &self,
        clock_time_out: NonNull<CMTime>,
        reference_clock_time_out: NonNull<CMTime>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMClockGetAnchorTime(
                clock: &CMClock,
                clock_time_out: NonNull<CMTime>,
                reference_clock_time_out: NonNull<CMTime>,
            ) -> OSStatus;
        }
        unsafe { CMClockGetAnchorTime(self, clock_time_out, reference_clock_time_out) }
    }

    /// Indicates whether it is possible for two clocks to drift relative to each other.
    #[doc(alias = "CMClockMightDrift")]
    #[inline]
    pub unsafe fn might_drift(&self, other_clock: &CMClock) -> bool {
        extern "C-unwind" {
            fn CMClockMightDrift(clock: &CMClock, other_clock: &CMClock) -> Boolean;
        }
        let ret = unsafe { CMClockMightDrift(self, other_clock) };
        ret != 0
    }

    /// Makes the clock stop functioning.
    ///
    /// After invalidation, the clock will return errors from all APIs.
    /// This should only be called by the "owner" of the clock, who knows (for example) that some piece of hardware
    /// has gone away, and the clock will no longer work (and might even crash).
    #[doc(alias = "CMClockInvalidate")]
    #[inline]
    pub unsafe fn invalidate(&self) {
        extern "C-unwind" {
            fn CMClockInvalidate(clock: &CMClock);
        }
        unsafe { CMClockInvalidate(self) }
    }
}

unsafe impl ConcreteType for CMTimebase {
    /// Returns the CFTypeID for CMTimebase.
    #[doc(alias = "CMTimebaseGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CMTimebaseGetTypeID() -> CFTypeID;
        }
        unsafe { CMTimebaseGetTypeID() }
    }
}

impl CMTimebase {
    /// # Safety
    ///
    /// `timebase_out` must be a valid pointer.
    #[doc(alias = "CMTimebaseCreateWithMasterClock")]
    #[deprecated]
    #[inline]
    pub unsafe fn create_with_master_clock(
        allocator: Option<&CFAllocator>,
        master_clock: &CMClock,
        timebase_out: NonNull<*mut CMTimebase>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseCreateWithMasterClock(
                allocator: Option<&CFAllocator>,
                master_clock: &CMClock,
                timebase_out: NonNull<*mut CMTimebase>,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseCreateWithMasterClock(allocator, master_clock, timebase_out) }
    }

    // TODO: pub fn CMTimebaseCreateWithSourceClock(allocator: Option<&CFAllocator>,source_clock: &CMClock,timebase_out: NonNull<*mut CMTimebase>,) -> OSStatus;

    /// # Safety
    ///
    /// `timebase_out` must be a valid pointer.
    #[doc(alias = "CMTimebaseCreateWithMasterTimebase")]
    #[deprecated]
    #[inline]
    pub unsafe fn create_with_master_timebase(
        allocator: Option<&CFAllocator>,
        master_timebase: &CMTimebase,
        timebase_out: NonNull<*mut CMTimebase>,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseCreateWithMasterTimebase(
                allocator: Option<&CFAllocator>,
                master_timebase: &CMTimebase,
                timebase_out: NonNull<*mut CMTimebase>,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseCreateWithMasterTimebase(allocator, master_timebase, timebase_out) }
    }

    // TODO: pub fn CMTimebaseCreateWithSourceTimebase(allocator: Option<&CFAllocator>,source_timebase: &CMTimebase,timebase_out: NonNull<*mut CMTimebase>,) -> OSStatus;

    #[doc(alias = "CMTimebaseCopyMasterTimebase")]
    #[deprecated]
    #[inline]
    pub unsafe fn master_timebase(&self) -> Option<CFRetained<CMTimebase>> {
        extern "C-unwind" {
            fn CMTimebaseCopyMasterTimebase(timebase: &CMTimebase) -> Option<NonNull<CMTimebase>>;
        }
        let ret = unsafe { CMTimebaseCopyMasterTimebase(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    // TODO: pub fn CMTimebaseCopySourceTimebase(timebase: &CMTimebase,)-> Option<NonNull<CMTimebase>>;

    #[doc(alias = "CMTimebaseCopyMasterClock")]
    #[deprecated]
    #[inline]
    pub unsafe fn master_clock(&self) -> Option<CFRetained<CMClock>> {
        extern "C-unwind" {
            fn CMTimebaseCopyMasterClock(timebase: &CMTimebase) -> Option<NonNull<CMClock>>;
        }
        let ret = unsafe { CMTimebaseCopyMasterClock(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    // TODO: pub fn CMTimebaseCopySourceClock(timebase: &CMTimebase,)-> Option<NonNull<CMClock>>;

    #[doc(alias = "CMTimebaseCopyMaster")]
    #[deprecated]
    #[inline]
    pub unsafe fn master(&self) -> CFRetained<CMClockOrTimebase> {
        extern "C-unwind" {
            fn CMTimebaseCopyMaster(timebase: &CMTimebase) -> Option<NonNull<CMClockOrTimebase>>;
        }
        let ret = unsafe { CMTimebaseCopyMaster(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    // TODO: pub fn CMTimebaseCopySource(timebase: &CMTimebase,)-> Option<NonNull<CMClockOrTimebase>>;

    #[doc(alias = "CMTimebaseCopyUltimateMasterClock")]
    #[deprecated]
    #[inline]
    pub unsafe fn ultimate_master_clock(&self) -> CFRetained<CMClock> {
        extern "C-unwind" {
            fn CMTimebaseCopyUltimateMasterClock(timebase: &CMTimebase)
                -> Option<NonNull<CMClock>>;
        }
        let ret = unsafe { CMTimebaseCopyUltimateMasterClock(self) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    // TODO: pub fn CMTimebaseCopyUltimateSourceClock(timebase: &CMTimebase,)-> Option<NonNull<CMClock>>;

    /// Returns the immediate source timebase of a timebase.
    ///
    /// Returns NULL if the timebase actually has a source clock instead of a source timebase.
    /// Please use CMTimebaseCopySourceTimebase instead.
    #[doc(alias = "CMTimebaseGetMasterTimebase")]
    #[deprecated]
    #[inline]
    pub unsafe fn get_master_timebase(&self) -> Option<CFRetained<CMTimebase>> {
        extern "C-unwind" {
            fn CMTimebaseGetMasterTimebase(timebase: &CMTimebase) -> Option<NonNull<CMTimebase>>;
        }
        let ret = unsafe { CMTimebaseGetMasterTimebase(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the immediate source clock of a timebase.
    ///
    /// Returns NULL if the timebase actually has a source timebase instead of a source clock.
    /// Please use CMTimebaseCopySourceClock instead.
    #[doc(alias = "CMTimebaseGetMasterClock")]
    #[deprecated]
    #[inline]
    pub unsafe fn get_master_clock(&self) -> Option<CFRetained<CMClock>> {
        extern "C-unwind" {
            fn CMTimebaseGetMasterClock(timebase: &CMTimebase) -> Option<NonNull<CMClock>>;
        }
        let ret = unsafe { CMTimebaseGetMasterClock(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the immediate source (either timebase or clock) of a timebase.
    ///
    /// Only returns NULL if there was an error (such as timebase == NULL).
    /// Example of use: time = CMSyncGetTime(CMTimebaseGetMaster(timebase));
    /// Please use CMTimebaseCopySource instead.
    #[doc(alias = "CMTimebaseGetMaster")]
    #[deprecated]
    #[inline]
    pub unsafe fn get_master(&self) -> Option<CFRetained<CMClockOrTimebase>> {
        extern "C-unwind" {
            fn CMTimebaseGetMaster(timebase: &CMTimebase) -> Option<NonNull<CMClockOrTimebase>>;
        }
        let ret = unsafe { CMTimebaseGetMaster(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the source clock that is the source of all of a timebase's source timebases.
    ///
    /// Please use CMTimebaseCopyUltimateSourceClock instead.
    #[doc(alias = "CMTimebaseGetUltimateMasterClock")]
    #[deprecated]
    #[inline]
    pub unsafe fn get_ultimate_master_clock(&self) -> Option<CFRetained<CMClock>> {
        extern "C-unwind" {
            fn CMTimebaseGetUltimateMasterClock(timebase: &CMTimebase) -> Option<NonNull<CMClock>>;
        }
        let ret = unsafe { CMTimebaseGetUltimateMasterClock(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CMTimebaseSetMasterClock")]
    #[deprecated]
    #[inline]
    pub unsafe fn set_master_clock(&self, new_master_clock: &CMClock) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetMasterClock(
                timebase: &CMTimebase,
                new_master_clock: &CMClock,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseSetMasterClock(self, new_master_clock) }
    }

    // TODO: pub fn CMTimebaseSetSourceClock(timebase: &CMTimebase,new_source_clock: &CMClock,) -> OSStatus;

    #[doc(alias = "CMTimebaseSetMasterTimebase")]
    #[deprecated]
    #[inline]
    pub unsafe fn set_master_timebase(&self, new_master_timebase: &CMTimebase) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetMasterTimebase(
                timebase: &CMTimebase,
                new_master_timebase: &CMTimebase,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseSetMasterTimebase(self, new_master_timebase) }
    }

    // TODO: pub fn CMTimebaseSetSourceTimebase(timebase: &CMTimebase,new_source_timebase: &CMTimebase,) -> OSStatus;

    /// Retrieves the current time from a timebase.
    #[doc(alias = "CMTimebaseGetTime")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn time(&self) -> CMTime {
        extern "C-unwind" {
            fn CMTimebaseGetTime(timebase: &CMTimebase) -> CMTime;
        }
        unsafe { CMTimebaseGetTime(self) }
    }

    /// Retrieves the current time from a timebase in the specified timescale.
    #[doc(alias = "CMTimebaseGetTimeWithTimeScale")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn time_with_time_scale(
        &self,
        timescale: CMTimeScale,
        method: CMTimeRoundingMethod,
    ) -> CMTime {
        extern "C-unwind" {
            fn CMTimebaseGetTimeWithTimeScale(
                timebase: &CMTimebase,
                timescale: CMTimeScale,
                method: CMTimeRoundingMethod,
            ) -> CMTime;
        }
        unsafe { CMTimebaseGetTimeWithTimeScale(self, timescale, method) }
    }

    /// Sets the current time of a timebase.
    #[doc(alias = "CMTimebaseSetTime")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn set_time(&self, time: CMTime) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetTime(timebase: &CMTimebase, time: CMTime) -> OSStatus;
        }
        unsafe { CMTimebaseSetTime(self, time) }
    }

    /// Sets the time of a timebase at a particular source time.
    ///
    /// CMTimebaseGetTime's results will be interpolated from that anchor time.
    /// CMTimebaseSetTime(timebase, time) is equivalent to calling
    /// CMClockOrTimebaseRef source = CMTimebaseCopySource(timebase);
    /// CMTimebaseSetAnchorTime(timebase, time, CMSyncGetTime(source));
    /// CFRelease(source).
    #[doc(alias = "CMTimebaseSetAnchorTime")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn set_anchor_time(
        &self,
        timebase_time: CMTime,
        immediate_source_time: CMTime,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetAnchorTime(
                timebase: &CMTimebase,
                timebase_time: CMTime,
                immediate_source_time: CMTime,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseSetAnchorTime(self, timebase_time, immediate_source_time) }
    }

    /// Retrieves the current rate of a timebase.
    ///
    /// This is the rate relative to its immediate source clock or timebase.
    /// For example, if a timebase is running at twice the rate of its source, its rate is 2.0.
    #[doc(alias = "CMTimebaseGetRate")]
    #[inline]
    pub unsafe fn rate(&self) -> f64 {
        extern "C-unwind" {
            fn CMTimebaseGetRate(timebase: &CMTimebase) -> f64;
        }
        unsafe { CMTimebaseGetRate(self) }
    }

    /// Retrieves the current time and rate of a timebase.
    ///
    /// You can use this function to take a consistent snapshot of the two values,
    /// avoiding possible inconsistencies due to external changes between retrieval of time and rate.
    ///
    /// # Safety
    ///
    /// - `time_out` must be a valid pointer or null.
    /// - `rate_out` must be a valid pointer or null.
    #[doc(alias = "CMTimebaseGetTimeAndRate")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn time_and_rate(&self, time_out: *mut CMTime, rate_out: *mut f64) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseGetTimeAndRate(
                timebase: &CMTimebase,
                time_out: *mut CMTime,
                rate_out: *mut f64,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseGetTimeAndRate(self, time_out, rate_out) }
    }

    /// Sets the rate of a timebase.
    #[doc(alias = "CMTimebaseSetRate")]
    #[inline]
    pub unsafe fn set_rate(&self, rate: f64) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetRate(timebase: &CMTimebase, rate: f64) -> OSStatus;
        }
        unsafe { CMTimebaseSetRate(self, rate) }
    }

    /// Sets the time of a timebase at a particular source time, and changes the rate at exactly that time.
    ///
    /// CMTimebaseGetTime's results will be interpolated from that anchor time as though the timebase
    /// has been running at the requested rate since that time.
    /// CMTimebaseSetRate(timebase, rate) is approximately equivalent to calling
    /// CMClockOrTimebaseRef source = CMTimebaseCopySource(timebase);
    /// CMTimebaseSetRateAndAnchorTime(timebase, rate, CMTimebaseGetTime(timebase), CMSyncGetTime(source)),
    /// CFRelease(source);
    /// except that CMTimebaseSetRate will not generate a TimeJumped notification, and
    /// CMTimebaseSetRateAndAnchorTime will.
    #[doc(alias = "CMTimebaseSetRateAndAnchorTime")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn set_rate_and_anchor_time(
        &self,
        rate: f64,
        timebase_time: CMTime,
        immediate_source_time: CMTime,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetRateAndAnchorTime(
                timebase: &CMTimebase,
                rate: f64,
                timebase_time: CMTime,
                immediate_source_time: CMTime,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseSetRateAndAnchorTime(self, rate, timebase_time, immediate_source_time) }
    }

    /// Gets the effective rate of a timebase (which combines its rate with the rates of all its source timebases).
    ///
    /// Calling CMTimebaseGetEffectiveRate(timebase) is equivalent to calling
    /// CMClockRef clock = CMTimebaseCopyUltimateSourceClock(timebase);
    /// CMSyncGetRelativeRate(timebase, clock).
    /// CFRelease(clock);
    #[doc(alias = "CMTimebaseGetEffectiveRate")]
    #[inline]
    pub unsafe fn effective_rate(&self) -> f64 {
        extern "C-unwind" {
            fn CMTimebaseGetEffectiveRate(timebase: &CMTimebase) -> f64;
        }
        unsafe { CMTimebaseGetEffectiveRate(self) }
    }

    /// Adds the timer to the list of timers managed by the timebase.
    ///
    /// The timer must be a repeating run loop timer (with a very long interval at
    /// least as long as kCMTimebaseVeryLongCFTimeInterval), attached to a runloop.
    /// The timebase will retain the timer, and will maintain its "NextFireDate"
    /// according to the CMTime set using CMTimebaseSetTimerNextFireTime.
    /// Until the first call to CMTimebaseSetTimerNextFireTime, the "NextFireDate"
    /// will be set far, far in the future. The runloop that timer is attached to must be
    /// passed in and the timebase will retain that runloop. The retained runloop will be
    /// used to call CFRunLoopWakeUp() any time the timebase modifies the timer's fire date.
    ///
    /// # Safety
    ///
    /// `runloop` possibly has additional threading requirements.
    #[doc(alias = "CMTimebaseAddTimer")]
    #[inline]
    pub unsafe fn add_timer(&self, timer: &CFRunLoopTimer, runloop: &CFRunLoop) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseAddTimer(
                timebase: &CMTimebase,
                timer: &CFRunLoopTimer,
                runloop: &CFRunLoop,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseAddTimer(self, timer, runloop) }
    }

    /// Removes the timer from the list of timers managed by the timebase.
    ///
    /// The timebase will no longer maintain the timer's "NextFireDate".
    /// If the timer is invalidated, the timebase will eventually remove it
    /// from its list and release it even if this function is not called.
    #[doc(alias = "CMTimebaseRemoveTimer")]
    #[inline]
    pub unsafe fn remove_timer(&self, timer: &CFRunLoopTimer) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseRemoveTimer(timebase: &CMTimebase, timer: &CFRunLoopTimer) -> OSStatus;
        }
        unsafe { CMTimebaseRemoveTimer(self, timer) }
    }

    /// Sets the CMTime on the timebase's timeline at which the timer should next be fired.
    ///
    /// The timer must be on the list of timers managed by the timebase.
    /// The timebase will continue to update the timer's "NextFireDate" according to time jumps
    /// and effective rate changes.
    /// If fireTime is not numeric, or if the timebase is not moving, the "NextFireDate"
    /// will be set to a date far, far in the future.
    /// <BR
    /// >
    /// IMPORTANT NOTE: Due to the way that CFRunLoopTimers are implemented, if a timer passes
    /// through a state in which it is due to fire, it may fire even if its rescheduled before
    /// the runloop runs again.  Clients should take care to avoid temporarily scheduling timers
    /// in the past.  For example, set the timebase's rate or time before you set the timer's
    /// next fire time, if you are doing both at once.  (If setting the timebase's rate or time
    /// might put the timer's fire time in the past, you may need to set the fire time to
    /// kCMTimeInvalid across the timebase change.)
    #[doc(alias = "CMTimebaseSetTimerNextFireTime")]
    #[cfg(feature = "CMTime")]
    #[inline]
    pub unsafe fn set_timer_next_fire_time(
        &self,
        timer: &CFRunLoopTimer,
        fire_time: CMTime,
        flags: u32,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetTimerNextFireTime(
                timebase: &CMTimebase,
                timer: &CFRunLoopTimer,
                fire_time: CMTime,
                flags: u32,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseSetTimerNextFireTime(self, timer, fire_time, flags) }
    }

    /// Sets the timer to fire immediately once, overriding any previous CMTimebaseSetTimerNextFireTime call.
    ///
    /// The timer must be on the list of timers managed by the timebase.
    /// This is equivalent to calling
    /// CFRunLoopTimerSetNextFireDate( timer, CFAbsoluteTimeGetCurrent() );
    /// except that the timebase gets to know that it shouldn't interfere.
    #[doc(alias = "CMTimebaseSetTimerToFireImmediately")]
    #[inline]
    pub unsafe fn set_timer_to_fire_immediately(&self, timer: &CFRunLoopTimer) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetTimerToFireImmediately(
                timebase: &CMTimebase,
                timer: &CFRunLoopTimer,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseSetTimerToFireImmediately(self, timer) }
    }

    /// Adds the timer dispatch source to the list of timers managed by the timebase.
    ///
    /// The timer source must have been created by calling
    /// dispatch_source_create( DISPATCH_SOURCE_TYPE_TIMER, 0, 0, some_dispatch_queue )
    /// and should have had an event handler associated with it via
    /// dispatch_source_set_event_handler( timerSource, some_handler_block )
    /// or dispatch_source_set_event_handler_f( timerSource, some_handler_function ).
    /// Don't forget to call dispatch_resume( timerSource ) as dispatch sources are
    /// created suspended.
    ///
    /// The timebase will retain the timer source, and will maintain its start time
    /// according to the CMTime set using CMTimebaseSetTimerDispatchSourceNextFireTime.
    /// Until the first call to CMTimebaseSetTimerDispatchSourceNextFireTime, the start time
    /// will be set to DISPATCH_TIME_FOREVER.
    #[doc(alias = "CMTimebaseAddTimerDispatchSource")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn add_timer_dispatch_source(&self, timer_source: &DispatchSource) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseAddTimerDispatchSource(
                timebase: &CMTimebase,
                timer_source: &DispatchSource,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseAddTimerDispatchSource(self, timer_source) }
    }

    /// Removes the timer dispatch source from the list of timers managed by the timebase.
    ///
    /// The timebase will no longer maintain the timer source's start time.
    /// If the timer source is cancelled, the timebase will eventually remove it
    /// from its list and release it even if this function is not called.
    #[doc(alias = "CMTimebaseRemoveTimerDispatchSource")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn remove_timer_dispatch_source(&self, timer_source: &DispatchSource) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseRemoveTimerDispatchSource(
                timebase: &CMTimebase,
                timer_source: &DispatchSource,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseRemoveTimerDispatchSource(self, timer_source) }
    }

    /// Sets the CMTime on the timebase's timeline at which the timer dispatch source should next be fired.
    ///
    /// The timer source must be on the list of timers managed by the timebase.
    /// The timebase will continue to update the timer dispatch source's start time
    /// according to time jumps and effective rate changes.
    /// If fireTime is not numeric, or if the timebase is not moving, the start time
    /// will be set to DISPATCH_TIME_FOREVER.
    /// <BR
    /// >
    /// IMPORTANT NOTE: Due to the way that timer dispatch sources are implemented, if a timer passes
    /// through a state in which it is due to fire, it may fire even if its rescheduled before
    /// the event handler is run.  Clients should take care to avoid temporarily scheduling timers
    /// in the past.  For example, set the timebase's rate or time before you set the timer's
    /// next fire time, if you are doing both at once.  (If setting the timebase's rate or time
    /// might put the timer's fire time in the past, you may need to set the fire time to
    /// kCMTimeInvalid across the timebase change.)
    #[doc(alias = "CMTimebaseSetTimerDispatchSourceNextFireTime")]
    #[cfg(all(feature = "CMTime", feature = "dispatch2"))]
    #[inline]
    pub unsafe fn set_timer_dispatch_source_next_fire_time(
        &self,
        timer_source: &DispatchSource,
        fire_time: CMTime,
        flags: u32,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetTimerDispatchSourceNextFireTime(
                timebase: &CMTimebase,
                timer_source: &DispatchSource,
                fire_time: CMTime,
                flags: u32,
            ) -> OSStatus;
        }
        unsafe {
            CMTimebaseSetTimerDispatchSourceNextFireTime(self, timer_source, fire_time, flags)
        }
    }

    /// Sets the timer dispatch source to fire immediately once, overriding any previous
    /// CMTimebaseSetTimerDispatchSourceNextFireTime call.
    ///
    /// The timer source must be on the list of timers managed by the timebase.
    /// This is equivalent to calling
    /// dispatch_source_set_timer( timerSource, DISPATCH_TIME_NOW, 0, 0 );
    /// except that the timebase gets to know that it shouldn't interfere.
    #[doc(alias = "CMTimebaseSetTimerDispatchSourceToFireImmediately")]
    #[cfg(feature = "dispatch2")]
    #[inline]
    pub unsafe fn set_timer_dispatch_source_to_fire_immediately(
        &self,
        timer_source: &DispatchSource,
    ) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseSetTimerDispatchSourceToFireImmediately(
                timebase: &CMTimebase,
                timer_source: &DispatchSource,
            ) -> OSStatus;
        }
        unsafe { CMTimebaseSetTimerDispatchSourceToFireImmediately(self, timer_source) }
    }
}

extern "C-unwind" {
    /// Queries the relative rate of one timebase or clock relative to another timebase or clock.
    ///
    /// If both have a common source, this calculation is performed purely based on the rates in the common tree
    /// rooted in that source.
    /// If they have different source clocks (or are both clocks), this calculation takes into account the measured
    /// drift between the two clocks, using host time as a pivot.
    /// The rate of a moving timebase relative to a stopped timebase is a NaN.
    /// Calling CMTimebaseGetEffectiveRate(timebase) is equivalent to calling
    /// CMClockRef clock = CMTimebaseCopyUltimateSourceClock(timebase);
    /// CMSyncGetRelativeRate(timebase, clock).
    /// CFRelease(clock);
    ///
    /// # Safety
    ///
    /// - `of_clock_or_timebase` should be of the correct type.
    /// - `relative_to_clock_or_timebase` should be of the correct type.
    pub fn CMSyncGetRelativeRate(
        of_clock_or_timebase: &CMClockOrTimebase,
        relative_to_clock_or_timebase: &CMClockOrTimebase,
    ) -> f64;
}

extern "C-unwind" {
    /// Queries the relative rate of one timebase or clock relative to another timebase or clock and the times of each timebase or clock at which the relative rate went into effect.
    ///
    /// If both have a common source, this calculation is performed purely based on the rates in the common tree
    /// rooted in that source.
    /// If they have different source clocks (or are both clocks), this calculation takes into account the measured
    /// drift between the two clocks, using host time as a pivot.
    /// The rate of a moving timebase relative to a stopped timebase is a NaN.
    ///
    /// # Safety
    ///
    /// - `of_clock_or_timebase` should be of the correct type.
    /// - `relative_to_clock_or_timebase` should be of the correct type.
    /// - `out_relative_rate` must be a valid pointer or null.
    /// - `out_of_clock_or_timebase_anchor_time` must be a valid pointer or null.
    /// - `out_relative_to_clock_or_timebase_anchor_time` must be a valid pointer or null.
    #[cfg(feature = "CMTime")]
    pub fn CMSyncGetRelativeRateAndAnchorTime(
        of_clock_or_timebase: &CMClockOrTimebase,
        relative_to_clock_or_timebase: &CMClockOrTimebase,
        out_relative_rate: *mut f64,
        out_of_clock_or_timebase_anchor_time: *mut CMTime,
        out_relative_to_clock_or_timebase_anchor_time: *mut CMTime,
    ) -> OSStatus;
}

extern "C-unwind" {
    /// Converts a time from one timebase or clock to another timebase or clock.
    ///
    /// If both have a common source, this calculation is performed purely based on the mathematical rates and offsets
    /// in the common tree rooted in that source.
    /// If they have different source clocks (or are both clocks), this calculation also compensates
    /// for measured drift between the clocks.
    /// To convert to or from host time, pass CMClockGetHostTimeClock() as the appropriate argument.
    ///
    /// # Safety
    ///
    /// - `from_clock_or_timebase` should be of the correct type.
    /// - `to_clock_or_timebase` should be of the correct type.
    #[cfg(feature = "CMTime")]
    pub fn CMSyncConvertTime(
        time: CMTime,
        from_clock_or_timebase: &CMClockOrTimebase,
        to_clock_or_timebase: &CMClockOrTimebase,
    ) -> CMTime;
}

/// Reports whether it is possible for one timebase/clock to drift relative to the other.
///
/// A timebase can drift relative to another if their ultimate source clocks that can drift relative
/// to each other.
///
/// # Safety
///
/// - `clock_or_timebase1` should be of the correct type.
/// - `clock_or_timebase2` should be of the correct type.
#[inline]
pub unsafe extern "C-unwind" fn CMSyncMightDrift(
    clock_or_timebase1: &CMClockOrTimebase,
    clock_or_timebase2: &CMClockOrTimebase,
) -> bool {
    extern "C-unwind" {
        fn CMSyncMightDrift(
            clock_or_timebase1: &CMClockOrTimebase,
            clock_or_timebase2: &CMClockOrTimebase,
        ) -> Boolean;
    }
    let ret = unsafe { CMSyncMightDrift(clock_or_timebase1, clock_or_timebase2) };
    ret != 0
}

extern "C-unwind" {
    /// A helper function to get time from a clock or timebase.
    ///
    /// CMSyncGetTime simply calls either CMClockGetTime or CMTimebaseGetTime, as appropriate.
    /// It comes in handy for things like:
    /// CMClockOrTimebaseRef source = CMTimebaseCopySource(timebase);
    /// CMSyncGetTime(source);
    /// CFRelease(source);
    ///
    /// # Safety
    ///
    /// `clock_or_timebase` should be of the correct type.
    #[cfg(feature = "CMTime")]
    pub fn CMSyncGetTime(clock_or_timebase: &CMClockOrTimebase) -> CMTime;
}

impl CMTimebase {
    /// Requests that the timebase wait until it is not posting any notifications.
    #[doc(alias = "CMTimebaseNotificationBarrier")]
    #[inline]
    pub unsafe fn notification_barrier(&self) -> OSStatus {
        extern "C-unwind" {
            fn CMTimebaseNotificationBarrier(timebase: &CMTimebase) -> OSStatus;
        }
        unsafe { CMTimebaseNotificationBarrier(self) }
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmtimebasenotification_effectiveratechanged?language=objc)
    pub static kCMTimebaseNotification_EffectiveRateChanged: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmtimebasenotification_timejumped?language=objc)
    pub static kCMTimebaseNotification_TimeJumped: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/coremedia/kcmtimebasenotificationkey_eventtime?language=objc)
    pub static kCMTimebaseNotificationKey_EventTime: &'static CFString;
}

#[deprecated = "renamed to `CMClock::host_time_clock`"]
#[inline]
pub unsafe extern "C-unwind" fn CMClockGetHostTimeClock() -> CFRetained<CMClock> {
    extern "C-unwind" {
        fn CMClockGetHostTimeClock() -> Option<NonNull<CMClock>>;
    }
    let ret = unsafe { CMClockGetHostTimeClock() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::retain(ret) }
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMClock::convert_host_time_to_system_units`"]
    pub fn CMClockConvertHostTimeToSystemUnits(host_time: CMTime) -> u64;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMClock::make_host_time_from_system_units`"]
    pub fn CMClockMakeHostTimeFromSystemUnits(host_time: u64) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMClock::time`"]
    pub fn CMClockGetTime(clock: &CMClock) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMClock::anchor_time`"]
    pub fn CMClockGetAnchorTime(
        clock: &CMClock,
        clock_time_out: NonNull<CMTime>,
        reference_clock_time_out: NonNull<CMTime>,
    ) -> OSStatus;
}

#[deprecated = "renamed to `CMClock::might_drift`"]
#[inline]
pub unsafe extern "C-unwind" fn CMClockMightDrift(clock: &CMClock, other_clock: &CMClock) -> bool {
    extern "C-unwind" {
        fn CMClockMightDrift(clock: &CMClock, other_clock: &CMClock) -> Boolean;
    }
    let ret = unsafe { CMClockMightDrift(clock, other_clock) };
    ret != 0
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMClock::invalidate`"]
    pub fn CMClockInvalidate(clock: &CMClock);
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::create_with_master_clock`"]
    pub fn CMTimebaseCreateWithMasterClock(
        allocator: Option<&CFAllocator>,
        master_clock: &CMClock,
        timebase_out: NonNull<*mut CMTimebase>,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::create_with_master_timebase`"]
    pub fn CMTimebaseCreateWithMasterTimebase(
        allocator: Option<&CFAllocator>,
        master_timebase: &CMTimebase,
        timebase_out: NonNull<*mut CMTimebase>,
    ) -> OSStatus;
}

#[deprecated = "renamed to `CMTimebase::master_timebase`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimebaseCopyMasterTimebase(
    timebase: &CMTimebase,
) -> Option<CFRetained<CMTimebase>> {
    extern "C-unwind" {
        fn CMTimebaseCopyMasterTimebase(timebase: &CMTimebase) -> Option<NonNull<CMTimebase>>;
    }
    let ret = unsafe { CMTimebaseCopyMasterTimebase(timebase) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CMTimebase::master_clock`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimebaseCopyMasterClock(
    timebase: &CMTimebase,
) -> Option<CFRetained<CMClock>> {
    extern "C-unwind" {
        fn CMTimebaseCopyMasterClock(timebase: &CMTimebase) -> Option<NonNull<CMClock>>;
    }
    let ret = unsafe { CMTimebaseCopyMasterClock(timebase) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CMTimebase::master`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimebaseCopyMaster(
    timebase: &CMTimebase,
) -> CFRetained<CMClockOrTimebase> {
    extern "C-unwind" {
        fn CMTimebaseCopyMaster(timebase: &CMTimebase) -> Option<NonNull<CMClockOrTimebase>>;
    }
    let ret = unsafe { CMTimebaseCopyMaster(timebase) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CMTimebase::ultimate_master_clock`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimebaseCopyUltimateMasterClock(
    timebase: &CMTimebase,
) -> CFRetained<CMClock> {
    extern "C-unwind" {
        fn CMTimebaseCopyUltimateMasterClock(timebase: &CMTimebase) -> Option<NonNull<CMClock>>;
    }
    let ret = unsafe { CMTimebaseCopyUltimateMasterClock(timebase) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CMTimebase::get_master_timebase`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimebaseGetMasterTimebase(
    timebase: &CMTimebase,
) -> Option<CFRetained<CMTimebase>> {
    extern "C-unwind" {
        fn CMTimebaseGetMasterTimebase(timebase: &CMTimebase) -> Option<NonNull<CMTimebase>>;
    }
    let ret = unsafe { CMTimebaseGetMasterTimebase(timebase) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CMTimebase::get_master_clock`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimebaseGetMasterClock(
    timebase: &CMTimebase,
) -> Option<CFRetained<CMClock>> {
    extern "C-unwind" {
        fn CMTimebaseGetMasterClock(timebase: &CMTimebase) -> Option<NonNull<CMClock>>;
    }
    let ret = unsafe { CMTimebaseGetMasterClock(timebase) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CMTimebase::get_master`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimebaseGetMaster(
    timebase: &CMTimebase,
) -> Option<CFRetained<CMClockOrTimebase>> {
    extern "C-unwind" {
        fn CMTimebaseGetMaster(timebase: &CMTimebase) -> Option<NonNull<CMClockOrTimebase>>;
    }
    let ret = unsafe { CMTimebaseGetMaster(timebase) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

#[deprecated = "renamed to `CMTimebase::get_ultimate_master_clock`"]
#[inline]
pub unsafe extern "C-unwind" fn CMTimebaseGetUltimateMasterClock(
    timebase: &CMTimebase,
) -> Option<CFRetained<CMClock>> {
    extern "C-unwind" {
        fn CMTimebaseGetUltimateMasterClock(timebase: &CMTimebase) -> Option<NonNull<CMClock>>;
    }
    let ret = unsafe { CMTimebaseGetUltimateMasterClock(timebase) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::set_master_clock`"]
    pub fn CMTimebaseSetMasterClock(timebase: &CMTimebase, new_master_clock: &CMClock) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::set_master_timebase`"]
    pub fn CMTimebaseSetMasterTimebase(
        timebase: &CMTimebase,
        new_master_timebase: &CMTimebase,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimebase::time`"]
    pub fn CMTimebaseGetTime(timebase: &CMTimebase) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimebase::time_with_time_scale`"]
    pub fn CMTimebaseGetTimeWithTimeScale(
        timebase: &CMTimebase,
        timescale: CMTimeScale,
        method: CMTimeRoundingMethod,
    ) -> CMTime;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimebase::set_time`"]
    pub fn CMTimebaseSetTime(timebase: &CMTimebase, time: CMTime) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimebase::set_anchor_time`"]
    pub fn CMTimebaseSetAnchorTime(
        timebase: &CMTimebase,
        timebase_time: CMTime,
        immediate_source_time: CMTime,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::rate`"]
    pub fn CMTimebaseGetRate(timebase: &CMTimebase) -> f64;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimebase::time_and_rate`"]
    pub fn CMTimebaseGetTimeAndRate(
        timebase: &CMTimebase,
        time_out: *mut CMTime,
        rate_out: *mut f64,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::set_rate`"]
    pub fn CMTimebaseSetRate(timebase: &CMTimebase, rate: f64) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimebase::set_rate_and_anchor_time`"]
    pub fn CMTimebaseSetRateAndAnchorTime(
        timebase: &CMTimebase,
        rate: f64,
        timebase_time: CMTime,
        immediate_source_time: CMTime,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::effective_rate`"]
    pub fn CMTimebaseGetEffectiveRate(timebase: &CMTimebase) -> f64;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::add_timer`"]
    pub fn CMTimebaseAddTimer(
        timebase: &CMTimebase,
        timer: &CFRunLoopTimer,
        runloop: &CFRunLoop,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::remove_timer`"]
    pub fn CMTimebaseRemoveTimer(timebase: &CMTimebase, timer: &CFRunLoopTimer) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "CMTime")]
    #[deprecated = "renamed to `CMTimebase::set_timer_next_fire_time`"]
    pub fn CMTimebaseSetTimerNextFireTime(
        timebase: &CMTimebase,
        timer: &CFRunLoopTimer,
        fire_time: CMTime,
        flags: u32,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::set_timer_to_fire_immediately`"]
    pub fn CMTimebaseSetTimerToFireImmediately(
        timebase: &CMTimebase,
        timer: &CFRunLoopTimer,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `CMTimebase::add_timer_dispatch_source`"]
    pub fn CMTimebaseAddTimerDispatchSource(
        timebase: &CMTimebase,
        timer_source: &DispatchSource,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `CMTimebase::remove_timer_dispatch_source`"]
    pub fn CMTimebaseRemoveTimerDispatchSource(
        timebase: &CMTimebase,
        timer_source: &DispatchSource,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(all(feature = "CMTime", feature = "dispatch2"))]
    #[deprecated = "renamed to `CMTimebase::set_timer_dispatch_source_next_fire_time`"]
    pub fn CMTimebaseSetTimerDispatchSourceNextFireTime(
        timebase: &CMTimebase,
        timer_source: &DispatchSource,
        fire_time: CMTime,
        flags: u32,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[cfg(feature = "dispatch2")]
    #[deprecated = "renamed to `CMTimebase::set_timer_dispatch_source_to_fire_immediately`"]
    pub fn CMTimebaseSetTimerDispatchSourceToFireImmediately(
        timebase: &CMTimebase,
        timer_source: &DispatchSource,
    ) -> OSStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CMTimebase::notification_barrier`"]
    pub fn CMTimebaseNotificationBarrier(timebase: &CMTimebase) -> OSStatus;
}
