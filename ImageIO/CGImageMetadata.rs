//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;

use crate::*;

/// an immutable container for CGImageMetadataTags
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/imageio/cgimagemetadata?language=objc)
#[doc(alias = "CGImageMetadataRef")]
#[repr(C)]
pub struct CGImageMetadata {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGImageMetadata {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGImageMetadata"> for CGImageMetadata {}
);

unsafe impl ConcreteType for CGImageMetadata {
    /// *!
    ///
    ///
    ///
    /// Gets the type identifier for the CGImageMetadata opaque type
    ///
    /// Returns: the type identifier for the CGImageMetadata opaque type
    #[doc(alias = "CGImageMetadataGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGImageMetadataGetTypeID() -> CFTypeID;
        }
        unsafe { CGImageMetadataGetTypeID() }
    }
}

/// a mutable container for CGImageMetadataTags
///
/// A CGMutableImageMetadataRef can be used in any function that
/// accepts a CGImageMetadataRef.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/imageio/cgmutableimagemetadata?language=objc)
#[doc(alias = "CGMutableImageMetadataRef")]
#[repr(C)]
pub struct CGMutableImageMetadata {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGMutableImageMetadata: CGImageMetadata {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGImageMetadata"> for CGMutableImageMetadata {}
);

impl CGMutableImageMetadata {
    /// Creates an empty CGMutableImageMetadataRef
    #[doc(alias = "CGImageMetadataCreateMutable")]
    #[inline]
    pub unsafe fn new() -> CFRetained<CGMutableImageMetadata> {
        extern "C-unwind" {
            fn CGImageMetadataCreateMutable() -> Option<NonNull<CGMutableImageMetadata>>;
        }
        let ret = unsafe { CGImageMetadataCreateMutable() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates a deep mutable copy of another CGImageMetadataRef
    ///
    /// Before modifying an immutable CGImageMetadataRef (such as metadata
    /// from CGImageSourceCopyMetadataAtIndex) you must first make a copy.
    /// This function makes a deep copy of all CGImageMetadataTags and their values.
    #[doc(alias = "CGImageMetadataCreateMutableCopy")]
    #[inline]
    pub unsafe fn new_copy(
        metadata: &CGImageMetadata,
    ) -> Option<CFRetained<CGMutableImageMetadata>> {
        extern "C-unwind" {
            fn CGImageMetadataCreateMutableCopy(
                metadata: &CGImageMetadata,
            ) -> Option<NonNull<CGMutableImageMetadata>>;
        }
        let ret = unsafe { CGImageMetadataCreateMutableCopy(metadata) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

/// an individual metadata tag
///
/// A CGImageMetadataTag encapsulates an EXIF, IPTC, or XMP property.
/// All tags contain a namespace, prefix, name, type, and value. Please see
///
/// ```text
///  CGImageMetadataTagCreate
/// ```
///
/// for more details.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/imageio/cgimagemetadatatag?language=objc)
#[doc(alias = "CGImageMetadataTagRef")]
#[repr(C)]
pub struct CGImageMetadataTag {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGImageMetadataTag {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGImageMetadataTag"> for CGImageMetadataTag {}
);

unsafe impl ConcreteType for CGImageMetadataTag {
    /// *!
    ///
    ///
    ///
    /// Gets the type identifier for the CGImageMetadataTag opaque type
    ///
    /// Returns: the type identifier for the CGImageMetadataTagGetTypeID opaque type
    #[doc(alias = "CGImageMetadataTagGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGImageMetadataTagGetTypeID() -> CFTypeID;
        }
        unsafe { CGImageMetadataTagGetTypeID() }
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespaceexif?language=objc)
    pub static kCGImageMetadataNamespaceExif: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespaceexifaux?language=objc)
    pub static kCGImageMetadataNamespaceExifAux: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespaceexifex?language=objc)
    pub static kCGImageMetadataNamespaceExifEX: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespacedublincore?language=objc)
    pub static kCGImageMetadataNamespaceDublinCore: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespaceiptccore?language=objc)
    pub static kCGImageMetadataNamespaceIPTCCore: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespaceiptcextension?language=objc)
    pub static kCGImageMetadataNamespaceIPTCExtension: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespacephotoshop?language=objc)
    pub static kCGImageMetadataNamespacePhotoshop: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespacetiff?language=objc)
    pub static kCGImageMetadataNamespaceTIFF: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespacexmpbasic?language=objc)
    pub static kCGImageMetadataNamespaceXMPBasic: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadatanamespacexmprights?language=objc)
    pub static kCGImageMetadataNamespaceXMPRights: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixexif?language=objc)
    pub static kCGImageMetadataPrefixExif: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixexifaux?language=objc)
    pub static kCGImageMetadataPrefixExifAux: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixexifex?language=objc)
    pub static kCGImageMetadataPrefixExifEX: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixdublincore?language=objc)
    pub static kCGImageMetadataPrefixDublinCore: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixiptccore?language=objc)
    pub static kCGImageMetadataPrefixIPTCCore: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixiptcextension?language=objc)
    pub static kCGImageMetadataPrefixIPTCExtension: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixphotoshop?language=objc)
    pub static kCGImageMetadataPrefixPhotoshop: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixtiff?language=objc)
    pub static kCGImageMetadataPrefixTIFF: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixxmpbasic?language=objc)
    pub static kCGImageMetadataPrefixXMPBasic: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataprefixxmprights?language=objc)
    pub static kCGImageMetadataPrefixXMPRights: &'static CFString;
}

/// The XMP type for a CGImageMetadataTag
///
/// CGImageMetadataType defines a list of constants used to indicate
/// the type for a CGImageMetadataTag. If you are reading metadata, use the type
/// to determine how to interpret the CGImageMetadataTag's value. If you are
/// creating a CGImageMetadataTag, use the type to specify how the tag
/// should be serialized in XMP. String types have CFStringRef values, array
/// types have CFArray values, and structure types have CFDictionary values.
///
/// CFType of the tag's value. This is only used when creating a new
/// CGImageMetadataTag - no existing tags should have this value. CFString
/// defaults to kCGImageMetadataTypeString, CFArray defaults to
/// kCGImageMetadataTypeArrayOrdered, and CFDictionary defaults to
/// kCGImageMetadataTypeStructure.
///
/// values will be converted to a string.
///
/// Serialized in XMP as
/// <rdf
/// :Bag>.
///
/// Serialized in XMP as
/// <rdf
/// :Seq>.
///
/// are alternates for the same value. Serialized in XMP as
/// <rdf
/// :Alt>.
///
/// where all elements are different localized strings for the same value.
/// Serialized in XMP as an alternate array of strings with xml:lang qualifiers.
///
/// array elements, fields of a structure may belong to different namespaces.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/imageio/cgimagemetadatatype?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGImageMetadataType(pub i32);
impl CGImageMetadataType {
    #[doc(alias = "kCGImageMetadataTypeInvalid")]
    pub const Invalid: Self = Self(-1);
    #[doc(alias = "kCGImageMetadataTypeDefault")]
    pub const Default: Self = Self(0);
    #[doc(alias = "kCGImageMetadataTypeString")]
    pub const String: Self = Self(1);
    #[doc(alias = "kCGImageMetadataTypeArrayUnordered")]
    pub const ArrayUnordered: Self = Self(2);
    #[doc(alias = "kCGImageMetadataTypeArrayOrdered")]
    pub const ArrayOrdered: Self = Self(3);
    #[doc(alias = "kCGImageMetadataTypeAlternateArray")]
    pub const AlternateArray: Self = Self(4);
    #[doc(alias = "kCGImageMetadataTypeAlternateText")]
    pub const AlternateText: Self = Self(5);
    #[doc(alias = "kCGImageMetadataTypeStructure")]
    pub const Structure: Self = Self(6);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGImageMetadataType {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGImageMetadataType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

impl CGImageMetadataTag {
    /// Creates a new CGImageMetadataTag
    ///
    /// Parameter `xmlns`: The namespace for the tag. The value can be a common XMP namespace
    /// defined above, such as kCGImageMetadataNamespaceExif, or a CFString with a
    /// custom namespace URI. Custom namespaces must be a valid XML namespace. By
    /// convention, namespaces should end with either '/' or '#'. For example, exif
    /// uses the namespace "http://ns.adobe.com/exif/1.0/".
    ///
    /// Parameter `prefix`: An abbreviation for the XML namespace. The value can be NULL if
    /// the namespace is defined as a constant. Custom prefixes must be a valid XML
    /// name. For example, the prefix used for "http://ns.adobe.com/exif/1.0/" is "exif".
    /// The XMP serialization of the tag will use the prefix. Prefixes are also
    /// important for path-based CGImageMetadata functions, such as
    ///
    /// ```text
    ///  CGImageMetadataCopyStringValueWithPath
    /// ```
    ///
    /// or
    ///
    /// ```text
    ///  CGImageMetadataSetValueWithPath
    /// ```
    ///
    /// .
    ///
    /// Parameter `name`: The name of the tag. It must be a valid XMP name.
    ///
    /// Parameter `type`: The type of the tag's value. Must be a constant from
    ///
    /// ```text
    ///  
    ///  CGImageMetadataType
    /// ```
    ///
    /// .
    ///
    /// Parameter `value`: The value of the tag. Allowable CFTypes include CFStringRef,
    /// CFNumberRef, CFBooleanRef, CFArrayRef, and CFDictionaryRef. The CFType of 'value'
    /// must correspond to the 'type'. The elements of a CFArray must be either a
    /// CFStringRef or CGImageMetadataTagRef. The keys of a CFDictionary must be
    /// CFStringRefs with valid XMP names. The values of a CFDictionary must be either
    /// CFStringRefs or CGImageMetadataTagRefs. A shallow copy of the value is stored
    /// in the tag. Therefore, modifying a mutable value after the tag is created
    /// will not affect the tag's value.
    ///
    /// Returns: Returns a pointer to a new CGImageMetadataTag. Returns NULL if a tag
    /// could not be created with the specified parameters.
    ///
    /// # Safety
    ///
    /// `value` should be of the correct type.
    #[doc(alias = "CGImageMetadataTagCreate")]
    #[inline]
    pub unsafe fn new(
        xmlns: &CFString,
        prefix: Option<&CFString>,
        name: &CFString,
        r#type: CGImageMetadataType,
        value: &CFType,
    ) -> Option<CFRetained<CGImageMetadataTag>> {
        extern "C-unwind" {
            fn CGImageMetadataTagCreate(
                xmlns: &CFString,
                prefix: Option<&CFString>,
                name: &CFString,
                r#type: CGImageMetadataType,
                value: &CFType,
            ) -> Option<NonNull<CGImageMetadataTag>>;
        }
        let ret = unsafe { CGImageMetadataTagCreate(xmlns, prefix, name, r#type, value) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// *!
    ///
    ///
    ///
    /// Returns a copy of the tag's namespace
    #[doc(alias = "CGImageMetadataTagCopyNamespace")]
    #[inline]
    pub unsafe fn namespace(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CGImageMetadataTagCopyNamespace(
                tag: &CGImageMetadataTag,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CGImageMetadataTagCopyNamespace(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a copy of the tag's prefix
    #[doc(alias = "CGImageMetadataTagCopyPrefix")]
    #[inline]
    pub unsafe fn prefix(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CGImageMetadataTagCopyPrefix(tag: &CGImageMetadataTag) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CGImageMetadataTagCopyPrefix(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a copy of the tag's name
    #[doc(alias = "CGImageMetadataTagCopyName")]
    #[inline]
    pub unsafe fn name(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CGImageMetadataTagCopyName(tag: &CGImageMetadataTag) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CGImageMetadataTagCopyName(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns a shallow copy of the tag's value
    ///
    /// This function should only be used to read the tag's value.
    /// CGImageMetadataCopyTagWithPath returns a copy of the tag (including a copy of
    /// the tag's value). Therefore mutating a tag's value returned from this function
    /// may not actually mutate the value in the CGImageMetadata. It is recommended
    /// to create a new tag followed by CGImageMetadataSetTagWithPath, or use
    /// CGImageMetadataSetValueWithPath to mutate a metadata value.
    #[doc(alias = "CGImageMetadataTagCopyValue")]
    #[inline]
    pub unsafe fn value(&self) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn CGImageMetadataTagCopyValue(tag: &CGImageMetadataTag) -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { CGImageMetadataTagCopyValue(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Get the type of the CGImageMetadataTag
    ///
    /// Returns: Returns a CGImageMetadataType constant for the CGImageMetadataTag.
    /// This is primarily used to determine how to interpret the tag's value.
    #[doc(alias = "CGImageMetadataTagGetType")]
    #[inline]
    pub unsafe fn r#type(&self) -> CGImageMetadataType {
        extern "C-unwind" {
            fn CGImageMetadataTagGetType(tag: &CGImageMetadataTag) -> CGImageMetadataType;
        }
        unsafe { CGImageMetadataTagGetType(self) }
    }

    /// Return a copy of the tag's qualifiers
    ///
    /// XMP allows properties to contain supplemental properties called
    /// qualifiers. Qualifiers are themselves CGImageMetadataTags with their own
    /// namespace, prefix, name, and value. A common use is the xml:lang qualifier
    /// for elements of an alternate-text array.
    ///
    /// Returns: Returns a copy of the array of qualifiers. Elements of the array are
    /// CGImageMetadataTags. Returns NULL if the tag does not have any qualifiers.
    /// The copy is shallow, the qualifiers are not deep copied.
    #[doc(alias = "CGImageMetadataTagCopyQualifiers")]
    #[inline]
    pub unsafe fn qualifiers(&self) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CGImageMetadataTagCopyQualifiers(
                tag: &CGImageMetadataTag,
            ) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CGImageMetadataTagCopyQualifiers(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CGImageMetadata {
    /// *!
    ///
    ///
    ///
    /// Obtain an array of tags from a CGImageMetadataRef
    ///
    /// Returns: Returns an array with a shallow copy of all top-level
    /// CGImageMetadataTagRefs in a CGImageMetadataRef.
    #[doc(alias = "CGImageMetadataCopyTags")]
    #[inline]
    pub unsafe fn tags(&self) -> Option<CFRetained<CFArray>> {
        extern "C-unwind" {
            fn CGImageMetadataCopyTags(metadata: &CGImageMetadata) -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CGImageMetadataCopyTags(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Searches for a specific CGImageMetadataTag in a CGImageMetadataRef
    ///
    /// This is the primary function for clients to obtain specific
    /// metadata properties from an image. The 'path' mechanism provides a way to
    /// access both simple top-level properties, such as Date
    /// &
    /// Time, or complex
    /// deeply-nested properties with ease.
    ///
    /// Parameter `metadata`: A collection of metadata tags.
    ///
    /// Parameter `parent`: A parent tag. If NULL, the path is relative to the root of the
    /// CGImageMetadataRef (i.e. it is not a child of another property). If the parent
    /// is provided, the effective path will be the concatenation of the parent's path
    /// and the 'path' parameter. This is useful for accessing array elements or
    /// structure fields inside nested tags.
    ///
    /// Parameter `path`: A string representing a path to the desired tag. Paths consist of
    /// a tag prefix (i.e. "exif") joined with a tag name (i.e. "Flash") by a colon
    /// (":"), such as CFSTR("exif:Flash").
    /// Elements of ordered and unordered arrays are accessed via 0-based indices inside square [] brackets.
    /// Elements of alternate-text arrays are accessed by an RFC 3066 language code inside square [] brackets.
    /// Fields of a structure are delimited by a period, '.'.
    /// Qualifiers are delimited by the '?' character. Only tags with string values (kCGImageMetadataTypeString)
    /// are allowed to have qualifiers - arrays and structures may not contain qualifiers.
    ///
    /// If parent is NULL, a prefix must be specified for the first tag. Prefixes for
    /// all subsequent tags are optional. If unspecified, the prefix is
    /// inherented from the nearest parent tag with a prefix. Custom prefixes must be
    /// registered using
    ///
    /// ```text
    ///  CGImageMetadataRegisterNamespaceForPrefix
    /// ```
    ///
    /// prior to use
    /// in any path-based functions.
    ///
    /// Examples:
    /// <ul>
    /// <li>
    /// 'path' = CFSTR("xmp:CreateDate")
    /// </li>
    /// <li>
    /// 'path' = CFSTR("exif:Flash.Fired")
    /// </li>
    /// <li>
    /// 'parent' = tag at path CFSTR("exif:Flash"), path = CFSTR("exif:Fired") (equivilent to previous)
    /// </li>
    /// <li>
    /// 'path' = CFSTR("exif:Flash.RedEyeMode")
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc:title")
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc:subject")
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc:subject[2]")
    /// </li>
    /// <li>
    /// 'parent' = tag at path CFSTR("dc:subject"), path = CFSTR("[2]") (equivilent to previous)
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc:description[x-default])"
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc.description[de])"
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc.description[fr])"
    /// </li>
    /// <li>
    /// 'path' = CFSTR("foo:product)"
    /// </li>
    /// <li>
    /// 'path' = CFSTR("foo:product?bar:manufacturer)"
    /// </li>
    /// </ul>
    ///
    /// Returns: Returns a copy of CGImageMetadataTag matching 'path', or NULL if no
    /// match is found. The copy of the tag's value is shallow. Tags
    /// copied from an immutable CGImageMetadataRef are also immutable. Because this
    /// function returns a copy of the tag's value, any modification of the tag's
    /// value must be followed by a CGImageMetadataSetTagWithPath to commit the
    /// change to the metadata container.
    #[doc(alias = "CGImageMetadataCopyTagWithPath")]
    #[inline]
    pub unsafe fn tag_with_path(
        &self,
        parent: Option<&CGImageMetadataTag>,
        path: &CFString,
    ) -> Option<CFRetained<CGImageMetadataTag>> {
        extern "C-unwind" {
            fn CGImageMetadataCopyTagWithPath(
                metadata: &CGImageMetadata,
                parent: Option<&CGImageMetadataTag>,
                path: &CFString,
            ) -> Option<NonNull<CGImageMetadataTag>>;
        }
        let ret = unsafe { CGImageMetadataCopyTagWithPath(self, parent, path) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Searches for a specific tag in a CGImageMetadataRef and returns its
    /// string value.
    ///
    /// This is a convenience method for searching for a tag at path and
    /// extracting the string value.
    ///
    /// Parameter `metadata`: A collection of metadata tags.
    ///
    /// Parameter `parent`: A parent tag. If NULL, the path is relative to the root of the
    /// CGImageMetadataRef (i.e. it is not a child of another property).
    ///
    /// Parameter `path`: A string with the path to the desired tag. Please consult
    /// the documentation of
    ///
    /// ```text
    ///  CGImageMetadataCopyTagWithPath
    /// ```
    ///
    /// for
    /// information about path syntax.
    ///
    /// Returns: Returns a string from a CGImageMetadataTag located at 'path'. The
    /// tag must be of type kCGImageMetadataTypeString or kCGImageMetadataTypeAlternateText.
    /// For AlternateText tags, the element with the "x-default" language qualifier
    /// will be returned. For other types, NULL will be returned.
    #[doc(alias = "CGImageMetadataCopyStringValueWithPath")]
    #[inline]
    pub unsafe fn string_value_with_path(
        &self,
        parent: Option<&CGImageMetadataTag>,
        path: &CFString,
    ) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CGImageMetadataCopyStringValueWithPath(
                metadata: &CGImageMetadata,
                parent: Option<&CGImageMetadataTag>,
                path: &CFString,
            ) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CGImageMetadataCopyStringValueWithPath(self, parent, path) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CGMutableImageMetadata {
    /// *!
    ///
    ///
    ///
    /// Associates an XMP namespace URI with a prefix string.
    ///
    /// This allows ImageIO to create custom metadata when it encounters
    /// an unrecognized prefix in a path (see CGImageMetadataCopyTagWithPath for more
    /// information about path syntax). A namespace must be registered before it can
    /// be used to add custom metadata. All namespaces found in the image's metadata,
    /// or defined as a constant above, will be pre-registered. Namespaces and
    /// prefixes must be unique.
    ///
    /// Returns: Returns true if successful. Returns false and sets 'err' if an error
    /// or conflict occurs.
    ///
    /// # Safety
    ///
    /// `err` must be a valid pointer or null.
    #[doc(alias = "CGImageMetadataRegisterNamespaceForPrefix")]
    #[inline]
    pub unsafe fn register_namespace_for_prefix(
        &self,
        xmlns: &CFString,
        prefix: &CFString,
        err: *mut *mut CFError,
    ) -> bool {
        extern "C-unwind" {
            fn CGImageMetadataRegisterNamespaceForPrefix(
                metadata: &CGMutableImageMetadata,
                xmlns: &CFString,
                prefix: &CFString,
                err: *mut *mut CFError,
            ) -> bool;
        }
        unsafe { CGImageMetadataRegisterNamespaceForPrefix(self, xmlns, prefix, err) }
    }

    /// Sets the tag at a specific path in a CGMutableImageMetadata container or a parent tag
    ///
    /// This is the primary function for adding new metadata tags to a
    /// metadata container, or updating existing tags. All tags required to reach
    /// the final tag (at the end of the path) will be created, if needed. Tags will
    /// created with default types (ordered arrays). Creating tags will fail if a
    /// prefix is encountered that has not been registered. Use
    ///
    /// ```text
    ///  CGImageMetadataRegisterNamespaceForPrefix
    /// ```
    ///
    /// to associate a prefix
    /// with a namespace prior to using a path-based CGImageMetadata function.
    /// Note that if a parent tag is provided,
    /// the children of that tag reference will be modified, which may be a different
    /// reference from the tag stored in the metadata container. Since tags are normally
    /// obtained as a copy, it is typically neccesary to use CGImageMetadataSetTagWithPath
    /// to commit the changed parent object back to the metadata container (using
    /// the parent's path and NULL for the parent).
    ///
    /// Parameter `metadata`: A mutable collection of metadata tags.
    /// Use
    ///
    /// ```text
    ///  CGImageMetadataCreateMutableCopy
    /// ```
    ///
    /// or
    ///
    /// ```text
    ///  CGImageMetadataCreateMutable
    /// ```
    ///
    /// to obtain a mutable metadata container.
    ///
    /// Parameter `parent`: A parent tag. If NULL, the path is relative to the root of the
    /// CGImageMetadataRef (i.e. it is not a child of another property).
    /// Note that if a parent tag is provided,
    /// the children of that tag reference will be modified, which may be a different
    /// reference from the tag stored in the metadata container. Since tags are normally
    /// obtained as a copy, it is typically neccesary to use CGImageMetadataSetTagWithPath
    /// to commit the changed parent object back to the metadata container (using
    /// the parent's path and NULL for the parent).
    ///
    /// Parameter `path`: A string with the path to the desired tag. Please consult
    /// the documentation of
    ///
    /// ```text
    ///  CGImageMetadataCopyTagWithPath
    /// ```
    ///
    /// for
    /// information about path syntax.
    ///
    /// Parameter `tag`: The CGImageMetadataTag to be added to the metadata. The tag
    /// will be retained.
    ///
    /// Returns: Returns true if successful, false otherwise.
    #[doc(alias = "CGImageMetadataSetTagWithPath")]
    #[inline]
    pub unsafe fn set_tag_with_path(
        &self,
        parent: Option<&CGImageMetadataTag>,
        path: &CFString,
        tag: &CGImageMetadataTag,
    ) -> bool {
        extern "C-unwind" {
            fn CGImageMetadataSetTagWithPath(
                metadata: &CGMutableImageMetadata,
                parent: Option<&CGImageMetadataTag>,
                path: &CFString,
                tag: &CGImageMetadataTag,
            ) -> bool;
        }
        unsafe { CGImageMetadataSetTagWithPath(self, parent, path, tag) }
    }

    /// Sets the value of the tag at a specific path in a CGMutableImageMetadataRef container or a parent tag
    ///
    /// This function is used to add new metadata values to a
    /// metadata container, or update existing tag values. All tags required to reach
    /// the final tag (at the end of the path) are created, if needed. Tags are
    /// created with default types (i.e. arrays will be ordered). Creating tags will
    /// fail if a prefix is encountered that has not been registered. Use
    ///
    /// ```text
    ///  CGImageMetadataRegisterNamespaceForPrefix
    /// ```
    ///
    /// to associate a prefix
    /// with a namespace prior to using a path-based CGImageMetadata function.
    ///
    /// Examples
    /// <ul>
    /// <li>
    /// 'path' = CFSTR("xmp:CreateDate"), 'value' = CFSTR("2011-09-20T14:54:47-08:00")
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc:subject[0]"), 'value' = CFSTR("San Francisco")
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc:subject[1]"), 'value' = CFSTR("Golden Gate Bridge")
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc:description[en]") 'value' = CFSTR("my image description")
    /// </li>
    /// <li>
    /// 'path' = CFSTR("dc:description[de]") 'value' = CFSTR("meine bildbeschreibung")
    /// </li>
    /// </ul>
    /// Note that if a parent tag is provided,
    /// the children of that tag reference will be modified, which may be a different
    /// reference from the tag stored in the metadata container. Since tags are normally
    /// obtained as a copy, it is typically neccesary to use CGImageMetadataSetTagWithPath
    /// to commit the changed parent object back to the metadata container (using
    /// the parent's path and NULL for the parent).
    ///
    /// Parameter `metadata`: A mutable collection of metadata tags.
    /// Use
    ///
    /// ```text
    ///  CGImageMetadataCreateMutableCopy
    /// ```
    ///
    /// or
    ///
    /// ```text
    ///  CGImageMetadataCreateMutable
    /// ```
    ///
    /// to obtain a mutable metadata container.
    ///
    /// Parameter `parent`: A parent tag. If NULL, the path is relative to the root of the
    /// CGImageMetadataRef (i.e. it is not a child of another property).
    ///
    /// Parameter `path`: A string with the path to the desired tag. Please consult
    /// the documentation of
    ///
    /// ```text
    ///  CGImageMetadataCopyTagWithPath
    /// ```
    ///
    /// for
    /// information about path syntax.
    ///
    /// Parameter `value`: The value to be added to the CGImageMetadataTag matching the path.
    /// The tag will be retained. The restrictions for the value are the same as in
    ///
    /// ```text
    ///  CGImageMetadataTagCreate
    /// ```
    ///
    /// .
    ///
    /// Returns: Returns true if successful, false otherwise.
    ///
    /// # Safety
    ///
    /// `value` should be of the correct type.
    #[doc(alias = "CGImageMetadataSetValueWithPath")]
    #[inline]
    pub unsafe fn set_value_with_path(
        &self,
        parent: Option<&CGImageMetadataTag>,
        path: &CFString,
        value: &CFType,
    ) -> bool {
        extern "C-unwind" {
            fn CGImageMetadataSetValueWithPath(
                metadata: &CGMutableImageMetadata,
                parent: Option<&CGImageMetadataTag>,
                path: &CFString,
                value: &CFType,
            ) -> bool;
        }
        unsafe { CGImageMetadataSetValueWithPath(self, parent, path, value) }
    }

    /// Removes the tag at a specific path from a CGMutableImageMetadata container or from the parent tag
    ///
    /// Use this function to delete a metadata tag matching a specific
    /// path from a mutable metadata container. Note that if a parent tag is provided,
    /// the children of that tag reference will be modified, which may be a different
    /// reference from the tag stored in the metadata container. Since tags are normally
    /// obtained as a copy, it is typically neccesary to use CGImageMetadataSetTagWithPath
    /// to commit the changed parent object back to the metadata container (using
    /// the parent's path and NULL for the parent).
    ///
    /// Parameter `parent`: A parent tag. If NULL, the path is relative to the root of the
    /// CGImageMetadataRef (i.e. it is not a child of another property).
    ///
    /// Parameter `path`: A string with the path to the desired tag. Please consult
    /// the documentation of
    ///
    /// ```text
    ///  CGImageMetadataCopyTagWithPath
    /// ```
    ///
    /// for
    /// information about path syntax.
    #[doc(alias = "CGImageMetadataRemoveTagWithPath")]
    #[inline]
    pub unsafe fn remove_tag_with_path(
        &self,
        parent: Option<&CGImageMetadataTag>,
        path: &CFString,
    ) -> bool {
        extern "C-unwind" {
            fn CGImageMetadataRemoveTagWithPath(
                metadata: &CGMutableImageMetadata,
                parent: Option<&CGImageMetadataTag>,
                path: &CFString,
            ) -> bool;
        }
        unsafe { CGImageMetadataRemoveTagWithPath(self, parent, path) }
    }
}

/// The block type used by CGImageMetadataEnumerateTagsUsingBlock
///
/// Parameter `path`: The full path to the tag in the metadata container.
///
/// Parameter `tag`: The CGImageMetadataTagRef corresponding to the path in metadata.
///
/// Returns: Return true to continue iterating through the tags, or return false to stop.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/imageio/cgimagemetadatatagblock?language=objc)
#[cfg(feature = "block2")]
pub type CGImageMetadataTagBlock =
    *mut block2::DynBlock<dyn Fn(NonNull<CFString>, NonNull<CGImageMetadataTag>) -> bool>;

impl CGImageMetadata {
    /// Executes a given block using each tag in the metadata
    ///
    /// This function iterates over all of the tags in a
    /// CGImageMetadataRef, executing the block for each tag. The default behavior
    /// iterates over all top-level tags in the metadata. The path of the tag and
    /// the tag itself is passed to the block. The metadata cannot be modified inside
    /// the block - consider adding the tags of interest into another collection.
    ///
    /// Parameter `metadata`: A collection of metadata tags.
    ///
    /// Parameter `rootPath`: Iteration will occur for all children of the tag matching
    /// the root path. Please refer to CGImageMetadataCopyTagWithPath for information
    /// about path syntax. If NULL or an empty string, the block will be executed
    /// for all top-level tags in the metadata container.
    ///
    /// Parameter `options`: A dictionary of options for iterating through the tags.
    /// Currently the only supported option is kCGImageMetadataEnumerateRecursively,
    /// which should be set to a CFBoolean.
    ///
    /// Parameter `block`: The block that is executed for each tag in metadata.
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    /// - `block` must be a valid pointer.
    #[doc(alias = "CGImageMetadataEnumerateTagsUsingBlock")]
    #[cfg(feature = "block2")]
    #[inline]
    pub unsafe fn enumerate_tags_using_block(
        &self,
        root_path: Option<&CFString>,
        options: Option<&CFDictionary>,
        block: CGImageMetadataTagBlock,
    ) {
        extern "C-unwind" {
            fn CGImageMetadataEnumerateTagsUsingBlock(
                metadata: &CGImageMetadata,
                root_path: Option<&CFString>,
                options: Option<&CFDictionary>,
                block: CGImageMetadataTagBlock,
            );
        }
        unsafe { CGImageMetadataEnumerateTagsUsingBlock(self, root_path, options, block) }
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagemetadataenumeraterecursively?language=objc)
    pub static kCGImageMetadataEnumerateRecursively: &'static CFString;
}

impl CGImageMetadata {
    /// *!
    ///
    ///
    ///
    /// Searches for a specific CGImageMetadataTag matching a kCGImageProperty constant
    ///
    /// Provides a bridge for values from CGImageCopyPropertiesAtIndex, simplifying
    /// access for properties defined in EXIF and IPTC standards, which have no notion of
    /// namespaces, prefixes, or XMP property types.
    /// Metadata Working Group guidance is factored into the mapping of CGImageProperties to
    /// XMP compatible CGImageMetadataTags.
    /// For example, kCGImagePropertyExifDateTimeOriginal will get the value of the
    /// corresponding XMP tag, which is photoshop:DateCreated. Note that property values will
    /// still be in their XMP forms, such as "YYYY-MM-DDThh:mm:ss" for DateTime, rather than
    /// the EXIF or IPTC DateTime formats.
    ///
    /// Parameter `metadata`: A collection of metadata tags
    ///
    /// Parameter `dictionaryName`: the metadata subdictionary to which the image property belongs,
    /// such as kCGImagePropertyExifDictionary or kCGImagePropertyIPTCDictionary. Not all
    /// dictionaries and properties are supported at this time.
    ///
    /// Parameter `propertyName`: the name of the property. This must be a defined property constant
    /// corresponding to the 'dictionaryName'. For example, kCGImagePropertyTIFFOrientation,
    /// kCGImagePropertyExifDateTimeOriginal, or kCGImagePropertyIPTCKeywords. A warning
    /// will be logged if the CGImageProperty is unsupported by CGImageMetadata.
    ///
    /// Returns: Returns a CGImageMetadataTagRef with the appropriate namespace, prefix,
    /// tag name, and XMP value for the corresponding CGImageProperty. Returns NULL if the
    /// property could not be found.
    #[doc(alias = "CGImageMetadataCopyTagMatchingImageProperty")]
    #[inline]
    pub unsafe fn tag_matching_image_property(
        &self,
        dictionary_name: &CFString,
        property_name: &CFString,
    ) -> Option<CFRetained<CGImageMetadataTag>> {
        extern "C-unwind" {
            fn CGImageMetadataCopyTagMatchingImageProperty(
                metadata: &CGImageMetadata,
                dictionary_name: &CFString,
                property_name: &CFString,
            ) -> Option<NonNull<CGImageMetadataTag>>;
        }
        let ret = unsafe {
            CGImageMetadataCopyTagMatchingImageProperty(self, dictionary_name, property_name)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

impl CGMutableImageMetadata {
    /// Sets the value of the CGImageMetadataTag matching a kCGImageProperty constant
    ///
    /// Provides a bridge for values from CGImageCopyPropertiesAtIndex, simplifying
    /// changing property values defined in EXIF and IPTC standards, which have no notion of
    /// namespaces, prefixes, or XMP property types.
    /// Metadata Working Group guidance is factored into the mapping of CGImageProperties to
    /// XMP compatible CGImageMetadataTags.
    /// For example, setting kCGImagePropertyExifDateTimeOriginal will set the value of the
    /// corresponding XMP tag, which is photoshop:DateCreated. Note that property values should
    /// still be in their XMP forms, such as "YYYY-MM-DDThh:mm:ss" for DateTime, rather than
    /// the EXIF or IPTC DateTime formats. Although this function will allow the caller to set
    /// custom values for these properties, you should consult the appropriate specifications
    /// for details about property value formats for EXIF and IPTC tags in XMP.
    ///
    /// Parameter `metadata`: A mutable collection of metadata tags
    ///
    /// Parameter `dictionaryName`: the metadata subdictionary to which the image property belongs,
    /// such as kCGImagePropertyExifDictionary or kCGImagePropertyIPTCDictionary. Not all
    /// dictionaries and properties are supported at this time.
    ///
    /// Parameter `propertyName`: the name of the property. This must be a defined property constant
    /// corresponding to the 'dictionaryName'. For example, kCGImagePropertyTIFFOrientation,
    /// kCGImagePropertyExifDateTimeOriginal, or kCGImagePropertyIPTCKeywords. A warning
    /// will be logged if the CGImageProperty is unsupported by CGImageMetadata.
    ///
    /// Parameter `value`: A CFTypeRef with the value for the tag. The same value restrictions apply
    /// as in
    ///
    /// ```text
    ///  CGImageMetadataTagCreate
    /// ```
    ///
    /// .
    ///
    /// Returns: Returns true if successful, false otherwise.
    ///
    /// # Safety
    ///
    /// `value` should be of the correct type.
    #[doc(alias = "CGImageMetadataSetValueMatchingImageProperty")]
    #[inline]
    pub unsafe fn set_value_matching_image_property(
        &self,
        dictionary_name: &CFString,
        property_name: &CFString,
        value: &CFType,
    ) -> bool {
        extern "C-unwind" {
            fn CGImageMetadataSetValueMatchingImageProperty(
                metadata: &CGMutableImageMetadata,
                dictionary_name: &CFString,
                property_name: &CFString,
                value: &CFType,
            ) -> bool;
        }
        unsafe {
            CGImageMetadataSetValueMatchingImageProperty(
                self,
                dictionary_name,
                property_name,
                value,
            )
        }
    }
}

impl CGImageMetadata {
    /// Serializes the CGImageMetadataRef to XMP data
    ///
    /// This converts all of the metadata tags to a block of XMP data. Common uses
    /// include creating sidecar files that contain metadata for image formats that do not
    /// support embedded XMP, or cannot be edited due to other format restrictions (such as
    /// proprietary RAW camera formats).
    ///
    /// Parameter `metadata`: A collection of metadata tags.
    ///
    /// Parameter `options`: should be NULL. Options are currently not used, but may be used in
    /// future release.
    ///
    /// Returns: Returns a CFData containing an XMP representation of the metadata. Returns
    /// NULL if an error occurred.
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageMetadataCreateXMPData")]
    #[inline]
    pub unsafe fn xmp_data(&self, options: Option<&CFDictionary>) -> Option<CFRetained<CFData>> {
        extern "C-unwind" {
            fn CGImageMetadataCreateXMPData(
                metadata: &CGImageMetadata,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CFData>>;
        }
        let ret = unsafe { CGImageMetadataCreateXMPData(self, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates a collection of CGImageMetadataTags from a block of XMP data
    ///
    /// Converts XMP data into a collection of metadata tags.
    /// The data must be a complete XMP tree. XMP packet  headers (
    /// <
    /// ?xpacket .. ?>) are
    /// supported.
    ///
    /// Parameter `data`: The XMP data.
    ///
    /// Returns: Returns a collection of CGImageMetadata tags. Returns NULL if an error occurred.
    #[doc(alias = "CGImageMetadataCreateFromXMPData")]
    #[inline]
    pub unsafe fn from_xmp_data(data: &CFData) -> Option<CFRetained<CGImageMetadata>> {
        extern "C-unwind" {
            fn CGImageMetadataCreateFromXMPData(data: &CFData) -> Option<NonNull<CGImageMetadata>>;
        }
        let ret = unsafe { CGImageMetadataCreateFromXMPData(data) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

extern "C" {
    /// Error domain for all errors originating in ImageIO for CGImageMetadata APIs.
    /// Error codes may be interpreted using the list below.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/imageio/kcferrordomaincgimagemetadata?language=objc)
    pub static kCFErrorDomainCGImageMetadata: &'static CFString;
}

/// the list of all error codes returned under the error domain kCFErrorDomainCGImageMetadata
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/imageio/cgimagemetadataerrors?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGImageMetadataErrors(pub i32);
impl CGImageMetadataErrors {
    #[doc(alias = "kCGImageMetadataErrorUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "kCGImageMetadataErrorUnsupportedFormat")]
    pub const UnsupportedFormat: Self = Self(1);
    #[doc(alias = "kCGImageMetadataErrorBadArgument")]
    pub const BadArgument: Self = Self(2);
    #[doc(alias = "kCGImageMetadataErrorConflictingArguments")]
    pub const ConflictingArguments: Self = Self(3);
    #[doc(alias = "kCGImageMetadataErrorPrefixConflict")]
    pub const PrefixConflict: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGImageMetadataErrors {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGImageMetadataErrors {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[deprecated = "renamed to `CGMutableImageMetadata::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataCreateMutable() -> CFRetained<CGMutableImageMetadata>
{
    extern "C-unwind" {
        fn CGImageMetadataCreateMutable() -> Option<NonNull<CGMutableImageMetadata>>;
    }
    let ret = unsafe { CGImageMetadataCreateMutable() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[deprecated = "renamed to `CGMutableImageMetadata::new_copy`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataCreateMutableCopy(
    metadata: &CGImageMetadata,
) -> Option<CFRetained<CGMutableImageMetadata>> {
    extern "C-unwind" {
        fn CGImageMetadataCreateMutableCopy(
            metadata: &CGImageMetadata,
        ) -> Option<NonNull<CGMutableImageMetadata>>;
    }
    let ret = unsafe { CGImageMetadataCreateMutableCopy(metadata) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageMetadataTag::new`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataTagCreate(
    xmlns: &CFString,
    prefix: Option<&CFString>,
    name: &CFString,
    r#type: CGImageMetadataType,
    value: &CFType,
) -> Option<CFRetained<CGImageMetadataTag>> {
    extern "C-unwind" {
        fn CGImageMetadataTagCreate(
            xmlns: &CFString,
            prefix: Option<&CFString>,
            name: &CFString,
            r#type: CGImageMetadataType,
            value: &CFType,
        ) -> Option<NonNull<CGImageMetadataTag>>;
    }
    let ret = unsafe { CGImageMetadataTagCreate(xmlns, prefix, name, r#type, value) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageMetadataTag::namespace`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataTagCopyNamespace(
    tag: &CGImageMetadataTag,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CGImageMetadataTagCopyNamespace(tag: &CGImageMetadataTag) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CGImageMetadataTagCopyNamespace(tag) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageMetadataTag::prefix`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataTagCopyPrefix(
    tag: &CGImageMetadataTag,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CGImageMetadataTagCopyPrefix(tag: &CGImageMetadataTag) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CGImageMetadataTagCopyPrefix(tag) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageMetadataTag::name`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataTagCopyName(
    tag: &CGImageMetadataTag,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CGImageMetadataTagCopyName(tag: &CGImageMetadataTag) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CGImageMetadataTagCopyName(tag) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageMetadataTag::value`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataTagCopyValue(
    tag: &CGImageMetadataTag,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn CGImageMetadataTagCopyValue(tag: &CGImageMetadataTag) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { CGImageMetadataTagCopyValue(tag) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageMetadataTag::type`"]
    pub fn CGImageMetadataTagGetType(tag: &CGImageMetadataTag) -> CGImageMetadataType;
}

#[deprecated = "renamed to `CGImageMetadataTag::qualifiers`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataTagCopyQualifiers(
    tag: &CGImageMetadataTag,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CGImageMetadataTagCopyQualifiers(tag: &CGImageMetadataTag) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CGImageMetadataTagCopyQualifiers(tag) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageMetadata::tags`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataCopyTags(
    metadata: &CGImageMetadata,
) -> Option<CFRetained<CFArray>> {
    extern "C-unwind" {
        fn CGImageMetadataCopyTags(metadata: &CGImageMetadata) -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CGImageMetadataCopyTags(metadata) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageMetadata::tag_with_path`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataCopyTagWithPath(
    metadata: &CGImageMetadata,
    parent: Option<&CGImageMetadataTag>,
    path: &CFString,
) -> Option<CFRetained<CGImageMetadataTag>> {
    extern "C-unwind" {
        fn CGImageMetadataCopyTagWithPath(
            metadata: &CGImageMetadata,
            parent: Option<&CGImageMetadataTag>,
            path: &CFString,
        ) -> Option<NonNull<CGImageMetadataTag>>;
    }
    let ret = unsafe { CGImageMetadataCopyTagWithPath(metadata, parent, path) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageMetadata::string_value_with_path`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataCopyStringValueWithPath(
    metadata: &CGImageMetadata,
    parent: Option<&CGImageMetadataTag>,
    path: &CFString,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CGImageMetadataCopyStringValueWithPath(
            metadata: &CGImageMetadata,
            parent: Option<&CGImageMetadataTag>,
            path: &CFString,
        ) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CGImageMetadataCopyStringValueWithPath(metadata, parent, path) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutableImageMetadata::register_namespace_for_prefix`"]
    pub fn CGImageMetadataRegisterNamespaceForPrefix(
        metadata: &CGMutableImageMetadata,
        xmlns: &CFString,
        prefix: &CFString,
        err: *mut *mut CFError,
    ) -> bool;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutableImageMetadata::set_tag_with_path`"]
    pub fn CGImageMetadataSetTagWithPath(
        metadata: &CGMutableImageMetadata,
        parent: Option<&CGImageMetadataTag>,
        path: &CFString,
        tag: &CGImageMetadataTag,
    ) -> bool;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutableImageMetadata::set_value_with_path`"]
    pub fn CGImageMetadataSetValueWithPath(
        metadata: &CGMutableImageMetadata,
        parent: Option<&CGImageMetadataTag>,
        path: &CFString,
        value: &CFType,
    ) -> bool;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutableImageMetadata::remove_tag_with_path`"]
    pub fn CGImageMetadataRemoveTagWithPath(
        metadata: &CGMutableImageMetadata,
        parent: Option<&CGImageMetadataTag>,
        path: &CFString,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "block2")]
    #[deprecated = "renamed to `CGImageMetadata::enumerate_tags_using_block`"]
    pub fn CGImageMetadataEnumerateTagsUsingBlock(
        metadata: &CGImageMetadata,
        root_path: Option<&CFString>,
        options: Option<&CFDictionary>,
        block: CGImageMetadataTagBlock,
    );
}

#[deprecated = "renamed to `CGImageMetadata::tag_matching_image_property`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataCopyTagMatchingImageProperty(
    metadata: &CGImageMetadata,
    dictionary_name: &CFString,
    property_name: &CFString,
) -> Option<CFRetained<CGImageMetadataTag>> {
    extern "C-unwind" {
        fn CGImageMetadataCopyTagMatchingImageProperty(
            metadata: &CGImageMetadata,
            dictionary_name: &CFString,
            property_name: &CFString,
        ) -> Option<NonNull<CGImageMetadataTag>>;
    }
    let ret = unsafe {
        CGImageMetadataCopyTagMatchingImageProperty(metadata, dictionary_name, property_name)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGMutableImageMetadata::set_value_matching_image_property`"]
    pub fn CGImageMetadataSetValueMatchingImageProperty(
        metadata: &CGMutableImageMetadata,
        dictionary_name: &CFString,
        property_name: &CFString,
        value: &CFType,
    ) -> bool;
}

#[deprecated = "renamed to `CGImageMetadata::xmp_data`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataCreateXMPData(
    metadata: &CGImageMetadata,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CFData>> {
    extern "C-unwind" {
        fn CGImageMetadataCreateXMPData(
            metadata: &CGImageMetadata,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CFData>>;
    }
    let ret = unsafe { CGImageMetadataCreateXMPData(metadata, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageMetadata::from_xmp_data`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageMetadataCreateFromXMPData(
    data: &CFData,
) -> Option<CFRetained<CGImageMetadata>> {
    extern "C-unwind" {
        fn CGImageMetadataCreateFromXMPData(data: &CFData) -> Option<NonNull<CGImageMetadata>>;
    }
    let ret = unsafe { CGImageMetadataCreateFromXMPData(data) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}
