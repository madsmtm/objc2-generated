//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/imageio/cgimagesource?language=objc)
#[doc(alias = "CGImageSourceRef")]
#[repr(C)]
pub struct CGImageSource {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGImageSource {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGImageSource"> for CGImageSource {}
);

/// [Apple's documentation](https://developer.apple.com/documentation/imageio/cgimagesourcestatus?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CGImageSourceStatus(pub i32);
impl CGImageSourceStatus {
    #[doc(alias = "kCGImageStatusUnexpectedEOF")]
    pub const StatusUnexpectedEOF: Self = Self(-5);
    #[doc(alias = "kCGImageStatusInvalidData")]
    pub const StatusInvalidData: Self = Self(-4);
    #[doc(alias = "kCGImageStatusUnknownType")]
    pub const StatusUnknownType: Self = Self(-3);
    #[doc(alias = "kCGImageStatusReadingHeader")]
    pub const StatusReadingHeader: Self = Self(-2);
    #[doc(alias = "kCGImageStatusIncomplete")]
    pub const StatusIncomplete: Self = Self(-1);
    #[doc(alias = "kCGImageStatusComplete")]
    pub const StatusComplete: Self = Self(0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGImageSourceStatus {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGImageSourceStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// Keys for the options dictionary when creating a CGImageSourceRef. *
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcetypeidentifierhint?language=objc)
    pub static kCGImageSourceTypeIdentifierHint: &'static CFString;
}

extern "C" {
    /// Keys for the options dictionary of "CGImageSourceCopyPropertiesAtIndex"
    /// * and "CGImageSourceCreateImageAtIndex". *
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourceshouldcache?language=objc)
    pub static kCGImageSourceShouldCache: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourceshouldcacheimmediately?language=objc)
    pub static kCGImageSourceShouldCacheImmediately: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourceshouldallowfloat?language=objc)
    pub static kCGImageSourceShouldAllowFloat: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcecreatethumbnailfromimageifabsent?language=objc)
    pub static kCGImageSourceCreateThumbnailFromImageIfAbsent: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcecreatethumbnailfromimagealways?language=objc)
    pub static kCGImageSourceCreateThumbnailFromImageAlways: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcethumbnailmaxpixelsize?language=objc)
    pub static kCGImageSourceThumbnailMaxPixelSize: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcecreatethumbnailwithtransform?language=objc)
    pub static kCGImageSourceCreateThumbnailWithTransform: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcesubsamplefactor?language=objc)
    pub static kCGImageSourceSubsampleFactor: &'static CFString;
}

unsafe impl ConcreteType for CGImageSource {
    #[doc(alias = "CGImageSourceGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGImageSourceGetTypeID() -> CFTypeID;
        }
        unsafe { CGImageSourceGetTypeID() }
    }
}

impl CGImageSource {
    #[doc(alias = "CGImageSourceCopyTypeIdentifiers")]
    #[inline]
    pub unsafe fn type_identifiers() -> CFRetained<CFArray> {
        extern "C-unwind" {
            fn CGImageSourceCopyTypeIdentifiers() -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CGImageSourceCopyTypeIdentifiers() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CGImageSourceCreateWithDataProvider")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub unsafe fn with_data_provider(
        provider: &CGDataProvider,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImageSource>> {
        extern "C-unwind" {
            fn CGImageSourceCreateWithDataProvider(
                provider: &CGDataProvider,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageSource>>;
        }
        let ret = unsafe { CGImageSourceCreateWithDataProvider(provider, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CGImageSourceCreateWithData")]
    #[inline]
    pub unsafe fn with_data(
        data: &CFData,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImageSource>> {
        extern "C-unwind" {
            fn CGImageSourceCreateWithData(
                data: &CFData,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageSource>>;
        }
        let ret = unsafe { CGImageSourceCreateWithData(data, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CGImageSourceCreateWithURL")]
    #[inline]
    pub unsafe fn with_url(
        url: &CFURL,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImageSource>> {
        extern "C-unwind" {
            fn CGImageSourceCreateWithURL(
                url: &CFURL,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageSource>>;
        }
        let ret = unsafe { CGImageSourceCreateWithURL(url, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGImageSourceGetType")]
    #[inline]
    pub unsafe fn r#type(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CGImageSourceGetType(isrc: &CGImageSource) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CGImageSourceGetType(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    #[doc(alias = "CGImageSourceGetCount")]
    #[inline]
    pub unsafe fn count(&self) -> usize {
        extern "C-unwind" {
            fn CGImageSourceGetCount(isrc: &CGImageSource) -> usize;
        }
        unsafe { CGImageSourceGetCount(self) }
    }

    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CGImageSourceCopyProperties")]
    #[inline]
    pub unsafe fn properties(
        &self,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CGImageSourceCopyProperties(
                isrc: &CGImageSource,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CGImageSourceCopyProperties(self, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CGImageSourceCopyPropertiesAtIndex")]
    #[inline]
    pub unsafe fn properties_at_index(
        &self,
        index: usize,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CGImageSourceCopyPropertiesAtIndex(
                isrc: &CGImageSource,
                index: usize,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CGImageSourceCopyPropertiesAtIndex(self, index, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CGImageSourceCopyMetadataAtIndex")]
    #[cfg(feature = "CGImageMetadata")]
    #[inline]
    pub unsafe fn metadata_at_index(
        &self,
        index: usize,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImageMetadata>> {
        extern "C-unwind" {
            fn CGImageSourceCopyMetadataAtIndex(
                isrc: &CGImageSource,
                index: usize,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageMetadata>>;
        }
        let ret = unsafe { CGImageSourceCopyMetadataAtIndex(self, index, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CGImageSourceCreateImageAtIndex")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub unsafe fn image_at_index(
        &self,
        index: usize,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageSourceCreateImageAtIndex(
                isrc: &CGImageSource,
                index: usize,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageSourceCreateImageAtIndex(self, index, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGImageSourceRemoveCacheAtIndex")]
    #[inline]
    pub unsafe fn remove_cache_at_index(&self, index: usize) {
        extern "C-unwind" {
            fn CGImageSourceRemoveCacheAtIndex(isrc: &CGImageSource, index: usize);
        }
        unsafe { CGImageSourceRemoveCacheAtIndex(self, index) }
    }

    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CGImageSourceCreateThumbnailAtIndex")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub unsafe fn thumbnail_at_index(
        &self,
        index: usize,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageSourceCreateThumbnailAtIndex(
                isrc: &CGImageSource,
                index: usize,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageSourceCreateThumbnailAtIndex(self, index, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// `options` generics must be of the correct type.
    #[doc(alias = "CGImageSourceCreateIncremental")]
    #[inline]
    pub unsafe fn new_incremental(options: Option<&CFDictionary>) -> CFRetained<CGImageSource> {
        extern "C-unwind" {
            fn CGImageSourceCreateIncremental(
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageSource>>;
        }
        let ret = unsafe { CGImageSourceCreateIncremental(options) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    #[doc(alias = "CGImageSourceUpdateData")]
    #[inline]
    pub unsafe fn update_data(&self, data: &CFData, r#final: bool) {
        extern "C-unwind" {
            fn CGImageSourceUpdateData(isrc: &CGImageSource, data: &CFData, r#final: bool);
        }
        unsafe { CGImageSourceUpdateData(self, data, r#final) }
    }

    #[doc(alias = "CGImageSourceUpdateDataProvider")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub unsafe fn update_data_provider(&self, provider: &CGDataProvider, r#final: bool) {
        extern "C-unwind" {
            fn CGImageSourceUpdateDataProvider(
                isrc: &CGImageSource,
                provider: &CGDataProvider,
                r#final: bool,
            );
        }
        unsafe { CGImageSourceUpdateDataProvider(self, provider, r#final) }
    }

    #[doc(alias = "CGImageSourceGetStatus")]
    #[inline]
    pub unsafe fn status(&self) -> CGImageSourceStatus {
        extern "C-unwind" {
            fn CGImageSourceGetStatus(isrc: &CGImageSource) -> CGImageSourceStatus;
        }
        unsafe { CGImageSourceGetStatus(self) }
    }

    #[doc(alias = "CGImageSourceGetStatusAtIndex")]
    #[inline]
    pub unsafe fn status_at_index(&self, index: usize) -> CGImageSourceStatus {
        extern "C-unwind" {
            fn CGImageSourceGetStatusAtIndex(
                isrc: &CGImageSource,
                index: usize,
            ) -> CGImageSourceStatus;
        }
        unsafe { CGImageSourceGetStatusAtIndex(self, index) }
    }

    #[doc(alias = "CGImageSourceGetPrimaryImageIndex")]
    #[inline]
    pub unsafe fn primary_image_index(&self) -> usize {
        extern "C-unwind" {
            fn CGImageSourceGetPrimaryImageIndex(isrc: &CGImageSource) -> usize;
        }
        unsafe { CGImageSourceGetPrimaryImageIndex(self) }
    }

    #[doc(alias = "CGImageSourceCopyAuxiliaryDataInfoAtIndex")]
    #[inline]
    pub unsafe fn auxiliary_data_info_at_index(
        &self,
        index: usize,
        auxiliary_image_data_type: &CFString,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CGImageSourceCopyAuxiliaryDataInfoAtIndex(
                isrc: &CGImageSource,
                index: usize,
                auxiliary_image_data_type: &CFString,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe {
            CGImageSourceCopyAuxiliaryDataInfoAtIndex(self, index, auxiliary_image_data_type)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcedecoderequest?language=objc)
    pub static kCGImageSourceDecodeRequest: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcedecodetohdr?language=objc)
    pub static kCGImageSourceDecodeToHDR: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcedecodetosdr?language=objc)
    pub static kCGImageSourceDecodeToSDR: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcegenerateimagespecificlumascaling?language=objc)
    pub static kCGImageSourceGenerateImageSpecificLumaScaling: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgimagesourcedecoderequestoptions?language=objc)
    pub static kCGImageSourceDecodeRequestOptions: &'static CFString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/imageio/kcgcomputehdrstats?language=objc)
    pub static kCGComputeHDRStats: &'static CFString;
}

impl CGImageSource {
    /// # Safety
    ///
    /// `allowable_types` generic must be of the correct type.
    #[doc(alias = "CGImageSourceSetAllowableTypes")]
    #[inline]
    pub unsafe fn set_allowable_types(allowable_types: &CFArray) -> OSStatus {
        extern "C-unwind" {
            fn CGImageSourceSetAllowableTypes(allowable_types: &CFArray) -> OSStatus;
        }
        unsafe { CGImageSourceSetAllowableTypes(allowable_types) }
    }
}

#[deprecated = "renamed to `CGImageSource::type_identifiers`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyTypeIdentifiers() -> CFRetained<CFArray> {
    extern "C-unwind" {
        fn CGImageSourceCopyTypeIdentifiers() -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CGImageSourceCopyTypeIdentifiers() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[cfg(feature = "objc2-core-graphics")]
#[deprecated = "renamed to `CGImageSource::with_data_provider`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateWithDataProvider(
    provider: &CGDataProvider,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImageSource>> {
    extern "C-unwind" {
        fn CGImageSourceCreateWithDataProvider(
            provider: &CGDataProvider,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageSource>>;
    }
    let ret = unsafe { CGImageSourceCreateWithDataProvider(provider, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::with_data`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateWithData(
    data: &CFData,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImageSource>> {
    extern "C-unwind" {
        fn CGImageSourceCreateWithData(
            data: &CFData,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageSource>>;
    }
    let ret = unsafe { CGImageSourceCreateWithData(data, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::with_url`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateWithURL(
    url: &CFURL,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImageSource>> {
    extern "C-unwind" {
        fn CGImageSourceCreateWithURL(
            url: &CFURL,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageSource>>;
    }
    let ret = unsafe { CGImageSourceCreateWithURL(url, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::type`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceGetType(
    isrc: &CGImageSource,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CGImageSourceGetType(isrc: &CGImageSource) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CGImageSourceGetType(isrc) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::count`"]
    pub fn CGImageSourceGetCount(isrc: &CGImageSource) -> usize;
}

#[deprecated = "renamed to `CGImageSource::properties`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyProperties(
    isrc: &CGImageSource,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CGImageSourceCopyProperties(
            isrc: &CGImageSource,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGImageSourceCopyProperties(isrc, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::properties_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyPropertiesAtIndex(
    isrc: &CGImageSource,
    index: usize,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CGImageSourceCopyPropertiesAtIndex(
            isrc: &CGImageSource,
            index: usize,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGImageSourceCopyPropertiesAtIndex(isrc, index, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGImageMetadata")]
#[deprecated = "renamed to `CGImageSource::metadata_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyMetadataAtIndex(
    isrc: &CGImageSource,
    index: usize,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImageMetadata>> {
    extern "C-unwind" {
        fn CGImageSourceCopyMetadataAtIndex(
            isrc: &CGImageSource,
            index: usize,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageMetadata>>;
    }
    let ret = unsafe { CGImageSourceCopyMetadataAtIndex(isrc, index, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-graphics")]
#[deprecated = "renamed to `CGImageSource::image_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateImageAtIndex(
    isrc: &CGImageSource,
    index: usize,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageSourceCreateImageAtIndex(
            isrc: &CGImageSource,
            index: usize,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageSourceCreateImageAtIndex(isrc, index, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::remove_cache_at_index`"]
    pub fn CGImageSourceRemoveCacheAtIndex(isrc: &CGImageSource, index: usize);
}

#[cfg(feature = "objc2-core-graphics")]
#[deprecated = "renamed to `CGImageSource::thumbnail_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateThumbnailAtIndex(
    isrc: &CGImageSource,
    index: usize,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageSourceCreateThumbnailAtIndex(
            isrc: &CGImageSource,
            index: usize,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageSourceCreateThumbnailAtIndex(isrc, index, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::new_incremental`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateIncremental(
    options: Option<&CFDictionary>,
) -> CFRetained<CGImageSource> {
    extern "C-unwind" {
        fn CGImageSourceCreateIncremental(
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageSource>>;
    }
    let ret = unsafe { CGImageSourceCreateIncremental(options) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::update_data`"]
    pub fn CGImageSourceUpdateData(isrc: &CGImageSource, data: &CFData, r#final: bool);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-graphics")]
    #[deprecated = "renamed to `CGImageSource::update_data_provider`"]
    pub fn CGImageSourceUpdateDataProvider(
        isrc: &CGImageSource,
        provider: &CGDataProvider,
        r#final: bool,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::status`"]
    pub fn CGImageSourceGetStatus(isrc: &CGImageSource) -> CGImageSourceStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::status_at_index`"]
    pub fn CGImageSourceGetStatusAtIndex(isrc: &CGImageSource, index: usize)
        -> CGImageSourceStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::primary_image_index`"]
    pub fn CGImageSourceGetPrimaryImageIndex(isrc: &CGImageSource) -> usize;
}

#[deprecated = "renamed to `CGImageSource::auxiliary_data_info_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyAuxiliaryDataInfoAtIndex(
    isrc: &CGImageSource,
    index: usize,
    auxiliary_image_data_type: &CFString,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CGImageSourceCopyAuxiliaryDataInfoAtIndex(
            isrc: &CGImageSource,
            index: usize,
            auxiliary_image_data_type: &CFString,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe {
        CGImageSourceCopyAuxiliaryDataInfoAtIndex(isrc, index, auxiliary_image_data_type)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::set_allowable_types`"]
    pub fn CGImageSourceSetAllowableTypes(allowable_types: &CFArray) -> OSStatus;
}
