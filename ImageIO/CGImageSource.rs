//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::cell::UnsafeCell;
use core::ffi::*;
use core::marker::{PhantomData, PhantomPinned};
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;

use crate::*;

/// An opaque type that you use to read image data from a URL, data object, or data consumer.
///
/// ## Overview
///
/// Use a [`CGImageSourceRef`](https://developer.apple.com/documentation/imageio/cgimagesource) type to read data efficiently for most image file formats. The image source object manages the data buffers needed to load the image data and performs any operations on that data to turn it into a usable image. For example, it decompresses data stored in a compressed format. You can also use an image source to fetch or create thumbnail images and access metadata stored with the image.
///
/// Create an image source object from a [`CFURLRef`](https://developer.apple.com/documentation/corefoundation/cfurl), [`CFDataRef`](https://developer.apple.com/documentation/corefoundation/cfdata), or [`CGDataProviderRef`](https://developer.apple.com/documentation/coregraphics/cgdataprovider) data type. The image source object reads data from the specified type and extracts the image information for you.
///
/// For more information, see [Image I/O Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/ImageIOGuide/imageio_intro/ikpg_intro.html#//apple_ref/doc/uid/TP40005462).
///
///
#[doc(alias = "CGImageSourceRef")]
#[repr(C)]
pub struct CGImageSource {
    inner: [u8; 0],
    _p: UnsafeCell<PhantomData<(*const UnsafeCell<()>, PhantomPinned)>>,
}

cf_type!(
    unsafe impl CGImageSource {}
);
#[cfg(feature = "objc2")]
cf_objc2_type!(
    unsafe impl RefEncode<"CGImageSource"> for CGImageSource {}
);

/// The set of status values for images and image sources.
///
/// ## Overview
///
/// The [`CGImageSourceGetStatus`](https://developer.apple.com/documentation/imageio/cgimagesourcegetstatus(_:)) and [`CGImageSourceGetStatusAtIndex`](https://developer.apple.com/documentation/imageio/cgimagesourcegetstatusatindex(_:_:)) functions return these values.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CGImageSourceStatus(pub i32);
impl CGImageSourceStatus {
    /// The end of the file occurred unexpectedly.
    #[doc(alias = "kCGImageStatusUnexpectedEOF")]
    pub const StatusUnexpectedEOF: Self = Self(-5);
    /// The data is not valid.
    #[doc(alias = "kCGImageStatusInvalidData")]
    pub const StatusInvalidData: Self = Self(-4);
    /// The image is an unknown type.
    #[doc(alias = "kCGImageStatusUnknownType")]
    pub const StatusUnknownType: Self = Self(-3);
    /// The image source is reading the header.
    #[doc(alias = "kCGImageStatusReadingHeader")]
    pub const StatusReadingHeader: Self = Self(-2);
    /// The operation is not complete
    #[doc(alias = "kCGImageStatusIncomplete")]
    pub const StatusIncomplete: Self = Self(-1);
    /// The operation is complete.
    #[doc(alias = "kCGImageStatusComplete")]
    pub const StatusComplete: Self = Self(0);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for CGImageSourceStatus {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for CGImageSourceStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The uniform type identifier that represents your best guess for the image’s type.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`CFStringRef`](https://developer.apple.com/documentation/corefoundation/cfstring) object. Add this key to the options dictionary when you create a [`CGImageSourceRef`](https://developer.apple.com/documentation/imageio/cgimagesource) object.
    ///
    ///
    /// Keys for the options dictionary when creating a CGImageSourceRef. *
    pub static kCGImageSourceTypeIdentifierHint: &'static CFString;
}

extern "C" {
    /// A Boolean value that indicates whether to cache the decoded image.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`CFBooleanRef`](https://developer.apple.com/documentation/corefoundation/cfboolean). The default value is [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue) for 64-bit architectures, and [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse) for 32-bit architectures.
    ///
    /// Include this key in the options dictionary you pass to the functions [`CGImageSourceCopyPropertiesAtIndex`](https://developer.apple.com/documentation/imageio/cgimagesourcecopypropertiesatindex(_:_:_:)) and [`CGImageSourceCreateImageAtIndex`](https://developer.apple.com/documentation/imageio/cgimagesourcecreateimageatindex(_:_:_:)).
    ///
    ///
    /// Keys for the options dictionary of "CGImageSourceCopyPropertiesAtIndex"
    /// * and "CGImageSourceCreateImageAtIndex". *
    pub static kCGImageSourceShouldCache: &'static CFString;
}

extern "C" {
    /// A Boolean value that indicates whether image decoding and caching happens at image creation time.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`CFBooleanRef`](https://developer.apple.com/documentation/corefoundation/cfboolean). The default value is [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse), which causes decoding and caching to happen only when you render the image.
    ///
    /// Include this key in the options dictionary you pass to the functions [`CGImageSourceCopyPropertiesAtIndex`](https://developer.apple.com/documentation/imageio/cgimagesourcecopypropertiesatindex(_:_:_:)) and [`CGImageSourceCreateImageAtIndex`](https://developer.apple.com/documentation/imageio/cgimagesourcecreateimageatindex(_:_:_:)).
    ///
    ///
    pub static kCGImageSourceShouldCacheImmediately: &'static CFString;
}

extern "C" {
    /// A Boolean that indicates whether to use floating-point values in returned images.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`CFBooleanRef`](https://developer.apple.com/documentation/corefoundation/cfboolean). The default value is [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse), which tells the image source not to use floating-point values.
    ///
    /// If the image format supports floating-point values, this key tells the image source to format [`CGImageRef`](https://developer.apple.com/documentation/coregraphics/cgimage) types using those values. The use of extended-range floating-point values may require additional processing to render in a pleasing manner.
    ///
    ///
    pub static kCGImageSourceShouldAllowFloat: &'static CFString;
}

extern "C" {
    /// A Boolean value that indicates whether to create a thumbnail image automatically if the data source doesn’t contain one.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`CFBooleanRef`](https://developer.apple.com/documentation/corefoundation/cfboolean). The default value is [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse).
    ///
    /// If you set the value of this key to [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue), the image source creates the thumbnail from the full image, subject to the limit specified by [`kCGImageSourceThumbnailMaxPixelSize`](https://developer.apple.com/documentation/imageio/kcgimagesourcethumbnailmaxpixelsize). If you don’t specify a maximum pixel size, the image soucre creates the thumbnail using the image’s full size, which in most cases is not desirable.
    ///
    /// Include this key in the options dictionary you pass to the function [`CGImageSourceCreateThumbnailAtIndex`](https://developer.apple.com/documentation/imageio/cgimagesourcecreatethumbnailatindex(_:_:_:)).
    ///
    ///
    pub static kCGImageSourceCreateThumbnailFromImageIfAbsent: &'static CFString;
}

extern "C" {
    /// A Boolean value that indicates whether to always create a thumbnail image.
    ///
    /// ## Discussion
    ///
    /// The value of this key is a [`CFBooleanRef`](https://developer.apple.com/documentation/corefoundation/cfboolean). The default value is [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse).
    ///
    /// If you set the value of this key to [`kCFBooleanTrue`](https://developer.apple.com/documentation/corefoundation/kcfbooleantrue), the image source creates the thumbnail from the full image, subject to the limit specified by [`kCGImageSourceThumbnailMaxPixelSize`](https://developer.apple.com/documentation/imageio/kcgimagesourcethumbnailmaxpixelsize). If you don’t specify a maximum pixel size, the image source creates the thumbnail using the image’s full size, which in most cases is not desirable.
    ///
    /// Include this key in the options dictionary you pass to the function [`CGImageSourceCreateThumbnailAtIndex`](https://developer.apple.com/documentation/imageio/cgimagesourcecreatethumbnailatindex(_:_:_:)).
    ///
    ///
    pub static kCGImageSourceCreateThumbnailFromImageAlways: &'static CFString;
}

extern "C" {
    /// The maximum width and height of a thumbnail image, specified in pixels.
    ///
    /// ## Discussion
    ///
    /// If this key is not specified, the width and height of a thumbnail is not limited and thumbnails may be as big as the image itself. If present, this key must be a CFNumber value. This key can be provided in the options dictionary that you pass to the function [`CGImageSourceCreateThumbnailAtIndex`](https://developer.apple.com/documentation/imageio/cgimagesourcecreatethumbnailatindex(_:_:_:)).
    ///
    ///
    pub static kCGImageSourceThumbnailMaxPixelSize: &'static CFString;
}

extern "C" {
    /// A Boolean value that indicates whether to rotate and scale the thumbnail image to match the image’s orientation and aspect ratio.
    ///
    /// ## Discussion
    ///
    /// The value of this key must be a CFBoolean value. The default value is [`kCFBooleanFalse`](https://developer.apple.com/documentation/corefoundation/kcfbooleanfalse).
    ///
    ///
    pub static kCGImageSourceCreateThumbnailWithTransform: &'static CFString;
}

extern "C" {
    /// The factor by which to scale down any returned images.
    ///
    /// ## Discussion
    ///
    /// When you specify this key, the image source scales down the image data by the specified numerical factor. The value of this key must be a [`CFNumberRef`](https://developer.apple.com/documentation/corefoundation/cfnumber) containing the integer value 2, 4, or 8. If the image doesn’t support the specified scale factor, the image source provides a larger or full-size normal image.
    ///
    /// Image sources support this option only for JPEG, HEIF, TIFF, and PNG images.
    ///
    ///
    pub static kCGImageSourceSubsampleFactor: &'static CFString;
}

unsafe impl ConcreteType for CGImageSource {
    /// Returns the unique type identifier of an image source opaque type.
    ///
    /// ## Return Value
    ///
    /// Returns the Core Foundation type ID for an image source.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// A type identifier is an integer that identifies the opaque type to which a Core Foundation object belongs. You use type IDs in various contexts, such as when you are operating on heterogeneous collections. Note that a Core Foundation type ID is different from a uniform type identifier.
    ///
    ///
    #[doc(alias = "CGImageSourceGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn CGImageSourceGetTypeID() -> CFTypeID;
        }
        unsafe { CGImageSourceGetTypeID() }
    }
}

impl CGImageSource {
    /// Returns an array of uniform type identifiers that are supported for image sources.
    ///
    /// ## Return Value
    ///
    /// Returns an array of the uniform type identifiers that are supported for image sources.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// For a list of system-declared and third-party identifiers, see [`Uniform Type Identifiers`](https://developer.apple.com/documentation/uniformtypeidentifiers).
    ///
    ///
    #[doc(alias = "CGImageSourceCopyTypeIdentifiers")]
    #[inline]
    pub unsafe fn type_identifiers() -> CFRetained<CFArray> {
        extern "C-unwind" {
            fn CGImageSourceCopyTypeIdentifiers() -> Option<NonNull<CFArray>>;
        }
        let ret = unsafe { CGImageSourceCopyTypeIdentifiers() };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Creates an image source that reads data from the specified data provider.
    ///
    /// Parameters:
    /// - provider: The data provider to read from. For more information on data providers, see [`CGDataProviderRef`](https://developer.apple.com/documentation/coregraphics/cgdataprovider) and [Quartz 2D Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/drawingwithquartz2d/Introduction/Introduction.html#//apple_ref/doc/uid/TP30001066).
    ///
    /// - options: A dictionary that specifies additional creation options. For a list of possible values, see [Specifying the Read Options](https://developer.apple.com/documentation/imageio/cgimagesource#specifying-the-read-options).
    ///
    ///
    /// ## Return Value
    ///
    /// An image source. You’re responsible for releasing this type using [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageSourceCreateWithDataProvider")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub unsafe fn with_data_provider(
        provider: &CGDataProvider,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImageSource>> {
        extern "C-unwind" {
            fn CGImageSourceCreateWithDataProvider(
                provider: &CGDataProvider,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageSource>>;
        }
        let ret = unsafe { CGImageSourceCreateWithDataProvider(provider, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates an image source that reads from a Core Foundation data object.
    ///
    /// Parameters:
    /// - data: The data object from which to read. For more information on data objects, see doc://com.apple.documentation/documentation/corefoundation/cfdata-rv9 (Swift), [`CFDataRef`](https://developer.apple.com/documentation/corefoundation/cfdata) (Objective-C), and [Data Objects](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFBinaryData/DataObjects.html#//apple_ref/doc/uid/20000171).
    ///
    /// - options: A dictionary that specifies additional creation options. For a list of possible values, see [Specifying the Read Options](https://developer.apple.com/documentation/imageio/cgimagesource#specifying-the-read-options).
    ///
    ///
    /// ## Return Value
    ///
    /// An image source. You’re responsible for releasing this type using [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageSourceCreateWithData")]
    #[inline]
    pub unsafe fn with_data(
        data: &CFData,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImageSource>> {
        extern "C-unwind" {
            fn CGImageSourceCreateWithData(
                data: &CFData,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageSource>>;
        }
        let ret = unsafe { CGImageSourceCreateWithData(data, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates an image source that reads from a location specified by a URL.
    ///
    /// Parameters:
    /// - url: The URL of the image.
    ///
    /// - options: A dictionary that specifies additional creation options. For a list of possible values, see [Specifying the Read Options](https://developer.apple.com/documentation/imageio/cgimagesource#specifying-the-read-options).
    ///
    ///
    /// ## Return Value
    ///
    /// An image source. You’re responsible for releasing this type using [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageSourceCreateWithURL")]
    #[inline]
    pub unsafe fn with_url(
        url: &CFURL,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImageSource>> {
        extern "C-unwind" {
            fn CGImageSourceCreateWithURL(
                url: &CFURL,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageSource>>;
        }
        let ret = unsafe { CGImageSourceCreateWithURL(url, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the uniform type identifier of the source container.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    ///
    /// ## Return Value
    ///
    /// The uniform type identifier of the image source container.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// The uniform type identifier of the source container can be different from the type of the images in the container. For example, the `.icns` format supports embedded `JPEG2000`. The type of the source container is `"com.apple.icns"`, but type of the images is `JPEG2000`.
    ///
    /// For a list of system-declared and third-party identifiers, see [`Uniform Type Identifiers`](https://developer.apple.com/documentation/uniformtypeidentifiers).
    ///
    ///
    #[doc(alias = "CGImageSourceGetType")]
    #[inline]
    pub unsafe fn r#type(&self) -> Option<CFRetained<CFString>> {
        extern "C-unwind" {
            fn CGImageSourceGetType(isrc: &CGImageSource) -> Option<NonNull<CFString>>;
        }
        let ret = unsafe { CGImageSourceGetType(self) };
        ret.map(|ret| unsafe { CFRetained::retain(ret) })
    }

    /// Returns the number of images (not including thumbnails) in the image source.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    ///
    /// ## Return Value
    ///
    /// The number of images. If the image source is a multilayered Photoshop (PSD) file, the function returns `1`.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function does not extract the layers of a PSD file.
    ///
    ///
    #[doc(alias = "CGImageSourceGetCount")]
    #[inline]
    pub unsafe fn count(&self) -> usize {
        extern "C-unwind" {
            fn CGImageSourceGetCount(isrc: &CGImageSource) -> usize;
        }
        unsafe { CGImageSourceGetCount(self) }
    }

    /// Returns the properties of the image source.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    /// - options: A dictionary you can use to request additional options. For a list of possible values, see [Specifying the Read Options](https://developer.apple.com/documentation/imageio/cgimagesource#specifying-the-read-options).
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary that contains the properties associated with the image source container. See `CGImageProperties` for a list of properties that can be in the dictionary.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// These properties apply to the container in general but not necessarily to any individual image contained in the image source.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageSourceCopyProperties")]
    #[inline]
    pub unsafe fn properties(
        &self,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CGImageSourceCopyProperties(
                isrc: &CGImageSource,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CGImageSourceCopyProperties(self, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the properties of the image at a specified location in an image source.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    /// - index: The zero-based index into the images of the image source. If the index is invalid, this method returns `NULL`.
    ///
    /// - options: A dictionary you can use to request additional options. For a list of possible values, see [Specifying the Read Options](https://developer.apple.com/documentation/imageio/cgimagesource#specifying-the-read-options).
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary that contains the properties associated with the image. See `CGImageProperties` for a list of properties that allowed in the dictionary.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageSourceCopyPropertiesAtIndex")]
    #[inline]
    pub unsafe fn properties_at_index(
        &self,
        index: usize,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CGImageSourceCopyPropertiesAtIndex(
                isrc: &CGImageSource,
                index: usize,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { CGImageSourceCopyPropertiesAtIndex(self, index, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageSourceCopyMetadataAtIndex")]
    #[cfg(feature = "CGImageMetadata")]
    #[inline]
    pub unsafe fn metadata_at_index(
        &self,
        index: usize,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImageMetadata>> {
        extern "C-unwind" {
            fn CGImageSourceCopyMetadataAtIndex(
                isrc: &CGImageSource,
                index: usize,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageMetadata>>;
        }
        let ret = unsafe { CGImageSourceCopyMetadataAtIndex(self, index, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates an image object from the data at the specified index in an image source.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    /// - index: The zero-based index of the image you want. If the index is invalid, this method returns `NULL`.
    ///
    /// - options: A dictionary that specifies additional creation options. For a list of possible values, see [Specifying the Read Options](https://developer.apple.com/documentation/imageio/cgimagesource#specifying-the-read-options).
    ///
    ///
    /// ## Return Value
    ///
    /// The image at the specified index, or `NULL` if an error occurs. You’re responsible for releasing the returned object using [`CGImageRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/coregraphics/1556742-cgimagerelease).
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageSourceCreateImageAtIndex")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub unsafe fn image_at_index(
        &self,
        index: usize,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageSourceCreateImageAtIndex(
                isrc: &CGImageSource,
                index: usize,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageSourceCreateImageAtIndex(self, index, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "CGImageSourceRemoveCacheAtIndex")]
    #[inline]
    pub unsafe fn remove_cache_at_index(&self, index: usize) {
        extern "C-unwind" {
            fn CGImageSourceRemoveCacheAtIndex(isrc: &CGImageSource, index: usize);
        }
        unsafe { CGImageSourceRemoveCacheAtIndex(self, index) }
    }

    /// Creates a thumbnail version of the image at the specified index in an image source.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    /// - index: The zero-based index of the image you want. If the index is invalid, this method returns `NULL`.
    ///
    /// - options: A dictionary that specifies additional creation options. For a list of possible values, see [Specifying the Read Options](https://developer.apple.com/documentation/imageio/cgimagesource#specifying-the-read-options).
    ///
    ///
    /// ## Return Value
    ///
    /// The image at the specified index, or `NULL` if an error occurs. You are responsible for releasing the returned object using [`CGImageRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/coregraphics/1556742-cgimagerelease).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// If the image source is a PDF, this function creates a 72 dpi image of the PDF page specified by the index that you pass. You must, however, pass an options dictionary that contains either the [`kCGImageSourceCreateThumbnailFromImageIfAbsent`](https://developer.apple.com/documentation/imageio/kcgimagesourcecreatethumbnailfromimageifabsent) or [`kCGImageSourceCreateThumbnailFromImageAlways`](https://developer.apple.com/documentation/imageio/kcgimagesourcecreatethumbnailfromimagealways) keys, with the value of the key set to `true`.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageSourceCreateThumbnailAtIndex")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub unsafe fn thumbnail_at_index(
        &self,
        index: usize,
        options: Option<&CFDictionary>,
    ) -> Option<CFRetained<CGImage>> {
        extern "C-unwind" {
            fn CGImageSourceCreateThumbnailAtIndex(
                isrc: &CGImageSource,
                index: usize,
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImage>>;
        }
        let ret = unsafe { CGImageSourceCreateThumbnailAtIndex(self, index, options) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Creates an empty image source that you can use to accumulate incremental image data.
    ///
    /// Parameters:
    /// - options: A dictionary that specifies additional creation options. For a list of possible values, see [Specifying the Read Options](https://developer.apple.com/documentation/imageio/cgimagesource#specifying-the-read-options).
    ///
    ///
    /// ## Return Value
    ///
    /// An empty image source object. You’re responsible for releasing this type using [`CFRelease`](https://developer.apple.comhttps://developer.apple.com/documentation/corefoundation/1521153-cfrelease).
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// This function creates an empty image source container, which you use to accumulate data downloaded in chunks from the network. To add new chunks of data to the image source, call the [`CGImageSourceUpdateDataProvider`](https://developer.apple.com/documentation/imageio/cgimagesourceupdatedataprovider(_:_:_:)) or [`CGImageSourceUpdateData`](https://developer.apple.com/documentation/imageio/cgimagesourceupdatedata(_:_:_:)) functions.
    ///
    ///
    ///
    /// # Safety
    ///
    /// - `options` generic must be of the correct type.
    /// - `options` generic must be of the correct type.
    #[doc(alias = "CGImageSourceCreateIncremental")]
    #[inline]
    pub unsafe fn new_incremental(options: Option<&CFDictionary>) -> CFRetained<CGImageSource> {
        extern "C-unwind" {
            fn CGImageSourceCreateIncremental(
                options: Option<&CFDictionary>,
            ) -> Option<NonNull<CGImageSource>>;
        }
        let ret = unsafe { CGImageSourceCreateIncremental(options) };
        let ret =
            ret.expect("function was marked as returning non-null, but actually returned NULL");
        unsafe { CFRetained::from_raw(ret) }
    }

    /// Updates the data in an incremental image source.
    ///
    /// Parameters:
    /// - isrc: The image source to modify.
    ///
    /// - data: The updated data for the image source. Each time you call this function, specify all of the accumulated image data so far.
    ///
    /// - final: A Boolean value that indicates whether the `data` parameter represents the complete data set. Specify `true` if the data is complete or `false` if it isn’t.
    ///
    ///
    /// ## Discussion
    ///
    /// This method updates the state of the image source and its contained images. Call this method one or more times to update the contents of an incremental data source. Each time you call the method, you must specify all of the accumulated image data, not just the new data you received.
    ///
    ///
    #[doc(alias = "CGImageSourceUpdateData")]
    #[inline]
    pub unsafe fn update_data(&self, data: &CFData, r#final: bool) {
        extern "C-unwind" {
            fn CGImageSourceUpdateData(isrc: &CGImageSource, data: &CFData, r#final: bool);
        }
        unsafe { CGImageSourceUpdateData(self, data, r#final) }
    }

    /// Updates an incremental image source with a new data provider.
    ///
    /// Parameters:
    /// - isrc: The image source to modify.
    ///
    /// - provider: The new data provider. The new data provider must provide all the previous data supplied to the image source and any additional new data.
    ///
    /// - final: A Boolean value that indicates whether the `provider` parameter provides the complete data set. Specify `true` if the data is complete or `false` if it isn’t.
    ///
    #[doc(alias = "CGImageSourceUpdateDataProvider")]
    #[cfg(feature = "objc2-core-graphics")]
    #[inline]
    pub unsafe fn update_data_provider(&self, provider: &CGDataProvider, r#final: bool) {
        extern "C-unwind" {
            fn CGImageSourceUpdateDataProvider(
                isrc: &CGImageSource,
                provider: &CGDataProvider,
                r#final: bool,
            );
        }
        unsafe { CGImageSourceUpdateDataProvider(self, provider, r#final) }
    }

    /// Return the status of an image source.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the current status of the image source. See [`CGImageSourceStatus`](https://developer.apple.com/documentation/imageio/cgimagesourcestatus) for a list of possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Status information is particularly informative for incremental image sources, but it may also be useful on image sources that contain non-incremental data.
    ///
    ///
    #[doc(alias = "CGImageSourceGetStatus")]
    #[inline]
    pub unsafe fn status(&self) -> CGImageSourceStatus {
        extern "C-unwind" {
            fn CGImageSourceGetStatus(isrc: &CGImageSource) -> CGImageSourceStatus;
        }
        unsafe { CGImageSourceGetStatus(self) }
    }

    /// Returns the current status of an image at the specified location in the image source.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    /// - index: The zero-based index into the images of the image source. If the index is invalid, this method returns `NULL`.
    ///
    ///
    /// ## Return Value
    ///
    /// Returns the current status of the image. See [`CGImageSourceStatus`](https://developer.apple.com/documentation/imageio/cgimagesourcestatus) for a list of possible values.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Status information is particularly informative for incremental image sources, but you may also use it on image sources that contain non-incremental data.
    ///
    ///
    #[doc(alias = "CGImageSourceGetStatusAtIndex")]
    #[inline]
    pub unsafe fn status_at_index(&self, index: usize) -> CGImageSourceStatus {
        extern "C-unwind" {
            fn CGImageSourceGetStatusAtIndex(
                isrc: &CGImageSource,
                index: usize,
            ) -> CGImageSourceStatus;
        }
        unsafe { CGImageSourceGetStatusAtIndex(self, index) }
    }

    /// Returns the index of the primary image for an High Efficiency Image File Format (HEIF) image.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    ///
    /// ## Return Value
    ///
    /// The index of the primary image, or `0` for image formats other than the HEIF format.
    ///
    ///
    #[doc(alias = "CGImageSourceGetPrimaryImageIndex")]
    #[inline]
    pub unsafe fn primary_image_index(&self) -> usize {
        extern "C-unwind" {
            fn CGImageSourceGetPrimaryImageIndex(isrc: &CGImageSource) -> usize;
        }
        unsafe { CGImageSourceGetPrimaryImageIndex(self) }
    }

    /// Returns auxiliary data, such as mattes and depth information, that accompany the image.
    ///
    /// Parameters:
    /// - isrc: The image source that contains the image data.
    ///
    /// - index: The zero-based index into the images of the image source. If the index is invalid, this method returns `NULL`.
    ///
    /// - auxiliaryImageDataType: The auxiliary data to retrieve. For a list of possible values, see [Auxiliary Image Data](https://developer.apple.com/documentation/imageio/individual-image-properties#auxiliary-image-data) and [Auxiliary Data Types](https://developer.apple.com/documentation/imageio/individual-image-properties#auxiliary-data-types).
    ///
    ///
    /// ## Return Value
    ///
    /// A dictionary that contains the auxiliary data, or `NULL` if an error occurs.
    ///
    ///
    #[doc(alias = "CGImageSourceCopyAuxiliaryDataInfoAtIndex")]
    #[inline]
    pub unsafe fn auxiliary_data_info_at_index(
        &self,
        index: usize,
        auxiliary_image_data_type: &CFString,
    ) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn CGImageSourceCopyAuxiliaryDataInfoAtIndex(
                isrc: &CGImageSource,
                index: usize,
                auxiliary_image_data_type: &CFString,
            ) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe {
            CGImageSourceCopyAuxiliaryDataInfoAtIndex(self, index, auxiliary_image_data_type)
        };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }
}

extern "C" {
    ///
    /// ## Overview
    ///
    /// For more information, see [Image I/O Programming Guide](https://developer.apple.com/library/archive/documentation/GraphicsImaging/Conceptual/ImageIOGuide/imageio_intro/ikpg_intro.html#//apple_ref/doc/uid/TP40005462).
    ///
    ///
    pub static kCGImageSourceDecodeRequest: &'static CFString;
}

extern "C" {
    pub static kCGImageSourceDecodeToHDR: &'static CFString;
}

extern "C" {
    pub static kCGImageSourceDecodeToSDR: &'static CFString;
}

extern "C" {
    pub static kCGImageSourceGenerateImageSpecificLumaScaling: &'static CFString;
}

extern "C" {
    pub static kCGImageSourceDecodeRequestOptions: &'static CFString;
}

extern "C" {
    pub static kCGComputeHDRStats: &'static CFString;
}

impl CGImageSource {
    /// # Safety
    ///
    /// `allowable_types` generic must be of the correct type.
    #[doc(alias = "CGImageSourceSetAllowableTypes")]
    #[inline]
    pub unsafe fn set_allowable_types(allowable_types: &CFArray) -> OSStatus {
        extern "C-unwind" {
            fn CGImageSourceSetAllowableTypes(allowable_types: &CFArray) -> OSStatus;
        }
        unsafe { CGImageSourceSetAllowableTypes(allowable_types) }
    }
}

#[deprecated = "renamed to `CGImageSource::type_identifiers`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyTypeIdentifiers() -> CFRetained<CFArray> {
    extern "C-unwind" {
        fn CGImageSourceCopyTypeIdentifiers() -> Option<NonNull<CFArray>>;
    }
    let ret = unsafe { CGImageSourceCopyTypeIdentifiers() };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

#[cfg(feature = "objc2-core-graphics")]
#[deprecated = "renamed to `CGImageSource::with_data_provider`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateWithDataProvider(
    provider: &CGDataProvider,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImageSource>> {
    extern "C-unwind" {
        fn CGImageSourceCreateWithDataProvider(
            provider: &CGDataProvider,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageSource>>;
    }
    let ret = unsafe { CGImageSourceCreateWithDataProvider(provider, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::with_data`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateWithData(
    data: &CFData,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImageSource>> {
    extern "C-unwind" {
        fn CGImageSourceCreateWithData(
            data: &CFData,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageSource>>;
    }
    let ret = unsafe { CGImageSourceCreateWithData(data, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::with_url`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateWithURL(
    url: &CFURL,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImageSource>> {
    extern "C-unwind" {
        fn CGImageSourceCreateWithURL(
            url: &CFURL,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageSource>>;
    }
    let ret = unsafe { CGImageSourceCreateWithURL(url, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::type`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceGetType(
    isrc: &CGImageSource,
) -> Option<CFRetained<CFString>> {
    extern "C-unwind" {
        fn CGImageSourceGetType(isrc: &CGImageSource) -> Option<NonNull<CFString>>;
    }
    let ret = unsafe { CGImageSourceGetType(isrc) };
    ret.map(|ret| unsafe { CFRetained::retain(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::count`"]
    pub fn CGImageSourceGetCount(isrc: &CGImageSource) -> usize;
}

#[deprecated = "renamed to `CGImageSource::properties`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyProperties(
    isrc: &CGImageSource,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CGImageSourceCopyProperties(
            isrc: &CGImageSource,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGImageSourceCopyProperties(isrc, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::properties_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyPropertiesAtIndex(
    isrc: &CGImageSource,
    index: usize,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CGImageSourceCopyPropertiesAtIndex(
            isrc: &CGImageSource,
            index: usize,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { CGImageSourceCopyPropertiesAtIndex(isrc, index, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "CGImageMetadata")]
#[deprecated = "renamed to `CGImageSource::metadata_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyMetadataAtIndex(
    isrc: &CGImageSource,
    index: usize,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImageMetadata>> {
    extern "C-unwind" {
        fn CGImageSourceCopyMetadataAtIndex(
            isrc: &CGImageSource,
            index: usize,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageMetadata>>;
    }
    let ret = unsafe { CGImageSourceCopyMetadataAtIndex(isrc, index, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-graphics")]
#[deprecated = "renamed to `CGImageSource::image_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateImageAtIndex(
    isrc: &CGImageSource,
    index: usize,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageSourceCreateImageAtIndex(
            isrc: &CGImageSource,
            index: usize,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageSourceCreateImageAtIndex(isrc, index, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::remove_cache_at_index`"]
    pub fn CGImageSourceRemoveCacheAtIndex(isrc: &CGImageSource, index: usize);
}

#[cfg(feature = "objc2-core-graphics")]
#[deprecated = "renamed to `CGImageSource::thumbnail_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateThumbnailAtIndex(
    isrc: &CGImageSource,
    index: usize,
    options: Option<&CFDictionary>,
) -> Option<CFRetained<CGImage>> {
    extern "C-unwind" {
        fn CGImageSourceCreateThumbnailAtIndex(
            isrc: &CGImageSource,
            index: usize,
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImage>>;
    }
    let ret = unsafe { CGImageSourceCreateThumbnailAtIndex(isrc, index, options) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `CGImageSource::new_incremental`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCreateIncremental(
    options: Option<&CFDictionary>,
) -> CFRetained<CGImageSource> {
    extern "C-unwind" {
        fn CGImageSourceCreateIncremental(
            options: Option<&CFDictionary>,
        ) -> Option<NonNull<CGImageSource>>;
    }
    let ret = unsafe { CGImageSourceCreateIncremental(options) };
    let ret = ret.expect("function was marked as returning non-null, but actually returned NULL");
    unsafe { CFRetained::from_raw(ret) }
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::update_data`"]
    pub fn CGImageSourceUpdateData(isrc: &CGImageSource, data: &CFData, r#final: bool);
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-graphics")]
    #[deprecated = "renamed to `CGImageSource::update_data_provider`"]
    pub fn CGImageSourceUpdateDataProvider(
        isrc: &CGImageSource,
        provider: &CGDataProvider,
        r#final: bool,
    );
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::status`"]
    pub fn CGImageSourceGetStatus(isrc: &CGImageSource) -> CGImageSourceStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::status_at_index`"]
    pub fn CGImageSourceGetStatusAtIndex(isrc: &CGImageSource, index: usize)
        -> CGImageSourceStatus;
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::primary_image_index`"]
    pub fn CGImageSourceGetPrimaryImageIndex(isrc: &CGImageSource) -> usize;
}

#[deprecated = "renamed to `CGImageSource::auxiliary_data_info_at_index`"]
#[inline]
pub unsafe extern "C-unwind" fn CGImageSourceCopyAuxiliaryDataInfoAtIndex(
    isrc: &CGImageSource,
    index: usize,
    auxiliary_image_data_type: &CFString,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn CGImageSourceCopyAuxiliaryDataInfoAtIndex(
            isrc: &CGImageSource,
            index: usize,
            auxiliary_image_data_type: &CFString,
        ) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe {
        CGImageSourceCopyAuxiliaryDataInfoAtIndex(isrc, index, auxiliary_image_data_type)
    };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

extern "C-unwind" {
    #[deprecated = "renamed to `CGImageSource::set_allowable_types`"]
    pub fn CGImageSourceSetAllowableTypes(allowable_types: &CFArray) -> OSStatus;
}
