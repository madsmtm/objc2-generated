//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// A descriptor that defines a complication and the families that it supports.
    ///
    /// ## Overview
    ///
    /// Use complication descriptors to define the different types of complications that your app supports. Each descriptor provides a unique identifier for the complication, and the list of families that the complication supports. ClockKit defines the available families using the [`CLKComplicationFamily`](https://developer.apple.com/documentation/clockkit/clkcomplicationfamily) enumeration, while your app can define as many identifiers as it needs. Each unique [`identifier`](https://developer.apple.com/documentation/clockkit/clkcomplication/identifier) within your app represents a separate complication in the complication picker. For example, a weather app may have separate descriptors for `Condition`, `Temperature`, and `Precipitation.`
    ///
    /// ```swift
    /// // Create the condition descriptor.
    /// let conditionDescriptor = CLKComplicationDescriptor(
    ///     identifier: complicationConditionIdentifier,
    ///     displayName: "Weather Condition",
    ///     supportedFamilies: mySupportedFamilies)
    ///
    /// // Create the temperature descriptor.
    /// let temperatureDescriptor = CLKComplicationDescriptor(
    ///     identifier: complicationTemperatureIdentifier,
    ///     displayName: "Temperature",
    ///     supportedFamilies: mySupportedFamilies)
    ///
    /// // Create the precipitation descriptor.
    /// let precipitationDescriptor = CLKComplicationDescriptor(
    ///     identifier: complicationPrecipitationIdentifier,
    ///     displayName: "Percipitation",
    ///     supportedFamilies: mySupportedFamilies)
    /// ```
    ///
    /// You can dynamically create unique identifiers to further customize the complications. For example, if the weather app provides separate complications for all the cities in the user’s favorite city list, it can create a separate descriptor for each city and weather data pair. The app can create unique identifiers by appending the city name and the weather data’s name.
    ///
    /// ```swift
    /// func getComplicationDescriptors(handler: @escaping ([CLKComplicationDescriptor]) -> Void) {
    ///     var descriptors = [CLKComplicationDescriptor]()
    ///     
    ///     for city in myData.favoriteCities {
    ///         
    ///         let conditionIdentifier = complicationConditionIdentifier + ": \(city.id)"
    ///         let temperatureIdentifier = complicationTemperatureIdentifier + ": \(city.id)"
    ///         let perceptionIdentifier = complicationPrecipitationIdentifier + ": \(city.id)"
    ///         
    ///         // Create the descriptors for the city.
    ///         descriptors.append(CLKComplicationDescriptor(
    ///                             identifier: conditionIdentifier,
    ///                             displayName: "\(city.abbreviation) Weather Condition",
    ///                             supportedFamilies: CLKComplicationFamily.allCases,
    ///                             userInfo: [myCityIDKey: city.id,
    ///                                        myTypeIdentifierKey: conditionIdentifier]))
    ///
    ///         descriptors.append(CLKComplicationDescriptor(
    ///                             identifier: temperatureIdentifier,
    ///                             displayName: "\(city.abbreviation) Temperature",
    ///                             supportedFamilies: CLKComplicationFamily.allCases,
    ///                             userInfo: [myCityIDKey: city.id,
    ///                                        myTypeIdentifierKey: temperatureIdentifier]))
    ///
    ///         descriptors.append(CLKComplicationDescriptor(
    ///                             identifier: perceptionIdentifier,
    ///                             displayName: "\(city.abbreviation) Percipitation",
    ///                             supportedFamilies: CLKComplicationFamily.allCases,
    ///                             userInfo: [myCityIDKey: city.id,
    ///                                        myTypeIdentifierKey: perceptionIdentifier]))
    ///         
    ///     }
    ///     
    ///     // The order of the descriptors array
    ///     // determines the order in the complication picker.
    ///     handler(descriptors)
    /// }
    /// ```
    ///
    /// When dynamically creating identifiers, consider using the descriptor’s [`userInfo`](https://developer.apple.com/documentation/clockkit/clkcomplicationdescriptor/userinfo) property to contain any additional information your app needs to create timeline entries for the complication. In the above example, the weather app adds the `myCityIDKey` and `myTypeIdentifierKey` `keys` so that it can access the city and weather data type without parsing the `identifier` string.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct CLKComplicationDescriptor;
);

unsafe impl Send for CLKComplicationDescriptor {}

unsafe impl Sync for CLKComplicationDescriptor {}

extern_conformance!(
    unsafe impl NSObjectProtocol for CLKComplicationDescriptor {}
);

impl CLKComplicationDescriptor {
    extern_methods!(
        /// Identifies this complication.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(identifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn identifier(&self) -> Retained<NSString>;

        /// The display name for this complication.
        /// This will be displayed when editing complications of a watch face.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(displayName))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayName(&self) -> Retained<NSString>;

        /// An array of `CLKComplicationFamily`s that this complication supports.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(supportedFamilies))]
        #[unsafe(method_family = none)]
        pub unsafe fn supportedFamilies(&self) -> Retained<NSArray<NSNumber>>;

        /// An optional dictionary that can be used to pass information back to your extension via CLKComplication.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInfo(&self) -> Option<Retained<NSDictionary>>;

        /// An optional user activity that can be used to pass information back to your extension via CLKComplication.
        /// This activity will be used to launch your app when the complication is tapped on.
        ///
        /// This property is not atomic.
        ///
        /// # Safety
        ///
        /// This might not be thread-safe.
        #[unsafe(method(userActivity))]
        #[unsafe(method_family = none)]
        pub unsafe fn userActivity(&self) -> Option<Retained<NSUserActivity>>;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;

        #[deprecated = "On watchOS 9.0 or later, use WidgetKit instead"]
        #[unsafe(method(initWithIdentifier:displayName:supportedFamilies:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier_displayName_supportedFamilies(
            this: Allocated<Self>,
            identifier: &NSString,
            display_name: &NSString,
            supported_families: &NSArray<NSNumber>,
        ) -> Retained<Self>;

        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[deprecated = "On watchOS 9.0 or later, use WidgetKit instead"]
        #[unsafe(method(initWithIdentifier:displayName:supportedFamilies:userInfo:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier_displayName_supportedFamilies_userInfo(
            this: Allocated<Self>,
            identifier: &NSString,
            display_name: &NSString,
            supported_families: &NSArray<NSNumber>,
            user_info: &NSDictionary,
        ) -> Retained<Self>;

        #[deprecated = "On watchOS 9.0 or later, use WidgetKit instead"]
        #[unsafe(method(initWithIdentifier:displayName:supportedFamilies:userActivity:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithIdentifier_displayName_supportedFamilies_userActivity(
            this: Allocated<Self>,
            identifier: &NSString,
            display_name: &NSString,
            supported_families: &NSArray<NSNumber>,
            user_activity: &NSUserActivity,
        ) -> Retained<Self>;
    );
}
