//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/spritekit/sktextureatlas?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SKTextureAtlas;
);

extern_conformance!(
    unsafe impl NSCoding for SKTextureAtlas {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for SKTextureAtlas {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for SKTextureAtlas {}
);

impl SKTextureAtlas {
    extern_methods!(
        #[unsafe(method(atlasNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn atlasNamed(name: &NSString) -> Retained<Self>;

        /// # Safety
        ///
        /// `properties` generic should be of the correct type.
        #[unsafe(method(atlasWithDictionary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn atlasWithDictionary(
            properties: &NSDictionary<NSString, AnyObject>,
        ) -> Retained<Self>;

        #[cfg(feature = "SKTexture")]
        #[unsafe(method(textureNamed:))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNamed(&self, name: &NSString) -> Retained<SKTexture>;

        #[cfg(feature = "block2")]
        /// Start a texture atlas preload operation on an array of texture atlas
        ///
        ///
        /// Parameter `textureAtlases`: an array of SKTextureAtlas to be preloaded
        ///
        /// Parameter `completionHandler`: will be called upon the preload completion
        #[unsafe(method(preloadTextureAtlases:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn preloadTextureAtlases_withCompletionHandler(
            texture_atlases: &NSArray<SKTextureAtlas>,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[cfg(feature = "block2")]
        /// Start a texture atlas preload operation on an array of texture atlas identifiers, error == nil if all atlases were found,
        /// else an NSError is returned and the user info will contain a list of the atlases that couldn't be found
        /// the ones that could be found are looked up and prefetched.
        ///
        ///
        /// Parameter `atlasNames`: is an array of the SKTextureAtlas, that were located and preloaded.
        ///
        /// Parameter `completionHandler`: will be called upon the preload completion.
        #[unsafe(method(preloadTextureAtlasesNamed:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn preloadTextureAtlasesNamed_withCompletionHandler(
            atlas_names: &NSArray<NSString>,
            completion_handler: &block2::DynBlock<
                dyn Fn(*mut NSError, NonNull<NSArray<SKTextureAtlas>>),
            >,
        );

        #[cfg(feature = "block2")]
        /// Request that this texture atlas be loaded into vram on the next render update, with a callback handler.
        #[unsafe(method(preloadWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn preloadWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn()>,
        );

        #[unsafe(method(textureNames))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureNames(&self) -> Retained<NSArray<NSString>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl SKTextureAtlas {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
