//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-avf-audio")]
use objc2_avf_audio::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-graphics")]
use objc2_core_graphics::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-metal")]
#[cfg(not(target_os = "watchos"))]
use objc2_metal::*;

use crate::*;

/// antialiasing modes for scene renderers
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnantialiasingmode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SCNAntialiasingMode(pub NSUInteger);
impl SCNAntialiasingMode {
    #[doc(alias = "SCNAntialiasingModeNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "SCNAntialiasingModeMultisampling2X")]
    pub const Multisampling2X: Self = Self(1);
    #[doc(alias = "SCNAntialiasingModeMultisampling4X")]
    pub const Multisampling4X: Self = Self(2);
    #[doc(alias = "SCNAntialiasingModeMultisampling8X")]
    pub const Multisampling8X: Self = Self(3);
    #[doc(alias = "SCNAntialiasingModeMultisampling16X")]
    pub const Multisampling16X: Self = Self(4);
}

unsafe impl Encode for SCNAntialiasingMode {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for SCNAntialiasingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// rendering API used by SCNView and SCNRenderer.
///
/// Default preferred API is SCNRenderingAPIMetal on iOS and it depends on the configuration on macOS.
/// If Metal is requested but not available then it fallbacks to SCNRenderingAPIOpenGLES2 on iOS and to SCNRenderingAPIOpenGLLegacy on macOS.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnrenderingapi?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SCNRenderingAPI(pub NSUInteger);
impl SCNRenderingAPI {
    #[doc(alias = "SCNRenderingAPIMetal")]
    pub const Metal: Self = Self(0);
    #[doc(alias = "SCNRenderingAPIOpenGLLegacy")]
    pub const OpenGLLegacy: Self = Self(1);
    #[doc(alias = "SCNRenderingAPIOpenGLCore32")]
    pub const OpenGLCore32: Self = Self(2);
    #[doc(alias = "SCNRenderingAPIOpenGLCore41")]
    pub const OpenGLCore41: Self = Self(3);
}

unsafe impl Encode for SCNRenderingAPI {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for SCNRenderingAPI {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Debug options.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scndebugoptions?language=objc)
// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SCNDebugOptions(pub NSUInteger);
bitflags::bitflags! {
    impl SCNDebugOptions: NSUInteger {
        #[doc(alias = "SCNDebugOptionNone")]
        const None = 0;
        #[doc(alias = "SCNDebugOptionShowPhysicsShapes")]
        const ShowPhysicsShapes = 1<<0;
        #[doc(alias = "SCNDebugOptionShowBoundingBoxes")]
        const ShowBoundingBoxes = 1<<1;
        #[doc(alias = "SCNDebugOptionShowLightInfluences")]
        const ShowLightInfluences = 1<<2;
        #[doc(alias = "SCNDebugOptionShowLightExtents")]
        const ShowLightExtents = 1<<3;
        #[doc(alias = "SCNDebugOptionShowPhysicsFields")]
        const ShowPhysicsFields = 1<<4;
        #[doc(alias = "SCNDebugOptionShowWireframe")]
        const ShowWireframe = 1<<5;
        #[doc(alias = "SCNDebugOptionRenderAsWireframe")]
        const RenderAsWireframe = 1<<6;
        #[doc(alias = "SCNDebugOptionShowSkeletons")]
        const ShowSkeletons = 1<<7;
        #[doc(alias = "SCNDebugOptionShowCreases")]
        const ShowCreases = 1<<8;
        #[doc(alias = "SCNDebugOptionShowConstraints")]
        const ShowConstraints = 1<<9;
        #[doc(alias = "SCNDebugOptionShowCameras")]
        const ShowCameras = 1<<10;
    }
}

unsafe impl Encode for SCNDebugOptions {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for SCNDebugOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// Protocol adopted by the various renderers (SCNView, SCNLayer, SCNRenderer)
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnscenerenderer?language=objc)
    pub unsafe trait SCNSceneRenderer: NSObjectProtocol {
        #[cfg(feature = "SCNScene")]
        /// Specifies the scene of the receiver.
        #[unsafe(method(scene))]
        #[unsafe(method_family = none)]
        unsafe fn scene(&self) -> Option<Retained<SCNScene>>;

        #[cfg(feature = "SCNScene")]
        /// Setter for [`scene`][Self::scene].
        #[unsafe(method(setScene:))]
        #[unsafe(method_family = none)]
        unsafe fn setScene(&self, scene: Option<&SCNScene>);

        /// Specifies the current "scene time" to display the scene.
        ///
        /// The scene time only affect scene time based animations (see SCNAnimation.h "usesSceneTimeBase" and SCNSceneSource.h "SCNSceneSourceAnimationImportPolicyKey" for how to create scene time based animations). Scene time based animations and this property are typically used by tools and viewer to ease seeking in time while previewing a scene.
        #[unsafe(method(sceneTime))]
        #[unsafe(method_family = none)]
        unsafe fn sceneTime(&self) -> NSTimeInterval;

        /// Setter for [`sceneTime`][Self::sceneTime].
        #[unsafe(method(setSceneTime:))]
        #[unsafe(method_family = none)]
        unsafe fn setSceneTime(&self, scene_time: NSTimeInterval);

        /// Specifies the renderer delegate.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        unsafe fn delegate(&self)
            -> Option<Retained<ProtocolObject<dyn SCNSceneRendererDelegate>>>;

        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn SCNSceneRendererDelegate>>,
        );

        #[cfg(all(feature = "SCNHitTest", feature = "objc2-core-foundation"))]
        /// Returns an array of SCNHitTestResult for each node that contains a specified point.
        ///
        /// Parameter `point`: A point in the coordinate system of the receiver.
        ///
        /// Parameter `options`: Optional parameters (see the "Hit test options" group for the available options).
        #[unsafe(method(hitTest:options:))]
        #[unsafe(method_family = none)]
        unsafe fn hitTest_options(
            &self,
            point: CGPoint,
            options: Option<&NSDictionary<SCNHitTestOption, AnyObject>>,
        ) -> Retained<NSArray<SCNHitTestResult>>;

        #[cfg(feature = "SCNNode")]
        /// Test whether node is visible from the specified point of view.
        ///
        /// Parameter `node`: The node to test the visibility of.
        ///
        /// Parameter `pointOfView`: The point of view used to test the visibility.
        ///
        /// Return YES if the node is inside or intersects the clipping planes of the point of view. This method doesn't test if 'node' is occluded by another node.
        #[unsafe(method(isNodeInsideFrustum:withPointOfView:))]
        #[unsafe(method_family = none)]
        unsafe fn isNodeInsideFrustum_withPointOfView(
            &self,
            node: &SCNNode,
            point_of_view: &SCNNode,
        ) -> bool;

        #[cfg(feature = "SCNNode")]
        /// Returns an array containing the nodes visible from the specified point of view.
        ///
        /// Parameter `pointOfView`: The point of view used to test the visibility.
        ///
        /// Returns an array of all the nodes that are inside or intersects the clipping planes of the point of view. Starting in macOS10.13/iOS11 this method work with the presentation tree.
        #[unsafe(method(nodesInsideFrustumWithPointOfView:))]
        #[unsafe(method_family = none)]
        unsafe fn nodesInsideFrustumWithPointOfView(
            &self,
            point_of_view: &SCNNode,
        ) -> Retained<NSArray<SCNNode>>;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Projects a point in the world coordinate system using the receiver's current point of view and viewport.
        ///
        /// Parameter `point`: The world position to be projected.
        ///
        /// A point projected from the near (resp. far) clip plane will have a z component of 0 (resp. 1). Starting in macOS 11.0, iOS 14, tvOS 14 and watchOS 7 the range of z component will be reversed (from 1 to 0) if the receiver uses 'reverseZ'.
        #[unsafe(method(projectPoint:))]
        #[unsafe(method_family = none)]
        unsafe fn projectPoint(&self, point: SCNVector3) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Unprojects a screenspace 2D point with depth info using the receiver's current point of view and viewport.
        ///
        /// Parameter `point`: The screenspace position to be unprojected.
        ///
        /// A point whose z component is 0 (resp. 1) is unprojected on the near (resp. far) clip plane. Starting in macOS 11.0, iOS 14, tvOS 14 and watchOS 7 the range of the z component will be reversed (from 1 to 0) if the receiver uses 'reverseZ'.
        #[unsafe(method(unprojectPoint:))]
        #[unsafe(method_family = none)]
        unsafe fn unprojectPoint(&self, point: SCNVector3) -> SCNVector3;

        /// Returns YES if the scene is playing, NO otherwise.
        #[unsafe(method(isPlaying))]
        #[unsafe(method_family = none)]
        unsafe fn isPlaying(&self) -> bool;

        /// Setter for [`isPlaying`][Self::isPlaying].
        #[unsafe(method(setPlaying:))]
        #[unsafe(method_family = none)]
        unsafe fn setPlaying(&self, playing: bool);

        /// Indicates whether the receiver restarts playback when it reaches the end of its content. Default: YES.
        ///
        /// YES when the receiver restarts playback when it finishes, NO otherwise.
        #[unsafe(method(loops))]
        #[unsafe(method_family = none)]
        unsafe fn loops(&self) -> bool;

        /// Setter for [`loops`][Self::loops].
        #[unsafe(method(setLoops:))]
        #[unsafe(method_family = none)]
        unsafe fn setLoops(&self, loops: bool);

        #[cfg(feature = "SCNNode")]
        /// Specifies the point of view used to render the scene.
        ///
        /// A point of view must have either a camera or a spot light attached.
        #[unsafe(method(pointOfView))]
        #[unsafe(method_family = none)]
        unsafe fn pointOfView(&self) -> Option<Retained<SCNNode>>;

        #[cfg(feature = "SCNNode")]
        /// Setter for [`pointOfView`][Self::pointOfView].
        #[unsafe(method(setPointOfView:))]
        #[unsafe(method_family = none)]
        unsafe fn setPointOfView(&self, point_of_view: Option<&SCNNode>);

        /// Specifies whether the receiver should automatically light up scenes that have no light source. The default is NO.
        ///
        /// When enabled, a diffuse light is automatically added and placed while rendering scenes that have no light or only ambient lights.
        #[unsafe(method(autoenablesDefaultLighting))]
        #[unsafe(method_family = none)]
        unsafe fn autoenablesDefaultLighting(&self) -> bool;

        /// Setter for [`autoenablesDefaultLighting`][Self::autoenablesDefaultLighting].
        #[unsafe(method(setAutoenablesDefaultLighting:))]
        #[unsafe(method_family = none)]
        unsafe fn setAutoenablesDefaultLighting(&self, autoenables_default_lighting: bool);

        /// Specifies whether the receiver should jitter the rendered scene to reduce aliasing artifacts.
        ///
        /// When enabled, the jittering is performed asynchronously and automatically by SCNView and SCNLayer. It is done synchronously by SCNRenderer.
        #[unsafe(method(isJitteringEnabled))]
        #[unsafe(method_family = none)]
        unsafe fn isJitteringEnabled(&self) -> bool;

        /// Setter for [`isJitteringEnabled`][Self::isJitteringEnabled].
        #[unsafe(method(setJitteringEnabled:))]
        #[unsafe(method_family = none)]
        unsafe fn setJitteringEnabled(&self, jittering_enabled: bool);

        /// Specifies whether the receiver should reduce aliasing artifacts in real time based on temporal coherency. Defaults to NO.
        #[unsafe(method(isTemporalAntialiasingEnabled))]
        #[unsafe(method_family = none)]
        unsafe fn isTemporalAntialiasingEnabled(&self) -> bool;

        /// Setter for [`isTemporalAntialiasingEnabled`][Self::isTemporalAntialiasingEnabled].
        #[unsafe(method(setTemporalAntialiasingEnabled:))]
        #[unsafe(method_family = none)]
        unsafe fn setTemporalAntialiasingEnabled(&self, temporal_antialiasing_enabled: bool);

        #[cfg(feature = "block2")]
        /// Prepare the specified object for drawing.
        ///
        /// Parameter `object`: The object to prepare. It can be an instance of SCNScene, SCNNode, SCNGeometry, or SCNMaterial
        ///
        /// Parameter `block`: This block will be called repeatedly while the object is prepared. Return YES if you want the operation to abort.
        ///
        /// Returns YES if the object was prepared successfully, NO if it was canceled. This method may be triggered from a secondary thread. This method is observable using NSProgress.
        #[unsafe(method(prepareObject:shouldAbortBlock:))]
        #[unsafe(method_family = none)]
        unsafe fn prepareObject_shouldAbortBlock(
            &self,
            object: &AnyObject,
            block: Option<&block2::Block<dyn Fn() -> Bool + '_>>,
        ) -> bool;

        #[cfg(feature = "block2")]
        /// Prepare the specified objects for drawing on the background.
        ///
        /// Parameter `objects`: The objects to prepare. It can be one or more instances of SCNScene, SCNNode, SCNGeometry, or SCNMaterial
        ///
        /// Parameter `completionHandler`: This block will be called when all objects has been prepared, or on failure.
        ///
        /// This method is observable using NSProgress.
        #[unsafe(method(prepareObjects:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn prepareObjects_withCompletionHandler(
            &self,
            objects: &NSArray,
            completion_handler: Option<&block2::Block<dyn Fn(Bool)>>,
        );

        /// Determines whether the receiver should display statistics info like FPS. Defaults to NO.
        ///
        /// When set to YES, statistics are displayed in a overlay on top of the rendered scene.
        #[unsafe(method(showsStatistics))]
        #[unsafe(method_family = none)]
        unsafe fn showsStatistics(&self) -> bool;

        /// Setter for [`showsStatistics`][Self::showsStatistics].
        #[unsafe(method(setShowsStatistics:))]
        #[unsafe(method_family = none)]
        unsafe fn setShowsStatistics(&self, shows_statistics: bool);

        /// Specifies the debug options of the receiver. Defaults to SCNDebugOptionNone.
        #[unsafe(method(debugOptions))]
        #[unsafe(method_family = none)]
        unsafe fn debugOptions(&self) -> SCNDebugOptions;

        /// Setter for [`debugOptions`][Self::debugOptions].
        #[unsafe(method(setDebugOptions:))]
        #[unsafe(method_family = none)]
        unsafe fn setDebugOptions(&self, debug_options: SCNDebugOptions);

        /// Specifies the rendering API associated to the receiver.
        ///
        /// This is the rendering API effectively used by the receiver. You can specify a preferred rendering API when initializing a view programmatically (see SCNPreferredRenderingAPI in SCNSceneRenderer.h) or using Interface Builder's SCNView inspector.
        #[unsafe(method(renderingAPI))]
        #[unsafe(method_family = none)]
        unsafe fn renderingAPI(&self) -> SCNRenderingAPI;

        #[cfg(feature = "objc2-core-graphics")]
        /// Specifies the color space used by the receiver for shading.
        ///
        /// SceneKit will automatically color match image and color objects (NSImage, NSColor, CGImageRef, CGColorRef, etc.). When you directly provide color components to shaders, use this property to color match them to the working color space.
        #[unsafe(method(workingColorSpace))]
        #[unsafe(method_family = none)]
        unsafe fn workingColorSpace(&self) -> Retained<CGColorSpace>;

        /// A Core OpenGL render context that is used as the render target (a CGLContextObj on macOS, an EAGLContext on iOS).
        #[unsafe(method(context))]
        #[unsafe(method_family = none)]
        unsafe fn context(&self) -> *mut c_void;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// The current render command encoder if any. This property is only valid within the SCNSceneRendererDelegate methods and when rendering with Metal. Otherwise it is set to nil.
        #[unsafe(method(currentRenderCommandEncoder))]
        #[unsafe(method_family = none)]
        unsafe fn currentRenderCommandEncoder(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn MTLRenderCommandEncoder>>>;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// The render pass descriptor of the receiver. This property is only valid within the SCNSceneRendererDelegate methods and when rendering with Metal. Otherwise it is set to nil.
        #[unsafe(method(currentRenderPassDescriptor))]
        #[unsafe(method_family = none)]
        unsafe fn currentRenderPassDescriptor(&self) -> Retained<MTLRenderPassDescriptor>;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// The metal device of the renderer. This property is only valid on a renderer created with a Metal device. Otherwise it is set to nil.
        #[unsafe(method(device))]
        #[unsafe(method_family = none)]
        unsafe fn device(&self) -> Option<Retained<ProtocolObject<dyn MTLDevice>>>;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// The pixel format of the color attachment 0 of the renderer. This property is only valid on a renderer created with a Metal device.
        #[unsafe(method(colorPixelFormat))]
        #[unsafe(method_family = none)]
        unsafe fn colorPixelFormat(&self) -> MTLPixelFormat;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// The pixel format of the depth attachment of the renderer. This property is only valid on a renderer created with a Metal device.
        #[unsafe(method(depthPixelFormat))]
        #[unsafe(method_family = none)]
        unsafe fn depthPixelFormat(&self) -> MTLPixelFormat;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// The pixel format of the stencil attachment of the renderer. This property is only valid on a renderer created with a Metal device.
        #[unsafe(method(stencilPixelFormat))]
        #[unsafe(method_family = none)]
        unsafe fn stencilPixelFormat(&self) -> MTLPixelFormat;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// The command queue of the renderer. This property is only valid on a renderer created with a Metal device. Otherwise it is set to nil.
        #[unsafe(method(commandQueue))]
        #[unsafe(method_family = none)]
        unsafe fn commandQueue(&self) -> Option<Retained<ProtocolObject<dyn MTLCommandQueue>>>;

        #[cfg(feature = "objc2-avf-audio")]
        /// Contains the instance of audio engine used by the scene.
        ///
        /// The audio engine can be used to add custom nodes to the audio graph.
        #[unsafe(method(audioEngine))]
        #[unsafe(method_family = none)]
        unsafe fn audioEngine(&self) -> Retained<AVAudioEngine>;

        #[cfg(feature = "objc2-avf-audio")]
        /// Contains the instance of audio environment node used by the scene to spacialize sounds.
        #[unsafe(method(audioEnvironmentNode))]
        #[unsafe(method_family = none)]
        unsafe fn audioEnvironmentNode(&self) -> Retained<AVAudioEnvironmentNode>;

        #[cfg(feature = "SCNNode")]
        /// Use this property to set the audio node to use as the listener position and orientation when rendering positional audio for this scene. The default is nil which means that the current point of view will be used dynamically.
        #[unsafe(method(audioListener))]
        #[unsafe(method_family = none)]
        unsafe fn audioListener(&self) -> Option<Retained<SCNNode>>;

        #[cfg(feature = "SCNNode")]
        /// Setter for [`audioListener`][Self::audioListener].
        #[unsafe(method(setAudioListener:))]
        #[unsafe(method_family = none)]
        unsafe fn setAudioListener(&self, audio_listener: Option<&SCNNode>);

        #[cfg(feature = "objc2-core-foundation")]
        /// Returns the current viewport for this renderer, can be used to get the actual viewport from within the delegate callback during a live resize.
        #[unsafe(method(currentViewport))]
        #[unsafe(method_family = none)]
        unsafe fn currentViewport(&self) -> CGRect;

        /// Specifies the current time to display the scene.
        ///
        /// Deprecated, use "sceneTime" instead.
        #[deprecated]
        #[unsafe(method(currentTime))]
        #[unsafe(method_family = none)]
        unsafe fn currentTime(&self) -> NSTimeInterval;

        /// Setter for [`currentTime`][Self::currentTime].
        #[deprecated]
        #[unsafe(method(setCurrentTime:))]
        #[unsafe(method_family = none)]
        unsafe fn setCurrentTime(&self, current_time: NSTimeInterval);

        /// Specifies if the renderer should use the reverse Z technique. Defaults to YES.
        ///
        /// This property is only valid on a renderer created with a Metal device.
        #[unsafe(method(usesReverseZ))]
        #[unsafe(method_family = none)]
        unsafe fn usesReverseZ(&self) -> bool;

        /// Setter for [`usesReverseZ`][Self::usesReverseZ].
        #[unsafe(method(setUsesReverseZ:))]
        #[unsafe(method_family = none)]
        unsafe fn setUsesReverseZ(&self, uses_reverse_z: bool);
    }
);

extern_protocol!(
    /// Implement this protocol to perform operations at various times during the rendering
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnscenerendererdelegate?language=objc)
    pub unsafe trait SCNSceneRendererDelegate: NSObjectProtocol {
        /// Implement this to perform per-frame game logic. Called exactly once per frame before any animation and actions are evaluated and any physics are simulated.
        ///
        /// Parameter `renderer`: The renderer that will render the scene.
        ///
        /// Parameter `time`: The time at which to update the scene.
        ///
        /// All modifications done within this method don't go through the transaction model, they are directly applied on the presentation tree.
        #[optional]
        #[unsafe(method(renderer:updateAtTime:))]
        #[unsafe(method_family = none)]
        unsafe fn renderer_updateAtTime(
            &self,
            renderer: &ProtocolObject<dyn SCNSceneRenderer>,
            time: NSTimeInterval,
        );

        /// Invoked on the delegate once the scene renderer did apply the animations.
        ///
        /// Parameter `renderer`: The renderer that did render the scene.
        ///
        /// Parameter `time`: The time at which the animations were applied.
        ///
        /// All modifications done within this method don't go through the transaction model, they are directly applied on the presentation tree.
        #[optional]
        #[unsafe(method(renderer:didApplyAnimationsAtTime:))]
        #[unsafe(method_family = none)]
        unsafe fn renderer_didApplyAnimationsAtTime(
            &self,
            renderer: &ProtocolObject<dyn SCNSceneRenderer>,
            time: NSTimeInterval,
        );

        /// Invoked on the delegate once the scene renderer did simulate the physics.
        ///
        /// Parameter `renderer`: The renderer that did render the scene.
        ///
        /// Parameter `time`: The time at which the physics were simulated.
        ///
        /// All modifications done within this method don't go through the transaction model, they are directly applied on the presentation tree.
        #[optional]
        #[unsafe(method(renderer:didSimulatePhysicsAtTime:))]
        #[unsafe(method_family = none)]
        unsafe fn renderer_didSimulatePhysicsAtTime(
            &self,
            renderer: &ProtocolObject<dyn SCNSceneRenderer>,
            time: NSTimeInterval,
        );

        /// Invoked on the delegate once the scene renderer did apply the constraints.
        ///
        /// Parameter `renderer`: The renderer that did render the scene.
        ///
        /// Parameter `time`: The time at which the constraints were simulated.
        ///
        /// All modifications done within this method don't go through the transaction model, they are directly applied on the presentation tree.
        #[optional]
        #[unsafe(method(renderer:didApplyConstraintsAtTime:))]
        #[unsafe(method_family = none)]
        unsafe fn renderer_didApplyConstraintsAtTime(
            &self,
            renderer: &ProtocolObject<dyn SCNSceneRenderer>,
            time: NSTimeInterval,
        );

        #[cfg(feature = "SCNScene")]
        /// Invoked on the delegate before the scene renderer renders the scene. At this point the openGL context and the destination framebuffer are bound.
        ///
        /// Parameter `renderer`: The renderer that will render the scene.
        ///
        /// Parameter `scene`: The scene to be rendered.
        ///
        /// Parameter `time`: The time at which the scene is to be rendered.
        ///
        /// Starting in 10.10 all modifications done within this method don't go through the transaction model, they are directly applied on the presentation tree.
        #[optional]
        #[unsafe(method(renderer:willRenderScene:atTime:))]
        #[unsafe(method_family = none)]
        unsafe fn renderer_willRenderScene_atTime(
            &self,
            renderer: &ProtocolObject<dyn SCNSceneRenderer>,
            scene: &SCNScene,
            time: NSTimeInterval,
        );

        #[cfg(feature = "SCNScene")]
        /// Invoked on the delegate once the scene renderer did render the scene.
        ///
        /// Parameter `renderer`: The renderer that did render the scene.
        ///
        /// Parameter `scene`: The rendered scene.
        ///
        /// Parameter `time`: The time at which the scene was rendered.
        ///
        /// Starting in 10.10 all modifications done within this method don't go through the transaction model, they are directly applied on the presentation tree.
        #[optional]
        #[unsafe(method(renderer:didRenderScene:atTime:))]
        #[unsafe(method_family = none)]
        unsafe fn renderer_didRenderScene_atTime(
            &self,
            renderer: &ProtocolObject<dyn SCNSceneRenderer>,
            scene: &SCNScene,
            time: NSTimeInterval,
        );
    }
);
