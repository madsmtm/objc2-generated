//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-metal")]
#[cfg(not(target_os = "watchos"))]
use objc2_metal::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypoint?language=objc)
// NS_TYPED_ENUM
pub type SCNShaderModifierEntryPoint = NSString;

/// The frequency at which the custom program input should be updated.
///
/// When the frequency is set to SCNBufferFrequencyPerFrame, the binding block is invoked once per frame.
/// When the frequency is set to SCNBufferFrequencyPerNode, the binding block is invoked once per SCNNode.
/// When the frequency is set to SCNBufferFrequencyPerShadable, the binding block is invoked once per SCNMaterial or SCNGeometry (depending on the object that owns the SCNProgram).
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnbufferfrequency?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SCNBufferFrequency(pub NSInteger);
impl SCNBufferFrequency {
    #[doc(alias = "SCNBufferFrequencyPerFrame")]
    pub const PerFrame: Self = Self(0);
    #[doc(alias = "SCNBufferFrequencyPerNode")]
    pub const PerNode: Self = Self(1);
    #[doc(alias = "SCNBufferFrequencyPerShadable")]
    pub const PerShadable: Self = Self(2);
}

unsafe impl Encode for SCNBufferFrequency {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNBufferFrequency {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnbufferstream?language=objc)
    pub unsafe trait SCNBufferStream: NSObjectProtocol {
        #[method(writeBytes:length:)]
        unsafe fn writeBytes_length(&self, bytes: NonNull<c_void>, length: NSUInteger);
    }
);

/// Signature for the block to execute to bind or unbind a buffer.
///
/// Parameter `buffer`: The buffer to fill.
///
/// Parameter `node`: The rendered node.
///
/// Parameter `shadable`: The rendered shadable (geometry or material).
///
/// Parameter `renderer`: The renderer that is currently rendering the scene.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnbufferbindingblock?language=objc)
#[cfg(all(feature = "SCNNode", feature = "SCNRenderer", feature = "block2"))]
pub type SCNBufferBindingBlock = *mut block2::Block<
    dyn Fn(
        NonNull<ProtocolObject<dyn SCNBufferStream>>,
        NonNull<SCNNode>,
        NonNull<ProtocolObject<dyn SCNShadable>>,
        NonNull<SCNRenderer>,
    ),
>;

/// Signature for the block to execute to bind or unbind a uniform of an OpenGL or OpenGLES based program.
///
/// Parameter `programID`: The id of the program object to bind/unbind values for.
///
/// Parameter `location`: The location of the symbol within the program object to bind/unbind values for.
///
/// Parameter `renderedNode`: The node currently being rendered.
///
/// Parameter `renderer`: The renderer that is currently rendering the scene.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnbindingblock?language=objc)
#[cfg(all(feature = "SCNNode", feature = "SCNRenderer", feature = "block2"))]
pub type SCNBindingBlock =
    *mut block2::Block<dyn Fn(c_uint, c_uint, *mut SCNNode, NonNull<SCNRenderer>)>;

extern_protocol!(
    /// The SCNShadable protocol defines an object that is rendered with shaders.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnshadable?language=objc)
    pub unsafe trait SCNShadable: NSObjectProtocol {
        /// Specifies a custom program used to render the receiver.
        ///
        /// When a program is set, it overrides all the rendering parameters such as material settings and shaderModifiers.
        #[optional]
        #[method_id(@__retain_semantics Other program)]
        unsafe fn program(&self) -> Option<Retained<SCNProgram>>;

        /// Setter for [`program`][Self::program].
        #[optional]
        #[method(setProgram:)]
        unsafe fn setProgram(&self, program: Option<&SCNProgram>);

        #[cfg(all(feature = "SCNNode", feature = "SCNRenderer", feature = "block2"))]
        /// Sets the block to call at render time to bind the value for the specified symbol of the receiver's SCNProgram. This method has no effect for symbols declared in shader modifiers.
        ///
        /// Parameter `symbol`: The name of the symbol to bind a value for.
        ///
        /// Parameter `block`: The block to call to bind the specified symbol.
        ///
        /// This method can only be used with OpenGL and OpenGLES based programs.
        #[optional]
        #[method(handleBindingOfSymbol:usingBlock:)]
        unsafe fn handleBindingOfSymbol_usingBlock(
            &self,
            symbol: &NSString,
            block: SCNBindingBlock,
        );

        #[cfg(all(feature = "SCNNode", feature = "SCNRenderer", feature = "block2"))]
        /// Sets the block to call at render time to unbind the value for the specified symbol of the receiver's SCNProgram. This method has no effect for symbols declared in shader modifiers.
        ///
        /// Parameter `symbol`: The name of the symbol to unbind.
        ///
        /// Parameter `block`: The block to call to unbind the specified symbol.
        ///
        /// This method can only be used with OpenGL and OpenGLES based programs.
        #[optional]
        #[method(handleUnbindingOfSymbol:usingBlock:)]
        unsafe fn handleUnbindingOfSymbol_usingBlock(
            &self,
            symbol: &NSString,
            block: SCNBindingBlock,
        );

        /// Dictionary of shader modifiers snippets, targeting entry points. The valid keys are the entry points described in the "Shader Modifier Entry Point" constants. The values are the code snippets formatted as described below.
        ///
        /// Shader modifiers allow you to inject shader code in the standard shaders of SceneKit. This injection is allowed in few controlled entry points, allowing specific kind of tasks in specific context. Each modifier can operate on specific structures along with access to global uniforms, that could be the standard SceneKit uniforms or its own declared uniforms.
        ///
        /// Shader modifiers can be used to tweak SceneKit rendering by adding custom code at the following entry points:
        /// 1. vertex   (SCNShaderModifierEntryPointGeometry)
        /// 2. surface  (SCNShaderModifierEntryPointSurface)
        /// 3. lighting (SCNShaderModifierEntryPointLightingModel)
        /// 4. fragment (SCNShaderModifierEntryPointFragment)
        /// See below for a detailed explanation of these entry points and the context they provide.
        ///
        /// Shader modifiers can be written in either GLSL or the Metal Shading Language. Metal shaders won't run on iOS 8 and macOS 10.10 or earlier.
        ///
        /// The structure of a shader modifier is:
        ///
        /// GLSL
        /// | uniform float myGrayAmount = 3.0; // Custom GLSL uniforms declarations are of the form `[uniform type uniformName [= defaultValue]]`
        /// |
        /// | // Optional global function definitions (for Metal: references to uniforms in global functions are not supported).
        /// | float mySin(float t) {
        /// |    return sin(t);
        /// | }
        /// |
        /// | [#pragma transparent | opaque]
        /// | [#pragma body]
        /// |
        /// | // the shader modifier code snippet itself
        /// | vec3 myColor = myGrayAmount;
        /// | _output.color.rgb += myColor;
        ///
        /// Metal Shading Language
        /// | #pragma arguments
        /// | float myGrayAmount; // Custom Metal uniforms declarations require a #pragma and are of the form `[type name]`
        /// |
        /// | #pragma declaration
        /// | // Optional global function definitions (for Metal: references to uniforms in global functions are not supported).
        /// | float mySin(float t) {
        /// |    return sin(t);
        /// | }
        /// |
        /// | [#pragma transparent | opaque]
        /// | [#pragma body]
        /// |
        /// | // the shader modifier code snippet itself
        /// | float3 myColor = myGrayAmount;
        /// | _output.color.rgb += myColor;
        ///
        /// The `#pragma body` directive
        /// Is only needed if you declared functions that must not be included in the shader code itself.
        ///
        /// The `#pragma transparent` directive
        /// Forces the rendering to be blended using the following equation:
        /// _output.color.rgb + (1 - _output.color.a) * dst.rgb;
        /// where `dst` represents the current fragment color. The rgb components must be premultiplied.
        ///
        /// The `#pragma opaque` directive
        /// Forces the rendering to be opaque. It then ignores the alpha component of the fragment.
        ///
        /// When using Metal, you can also transfer varying values from the vertex shader (geometry shader modifier) to the fragment shader (surface and/or fragment shader modifier):
        /// 1. Start by declaring the varying values in at least one of the shader modifiers:
        ///
        /// Metal Shading Language
        /// | #pragma varyings
        /// | half3 myVec;
        ///
        /// 2. Then write the varying values from the vertex shader (geometry shader modifier):
        ///
        /// Metal Shading Language
        /// | #pragma body
        /// | out.myVec = _geometry.normal.xyz * 0.5h + 0.5h;
        ///
        /// 3. Finally read the varying values from the fragment shader (surface and/or fragment shader modifier):
        ///
        /// Metal Shading Language
        /// | _output.color.rgb = saturate(in.myVec);
        ///
        /// SceneKit declares the following built-in uniforms:
        ///
        /// GLSL                                        | Metal Shading Language                                |
        /// --------------------------------------------┼-------------------------------------------------------┤
        /// float u_time                                | float    scn_frame.time                               | The current time, in seconds
        /// vec2  u_inverseResolution                   | float2   scn_frame.inverseResolution                  | 1.0 / screen size
        /// --------------------------------------------┼-------------------------------------------------------┤
        /// mat4  u_viewTransform                       | float4x4 scn_frame.viewTransform                      | See SCNViewTransform
        /// mat4  u_inverseViewTransform                | float4x4 scn_frame.inverseViewTransform               |
        /// mat4  u_projectionTransform                 | float4x4 scn_frame.projectionTransform                | See SCNProjectionTransform
        /// mat4  u_inverseProjectionTransform          | float4x4 scn_frame.inverseProjectionTransform         |
        /// --------------------------------------------┼-------------------------------------------------------┤
        /// mat4  u_normalTransform                     | float4x4 scn_node.normalTransform                     | See SCNNormalTransform
        /// mat4  u_modelTransform                      | float4x4 scn_node.modelTransform                      | See SCNModelTransform
        /// mat4  u_inverseModelTransform               | float4x4 scn_node.inverseModelTransform               |
        /// mat4  u_modelViewTransform                  | float4x4 scn_node.modelViewTransform                  | See SCNModelViewTransform
        /// mat4  u_inverseModelViewTransform           | float4x4 scn_node.inverseModelViewTransform           |
        /// mat4  u_modelViewProjectionTransform        | float4x4 scn_node.modelViewProjectionTransform        | See SCNModelViewProjectionTransform
        /// mat4  u_inverseModelViewProjectionTransform | float4x4 scn_node.inverseModelViewProjectionTransform |
        /// --------------------------------------------┼-------------------------------------------------------┤
        /// mat2x3 u_boundingBox;                       | float2x3 scn_node.boundingBox                         | The bounding box of the current geometry, in model space, u_boundingBox[0].xyz and u_boundingBox[1].xyz being respectively the minimum and maximum corner of the box.
        /// mat2x3 u_worldBoundingBox;                  | float2x3 scn_node.worldBoundingBox                    | The bounding box of the current geometry, in world space.
        ///
        /// When writing shaders using the Metal Shading Language a complete description of the type of the scn_frame variable (SCNSceneBuffer) can be found in the
        /// <SceneKit
        /// /scn_metal> header file.
        /// The type of the scn_node variable is generated at compile time and there's no corresponding header file in the framework.
        ///
        /// In addition to these built-in uniforms, it is possible to use custom uniforms:
        ///
        /// The SCNGeometry and SCNMaterial classes are key-value coding compliant classes, which means that you can set values for arbitrary keys. Even if the key `myAmplitude` is not a declared property of the class, you can still set a value for it.
        /// Declaring a `myAmplitude` uniform in the shader modifier makes SceneKit observe the reveiver's `myAmplitude` key. Any change to that key will make SceneKit bind the uniform with the new value.
        ///
        /// The following GLSL and Metal Shading Language types (and their Objective-C counterparts) can be used to declare (and bind) custom uniforms:
        ///
        /// GLSL        | Metal Shading Language | Objective-C                           |
        /// ------------┼------------------------┼---------------------------------------┤
        /// int         | int                    | NSNumber, NSInteger, int              |
        /// float       | float                  | NSNumber, CGFloat, float, double      |
        /// vec2        | float2                 | CGPoint                               |
        /// vec3        | float3                 | SCNVector3                            |
        /// vec4        | float4                 | SCNVector4                            |
        /// mat4, mat44 | float4x4               | SCNMatrix4                            |
        /// sampler2D   | texture2d              | SCNMaterialProperty                   |
        /// samplerCube | texturecube            | SCNMaterialProperty (with a cube map) |
        /// -           | device const T*        | MTLBuffer                             | Feature introduced in macOS 10.13, iOS 11.0 and tvOS 11.0
        /// -           | struct {...}           | NSData                                | The entire struct can be set using NSData but it is also possible to set individual members using the member's name as a key and a value compatible with the member's type
        ///
        /// Common scalar types wrapped into a NSValue are also supported.
        ///
        /// The following prefixes are reserved by SceneKit and should not be used in custom names:
        /// 1. u_
        /// 2. a_
        /// 3. v_
        ///
        /// Custom uniforms can be animated using explicit animations.
        #[optional]
        #[method_id(@__retain_semantics Other shaderModifiers)]
        unsafe fn shaderModifiers(
            &self,
        ) -> Option<Retained<NSDictionary<SCNShaderModifierEntryPoint, NSString>>>;

        /// Setter for [`shaderModifiers`][Self::shaderModifiers].
        #[optional]
        #[method(setShaderModifiers:)]
        unsafe fn setShaderModifiers(
            &self,
            shader_modifiers: Option<&NSDictionary<SCNShaderModifierEntryPoint, NSString>>,
        );

        /// The minimum language version required to interpret the shadable source code (wrapped MTLLanguageVersion). Defaults to nil.
        ///
        /// By default SceneKit does not use the most recent language version in order to reduce compilation times. If set to nil the shadable source code is assumed to compile with any language version greater than or equal to Metal 2.0.
        #[optional]
        #[method_id(@__retain_semantics Other minimumLanguageVersion)]
        unsafe fn minimumLanguageVersion(&self) -> Option<Retained<NSNumber>>;

        /// Setter for [`minimumLanguageVersion`][Self::minimumLanguageVersion].
        #[optional]
        #[method(setMinimumLanguageVersion:)]
        unsafe fn setMinimumLanguageVersion(&self, minimum_language_version: Option<&NSNumber>);
    }
);

extern "C" {
    /// Semantic options
    ///
    /// Valid keys for the option parameter of setSemantic:forSymbol:options:
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnprogrammappingchannelkey?language=objc)
    pub static SCNProgramMappingChannelKey: &'static NSString;
}

extern_class!(
    /// A SCNProgram lets you specify custom shaders to use when rendering materials.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnprogram?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SCNProgram;
);

unsafe impl NSCoding for SCNProgram {}

unsafe impl NSCopying for SCNProgram {}

unsafe impl CopyingHelper for SCNProgram {
    type Result = Self;
}

unsafe impl NSObjectProtocol for SCNProgram {}

unsafe impl NSSecureCoding for SCNProgram {}

extern_methods!(
    unsafe impl SCNProgram {
        /// Creates and initialize a program instance.
        #[method_id(@__retain_semantics Other program)]
        pub unsafe fn program() -> Retained<Self>;

        /// Determines the receiver's vertex shader.
        #[method_id(@__retain_semantics Other vertexShader)]
        pub unsafe fn vertexShader(&self) -> Option<Retained<NSString>>;

        /// Setter for [`vertexShader`][Self::vertexShader].
        #[method(setVertexShader:)]
        pub unsafe fn setVertexShader(&self, vertex_shader: Option<&NSString>);

        /// Determines the receiver's fragment shader.
        #[method_id(@__retain_semantics Other fragmentShader)]
        pub unsafe fn fragmentShader(&self) -> Option<Retained<NSString>>;

        /// Setter for [`fragmentShader`][Self::fragmentShader].
        #[method(setFragmentShader:)]
        pub unsafe fn setFragmentShader(&self, fragment_shader: Option<&NSString>);

        /// Determines the receiver's tessellation control shader. Tessellation shaders require OpenGL Core Profile.
        #[method_id(@__retain_semantics Other tessellationControlShader)]
        pub unsafe fn tessellationControlShader(&self) -> Option<Retained<NSString>>;

        /// Setter for [`tessellationControlShader`][Self::tessellationControlShader].
        #[method(setTessellationControlShader:)]
        pub unsafe fn setTessellationControlShader(
            &self,
            tessellation_control_shader: Option<&NSString>,
        );

        /// Determines the receiver's tessellation evaluation shader. Tessellation shaders require OpenGL Core Profile.
        #[method_id(@__retain_semantics Other tessellationEvaluationShader)]
        pub unsafe fn tessellationEvaluationShader(&self) -> Option<Retained<NSString>>;

        /// Setter for [`tessellationEvaluationShader`][Self::tessellationEvaluationShader].
        #[method(setTessellationEvaluationShader:)]
        pub unsafe fn setTessellationEvaluationShader(
            &self,
            tessellation_evaluation_shader: Option<&NSString>,
        );

        /// Determines the receiver's geometry shader. Geometry shaders require OpenGL Core Profile.
        #[method_id(@__retain_semantics Other geometryShader)]
        pub unsafe fn geometryShader(&self) -> Option<Retained<NSString>>;

        /// Setter for [`geometryShader`][Self::geometryShader].
        #[method(setGeometryShader:)]
        pub unsafe fn setGeometryShader(&self, geometry_shader: Option<&NSString>);

        /// Determines the receiver's vertex function name.
        ///
        /// The name of the vertex function (for Metal programs).
        #[method_id(@__retain_semantics Other vertexFunctionName)]
        pub unsafe fn vertexFunctionName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`vertexFunctionName`][Self::vertexFunctionName].
        #[method(setVertexFunctionName:)]
        pub unsafe fn setVertexFunctionName(&self, vertex_function_name: Option<&NSString>);

        /// Determines the receiver's fragment function name.
        ///
        /// The name of the fragment function (for Metal programs).
        #[method_id(@__retain_semantics Other fragmentFunctionName)]
        pub unsafe fn fragmentFunctionName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`fragmentFunctionName`][Self::fragmentFunctionName].
        #[method(setFragmentFunctionName:)]
        pub unsafe fn setFragmentFunctionName(&self, fragment_function_name: Option<&NSString>);

        #[cfg(all(feature = "SCNNode", feature = "SCNRenderer", feature = "block2"))]
        /// Sets the block to call at render time to bind the buffer of the specified symbol of the receiver's program.
        ///
        /// Parameter `name`: The name of the buffer to bind.
        ///
        /// Parameter `frequency`: The frequency at which the block has to be invoked. Can be per frame, per node or per geometry or material. See SCNBufferBindingBlock above.
        ///
        /// Parameter `block`: The block that binds the buffer.
        ///
        /// This method can only be used with Metal based programs.
        #[method(handleBindingOfBufferNamed:frequency:usingBlock:)]
        pub unsafe fn handleBindingOfBufferNamed_frequency_usingBlock(
            &self,
            name: &NSString,
            frequency: SCNBufferFrequency,
            block: SCNBufferBindingBlock,
        );

        /// Determines the receiver's fragment are opaque or not. Defaults to YES.
        #[method(isOpaque)]
        pub unsafe fn isOpaque(&self) -> bool;

        /// Setter for [`isOpaque`][Self::isOpaque].
        #[method(setOpaque:)]
        pub unsafe fn setOpaque(&self, opaque: bool);

        /// Associates a SceneKit semantic to a symbol.
        ///
        /// Parameter `semantic`: The SceneKit semantic to associate to the specified symbol.
        ///
        /// Parameter `symbol`: A symbol from the program source code.
        ///
        /// Parameter `options`: An optional dictionary. See the 'Semantic options' above.
        ///
        /// Associates semantics handled by the SceneKit runtime to a symbol from the program. Supported semantics are listed in SCNGeometry.h and SCNNode.h.
        #[method(setSemantic:forSymbol:options:)]
        pub unsafe fn setSemantic_forSymbol_options(
            &self,
            semantic: Option<&NSString>,
            symbol: &NSString,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        );

        /// Retrieves the SceneKit semantic associated to a symbol from the program source code.
        ///
        /// Parameter `symbol`: A symbol from the program source code.
        #[method_id(@__retain_semantics Other semanticForSymbol:)]
        pub unsafe fn semanticForSymbol(&self, symbol: &NSString) -> Option<Retained<NSString>>;

        /// Determines the receiver's delegate
        #[method_id(@__retain_semantics Other delegate)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn SCNProgramDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        #[method(setDelegate:)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn SCNProgramDelegate>>);

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// Specifies the Metal library to use to locate the function names specified above.
        ///
        /// If set to nil the default library is used. Defaults to nil.
        #[method_id(@__retain_semantics Other library)]
        pub unsafe fn library(&self) -> Option<Retained<ProtocolObject<dyn MTLLibrary>>>;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`library`][Self::library].
        #[method(setLibrary:)]
        pub unsafe fn setLibrary(&self, library: Option<&ProtocolObject<dyn MTLLibrary>>);
    }
);

extern_methods!(
    /// Methods declared on superclass `NSObject`
    unsafe impl SCNProgram {
        #[method_id(@__retain_semantics Init init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[method_id(@__retain_semantics New new)]
        pub unsafe fn new() -> Retained<Self>;
    }
);

extern_protocol!(
    /// The SCNProgramDelegate protocol declares the methods that an instance of SCNProgram invokes to delegate the binding of parameters.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnprogramdelegate?language=objc)
    pub unsafe trait SCNProgramDelegate: NSObjectProtocol {
        #[cfg(feature = "SCNRenderer")]
        /// Invoked on the delegate to let it bind program values and/or also bind associated graphics resources (such as textures).
        ///
        /// Parameter `program`: The program to bind values for.
        ///
        /// Parameter `symbol`: The name of the symbol to bind a value for.
        ///
        /// Parameter `location`: The location of the symbol within the program object to be modified.
        ///
        /// Parameter `programID`: The program object.
        ///
        /// Parameter `renderer`: The renderer that is currently rendering the scene.
        #[deprecated = "Use -[SCNShadable handleBindingOfSymbol:usingBlock:] instead"]
        #[optional]
        #[method(program:bindValueForSymbol:atLocation:programID:renderer:)]
        unsafe fn program_bindValueForSymbol_atLocation_programID_renderer(
            &self,
            program: &SCNProgram,
            symbol: &NSString,
            location: c_uint,
            program_id: c_uint,
            renderer: &SCNRenderer,
        ) -> bool;

        #[cfg(feature = "SCNRenderer")]
        /// Invoked on the delegate to let it unbind program values and/or also unbind associated graphic resources (such as textures).
        ///
        /// Parameter `program`: The program to unbind values for.
        ///
        /// Parameter `symbol`: The name of the symbol to unbind a value for.
        ///
        /// Parameter `location`: The location of the symbol within the program object to be modified.
        ///
        /// Parameter `programID`: The program object.
        ///
        /// Parameter `renderer`: The renderer that is currently rendering the scene.
        #[deprecated = "Use -[SCNShadable handleUnbindingOfSymbol:usingBlock:] instead"]
        #[optional]
        #[method(program:unbindValueForSymbol:atLocation:programID:renderer:)]
        unsafe fn program_unbindValueForSymbol_atLocation_programID_renderer(
            &self,
            program: &SCNProgram,
            symbol: &NSString,
            location: c_uint,
            program_id: c_uint,
            renderer: &SCNRenderer,
        );

        /// Invoked on the delegate whenever a compilation error occurs.
        ///
        /// Error domain is SCNErrorDomain.
        ///
        /// Parameter `program`: The program that generated a compilation error.
        ///
        /// Parameter `error`: The compilation error.
        #[optional]
        #[method(program:handleError:)]
        unsafe fn program_handleError(&self, program: &SCNProgram, error: &NSError);

        /// The delegate should implement this mehod and return NO if the fragments generated by the program are not opaque.
        ///
        /// Parameter `program`: The queried program.
        ///
        /// This is deprecated. Use SCNProgram's opaque property instead.
        #[deprecated = "Use SCNProgram.opaque instead"]
        #[optional]
        #[method(programIsOpaque:)]
        unsafe fn programIsOpaque(&self, program: &SCNProgram) -> bool;
    }
);

extern "C" {
    /// This is the entry point to operate on the geometry vertices, for example deforming them.
    ///
    /// It operates entirely in the vertex shader stage. It's input is the geometry structure:
    ///
    /// Structures available from the SCNShaderModifierEntryPointGeometry entry point:
    ///
    /// | struct SCNShaderGeometry {
    /// |    float4 position;
    /// |    float3 normal;
    /// |    float4 tangent;
    /// |    float4 color;
    /// |    float2 texcoords[kSCNTexcoordCount];
    /// | } _geometry;
    /// |
    /// | Access: ReadWrite
    /// | Stages: Vertex shader only
    ///
    /// kSCNTexcoordCount is a constant integer set to the number of texture coordinates used.
    ///
    /// All the geometric fields (position, normal and tangent) are in model space. You can use one of the provided automatic uniforms
    /// such as u_modelTransform or u_modelViewTransform if you want to operate in another space (but the results must stay in the model space, otherwise remaining computations won't be correct).
    /// The texture coordinates are the raw values found in the mesh, they have not been transformed yet by their optional contentsTransform. The contentsTransform if any is applied after the geometry shader modifier.
    ///
    /// Example: Simple sinusoidal deformation
    ///
    /// GLSL
    /// | uniform float Amplitude = 0.1;
    /// |
    /// | _geometry.position.xyz += _geometry.normal * (Amplitude * _geometry.position.y * _geometry.position.x) * sin(u_time);
    ///
    /// Metal Shading Language
    /// | #pragma arguments
    /// | float Amplitude;
    /// |
    /// | _geometry.position.xyz += _geometry.normal * (Amplitude * _geometry.position.y * _geometry.position.x) * sin(scn_frame.time);
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypointgeometry?language=objc)
    pub static SCNShaderModifierEntryPointGeometry: &'static SCNShaderModifierEntryPoint;
}

extern "C" {
    /// This is the entry point to alter the surface representation of the material, before the lighting has taken place.
    ///
    /// Structures available from the SCNShaderModifierEntryPointSurface entry point:
    ///
    /// | struct SCNShaderSurface {
    /// |    float3 view;                       // Direction from the point on the surface toward the camera (V)
    /// |    float3 position;                   // Position of the fragment
    /// |    float3 normal;                     // Normal of the fragment (N)
    /// |    float3 geometryNormal;             // Geometric normal of the fragment (normal map is ignored)
    /// |    float3 tangent;                    // Tangent of the fragment
    /// |    float3 bitangent;                  // Bitangent of the fragment
    /// |    float4 ambient;                    // Ambient property of the fragment
    /// |    float2 ambientTexcoord;            // Ambient texture coordinates
    /// |    float4 diffuse;                    // Diffuse property of the fragment. Alpha contains the opacity.
    /// |    float2 diffuseTexcoord;            // Diffuse texture coordinates
    /// |    float4 specular;                   // Specular property of the fragment
    /// |    float2 specularTexcoord;           // Specular texture coordinates
    /// |    float4 emission;                   // Emission property of the fragment
    /// |    float2 emissionTexcoord;           // Emission texture coordinates
    /// |    float4 multiply;                   // Multiply property of the fragment
    /// |    float2 multiplyTexcoord;           // Multiply texture coordinates
    /// |    float4 transparent;                // Transparent property of the fragment
    /// |    float2 transparentTexcoord;        // Transparent texture coordinates
    /// |    float4 reflective;                 // Reflective property of the fragment
    /// |    float  metalness;                  // Metalness property of the fragment
    /// |    float2 metalnessTexcoord;          // Metalness texture coordinates
    /// |    float  roughness;                  // Roughness property of the fragment
    /// |    float2 roughnessTexcoord;          // Roughness texture coordinates
    /// |    float  clearCoat;                  // Clear Coat property of the fragment.           Available since macOS 10.15, iOS 13, tvOS 13 and watchOS 6.
    /// |    float2 clearCoatTexcoord;          // Clear Coat texture coordinates.                Available since macOS 10.15, iOS 13, tvOS 13 and watchOS 6.
    /// |    float  clearCoatRoughness;         // Clear Coat Roughness property of the fragment. Available since macOS 10.15, iOS 13, tvOS 13 and watchOS 6.
    /// |    float2 clearCoatRoughnessTexcoord; // Clear Coat Roughness texture coordinates.      Available since macOS 10.15, iOS 13, tvOS 13 and watchOS 6.
    /// |    float3 clearCoatNormal;            // Clear Coat Normal property of the fragment.    Available since macOS 10.15, iOS 13, tvOS 13 and watchOS 6.
    /// |    float2 clearCoatNormalTexcoord;    // Clear Coat Normnal texture coordinates.        Available since macOS 10.15, iOS 13, tvOS 13 and watchOS 6.
    /// |    float4 selfIllumination;           // Self Illumination property of the fragment.    Available since macOS 10.13, iOS 11, tvOS 11 and watchOS 4. Available as `emission` in previous versions.
    /// |    float2 selfIlluminationTexcoord;   // Self Illumination texture coordinates.         Available since macOS 10.13, iOS 11, tvOS 11 and watchOS 4. Available as `emissionTexcoord` in previous versions.
    /// |    float  ambientOcclusion;           // Ambient Occlusion property of the fragment.    Available since macOS 10.13, iOS 11, tvOS 11 and watchOS 4. Available as `multiply` in previous versions.
    /// |    float2 ambientOcclusionTexcoord;   // Ambient Occlusion texture coordinates.         Available since macOS 10.13, iOS 11, tvOS 11 and watchOS 4. Available as `multiplyTexcoord` in previous versions.
    /// |    float  shininess;                  // Shininess property of the fragment
    /// |    float  fresnel;                    // Fresnel property of the fragment
    /// | } _surface;
    /// |
    /// | Access: ReadWrite
    /// | Stages: Fragment shader only
    ///
    /// All geometric fields are in view space.
    /// All the other properties will be colors (texture have already been sampled at this stage) or floats. You can however do an extra sampling of standard textures if you want.
    /// In this case the naming pattern is u_
    /// <property
    /// >Texture. For example u_diffuseTexture or u_reflectiveTexture. Note that you have to be sure that the material do have a texture
    /// set for this property, otherwise you'll trigger a shader compilation error.
    ///
    /// Example: Procedural black and white stripes
    ///
    /// GLSL
    /// | uniform float Scale = 12.0;
    /// | uniform float Width = 0.25;
    /// | uniform float Blend = 0.3;
    /// |
    /// | vec2 position = fract(_surface.diffuseTexcoord * Scale);
    /// | float f1 = clamp(position.y / Blend, 0.0, 1.0);
    /// | float f2 = clamp((position.y - Width) / Blend, 0.0, 1.0);
    /// | f1 = f1 * (1.0 - f2);
    /// | f1 = f1 * f1 * 2.0 * (3. * 2. * f1);
    /// | _surface.diffuse = mix(vec4(1.0), vec4(0.0), f1);
    ///
    /// Metal Shading Language
    /// | #pragma arguments
    /// | float Scale;
    /// | float Width;
    /// | float Blend;
    /// |
    /// | float2 position = fract(_surface.diffuseTexcoord * Scale);
    /// | float f1 = clamp(position.y / Blend, 0.0, 1.0);
    /// | float f2 = clamp((position.y - Width) / Blend, 0.0, 1.0);
    /// | f1 = f1 * (1.0 - f2);
    /// | f1 = f1 * f1 * 2.0 * (3. * 2. * f1);
    /// | _surface.diffuse = mix(float4(1.0), float4(0.0), f1);
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypointsurface?language=objc)
    pub static SCNShaderModifierEntryPointSurface: &'static SCNShaderModifierEntryPoint;
}

extern "C" {
    /// This is the entry point to provide custom lighting equation. The fragment will be called for each active light
    /// of the scene and will need to accumulate lighting contribution for the vertex or the fragment in the _lightingContribution structure, using the light structure given.
    ///
    /// Structures available from the SCNShaderModifierEntryPointLightingModel entry point:
    ///
    /// | All the structures available from the SCNShaderModifierEntryPointSurface entry point
    /// |
    /// | Access: ReadOnly
    /// | Stages: Vertex shader and fragment shader
    ///
    /// | struct SCNShaderLightingContribution {
    /// |    float3 ambient;
    /// |    float3 diffuse;
    /// |    float3 specular;
    /// | } _lightingContribution;
    /// |
    /// | Access: ReadWrite
    /// | Stages: Vertex shader and fragment shader
    ///
    /// | struct SCNShaderLight {
    /// |    float4 intensity;
    /// |    float3 direction; // Direction from the point on the surface toward the light (L)
    /// | } _light;
    /// |
    /// | Access: ReadOnly
    /// | Stages: Vertex shader and fragment shader
    ///
    /// Example: Wrap diffuse lighting
    ///
    /// GLSL
    /// | uniform float WrapFactor = 0.5;
    /// |
    /// | float dotProduct = (WrapFactor + max(0.0, dot(_surface.normal,_light.direction))) / (1 + WrapFactor);
    /// | _lightingContribution.diffuse += (dotProduct * _light.intensity.rgb);
    /// | vec3 halfVector = normalize(_light.direction + _surface.view);
    /// | dotProduct = max(0.0, pow(max(0.0, dot(_surface.normal, halfVector)), _surface.shininess));
    /// | _lightingContribution.specular += (dotProduct * _light.intensity.rgb);
    ///
    /// Metal Shading Language
    /// | #pragma arguments
    /// | float WrapFactor;
    /// |
    /// | float dotProduct = (WrapFactor + max(0.0, dot(_surface.normal,_light.direction))) / (1 + WrapFactor);
    /// | _lightingContribution.diffuse += (dotProduct * _light.intensity.rgb);
    /// | float3 halfVector = normalize(_light.direction + _surface.view);
    /// | dotProduct = max(0.0, pow(max(0.0, dot(_surface.normal, halfVector)), _surface.shininess));
    /// | _lightingContribution.specular += (dotProduct * _light.intensity.rgb);
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypointlightingmodel?language=objc)
    pub static SCNShaderModifierEntryPointLightingModel: &'static SCNShaderModifierEntryPoint;
}

extern "C" {
    /// This is the last entry point in the fragment shader, where you can alter the final color returned by the shader.
    ///
    /// You can alter the final color by reading and writing to the output color via the output structure below.
    ///
    /// Structures available from the SCNShaderModifierEntryPointFragment entry point:
    ///
    /// | All the structures available from the SCNShaderModifierEntryPointSurface entry point
    /// |
    /// | Access: ReadOnly
    /// | Stages: Fragment shader only
    ///
    /// | struct SCNFramebuffer {
    /// |    float4 color; // Contents of the destination framebuffer corresponding to the fragment being processed
    /// | } _framebuffer;  // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9.
    /// |
    /// | Access: ReadOnly
    /// | Stages: Fragment shader only
    ///
    /// | struct SCNShaderOutput {
    /// |    float4 color;
    /// | } _output;
    /// |
    /// | Access: ReadWrite
    /// | Stages: Fragment shader only
    ///
    /// Example: Inverse final color
    ///
    /// GLSL
    /// | _output.color.rgb = vec3(1.0) - _output.color.rgb;
    ///
    /// Metal Shading Language
    /// | _output.color.rgb = 1.0 - _output.color.rgb;
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnshadermodifierentrypointfragment?language=objc)
    pub static SCNShaderModifierEntryPointFragment: &'static SCNShaderModifierEntryPoint;
}
