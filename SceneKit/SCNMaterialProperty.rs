//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-metal")]
#[cfg(not(target_os = "watchos"))]
use objc2_metal::*;

use crate::*;

/// Texture filtering modes, used by the [`minificationFilter`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/minificationfilter), [`magnificationFilter`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/magnificationfilter), and [`mipFilter`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/mipfilter) properties.
///
/// ## Overview
///
/// Texture filtering determines the appearance of a material property’s contents when portions of the material surface appear larger or smaller than the original texture image. For example, when a texture is applied to a plane that recedes away from the camera into the distance:
///
/// - The texture coordinates at a point near the camera may correspond to a small fraction of a pixel in the original image. SceneKit uses the [`magnificationFilter`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/magnificationfilter) property to determine the color of the sampled texel at that point.
///
/// - The texture coordinates at a point far from the camera may correspond to an area of several pixels in the original image. SceneKit uses the [`minificationFilter`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/minificationfilter) property to determine the color of the sampled texel at that point.
///
/// SceneKit also uses the filter specified by the [`mipFilter`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/mipfilter) property when generating mipmap levels for a texture image.
///
///
/// Filtering modes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SCNFilterMode(pub NSInteger);
impl SCNFilterMode {
    /// No texture filtering is applied.
    ///
    /// ## Discussion
    ///
    /// Only valid for the [`mipFilter`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/mipfilter) property, specifying that SceneKit should not use mip mapping.
    ///
    ///
    #[doc(alias = "SCNFilterModeNone")]
    pub const None: Self = Self(0);
    /// Texture filtering returns the color from only one texel, whose location is nearest to the coordinates being sampled.
    #[doc(alias = "SCNFilterModeNearest")]
    pub const Nearest: Self = Self(1);
    /// Texture filtering sample texels from the neighborhood of the coordinates being sampled and linearly interpolates their colors.
    #[doc(alias = "SCNFilterModeLinear")]
    pub const Linear: Self = Self(2);
}

unsafe impl Encode for SCNFilterMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNFilterMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Modes to apply to texture wrapping, used by the [`wrapT`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/wrapt) and [`wrapS`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/wraps) properties.
///
/// ## Overview
///
/// Wrapping modes determine texture mapping behavior for cases where a material’s texture coordinates extend outside the range from `0.0` to `1.0`. For example, if you use the [`contentsTransform`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/contentstransform) property to shrink a texture relative to the surface of a geometry, you use the wrap mode properties to determine whether the texture repeats across the surface. The figure below shows the effect of each wrapping mode on an otherwise identical material.
///
///
/// ![](https://docs-assets.developer.apple.com/published/56b89682a8bddd05b937dd5b9ca9b645/media-2929787%402x.png)
///
///
///
/// Wrap modes
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SCNWrapMode(pub NSInteger);
impl SCNWrapMode {
    /// Texture coordinates are clamped to the range from `0.0` to `1.0`, inclusive.
    ///
    /// ## Discussion
    ///
    /// Texture sampling in areas whose texture coordinates would fall outside this range produces texel colors from the nearest edge of the texture image.
    ///
    ///
    #[doc(alias = "SCNWrapModeClamp")]
    pub const Clamp: Self = Self(1);
    /// Texture sampling uses only the fractional part of texture coordinates, passing through the range from `0.0` to (but not including) `1.0`.
    ///
    /// ## Discussion
    ///
    /// Texture sampling in areas of the material whose texture coordinates would fall outside from `0.0` to `1.0` results in tiling the texture image across the surface using the material.
    ///
    ///
    #[doc(alias = "SCNWrapModeRepeat")]
    pub const Repeat: Self = Self(2);
    /// Texture sampling uses texture colors for coordinates in the range from `0.0` to `1.0` (inclusive) and the material property’s [`borderColor`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/bordercolor) value otherwise.
    ///
    /// ## Discussion
    ///
    /// Texture sampling in areas whose texture coordinates would fall outside this range uses the [`borderColor`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/bordercolor) property instead of texel colors from the texture image.
    ///
    ///
    #[doc(alias = "SCNWrapModeClampToBorder")]
    pub const ClampToBorder: Self = Self(3);
    /// Texture sampling of texture coordinates outside range from `0.0` to `1.0` should behave as if the range reverses before repeating.
    ///
    /// ## Discussion
    ///
    /// Texture sampling in areas of the material whose texture coordinates would fall outside from `0.0` to `1.0` results in tiling both texture image and its mirror image across the surface using the material.
    ///
    ///
    #[doc(alias = "SCNWrapModeMirror")]
    pub const Mirror: Self = Self(4);
}

unsafe impl Encode for SCNWrapMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNWrapMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A container for the color or texture of one of a material’s visual properties.
    ///
    /// ## Overview
    ///
    /// A material has several visual properties that together determine its appearance under lighting and shading. SceneKit renders each pixel in the scene by combining the information from material properties with the locations, intensities, and colors of lights.
    ///
    /// A material property’s contents can be either a color, which provides a uniform effect across the surface of a material, or a texture, which SceneKit maps across the surface of a material using texture coordinates provided by the geometry object the material is attached to. A texture, in turn, can come from any of several sources, such as an image object, a URL to an image file, a specially formatted image or set of images for use as a cube map, or even animated content provided by Core Animation, SpriteKit, or AVFoundation—for the full set of options, see the [`contents`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/contents) property.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Typically, you associate texture images with materials when creating 3D assets with third-party authoring tools, and the scene files containing those assets reference external image files. For best results when shipping assets in your app bundle, place scene files in a folder with the `.scnassets` extension, and place image files referenced as textures from those scenes in an Asset Catalog.
    ///
    /// Xcode then optimizes the scene and texture resources for best performance on each target device, and prepares your texture resources for delivery features such as App Thinning and On-Demand Resources.
    ///
    ///
    ///
    /// </div>
    /// SceneKit uses the material property’s [`contents`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/contents) object in different ways for each visual property of a material. For example:
    ///
    /// - When you provide a color for the [`diffuse`](https://developer.apple.com/documentation/scenekit/scnmaterial/diffuse) property, it determines the material’s base color—geometries using the material appear shaded in gradations of this color when illuminated by white light. If you instead provide an image, SceneKit maps the image across the geometry’s surface instead of shading with a uniform base color.
    ///
    /// - When you provide a color for the [`specular`](https://developer.apple.com/documentation/scenekit/scnmaterial/specular) property, it affects the color of light reflected directly toward the viewer from the surface of a geometry using the material. If you instead provide a grayscale image, it determines the tendency of the material to reflect light directly toward the viewer—lighter pixels in the image make those areas of the material appear more shiny, and darker pixels make the material appear more matte.
    ///
    /// - The [`normal`](https://developer.apple.com/documentation/scenekit/scnmaterial/normal) property specifies the orientation of a surface at each point. Materials are uniformly smooth by default, so specifying a color for this property has no useful effect. Instead, you can specify an image for this property that describes the contours of the surface. SceneKit uses this image (called a normal map) in lighting, creating the illusion of a complex, bumpy surface without increasing the complexity of the geometry.
    ///
    /// For more details on each visual property and the ways their contents affect a material’s appearance, see [`SCNMaterial`](https://developer.apple.com/documentation/scenekit/scnmaterial).
    ///
    /// SceneKit also uses [`SCNMaterialProperty`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty) objects elsewhere:
    ///
    /// - To provide content to be rendered behind a scene, in the [`background`](https://developer.apple.com/documentation/scenekit/scnscene/background) property of an [`SCNScene`](https://developer.apple.com/documentation/scenekit/scnscene) object,
    ///
    /// - To affect the color and shape of illumination from a light source, in the [`gobo`](https://developer.apple.com/documentation/scenekit/scnlight/gobo) property of an [`SCNLight`](https://developer.apple.com/documentation/scenekit/scnlight) object.
    ///
    /// - To bind texture samplers to custom GLSL shader source code snippets, in classes conforming to the [`SCNShadable`](https://developer.apple.com/documentation/scenekit/scnshadable) protocol.
    ///
    ///
    /// The contents of a SCNMaterial slot
    ///
    /// This can be used to specify the various properties of SCNMaterial slots such as diffuse, ambient, etc.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SCNMaterialProperty;
);

extern_conformance!(
    unsafe impl NSCoding for SCNMaterialProperty {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for SCNMaterialProperty {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for SCNMaterialProperty {}
);

#[cfg(feature = "SCNAnimation")]
extern_conformance!(
    unsafe impl SCNAnimatable for SCNMaterialProperty {}
);

impl SCNMaterialProperty {
    extern_methods!(
        /// Creates and initialize a property instance with the specified contents.
        ///
        /// # Safety
        ///
        /// `contents` should be of the correct type.
        #[unsafe(method(materialPropertyWithContents:))]
        #[unsafe(method_family = none)]
        pub unsafe fn materialPropertyWithContents(contents: &AnyObject) -> Retained<Self>;

        /// Specifies the receiver's contents. This can be a color (NSColor, UIColor, CGColorRef), an image (NSImage, UIImage, CGImageRef), a layer (CALayer), a path (NSString or NSURL), a SpriteKit scene (SKScene), a texture (SKTexture, id
        /// <MTLTexture
        /// > or GLKTextureInfo), or a floating value between 0 and 1 (NSNumber) for metalness and roughness properties. AVCaptureDevice is supported on iOS 11 and AVPlayer is supported on macOS 10.13, iOS 11 and tvOS 11. Animatable when set to a color.
        ///
        /// Setting the contents to an instance of SKTexture will automatically update the wrapS, wrapT, contentsTransform, minification, magnification and mip filters according to the SKTexture settings.
        /// When a cube map is expected (e.g. SCNMaterial.reflective, SCNScene.background, SCNScene.lightingEnvironment) you can use
        /// 1. A horizontal strip image                          where `6 * image.height ==     image.width`
        /// 2. A vertical strip image                            where `    image.height == 6 * image.width`
        /// 3. A spherical projection image (latitude/longitude) where `2 * image.height ==     image.width`
        /// 4. A NSArray of 6 images. This array must contain images of the exact same dimensions, in the following order, in a left-handed coordinate system: +X, -X, +Y, -Y, +Z, -Z (or Right, Left, Top, Bottom, Front, Back).
        #[unsafe(method(contents))]
        #[unsafe(method_family = none)]
        pub unsafe fn contents(&self) -> Option<Retained<AnyObject>>;

        /// Setter for [`contents`][Self::contents].
        ///
        /// # Safety
        ///
        /// `contents` should be of the correct type.
        #[unsafe(method(setContents:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContents(&self, contents: Option<&AnyObject>);

        #[cfg(feature = "objc2-core-foundation")]
        /// Determines the receiver's intensity. This intensity is used to modulate the properties in several ways.
        /// It dims the diffuse, specular and emission properties, it varies the bumpiness of the normal property and the
        /// filter property is blended with white. Default value is 1.0. Animatable.
        #[unsafe(method(intensity))]
        #[unsafe(method_family = none)]
        pub unsafe fn intensity(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`intensity`][Self::intensity].
        #[unsafe(method(setIntensity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setIntensity(&self, intensity: CGFloat);

        /// Specifies the filter type to use when rendering the contents (specified in the `contents' property).
        ///
        /// The minification filter is used when to reduce the size of image data. See above the list of available modes. Defaults to SCNFilterModeLinear.
        #[unsafe(method(minificationFilter))]
        #[unsafe(method_family = none)]
        pub unsafe fn minificationFilter(&self) -> SCNFilterMode;

        /// Setter for [`minificationFilter`][Self::minificationFilter].
        #[unsafe(method(setMinificationFilter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinificationFilter(&self, minification_filter: SCNFilterMode);

        /// Specifies the filter type to use when rendering the the contents (specified in the `contents' property).
        ///
        /// The magnification filter is used when to increase the size of image data. See above the list of available modes. Defaults to SCNFilterModeLinear.
        #[unsafe(method(magnificationFilter))]
        #[unsafe(method_family = none)]
        pub unsafe fn magnificationFilter(&self) -> SCNFilterMode;

        /// Setter for [`magnificationFilter`][Self::magnificationFilter].
        #[unsafe(method(setMagnificationFilter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMagnificationFilter(&self, magnification_filter: SCNFilterMode);

        /// Specifies the mipmap filter to use during minification.
        ///
        /// Defaults to SCNFilterModeNearest starting macOS 10.12, iOS 10, tvOS 10 and watchOS 3. Defaults to SCNFilterModeNone in previous versions.
        #[unsafe(method(mipFilter))]
        #[unsafe(method_family = none)]
        pub unsafe fn mipFilter(&self) -> SCNFilterMode;

        /// Setter for [`mipFilter`][Self::mipFilter].
        #[unsafe(method(setMipFilter:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMipFilter(&self, mip_filter: SCNFilterMode);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        /// Determines the receiver's contents transform. Animatable.
        #[unsafe(method(contentsTransform))]
        #[unsafe(method_family = none)]
        pub unsafe fn contentsTransform(&self) -> SCNMatrix4;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`contentsTransform`][Self::contentsTransform].
        #[unsafe(method(setContentsTransform:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setContentsTransform(&self, contents_transform: SCNMatrix4);

        /// Determines the receiver's wrap mode for the s texture coordinate. Defaults to SCNWrapModeClamp.
        #[unsafe(method(wrapS))]
        #[unsafe(method_family = none)]
        pub unsafe fn wrapS(&self) -> SCNWrapMode;

        /// Setter for [`wrapS`][Self::wrapS].
        #[unsafe(method(setWrapS:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWrapS(&self, wrap_s: SCNWrapMode);

        /// Determines the receiver's wrap mode for the t texture coordinate. Defaults to SCNWrapModeClamp.
        #[unsafe(method(wrapT))]
        #[unsafe(method_family = none)]
        pub unsafe fn wrapT(&self) -> SCNWrapMode;

        /// Setter for [`wrapT`][Self::wrapT].
        #[unsafe(method(setWrapT:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWrapT(&self, wrap_t: SCNWrapMode);

        /// Determines the receiver's mapping channel. Defaults to 0.
        ///
        /// Geometries potentially have multiple sources of texture coordinates. Every source has a unique mapping channel index. The mapping channel allows to select which source of texture coordinates is used to map the content of the receiver.
        #[unsafe(method(mappingChannel))]
        #[unsafe(method_family = none)]
        pub unsafe fn mappingChannel(&self) -> NSInteger;

        /// Setter for [`mappingChannel`][Self::mappingChannel].
        #[unsafe(method(setMappingChannel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMappingChannel(&self, mapping_channel: NSInteger);

        #[cfg(feature = "SceneKitTypes")]
        /// Specifies the texture components to sample in the shader. Defaults to SCNColorMaskRed for displacement property, and to SCNColorMaskAll for other properties.
        ///
        /// Use this property to when using a texture that combine multiple informations in the different texture components. For example if you pack the roughness in red and metalness in blue etc... You can specify what component to use from the texture for this given material property. This property is only supported by Metal renderers.
        #[unsafe(method(textureComponents))]
        #[unsafe(method_family = none)]
        pub unsafe fn textureComponents(&self) -> SCNColorMask;

        #[cfg(feature = "SceneKitTypes")]
        /// Setter for [`textureComponents`][Self::textureComponents].
        #[unsafe(method(setTextureComponents:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTextureComponents(&self, texture_components: SCNColorMask);

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the receiver's max anisotropy. Defaults to MAXFLOAT.
        ///
        /// Anisotropic filtering reduces blur and preserves detail at extreme viewing angles.
        #[unsafe(method(maxAnisotropy))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxAnisotropy(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`maxAnisotropy`][Self::maxAnisotropy].
        #[unsafe(method(setMaxAnisotropy:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaxAnisotropy(&self, max_anisotropy: CGFloat);

        /// Returns an object suitable for a scene's `lightingEnvironment.contents` and initialized with data that was previously created by `+precomputedLightingEnvironmentDataForContents:device:error:`.
        #[unsafe(method(precomputedLightingEnvironmentContentsWithURL:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn precomputedLightingEnvironmentContentsWithURL_error(
            url: &NSURL,
        ) -> Result<Retained<AnyObject>, Retained<NSError>>;

        /// Returns an object suitable for a scene's `lightingEnvironment.contents` and initialized with data that was previously created by `+precomputedLightingEnvironmentDataForContents:device:error:`.
        #[unsafe(method(precomputedLightingEnvironmentContentsWithData:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn precomputedLightingEnvironmentContentsWithData_error(
            data: &NSData,
        ) -> Result<Retained<AnyObject>, Retained<NSError>>;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// Returns an `NSData` instance containing the result of CPU and GPU-intensive operations that is suitable for caching.
        ///
        /// This method can be leveraged in a custom offline asset pipeline, or at run time at a convenient time before the scene is presented to the user.
        ///
        /// # Safety
        ///
        /// `contents` should be of the correct type.
        #[unsafe(method(precomputedLightingEnvironmentDataForContents:device:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn precomputedLightingEnvironmentDataForContents_device_error(
            contents: &AnyObject,
            device: Option<&ProtocolObject<dyn MTLDevice>>,
        ) -> Result<Retained<NSData>, Retained<NSError>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl SCNMaterialProperty {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
