//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-metal")]
#[cfg(not(target_os = "watchos"))]
use objc2_metal::*;

use crate::*;

extern_class!(
    /// A specification for augmenting or postprocessing SceneKit’s rendering of a scene using additional drawing passes with custom Metal or OpenGL shaders.
    ///
    /// ## Overview
    ///
    /// Examples of multipass rendering techniques include:
    ///
    /// - Postprocessing rendered pixels. To create effects such as color grading and displacement mapping, define techniques that use as input the color buffer rendered by SceneKit and process that buffer with a fragment shader.
    ///
    /// - Deferred shading. To create effects such as motion blur and screen-space ambient occlusion (SSAO), define techniques that capture information about the scene into an intermediary buffer during the main rendering pass and then perform additional drawing passes using that buffer to create the final output image. The figure below illustrates the rendering process for an SSAO technique.
    ///
    ///
    /// ![](https://docs-assets.developer.apple.com/published/2fb4cf9f24e6d70b088647cbafefad95/media-2929792%402x.png)
    ///
    ///
    /// To create an [`SCNTechnique`](https://developer.apple.com/documentation/scenekit/scntechnique) object, you supply a technique definition that specifies the input and output image buffers, shader programs, shader input variables, and rendering options for each drawing pass in the technique. Defining a technique does not require Metal or OpenGL client code, but you should be familiar with the terminology and conventions of GPU rendering.
    ///
    /// To use a technique, assign it to the [`technique`](https://developer.apple.com/documentation/scenekit/scntechniquesupport/technique) property of a view (or other SceneKit renderer object) or a camera.
    ///
    /// ### Defining a Technique
    ///
    /// SceneKit treats rendering techniques—along with shaders, 3D models, and 2D art assets—as resources rather than as part of your application code. Because the effects you create with techniques are highly visual, this approach allows you to separate design efforts from development efforts and quickly iterate on creating the visual content of your app or game.
    ///
    /// Create a technique object using the [`techniqueWithDictionary:`](https://developer.apple.com/documentation/scenekit/scntechnique/init(dictionary:)) method, providing a dictionary that defines the technique as a series of drawing passes, each with its own shader program, inputs and outputs, and rendering options. Typically, you obtain this dictionary from a property list file included in your app’s bundle resources. Table 1 and the additional tables and sections that follow specify the format of this dictionary’s contents.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "passes" }] }], [Paragraph { inline_content: [Text { text: "A dictionary of drawing pass definitions. " }, Image { identifier: "spacer", metadata: None }, Text { text: " Each key is a unique string you provide to identify the pass, and the corresponding value is a dictionary defining that drawing pass. See Table 2." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "sequence" }] }], [Paragraph { inline_content: [Text { text: "An array of strings, each of which names a drawing pass from the " }, CodeVoice { code: "passes" }, Text { text: " dictionary. SceneKit performs the drawing passes in the order specified by this array." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "symbols" }] }], [Paragraph { inline_content: [Text { text: "A dictionary defining the bindings for GLSL attributes and uniform variables used in the technique’s shader programs. " }, Image { identifier: "spacer", metadata: None }, Text { text: " Each key matches the name of a symbol used in the shader source code, and the corresponding value is a dictionary describing how that symbol should be used. See Table 4." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "targets" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "A dictionary defining intermediary rendering targets. " }, Image { identifier: "spacer", metadata: None }, Text { text: " Each key is a unique string you provide to identify the target (used in the inputs and outputs dictionaries of a drawing pass definition), and the corresponding value is a dictionary defining the rendering target. See Table 5." }] }]]], alignments: None, metadata: None })
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Type" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "draw" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "What to render for the drawing pass: " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "DRAW_SCENE" }, Text { text: ": Render the entire scene. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "DRAW_NODE" }, Text { text: ": Render only the node specified by the " }, CodeVoice { code: "node" }, Text { text: " key (and its hierarchy of child nodes). " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "DRAW_QUAD" }, Text { text: ": Render only a rectangle covering the entire bounds of the view. Use this option for drawing passes that process image buffers output by earlier passes." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "program" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The GLSL shader program to use for the drawing pass. " }, Image { identifier: "spacer", metadata: None }, Text { text: " Shader source code files in the app’s bundle resources directory must have the same base name and the extensions " }, CodeVoice { code: ".vsh" }, Text { text: " (vertex shader) and " }, CodeVoice { code: ".fsh" }, Text { text: " (fragment shader). For example, if the program name is “invert”, the files “invert.fsh” and “invert.vsh” must exist." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "metalVertexShader" }, Text { text: " " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "metalFragmentShader" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The names of the Metal vertex and fragment shader functions to use for the drawing pass. These functions must exist in the app’s default Metal library. " }, Image { identifier: "spacer", metadata: None }, Text { text: " You must specify both fragment and vertex shaders, and you must specify either a GLSL shader program, a pair of Metal functions, or both. If both are specified, SceneKit uses whichever shader is appropriate for the current renderer." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "inputs" }] }], [Paragraph { inline_content: [Text { text: "Dictionary" }] }], [Paragraph { inline_content: [Text { text: "Definitions of input variables for the drawing pass. " }, Image { identifier: "spacer", metadata: None }, Text { text: " Each key is the name of a uniform variable used in the GLSL shader source code referenced by the program key. The corresponding value may be any of: " }, Image { identifier: "spacer", metadata: None }, Text { text: " A symbol name from the technique’s " }, CodeVoice { code: "symbols" }, Text { text: " dictionary " }, Image { identifier: "spacer", metadata: None }, Text { text: " A render target name (see " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNTechnique#Render-Targets-Inputs-and-Outputs", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ") " }, Image { identifier: "spacer", metadata: None }, Text { text: " A dictionary describing a texture sampler (see Table 6)" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "outputs" }] }], [Paragraph { inline_content: [Text { text: "Dictionary" }] }], [Paragraph { inline_content: [Text { text: "Definitions of output image buffers for the drawing pass. " }, Image { identifier: "spacer", metadata: None }, Text { text: " Each key is one of the strings " }, CodeVoice { code: "color" }, Text { text: ", " }, CodeVoice { code: "depth" }, Text { text: ", or " }, CodeVoice { code: "stencil" }, Text { text: ",  and the corresponding value is a string identifying a render target. See " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNTechnique#Render-Targets-Inputs-and-Outputs", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "node" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNNode/name", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property of the node to render, or " }, CodeVoice { code: "self" }, Text { text: " to reference the node the technique is attached to. Applies only if the " }, CodeVoice { code: "draw" }, Text { text: " key specifies " }, CodeVoice { code: "DRAW_NODE" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "colorStates" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "Dictionary" }] }], [Paragraph { inline_content: [Text { text: "Options for the color output; one or more of these keys and values: " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "clear" }, Text { text: " (Boolean, defaults to " }, Reference { identifier: "doc://com.apple.documentation/documentation/Swift/false", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " in macOS and " }, Reference { identifier: "doc://com.apple.documentation/documentation/Swift/true", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " on iOS): Whether to clear the rendering target before drawing. If " }, Reference { identifier: "doc://com.apple.documentation/documentation/Swift/true", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", you must specify one of the " }, CodeVoice { code: "clearColor" }, Text { text: " and " }, CodeVoice { code: "clearWithSceneBackgroundColor" }, Text { text: " options. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "clearColor" }, Text { text: " (string): The color to fill the render target with when clearing, specified in floating-point RGBA format. (For example, “0.5 0.5 0.5 1.0” is a fully opaque gray color.) Alternatively, the string " }, CodeVoice { code: "sceneBackground" }, Text { text: " specifies to use the scene’s " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNScene/background", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property when clearing." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "depthStates" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "Dictionary" }] }], [Paragraph { inline_content: [Text { text: "Options for the depth output; one or more of these keys and values: " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "clear" }, Text { text: " (Boolean, default " }, Reference { identifier: "doc://com.apple.documentation/documentation/Swift/false", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: "): Whether to clear the depth buffer before drawing. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "enableWrite" }, Text { text: " (Boolean, default " }, Reference { identifier: "doc://com.apple.documentation/documentation/Swift/true", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: "): Whether to write to the depth buffer when drawing. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "enableRead" }, Text { text: " (Boolean, default " }, Reference { identifier: "doc://com.apple.documentation/documentation/Swift/true", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: "): Whether to read from the depth buffer when drawing. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "func" }, Text { text: " (string): The depth test function: " }, CodeVoice { code: "never" }, Text { text: ", " }, CodeVoice { code: "always" }, Text { text: ", " }, CodeVoice { code: "equal" }, Text { text: ", " }, CodeVoice { code: "notEqual" }, Text { text: ", " }, CodeVoice { code: "less" }, Text { text: ", " }, CodeVoice { code: "lessEqual" }, Text { text: ", " }, CodeVoice { code: "greater" }, Text { text: ", or " }, CodeVoice { code: "greaterEqual" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "stencilStates" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "Dictionary" }] }], [Paragraph { inline_content: [Text { text: "Options for the stencil output; one or more of these keys and values: " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "clear" }, Text { text: " (Boolean, default " }, Reference { identifier: "doc://com.apple.documentation/documentation/Swift/false", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: "): Whether to clear the stencil buffer before drawing. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "enable" }, Text { text: " (Boolean, default " }, Reference { identifier: "doc://com.apple.documentation/documentation/Swift/false", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: "): Whether the drawing pass should write to the stencil buffer. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "behavior" }, Text { text: ": A dictionary specifying how to use the stencil buffer when rendering front faces (or both faces, if nothing is specified for the " }, CodeVoice { code: "backFaceBehavior" }, Text { text: " key). See Table 3. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "backFaceBehavior" }, Text { text: ": A dictionary specifying how to use the stencil buffer when rendering back faces. See Table 3." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "cullMode" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The faces of scene geometry to be rendered: " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "back" }, Text { text: " (default): Cull back faces, rendering front faces only. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "front" }, Text { text: ": Cull front faces, rendering back faces only. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "none" }, Text { text: ": Render both front- and back-facing polygons." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "blendStates" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "Dictionary" }] }], [Paragraph { inline_content: [Text { text: "Options for color blending; one or more of these keys and values: " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "enable" }, Text { text: " (Boolean): Whether to use color blending. If " }, Reference { identifier: "doc://com.apple.documentation/documentation/Swift/false", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", the other blending options have no effect. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "colorSrc" }, Text { text: " (string): The blend mode for source colors. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "colorDst" }, Text { text: " (string): The blend mode for destination colors. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "alphaSrc" }, Text { text: " (string): The blend mode for source alpha values. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "alphaDst" }, Text { text: " (string): The blend mode for destination alpha values. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "colorOp" }, Text { text: " (string): The blend operation for color components. " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "alphaOp" }, Text { text: " (string): The blend operation for alpha values. " }, Image { identifier: "spacer", metadata: None }, Text { text: " See " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNTechnique#Blending", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "viewport" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "A custom viewport rectangle in view coordinates, formatted as four numbers (origin x, origin y, width, and height). By default, a drawing pass covers the entire bounds of the view." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "pointOfView" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The name of a node in the scene to use as the viewer’s position for rendering; equivalent to the " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNSceneRenderer/pointOfView", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " property on a renderer." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "samples" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "Number (unsigned integer)" }] }], [Paragraph { inline_content: [Text { text: "The number of samples per pixel for enabling multisampled rendering for the drawing pass. Defaults to " }, CodeVoice { code: "1" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "includeCategoryMask" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "Number (8-bit unsigned integer)" }] }], [Paragraph { inline_content: [Text { text: "A bitfield used for including nodes in the drawing pass if the " }, CodeVoice { code: "draw" }, Text { text: " key specifies " }, CodeVoice { code: "DRAW_SCENE" }, Text { text: " or " }, CodeVoice { code: "DRAW_NODE" }, Text { text: ". Defaults to all bits set. See " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNTechnique#Category-Masks", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "excludeCategoryMask" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "Number (8-bit unsigned integer)" }] }], [Paragraph { inline_content: [Text { text: "A bitfield used for excluding nodes from the drawing pass if the " }, CodeVoice { code: "draw" }, Text { text: " key specifies " }, CodeVoice { code: "DRAW_SCENE" }, Text { text: " or " }, CodeVoice { code: "DRAW_NODE" }, Text { text: ". Defaults to no bits set. See " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNTechnique#Category-Masks", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: "." }] }]]], alignments: None, metadata: None })
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Type" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "depthFail" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The stencil operation to use if the depth test fails: " }, CodeVoice { code: "keep" }, Text { text: ", " }, CodeVoice { code: "zero" }, Text { text: ", " }, CodeVoice { code: "replace" }, Text { text: ", " }, CodeVoice { code: "increment" }, Text { text: ", " }, CodeVoice { code: "decrement" }, Text { text: ", " }, CodeVoice { code: "invert" }, Text { text: ", " }, CodeVoice { code: "incrementWrap" }, Text { text: ", or " }, CodeVoice { code: "decrementWrap" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "fail" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The stencil operation to use if the depth test succeeds and the stencil test fails: " }, CodeVoice { code: "keep" }, Text { text: ", " }, CodeVoice { code: "zero" }, Text { text: ", " }, CodeVoice { code: "replace" }, Text { text: ", " }, CodeVoice { code: "increment" }, Text { text: ", " }, CodeVoice { code: "decrement" }, Text { text: ", " }, CodeVoice { code: "invert" }, Text { text: ", " }, CodeVoice { code: "incrementWrap" }, Text { text: ", or " }, CodeVoice { code: "decrementWrap" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "pass" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The stencil operation to use if the depth and stencil tests succeed: " }, CodeVoice { code: "keep" }, Text { text: ", " }, CodeVoice { code: "zero" }, Text { text: ", " }, CodeVoice { code: "replace" }, Text { text: ", " }, CodeVoice { code: "increment" }, Text { text: ", " }, CodeVoice { code: "decrement" }, Text { text: ", " }, CodeVoice { code: "invert" }, Text { text: ", " }, CodeVoice { code: "incrementWrap" }, Text { text: ", or " }, CodeVoice { code: "decrementWrap" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "function" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The stencil test function: " }, CodeVoice { code: "never" }, Text { text: ", " }, CodeVoice { code: "always" }, Text { text: ", " }, CodeVoice { code: "equal" }, Text { text: ", " }, CodeVoice { code: "notEqual" }, Text { text: ", " }, CodeVoice { code: "less" }, Text { text: ", " }, CodeVoice { code: "lessEqual" }, Text { text: ", " }, CodeVoice { code: "greater" }, Text { text: ", or " }, CodeVoice { code: "greaterEqual" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "readMask" }] }], [Paragraph { inline_content: [Text { text: "Number (8-bit unsigned integer)" }] }], [Paragraph { inline_content: [Text { text: "A bitmask for selecting the bit plane of the stencil buffer to be tested." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "writeMask" }] }], [Paragraph { inline_content: [Text { text: "Number (8-bit unsigned integer)" }] }], [Paragraph { inline_content: [Text { text: "A bitmask for selecting the bit plane of the stencil buffer to write to." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "referenceValue" }] }], [Paragraph { inline_content: [Text { text: "Number (8-bit unsigned integer)" }] }], [Paragraph { inline_content: [Text { text: "The reference value for stencil tests. Defaults to " }, CodeVoice { code: "0" }, Text { text: "." }] }]]], alignments: None, metadata: None })
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Type" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "semantic" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "Use this option to bind shader symbols to data supplied by SceneKit: " }, Image { identifier: "spacer", metadata: None }, Text { text: " The values " }, CodeVoice { code: "vertex" }, Text { text: ", " }, CodeVoice { code: "normal" }, Text { text: ", " }, CodeVoice { code: "color" }, Text { text: ", and " }, CodeVoice { code: "texcoord" }, Text { text: " bind to geometry source semantics. See Geometry Semantic Identifiers. " }, Image { identifier: "spacer", metadata: None }, Text { text: " The values " }, CodeVoice { code: "modelViewProjectionTransform" }, Text { text: ", " }, CodeVoice { code: "modelViewTransform" }, Text { text: ", " }, CodeVoice { code: "modelTransform" }, Text { text: ", " }, CodeVoice { code: "viewTransform" }, Text { text: ", " }, CodeVoice { code: "projectionTransform" }, Text { text: ", " }, CodeVoice { code: "normalTransform" }, Text { text: ", " }, CodeVoice { code: "modelViewProjectionInverseTransform" }, Text { text: ", " }, CodeVoice { code: "modelViewInverseTransform" }, Text { text: ", " }, CodeVoice { code: "modelInverseTransform" }, Text { text: ", " }, CodeVoice { code: "viewInverseTransform" }, Text { text: ", " }, CodeVoice { code: "projectionInverseTransform" }, Text { text: ", and " }, CodeVoice { code: "normalInverseTransform" }, Text { text: " bind to rendering transformation matrices. See Rendering Transform Keys. " }, Image { identifier: "spacer", metadata: None }, Text { text: " The value " }, CodeVoice { code: "time" }, Text { text: " binds the system time elapsed since rendering began. " }, Image { identifier: "spacer", metadata: None }, Text { text: " If you set a " }, CodeVoice { code: "semantic" }, Text { text: " value for a symbol, no " }, CodeVoice { code: "type" }, Text { text: " value is required." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "type" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The GLSL type of the input variable: " }, CodeVoice { code: "float" }, Text { text: ", " }, CodeVoice { code: "vec2" }, Text { text: ", " }, CodeVoice { code: "vec3" }, Text { text: ", " }, CodeVoice { code: "vec4" }, Text { text: ", " }, CodeVoice { code: "mat4" }, Text { text: ", " }, CodeVoice { code: "int" }, Text { text: ", " }, CodeVoice { code: "ivec2" }, Text { text: ", " }, CodeVoice { code: "ivec3" }, Text { text: ", " }, CodeVoice { code: "ivec4" }, Text { text: ", " }, CodeVoice { code: "mat3" }, Text { text: ", " }, CodeVoice { code: "sampler2D" }, Text { text: ", or " }, CodeVoice { code: "none" }, Text { text: ". " }, Image { identifier: "spacer", metadata: None }, Text { text: " Use this option when providing custom values to shader programs (see Handling Parameters for a Technique’s Shader Programs)." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "image" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "If the symbol’s type is " }, CodeVoice { code: "sampler2D" }, Text { text: ", the name of an image file in the app’s bundle resources directory." }] }]]], alignments: None, metadata: None })
    /// #### Category Masks
    ///
    /// When SceneKit performs a rendering pass whose `draw` option is `DRAW_SCENE` or `DRAW_NODE`, you can use category masks to filter the set of nodes drawn during that pass. For each node in the scene (or for `DRAW_NODE`, in the node subtree), SceneKit compares the node’s [`categoryBitMask`](https://developer.apple.com/documentation/scenekit/scnnode/categorybitmask) property and the `includeCategoryMask` and `excludeCategoryMask` options in the pass definition using bitwise AND operations. If the node’s category mask and the include mask overlap (that is, the bitwise AND results in a nonzero value) and the node’s category mask and the exclude mask do not overlap, SceneKit includes the node in the drawing pass. Otherwise the node is not rendered in the pass.
    ///
    /// #### Render Targets, Inputs and Outputs
    ///
    /// A drawing pass renders pixel data into one or more target image buffer (or framebuffer). In SceneKit’s main drawing pass, the color render target is the screen (or rather, a view or layer for screen display), and a depth render target temporarily stores the information needed to ensure that rendered surfaces appear in the correct depth order.
    ///
    /// A pass in a custom rendering technique may postprocess the pixel data in SceneKit’s render target, generate its own pixel data for display, or render to an intermediate target to be used as input in a later pass. You specify render targets using the following identifiers in the `inputs` and `outputs` dictionaries of a pass definition:
    ///
    /// - Use the `COLOR` and `DEPTH` targets as inputs to identify the color and depth buffers rendered to in SceneKit’s main drawing pass.
    ///
    /// Use the `COLOR` target as an output to identify the image buffer displayed as the end result of a technique.
    ///
    /// - To create an intermediate target, define your own identifier as a key in the `targets` dictionary of a technique definition. For the corresponding value, provide a dictionary defining the render target using the keys and values in Table 5. Intermediate targets may be color, depth, or combined depth and stencil buffers. After you define a target, you can use its identifier in the `inputs` and `outputs` dictionaries of a pass definition.
    ///
    /// - To use an image as an input texture for a pass, define a symbol of type `sampler2D` in the technique’s `symbols` dictionary.
    ///
    /// To specify a render target or image sampler in the `inputs` dictionary of a pass definition, you can provide either an identifier string or a dictionary with the format described in Table 6. The options for samplers correspond to similar properties for SceneKit material textures. For more details on each, see [`SCNMaterialProperty`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty).
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Type" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "type" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The type of render target: " }, CodeVoice { code: "color" }, Text { text: ", " }, CodeVoice { code: "depth" }, Text { text: ", or " }, CodeVoice { code: "stencil" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "format" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The render target’s pixel format; one of the following: " }, Image { identifier: "spacer", metadata: None }, Text { text: " Color: " }, CodeVoice { code: "rgba" }, Text { text: " (default), " }, CodeVoice { code: "rgb32f" }, Text { text: ", " }, CodeVoice { code: "r8" }, Text { text: ", or " }, CodeVoice { code: "r16" }, Text { text: " " }, Image { identifier: "spacer", metadata: None }, Text { text: " Depth/stencil: " }, CodeVoice { code: "depth24" }, Text { text: " (default) or " }, CodeVoice { code: "depth24stencil8" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "size" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [Text { text: "The size of the render target image, in points, specified in a string of format “WxH”. For example, the string “320x480” specifies an image buffer 320 points wide by 480 points tall." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "scaleFactor" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "Number (floating-point)" }] }], [Paragraph { inline_content: [Text { text: "The scale factor of the render target. Defaults to " }, CodeVoice { code: "1.0" }, Text { text: ". For example, a value of " }, CodeVoice { code: "2.0" }, Text { text: " specifies 2 pixels per point, so a target whose size is “320x480” is 640 by 960 pixels." }] }]]], alignments: None, metadata: None })
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Key" }] }], [Paragraph { inline_content: [Text { text: "Type" }] }], [Paragraph { inline_content: [Text { text: "Value" }] }]], [[Paragraph { inline_content: [CodeVoice { code: "target" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [CodeVoice { code: "COLOR" }, Text { text: ", " }, CodeVoice { code: "DEPTH" }, Text { text: ", a key from the technique’s " }, CodeVoice { code: "targets" }, Text { text: " dictionary, or a key from the technique’s " }, CodeVoice { code: "symbols" }, Text { text: " dictionary identifying a texture sampler." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "magnificationFilter" }, Text { text: " (optional) " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "minificationFilter" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [CodeVoice { code: "linear" }, Text { text: " or " }, CodeVoice { code: "nearest" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "mipFilter" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [CodeVoice { code: "linear" }, Text { text: ", " }, CodeVoice { code: "nearest" }, Text { text: ", or " }, CodeVoice { code: "none" }, Text { text: "." }] }]], [[Paragraph { inline_content: [CodeVoice { code: "wrapS" }, Text { text: " (optional) " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "wrapT" }, Text { text: " (optional) " }, Image { identifier: "spacer", metadata: None }, Text { text: " " }, CodeVoice { code: "wrapP" }, Text { text: " (optional)" }] }], [Paragraph { inline_content: [Text { text: "String" }] }], [Paragraph { inline_content: [CodeVoice { code: "clamp" }, Text { text: ", " }, CodeVoice { code: "repeat" }, Text { text: ", " }, CodeVoice { code: "clampToBorder" }, Text { text: ", " }, CodeVoice { code: "mirror" }, Text { text: "." }] }]]], alignments: None, metadata: None })
    /// #### Blending
    ///
    /// The `blendStates` key of a pass definition defines color blending options. Blending is disabled by default for faster rendering performance. Including a dictionary for this key enables blending (unless the dictionary’s `enable` key specifies [`false`](https://developer.apple.com/documentation/swift/false)). Color blending combines a source color (the color output by the drawing pass’s shader program) with a destination color (the existing contents of the output buffer) using specified modes and operations.
    ///
    /// - Available blend modes (for the `colorSrc`, `colorDst`, `alphaSrc`, and `alphaDst` keys): `zero`, `one`, `srcColor`, `oneMinusSrcColor`, `srcAlpha`, `oneMinusSrcAlpha`, `dstColor`, `oneMinusDstColor`, `dstAlpha`, `oneMinusDstAlpha`, `constantColor`, `oneMinusConstantColor`, `constantAlpha`, `oneMinusConstantAlpha`, and `alphaSaturate`.
    ///
    /// - Available blend operations (for the `colorOp` and `alphaOp` keys): `add`, `subtract`, `reverseSubtract`, `min`, `max`.
    ///
    /// These values correspond to blending options defined by the OpenGL specification. For further details, consult the [OpenGL API Registry](http://www.opengl.org/registry/) or [OpenGL ES API Registry](http://www.khronos.org/registry/gles/).
    ///
    /// ### Example Technique Definition
    ///
    /// Listing 1 shows an example definition dictionary for a technique that uses displacement mapping with a noise texture to postprocess a rendered scene. For ease of reading, the dictionary is formatted in JSON syntax. (To load an [`NSDictionary`](https://developer.apple.com/documentation/foundation/nsdictionary) object from text in this format, use the [`NSJSONSerialization`](https://developer.apple.com/documentation/foundation/jsonserialization) class.) Listing 2 and Listing 3 show the GLSL source code for the technique’s vertex and fragment shaders.
    ///
    /// Listing 1. JSON definition dictionary for a technique
    ///
    /// ```objc
    /// {
    ///   "passes" : {
    ///     "displacement" : {
    ///       "outputs" : {
    ///         "color" : "COLOR"
    ///       },
    ///       "inputs" : {
    ///         "colorSampler" : "COLOR",
    ///         "noiseSampler" : "noiseSymbol",
    ///         "a_position" : "a_position-symbol"
    ///       },
    ///       "program" : "displacement",
    ///       "draw" : "DRAW_QUAD"
    ///     }
    ///   },
    ///   "sequence" : [
    ///     "displacement"
    ///   ],
    ///   "symbols" : {
    ///     "a_position-symbol" : {
    ///       "semantic" : "vertex"
    ///     },
    ///     "noiseSymbol" : {
    ///       "image" : "noise.png",
    ///       "type" : "sampler2D"
    ///     }
    ///   }
    /// }
    /// ```
    ///
    /// Listing 2. GLSL Vertex shader source code for displacement mapping technique
    ///
    /// ```objc
    /// attribute vec4 a_position;
    /// varying vec2 uv;
    ///  
    /// void main() {
    ///     gl_Position = a_position;
    ///     uv = (a_position.xy + 1.0) * 0.5;
    /// }
    /// ```
    ///
    /// Listing 3. GLSL Fragment shader source code for displacement mapping technique
    ///
    /// ```objc
    /// uniform sampler2D colorSampler;
    /// uniform sampler2D noiseSampler;
    ///  
    /// varying vec2 uv;
    ///  
    /// void main() {
    ///     vec2 displacement = texture2D(noiseSampler, uv).rg - vec2(0.5, 0.5);
    ///     gl_FragColor = texture2D(colorSampler, uv + displacement * vec2(0.1,0.1));
    /// }
    /// ```
    ///
    ///
    /// SCNTechnique represents a rendering process that may require multiple passes.
    ///
    /// A technique is generally initialized from a Property List file. It can be set to any object that conforms to the SCNTechniqueSupport protocol.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SCNTechnique;
);

extern_conformance!(
    unsafe impl NSCoding for SCNTechnique {}
);

extern_conformance!(
    unsafe impl NSCopying for SCNTechnique {}
);

unsafe impl CopyingHelper for SCNTechnique {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for SCNTechnique {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for SCNTechnique {}
);

#[cfg(feature = "SCNAnimation")]
extern_conformance!(
    unsafe impl SCNAnimatable for SCNTechnique {}
);

impl SCNTechnique {
    extern_methods!(
        /// Creates and returns a technique instance initialized with the specified dictionary.
        ///
        /// Parameter `dictionary`: The dictionary representation of the technique.
        ///
        /// The format of the dictionary is described below. Quoted strings can be any name of your choice. Tags are defined below.
        /// The passes are executed sequentially as specified in the "sequence" section. The definition of each pass is within the "passes" section. A pass may have inputs/outputs that reference targets or symbols defined in the "targets" and "symbols" section. The entries of the "symbols" section can be set/get and animated with SCNTechnique's APIs below.
        ///
        /// {
        /// sequence: ["Pass1", "Pass2", ...],
        /// passes: {
        /// "Pass1": {
        /// outputs:
        /// <outputs
        /// >
        /// inputs:
        /// <inputs
        /// >
        /// draw:
        /// <draw
        /// command>
        /// program:
        /// <program
        /// name>
        /// metalVertexShader:
        /// <METAL
        /// vertex shader function name>
        /// metalFragmentShader:
        /// <METAL
        /// fragment shader function name>
        /// colorStates:
        /// <color
        /// states>               //optional
        /// depthStates:
        /// <depth
        /// states>               //optional
        /// stencilStates:
        /// <stencil
        /// states>           //optional
        /// cullMode:
        /// <cull
        /// mode>                     //optional
        /// blendStates:
        /// <blend
        /// states>               //optional
        /// viewport:
        /// <custom
        /// viewport>               //optional
        /// pointOfView:
        /// <node
        /// name>                  //optional
        /// samples:
        /// <sample
        /// count>                   //optional
        /// excludeCategoryMask:
        /// <category
        /// bitMask>   //optional
        /// includeCategoryMask:
        /// <category
        /// bitMask>   //optional
        /// },
        /// "Pass2" : {
        /// [...]
        /// }
        /// }
        /// symbols: {
        /// "symbol A": {
        /// <symbol
        /// description>
        /// }
        /// [...]
        /// }
        /// targets: {
        /// "target A": {
        /// <target
        /// description>
        /// }
        /// [...]
        /// },
        ///
        /// //optional
        ///
        /// bundle:
        /// <bundleIdentifier
        /// >,
        /// metalLibraryName:
        /// <metalLibraryName
        /// >,
        /// }
        ///
        /// <outputs
        /// >:
        /// The possible (and optional) keys with their possible associated values are:
        /// color: a string referencing a color render target. See
        /// <render
        /// target reference>.
        /// depth: a string referencing a depth render target. See
        /// <render
        /// target reference>.
        /// stencil: a string referencing a stencil render target. See
        /// <render
        /// target reference>.
        ///
        /// <inputs
        /// >:
        /// The inputs are listed in a dictionary. The keys are the uniform name as specified in the program of this pass.
        /// The values can be a single string referencing a symbol or a semantic or a target OR a dictionary with the following structure:
        ///
        /// {
        /// target:
        /// <render
        /// target reference>,
        ///
        /// //optional:
        /// minificationFilter: linear, nearest
        /// magnificationFilter: linear, nearest
        /// mipFilter: linear, nearest, none
        /// wrapS: clamp, repeat, clampToBorder, mirror
        /// wrapT: clamp, repeat, clampToBorder, mirror
        /// wrapP: clamp, repeat, clampToBorder, mirror
        /// maxAnisotropy: a number
        /// }
        ///
        /// (See SCNMaterialProperty for more documentation and default values of these optional parameters.)
        ///
        /// <render
        /// target reference>
        /// A string referencing a target (i.e an entry in the top level "targets" dictionary) or one of the special strings below:
        /// COLOR  The render target that represents that main color fragments that will be displayed on the screen ultimately.
        /// DEPTH  The render target that represents that main depth fragments.
        ///
        /// <draw
        /// command>
        /// can be one of the following strings:
        /// DRAW_SCENE:    render the entire scene
        /// DRAW_QUAD:     render a fullscreen quad
        /// DRAW_NODE:     render a node and its sub-tree. The node is specified by setting its name as the value for the key "node".
        ///
        /// <program
        /// name>
        /// Name of a program (a vertex shader + a fragment shader) located in the application bundle.
        /// The vertex shader must have the extension "vsh" and the fragment shader "fsh".
        ///
        /// <METAL
        /// vertex shader function name>
        /// Name of a METAL function to use as the vertex shader.
        ///
        /// <METAL
        /// fragment shader function name>
        /// Name of a METAL function to use as the fragment shader.
        ///
        /// <color
        /// states>
        /// A dictionary with the following optional keys:
        /// "clear" a boolean specifying whether the color target should be cleared or not
        /// "clearColor" a string specifying the clear color as 4 float ("red green blue alpha"), or the string "sceneBackground" to clear with the scene background color.
        ///
        /// <depth
        /// states>
        /// A dictionary with the following optional keys:
        /// "clear" a boolean specifying whether the depth target should be cleared or not
        /// "enableWrite" a boolean specifying whether writing to depth should be enabled or not.
        /// "enableRead" a boolean specifying whether reading from depth should be enabled or not.
        /// "func" a string specifying depth function to use. See
        /// <comparison
        /// function> for the possible values.
        ///
        /// <stencil
        /// states>
        /// A dictionary with the following optional keys:
        /// "clear" a boolean specifying whether the stencil target should be cleared or not
        /// "enable" a boolean specifying whether writing to stencil should be enabled or not.
        /// "behavior" a dictionary describing the stencil behavior of the front face, or of both faces if no backFaceBehavior is specified. See
        /// <stencil
        /// behavior> for the format of this dictionary.
        /// "backFaceBehavior" a dictionary describing the behavior of the back face. See
        /// <stencil
        /// behavior> for the format of this dictionary.
        ///
        /// <stencil
        /// behavior>
        /// A dictionary with the following optional keys:
        /// "depthFail" a string specifying the operation to do if the depth test fails. See
        /// <stencil
        /// operation> for the possible values.
        /// "fail" a string specifying the operation to do if the stencil test fails. See
        /// <Stencil
        /// operation> for the possible values.
        /// "pass" a string specifying the operation to do if the stencil test passes. See
        /// <stencil
        /// operation> for the possible values.
        /// "function" a string specifying the stencil test. See
        /// <comparison
        /// function> for the possible values.
        /// "readMask" a uint8_t number specifying a mask that is ANDed with both the reference value and the stored stencil value when the test is done
        /// "writeMask" a uint8_t number specifies a bit mask to enable and disable writing of individual bits in the stencil planes
        /// "referenceValue" a uint8_t number specifies the reference value for the stencil test. The initial value is 0.
        ///
        /// <stencil
        /// operation>
        /// A string specifying a stencil operation. It can be one of the following: keep, zero, replace, increment, decrement, invert, incrementWrap, decrementWrap
        ///
        /// <comparison
        /// function>
        /// A string specifying a comparison function. It can be one of the following: never, always, equal, notEqual, less, lessEqual, greater, greaterEqual
        ///
        /// <blend
        /// states>
        /// A dictionary with the following optional keys:
        /// "enable" a boolean number specifying if the blending should be enabled or not. defaults to true.
        /// "colorSrc" a string specifying a blend mode. See
        /// <blend
        /// mode>
        /// "colorDst" a string specifying a blend mode. See
        /// <blend
        /// mode>
        /// "alphaSrc" a string specifying a blend mode. See
        /// <blend
        /// mode>
        /// "alphaDst" a string specifying a blend mode. See
        /// <blend
        /// mode>
        /// "colorOp" a string specifying a blend operation. See
        /// <blend
        /// operation>
        /// "alphaOp" a string specifying a blend operation. See
        /// <blend
        /// operation>
        /// In no Blend states are specified, then the blending is turned off.
        ///
        /// <blend
        /// mode>
        /// A string specifying a blend mode. It can be one of the following: zero, one, srcColor, oneMinusSrcColor, srcAlpha, oneMinusSrcAlpha, dstColor, oneMinusDstColor, dstAlpha, oneMinusDstAlpha, constantColor, oneMinusConstantColor, constantAlpha, oneMinusConstantAlpha, alphaSaturate.
        ///
        /// <blend
        /// operation>
        /// A string specifying a blend operation. It can be one of the following: add, substract, reverseSubstract, min, max.
        ///
        /// <cull
        /// mode>
        /// A string specifying a cull mode. It can be one of the following: front, none, back.
        ///
        /// <custom
        /// viewport>
        /// A string specifying the viewport as 4 float.
        ///
        /// <category
        /// bitMask>
        /// A integer value representing a node category mask (see SCNNode's categoryBitMask).
        /// if the key "excludeCategoryMask" is not specified then it defaults to 0.
        /// if the key "includeCategoryMask" is not specified then it defaults to all bits set.
        /// The DRAW_SCENE command will then render nodes that validate the following test (node.categoryBitMask
        /// &
        /// includeCategoryMask)
        /// &
        /// &
        /// !(excludeCategoryMask
        /// &
        /// node.categoryBitMask).
        ///
        /// <node
        /// name>
        /// The name of a node, or "self" to reference the owner of the technique if any.
        ///
        /// <sample
        /// count>
        /// The number of samples (multisampling) used to render the pass.
        ///
        /// <symbol
        /// description>
        /// A dictionary with the following optional keys and their possible associated values:
        ///
        /// semantic: vertex, normal, color, texcoord, tangent, time, modelViewProjectionTransform, modelViewTransform, modelTransform, viewTransform, projectionTransform, normalTransform, modelViewProjectionInverseTransform, modelViewInverseTransform, modelInverseTransform, viewInverseTransform, projectionInverseTransform, normalInverseTransform
        ///
        /// type: float, vec2, vec3, vec4, mat4, int, ivec2, ivec3, ivec4, mat3, sampler2D, none. Every types can also be an array of the given type by adding [N] where N is the number of elements in the array.
        ///
        /// image: name of an image located in the application bundle. (only valid when type is sampler2D)
        ///
        /// if a semantic is set, no type is required.
        /// Note that with Metal shaders you should not provide any semantic. Instead simply declare a struct in you shader and add the members you need named as specified in SceneKit/scn_metal.
        ///
        /// For example for a per-node semantic:
        ///
        /// struct MyStruct
        /// {
        /// float4x4 modelTransform;
        /// float4x4 modelViewProjectionTransform;
        /// };
        /// then in your function add an argument that must be named “scn_node” to get the members automatically filed with node semantics (see the documentation in scn_metal).
        ///
        /// <target
        /// description>
        /// A dictionary with the following optional keys and their possible associated values:
        ///
        /// type: a string specifying the type of the render target. It can be one of the following: color, depth, stencil
        /// format: a string specifying the format of the render target. It can be:
        /// - for color targets (if not specified defaults to the framebuffer's pixel format)
        /// - r8
        /// - r16                   // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - r16f
        /// - r32f                  // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - rg8                   // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - rg16
        /// - rg16f                 // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - rg32f                 // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - rgba8                 // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - rgba16                // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - rgba16f               // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - rgba32f
        /// - rgba (deprecated)
        /// - for depth targets
        /// - depth16               // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - depth24
        /// - depth32f              // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - for combined depth and stencil targets:
        /// - depth24Unorm_stencil8 // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// - depth32Float_stencil8 // Available since macOS 13, iOS 16, tvOS 16 and watchOS 9
        /// scaleFactor: a float value (encapsulated in a NSNumber) that controls the size of the render target. Defaults to 1, which means 1x the size of the main viewport.
        /// size: a string with the format %dx%d that controls the size of the render target.
        /// persistent: a boolean that tells if this target should persist from one frame to the next. It permits to create temporal effects suchs as motion blur. Defaults to NO.
        ///
        /// <bundleIdentifier
        /// >
        /// An optional bundle identifier to load metal programs from
        ///
        /// <metalLibraryName
        /// >
        /// An optional metal library name to load metal programs from. The metallib file is located from the default or specified bundle using NSBundle pathForResource:ofType:.
        ///
        /// # Safety
        ///
        /// `dictionary` generic should be of the correct type.
        #[unsafe(method(techniqueWithDictionary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn techniqueWithDictionary(
            dictionary: &NSDictionary<NSString, AnyObject>,
        ) -> Option<Retained<SCNTechnique>>;

        /// Creates and returns a technique by sequencing the passes from the specified techniques.
        ///
        /// Parameter `techniques`: The techniques to sequence.
        ///
        /// The passes from "techniques" are executed sequentially. The symbols and targets are merged. This allows to use the same uniform ad targets across multiple techniques.
        #[unsafe(method(techniqueBySequencingTechniques:))]
        #[unsafe(method_family = none)]
        pub unsafe fn techniqueBySequencingTechniques(
            techniques: &NSArray<SCNTechnique>,
        ) -> Option<Retained<SCNTechnique>>;

        #[cfg(all(
            feature = "SCNNode",
            feature = "SCNRenderer",
            feature = "SCNShadable",
            feature = "block2"
        ))]
        /// Sets the block to call at render time to bind the value for the specified symbol of the receiver.
        ///
        /// Parameter `symbol`: The name of the symbol to bind a value for.
        ///
        /// Parameter `block`: The block to call to bind the specified symbol.
        ///
        /// The block will be called at every frame for every pass referencing the specified symbol.
        ///
        /// # Safety
        ///
        /// `block` must be a valid pointer or null.
        #[unsafe(method(handleBindingOfSymbol:usingBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn handleBindingOfSymbol_usingBlock(
            &self,
            symbol: &NSString,
            block: SCNBindingBlock,
        );

        /// Returns the dictionary representation of the technique.
        #[unsafe(method(dictionaryRepresentation))]
        #[unsafe(method_family = none)]
        pub unsafe fn dictionaryRepresentation(
            &self,
        ) -> Retained<NSDictionary<NSString, AnyObject>>;

        /// # Safety
        ///
        /// `key` should be of the correct type.
        #[unsafe(method(objectForKeyedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectForKeyedSubscript(
            &self,
            key: &AnyObject,
        ) -> Option<Retained<AnyObject>>;

        /// # Safety
        ///
        /// - `obj` should be of the correct type.
        /// - `key` should be of the correct type.
        #[unsafe(method(setObject:forKeyedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setObject_forKeyedSubscript(
            &self,
            obj: Option<&AnyObject>,
            key: &ProtocolObject<dyn NSCopying>,
        );

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// The Metal library to use to load the Metal programs specified in the technique description. Defaults to nil which corresponds to the default Metal library.
        #[unsafe(method(library))]
        #[unsafe(method_family = none)]
        pub unsafe fn library(&self) -> Option<Retained<ProtocolObject<dyn MTLLibrary>>>;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`library`][Self::library].
        #[unsafe(method(setLibrary:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLibrary(&self, library: Option<&ProtocolObject<dyn MTLLibrary>>);
    );
}

/// Methods declared on superclass `NSObject`.
impl SCNTechnique {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// The common interface for SceneKit objects that support multipass rendering using [`SCNTechnique`](https://developer.apple.com/documentation/scenekit/scntechnique) objects.
    ///
    /// ## Overview
    ///
    /// Techniques let you specify approaches to rendering a scene that involves multiple drawing passes. For example, you might create a technique that uses a shader program to postprocess a rendered scene on the GPU, creating special effects such as color grading, screen-space ambient occlusion, or motion blur. Different SceneKit objects support techniques in different ways, summarized in Table 1.
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Class" }] }], [Paragraph { inline_content: [Text { text: "Description" }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNView", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNLayer", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: " (macOS), " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNRenderer", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Apply effects whenever the scene is rendered." }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNCamera", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Apply effects when the camera is the current point of view." }] }]], [[Paragraph { inline_content: [Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNLight", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }], [Paragraph { inline_content: [Text { text: "Apply effects when the light is enabled." }] }]]], alignments: None, metadata: None })
    ///
    /// The SCNTechniqueSupport protocol describes an object that supports single or multi-pass techniques
    pub unsafe trait SCNTechniqueSupport: NSObjectProtocol {
        /// Specifies the technique of the receiver. Defaults to nil.
        #[unsafe(method(technique))]
        #[unsafe(method_family = none)]
        unsafe fn technique(&self) -> Option<Retained<SCNTechnique>>;

        /// Setter for [`technique`][Self::technique].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setTechnique:))]
        #[unsafe(method_family = none)]
        unsafe fn setTechnique(&self, technique: Option<&SCNTechnique>);
    }
);
