//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;
#[cfg(feature = "objc2-metal")]
#[cfg(not(target_os = "watchos"))]
use objc2_metal::*;

use crate::*;

/// The drawing primitive that connects vertices when rendering a geometry element, used by the [`primitiveType`](https://developer.apple.com/documentation/scenekit/scngeometryelement/primitivetype) property to specify how SceneKit interprets the geometry element’s data.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SCNGeometryPrimitiveType(pub NSInteger);
impl SCNGeometryPrimitiveType {
    /// The geometry element’s data is a sequence of triangles, with each triangle described by three new vertices.
    #[doc(alias = "SCNGeometryPrimitiveTypeTriangles")]
    pub const Triangles: Self = Self(0);
    /// The geometry element’s data is a sequence of triangles, with each triangle described by one new vertex and two vertices from the previous triangle.
    #[doc(alias = "SCNGeometryPrimitiveTypeTriangleStrip")]
    pub const TriangleStrip: Self = Self(1);
    /// The geometry element’s data is a sequence of line segments, with each line segment described by two new vertices.
    #[doc(alias = "SCNGeometryPrimitiveTypeLine")]
    pub const Line: Self = Self(2);
    /// The geometry element’s data is a sequence of unconnected points.
    #[doc(alias = "SCNGeometryPrimitiveTypePoint")]
    pub const Point: Self = Self(3);
    #[doc(alias = "SCNGeometryPrimitiveTypePolygon")]
    pub const Polygon: Self = Self(4);
}

unsafe impl Encode for SCNGeometryPrimitiveType {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNGeometryPrimitiveType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

// NS_TYPED_EXTENSIBLE_ENUM
pub type SCNGeometrySourceSemantic = NSString;

extern "C" {
    /// The semantic for vertex position data.
    ///
    /// ## Discussion
    ///
    /// For a geometry source, this semantic identifies data containing the positions of each vertex in the geometry. If you create a custom geometry using the [`geometryWithSources:elements:`](https://developer.apple.com/documentation/scenekit/scngeometry/init(sources:elements:)) method, you must provide a geometry source for this semantic.
    ///
    /// For a custom shader program, you use this semantic to bind SceneKit’s vertex position data to an input attribute of the shader.
    ///
    /// Vertex position data is typically an array of three- or four-component vectors.
    ///
    ///
    pub static SCNGeometrySourceSemanticVertex: &'static SCNGeometrySourceSemantic;
}

extern "C" {
    /// The semantic for surface normal data.
    ///
    /// ## Discussion
    ///
    /// For a geometry source, this semantic identifies data containing the surface normal vector at each vertex in the geometry. SceneKit uses this information to compute lighting effects on the surface.
    ///
    /// For a custom shader program, you use this semantic to bind SceneKit’s vertex normal data to an input attribute of the shader.
    ///
    /// Vertex normal data is typically an array of three- or four-component vectors.
    ///
    ///
    pub static SCNGeometrySourceSemanticNormal: &'static SCNGeometrySourceSemantic;
}

extern "C" {
    /// The semantic for per-vertex color data.
    ///
    /// ## Discussion
    ///
    /// For a geometry source, this semantic identifies data containing a color for each vertex in the geometry. SceneKit interpolates per-vertex colors across a surface to produce smooth shading. Per-vertex colors modulate those produced by lighting and a geometry’s materials, if applicable.
    ///
    /// For a custom shader program, you use this semantic to bind SceneKit’s vertex color data to an input attribute of the shader.
    ///
    /// Vertex color data is typically an array of three- or four-component vectors.
    ///
    ///
    pub static SCNGeometrySourceSemanticColor: &'static SCNGeometrySourceSemantic;
}

extern "C" {
    /// The semantic for texture coordinate data.
    ///
    /// ## Discussion
    ///
    /// For a geometry source, this semantic identifies data containing texture mapping coordinates for each vertex in the geometry. Unlike other semantics, a geometry may contain multiple sources for texture coordinates—each corresponds to a separate [`mappingChannel`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty/mappingchannel) number that you can use when associating textured materials.
    ///
    /// For a custom shader program, you use this semantic to bind SceneKit’s texture coordinate data to one or more input attributes of the shader.
    ///
    /// Texture coordinate data is typically an array of two-component vectors.
    ///
    ///
    pub static SCNGeometrySourceSemanticTexcoord: &'static SCNGeometrySourceSemantic;
}

extern "C" {
    /// The semantic for surface tangent vector data.
    ///
    /// ## Discussion
    ///
    /// For a geometry source, this semantic identifies data containing the surface tangent vector at each vertex in the geometry. SceneKit uses this information to compute advanced lighting effects on the surface.
    ///
    /// For a custom shader program, you use this semantic to bind SceneKit’s vertex tangent data to an input attribute of the shader.
    ///
    /// Vertex tangent data is typically an array of three- or four-component vectors.
    ///
    ///
    pub static SCNGeometrySourceSemanticTangent: &'static SCNGeometrySourceSemantic;
}

extern "C" {
    /// The semantic for vertex crease data, used for subdividing surfaces.
    ///
    /// ## Discussion
    ///
    /// For a geometry source, this semantic identifies data containing crease data for each vertex in the geometry. SceneKit uses this information to determine the sharpness of corners and smoothness of surfaces when you change a geometry’s [`subdivisionLevel`](https://developer.apple.com/documentation/scenekit/scngeometry/subdivisionlevel) property.
    ///
    /// For a custom shader program, you use this semantic to bind SceneKit’s vertex crease data to an input attribute of the shader.
    ///
    /// Vertex crease data is an array of scalar floating-point values, where each value determines the smoothness or sharpness of the corresponding vertex: A value of `0.0` specifies a completely smoothed corner, and a value of `10.0` or greater specifies an infinitely sharp point.
    ///
    ///
    pub static SCNGeometrySourceSemanticVertexCrease: &'static SCNGeometrySourceSemantic;
}

extern "C" {
    /// The semantic for edge crease data, used for subdividing surfaces.
    ///
    /// ## Discussion
    ///
    /// For a geometry source, this semantic identifies data containing crease data for each vertex in the geometry. SceneKit uses this information to determine the sharpness of edges and smoothness of surfaces when you change a geometry’s [`subdivisionLevel`](https://developer.apple.com/documentation/scenekit/scngeometry/subdivisionlevel) property.
    ///
    /// For a custom shader program, you use this semantic to bind SceneKit’s edge crease data to an input attribute of the shader.
    ///
    /// Edge crease data is an array of scalar floating-point values, where each value determines the smoothness or sharpness of the edge identified by the primitive at the corresponding index in the geometry’s [SceneKit Constants](https://developer.apple.com/documentation/scenekit/scenekit-constants) geometry element: A value of `0.0` specifies a completely smoothed edge, and a value of `10.0` or greater specifies an infinitely sharp edge.
    ///
    ///
    pub static SCNGeometrySourceSemanticEdgeCrease: &'static SCNGeometrySourceSemantic;
}

extern "C" {
    /// The semantic for bone weight data, used for skeletal animation of skinned surfaces.
    ///
    /// ## Discussion
    ///
    /// For a geometry source, this semantic identifies data containing skeletal animation data for each vertex in the geometry. SceneKit uses this information to determine how much a vertex’s position is influenced by the positions of bone nodes in the skeleton.
    ///
    /// For a custom shader program, you use this semantic to bind SceneKit’s bone weight data to an input attribute of the shader.
    ///
    /// For details on skeletal animation, see [`SCNSkinner`](https://developer.apple.com/documentation/scenekit/scnskinner).
    ///
    ///
    pub static SCNGeometrySourceSemanticBoneWeights: &'static SCNGeometrySourceSemantic;
}

extern "C" {
    /// The semantic for bone index data, used for skeletal animation of skinned surfaces.
    ///
    /// ## Discussion
    ///
    /// For a geometry source, this semantic identifies data containing skeletal animation data for each vertex in the geometry. SceneKit uses this information to determine which bone nodes in the skeleton affect the behavior of each vertex.
    ///
    /// For a custom shader program, you use this semantic to bind SceneKit’s bone index data to an input attribute of the shader.
    ///
    /// For details on skeletal animation, see [`SCNSkinner`](https://developer.apple.com/documentation/scenekit/scnskinner).
    ///
    ///
    pub static SCNGeometrySourceSemanticBoneIndices: &'static SCNGeometrySourceSemantic;
}

extern_class!(
    /// A three-dimensional shape (also called a model or mesh) that can be displayed in a scene, with attached materials that define its appearance.
    ///
    /// ## Overview
    ///
    /// In SceneKit, geometries attached to [`SCNNode`](https://developer.apple.com/documentation/scenekit/scnnode) objects form the visible elements of a scene, and [`SCNMaterial`](https://developer.apple.com/documentation/scenekit/scnmaterial) objects attached to a geometry determine its appearance.
    ///
    /// ### Working with Geometry Objects
    ///
    /// You control a geometry’s appearance in a scene with nodes and materials. A geometry object provides only the form of a visible object rendered by SceneKit. You specify color and texture for a geometry’s surface, control how it responds to light, and add special effects by attaching materials (for details, see the methods in Managing a Geometry’s Materials). You position and orient a geometry in a scene by attaching it to an [`SCNNode`](https://developer.apple.com/documentation/scenekit/scnnode) object. Multiple nodes can reference the same geometry object, allowing it to appear at different positions in a scene.
    ///
    /// You can easily copy geometries and change their materials. A geometry object manages the association between immutable vertex data and a mutable assignment of materials. To make a geometry appear more than once in the same scene with a different set of materials, use its inherited [`copy`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class/copy()) method. The copy shares the underlying vertex data of the original, but can be assigned materials independently. You can thus make many copies of a geometry without incurring a significant cost to rendering performance.
    ///
    /// You can animate a geometry object. The vertex data associated with a geometry is immutable, but SceneKit provides several ways to animate geometry. You can use a [`SCNMorpher`](https://developer.apple.com/documentation/scenekit/scnmorpher) or [`SCNSkinner`](https://developer.apple.com/documentation/scenekit/scnskinner) object to deform a geometry’s surface, or run animations created in an external 3D authoring tool and loaded from a scene file. You can also use methods in the [`SCNShadable`](https://developer.apple.com/documentation/scenekit/scnshadable) protocol to add custom GLSL shader programs that alter SceneKit’s rendering of a geometry.
    ///
    /// ### Obtaining a Geometry Object
    ///
    /// SceneKit provides several ways to introduce geometry objects to your app:
    ///
    /// (TODO table: Table { header: "row", extended_data: None, rows: [[[Paragraph { inline_content: [Text { text: "Action" }] }], [Paragraph { inline_content: [Text { text: "For further information" }] }]], [[Paragraph { inline_content: [Text { text: "Load from a scene file created using external 3D authoring tools" }] }], [Paragraph { inline_content: [Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNScene", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNSceneSource", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }]], [[Paragraph { inline_content: [Text { text: "Use and customize SceneKit’s built-in primitive shapes" }] }], [Paragraph { inline_content: [Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNPlane", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNBox", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNSphere", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNPyramid", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNCone", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNCylinder", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNCapsule", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNTube", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", and " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNTorus", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }]], [[Paragraph { inline_content: [Text { text: "Create 3D geometry from 2D text or Bézier curves" }] }], [Paragraph { inline_content: [Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNText", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNShape", is_active: true, overriding_title: None, overriding_title_inline_content: None }] }]], [[Paragraph { inline_content: [Text { text: "Create a custom geometry from vertex data" }] }], [Paragraph { inline_content: [Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNGeometrySource", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNGeometryElement", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", " }, Reference { identifier: "doc://com.apple.scenekit/documentation/SceneKit/SCNGeometry/init(sources:elements:)", is_active: true, overriding_title: None, overriding_title_inline_content: None }, Text { text: ", Managing Geometry Data" }] }]]], alignments: None, metadata: None })
    ///
    /// SCNGeometry is an abstract class that represents the geometry that can be attached to a SCNNode.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SCNGeometry;
);

extern_conformance!(
    unsafe impl NSCoding for SCNGeometry {}
);

extern_conformance!(
    unsafe impl NSCopying for SCNGeometry {}
);

unsafe impl CopyingHelper for SCNGeometry {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for SCNGeometry {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for SCNGeometry {}
);

#[cfg(feature = "SCNAnimation")]
extern_conformance!(
    unsafe impl SCNAnimatable for SCNGeometry {}
);

#[cfg(feature = "SCNBoundingVolume")]
extern_conformance!(
    unsafe impl SCNBoundingVolume for SCNGeometry {}
);

#[cfg(feature = "SCNShadable")]
extern_conformance!(
    unsafe impl SCNShadable for SCNGeometry {}
);

impl SCNGeometry {
    extern_methods!(
        /// Creates and returns an empty geometry object.
        ///
        /// An empty geometry may be used as the lowest level of detail of a geometry.
        #[unsafe(method(geometry))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometry() -> Retained<Self>;

        /// Determines the name of the receiver.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Option<Retained<NSString>>;

        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        #[cfg(feature = "SCNMaterial")]
        /// Specifies the receiver's materials array.
        ///
        /// Each geometry element can be rendered using a different material. The index of the material used for a geometry element is equal to the index of that element modulo the number of materials.
        #[unsafe(method(materials))]
        #[unsafe(method_family = none)]
        pub unsafe fn materials(&self) -> Retained<NSArray<SCNMaterial>>;

        #[cfg(feature = "SCNMaterial")]
        /// Setter for [`materials`][Self::materials].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setMaterials:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaterials(&self, materials: &NSArray<SCNMaterial>);

        #[cfg(feature = "SCNMaterial")]
        /// Determines the first material of the geometry. Returns nil if the geometry has no material.
        ///
        /// This method is here for convenience. It is equivalent to the first object in the "materials" array above.
        #[unsafe(method(firstMaterial))]
        #[unsafe(method_family = none)]
        pub unsafe fn firstMaterial(&self) -> Option<Retained<SCNMaterial>>;

        #[cfg(feature = "SCNMaterial")]
        /// Setter for [`firstMaterial`][Self::firstMaterial].
        #[unsafe(method(setFirstMaterial:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFirstMaterial(&self, first_material: Option<&SCNMaterial>);

        #[cfg(feature = "SCNMaterial")]
        /// Insert a material in the materials array at the specified index.
        ///
        /// Parameter `material`: The material to insert.
        ///
        /// Parameter `index`: Index in the materials array to insert the new material.
        #[unsafe(method(insertMaterial:atIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertMaterial_atIndex(&self, material: &SCNMaterial, index: NSUInteger);

        /// Remove the material at the specified index from the materials array.
        ///
        /// Parameter `index`: The index of the material to remove from the 'materials' array.
        #[unsafe(method(removeMaterialAtIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeMaterialAtIndex(&self, index: NSUInteger);

        #[cfg(feature = "SCNMaterial")]
        /// Remove the material at the index 'index' from the materials array of the receiver and insert 'material' in its position.
        ///
        /// Parameter `index`: The index of the material to replace in the materials array.
        ///
        /// Parameter `material`: The new material that will replace the previous one.
        #[unsafe(method(replaceMaterialAtIndex:withMaterial:))]
        #[unsafe(method_family = none)]
        pub unsafe fn replaceMaterialAtIndex_withMaterial(
            &self,
            index: NSUInteger,
            material: &SCNMaterial,
        );

        #[cfg(feature = "SCNMaterial")]
        /// Return the first material from the materials array of the receiver with the specified name.
        ///
        /// Parameter `name`: The name of the material to retrieve.
        #[unsafe(method(materialWithName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn materialWithName(&self, name: &NSString) -> Option<Retained<SCNMaterial>>;

        /// Creates and returns a new geometry built from geometry sources and geometry elements.
        ///
        /// Parameter `sources`: An array of geometry sources. If several geometry sources have the same semantic, only the first one is taken into account.
        ///
        /// Parameter `elements`: An array of geometry elements. The sort order in the array determines the mapping between materials and geometry elements.
        ///
        /// A geometry is made of geometry sources (at least `SCNGeometrySourceSemanticVertex`) and at least one geometry element. Multiple sources for texture coordinates are accepted. In that case the `mappingChannel` is implicitly set based on the order of the texture sources, starting at index 0.
        #[unsafe(method(geometryWithSources:elements:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometryWithSources_elements(
            sources: &NSArray<SCNGeometrySource>,
            elements: Option<&NSArray<SCNGeometryElement>>,
        ) -> Retained<Self>;

        /// Creates and returns a new geometry built from geometry sources and geometry elements, with per-source indexed geometry data.
        ///
        /// Parameter `sources`: An array of geometry sources. If several geometry sources have the same semantic, only the first one is taken into account.
        ///
        /// Parameter `elements`: An array of geometry elements. The sort order in the array determines the mapping between materials and geometry elements.
        ///
        /// Parameter `sourceChannels`: An array of indices that describes, for each geometry source, which channel of the geometry elements to use.
        ///
        /// ```text
        /// Example: geometry made of 3 primitives (2 quads, 1 pentagon) using different indices to reference position and UV data (2 channels)
        ///
        /// Positions         ┆   POS0           POS3           POS4    ┆             quad   quad   pentagon    quad   quad   pentagon    ┆   SCNGeometryElement *element = [SCNGeometryElement geometryElementWithData:…
        /// 0 │ (0.0, 0.0, 0.0)   ┆        ┌───────────┬───────────┐        ┆           ┌─────┐ ┌─────┐ ┌───────┐ ┌─────┐ ┌─────┐ ┌───────┐   ┆                                                               primitiveType:SCNGeometryPrimitiveTypePolygon
        /// 1 │ (0.0, 1.0, 0.0)   ┆        │UV0     UV3│UV0     UV3│        ┆     4 4 5 0 1 2 3 5 4 3 2 7 6 5 2 1 0 1 2 3 2 3 0 1 1 2 3 4 0   ┆                                                              primitiveCount:3
        /// 2 │ (1.0, 0.0, 0.0)   ┆        │           │           │        ┆     └───┘ └───────────────────────┘ └───────────────────────┘   ┆                                                         indicesChannelCount:2
        /// 3 │ (1.0, 1.0, 0.0)   ┆        │     A     │     B     │        ┆   polygons        channel 0                 channel 1           ┆                                                  interleavedIndicesChannels:…
        /// 4 │ (2.0, 0.0, 0.0)   ┆        │           │           │        ┆                  (positions)                  (UVs)             ┆                                                               bytesPerIndex:…];
        /// 5 │ (2.0, 1.0, 0.0)   ┆        │UV1     UV2│UV1     UV2│        ┆                                                                 ┆
        /// 6 │ (2.0, 2.0, 0.0)   ┆   POS1 ├───────────┴───────────┤ POS5   ┆                                                                 ┆   SCNGeometry *geometry = [SCNGeometry geometryWithSources:
        /// @
        /// [positionSource, texcoordsSource]
        /// 7 │ (0.0, 2.0, 0.0)   ┆        │UVO       UV4       UV3│        ┆                                                                 ┆                                                   elements:
        /// @
        /// [element]
        /// ┆        │         POS2          │        ┆                quad A          quad B          pentagon C       ┆                                             sourceChannels:
        /// @
        /// [0, 1]];
        /// UVs               ┆        │                       │        ┆           ┌─────────────┐ ┌─────────────┐ ┌─────────────────┐   ┆
        /// 0 │ (0.0, 0.0)        ┆        │           C           │        ┆     4 4 5 0 0 1 1 2 2 3 3 5 2 4 3 3 0 2 1 7 1 6 2 5 3 2 4 1 0   ┆
        /// 1 │ (0.0, 1.0)        ┆        │                       │        ┆     └───┘└──────────────────────────────────────────────────┘   ┆
        /// 2 │ (1.0, 1.0)        ┆        │UV1                 UV2│        ┆   polygons               interleaved  channels                  ┆
        /// 3 │ (1.0, 0.0)        ┆        └───────────────────────┘        ┆                           (positions and UVs)                   ┆
        /// 4 │ (0.5, 0.0)        ┆   POS7                          POS6    ┆                                                                 ┆
        ///
        /// Example: geometry made of 3 primitives (2 quads, 1 pentagon) using the same indices to reference position and UV data (1 channel)
        ///
        /// Positions         ┆   POS0           POS3           POS4    ┆             quad A      quad B      pentagon C                  ┆   SCNGeometryElement *element = [SCNGeometryElement geometryElementWithData:…
        /// 0 │ (0.0, 4.0, 0.0)   ┆        ┌───────────┬───────────┐        ┆           ┌────────┐  ┌────────┐  ┌───────────┐                 ┆                                                               primitiveType:SCNGeometryPrimitiveTypePolygon
        /// 1 │ (0.0, 2.0, 0.0)   ┆        │UV0     UV3│UV3     UV4│        ┆     4 4 5 0  1  2  3  5  4  3  2  7  6  5  2  1                 ┆                                                              primitiveCount:3
        /// 2 │ (2.0, 2.0, 0.0)   ┆        │           │           │        ┆     └───┘ └───────────────────────────────────┘                 ┆                                                               bytesPerIndex:…];
        /// 3 │ (2.0, 4.0, 0.0)   ┆        │     A     │     B     │        ┆   polygons              channel 0                               ┆
        /// 4 │ (4.0, 4.0, 0.0)   ┆        │           │           │        ┆                    (positions and UVs)                          ┆   SCNGeometry *geometry = [SCNGeometry geometryWithSources:
        /// @
        /// [positionSource, texcoordsSource]
        /// 5 │ (4.0, 2.0, 0.0)   ┆        │UV1     UV2│UV2     UV5│        ┆                                                                 ┆                                                   elements:
        /// @
        /// [element]];
        /// 6 │ (4.0, 0.0, 0.0)   ┆   POS1 ├───────────┴───────────┤ POS5   ┆                                                                 ┆
        /// 7 │ (0.0, 0.0, 0.0)   ┆        │UV1       UV2       UV5│        ┆                                                                 ┆                                            === or equivalently ===
        /// ┆        │         POS2          │        ┆                                                                 ┆
        /// UVs               ┆        │                       │        ┆                                                                 ┆   SCNGeometryElement *element = [SCNGeometryElement geometryElementWithData:…
        /// 0 │ (0.0, 0.0)        ┆        │           C           │        ┆                                                                 ┆                                                               primitiveType:SCNGeometryPrimitiveTypePolygon
        /// 1 │ (0.0, 0.5)        ┆        │                       │        ┆                                                                 ┆                                                              primitiveCount:3
        /// 2 │ (0.5, 0.5)        ┆        │UV7                 UV6│        ┆                                                                 ┆                                                         indicesChannelCount:1
        /// 3 │ (0.5, 0.0)        ┆        └───────────────────────┘        ┆                                                                 ┆                                                  interleavedIndicesChannels:…
        /// 4 │ (1.0, 0.0)        ┆   POS7                          POS6    ┆                                                                 ┆                                                               bytesPerIndex:…];
        /// 5 │ (1.0, 0.5)        ┆                                         ┆                                                                 ┆
        /// 6 │ (1.0, 1.0)        ┆                                         ┆                                                                 ┆   SCNGeometry *geometry = [SCNGeometry geometryWithSources:
        /// @
        /// [positionSource, texcoordsSource]
        /// 7 │ (0.0, 1.0)        ┆                                         ┆                                                                 ┆                                                   elements:
        /// @
        /// [element]
        /// ┆                                         ┆                                                                 ┆                                             sourceChannels:
        /// @
        /// [0, 0]];                                                                                                                                               ┆
        /// ```
        #[unsafe(method(geometryWithSources:elements:sourceChannels:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometryWithSources_elements_sourceChannels(
            sources: &NSArray<SCNGeometrySource>,
            elements: Option<&NSArray<SCNGeometryElement>>,
            source_channels: Option<&NSArray<NSNumber>>,
        ) -> Retained<Self>;

        /// The array of geometry sources of the receiver.
        #[unsafe(method(geometrySources))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometrySources(&self) -> Retained<NSArray<SCNGeometrySource>>;

        /// Returns the geometry sources for a given semantic.
        ///
        /// Parameter `semantic`: The semantic of the geometry sources that should be retrieved.
        ///
        /// Returns nil if no geometry source is found for the given semantic. May return more than one source, typically for multiple texture coordinate sources.
        #[unsafe(method(geometrySourcesForSemantic:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometrySourcesForSemantic(
            &self,
            semantic: &SCNGeometrySourceSemantic,
        ) -> Retained<NSArray<SCNGeometrySource>>;

        /// The array of geometry elements of the receiver.
        #[unsafe(method(geometryElements))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometryElements(&self) -> Retained<NSArray<SCNGeometryElement>>;

        /// Returns the number of geometry elements owned by the geometry.
        #[unsafe(method(geometryElementCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometryElementCount(&self) -> NSInteger;

        /// Returns the geometry element at a given index.
        ///
        /// Parameter `elementIndex`: The index of the geometry element.
        #[unsafe(method(geometryElementAtIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometryElementAtIndex(
            &self,
            element_index: NSInteger,
        ) -> Retained<SCNGeometryElement>;

        /// An array of indices that describes, for each geometry source, which channel of the geometry elements to use.
        #[unsafe(method(geometrySourceChannels))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometrySourceChannels(&self) -> Option<Retained<NSArray<NSNumber>>>;

        #[cfg(feature = "SCNLevelOfDetail")]
        /// Determines the receiver's levels of detail. Defaults to nil.
        #[unsafe(method(levelsOfDetail))]
        #[unsafe(method_family = none)]
        pub unsafe fn levelsOfDetail(&self) -> Option<Retained<NSArray<SCNLevelOfDetail>>>;

        #[cfg(feature = "SCNLevelOfDetail")]
        /// Setter for [`levelsOfDetail`][Self::levelsOfDetail].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLevelsOfDetail:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLevelsOfDetail(
            &self,
            levels_of_detail: Option<&NSArray<SCNLevelOfDetail>>,
        );

        #[unsafe(method(tessellator))]
        #[unsafe(method_family = none)]
        pub unsafe fn tessellator(&self) -> Option<Retained<SCNGeometryTessellator>>;

        /// Setter for [`tessellator`][Self::tessellator].
        #[unsafe(method(setTessellator:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTessellator(&self, tessellator: Option<&SCNGeometryTessellator>);

        /// Specifies the subdivision level of the receiver. Defaults to 0.
        ///
        /// A subdivision level of 0 means no subdivision. When the `tessellator` property of the receiver is not nil, the refinement is done on the GPU.
        #[unsafe(method(subdivisionLevel))]
        #[unsafe(method_family = none)]
        pub unsafe fn subdivisionLevel(&self) -> NSUInteger;

        /// Setter for [`subdivisionLevel`][Self::subdivisionLevel].
        #[unsafe(method(setSubdivisionLevel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSubdivisionLevel(&self, subdivision_level: NSUInteger);

        /// Specifies if the subdivision is adaptive or uniform. Defaults to YES.
        ///
        /// Adaptive subdivision requires that the `tessellator` property of the receiver is not nil.
        #[unsafe(method(wantsAdaptiveSubdivision))]
        #[unsafe(method_family = none)]
        pub unsafe fn wantsAdaptiveSubdivision(&self) -> bool;

        /// Setter for [`wantsAdaptiveSubdivision`][Self::wantsAdaptiveSubdivision].
        #[unsafe(method(setWantsAdaptiveSubdivision:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWantsAdaptiveSubdivision(&self, wants_adaptive_subdivision: bool);

        /// Specifies the edges creases that control the subdivision. Defaults to nil.
        ///
        /// The primitive type of this geometry element must be SCNGeometryPrimitiveTypeLine. See subdivisionLevel above to control the level of subdivision. See edgeCreasesSource below to specify sharpness of the creases.
        #[unsafe(method(edgeCreasesElement))]
        #[unsafe(method_family = none)]
        pub unsafe fn edgeCreasesElement(&self) -> Option<Retained<SCNGeometryElement>>;

        /// Setter for [`edgeCreasesElement`][Self::edgeCreasesElement].
        #[unsafe(method(setEdgeCreasesElement:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEdgeCreasesElement(
            &self,
            edge_creases_element: Option<&SCNGeometryElement>,
        );

        /// Specifies the crease value of the edges specified by edgeCreasesElement. Defaults to nil.
        ///
        /// The semantic of this geometry source must be "SCNGeometrySourceSemanticEdgeCrease". The creases values are floating values between 0 and 10, where 0 means smooth and 10 means infinitely sharp. See subdivisionLevel above to control the level of subdivision. See edgeCreasesElement above to specify edges for edge creases.
        #[unsafe(method(edgeCreasesSource))]
        #[unsafe(method_family = none)]
        pub unsafe fn edgeCreasesSource(&self) -> Option<Retained<SCNGeometrySource>>;

        /// Setter for [`edgeCreasesSource`][Self::edgeCreasesSource].
        #[unsafe(method(setEdgeCreasesSource:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEdgeCreasesSource(&self, edge_creases_source: Option<&SCNGeometrySource>);
    );
}

/// Methods declared on superclass `NSObject`.
impl SCNGeometry {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A container for vertex data forming part of the definition for a three-dimensional object, or geometry.
    ///
    /// ## Overview
    ///
    /// You use geometry sources together with [`SCNGeometryElement`](https://developer.apple.com/documentation/scenekit/scngeometryelement) objects to define custom [`SCNGeometry`](https://developer.apple.com/documentation/scenekit/scngeometry) objects or to inspect the data that composes an existing geometry.
    ///
    /// You create a custom geometry using a three-step process:
    ///
    /// 1. Create one or more [`SCNGeometrySource`](https://developer.apple.com/documentation/scenekit/scngeometrysource) objects containing vertex data. Each geometry source defines an attribute, or semantic, of the vertices it describes. You must provide at least one geometry source, using the [`SCNGeometrySourceSemanticVertex`](https://developer.apple.com/documentation/scenekit/scngeometrysource/semantic-swift.struct/vertex) semantic, to create a custom geometry; typically you also provide geometry sources for surface normals and texture coordinates.
    ///
    /// 2. Create at least one [`SCNGeometryElement`](https://developer.apple.com/documentation/scenekit/scngeometryelement) object, containing an array of indices identifying vertices in the geometry sources and describing the drawing primitive that SceneKit uses to connect the vertices when rendering the geometry.
    ///
    /// 3. Create an [`SCNGeometry`](https://developer.apple.com/documentation/scenekit/scngeometry) instance from the geometry sources and geometry elements.
    ///
    /// ### Interleaving Vertex Data
    ///
    /// Because most geometries use more than one geometry source and the GPU typically uses data from multiple sources together, you can achieve better rendering performance for custom geometries by interleaving the vertex data for multiple semantics in the same array.
    ///
    /// To do this, first create an array where each element contains values for multiple semantics for the same vertex. Next, create an [`NSData`](https://developer.apple.com/documentation/foundation/nsdata) object from that array, and create each geometry source from that data using the `offset` and `stride` parameters to specify where the values for each semantic can be found in the array. To make specifying the sizes and locations of vectors more convenient, you can define your own data structure for vertices and use the `sizeof` (and, in Objective-C, `offsetof`) functions, as shown in Listing 1.
    ///
    /// Listing 1. Creating multiple geometry sources from interleaved data
    ///
    /// ```objc
    /// typedef struct {
    ///     float x, y, z;    // position
    ///     float nx, ny, nz; // normal
    ///     float s, t;       // texture coordinates
    /// } MyVertex;
    ///  
    /// MyVertex vertices[VERTEX_COUNT] = { /* ... vertex data ... */ };
    /// NSData *data = [NSData dataWithBytes:vertices length:sizeof(vertices)];
    /// SCNGeometrySource *vertexSource, *normalSource, *tcoordSource;
    ///  
    /// vertexSource = [SCNGeometrySource geometrySourceWithData:data
    ///                                                 semantic:SCNGeometrySourceSemanticVertex
    ///                                              vectorCount:VERTEX_COUNT
    ///                                          floatComponents:YES
    ///                                      componentsPerVector:3 // x, y, z
    ///                                        bytesPerComponent:sizeof(float)
    ///                                               dataOffset:offsetof(MyVertex, x)
    ///                                               dataStride:sizeof(MyVertex)];
    ///  
    /// normalSource = [SCNGeometrySource geometrySourceWithData:data
    ///                                                 semantic:SCNGeometrySourceSemanticNormal
    ///                                              vectorCount:VERTEX_COUNT
    ///                                          floatComponents:YES
    ///                                      componentsPerVector:3 // nx, ny, nz
    ///                                        bytesPerComponent:sizeof(float)
    ///                                               dataOffset:offsetof(MyVertex, nx)
    ///                                               dataStride:sizeof(MyVertex)];
    ///  
    /// tcoordSource = [SCNGeometrySource geometrySourceWithData:data
    ///                                                 semantic:SCNGeometrySourceSemanticTexcoord
    ///                                              vectorCount:VERTEX_COUNT
    ///                                          floatComponents:YES
    ///                                      componentsPerVector:2 // s, t
    ///                                        bytesPerComponent:sizeof(float)
    ///                                               dataOffset:offsetof(MyVertex, s)
    ///                                               dataStride:sizeof(MyVertex)];
    /// ```
    ///
    ///
    /// A geometry source contains geometry data for a specific semantic. The data format is described by properties.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SCNGeometrySource;
);

extern_conformance!(
    unsafe impl NSCoding for SCNGeometrySource {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for SCNGeometrySource {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for SCNGeometrySource {}
);

impl SCNGeometrySource {
    extern_methods!(
        /// Creates and returns a geometry source from the given data and parameters.
        ///
        /// Parameter `data`: The geometry data.
        ///
        /// Parameter `semantic`: The semantic of the geometry source.
        ///
        /// Parameter `vectorCount`: The number of geometry source vectors.
        ///
        /// Parameter `floatComponents`: A flag that indicates if vector components are floating point values.
        ///
        /// Parameter `componentsPerVector`: The number of scalar components in a vector.
        ///
        /// Parameter `bytesPerComponent`: The number of bytes that represent a vector component.
        ///
        /// Parameter `offset`: The offset from the beginning of the data. In bytes.
        ///
        /// Parameter `stride`: The number of bytes from a vector to the next one in the data.
        #[unsafe(method(geometrySourceWithData:semantic:vectorCount:floatComponents:componentsPerVector:bytesPerComponent:dataOffset:dataStride:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometrySourceWithData_semantic_vectorCount_floatComponents_componentsPerVector_bytesPerComponent_dataOffset_dataStride(
            data: &NSData,
            semantic: &SCNGeometrySourceSemantic,
            vector_count: NSInteger,
            float_components: bool,
            components_per_vector: NSInteger,
            bytes_per_component: NSInteger,
            offset: NSInteger,
            stride: NSInteger,
        ) -> Retained<Self>;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Creates and returns a geometry source from vertices stored in a buffer of SCNVector3 values.
        ///
        /// Parameter `vertices`: The buffer of vertices.
        ///
        /// Parameter `count`: The number of vertices.
        ///
        /// Input vertices are copied to an optimized data format. The actual format is described by the properties of the resulting instance.
        ///
        /// # Safety
        ///
        /// `vertices` must be a valid pointer.
        #[unsafe(method(geometrySourceWithVertices:count:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometrySourceWithVertices_count(
            vertices: NonNull<SCNVector3>,
            count: NSInteger,
        ) -> Retained<Self>;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Creates and returns a geometry source from normals stored in a buffer of SCNVector3 values.
        ///
        /// Parameter `normals`: The buffer of normals.
        ///
        /// Parameter `count`: The number of normals.
        ///
        /// Input normals are copied to an optimized data format. The actual format is described by the properties of the resulting instance.
        ///
        /// # Safety
        ///
        /// `normals` must be a valid pointer.
        #[unsafe(method(geometrySourceWithNormals:count:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometrySourceWithNormals_count(
            normals: NonNull<SCNVector3>,
            count: NSInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-core-foundation")]
        /// Creates and returns a geometry source from texture coordinates stored in a buffer of CGPoint values.
        ///
        /// Parameter `texcoord`: The buffer of texture coordinates.
        ///
        /// Parameter `count`: The number of texture coordinate points.
        ///
        /// Input texture coordinates are copied to an optimized data format. The actual format is described by the properties of the resulting instance.
        ///
        /// # Safety
        ///
        /// `texcoord` must be a valid pointer.
        #[unsafe(method(geometrySourceWithTextureCoordinates:count:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometrySourceWithTextureCoordinates_count(
            texcoord: NonNull<CGPoint>,
            count: NSInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// Creates and returns a geometry source from the given data and parameters.
        ///
        /// Parameter `buffer`: A Metal buffer.
        ///
        /// Parameter `vertexFormat`: The vertex format.
        ///
        /// Parameter `semantic`: The semantic of the geometry source.
        ///
        /// Parameter `vertexCount`: The number of vertex.
        ///
        /// Parameter `offset`: The offset from the beginning of the data. In bytes.
        ///
        /// Parameter `stride`: The number of bytes from a vector to the next one in the data.
        ///
        /// Attempting to modify the Metal buffer outside the SCNSceneRenderer delegate callbacks is undefined.
        /// The typical usage it to modify the MTLBuffer within the willRenderScene callback, using a compute kernel or a vertex function in the user own command buffer. So something like:
        ///
        /// - (void)renderer:(id
        /// <SCNSceneRenderer
        /// >)aRenderer willRenderScene:(SCNScene *)scene atTime:(NSTimeInterval)time
        /// {
        /// // ask for a new command buffer
        /// id
        /// <MTLCommandBuffer
        /// > myCommandBuffer = [aRenderer.commandQueue commandBuffer];
        ///
        /// // get a compute command encoder
        /// id
        /// <MTLComputeCommandEncoder
        /// > myComputeCommandEncoder = [myCommandBuffer computeCommandEncoder];
        ///
        /// // configure the compute command encoder's pipeline state, buffer inputs etc...
        /// //...
        ///
        /// // dispatch the
        /// [myComputeCommandEncoder dispatchThreadgroups:numberOfWorkingGroups threadsPerThreadgroup:numberOfThreads];
        /// [myComputeCommandEncoder endEncoding];
        ///
        /// [myCommandBuffer commit];
        /// }
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(geometrySourceWithBuffer:vertexFormat:semantic:vertexCount:dataOffset:dataStride:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometrySourceWithBuffer_vertexFormat_semantic_vertexCount_dataOffset_dataStride(
            buffer: &ProtocolObject<dyn MTLBuffer>,
            vertex_format: MTLVertexFormat,
            semantic: &SCNGeometrySourceSemantic,
            vertex_count: NSInteger,
            offset: NSInteger,
            stride: NSInteger,
        ) -> Retained<Self>;

        /// The data for the geometry source
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Retained<NSData>;

        /// The semantic of the geometry source
        #[unsafe(method(semantic))]
        #[unsafe(method_family = none)]
        pub unsafe fn semantic(&self) -> Retained<SCNGeometrySourceSemantic>;

        /// The number of vectors in the data.
        #[unsafe(method(vectorCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn vectorCount(&self) -> NSInteger;

        /// A flag that indicates if vector components are floating point values.
        #[unsafe(method(floatComponents))]
        #[unsafe(method_family = none)]
        pub unsafe fn floatComponents(&self) -> bool;

        /// The number of scalar components in each vector.
        #[unsafe(method(componentsPerVector))]
        #[unsafe(method_family = none)]
        pub unsafe fn componentsPerVector(&self) -> NSInteger;

        /// The size of a vector component in bytes.
        #[unsafe(method(bytesPerComponent))]
        #[unsafe(method_family = none)]
        pub unsafe fn bytesPerComponent(&self) -> NSInteger;

        /// The offset from the beginning of the data. In bytes.
        #[unsafe(method(dataOffset))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataOffset(&self) -> NSInteger;

        /// The number of bytes from a vector to the next one in the data.
        #[unsafe(method(dataStride))]
        #[unsafe(method_family = none)]
        pub unsafe fn dataStride(&self) -> NSInteger;
    );
}

/// Methods declared on superclass `NSObject`.
impl SCNGeometrySource {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// A container for index data describing how vertices connect to define a three-dimensional object, or geometry.
    ///
    /// ## Overview
    ///
    /// You use geometry elements together with [`SCNGeometrySource`](https://developer.apple.com/documentation/scenekit/scngeometrysource) objects to define custom [`SCNGeometry`](https://developer.apple.com/documentation/scenekit/scngeometry) objects or to inspect the data that composes an existing geometry. You create a custom geometry using a three-step process:
    ///
    /// 1. Create one or more [`SCNGeometrySource`](https://developer.apple.com/documentation/scenekit/scngeometrysource) objects, each of which defines per-vertex information such as position, surface normal, or texture coordinates for all vertices in the geometry.
    ///
    /// 2. Create at least one [`SCNGeometryElement`](https://developer.apple.com/documentation/scenekit/scngeometryelement) object, containing an array of indices identifying vertices in the geometry sources and describing the drawing primitive that SceneKit uses to connect the vertices when rendering the geometry.
    ///
    /// 3. Create an [`SCNGeometry`](https://developer.apple.com/documentation/scenekit/scngeometry) instance from the geometry sources and geometry elements.
    ///
    /// When SceneKit renders a geometry, each geometry element corresponds to a drawing command sent to the GPU. Because different rendering states require separate drawing commands, you can define a geometry using multiple geometry elements. For example, the teapot geometry shown below has four geometry elements, so you can assign up to four [`SCNMaterial`](https://developer.apple.com/documentation/scenekit/scnmaterial) objects in order to render each element with a different appearance. But because each drawing command incurs a CPU time overhead when rendering, minimizing the number of elements in a custom geometry can improve rendering performance.
    ///
    ///
    /// ![](https://docs-assets.developer.apple.com/published/4cd3b44ccbea79bf52cb77c6d99edcff/media-2929778%402x.png)
    ///
    ///
    ///
    /// A geometry element describes how vertices from a geometry source are connected together.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SCNGeometryElement;
);

extern_conformance!(
    unsafe impl NSCoding for SCNGeometryElement {}
);

extern_conformance!(
    unsafe impl NSObjectProtocol for SCNGeometryElement {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for SCNGeometryElement {}
);

impl SCNGeometryElement {
    extern_methods!(
        /// Creates and returns a geometry element from the given data and data format info.
        ///
        /// Parameter `data`: The data that contains element indices. You can pass nil to use an implicit vertex ordering (0,1,2,…).
        ///
        /// Parameter `primitiveType`: The primitive type, as listed in the SCNGeometryPrimitiveType enumeration.
        ///
        /// Parameter `primitiveCount`: The number of primitives in the data.
        ///
        /// Parameter `bytesPerIndex`: The number of bytes that represent a single index value in the data.
        #[unsafe(method(geometryElementWithData:primitiveType:primitiveCount:bytesPerIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometryElementWithData_primitiveType_primitiveCount_bytesPerIndex(
            data: Option<&NSData>,
            primitive_type: SCNGeometryPrimitiveType,
            primitive_count: NSInteger,
            bytes_per_index: NSInteger,
        ) -> Retained<Self>;

        /// Parameter `data`: The data that contains element indices. You can pass nil to use an implicit vertex ordering (0,1,2,…).
        ///
        /// Parameter `primitiveType`: The primitive type, as listed in the SCNGeometryPrimitiveType enumeration.
        ///
        /// Parameter `primitiveCount`: The number of primitives in the data.
        ///
        /// Parameter `indicesChannelCount`: The number of channels for the vertex indices.
        ///
        /// Parameter `interleavedIndicesChannels`: Whether the channels are interleaved.
        ///
        /// Parameter `bytesPerIndex`: The number of bytes that represent a single index value in the data.
        #[unsafe(method(geometryElementWithData:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometryElementWithData_primitiveType_primitiveCount_indicesChannelCount_interleavedIndicesChannels_bytesPerIndex(
            data: Option<&NSData>,
            primitive_type: SCNGeometryPrimitiveType,
            primitive_count: NSInteger,
            indices_channel_count: NSInteger,
            interleaved_indices_channels: bool,
            bytes_per_index: NSInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// Creates and returns a geometry element from the given Metal buffer and parameters.
        ///
        /// Parameter `buffer`: The buffer that contains element indices.
        ///
        /// Parameter `primitiveType`: The primitive type, as listed in the SCNGeometryPrimitiveType enumeration.
        ///
        /// Parameter `primitiveCount`: The number of primitives in the data.
        ///
        /// Parameter `bytesPerIndex`: The number of bytes that represent a single index value in the data.
        ///
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(geometryElementWithBuffer:primitiveType:primitiveCount:bytesPerIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometryElementWithBuffer_primitiveType_primitiveCount_bytesPerIndex(
            buffer: &ProtocolObject<dyn MTLBuffer>,
            primitive_type: SCNGeometryPrimitiveType,
            primitive_count: NSInteger,
            bytes_per_index: NSInteger,
        ) -> Retained<Self>;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// # Safety
        ///
        /// - `buffer` may need to be synchronized.
        /// - `buffer` may be unretained, you must ensure it is kept alive while in use.
        /// - `buffer` contents should be of the correct type.
        #[unsafe(method(geometryElementWithBuffer:primitiveType:primitiveCount:indicesChannelCount:interleavedIndicesChannels:bytesPerIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometryElementWithBuffer_primitiveType_primitiveCount_indicesChannelCount_interleavedIndicesChannels_bytesPerIndex(
            buffer: &ProtocolObject<dyn MTLBuffer>,
            primitive_type: SCNGeometryPrimitiveType,
            primitive_count: NSInteger,
            indices_channel_count: NSInteger,
            interleaved_indices_channels: bool,
            bytes_per_index: NSInteger,
        ) -> Retained<Self>;

        /// The data for the geometry element
        #[unsafe(method(data))]
        #[unsafe(method_family = none)]
        pub unsafe fn data(&self) -> Retained<NSData>;

        /// The type of the geometry element. Possible values are listed in the SCNGeometryPrimitiveType enumeration.
        #[unsafe(method(primitiveType))]
        #[unsafe(method_family = none)]
        pub unsafe fn primitiveType(&self) -> SCNGeometryPrimitiveType;

        /// The number of primitives in the data.
        #[unsafe(method(primitiveCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn primitiveCount(&self) -> NSInteger;

        /// Determines whether the channels are interleaved.
        #[unsafe(method(hasInterleavedIndicesChannels))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasInterleavedIndicesChannels(&self) -> bool;

        /// The number of channels in the geometry element.
        #[unsafe(method(indicesChannelCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn indicesChannelCount(&self) -> NSInteger;

        /// The number of bytes that represent an index value
        #[unsafe(method(bytesPerIndex))]
        #[unsafe(method_family = none)]
        pub unsafe fn bytesPerIndex(&self) -> NSInteger;

        /// Specifies the subrange of primitives to render within NSMakeRange(0, primitiveCount). Defaults to NSMakeRange(NSNotFound, 0).
        ///
        /// When the location of the range is set to NSNotFound, the entire geometry element is rendered.
        #[unsafe(method(primitiveRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn primitiveRange(&self) -> NSRange;

        /// Setter for [`primitiveRange`][Self::primitiveRange].
        #[unsafe(method(setPrimitiveRange:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPrimitiveRange(&self, primitive_range: NSRange);

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the size of the point in local space. Defaults to 1
        #[unsafe(method(pointSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn pointSize(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`pointSize`][Self::pointSize].
        #[unsafe(method(setPointSize:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPointSize(&self, point_size: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the minimum size in screen-space (in pixel). Defaults to 1
        #[unsafe(method(minimumPointScreenSpaceRadius))]
        #[unsafe(method_family = none)]
        pub unsafe fn minimumPointScreenSpaceRadius(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`minimumPointScreenSpaceRadius`][Self::minimumPointScreenSpaceRadius].
        #[unsafe(method(setMinimumPointScreenSpaceRadius:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinimumPointScreenSpaceRadius(
            &self,
            minimum_point_screen_space_radius: CGFloat,
        );

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the maximum size in screen-space (in pixel). Defaults to 1
        #[unsafe(method(maximumPointScreenSpaceRadius))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumPointScreenSpaceRadius(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`maximumPointScreenSpaceRadius`][Self::maximumPointScreenSpaceRadius].
        #[unsafe(method(setMaximumPointScreenSpaceRadius:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumPointScreenSpaceRadius(
            &self,
            maximum_point_screen_space_radius: CGFloat,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl SCNGeometryElement {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SCNTessellationSmoothingMode(pub NSInteger);
impl SCNTessellationSmoothingMode {
    #[doc(alias = "SCNTessellationSmoothingModeNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "SCNTessellationSmoothingModePNTriangles")]
    pub const PNTriangles: Self = Self(1);
    #[doc(alias = "SCNTessellationSmoothingModePhong")]
    pub const Phong: Self = Self(2);
}

unsafe impl Encode for SCNTessellationSmoothingMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNTessellationSmoothingMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A geometry tessellator describes how a more detailed surface is calculated from the geometry's initial surface.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SCNGeometryTessellator;
);

extern_conformance!(
    unsafe impl NSCoding for SCNGeometryTessellator {}
);

extern_conformance!(
    unsafe impl NSCopying for SCNGeometryTessellator {}
);

unsafe impl CopyingHelper for SCNGeometryTessellator {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for SCNGeometryTessellator {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for SCNGeometryTessellator {}
);

impl SCNGeometryTessellator {
    extern_methods!(
        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the scale factor applied to the per-patch tessellation factors. Defaults to 1.
        #[unsafe(method(tessellationFactorScale))]
        #[unsafe(method_family = none)]
        pub unsafe fn tessellationFactorScale(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`tessellationFactorScale`][Self::tessellationFactorScale].
        #[unsafe(method(setTessellationFactorScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTessellationFactorScale(&self, tessellation_factor_scale: CGFloat);

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// Specifies the tessellation partition mode. Defaults to MTLTessellationPartitionModeInteger.
        #[unsafe(method(tessellationPartitionMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn tessellationPartitionMode(&self) -> MTLTessellationPartitionMode;

        #[cfg(feature = "objc2-metal")]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`tessellationPartitionMode`][Self::tessellationPartitionMode].
        #[unsafe(method(setTessellationPartitionMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTessellationPartitionMode(
            &self,
            tessellation_partition_mode: MTLTessellationPartitionMode,
        );

        /// Specifies if the tessellation should be uniform or adaptive. Defaults to NO.
        #[unsafe(method(isAdaptive))]
        #[unsafe(method_family = none)]
        pub unsafe fn isAdaptive(&self) -> bool;

        /// Setter for [`isAdaptive`][Self::isAdaptive].
        #[unsafe(method(setAdaptive:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAdaptive(&self, adaptive: bool);

        /// Specifies if the level of tessellation should be adapted in screenSpace. Defaults to NO.
        #[unsafe(method(isScreenSpace))]
        #[unsafe(method_family = none)]
        pub unsafe fn isScreenSpace(&self) -> bool;

        /// Setter for [`isScreenSpace`][Self::isScreenSpace].
        #[unsafe(method(setScreenSpace:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setScreenSpace(&self, screen_space: bool);

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the edge tessellation factor. Defaults to 1.
        ///
        /// This has no effect for adaptive subdivision
        #[unsafe(method(edgeTessellationFactor))]
        #[unsafe(method_family = none)]
        pub unsafe fn edgeTessellationFactor(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`edgeTessellationFactor`][Self::edgeTessellationFactor].
        #[unsafe(method(setEdgeTessellationFactor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEdgeTessellationFactor(&self, edge_tessellation_factor: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the inside tessellation factor. Defaults to 1.
        ///
        /// This has no effect for adaptive subdivision
        #[unsafe(method(insideTessellationFactor))]
        #[unsafe(method_family = none)]
        pub unsafe fn insideTessellationFactor(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`insideTessellationFactor`][Self::insideTessellationFactor].
        #[unsafe(method(setInsideTessellationFactor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInsideTessellationFactor(&self, inside_tessellation_factor: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the maximum edge length. Defaults to 1.
        ///
        /// This has no effect for non-adaptive subdivision
        #[unsafe(method(maximumEdgeLength))]
        #[unsafe(method_family = none)]
        pub unsafe fn maximumEdgeLength(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`maximumEdgeLength`][Self::maximumEdgeLength].
        #[unsafe(method(setMaximumEdgeLength:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaximumEdgeLength(&self, maximum_edge_length: CGFloat);

        /// Defaults to SCNTessellationSmoothingModeNone.
        #[unsafe(method(smoothingMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn smoothingMode(&self) -> SCNTessellationSmoothingMode;

        /// Setter for [`smoothingMode`][Self::smoothingMode].
        #[unsafe(method(setSmoothingMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSmoothingMode(&self, smoothing_mode: SCNTessellationSmoothingMode);
    );
}

/// Methods declared on superclass `NSObject`.
impl SCNGeometryTessellator {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
