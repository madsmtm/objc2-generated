//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-core-image")]
#[cfg(not(target_os = "watchos"))]
use objc2_core_image::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// Rendering arguments
    ///
    /// These keys are used for the 'semantic' argument of -[SCNProgram setSemantic:forSymbol:options:]
    /// Transforms are SCNMatrix4 wrapped in NSValues.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnmodeltransform?language=objc)
    pub static SCNModelTransform: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnviewtransform?language=objc)
    pub static SCNViewTransform: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnprojectiontransform?language=objc)
    pub static SCNProjectionTransform: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnnormaltransform?language=objc)
    pub static SCNNormalTransform: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnmodelviewtransform?language=objc)
    pub static SCNModelViewTransform: &'static NSString;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnmodelviewprojectiontransform?language=objc)
    pub static SCNModelViewProjectionTransform: &'static NSString;
}

/// The available modes of movability.
///
/// Movable nodes are not captured when computing light probes.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnmovabilityhint?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SCNMovabilityHint(pub NSInteger);
impl SCNMovabilityHint {
    #[doc(alias = "SCNMovabilityHintFixed")]
    pub const Fixed: Self = Self(0);
    #[doc(alias = "SCNMovabilityHintMovable")]
    pub const Movable: Self = Self(1);
}

unsafe impl Encode for SCNMovabilityHint {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNMovabilityHint {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Control the focus (UIFocus) behavior.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnnodefocusbehavior?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct SCNNodeFocusBehavior(pub NSInteger);
impl SCNNodeFocusBehavior {
    #[doc(alias = "SCNNodeFocusBehaviorNone")]
    pub const None: Self = Self(0);
    #[doc(alias = "SCNNodeFocusBehaviorOccluding")]
    pub const Occluding: Self = Self(1);
    #[doc(alias = "SCNNodeFocusBehaviorFocusable")]
    pub const Focusable: Self = Self(2);
}

unsafe impl Encode for SCNNodeFocusBehavior {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNNodeFocusBehavior {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// SCNNode is the model class for node-tree objects.
    ///
    /// It encapsulates the position, rotations, and other transforms of a node, which define a coordinate system.
    /// The coordinate systems of all the sub-nodes are relative to the one of their parent node.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnnode?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SCNNode;
);

extern_conformance!(
    unsafe impl NSCoding for SCNNode {}
);

extern_conformance!(
    unsafe impl NSCopying for SCNNode {}
);

unsafe impl CopyingHelper for SCNNode {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for SCNNode {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for SCNNode {}
);

#[cfg(feature = "SCNAction")]
extern_conformance!(
    unsafe impl SCNActionable for SCNNode {}
);

#[cfg(feature = "SCNAnimation")]
extern_conformance!(
    unsafe impl SCNAnimatable for SCNNode {}
);

#[cfg(feature = "SCNBoundingVolume")]
extern_conformance!(
    unsafe impl SCNBoundingVolume for SCNNode {}
);

impl SCNNode {
    extern_methods!(
        /// Creates and initializes a node instance.
        #[unsafe(method(node))]
        #[unsafe(method_family = none)]
        pub unsafe fn node() -> Retained<Self>;

        #[cfg(feature = "SCNGeometry")]
        /// Creates and initializes a node instance with the specified geometry attached.
        ///
        /// Parameter `geometry`: The geometry to attach.
        #[unsafe(method(nodeWithGeometry:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nodeWithGeometry(geometry: Option<&SCNGeometry>) -> Retained<SCNNode>;

        /// Returns a copy of the receiver. The returned instance is autoreleased.
        ///
        /// The copy is recursive: every child node will be cloned, too. For a non-recursive copy, use copy instead.
        /// The copied nodes will share their attached objects (light, geometry, camera, ...) with the original instances;
        /// if you want, for example, to change the materials of the copy independently of the original object, you'll
        /// have to copy the geometry of the node separately.
        #[unsafe(method(clone))]
        #[unsafe(method_family = none)]
        pub unsafe fn clone(&self) -> Retained<Self>;

        #[unsafe(method(flattenedClone))]
        #[unsafe(method_family = none)]
        pub unsafe fn flattenedClone(&self) -> Retained<Self>;

        /// Determines the name of the receiver.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Option<Retained<NSString>>;

        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        #[cfg(feature = "SCNLight")]
        /// Determines the light attached to the receiver.
        #[unsafe(method(light))]
        #[unsafe(method_family = none)]
        pub unsafe fn light(&self) -> Option<Retained<SCNLight>>;

        #[cfg(feature = "SCNLight")]
        /// Setter for [`light`][Self::light].
        #[unsafe(method(setLight:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLight(&self, light: Option<&SCNLight>);

        #[cfg(feature = "SCNCamera")]
        /// Determines the camera attached to the receiver.
        #[unsafe(method(camera))]
        #[unsafe(method_family = none)]
        pub unsafe fn camera(&self) -> Option<Retained<SCNCamera>>;

        #[cfg(feature = "SCNCamera")]
        /// Setter for [`camera`][Self::camera].
        #[unsafe(method(setCamera:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCamera(&self, camera: Option<&SCNCamera>);

        #[cfg(feature = "SCNGeometry")]
        /// Returns the geometry attached to the receiver.
        #[unsafe(method(geometry))]
        #[unsafe(method_family = none)]
        pub unsafe fn geometry(&self) -> Option<Retained<SCNGeometry>>;

        #[cfg(feature = "SCNGeometry")]
        /// Setter for [`geometry`][Self::geometry].
        #[unsafe(method(setGeometry:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setGeometry(&self, geometry: Option<&SCNGeometry>);

        #[cfg(feature = "SCNSkinner")]
        /// Returns the skinner attached to the receiver.
        #[unsafe(method(skinner))]
        #[unsafe(method_family = none)]
        pub unsafe fn skinner(&self) -> Option<Retained<SCNSkinner>>;

        #[cfg(feature = "SCNSkinner")]
        /// Setter for [`skinner`][Self::skinner].
        #[unsafe(method(setSkinner:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setSkinner(&self, skinner: Option<&SCNSkinner>);

        #[cfg(feature = "SCNMorpher")]
        /// Returns the morpher attached to the receiver.
        #[unsafe(method(morpher))]
        #[unsafe(method_family = none)]
        pub unsafe fn morpher(&self) -> Option<Retained<SCNMorpher>>;

        #[cfg(feature = "SCNMorpher")]
        /// Setter for [`morpher`][Self::morpher].
        #[unsafe(method(setMorpher:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMorpher(&self, morpher: Option<&SCNMorpher>);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        /// Determines the receiver's transform. Animatable.
        ///
        /// The transform is the combination of the position, rotation and scale defined below. So when the transform is set, the receiver's position, rotation and scale are changed to match the new transform.
        #[unsafe(method(transform))]
        #[unsafe(method_family = none)]
        pub unsafe fn transform(&self) -> SCNMatrix4;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`transform`][Self::transform].
        #[unsafe(method(setTransform:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTransform(&self, transform: SCNMatrix4);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        /// Determines the receiver's transform in world space (relative to the scene's root node). Animatable.
        #[unsafe(method(worldTransform))]
        #[unsafe(method_family = none)]
        pub unsafe fn worldTransform(&self) -> SCNMatrix4;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        #[unsafe(method(setWorldTransform:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWorldTransform(&self, world_transform: SCNMatrix4);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Determines the receiver's position. Animatable.
        #[unsafe(method(position))]
        #[unsafe(method_family = none)]
        pub unsafe fn position(&self) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Setter for [`position`][Self::position].
        #[unsafe(method(setPosition:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPosition(&self, position: SCNVector3);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Determines the receiver's position in world space (relative to the scene's root node).
        #[unsafe(method(worldPosition))]
        #[unsafe(method_family = none)]
        pub unsafe fn worldPosition(&self) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Setter for [`worldPosition`][Self::worldPosition].
        #[unsafe(method(setWorldPosition:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWorldPosition(&self, world_position: SCNVector3);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Determines the receiver's rotation. Animatable.
        ///
        /// The rotation is axis angle rotation. The three first components are the axis, the fourth one is the rotation (in radian).
        #[unsafe(method(rotation))]
        #[unsafe(method_family = none)]
        pub unsafe fn rotation(&self) -> SCNVector4;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Setter for [`rotation`][Self::rotation].
        #[unsafe(method(setRotation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRotation(&self, rotation: SCNVector4);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Determines the receiver's orientation as a unit quaternion. Animatable.
        #[unsafe(method(orientation))]
        #[unsafe(method_family = none)]
        pub unsafe fn orientation(&self) -> SCNQuaternion;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Setter for [`orientation`][Self::orientation].
        #[unsafe(method(setOrientation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOrientation(&self, orientation: SCNQuaternion);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Determines the receiver's orientation in world space (relative to the scene's root node). Animatable.
        #[unsafe(method(worldOrientation))]
        #[unsafe(method_family = none)]
        pub unsafe fn worldOrientation(&self) -> SCNQuaternion;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Setter for [`worldOrientation`][Self::worldOrientation].
        #[unsafe(method(setWorldOrientation:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWorldOrientation(&self, world_orientation: SCNQuaternion);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Determines the receiver's euler angles. Animatable.
        ///
        /// The order of components in this vector matches the axes of rotation:
        /// 1. Pitch (the x component) is the rotation about the node's x-axis (in radians)
        /// 2. Yaw   (the y component) is the rotation about the node's y-axis (in radians)
        /// 3. Roll  (the z component) is the rotation about the node's z-axis (in radians)
        /// SceneKit applies these rotations in the reverse order of the components:
        /// 1. first roll
        /// 2. then yaw
        /// 3. then pitch
        #[unsafe(method(eulerAngles))]
        #[unsafe(method_family = none)]
        pub unsafe fn eulerAngles(&self) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Setter for [`eulerAngles`][Self::eulerAngles].
        #[unsafe(method(setEulerAngles:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setEulerAngles(&self, euler_angles: SCNVector3);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Determines the receiver's scale. Animatable.
        #[unsafe(method(scale))]
        #[unsafe(method_family = none)]
        pub unsafe fn scale(&self) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Setter for [`scale`][Self::scale].
        #[unsafe(method(setScale:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setScale(&self, scale: SCNVector3);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        /// Determines the receiver's pivot. Animatable.
        #[unsafe(method(pivot))]
        #[unsafe(method_family = none)]
        pub unsafe fn pivot(&self) -> SCNMatrix4;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`pivot`][Self::pivot].
        #[unsafe(method(setPivot:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPivot(&self, pivot: SCNMatrix4);

        /// Determines whether the receiver is displayed. Defaults to NO. Animatable.
        #[unsafe(method(isHidden))]
        #[unsafe(method_family = none)]
        pub unsafe fn isHidden(&self) -> bool;

        /// Setter for [`isHidden`][Self::isHidden].
        #[unsafe(method(setHidden:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setHidden(&self, hidden: bool);

        #[cfg(feature = "objc2-core-foundation")]
        /// Determines the opacity of the receiver. Default is 1. Animatable.
        #[unsafe(method(opacity))]
        #[unsafe(method_family = none)]
        pub unsafe fn opacity(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`opacity`][Self::opacity].
        #[unsafe(method(setOpacity:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setOpacity(&self, opacity: CGFloat);

        /// Determines the rendering order of the receiver.
        ///
        /// Nodes with greater rendering orders are rendered last. Defaults to 0.
        #[unsafe(method(renderingOrder))]
        #[unsafe(method_family = none)]
        pub unsafe fn renderingOrder(&self) -> NSInteger;

        /// Setter for [`renderingOrder`][Self::renderingOrder].
        #[unsafe(method(setRenderingOrder:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRenderingOrder(&self, rendering_order: NSInteger);

        /// Determines if the node is rendered in shadow maps. Defaults to YES.
        #[unsafe(method(castsShadow))]
        #[unsafe(method_family = none)]
        pub unsafe fn castsShadow(&self) -> bool;

        /// Setter for [`castsShadow`][Self::castsShadow].
        #[unsafe(method(setCastsShadow:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCastsShadow(&self, casts_shadow: bool);

        /// Communicates to SceneKit’s rendering system about how you want to move content in your scene; it does not affect your ability to change the node’s position or add animations or physics to the node. Defaults to SCNMovabilityHintFixed.
        #[unsafe(method(movabilityHint))]
        #[unsafe(method_family = none)]
        pub unsafe fn movabilityHint(&self) -> SCNMovabilityHint;

        /// Setter for [`movabilityHint`][Self::movabilityHint].
        #[unsafe(method(setMovabilityHint:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMovabilityHint(&self, movability_hint: SCNMovabilityHint);

        /// Returns the parent node of the receiver.
        #[unsafe(method(parentNode))]
        #[unsafe(method_family = none)]
        pub unsafe fn parentNode(&self) -> Option<Retained<SCNNode>>;

        /// Returns the child node array of the receiver.
        #[unsafe(method(childNodes))]
        #[unsafe(method_family = none)]
        pub unsafe fn childNodes(&self) -> Retained<NSArray<SCNNode>>;

        /// Appends the node to the receiver’s childNodes array.
        ///
        /// Parameter `child`: The node to be added to the receiver’s childNodes array.
        #[unsafe(method(addChildNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addChildNode(&self, child: &SCNNode);

        /// Insert a node in the childNodes array at the specified index.
        ///
        /// Parameter `child`: The node to insert.
        ///
        /// Parameter `index`: Index in the childNodes array to insert the node.
        #[unsafe(method(insertChildNode:atIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn insertChildNode_atIndex(&self, child: &SCNNode, index: NSUInteger);

        /// Removes the node from the childNodes array of the receiver’s parentNode.
        #[unsafe(method(removeFromParentNode))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeFromParentNode(&self);

        /// Remove `child' from the childNode array of the receiver and insert 'child2' if non-nil in its position.
        ///
        /// If the parentNode of `child' is not the receiver, the behavior is undefined.
        ///
        /// Parameter `oldChild`: The node to replace in the childNodes array.
        ///
        /// Parameter `newChild`: The new node that will replace the previous one.
        #[unsafe(method(replaceChildNode:with:))]
        #[unsafe(method_family = none)]
        pub unsafe fn replaceChildNode_with(&self, old_child: &SCNNode, new_child: &SCNNode);

        /// Returns the first node found in the node tree with the specified name.
        ///
        /// The search uses a pre-order tree traversal.
        ///
        /// Parameter `name`: The name of the node you are searching for.
        ///
        /// Parameter `recursively`: Set to YES if you want the search to look through the sub-nodes recursively.
        #[unsafe(method(childNodeWithName:recursively:))]
        #[unsafe(method_family = none)]
        pub unsafe fn childNodeWithName_recursively(
            &self,
            name: &NSString,
            recursively: bool,
        ) -> Option<Retained<SCNNode>>;

        #[cfg(feature = "block2")]
        /// Returns the child nodes of the receiver that passes a test in a given Block.
        ///
        /// The search is recursive and uses a pre-order tree traversal.
        ///
        /// Parameter `predicate`: The block to apply to child nodes of the receiver. The block takes two arguments: "child" is a child node and "stop" is a reference to a Boolean value. The block can set the value to YES to stop further processing of the node hierarchy. The stop argument is an out-only argument. You should only ever set this Boolean to YES within the Block. The Block returns a Boolean value that indicates whether "child" passed the test.
        #[unsafe(method(childNodesPassingTest:))]
        #[unsafe(method_family = none)]
        pub unsafe fn childNodesPassingTest(
            &self,
            predicate: &block2::DynBlock<dyn Fn(NonNull<SCNNode>, NonNull<Bool>) -> Bool + '_>,
        ) -> Retained<NSArray<SCNNode>>;

        #[cfg(feature = "block2")]
        /// Executes a given block on each child node under the receiver.
        ///
        /// The search is recursive and uses a pre-order tree traversal.
        ///
        /// Parameter `block`: The block to apply to child nodes of the receiver. The block takes two arguments: "child" is a child node and "stop" is a reference to a Boolean value. The block can set the value to YES to stop further processing of the node hierarchy. The stop argument is an out-only argument. You should only ever set this Boolean to YES within the Block.
        #[unsafe(method(enumerateChildNodesUsingBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enumerateChildNodesUsingBlock(
            &self,
            block: &block2::DynBlock<dyn Fn(NonNull<SCNNode>, NonNull<Bool>) + '_>,
        );

        #[cfg(feature = "block2")]
        /// Executes a given block on the receiver and its child nodes.
        ///
        /// The search is recursive and uses a pre-order tree traversal.
        ///
        /// Parameter `block`: The block to apply to the receiver and its child nodes. The block takes two arguments: "node" is a node in the hierarchy of the receiver (including the receiver) and "stop" is a reference to a Boolean value. The block can set the value to YES to stop further processing of the node hierarchy. The stop argument is an out-only argument. You should only ever set this Boolean to YES within the Block.
        #[unsafe(method(enumerateHierarchyUsingBlock:))]
        #[unsafe(method_family = none)]
        pub unsafe fn enumerateHierarchyUsingBlock(
            &self,
            block: &block2::DynBlock<dyn Fn(NonNull<SCNNode>, NonNull<Bool>) + '_>,
        );

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Converts a position from the receiver’s coordinate system to that of the specified node.
        ///
        /// Parameter `position`: A position specified in the local coordinate system of the receiver.
        ///
        /// Parameter `node`: The node into whose coordinate system "position" is to be converted. If "node" is nil, this method instead converts to world coordinates.
        #[unsafe(method(convertPosition:toNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn convertPosition_toNode(
            &self,
            position: SCNVector3,
            node: Option<&SCNNode>,
        ) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Converts a position from the coordinate system of a given node to that of the receiver.
        ///
        /// Parameter `position`: A position specified in the local coordinate system of "node".
        ///
        /// Parameter `node`: The node from whose coordinate system "position" is to be converted. If "node" is nil, this method instead converts from world coordinates.
        #[unsafe(method(convertPosition:fromNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn convertPosition_fromNode(
            &self,
            position: SCNVector3,
            node: Option<&SCNNode>,
        ) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Converts a vector from the coordinate system of a given node to that of the receiver.
        ///
        ///
        /// Parameter `vector`: A vector specified in the local coordinate system the receiver.
        ///
        /// Parameter `node`: The node defining the space from which the vector should be transformed. If "node" is nil, this method instead converts from world coordinates.
        ///
        ///
        /// Returns: vector transformed from receiver local space to node local space.
        #[unsafe(method(convertVector:toNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn convertVector_toNode(
            &self,
            vector: SCNVector3,
            node: Option<&SCNNode>,
        ) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Converts a vector from the coordinate system of a given node to that of the receiver.
        ///
        ///
        /// Parameter `vector`: A vector specified in the local coordinate system of "node".
        ///
        /// Parameter `node`: The node defining the space to which the vector should be transformed to. If "node" is nil, this method instead converts from world coordinates.
        ///
        ///
        /// Returns: vector transformed from node space to reveiver local space.
        #[unsafe(method(convertVector:fromNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn convertVector_fromNode(
            &self,
            vector: SCNVector3,
            node: Option<&SCNNode>,
        ) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        /// Converts a transform from the receiver’s coordinate system to that of the specified node.
        ///
        /// Parameter `transform`: A transform specified in the local coordinate system of the receiver.
        ///
        /// Parameter `node`: The node into whose coordinate system "transform" is to be converted. If "node" is nil, this method instead converts to world coordinates.
        #[unsafe(method(convertTransform:toNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn convertTransform_toNode(
            &self,
            transform: SCNMatrix4,
            node: Option<&SCNNode>,
        ) -> SCNMatrix4;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-quartz-core"))]
        #[cfg(not(target_os = "watchos"))]
        /// Converts a transform from the coordinate system of a given node to that of the receiver.
        ///
        /// Parameter `transform`: A transform specified in the local coordinate system of "node".
        ///
        /// Parameter `node`: The node from whose coordinate system "transform" is to be converted. If "node" is nil, this method instead converts from world coordinates.
        #[unsafe(method(convertTransform:fromNode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn convertTransform_fromNode(
            &self,
            transform: SCNMatrix4,
            node: Option<&SCNNode>,
        ) -> SCNMatrix4;

        #[cfg(feature = "SCNPhysicsBody")]
        /// The description of the physics body of the receiver.
        ///
        /// Default is nil.
        #[unsafe(method(physicsBody))]
        #[unsafe(method_family = none)]
        pub unsafe fn physicsBody(&self) -> Option<Retained<SCNPhysicsBody>>;

        #[cfg(feature = "SCNPhysicsBody")]
        /// Setter for [`physicsBody`][Self::physicsBody].
        #[unsafe(method(setPhysicsBody:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPhysicsBody(&self, physics_body: Option<&SCNPhysicsBody>);

        #[cfg(feature = "SCNPhysicsField")]
        /// The description of the physics field of the receiver.
        ///
        /// Default is nil.
        #[unsafe(method(physicsField))]
        #[unsafe(method_family = none)]
        pub unsafe fn physicsField(&self) -> Option<Retained<SCNPhysicsField>>;

        #[cfg(feature = "SCNPhysicsField")]
        /// Setter for [`physicsField`][Self::physicsField].
        #[unsafe(method(setPhysicsField:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPhysicsField(&self, physics_field: Option<&SCNPhysicsField>);

        #[cfg(feature = "SCNConstraint")]
        /// An array of SCNConstraint that are applied to the receiver.
        ///
        /// Adding or removing a constraint can be implicitly animated based on the current transaction.
        #[unsafe(method(constraints))]
        #[unsafe(method_family = none)]
        pub unsafe fn constraints(&self) -> Option<Retained<NSArray<SCNConstraint>>>;

        #[cfg(feature = "SCNConstraint")]
        /// Setter for [`constraints`][Self::constraints].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setConstraints:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setConstraints(&self, constraints: Option<&NSArray<SCNConstraint>>);

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        /// An array of Core Image filters that are applied to the rendering of the receiver and its child nodes. Animatable.
        ///
        /// Defaults to nil. Filter properties should be modified by calling setValue:forKeyPath: on each node that the filter is attached to. If the inputs of the filter are modified directly after the filter is attached to a node, the behavior is undefined.
        #[unsafe(method(filters))]
        #[unsafe(method_family = none)]
        pub unsafe fn filters(&self) -> Option<Retained<NSArray<CIFilter>>>;

        #[cfg(feature = "objc2-core-image")]
        #[cfg(not(target_os = "watchos"))]
        /// Setter for [`filters`][Self::filters].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setFilters:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFilters(&self, filters: Option<&NSArray<CIFilter>>);

        /// Returns the presentation node.
        ///
        /// Returns a copy of the node containing all the properties as they were at the start of the current transaction, with any active animations applied.
        /// This gives a close approximation to the version of the node that is currently displayed.
        /// The effect of attempting to modify the returned node in any way is undefined. The returned node has no parent and no child nodes.
        #[unsafe(method(presentationNode))]
        #[unsafe(method_family = none)]
        pub unsafe fn presentationNode(&self) -> Retained<SCNNode>;

        /// Controls whether or not the node's actions and animations are updated or paused. Defaults to NO.
        #[unsafe(method(isPaused))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPaused(&self) -> bool;

        /// Setter for [`isPaused`][Self::isPaused].
        #[unsafe(method(setPaused:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPaused(&self, paused: bool);

        /// Specifies the receiver's renderer delegate object.
        ///
        /// Setting a renderer delegate prevents the SceneKit renderer from drawing the node and lets you use custom OpenGL code instead.
        /// The preferred way to customize the rendering is to tweak the material properties of the different materials of the node's geometry. SCNMaterial conforms to the SCNShadable protocol and allows for more advanced rendering using GLSL.
        /// You would typically use a renderer delegate with a node that has no geometry and only serves as a location in space. An example would be attaching a particle system to that node and render it with custom OpenGL code.
        ///
        /// # Safety
        ///
        /// This is not retained internally, you must ensure the object is still alive.
        #[unsafe(method(rendererDelegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn rendererDelegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn SCNNodeRendererDelegate>>>;

        /// Setter for [`rendererDelegate`][Self::rendererDelegate].
        ///
        /// # Safety
        ///
        /// This is unretained, you must ensure the object is kept alive while in use.
        #[unsafe(method(setRendererDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRendererDelegate(
            &self,
            renderer_delegate: Option<&ProtocolObject<dyn SCNNodeRendererDelegate>>,
        );

        #[cfg(all(
            feature = "SCNHitTest",
            feature = "SceneKitTypes",
            feature = "objc2-core-foundation"
        ))]
        /// Returns an array of SCNHitTestResult for each node in the receiver's sub tree that intersects the specified segment.
        ///
        /// Parameter `pointA`: The first point of the segment relative to the receiver.
        ///
        /// Parameter `pointB`: The second point of the segment relative to the receiver.
        ///
        /// Parameter `options`: Optional parameters (see the "Hit test options" section in SCNSceneRenderer.h for the available options).
        ///
        /// See SCNSceneRenderer.h for a screen-space hit testing method.
        ///
        /// # Safety
        ///
        /// `options` generic should be of the correct type.
        #[unsafe(method(hitTestWithSegmentFromPoint:toPoint:options:))]
        #[unsafe(method_family = none)]
        pub unsafe fn hitTestWithSegmentFromPoint_toPoint_options(
            &self,
            point_a: SCNVector3,
            point_b: SCNVector3,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<NSArray<SCNHitTestResult>>;

        /// Defines what logical 'categories' the receiver belongs too. Defaults to 1.
        ///
        /// Categories can be used to
        /// 1. exclude nodes from the influence of a given light (see SCNLight.categoryBitMask)
        /// 2. include/exclude nodes from render passes (see SCNTechnique.h)
        /// 3. specify which nodes to use when hit-testing (see SCNHitTestOptionCategoryBitMask)
        #[unsafe(method(categoryBitMask))]
        #[unsafe(method_family = none)]
        pub unsafe fn categoryBitMask(&self) -> NSUInteger;

        /// Setter for [`categoryBitMask`][Self::categoryBitMask].
        #[unsafe(method(setCategoryBitMask:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCategoryBitMask(&self, category_bit_mask: NSUInteger);
    );
}

/// Methods declared on superclass `NSObject`.
impl SCNNode {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// Transforms.
impl SCNNode {
    extern_methods!(
        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// The local unit Y axis (0, 1, 0).
        #[unsafe(method(localUp))]
        #[unsafe(method_family = none)]
        pub unsafe fn localUp() -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// The local unit X axis (1, 0, 0).
        #[unsafe(method(localRight))]
        #[unsafe(method_family = none)]
        pub unsafe fn localRight() -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// The local unit -Z axis (0, 0, -1).
        #[unsafe(method(localFront))]
        #[unsafe(method_family = none)]
        pub unsafe fn localFront() -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// The local unit Y axis (0, 1, 0) in world space.
        #[unsafe(method(worldUp))]
        #[unsafe(method_family = none)]
        pub unsafe fn worldUp(&self) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// The local unit X axis (1, 0, 0) in world space.
        #[unsafe(method(worldRight))]
        #[unsafe(method_family = none)]
        pub unsafe fn worldRight(&self) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// The local unit -Z axis (0, 0, -1) in world space.
        #[unsafe(method(worldFront))]
        #[unsafe(method_family = none)]
        pub unsafe fn worldFront(&self) -> SCNVector3;

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Convenience for calling lookAt:up:localFront: with worldUp set to `self.worldUp`
        /// and localFront [SCNNode localFront].
        ///
        /// Parameter `worldTarget`: target position in world space.
        #[unsafe(method(lookAt:))]
        #[unsafe(method_family = none)]
        pub unsafe fn lookAt(&self, world_target: SCNVector3);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Set the orientation of the node so its front vector is pointing toward a given
        /// target. Using a reference up vector in world space and a front vector in
        /// local space.
        ///
        ///
        /// Parameter `worldTarget`: position in world space.
        ///
        /// Parameter `worldUp`: the up vector in world space.
        ///
        /// Parameter `localFront`: the front vector in local space.
        #[unsafe(method(lookAt:up:localFront:))]
        #[unsafe(method_family = none)]
        pub unsafe fn lookAt_up_localFront(
            &self,
            world_target: SCNVector3,
            world_up: SCNVector3,
            local_front: SCNVector3,
        );

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Translate the current node position along the given vector in local space.
        ///
        ///
        /// Parameter `translation`: the translation in local space.
        #[unsafe(method(localTranslateBy:))]
        #[unsafe(method_family = none)]
        pub unsafe fn localTranslateBy(&self, translation: SCNVector3);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Apply a the given rotation to the current one.
        ///
        ///
        /// Parameter `rotation`: rotation in local space.
        #[unsafe(method(localRotateBy:))]
        #[unsafe(method_family = none)]
        pub unsafe fn localRotateBy(&self, rotation: SCNQuaternion);

        #[cfg(all(feature = "SceneKitTypes", feature = "objc2-core-foundation"))]
        /// Apply a rotation relative to a target point in parent space.
        ///
        ///
        /// Parameter `worldRotation`: rotation to apply in world space.
        ///
        /// Parameter `worldTarget`: position of the target in world space.
        #[unsafe(method(rotateBy:aroundTarget:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rotateBy_aroundTarget(
            &self,
            world_rotation: SCNQuaternion,
            world_target: SCNVector3,
        );
    );
}

extern_protocol!(
    /// The SCNNodeRendererDelegate protocol declares the methods that an instance of SCNNode invokes to let a delegate customize its rendering.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/scenekit/scnnoderendererdelegate?language=objc)
    pub unsafe trait SCNNodeRendererDelegate: NSObjectProtocol {
        #[cfg(feature = "SCNRenderer")]
        /// Invoked when a node is rendered.
        ///
        /// The preferred way to customize the rendering is to tweak the material properties of the different materials of the node's geometry. SCNMaterial conforms to the SCNShadable protocol and allows for more advanced rendering using GLSL.
        /// You would typically use a renderer delegate with a node that has no geometry and only serves as a location in space. An example would be attaching a particle system to that node and render it with custom OpenGL code.
        /// Only drawing calls and the means to achieve them are supposed to be performed during the renderer delegate callback, any changes in the model (nodes, geometry...) would involve unexpected results.
        ///
        /// Parameter `node`: The node to render.
        ///
        /// Parameter `renderer`: The scene renderer to render into.
        ///
        /// Parameter `arguments`: A dictionary whose values are SCNMatrix4 matrices wrapped in NSValue objects.
        ///
        /// # Safety
        ///
        /// `arguments` generic should be of the correct type.
        #[optional]
        #[unsafe(method(renderNode:renderer:arguments:))]
        #[unsafe(method_family = none)]
        unsafe fn renderNode_renderer_arguments(
            &self,
            node: &SCNNode,
            renderer: &SCNRenderer,
            arguments: &NSDictionary<NSString, AnyObject>,
        );
    }
);

/// SIMD.
impl SCNNode {
    extern_methods!();
}

/// Focus.
impl SCNNode {
    extern_methods!(
        /// Controls the behavior of the receiver regarding the UIFocus system. Defaults to SCNNodeFocusBehaviorNone.
        #[unsafe(method(focusBehavior))]
        #[unsafe(method_family = none)]
        pub unsafe fn focusBehavior(&self) -> SCNNodeFocusBehavior;

        /// Setter for [`focusBehavior`][Self::focusBehavior].
        #[unsafe(method(setFocusBehavior:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFocusBehavior(&self, focus_behavior: SCNNodeFocusBehavior);
    );
}
