//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
use objc2_foundation::*;

use crate::*;

/// Constants specifying the lighting and shading algorithm to use for rendering a material.
///
/// ## Discussion
///
///
/// ![](https://docs-assets.developer.apple.com/published/a1b3893bc30880a4d37b9f6536e168ee/media-2929794%402x.png)
///
///
///
// NS_TYPED_ENUM
pub type SCNLightingModel = NSString;

extern "C" {
    /// Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Phong  formula.
    ///
    /// ## Discussion
    ///
    /// The Phong approximation of real-world reflectance calculates the color of a point on a surface using the following formula:
    ///
    /// ```objc
    /// color = ambient * al + diffuse * max(0, dot(N, L)) + specular * pow(max(0, dot(R, E)), shininess)
    /// ```
    ///
    /// Some terms refer to the material’s properties: [`ambient`](https://developer.apple.com/documentation/scenekit/scnmaterial/ambient), [`diffuse`](https://developer.apple.com/documentation/scenekit/scnmaterial/diffuse), [`specular`](https://developer.apple.com/documentation/scenekit/scnmaterial/specular), and [`shininess`](https://developer.apple.com/documentation/scenekit/scnmaterial/shininess). The other terms are as follows:
    ///
    /// - `al`: The sum of all ambient lights in the scene (a color).
    ///
    /// - `N`: The surface normal vector at the point being shaded, as supplied by the geometry’s vertex data, interpolated between vertices, and possibly modified by the material’s [`normal`](https://developer.apple.com/documentation/scenekit/scnmaterial/normal) property.
    ///
    /// - `L`: The (normalized) vector from the point being shaded to the light source.
    ///
    /// - `E`: The (normalized) vector from the point being shaded to the viewer.
    ///
    /// - `R`: The reflection of the light vector `L` across the normal vector `N`.
    ///
    ///
    pub static SCNLightingModelPhong: &'static SCNLightingModel;
}

extern "C" {
    /// Shading that incorporates ambient, diffuse, and specular properties, where specular highlights are calculated using the Blinn-Phong  formula.
    ///
    /// ## Discussion
    ///
    /// The Blinn-Phong approximation of real-world reflectance calculates the color of a point on a surface using the following formula:
    ///
    /// ```objc
    /// color = ambient * al + diffuse * max(0, dot(N, L)) + specular * pow(max(0, dot(H, N)), shininess)
    /// ```
    ///
    /// Some terms refer to the material’s properties: [`ambient`](https://developer.apple.com/documentation/scenekit/scnmaterial/ambient), [`diffuse`](https://developer.apple.com/documentation/scenekit/scnmaterial/diffuse), [`specular`](https://developer.apple.com/documentation/scenekit/scnmaterial/specular), and [`shininess`](https://developer.apple.com/documentation/scenekit/scnmaterial/shininess). The other terms are as follows:
    ///
    /// - `al`: The sum of all ambient lights in the scene (a color).
    ///
    /// - `N`: The surface normal vector at the point being shaded, as supplied by the geometry’s vertex data, interpolated between vertices, and possibly modified by the material’s [`normal`](https://developer.apple.com/documentation/scenekit/scnmaterial/normal) property.
    ///
    /// - `L`: The (normalized) vector from the point being shaded to the light source.
    ///
    /// - `H`: A vector halfway between the light vector `L` and the (normalized) eye vector `E` (the vector from the point being shaded to the viewer), calculated using the formula `H = normalize(L + E)`.
    ///
    ///
    pub static SCNLightingModelBlinn: &'static SCNLightingModel;
}

extern "C" {
    /// Shading that incorporates ambient and diffuse properties only.
    ///
    /// ## Discussion
    ///
    /// This shading model is based on Lambert’s Law of diffuse reflectance, calculating the color of a point on a surface with the following formula:
    ///
    /// ```objc
    /// color = ambient * al + diffuse * max(0, dot(N, L))
    /// ```
    ///
    /// The [`ambient`](https://developer.apple.com/documentation/scenekit/scnmaterial/ambient) and [`diffuse`](https://developer.apple.com/documentation/scenekit/scnmaterial/diffuse) terms refer to the material’s properties. The other terms are as follows:
    ///
    /// - `al`: The sum of all ambient lights in the scene (a color).
    ///
    /// - `N`: The surface normal vector at the point being shaded, as supplied by the geometry’s vertex data, interpolated between vertices, and possibly modified by the material’s [`normal`](https://developer.apple.com/documentation/scenekit/scnmaterial/normal) property.
    ///
    /// - `L`: The (normalized) vector from the point being shaded to the light source.
    ///
    ///
    pub static SCNLightingModelLambert: &'static SCNLightingModel;
}

extern "C" {
    /// Uniform shading that incorporates ambient lighting only.
    ///
    /// ## Discussion
    ///
    /// This shading model calculates the color of a point on a surface with the following formula:
    ///
    /// ```objc
    /// color = ambient * al + diffuse
    /// ```
    ///
    /// The [`ambient`](https://developer.apple.com/documentation/scenekit/scnmaterial/ambient) and [`diffuse`](https://developer.apple.com/documentation/scenekit/scnmaterial/diffuse) terms refer to the material’s properties. The `al` term is the sum of all ambient lights in the scene (a color).
    ///
    ///
    pub static SCNLightingModelConstant: &'static SCNLightingModel;
}

extern "C" {
    /// Shading based on a realistic abstraction of physical lights and materials.
    ///
    /// ## Discussion
    ///
    /// Physically-based shading incorporates a refined model of the interactions between real-world lights and materials. Using modern GPU hardware and algorithms, this model can produce more realistic results than the loose abstractions of traditional shading, while also offering a set of material properties that is easier for artists to work with. Especially when combined with environmental lighting (see the [`SCNScene`](https://developer.apple.com/documentation/scenekit/scnscene) [`lightingEnvironment`](https://developer.apple.com/documentation/scenekit/scnscene/lightingenvironment) property) and high dynamic range cameras (see the [`SCNCamera`](https://developer.apple.com/documentation/scenekit/scncamera) [`wantsHDR`](https://developer.apple.com/documentation/scenekit/scncamera/wantshdr) property), physically-based shading can produce realistic results similar to those seen in recent animated feature films.
    ///
    /// Physically based shading relies primarily on three material properties:
    ///
    /// - The [`diffuse`](https://developer.apple.com/documentation/scenekit/scnmaterial/diffuse) property (called albedo in some authoring tools) provides the “base” color of a material.
    ///
    /// - The [`roughness`](https://developer.apple.com/documentation/scenekit/scnmaterial/roughness) property (inverted and called smoothness in some authoring tools) is an approximation of the microscopic detail in a real-world surface. By approximating these “microfacets” as a single term, this property helps produce lighting calculations that resemble the energy-conserving laws of real-world physics, resulting in more realistic variation between matte and shiny surfaces.
    ///
    /// - The [`metalness`](https://developer.apple.com/documentation/scenekit/scnmaterial/metalness) property approximates other aspects of a physical surface, such as index of refraction, tendency to produce sharp reflections, and tendency to produce Fresnel reflections at grazing angles, which together produce an overall metallic or nonmetallic (also called dielectric) appearance.
    ///
    /// In addition, you can add surface detail to a physically based material with the [`normal`](https://developer.apple.com/documentation/scenekit/scnmaterial/normal) and [`ambientOcclusion`](https://developer.apple.com/documentation/scenekit/scnmaterial/ambientocclusion) properties, and modulate the contribution of environmental lighting with the [`selfIllumination`](https://developer.apple.com/documentation/scenekit/scnmaterial/selfillumination) property.
    ///
    /// Physically based materials ignore the [`ambient`](https://developer.apple.com/documentation/scenekit/scnmaterial/ambient), [`specular`](https://developer.apple.com/documentation/scenekit/scnmaterial/specular), and [`reflective`](https://developer.apple.com/documentation/scenekit/scnmaterial/reflective) material properties and the [`shininess`](https://developer.apple.com/documentation/scenekit/scnmaterial/shininess), [`fresnelExponent`](https://developer.apple.com/documentation/scenekit/scnmaterial/fresnelexponent), and [`locksAmbientWithDiffuse`](https://developer.apple.com/documentation/scenekit/scnmaterial/locksambientwithdiffuse) parameters.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Physically based rendering requires a Metal renderer. When displaying a material in a view whose [`renderingAPI`](https://developer.apple.com/documentation/scenekit/scnscenerenderer/renderingapi) value is not [`SCNRenderingAPIMetal`](https://developer.apple.com/documentation/scenekit/scnrenderingapi/metal), SceneKit falls back to rendering that material with the [`SCNLightingModelBlinn`](https://developer.apple.com/documentation/scenekit/scnmaterial/lightingmodel-swift.struct/blinn) lighting model. (Metal rendering is not supported in Simulator or Xcode Playgrounds when targeting iOS or tvOS, and is not available at all in watchOS, so this fallback always occurs in those environments.)
    ///
    ///
    ///
    /// </div>
    ///
    pub static SCNLightingModelPhysicallyBased: &'static SCNLightingModel;
}

extern "C" {
    pub static SCNLightingModelShadowOnly: &'static SCNLightingModel;
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SCNFillMode(pub NSUInteger);
impl SCNFillMode {
    #[doc(alias = "SCNFillModeFill")]
    pub const Fill: Self = Self(0);
    #[doc(alias = "SCNFillModeLines")]
    pub const Lines: Self = Self(1);
}

unsafe impl Encode for SCNFillMode {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for SCNFillMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The modes SceneKit uses to determine which polygons to render in a surface, used by the [`cullMode`](https://developer.apple.com/documentation/scenekit/scnmaterial/cullmode) property.
///
/// ## Overview
///
/// The vertex data and normal vectors in a geometry designate which side of each polygon is to be considered its front face, and the geometry’s orientation with respect to the camera determines which front surfaces are currently visible. Typically, back-facing surfaces are found only on the interior of a closed geometry, obscured by front-facing surfaces, so rendering these surfaces has a performance cost but no visible effect.
///
///
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SCNCullMode(pub NSInteger);
impl SCNCullMode {
    #[doc(alias = "SCNCullModeBack")]
    pub const Back: Self = Self(0);
    #[doc(alias = "SCNCullModeFront")]
    pub const Front: Self = Self(1);
}

unsafe impl Encode for SCNCullMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNCullMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The modes SceneKit uses to calculate the opacity of pixels rendered with a material, used by the [`transparencyMode`](https://developer.apple.com/documentation/scenekit/scnmaterial/transparencymode) property.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SCNTransparencyMode(pub NSInteger);
impl SCNTransparencyMode {
    /// SceneKit derives transparency information from the alpha channel of colors. The value `1.0` is opaque.
    #[doc(alias = "SCNTransparencyModeAOne")]
    pub const AOne: Self = Self(0);
    /// SceneKit derives transparency information from the luminance of colors. The value `0.0` is opaque.
    ///
    /// ## Discussion
    ///
    /// When using this mode, SceneKit ignores the alpha value of colors in the material’s [`transparent`](https://developer.apple.com/documentation/scenekit/scnmaterial/transparent) property. SceneKit calculates the luminance of a color from its red, green, and blue channels and uses the resulting value to determine the material’s opacity.
    ///
    ///
    #[doc(alias = "SCNTransparencyModeRGBZero")]
    pub const RGBZero: Self = Self(1);
    #[doc(alias = "SCNTransparencyModeSingleLayer")]
    pub const SingleLayer: Self = Self(2);
    #[doc(alias = "SCNTransparencyModeDualLayer")]
    pub const DualLayer: Self = Self(3);
    #[doc(alias = "SCNTransparencyModeDefault")]
    pub const Default: Self = Self(SCNTransparencyMode::AOne.0);
}

unsafe impl Encode for SCNTransparencyMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNTransparencyMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Modes that describe how SceneKit blends source colors rendered using a material with destination colors already in a rendering target, used by the [`blendMode`](https://developer.apple.com/documentation/scenekit/scnmaterial/blendmode) property.
/// Blend modes that SCNMaterial uses to compose with the framebuffer to produce blended colors.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct SCNBlendMode(pub NSInteger);
impl SCNBlendMode {
    /// Blend by multiplying source and destination color values by their corresponding alpha values.
    ///
    /// ## Discussion
    ///
    /// This mode is the default value of the [`blendMode`](https://developer.apple.com/documentation/scenekit/scnmaterial/blendmode) property.
    ///
    ///
    #[doc(alias = "SCNBlendModeAlpha")]
    pub const Alpha: Self = Self(0);
    /// Blend by adding the source color to the destination color.
    ///
    /// ## Discussion
    ///
    /// This mode results in a brightening effect that can be useful for making objects appear to glow relative to their surroundings.
    ///
    ///
    #[doc(alias = "SCNBlendModeAdd")]
    pub const Add: Self = Self(1);
    /// Blend by subtracting the source color from the destination color.
    #[doc(alias = "SCNBlendModeSubtract")]
    pub const Subtract: Self = Self(2);
    /// Blend by multiplying the source color with the background color.
    ///
    /// ## Discussion
    ///
    /// This mode results in colors that are at least as dark as either of the two contributing colors.
    ///
    ///
    #[doc(alias = "SCNBlendModeMultiply")]
    pub const Multiply: Self = Self(3);
    /// Blend by multiplying the inverse of the source color with the inverse of the destination color.
    ///
    /// ## Discussion
    ///
    /// This mode results in colors that are at least as light as either of the two contributing colors.
    ///
    ///
    #[doc(alias = "SCNBlendModeScreen")]
    pub const Screen: Self = Self(4);
    /// Blend by replacing the destination color with the source color, ignoring alpha.
    #[doc(alias = "SCNBlendModeReplace")]
    pub const Replace: Self = Self(5);
    #[doc(alias = "SCNBlendModeMax")]
    pub const Max: Self = Self(6);
}

unsafe impl Encode for SCNBlendMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for SCNBlendMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A set of shading attributes that define the appearance of a geometry’s surface when rendered.
    ///
    /// ## Overview
    ///
    /// When you create a material, you define a collection of visual attributes and their options, which you can then reuse for multiple geometries in a scene.
    ///
    /// A material has several visual properties, each of which defines a different part of SceneKit’s lighting and shading process. Each visual property is an instance of the [`SCNMaterialProperty`](https://developer.apple.com/documentation/scenekit/scnmaterialproperty) class that provides a solid color, texture, or other 2D content for that aspect of SceneKit’s rendering. The material’s [`lightingModelName`](https://developer.apple.com/documentation/scenekit/scnmaterial/lightingmodel-swift.property) property then determines the formula SceneKit uses to combine the visual properties with the lights in the scene to produce the final color for each pixel in the rendered scene. For more details on the rendering process, see [`SCNLightingModel`](https://developer.apple.com/documentation/scenekit/scnmaterial/lightingmodel-swift.struct).
    ///
    /// You attach one or more materials to an instance of the [`SCNGeometry`](https://developer.apple.com/documentation/scenekit/scngeometry) class using its [`firstMaterial`](https://developer.apple.com/documentation/scenekit/scngeometry/firstmaterial) or [`materials`](https://developer.apple.com/documentation/scenekit/scngeometry/materials) property. Multiple geometries can reference the same material. In this case, changing the attributes of the material changes the appearance of every geometry that uses it.
    ///
    ///
    /// A SCNMaterial determines how a geometry is rendered. It encapsulates the colors and textures that define the appearance of 3d geometries.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct SCNMaterial;
);

extern_conformance!(
    unsafe impl NSCoding for SCNMaterial {}
);

extern_conformance!(
    unsafe impl NSCopying for SCNMaterial {}
);

unsafe impl CopyingHelper for SCNMaterial {
    type Result = Self;
}

extern_conformance!(
    unsafe impl NSObjectProtocol for SCNMaterial {}
);

extern_conformance!(
    unsafe impl NSSecureCoding for SCNMaterial {}
);

#[cfg(feature = "SCNAnimation")]
extern_conformance!(
    unsafe impl SCNAnimatable for SCNMaterial {}
);

#[cfg(feature = "SCNShadable")]
extern_conformance!(
    unsafe impl SCNShadable for SCNMaterial {}
);

impl SCNMaterial {
    extern_methods!(
        /// Creates and initialize a material instance.
        #[unsafe(method(material))]
        #[unsafe(method_family = none)]
        pub unsafe fn material() -> Retained<Self>;

        /// Determines the name of the receiver.
        #[unsafe(method(name))]
        #[unsafe(method_family = none)]
        pub unsafe fn name(&self) -> Option<Retained<NSString>>;

        /// Setter for [`name`][Self::name].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setName(&self, name: Option<&NSString>);

        #[cfg(feature = "SCNMaterialProperty")]
        /// Specifies the receiver's diffuse property.
        ///
        /// The diffuse property specifies the amount of light diffusely reflected from the surface. The diffuse light is reflected equally in all directions and is therefore independent of the point of view.
        #[unsafe(method(diffuse))]
        #[unsafe(method_family = none)]
        pub unsafe fn diffuse(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// Specifies the receiver's ambient property.
        ///
        /// The ambient property specifies the amount of ambient light to reflect. This property has no visual impact on scenes that have no ambient light. Setting the ambient has no effect if locksAmbientWithDiffuse is set to YES.
        #[unsafe(method(ambient))]
        #[unsafe(method_family = none)]
        pub unsafe fn ambient(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// Specifies the receiver's specular property.
        ///
        /// The specular property specifies the amount of light to reflect in a mirror-like manner. The specular intensity increases when the point of view lines up with the direction of the reflected light.
        #[unsafe(method(specular))]
        #[unsafe(method_family = none)]
        pub unsafe fn specular(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The emission property specifies the amount of light the material emits. This emission does not light up other surfaces in the scene.
        #[unsafe(method(emission))]
        #[unsafe(method_family = none)]
        pub unsafe fn emission(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The transparent property specifies the transparent areas of the material.
        #[unsafe(method(transparent))]
        #[unsafe(method_family = none)]
        pub unsafe fn transparent(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The reflective property specifies the reflectivity of the surface. The surface will not actually reflect other objects in the scene. This property may be used as a sphere mapping to reflect a precomputed environment.
        #[unsafe(method(reflective))]
        #[unsafe(method_family = none)]
        pub unsafe fn reflective(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The multiply property specifies a color or an image used to multiply the output fragments with. The computed fragments are multiplied with the multiply value to produce the final fragments. This property may be used for shadow maps, to fade out or tint 3d objects.
        #[unsafe(method(multiply))]
        #[unsafe(method_family = none)]
        pub unsafe fn multiply(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The normal property specifies the surface orientation.
        ///
        /// When an image is set on the normal property the material is automatically lit per pixel. Setting a color has no effect.
        #[unsafe(method(normal))]
        #[unsafe(method_family = none)]
        pub unsafe fn normal(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The displacement property specifies how vertex are translated in tangent space.
        ///
        /// Pass a grayscale image for a simple 'elevation' or rgb image for a vector displacement.
        #[unsafe(method(displacement))]
        #[unsafe(method_family = none)]
        pub unsafe fn displacement(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The ambientOcclusion property specifies the ambient occlusion of the surface. The ambient occlusion is multiplied with the ambient light, then the result is added to the lighting contribution. This property has no visual impact on scenes that have no ambient light. When an ambient occlusion map is set, the ambient property is ignored.
        #[unsafe(method(ambientOcclusion))]
        #[unsafe(method_family = none)]
        pub unsafe fn ambientOcclusion(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The selfIllumination property specifies a texture or a color that is added to the lighting contribution of the surface. When a selfIllumination is set, the emission property is ignored.
        #[unsafe(method(selfIllumination))]
        #[unsafe(method_family = none)]
        pub unsafe fn selfIllumination(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The metalness property specifies how metallic the material's surface appears. Lower values (darker colors) cause the material to appear more like a dielectric surface. Higher values (brighter colors) cause the surface to appear more metallic. This property is only used when 'lightingModelName' is 'SCNLightingModelPhysicallyBased'.
        #[unsafe(method(metalness))]
        #[unsafe(method_family = none)]
        pub unsafe fn metalness(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The roughness property specifies the apparent smoothness of the surface. Lower values (darker colors) cause the material to appear shiny, with well-defined specular highlights. Higher values (brighter colors) cause specular highlights to spread out and the diffuse property of the material to become more retroreflective. This property is only used when 'lightingModelName' is 'SCNLightingModelPhysicallyBased'.
        #[unsafe(method(roughness))]
        #[unsafe(method_family = none)]
        pub unsafe fn roughness(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The clearCoat property specifies color and intensity of the coat layer.
        #[unsafe(method(clearCoat))]
        #[unsafe(method_family = none)]
        pub unsafe fn clearCoat(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The clearCoat property specifies color and intensity of the coat roughness.
        #[unsafe(method(clearCoatRoughness))]
        #[unsafe(method_family = none)]
        pub unsafe fn clearCoatRoughness(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "SCNMaterialProperty")]
        /// The clearCoatNormal property specifies color and intensity of the optional coat normal map.
        #[unsafe(method(clearCoatNormal))]
        #[unsafe(method_family = none)]
        pub unsafe fn clearCoatNormal(&self) -> Retained<SCNMaterialProperty>;

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the receiver's shininess value. Defaults to 1.0. Animatable.
        #[unsafe(method(shininess))]
        #[unsafe(method_family = none)]
        pub unsafe fn shininess(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`shininess`][Self::shininess].
        #[unsafe(method(setShininess:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setShininess(&self, shininess: CGFloat);

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the receiver's transparency value. Defaults to 1.0. Animatable.
        ///
        /// The color of the transparent property is multiplied by this property. The result is then used to produce the final transparency according to the rule defined by the transparencyMode property.
        #[unsafe(method(transparency))]
        #[unsafe(method_family = none)]
        pub unsafe fn transparency(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`transparency`][Self::transparency].
        #[unsafe(method(setTransparency:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTransparency(&self, transparency: CGFloat);

        /// Determines the receiver's lighting model. See above for the list of lighting models. Defaults to SCNLightingModelBlinn.
        #[unsafe(method(lightingModelName))]
        #[unsafe(method_family = none)]
        pub unsafe fn lightingModelName(&self) -> Retained<SCNLightingModel>;

        /// Setter for [`lightingModelName`][Self::lightingModelName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setLightingModelName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLightingModelName(&self, lighting_model_name: &SCNLightingModel);

        /// Determines whether the receiver is lit per pixel. Defaults to YES. Animatable.
        #[unsafe(method(isLitPerPixel))]
        #[unsafe(method_family = none)]
        pub unsafe fn isLitPerPixel(&self) -> bool;

        /// Setter for [`isLitPerPixel`][Self::isLitPerPixel].
        #[unsafe(method(setLitPerPixel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLitPerPixel(&self, lit_per_pixel: bool);

        /// Determines whether the receiver is double sided. Defaults to NO. Animatable.
        #[unsafe(method(isDoubleSided))]
        #[unsafe(method_family = none)]
        pub unsafe fn isDoubleSided(&self) -> bool;

        /// Setter for [`isDoubleSided`][Self::isDoubleSided].
        #[unsafe(method(setDoubleSided:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDoubleSided(&self, double_sided: bool);

        /// Determines of to how to rasterize the receiver's primitives. Defaults to SCNFillModeFill.
        #[unsafe(method(fillMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn fillMode(&self) -> SCNFillMode;

        /// Setter for [`fillMode`][Self::fillMode].
        #[unsafe(method(setFillMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFillMode(&self, fill_mode: SCNFillMode);

        /// Determines the culling mode of the receiver. Defaults to SCNCullModeBack. Animatable.
        #[unsafe(method(cullMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn cullMode(&self) -> SCNCullMode;

        /// Setter for [`cullMode`][Self::cullMode].
        #[unsafe(method(setCullMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCullMode(&self, cull_mode: SCNCullMode);

        /// Determines the transparency mode of the receiver. See above for the transparency modes. Defaults to SCNTransparencyModeDefault.
        #[unsafe(method(transparencyMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn transparencyMode(&self) -> SCNTransparencyMode;

        /// Setter for [`transparencyMode`][Self::transparencyMode].
        #[unsafe(method(setTransparencyMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setTransparencyMode(&self, transparency_mode: SCNTransparencyMode);

        /// Makes the ambient property automatically match the diffuse property. Defaults to NO on 10.9 and before, defaults to YES otherwise. Animatable.
        #[unsafe(method(locksAmbientWithDiffuse))]
        #[unsafe(method_family = none)]
        pub unsafe fn locksAmbientWithDiffuse(&self) -> bool;

        /// Setter for [`locksAmbientWithDiffuse`][Self::locksAmbientWithDiffuse].
        #[unsafe(method(setLocksAmbientWithDiffuse:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setLocksAmbientWithDiffuse(&self, locks_ambient_with_diffuse: bool);

        /// Determines whether the receiver writes to the depth buffer when rendered. Defaults to YES.
        #[unsafe(method(writesToDepthBuffer))]
        #[unsafe(method_family = none)]
        pub unsafe fn writesToDepthBuffer(&self) -> bool;

        /// Setter for [`writesToDepthBuffer`][Self::writesToDepthBuffer].
        #[unsafe(method(setWritesToDepthBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setWritesToDepthBuffer(&self, writes_to_depth_buffer: bool);

        #[cfg(feature = "SceneKitTypes")]
        /// Determines whether the receiver writes to the color buffer when rendered. Defaults to SCNColorMaskAll.
        #[unsafe(method(colorBufferWriteMask))]
        #[unsafe(method_family = none)]
        pub unsafe fn colorBufferWriteMask(&self) -> SCNColorMask;

        #[cfg(feature = "SceneKitTypes")]
        /// Setter for [`colorBufferWriteMask`][Self::colorBufferWriteMask].
        #[unsafe(method(setColorBufferWriteMask:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setColorBufferWriteMask(&self, color_buffer_write_mask: SCNColorMask);

        /// Determines whether the receiver reads from the depth buffer when rendered. Defaults to YES.
        #[unsafe(method(readsFromDepthBuffer))]
        #[unsafe(method_family = none)]
        pub unsafe fn readsFromDepthBuffer(&self) -> bool;

        /// Setter for [`readsFromDepthBuffer`][Self::readsFromDepthBuffer].
        #[unsafe(method(setReadsFromDepthBuffer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setReadsFromDepthBuffer(&self, reads_from_depth_buffer: bool);

        #[cfg(feature = "objc2-core-foundation")]
        /// Specifies the receiver's fresnel exponent value. Defaults to 0.0. Animatable.
        ///
        /// The effect of the reflectivity property is modulated by this property. The fresnelExponent changes the exponent of the reflectance. The bigger the exponent, the more concentrated the reflection is around the edges.
        #[unsafe(method(fresnelExponent))]
        #[unsafe(method_family = none)]
        pub unsafe fn fresnelExponent(&self) -> CGFloat;

        #[cfg(feature = "objc2-core-foundation")]
        /// Setter for [`fresnelExponent`][Self::fresnelExponent].
        #[unsafe(method(setFresnelExponent:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setFresnelExponent(&self, fresnel_exponent: CGFloat);

        /// Specifies the receiver's blend mode. Defaults to SCNBlendModeAlpha.
        #[unsafe(method(blendMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn blendMode(&self) -> SCNBlendMode;

        /// Setter for [`blendMode`][Self::blendMode].
        #[unsafe(method(setBlendMode:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setBlendMode(&self, blend_mode: SCNBlendMode);
    );
}

/// Methods declared on superclass `NSObject`.
impl SCNMaterial {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
