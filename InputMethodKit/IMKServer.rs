//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// Key used to obtain an input method's mode dictionary from the input method's bundle.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/inputmethodkit/imkmodedictionary?language=objc)
    pub static IMKModeDictionary: &'static NSString;
}

extern "C" {
    /// Key used to find an input method's input controller class name from the input method's bundle.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/inputmethodkit/imkcontrollerclass?language=objc)
    pub static IMKControllerClass: &'static NSString;
}

extern "C" {
    /// Key used to find an input method's delegate class name from the input method's bundle.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/inputmethodkit/imkdelegateclass?language=objc)
    pub static IMKDelegateClass: &'static NSString;
}

extern_class!(
    /// This class manages input sessions.
    ///
    /// An input method should create one and only one of these objects.  An IMKServer creates an NSConnection that can be connected to by input clients.  After a connection has been made an IMKServer manages communication between the client and the input method.  For each communication session the IMKServer will create an IMKInputController class as well as delegate classes for that controller.  Each controller object then serves as a proxy for the input session on the client side.  This means that input methods do not have to concern themselves with managing client sessions.  A given controller will only receive communication from a single session.
    ///
    /// IMKServer's also will manage a basic candidate window for an input method.  See IMKCandidates.h to understand how to create a candidate window and associate the candidate window with the IMKServer object.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/inputmethodkit/imkserver?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct IMKServer;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for IMKServer {}
);

impl IMKServer {
    extern_methods!(
        /// Create a IMKServer from information in the bundle's Info.plist.
        ///
        /// This method will look into the info.plist for a controller class and delegate class.  The class names will be loaded, no classes will be instantiated.  Additionally, an NSConnection will be allocated and registered with the name parameter.
        #[unsafe(method(initWithName:bundleIdentifier:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName_bundleIdentifier(
            this: Allocated<Self>,
            name: Option<&NSString>,
            bundle_identifier: Option<&NSString>,
        ) -> Option<Retained<Self>>;

        /// Creates an IMKServer using the parameters.
        ///
        /// This method creates an IMKServer object without attempting to examine the bundle instead the class names provided as parameters are used to create input controller objects and delegate objects.
        #[unsafe(method(initWithName:controllerClass:delegateClass:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithName_controllerClass_delegateClass(
            this: Allocated<Self>,
            name: Option<&NSString>,
            controller_class_id: Option<&AnyClass>,
            delegate_class_id: Option<&AnyClass>,
        ) -> Option<Retained<Self>>;

        /// Returns an NSBundle for the input method.
        ///
        /// If the IMKServer contains a bundle identifier the NSBundle is created from that.  Otherwise, the bundle  is created for the main bundle.  The returned NSBundle is an autoreleased object.
        #[unsafe(method(bundle))]
        #[unsafe(method_family = none)]
        pub unsafe fn bundle(&self) -> Option<Retained<NSBundle>>;

        /// Call this before terminating a palette IM.
        ///
        /// Palettes need to be able to terminate.  When this method is called the IMKServer will notify each client of the palette that
        /// the palette is about to terminate.  The palette can terminate safely if a value of YES is returned.  If the caller of this method is not
        /// an input method of type palette an exception will be thrown.
        ///
        /// If the method returns NO the palette should not terminate.
        #[unsafe(method(paletteWillTerminate))]
        #[unsafe(method_family = none)]
        pub unsafe fn paletteWillTerminate(&self) -> bool;

        /// Returns a BOOL indicating whether or not the last key press was a dead key.
        #[unsafe(method(lastKeyEventWasDeadKey))]
        #[unsafe(method_family = none)]
        pub unsafe fn lastKeyEventWasDeadKey(&self) -> bool;
    );
}

/// Methods declared on superclass `NSObject`.
impl IMKServer {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
