//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

pub const EAGL_MAJOR_VERSION: c_uint = 1;
pub const EAGL_MINOR_VERSION: c_uint = 0;
/// Versions of OpenGL ES that a rendering context provides.
/// *********************************************************************
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct EAGLRenderingAPI(pub NSUInteger);
impl EAGLRenderingAPI {
    /// Context supports OpenGL ES 1.x rendering API.
    #[doc(alias = "kEAGLRenderingAPIOpenGLES1")]
    pub const OpenGLES1: Self = Self(1);
    /// Context supports OpenGL ES 2.x rendering API.
    #[doc(alias = "kEAGLRenderingAPIOpenGLES2")]
    pub const OpenGLES2: Self = Self(2);
    /// Context supports OpenGL ES 3.x rendering API.
    #[doc(alias = "kEAGLRenderingAPIOpenGLES3")]
    pub const OpenGLES3: Self = Self(3);
}

unsafe impl Encode for EAGLRenderingAPI {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for EAGLRenderingAPI {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C-unwind" {
    /// Retrieves the version information for the EAGL implementation.
    ///
    /// Parameters:
    /// - major: On output, the major version of the EAGL implementation.
    ///
    /// - minor: On output, the minor version of the EAGL implementation.
    ///
    ///
    /// ## Discussion
    ///
    /// If `major` and `minor` parameters are not `nil`, they return the major and minor version number of the EAGL implementation, respectively.
    ///
    ///
    /// *********************************************************************
    ///
    /// # Safety
    ///
    /// - `major` must be a valid pointer.
    /// - `minor` must be a valid pointer.
    pub fn EAGLGetVersion(major: NonNull<c_uint>, minor: NonNull<c_uint>);
}

extern_class!(
    /// An `EAGLSharegroup` object manages OpenGL ES resources associated with one or more `EAGLContext` objects. It is created when an `EAGLContext` object is initialized and disposed of when the last `EAGLContext` object that references it is released. As an opaque object, there is no developer accessible API.
    ///
    /// ## Overview
    ///
    /// Currently, the sharegroup manages textures, buffers, framebuffers, and renderbuffers. It is your application’s responsibility to manage state changes to shared objects when those objects are accessed from multiple contexts in the sharegroup. The results of changing the state of a shared object while it is being used for rendering in another context are undefined. To obtain deterministic results, your application must take explicit steps to ensure that the shared object is not currently being used for rendering while your application modifies it. Further, state changes are not guaranteed to be noticed by another context in the sharegroup until that context rebinds the shared object.
    ///
    /// To ensure defined results of state changes to shared objects across contexts in the sharegroup, your application must perform the following tasks, in this order:
    ///
    /// 1. Call `glFlush` on the rendering context that issues the state-modifying routines.
    ///
    /// 2. Call `glBindTexture` or `glBindBuffer` on the rendering context that depends on the texture or vertex buffer object state changes, respectively.
    ///
    /// A shared object is not deleted until it is no longer bound to any context.
    ///
    ///
    /// *********************************************************************
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct EAGLSharegroup;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for EAGLSharegroup {}
);

impl EAGLSharegroup {
    extern_methods!(
        #[unsafe(method(debugLabel))]
        #[unsafe(method_family = none)]
        pub unsafe fn debugLabel(&self) -> Option<Retained<NSString>>;

        /// Setter for [`debugLabel`][Self::debugLabel].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDebugLabel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDebugLabel(&self, debug_label: Option<&NSString>);
    );
}

/// Methods declared on superclass `NSObject`.
impl EAGLSharegroup {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An [`EAGLContext`](https://developer.apple.com/documentation/opengles/eaglcontext) object manages an OpenGL ES _rendering context_—the state information, commands, and resources needed to draw using OpenGL ES. To execute OpenGL ES commands, you need a current rendering context.
    ///
    /// ## Overview
    ///
    /// Drawing resources, such as textures and renderbuffers, are managed for the [`EAGLContext`](https://developer.apple.com/documentation/opengles/eaglcontext) object by an [`EAGLSharegroup`](https://developer.apple.com/documentation/opengles/eaglsharegroup) object associated with the context. When you initialize a new [`EAGLContext`](https://developer.apple.com/documentation/opengles/eaglcontext) object, you can choose to have it create a new sharegroup, or you can use one obtained from a previously created context.
    ///
    /// Before drawing to a context, you must bind a complete framebuffer object to the context. For more information on configuring rendering contexts, see [OpenGL ES Programming Guide](https://developer.apple.com/library/archive/documentation/3DDrawing/Conceptual/OpenGLES_ProgrammingGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008793).
    ///
    ///
    /// *********************************************************************
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct EAGLContext;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for EAGLContext {}
);

impl EAGLContext {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Option<Retained<Self>>;

        #[unsafe(method(initWithAPI:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAPI(
            this: Allocated<Self>,
            api: EAGLRenderingAPI,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(initWithAPI:sharegroup:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithAPI_sharegroup(
            this: Allocated<Self>,
            api: EAGLRenderingAPI,
            sharegroup: &EAGLSharegroup,
        ) -> Option<Retained<Self>>;

        #[unsafe(method(setCurrentContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setCurrentContext(context: Option<&EAGLContext>) -> bool;

        #[unsafe(method(currentContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn currentContext() -> Option<Retained<EAGLContext>>;

        #[unsafe(method(API))]
        #[unsafe(method_family = none)]
        pub unsafe fn API(&self) -> EAGLRenderingAPI;

        #[unsafe(method(sharegroup))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharegroup(&self) -> Retained<EAGLSharegroup>;

        #[unsafe(method(debugLabel))]
        #[unsafe(method_family = none)]
        pub unsafe fn debugLabel(&self) -> Option<Retained<NSString>>;

        /// Setter for [`debugLabel`][Self::debugLabel].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setDebugLabel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDebugLabel(&self, debug_label: Option<&NSString>);

        #[unsafe(method(isMultiThreaded))]
        #[unsafe(method_family = none)]
        pub unsafe fn isMultiThreaded(&self) -> bool;

        /// Setter for [`isMultiThreaded`][Self::isMultiThreaded].
        #[unsafe(method(setMultiThreaded:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMultiThreaded(&self, multi_threaded: bool);
    );
}

/// Methods declared on superclass `NSObject`.
impl EAGLContext {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
