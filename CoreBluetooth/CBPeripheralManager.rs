//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "dispatch2")]
use dispatch2::*;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Represents the current state of a CBPeripheralManager.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corebluetooth/cbperipheralmanagerauthorizationstatus?language=objc)
// NS_ENUM
#[deprecated = "Use CBManagerAuthorization instead"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CBPeripheralManagerAuthorizationStatus(pub NSInteger);
impl CBPeripheralManagerAuthorizationStatus {
    #[deprecated = "Use CBManagerAuthorization instead"]
    #[doc(alias = "CBPeripheralManagerAuthorizationStatusNotDetermined")]
    pub const NotDetermined: Self = Self(0);
    #[deprecated = "Use CBManagerAuthorization instead"]
    #[doc(alias = "CBPeripheralManagerAuthorizationStatusRestricted")]
    pub const Restricted: Self = Self(1);
    #[deprecated = "Use CBManagerAuthorization instead"]
    #[doc(alias = "CBPeripheralManagerAuthorizationStatusDenied")]
    pub const Denied: Self = Self(2);
    #[deprecated = "Use CBManagerAuthorization instead"]
    #[doc(alias = "CBPeripheralManagerAuthorizationStatusAuthorized")]
    pub const Authorized: Self = Self(3);
}

unsafe impl Encode for CBPeripheralManagerAuthorizationStatus {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CBPeripheralManagerAuthorizationStatus {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Represents the current state of a CBPeripheralManager.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corebluetooth/cbperipheralmanagerstate?language=objc)
// NS_ENUM
#[deprecated = "Use CBManagerState instead"]
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CBPeripheralManagerState(pub NSInteger);
impl CBPeripheralManagerState {
    #[cfg(feature = "CBManager")]
    #[deprecated = "Use CBManagerState instead"]
    #[doc(alias = "CBPeripheralManagerStateUnknown")]
    pub const Unknown: Self = Self(CBManagerState::Unknown.0);
    #[cfg(feature = "CBManager")]
    #[deprecated = "Use CBManagerState instead"]
    #[doc(alias = "CBPeripheralManagerStateResetting")]
    pub const Resetting: Self = Self(CBManagerState::Resetting.0);
    #[cfg(feature = "CBManager")]
    #[deprecated = "Use CBManagerState instead"]
    #[doc(alias = "CBPeripheralManagerStateUnsupported")]
    pub const Unsupported: Self = Self(CBManagerState::Unsupported.0);
    #[cfg(feature = "CBManager")]
    #[deprecated = "Use CBManagerState instead"]
    #[doc(alias = "CBPeripheralManagerStateUnauthorized")]
    pub const Unauthorized: Self = Self(CBManagerState::Unauthorized.0);
    #[cfg(feature = "CBManager")]
    #[deprecated = "Use CBManagerState instead"]
    #[doc(alias = "CBPeripheralManagerStatePoweredOff")]
    pub const PoweredOff: Self = Self(CBManagerState::PoweredOff.0);
    #[cfg(feature = "CBManager")]
    #[deprecated = "Use CBManagerState instead"]
    #[doc(alias = "CBPeripheralManagerStatePoweredOn")]
    pub const PoweredOn: Self = Self(CBManagerState::PoweredOn.0);
}

unsafe impl Encode for CBPeripheralManagerState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CBPeripheralManagerState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The latency of a peripheral-central connection controls how frequently messages can be exchanged.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corebluetooth/cbperipheralmanagerconnectionlatency?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct CBPeripheralManagerConnectionLatency(pub NSInteger);
impl CBPeripheralManagerConnectionLatency {
    #[doc(alias = "CBPeripheralManagerConnectionLatencyLow")]
    pub const Low: Self = Self(0);
    #[doc(alias = "CBPeripheralManagerConnectionLatencyMedium")]
    pub const Medium: Self = Self(1);
    #[doc(alias = "CBPeripheralManagerConnectionLatencyHigh")]
    pub const High: Self = Self(2);
}

unsafe impl Encode for CBPeripheralManagerConnectionLatency {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CBPeripheralManagerConnectionLatency {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The
    /// <code>
    /// CBPeripheralManager
    /// </code>
    /// class is an abstraction of the Peripheral and Broadcaster GAP roles, and the GATT Server
    /// role. Its primary function is to allow you to manage published services within the GATT database, and to advertise these services
    /// to other devices.
    /// Each application has sandboxed access to the shared GATT database. You can add services to the database by calling {
    ///
    /// ```text
    ///  addService:};
    ///               they can be removed via {@link removeService:} and {@link removeAllServices}, as appropriate. While a service is in the database,
    ///               it is visible to and can be accessed by any connected GATT Client. However, applications that have not specified the "bluetooth-peripheral"
    ///               background mode will have the contents of their service(s) "disabled" when in the background. Any remote device trying to access
    ///               characteristic values or descriptors during this time will receive an error response.
    ///               Once you've published services that you want to share, you can ask to advertise their availability and allow other devices to connect
    ///               to you by calling {@link startAdvertising:}. Like the GATT database, advertisement is managed at the system level and shared by all
    ///               applications. This means that even if you aren't advertising at the moment, someone else might be!
    ///
    ///  
    ///
    /// ```
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corebluetooth/cbperipheralmanager?language=objc)
    #[unsafe(super(CBManager, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "CBManager")]
    pub struct CBPeripheralManager;
);

#[cfg(feature = "CBManager")]
extern_conformance!(
    unsafe impl NSObjectProtocol for CBPeripheralManager {}
);

#[cfg(feature = "CBManager")]
impl CBPeripheralManager {
    extern_methods!(
        /// The delegate object that will receive peripheral events.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(
            &self,
        ) -> Option<Retained<ProtocolObject<dyn CBPeripheralManagerDelegate>>>;

        /// This is a [weak property][objc2::topics::weak_property].
        /// Setter for [`delegate`][Self::delegate].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(
            &self,
            delegate: Option<&ProtocolObject<dyn CBPeripheralManagerDelegate>>,
        );

        /// Whether or not the peripheral is currently advertising data.
        #[unsafe(method(isAdvertising))]
        #[unsafe(method_family = none)]
        pub unsafe fn isAdvertising(&self) -> bool;

        /// This method does not prompt the user for access. You can use it to detect restricted access and simply hide UI instead of
        /// prompting for access.
        ///
        ///
        /// Returns: The current authorization status for sharing data while backgrounded. For the constants returned, see {
        ///
        /// ```text
        ///  CBPeripheralManagerAuthorizationStatus}.
        ///
        ///   @see        CBPeripheralManagerAuthorizationStatus
        ///  
        ///
        /// ```
        #[deprecated = "Use CBManagerAuthorization instead"]
        #[unsafe(method(authorizationStatus))]
        #[unsafe(method_family = none)]
        pub unsafe fn authorizationStatus() -> CBPeripheralManagerAuthorizationStatus;

        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Parameter `delegate`: The delegate that will receive peripheral role events.
        ///
        /// Parameter `queue`: The dispatch queue on which the events will be dispatched.
        ///
        ///
        /// The initialization call. The events of the peripheral role will be dispatched on the provided queue.
        /// If
        /// <i>
        /// nil
        /// </i>
        /// , the main queue will be used.
        #[unsafe(method(initWithDelegate:queue:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDelegate_queue(
            this: Allocated<Self>,
            delegate: Option<&ProtocolObject<dyn CBPeripheralManagerDelegate>>,
            queue: Option<&DispatchQueue>,
        ) -> Retained<Self>;

        #[cfg(feature = "dispatch2")]
        /// Parameter `delegate`: The delegate that will receive peripheral role events.
        ///
        /// Parameter `queue`: The dispatch queue on which the events will be dispatched.
        ///
        /// Parameter `options`: An optional dictionary specifying options for the manager.
        ///
        ///
        /// The initialization call. The events of the peripheral role will be dispatched on the provided queue.
        /// If
        /// <i>
        /// nil
        /// </i>
        /// , the main queue will be used.
        ///
        ///
        /// See also: CBPeripheralManagerOptionShowPowerAlertKey
        ///
        /// See also: CBPeripheralManagerOptionRestoreIdentifierKey
        #[unsafe(method(initWithDelegate:queue:options:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithDelegate_queue_options(
            this: Allocated<Self>,
            delegate: Option<&ProtocolObject<dyn CBPeripheralManagerDelegate>>,
            queue: Option<&DispatchQueue>,
            options: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<Self>;

        /// Parameter `advertisementData`: An optional dictionary containing the data to be advertised.
        ///
        ///
        /// Starts advertising. Supported advertising data types are
        /// <code>
        /// CBAdvertisementDataLocalNameKey
        /// </code>
        /// and
        /// <code>
        /// CBAdvertisementDataServiceUUIDsKey
        /// </code>
        /// .
        /// When in the foreground, an application can utilize up to 28 bytes of space in the initial advertisement data for
        /// any combination of the supported advertising data types. If this space is used up, there are an additional 10 bytes of
        /// space in the scan response that can be used only for the local name. Note that these sizes do not include the 2 bytes
        /// of header information that are required for each new data type. Any service UUIDs that do not fit in the allotted space
        /// will be added to a special "overflow" area, and can only be discovered by an iOS device that is explicitly scanning
        /// for them.
        /// While an application is in the background, the local name will not be used and all service UUIDs will be placed in the
        /// "overflow" area. However, applications that have not specified the "bluetooth-peripheral" background mode will not be able
        /// to advertise anything while in the background.
        ///
        ///
        /// See: peripheralManagerDidStartAdvertising:error:
        ///
        /// See also: CBAdvertisementData.h
        #[unsafe(method(startAdvertising:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startAdvertising(
            &self,
            advertisement_data: Option<&NSDictionary<NSString, AnyObject>>,
        );

        /// Stops advertising.
        #[unsafe(method(stopAdvertising))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopAdvertising(&self);

        #[cfg(all(feature = "CBCentral", feature = "CBPeer"))]
        /// Parameter `latency`: The desired connection latency.
        ///
        /// Parameter `central`: A connected central.
        ///
        ///
        /// Sets the desired connection latency for an existing connection to
        /// <i>
        /// central
        /// </i>
        /// . Connection latency changes are not guaranteed, so the
        /// resultant latency may vary. If a desired latency is not set, the latency chosen by
        /// <i>
        /// central
        /// </i>
        /// at the time of connection establishment
        /// will be used. Typically, it is not necessary to change the latency.
        ///
        ///
        /// See: CBPeripheralManagerConnectionLatency
        #[unsafe(method(setDesiredConnectionLatency:forCentral:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDesiredConnectionLatency_forCentral(
            &self,
            latency: CBPeripheralManagerConnectionLatency,
            central: &CBCentral,
        );

        #[cfg(all(feature = "CBAttribute", feature = "CBService"))]
        /// Parameter `service`: A GATT service.
        ///
        ///
        /// Publishes a service and its associated characteristic(s) to the local database. If the service contains included services,
        /// they must be published first.
        ///
        ///
        /// See: peripheralManager:didAddService:error:
        #[unsafe(method(addService:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addService(&self, service: &CBMutableService);

        #[cfg(all(feature = "CBAttribute", feature = "CBService"))]
        /// Parameter `service`: A GATT service.
        ///
        ///
        /// Removes a published service from the local database. If the service is included by other service(s), they must be removed
        /// first.
        #[unsafe(method(removeService:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeService(&self, service: &CBMutableService);

        /// Removes all published services from the local database.
        #[unsafe(method(removeAllServices))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeAllServices(&self);

        #[cfg(all(feature = "CBATTRequest", feature = "CBError"))]
        /// Parameter `request`: The original request that was received from the central.
        ///
        /// Parameter `result`: The result of attempting to fulfill
        /// <i>
        /// request
        /// </i>
        /// .
        ///
        ///
        /// Used to respond to request(s) received via the
        ///
        /// ```text
        ///  peripheralManager:didReceiveReadRequest:
        /// ```
        ///
        /// or
        ///
        /// ```text
        ///  peripheralManager:didReceiveWriteRequests:
        /// ```
        ///
        /// delegate methods.
        ///
        ///
        /// See: peripheralManager:didReceiveReadRequest:
        ///
        /// See: peripheralManager:didReceiveWriteRequests:
        #[unsafe(method(respondToRequest:withResult:))]
        #[unsafe(method_family = none)]
        pub unsafe fn respondToRequest_withResult(
            &self,
            request: &CBATTRequest,
            result: CBATTError,
        );

        #[cfg(all(
            feature = "CBAttribute",
            feature = "CBCentral",
            feature = "CBCharacteristic",
            feature = "CBPeer"
        ))]
        /// Parameter `value`: The value to be sent via a notification/indication.
        ///
        /// Parameter `characteristic`: The characteristic whose value has changed.
        ///
        /// Parameter `centrals`: A list of
        /// <code>
        /// CBCentral
        /// </code>
        /// objects to receive the update. Note that centrals which have not subscribed to
        /// <i>
        /// characteristic
        /// </i>
        /// will be ignored. If
        /// <i>
        /// nil
        /// </i>
        /// , all centrals that are subscribed to
        /// <i>
        /// characteristic
        /// </i>
        /// will be updated.
        ///
        ///
        /// Sends an updated characteristic value to one or more centrals, via a notification or indication. If
        /// <i>
        /// value
        /// </i>
        /// exceeds
        /// {
        ///
        /// ```text
        ///  maximumUpdateValueLength}, it will be truncated to fit.
        ///
        ///   @return                 <i>YES</i> if the update could be sent, or <i>NO</i> if the underlying transmit queue is full. If <i>NO</i> was returned,
        ///                           the delegate method @link peripheralManagerIsReadyToUpdateSubscribers:
        /// ```
        ///
        /// will be called once space has become
        /// available, and the update should be re-sent if so desired.
        ///
        ///
        /// See: peripheralManager:central:didSubscribeToCharacteristic:
        ///
        /// See: peripheralManager:central:didUnsubscribeFromCharacteristic:
        ///
        /// See: peripheralManagerIsReadyToUpdateSubscribers:
        ///
        /// See also: maximumUpdateValueLength
        #[unsafe(method(updateValue:forCharacteristic:onSubscribedCentrals:))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateValue_forCharacteristic_onSubscribedCentrals(
            &self,
            value: &NSData,
            characteristic: &CBMutableCharacteristic,
            centrals: Option<&NSArray<CBCentral>>,
        ) -> bool;

        /// Parameter `encryptionRequired`: YES if the service requires the link to be encrypted before a stream can be established.  NO if the service can be used over
        /// an unsecured link.
        ///
        ///
        /// Create a listener for incoming L2CAP Channel connections.  The system will determine an unused PSM at the time of publishing, which will be returned
        /// with
        ///
        /// ```text
        ///  peripheralManager:didPublishL2CAPChannel:error:
        /// ```
        ///
        /// .  L2CAP Channels are not discoverable by themselves, so it is the application's
        /// responsibility to handle PSM discovery on the client.
        #[unsafe(method(publishL2CAPChannelWithEncryption:))]
        #[unsafe(method_family = none)]
        pub unsafe fn publishL2CAPChannelWithEncryption(&self, encryption_required: bool);

        #[cfg(feature = "CBL2CAPChannel")]
        /// Parameter `PSM`: The service PSM to be removed from the system.
        ///
        ///
        /// Removes a published service from the local system.  No new connections for this PSM will be accepted, and any existing L2CAP channels
        /// using this PSM will be closed.
        #[unsafe(method(unpublishL2CAPChannel:))]
        #[unsafe(method_family = none)]
        pub unsafe fn unpublishL2CAPChannel(&self, psm: CBL2CAPPSM);
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "CBManager")]
impl CBPeripheralManager {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// The delegate of a
    ///
    /// ```text
    ///  CBPeripheralManager
    /// ```
    ///
    /// object must adopt the
    /// <code>
    /// CBPeripheralManagerDelegate
    /// </code>
    /// protocol. The
    /// single required method indicates the availability of the peripheral manager, while the optional methods provide information about
    /// centrals, which can connect and access the local database.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/corebluetooth/cbperipheralmanagerdelegate?language=objc)
    pub unsafe trait CBPeripheralManagerDelegate: NSObjectProtocol {
        #[cfg(feature = "CBManager")]
        /// Parameter `peripheral`: The peripheral manager whose state has changed.
        ///
        ///
        /// Invoked whenever the peripheral manager's state has been updated. Commands should only be issued when the state is
        /// <code>
        /// CBPeripheralManagerStatePoweredOn
        /// </code>
        /// . A state below
        /// <code>
        /// CBPeripheralManagerStatePoweredOn
        /// </code>
        /// implies that advertisement has paused and any connected centrals have been disconnected. If the state moves below
        /// <code>
        /// CBPeripheralManagerStatePoweredOff
        /// </code>
        /// , advertisement is stopped and must be explicitly restarted, and the
        /// local database is cleared and all services must be re-added.
        ///
        ///
        /// See: state
        #[unsafe(method(peripheralManagerDidUpdateState:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManagerDidUpdateState(&self, peripheral: &CBPeripheralManager);

        #[cfg(feature = "CBManager")]
        /// Parameter `peripheral`: The peripheral manager providing this information.
        ///
        /// Parameter `dict`: A dictionary containing information about
        /// <i>
        /// peripheral
        /// </i>
        /// that was preserved by the system at the time the app was terminated.
        ///
        ///
        /// For apps that opt-in to state preservation and restoration, this is the first method invoked when your app is relaunched into
        /// the background to complete some Bluetooth-related task. Use this method to synchronize your app's state with the state of the
        /// Bluetooth system.
        ///
        ///
        /// See also: CBPeripheralManagerRestoredStateServicesKey;
        ///
        /// See also: CBPeripheralManagerRestoredStateAdvertisementDataKey;
        #[optional]
        #[unsafe(method(peripheralManager:willRestoreState:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManager_willRestoreState(
            &self,
            peripheral: &CBPeripheralManager,
            dict: &NSDictionary<NSString, AnyObject>,
        );

        #[cfg(feature = "CBManager")]
        /// Parameter `peripheral`: The peripheral manager providing this information.
        ///
        /// Parameter `error`: If an error occurred, the cause of the failure.
        ///
        ///
        /// This method returns the result of a
        ///
        /// ```text
        ///  startAdvertising:
        /// ```
        ///
        /// call. If advertisement could
        /// not be started, the cause will be detailed in the
        /// <i>
        /// error
        /// </i>
        /// parameter.
        #[optional]
        #[unsafe(method(peripheralManagerDidStartAdvertising:error:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManagerDidStartAdvertising_error(
            &self,
            peripheral: &CBPeripheralManager,
            error: Option<&NSError>,
        );

        #[cfg(all(feature = "CBAttribute", feature = "CBManager", feature = "CBService"))]
        /// Parameter `peripheral`: The peripheral manager providing this information.
        ///
        /// Parameter `service`: The service that was added to the local database.
        ///
        /// Parameter `error`: If an error occurred, the cause of the failure.
        ///
        ///
        /// This method returns the result of an
        ///
        /// ```text
        ///  addService:
        /// ```
        ///
        /// call. If the service could
        /// not be published to the local database, the cause will be detailed in the
        /// <i>
        /// error
        /// </i>
        /// parameter.
        #[optional]
        #[unsafe(method(peripheralManager:didAddService:error:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManager_didAddService_error(
            &self,
            peripheral: &CBPeripheralManager,
            service: &CBService,
            error: Option<&NSError>,
        );

        #[cfg(all(
            feature = "CBAttribute",
            feature = "CBCentral",
            feature = "CBCharacteristic",
            feature = "CBManager",
            feature = "CBPeer"
        ))]
        /// Parameter `peripheral`: The peripheral manager providing this update.
        ///
        /// Parameter `central`: The central that issued the command.
        ///
        /// Parameter `characteristic`: The characteristic on which notifications or indications were enabled.
        ///
        ///
        /// This method is invoked when a central configures
        /// <i>
        /// characteristic
        /// </i>
        /// to notify or indicate.
        /// It should be used as a cue to start sending updates as the characteristic value changes.
        #[optional]
        #[unsafe(method(peripheralManager:central:didSubscribeToCharacteristic:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManager_central_didSubscribeToCharacteristic(
            &self,
            peripheral: &CBPeripheralManager,
            central: &CBCentral,
            characteristic: &CBCharacteristic,
        );

        #[cfg(all(
            feature = "CBAttribute",
            feature = "CBCentral",
            feature = "CBCharacteristic",
            feature = "CBManager",
            feature = "CBPeer"
        ))]
        /// Parameter `peripheral`: The peripheral manager providing this update.
        ///
        /// Parameter `central`: The central that issued the command.
        ///
        /// Parameter `characteristic`: The characteristic on which notifications or indications were disabled.
        ///
        ///
        /// This method is invoked when a central removes notifications/indications from
        /// <i>
        /// characteristic
        /// </i>
        /// .
        #[optional]
        #[unsafe(method(peripheralManager:central:didUnsubscribeFromCharacteristic:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManager_central_didUnsubscribeFromCharacteristic(
            &self,
            peripheral: &CBPeripheralManager,
            central: &CBCentral,
            characteristic: &CBCharacteristic,
        );

        #[cfg(all(feature = "CBATTRequest", feature = "CBManager"))]
        /// Parameter `peripheral`: The peripheral manager requesting this information.
        ///
        /// Parameter `request`: A
        /// <code>
        /// CBATTRequest
        /// </code>
        /// object.
        ///
        ///
        /// This method is invoked when
        /// <i>
        /// peripheral
        /// </i>
        /// receives an ATT request for a characteristic with a dynamic value.
        /// For every invocation of this method,
        ///
        /// ```text
        ///  respondToRequest:withResult:
        /// ```
        ///
        /// must be called.
        ///
        ///
        /// See: CBATTRequest
        #[optional]
        #[unsafe(method(peripheralManager:didReceiveReadRequest:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManager_didReceiveReadRequest(
            &self,
            peripheral: &CBPeripheralManager,
            request: &CBATTRequest,
        );

        #[cfg(all(feature = "CBATTRequest", feature = "CBManager"))]
        /// Parameter `peripheral`: The peripheral manager requesting this information.
        ///
        /// Parameter `requests`: A list of one or more
        /// <code>
        /// CBATTRequest
        /// </code>
        /// objects.
        ///
        ///
        /// This method is invoked when
        /// <i>
        /// peripheral
        /// </i>
        /// receives an ATT request or command for one or more characteristics with a dynamic value.
        /// For every invocation of this method,
        ///
        /// ```text
        ///  respondToRequest:withResult:
        /// ```
        ///
        /// should be called exactly once. If
        /// <i>
        /// requests
        /// </i>
        /// contains
        /// multiple requests, they must be treated as an atomic unit. If the execution of one of the requests would cause a failure, the request
        /// and error reason should be provided to
        /// <code>
        /// respondToRequest:withResult:
        /// </code>
        /// and none of the requests should be executed.
        ///
        ///
        /// See: CBATTRequest
        #[optional]
        #[unsafe(method(peripheralManager:didReceiveWriteRequests:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManager_didReceiveWriteRequests(
            &self,
            peripheral: &CBPeripheralManager,
            requests: &NSArray<CBATTRequest>,
        );

        #[cfg(feature = "CBManager")]
        /// Parameter `peripheral`: The peripheral manager providing this update.
        ///
        ///
        /// This method is invoked after a failed call to
        ///
        /// ```text
        ///  updateValue:forCharacteristic:onSubscribedCentrals:
        /// ```
        ///
        /// , when
        /// <i>
        /// peripheral
        /// </i>
        /// is again
        /// ready to send characteristic value updates.
        #[optional]
        #[unsafe(method(peripheralManagerIsReadyToUpdateSubscribers:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManagerIsReadyToUpdateSubscribers(
            &self,
            peripheral: &CBPeripheralManager,
        );

        #[cfg(all(feature = "CBL2CAPChannel", feature = "CBManager"))]
        /// Parameter `peripheral`: The peripheral manager requesting this information.
        ///
        /// Parameter `PSM`: The PSM of the channel that was published.
        ///
        /// Parameter `error`: If an error occurred, the cause of the failure.
        ///
        ///
        /// This method is the response to a
        ///
        /// ```text
        ///  publishL2CAPChannel:
        /// ```
        ///
        /// call.  The PSM will contain the PSM that was assigned for the published
        /// channel
        #[optional]
        #[unsafe(method(peripheralManager:didPublishL2CAPChannel:error:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManager_didPublishL2CAPChannel_error(
            &self,
            peripheral: &CBPeripheralManager,
            psm: CBL2CAPPSM,
            error: Option<&NSError>,
        );

        #[cfg(all(feature = "CBL2CAPChannel", feature = "CBManager"))]
        /// Parameter `peripheral`: The peripheral manager requesting this information.
        ///
        /// Parameter `PSM`: The PSM of the channel that was published.
        ///
        /// Parameter `error`: If an error occurred, the cause of the failure.
        ///
        ///
        /// This method is the response to a
        ///
        /// ```text
        ///  unpublishL2CAPChannel:
        /// ```
        ///
        /// call.
        #[optional]
        #[unsafe(method(peripheralManager:didUnpublishL2CAPChannel:error:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManager_didUnpublishL2CAPChannel_error(
            &self,
            peripheral: &CBPeripheralManager,
            psm: CBL2CAPPSM,
            error: Option<&NSError>,
        );

        #[cfg(all(feature = "CBL2CAPChannel", feature = "CBManager"))]
        /// Parameter `peripheral`: The peripheral manager requesting this information.
        ///
        /// Parameter `channel`: A
        /// <code>
        /// CBL2CAPChannel
        /// </code>
        /// object.
        ///
        /// Parameter `error`: If an error occurred, the cause of the failure.
        ///
        ///
        /// This method returns the result of establishing an incoming L2CAP channel , following publishing a channel using
        ///
        /// ```text
        ///  publishL2CAPChannel: @link call.
        ///
        ///  
        ///
        /// ```
        #[optional]
        #[unsafe(method(peripheralManager:didOpenL2CAPChannel:error:))]
        #[unsafe(method_family = none)]
        unsafe fn peripheralManager_didOpenL2CAPChannel_error(
            &self,
            peripheral: &CBPeripheralManager,
            channel: Option<&CBL2CAPChannel>,
            error: Option<&NSError>,
        );
    }
);
