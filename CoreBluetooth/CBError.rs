//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corebluetooth/cberrordomain?language=objc)
    pub static CBErrorDomain: &'static NSString;
}

/// The possible errors returned during LE transactions.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/corebluetooth/cberror?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CBError(pub NSInteger);
impl CBError {
    #[doc(alias = "CBErrorUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "CBErrorInvalidParameters")]
    pub const InvalidParameters: Self = Self(1);
    #[doc(alias = "CBErrorInvalidHandle")]
    pub const InvalidHandle: Self = Self(2);
    #[doc(alias = "CBErrorNotConnected")]
    pub const NotConnected: Self = Self(3);
    #[doc(alias = "CBErrorOutOfSpace")]
    pub const OutOfSpace: Self = Self(4);
    #[doc(alias = "CBErrorOperationCancelled")]
    pub const OperationCancelled: Self = Self(5);
    #[doc(alias = "CBErrorConnectionTimeout")]
    pub const ConnectionTimeout: Self = Self(6);
    #[doc(alias = "CBErrorPeripheralDisconnected")]
    pub const PeripheralDisconnected: Self = Self(7);
    #[doc(alias = "CBErrorUUIDNotAllowed")]
    pub const UUIDNotAllowed: Self = Self(8);
    #[doc(alias = "CBErrorAlreadyAdvertising")]
    pub const AlreadyAdvertising: Self = Self(9);
    #[doc(alias = "CBErrorConnectionFailed")]
    pub const ConnectionFailed: Self = Self(10);
    #[doc(alias = "CBErrorConnectionLimitReached")]
    pub const ConnectionLimitReached: Self = Self(11);
    #[doc(alias = "CBErrorUnkownDevice")]
    #[deprecated = "Use CBErrorUnknownDevice instead"]
    pub const UnkownDevice: Self = Self(12);
    #[doc(alias = "CBErrorUnknownDevice")]
    pub const UnknownDevice: Self = Self(12);
    #[doc(alias = "CBErrorOperationNotSupported")]
    pub const OperationNotSupported: Self = Self(13);
    #[doc(alias = "CBErrorPeerRemovedPairingInformation")]
    pub const PeerRemovedPairingInformation: Self = Self(14);
    #[doc(alias = "CBErrorEncryptionTimedOut")]
    pub const EncryptionTimedOut: Self = Self(15);
    #[doc(alias = "CBErrorTooManyLEPairedDevices")]
    pub const TooManyLEPairedDevices: Self = Self(16);
    #[doc(alias = "CBErrorLeGattExceededBackgroundNotificationLimit")]
    pub const LeGattExceededBackgroundNotificationLimit: Self = Self(17);
    #[doc(alias = "CBErrorLeGattNearBackgroundNotificationLimit")]
    pub const LeGattNearBackgroundNotificationLimit: Self = Self(18);
}

unsafe impl Encode for CBError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CBError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/corebluetooth/cbatterrordomain?language=objc)
    pub static CBATTErrorDomain: &'static NSString;
}

/// [Apple's documentation](https://developer.apple.com/documentation/corebluetooth/cbatterror?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct CBATTError(pub NSInteger);
impl CBATTError {
    #[doc(alias = "CBATTErrorSuccess")]
    pub const Success: Self = Self(0x00);
    #[doc(alias = "CBATTErrorInvalidHandle")]
    pub const InvalidHandle: Self = Self(0x01);
    #[doc(alias = "CBATTErrorReadNotPermitted")]
    pub const ReadNotPermitted: Self = Self(0x02);
    #[doc(alias = "CBATTErrorWriteNotPermitted")]
    pub const WriteNotPermitted: Self = Self(0x03);
    #[doc(alias = "CBATTErrorInvalidPdu")]
    pub const InvalidPdu: Self = Self(0x04);
    #[doc(alias = "CBATTErrorInsufficientAuthentication")]
    pub const InsufficientAuthentication: Self = Self(0x05);
    #[doc(alias = "CBATTErrorRequestNotSupported")]
    pub const RequestNotSupported: Self = Self(0x06);
    #[doc(alias = "CBATTErrorInvalidOffset")]
    pub const InvalidOffset: Self = Self(0x07);
    #[doc(alias = "CBATTErrorInsufficientAuthorization")]
    pub const InsufficientAuthorization: Self = Self(0x08);
    #[doc(alias = "CBATTErrorPrepareQueueFull")]
    pub const PrepareQueueFull: Self = Self(0x09);
    #[doc(alias = "CBATTErrorAttributeNotFound")]
    pub const AttributeNotFound: Self = Self(0x0A);
    #[doc(alias = "CBATTErrorAttributeNotLong")]
    pub const AttributeNotLong: Self = Self(0x0B);
    #[doc(alias = "CBATTErrorInsufficientEncryptionKeySize")]
    pub const InsufficientEncryptionKeySize: Self = Self(0x0C);
    #[doc(alias = "CBATTErrorInvalidAttributeValueLength")]
    pub const InvalidAttributeValueLength: Self = Self(0x0D);
    #[doc(alias = "CBATTErrorUnlikelyError")]
    pub const UnlikelyError: Self = Self(0x0E);
    #[doc(alias = "CBATTErrorInsufficientEncryption")]
    pub const InsufficientEncryption: Self = Self(0x0F);
    #[doc(alias = "CBATTErrorUnsupportedGroupType")]
    pub const UnsupportedGroupType: Self = Self(0x10);
    #[doc(alias = "CBATTErrorInsufficientResources")]
    pub const InsufficientResources: Self = Self(0x11);
}

unsafe impl Encode for CBATTError {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for CBATTError {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}
