//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Indicates whether delivery of data should be guaranteed.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MCSessionSendDataMode(pub NSInteger);
impl MCSessionSendDataMode {
    /// The framework should guarantee delivery of each message, enqueueing and retransmitting data as needed, and ensuring in-order delivery.
    ///
    /// ## Discussion
    ///
    /// Use this message type for application-critical data.
    ///
    ///
    #[doc(alias = "MCSessionSendDataReliable")]
    pub const Reliable: Self = Self(0);
    /// Messages to peers should be sent immediately without socket-level queueing. If a message cannot be sent immediately, it should be dropped. The order of messages is not guaranteed.
    ///
    /// ## Discussion
    ///
    /// Use this message type for data that ceases to be relevant if delayed, such as real-time gaming data.
    ///
    ///
    #[doc(alias = "MCSessionSendDataUnreliable")]
    pub const Unreliable: Self = Self(1);
}

unsafe impl Encode for MCSessionSendDataMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MCSessionSendDataMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Indicates the current state of a given peer within a session.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MCSessionState(pub NSInteger);
impl MCSessionState {
    /// The peer is not (or is no longer) in this session.
    #[doc(alias = "MCSessionStateNotConnected")]
    pub const NotConnected: Self = Self(0);
    /// A connection to the peer is currently being established.
    #[doc(alias = "MCSessionStateConnecting")]
    pub const Connecting: Self = Self(1);
    /// The peer is connected to this session.
    #[doc(alias = "MCSessionStateConnected")]
    pub const Connected: Self = Self(2);
}

unsafe impl Encode for MCSessionState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MCSessionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Indicates whether a session should use encryption when communicating with nearby peers.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MCEncryptionPreference(pub NSInteger);
impl MCEncryptionPreference {
    /// The session prefers to use encryption, but accepts unencrypted connections. A connection uses encryption when all the peers choose either [`MCEncryptionOptional`](https://developer.apple.com/documentation/multipeerconnectivity/mcencryptionpreference/optional) or [`MCEncryptionRequired`](https://developer.apple.com/documentation/multipeerconnectivity/mcencryptionpreference/required). If some peers choose [`MCEncryptionNone`](https://developer.apple.com/documentation/multipeerconnectivity/mcencryptionpreference/none), then the session will not be encrypted. For this reason, if some peers running your app can be configured without encryption, you should always assume that the session is unencrypted.
    #[doc(alias = "MCEncryptionOptional")]
    pub const Optional: Self = Self(0);
    /// The session requires encryption.
    #[doc(alias = "MCEncryptionRequired")]
    pub const Required: Self = Self(1);
    /// The session should not be encrypted.
    #[doc(alias = "MCEncryptionNone")]
    pub const None: Self = Self(2);
}

unsafe impl Encode for MCEncryptionPreference {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MCEncryptionPreference {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// The minimum number of peers that a session can support, including the local peer.
    pub static kMCSessionMinimumNumberOfPeers: NSUInteger;
}

extern "C" {
    /// The maximum number of peers that a session can support, including the local peer.
    pub static kMCSessionMaximumNumberOfPeers: NSUInteger;
}

extern_class!(
    /// An `MCSession` object enables and manages communication among all peers in a Multipeer Connectivity session.
    ///
    /// ### Initiating a Session
    ///
    /// To set up a session:
    ///
    /// 1. Use the [`initWithDisplayName:`](https://developer.apple.com/documentation/multipeerconnectivity/mcpeerid/init(displayname:)) method of the [`MCPeerID`](https://developer.apple.com/documentation/multipeerconnectivity/mcpeerid) to create a peer ID that represents the local peer, or retrieve a peer ID that you previously archived (to maintain a stable peer ID over time).
    ///
    /// 2. Use the peer ID with the method [`initWithPeer:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/init(peer:)) to initialize the session object.
    ///
    /// 3. Invite peers to join the session using an [`MCNearbyServiceBrowser`](https://developer.apple.com/documentation/multipeerconnectivity/mcnearbyservicebrowser) object, an [`MCBrowserViewController`](https://developer.apple.com/documentation/multipeerconnectivity/mcbrowserviewcontroller) object, or your own peer discovery code. (Sessions currently support up to 8 peers, including the local peer.)
    ///
    /// 4. Set up an [`MCNearbyServiceAdvertiser`](https://developer.apple.com/documentation/multipeerconnectivity/mcnearbyserviceadvertiser) object or [`MCAdvertiserAssistant`](https://developer.apple.com/documentation/multipeerconnectivity/mcadvertiserassistant) object to allow other devices to ask your app to join a session that they create.
    ///
    /// If you use one of the framework’s browser objects for peer discovery, when a peer accepts an invitation, the session calls its delegate object’s [`session:peer:didChangeState:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsessiondelegate/session(_:peer:didchange:)) method with [`MCSessionStateConnected`](https://developer.apple.com/documentation/multipeerconnectivity/mcsessionstate/connected) as the new state, along with an object that tells you which peer became connected. See Creating a Session for related methods.
    ///
    /// If instead you write your own peer discovery code, you are responsible for managing the connection manually. See the [Managing Peers Manually](https://developer.apple.com/documentation/multipeerconnectivity/mcsession#managing-peers-manually) section for more information.
    ///
    /// ### Communicating with Peers
    ///
    /// Once you have set up the session, your app can send data to other peers by calling one of the following methods, found in Sending Data and Resources:
    ///
    /// - [`sendData:toPeers:withMode:error:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/send(_:topeers:with:)) sends an `NSData` object to the specified peers.
    ///
    ///   On each recipient device, the delegate object’s [`session:didReceiveData:fromPeer:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsessiondelegate/session(_:didreceive:frompeer:)) method is called with the data object when the data has been fully received.
    ///
    /// - [`sendResourceAtURL:withName:toPeer:withCompletionHandler:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/sendresource(at:withname:topeer:withcompletionhandler:)) sends the contents from an `NSURL` object to the specified peer. The URL can be either a local file URL or a web URL. The `completionHandler` block is called when the resource is fully received by the recipient peer or when an error occurs during transmission.
    ///
    ///   This method returns an `NSProgress` object that you can use to cancel the transfer or check the current status of the transfer.
    ///
    ///   On the recipient device, the session calls its delegate object’s [`session:didStartReceivingResourceWithName:fromPeer:withProgress:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsessiondelegate/session(_:didstartreceivingresourcewithname:frompeer:with:)) method when the device begins receiving the resource, and calls its [`session:didFinishReceivingResourceWithName:fromPeer:atURL:withError:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsessiondelegate/session(_:didfinishreceivingresourcewithname:frompeer:at:witherror:)) method when the resource has been fully received or when an error occurs.
    ///
    /// - [`startStreamWithName:toPeer:error:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/startstream(withname:topeer:)) creates a connected byte stream (`NSOutputStream`) that you can use to send data to the specified peer.
    ///
    ///   On the recipient device, the session calls its delegate object’s [`session:didReceiveStream:withName:fromPeer:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsessiondelegate/session(_:didreceive:withname:frompeer:)) method with an `NSInputStream` object that represents the other endpoint of communication.
    ///
    ///   On both sides, your code must set the stream’s delegate, schedule the stream on a run loop, and open the stream. Your code must also implement stream delegate methods to manage sending and receiving stream data.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Delegate calls occur on a private operation queue. If your app needs to perform an action on a particular run loop or operation queue, its delegate method should explicitly dispatch or schedule that work.
    ///
    ///
    ///
    /// </div>
    /// ### Managing Peers Manually
    ///
    /// If instead of using the framework’s browser and advertiser objects to perform peer discovery, you decide to write your own peer discovery code (with `NSNetService` or the Bonjour C API, for example), you can manually connect nearby peers into a session. To do this:
    ///
    /// 1. Establish a connection from your app to nearby peers, and exchange peer IDs with those peers.
    ///
    /// Each peer should serialize its own local `MCPeerID` object with `NSKeyedArchiver`, and the receiving peer should unserialize it with `NSKeyedUnarchiver`.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Do not attempt to construct a peer ID object for a nonlocal peer using [`initWithDisplayName:`](https://developer.apple.com/documentation/multipeerconnectivity/mcpeerid/init(displayname:)). A peer ID object must be constructed _on the device that it represents_.
    ///
    ///
    ///
    /// </div>
    /// 2. Exchange connection data. After you have obtained the nearby peer’s ID object, call [`nearbyConnectionDataForPeer:withCompletionHandler:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/nearbyconnectiondata(forpeer:withcompletionhandler:)) to obtain a connection data object specific to that nearby peer.
    ///
    /// When the completion handler block is called, send the resulting connection data object to that peer.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Each device in the session must perform this step for each nonlocal peer in the session. So if there are four devices in the session, each device must generate a connection data object for each of the other three devices.
    ///
    ///
    ///
    /// </div>
    /// 3. When your app receives connection data from another peer, it must call [`connectPeer:withNearbyConnectionData:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/connectpeer(_:withnearbyconnectiondata:)) to add that peer to the session.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Each of the nonlocal peers must also call [`connectPeer:withNearbyConnectionData:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/connectpeer(_:withnearbyconnectiondata:)) with the connection data that it received from your app and other nonlocal peers.
    ///
    ///
    ///
    /// </div>
    /// You can also cancel an outstanding connection attempt by calling [`cancelConnectPeer:`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/cancelconnectpeer(_:)). These methods are described in the Managing Peers Manually group.
    ///
    /// ### Disconnecting
    ///
    /// To leave a session, your app must call [`disconnect`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession/disconnect()). For more details, see Leaving a Session.
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MCSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MCSession {}
);

impl MCSession {
    extern_methods!(
        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(initWithPeer:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPeer(this: Allocated<Self>, my_peer_id: &MCPeerID) -> Retained<Self>;

        #[cfg(feature = "MCPeerID")]
        /// # Safety
        ///
        /// `identity` generic should be of the correct type.
        #[unsafe(method(initWithPeer:securityIdentity:encryptionPreference:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPeer_securityIdentity_encryptionPreference(
            this: Allocated<Self>,
            my_peer_id: &MCPeerID,
            identity: Option<&NSArray>,
            encryption_preference: MCEncryptionPreference,
        ) -> Retained<Self>;

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(sendData:toPeers:withMode:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendData_toPeers_withMode_error(
            &self,
            data: &NSData,
            peer_i_ds: &NSArray<MCPeerID>,
            mode: MCSessionSendDataMode,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(disconnect))]
        #[unsafe(method_family = none)]
        pub unsafe fn disconnect(&self);

        #[cfg(all(feature = "MCPeerID", feature = "block2"))]
        #[unsafe(method(sendResourceAtURL:withName:toPeer:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendResourceAtURL_withName_toPeer_withCompletionHandler(
            &self,
            resource_url: &NSURL,
            resource_name: &NSString,
            peer_id: &MCPeerID,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        ) -> Option<Retained<NSProgress>>;

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(startStreamWithName:toPeer:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn startStreamWithName_toPeer_error(
            &self,
            stream_name: &NSString,
            peer_id: &MCPeerID,
        ) -> Result<Retained<NSOutputStream>, Retained<NSError>>;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn MCSessionDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn MCSessionDelegate>>);

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(myPeerID))]
        #[unsafe(method_family = none)]
        pub unsafe fn myPeerID(&self) -> Retained<MCPeerID>;

        #[unsafe(method(securityIdentity))]
        #[unsafe(method_family = none)]
        pub unsafe fn securityIdentity(&self) -> Option<Retained<NSArray>>;

        #[unsafe(method(encryptionPreference))]
        #[unsafe(method_family = none)]
        pub unsafe fn encryptionPreference(&self) -> MCEncryptionPreference;

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(connectedPeers))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectedPeers(&self) -> Retained<NSArray<MCPeerID>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MCSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// The `MCSessionDelegate` protocol defines methods that a delegate of the `MCSession` class can implement to handle session-related events. For more information, see [`MCSession`](https://developer.apple.com/documentation/multipeerconnectivity/mcsession).
    ///
    /// ## Overview
    ///
    /// Delegate calls occur on a private serial queue. If your app needs to perform an action on a particular run loop or operation queue, its delegate method should explicitly dispatch or schedule that work.
    ///
    ///
    pub unsafe trait MCSessionDelegate: NSObjectProtocol {
        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:peer:didChangeState:))]
        #[unsafe(method_family = none)]
        unsafe fn session_peer_didChangeState(
            &self,
            session: &MCSession,
            peer_id: &MCPeerID,
            state: MCSessionState,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:didReceiveData:fromPeer:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveData_fromPeer(
            &self,
            session: &MCSession,
            data: &NSData,
            peer_id: &MCPeerID,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:didReceiveStream:withName:fromPeer:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveStream_withName_fromPeer(
            &self,
            session: &MCSession,
            stream: &NSInputStream,
            stream_name: &NSString,
            peer_id: &MCPeerID,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:didStartReceivingResourceWithName:fromPeer:withProgress:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didStartReceivingResourceWithName_fromPeer_withProgress(
            &self,
            session: &MCSession,
            resource_name: &NSString,
            peer_id: &MCPeerID,
            progress: &NSProgress,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:didFinishReceivingResourceWithName:fromPeer:atURL:withError:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didFinishReceivingResourceWithName_fromPeer_atURL_withError(
            &self,
            session: &MCSession,
            resource_name: &NSString,
            peer_id: &MCPeerID,
            local_url: Option<&NSURL>,
            error: Option<&NSError>,
        );

        #[cfg(all(feature = "MCPeerID", feature = "block2"))]
        /// # Safety
        ///
        /// `certificate` generic should be of the correct type.
        #[optional]
        #[unsafe(method(session:didReceiveCertificate:fromPeer:certificateHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveCertificate_fromPeer_certificateHandler(
            &self,
            session: &MCSession,
            certificate: Option<&NSArray>,
            peer_id: &MCPeerID,
            certificate_handler: &block2::DynBlock<dyn Fn(Bool)>,
        );
    }
);

/// MCSessionCustomDiscovery.
impl MCSession {
    extern_methods!(
        #[cfg(all(feature = "MCPeerID", feature = "block2"))]
        #[unsafe(method(nearbyConnectionDataForPeer:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nearbyConnectionDataForPeer_withCompletionHandler(
            &self,
            peer_id: &MCPeerID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(connectPeer:withNearbyConnectionData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectPeer_withNearbyConnectionData(
            &self,
            peer_id: &MCPeerID,
            data: &NSData,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(cancelConnectPeer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelConnectPeer(&self, peer_id: &MCPeerID);
    );
}
