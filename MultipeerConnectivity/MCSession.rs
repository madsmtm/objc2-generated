//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/multipeerconnectivity/mcsessionsenddatamode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MCSessionSendDataMode(pub NSInteger);
impl MCSessionSendDataMode {
    #[doc(alias = "MCSessionSendDataReliable")]
    pub const Reliable: Self = Self(0);
    #[doc(alias = "MCSessionSendDataUnreliable")]
    pub const Unreliable: Self = Self(1);
}

unsafe impl Encode for MCSessionSendDataMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MCSessionSendDataMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/multipeerconnectivity/mcsessionstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MCSessionState(pub NSInteger);
impl MCSessionState {
    #[doc(alias = "MCSessionStateNotConnected")]
    pub const NotConnected: Self = Self(0);
    #[doc(alias = "MCSessionStateConnecting")]
    pub const Connecting: Self = Self(1);
    #[doc(alias = "MCSessionStateConnected")]
    pub const Connected: Self = Self(2);
}

unsafe impl Encode for MCSessionState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MCSessionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/multipeerconnectivity/mcencryptionpreference?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct MCEncryptionPreference(pub NSInteger);
impl MCEncryptionPreference {
    #[doc(alias = "MCEncryptionOptional")]
    pub const Optional: Self = Self(0);
    #[doc(alias = "MCEncryptionRequired")]
    pub const Required: Self = Self(1);
    #[doc(alias = "MCEncryptionNone")]
    pub const None: Self = Self(2);
}

unsafe impl Encode for MCEncryptionPreference {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for MCEncryptionPreference {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/multipeerconnectivity/kmcsessionminimumnumberofpeers?language=objc)
    pub static kMCSessionMinimumNumberOfPeers: NSUInteger;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/multipeerconnectivity/kmcsessionmaximumnumberofpeers?language=objc)
    pub static kMCSessionMaximumNumberOfPeers: NSUInteger;
}

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/multipeerconnectivity/mcsession?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct MCSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for MCSession {}
);

impl MCSession {
    extern_methods!(
        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(initWithPeer:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPeer(this: Allocated<Self>, my_peer_id: &MCPeerID) -> Retained<Self>;

        #[cfg(feature = "MCPeerID")]
        /// # Safety
        ///
        /// `identity` generic should be of the correct type.
        #[unsafe(method(initWithPeer:securityIdentity:encryptionPreference:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithPeer_securityIdentity_encryptionPreference(
            this: Allocated<Self>,
            my_peer_id: &MCPeerID,
            identity: Option<&NSArray>,
            encryption_preference: MCEncryptionPreference,
        ) -> Retained<Self>;

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(sendData:toPeers:withMode:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendData_toPeers_withMode_error(
            &self,
            data: &NSData,
            peer_i_ds: &NSArray<MCPeerID>,
            mode: MCSessionSendDataMode,
        ) -> Result<(), Retained<NSError>>;

        #[unsafe(method(disconnect))]
        #[unsafe(method_family = none)]
        pub unsafe fn disconnect(&self);

        #[cfg(all(feature = "MCPeerID", feature = "block2"))]
        #[unsafe(method(sendResourceAtURL:withName:toPeer:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendResourceAtURL_withName_toPeer_withCompletionHandler(
            &self,
            resource_url: &NSURL,
            resource_name: &NSString,
            peer_id: &MCPeerID,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        ) -> Option<Retained<NSProgress>>;

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(startStreamWithName:toPeer:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn startStreamWithName_toPeer_error(
            &self,
            stream_name: &NSString,
            peer_id: &MCPeerID,
        ) -> Result<Retained<NSOutputStream>, Retained<NSError>>;

        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn MCSessionDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn MCSessionDelegate>>);

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(myPeerID))]
        #[unsafe(method_family = none)]
        pub unsafe fn myPeerID(&self) -> Retained<MCPeerID>;

        #[unsafe(method(securityIdentity))]
        #[unsafe(method_family = none)]
        pub unsafe fn securityIdentity(&self) -> Option<Retained<NSArray>>;

        #[unsafe(method(encryptionPreference))]
        #[unsafe(method_family = none)]
        pub unsafe fn encryptionPreference(&self) -> MCEncryptionPreference;

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(connectedPeers))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectedPeers(&self) -> Retained<NSArray<MCPeerID>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl MCSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/multipeerconnectivity/mcsessiondelegate?language=objc)
    pub unsafe trait MCSessionDelegate: NSObjectProtocol {
        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:peer:didChangeState:))]
        #[unsafe(method_family = none)]
        unsafe fn session_peer_didChangeState(
            &self,
            session: &MCSession,
            peer_id: &MCPeerID,
            state: MCSessionState,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:didReceiveData:fromPeer:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveData_fromPeer(
            &self,
            session: &MCSession,
            data: &NSData,
            peer_id: &MCPeerID,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:didReceiveStream:withName:fromPeer:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveStream_withName_fromPeer(
            &self,
            session: &MCSession,
            stream: &NSInputStream,
            stream_name: &NSString,
            peer_id: &MCPeerID,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:didStartReceivingResourceWithName:fromPeer:withProgress:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didStartReceivingResourceWithName_fromPeer_withProgress(
            &self,
            session: &MCSession,
            resource_name: &NSString,
            peer_id: &MCPeerID,
            progress: &NSProgress,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(session:didFinishReceivingResourceWithName:fromPeer:atURL:withError:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didFinishReceivingResourceWithName_fromPeer_atURL_withError(
            &self,
            session: &MCSession,
            resource_name: &NSString,
            peer_id: &MCPeerID,
            local_url: Option<&NSURL>,
            error: Option<&NSError>,
        );

        #[cfg(all(feature = "MCPeerID", feature = "block2"))]
        /// # Safety
        ///
        /// `certificate` generic should be of the correct type.
        #[optional]
        #[unsafe(method(session:didReceiveCertificate:fromPeer:certificateHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveCertificate_fromPeer_certificateHandler(
            &self,
            session: &MCSession,
            certificate: Option<&NSArray>,
            peer_id: &MCPeerID,
            certificate_handler: &block2::DynBlock<dyn Fn(Bool)>,
        );
    }
);

/// MCSessionCustomDiscovery.
impl MCSession {
    extern_methods!(
        #[cfg(all(feature = "MCPeerID", feature = "block2"))]
        #[unsafe(method(nearbyConnectionDataForPeer:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn nearbyConnectionDataForPeer_withCompletionHandler(
            &self,
            peer_id: &MCPeerID,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSData, *mut NSError)>,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(connectPeer:withNearbyConnectionData:))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectPeer_withNearbyConnectionData(
            &self,
            peer_id: &MCPeerID,
            data: &NSData,
        );

        #[cfg(feature = "MCPeerID")]
        #[unsafe(method(cancelConnectPeer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelConnectPeer(&self, peer_id: &MCPeerID);
    );
}
