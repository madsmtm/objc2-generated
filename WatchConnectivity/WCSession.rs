//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// Constants indicating the activation state of a session.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct WCSessionActivationState(pub NSInteger);
impl WCSessionActivationState {
    /// The session is not activated. When in this state, no communication occurs between the Watch app and iOS app. It is a programmer error to try to send data to the counterpart app while in this state.
    #[doc(alias = "WCSessionActivationStateNotActivated")]
    pub const NotActivated: Self = Self(0);
    /// The session was active but is transitioning to the deactivated state. The session’s delegate object may still receive data while in this state, but it is a programmer error to try to send data to the counterpart app.
    #[doc(alias = "WCSessionActivationStateInactive")]
    pub const Inactive: Self = Self(1);
    /// The session is active and the Watch app and iOS app may communicate with each other freely.
    #[doc(alias = "WCSessionActivationStateActivated")]
    pub const Activated: Self = Self(2);
}

unsafe impl Encode for WCSessionActivationState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for WCSessionActivationState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// The object that initiates communication between a WatchKit extension and its companion iOS app.
    ///
    /// ## Overview
    ///
    /// Your iOS app and watchOS app must both create and configure an instance of this class at some point during their execution. When both session objects are active, the two processes can communicate immediately by sending messages back and forth. When only one session is active, the active session may still send updates and transfer files, but those transfers happen opportunistically in the background.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  The session object must be configured and activated before you attempt to send messages or obtain information about the state of the connection. Before activating the session, you may call the [`isSupported`](https://developer.apple.com/documentation/watchconnectivity/wcsession/issupported()) method to make sure that current device can use the Watch Connectivity framework.
    ///
    ///
    ///
    /// </div>
    /// ### Configuring and Activating the Session
    ///
    /// To configure and activate the session, assign a [`delegate`](https://developer.apple.com/documentation/watchconnectivity/wcsession/delegate) to the default session object and call that object’s [`activateSession`](https://developer.apple.com/documentation/watchconnectivity/wcsession/activate()) method, as shown in Listing 1. Your WatchKit extension and iOS app must each configure their own session object. Activating the session establishes a connection between the two apps.
    ///
    /// Listing 1. Configuring and activating a session
    ///
    /// (TODO tabnav: TabNavigator { tabs: [TabItem { title: "Swift", content: [CodeListing { syntax: Some("swift"), code: ["if WCSession.isSupported() {", "    let session = WCSession.defaultSession()", "    session.delegate = self", "    session.activateSession()", "}"], metadata: None }] }, TabItem { title: "Objective-C", content: [CodeListing { syntax: Some("objc"), code: ["if ([WCSession isSupported]) {", "   WCSession* session = [WCSession defaultSession];", "   session.delegate = self;", "   [session activateSession];", "}"], metadata: None }] }] })
    /// To support the pairing of multiple watches to the same iPhone, the session delegate of both your apps must implement the activation APIs. Implementing the [`session:activationDidCompleteWithState:error:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/session(_:activationdidcompletewith:error:)) method lets the session know that your app supports asynchronous activation. Implementing the [`sessionDidBecomeInactive:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/sessiondidbecomeinactive(_:)) and [`sessionDidDeactivate:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/sessiondiddeactivate(_:)) methods in the session delegate of your iOS app is required to manage transitions between different Apple Watches.
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  If your delegate does not implement the appropriate methods for asynchronous activation and activation state changes, your app opts out of multiple Apple Watch support altogether. Opting out has important implications for your app when the user switches from one Apple Watch to another. When a switch occurs, your app’s session is deactivated. When your app subsequently moves to the background, the system terminates your app. (Background execution modes do not prevent the termination of your app.) The next time your app launches, it connects with the new Apple Watch.
    ///
    ///
    ///
    /// </div>
    /// Apps may initiate transfers only when the session is active—that is, the [`activationState`](https://developer.apple.com/documentation/watchconnectivity/wcsession/activationstate) is set to [`WCSessionActivationStateActivated`](https://developer.apple.com/documentation/watchconnectivity/wcsessionactivationstate/activated). Your iOS app should also check the [`paired`](https://developer.apple.com/documentation/watchconnectivity/wcsession/ispaired) and [`watchAppInstalled`](https://developer.apple.com/documentation/watchconnectivity/wcsession/iswatchappinstalled) properties before sending any background messages, and it may need to check other properties as needed. Most of the properties you need to check are valid only while the session is active. At other times, the values of the properties may be undefined. The [`activationState`](https://developer.apple.com/documentation/watchconnectivity/wcsession/activationstate) property is always valid and contains the current activation state of the session. For details, see the corresponding property description.
    ///
    /// For more information about implementing the methods of the delegate object, see [`WCSessionDelegate`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate).
    ///
    /// ### Supporting Communication with Multiple Apple Watches
    ///
    /// An iPhone running iOS 9.3 or later may pair with more than one Apple Watch running watchOS 2.2 or later. In your Watch app, you should support asynchronous activation of the session, but doing so is not required. In your iOS app, you must support asynchronous activation of the session and also monitor the activation and deactivation of the session object. You do this by implementing the following methods in your session delegate:
    ///
    /// - [`session:activationDidCompleteWithState:error:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/session(_:activationdidcompletewith:error:))
    ///
    /// - [`sessionDidBecomeInactive:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/sessiondidbecomeinactive(_:))
    ///
    /// - [`sessionDidDeactivate:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/sessiondiddeactivate(_:))
    ///
    /// [Figure 1](/documentation/watchconnectivity/wcsession#1965795) shows the sequence of events that happen when the user switches from one Apple Watch to another. When automatic switching is enabled, only one Apple Watch at a time actually communicates with the iOS app. The Watch app on each watch stays in the active state, but the iOS app moves to the inactive and deactivated states during a switch. Moving to the inactive state gives the session a small amount of time to deliver any data that has already been received. As soon as that data is delivered, the session moves to the deactivated state. At that point, the iOS app must call the [`activateSession`](https://developer.apple.com/documentation/watchconnectivity/wcsession/activate()) method again to connect to the newly active watch, which in this example is now the second Apple Watch.
    ///
    ///
    /// ![](https://docs-assets.developer.apple.com/published/e844953b02347a3418fbdd7543cf0e5b/media-1965795%402x.png)
    ///
    ///
    /// Your iOS app can use the [`watchDirectoryURL`](https://developer.apple.com/documentation/watchconnectivity/wcsession/watchdirectoryurl) property to store data that is specific to only one instance of your Watch app running on a particular Apple Watch. In most cases, the data you display in each instance of your Watch app is the same. However, you might use this directory to store configuration data, preferences, or other data files that your iOS app needs to interact properly with your Watch app. If you do, use the activation and deactivation process to update your iOS app.
    ///
    /// For more information about handling session activation and deactivation, see [`WCSessionDelegate`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate).
    ///
    /// ### Communicating with the Counterpart App
    ///
    /// You may initiate data transfers to a counterpart app only when the [`activationState`](https://developer.apple.com/documentation/watchconnectivity/wcsession/activationstate) property is set to [`WCSessionActivationStateActivated`](https://developer.apple.com/documentation/watchconnectivity/wcsessionactivationstate/activated). The iOS app should ensure the Watch app is installed before trying to initiate transfers. You initiate transfers in any of the following ways:
    ///
    /// - Use the [`updateApplicationContext:error:`](https://developer.apple.com/documentation/watchconnectivity/wcsession/updateapplicationcontext(_:)) method to communicate recent state information to the counterpart. When the counterpart wakes, it can use this information to update its own state. For example, an iOS app that supports Background App Refresh can use part of its background execution time to update the corresponding Watch app. This method overwrites the previous data dictionary, so use this method when your app needs only the most recent data values.
    ///
    /// - Use the [`sendMessage:replyHandler:errorHandler:`](https://developer.apple.com/documentation/watchconnectivity/wcsession/sendmessage(_:replyhandler:errorhandler:)) or [`sendMessageData:replyHandler:errorHandler:`](https://developer.apple.com/documentation/watchconnectivity/wcsession/sendmessagedata(_:replyhandler:errorhandler:)) method to transfer data to a reachable counterpart. These methods are intended for immediate communication between your iOS app and WatchKit extension. The [`reachable`](https://developer.apple.com/documentation/watchconnectivity/wcsession/isreachable) property must currently be [`true`](https://developer.apple.com/documentation/swift/true) for these methods to succeed.
    ///
    /// - Use the [`transferUserInfo:`](https://developer.apple.com/documentation/watchconnectivity/wcsession/transferuserinfo(_:)) method to transfer a dictionary of data in the background. The dictionaries you send are queued for delivery to the counterpart and transfers continue when the current app is suspended or terminated.
    ///
    /// - Use the [`transferFile:metadata:`](https://developer.apple.com/documentation/watchconnectivity/wcsession/transferfile(_:metadata:)) method to transfer files in the background. Use this method in cases where you want to send more than a dictionary of values. For example, use this method to send images or file-based documents.
    ///
    /// - In iOS, use the [`transferCurrentComplicationUserInfo:`](https://developer.apple.com/documentation/watchconnectivity/wcsession/transfercurrentcomplicationuserinfo(_:)) method to send data related to your Watch app’s complication. Use of this method counts against your complication’s time budget.
    ///
    /// When sending messages to a counterpart, background messages are placed on a queue and transmitted in order. Incoming messages are similarly queued and delivered to the delegate in the order in which they were received. Data sent using the [`sendMessage:replyHandler:errorHandler:`](https://developer.apple.com/documentation/watchconnectivity/wcsession/sendmessage(_:replyhandler:errorhandler:)), [`sendMessageData:replyHandler:errorHandler:`](https://developer.apple.com/documentation/watchconnectivity/wcsession/sendmessagedata(_:replyhandler:errorhandler:)), and [`transferCurrentComplicationUserInfo:`](https://developer.apple.com/documentation/watchconnectivity/wcsession/transfercurrentcomplicationuserinfo(_:)) methods has a higher priority and is transmitted right away. All messages received by your app are delivered to the session delegate serially on a background thread.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Remember that background transfers are not delivered immediately. The system sends data as quickly as possible but transfers are not instantaneous, and the system may delay transfers slightly to improve power usage. Also, sending a large data file requires a commensurate amount of time to transmit the data to the other device and process it on the receiving side.
    ///
    ///
    ///
    /// </div>
    /// When sending messages, send only the data that your app needs. All transfers involve sending data wireless to the counterpart app, which consumes power. Rather than sending all of your data every time, send only the items that have changed.
    ///
    /// Be prepared to handle errors and provide a graceful fallback when data cannot be transferred. Errors can occur if there is insufficient space for the data on the target device, if the data itself is malformed, or if there is a communications error. Check for errors in your handler code and take appropriate actions.
    ///
    ///
    /// -------------------------------- WCSession --------------------------------
    /// The default session is used to communicate between two counterpart apps
    /// (i.e. iOS app and its native WatchKit extension). The session provides
    /// methods for sending, receiving, and tracking state.
    ///
    /// On start up an app should set a delegate on the default session and call
    /// activate. This will allow the system to populate the state properties and
    /// deliver any outstanding background transfers.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct WCSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for WCSession {}
);

impl WCSession {
    extern_methods!(
        /// Check if session is supported on this iOS device. Session is always available on WatchOS
        #[unsafe(method(isSupported))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSupported() -> bool;

        /// Use the default session for all transferring of content and state monitoring.
        #[unsafe(method(defaultSession))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultSession() -> Retained<WCSession>;

        /// Use the default session instead.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// A delegate must exist before the session will allow sends.
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn WCSessionDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn WCSessionDelegate>>);

        /// The default session must be activated on startup before the session's properties contain correct values and will begin receiving delegate callbacks. Calling activate without a delegate set is undefined. If the WCSessionDelegate session:activationDidCompleteWithState:error: is implemented this method becomes an asynchronous call.
        #[unsafe(method(activateSession))]
        #[unsafe(method_family = none)]
        pub unsafe fn activateSession(&self);

        /// The state of the current session
        #[unsafe(method(activationState))]
        #[unsafe(method_family = none)]
        pub unsafe fn activationState(&self) -> WCSessionActivationState;

        /// Whether or not there is more content for the session to deliver
        #[unsafe(method(hasContentPending))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasContentPending(&self) -> bool;

        /// Check if iOS device is paired to a watch
        #[unsafe(method(isPaired))]
        #[unsafe(method_family = none)]
        pub unsafe fn isPaired(&self) -> bool;

        /// Check if the user has the Watch app installed
        #[unsafe(method(isWatchAppInstalled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isWatchAppInstalled(&self) -> bool;

        /// Check if the user has the Watch app's complication enabled
        #[unsafe(method(isComplicationEnabled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isComplicationEnabled(&self) -> bool;

        /// The number of calls remaining to transferCurrentComplicationUserInfo: before the system starts transferring the complicationUserInfo as regular userInfos. If this is 0, the complicationUserInfo will be transferred as regular userInfos. Count will be 0 whenever the complication is not enabled
        #[unsafe(method(remainingComplicationUserInfoTransfers))]
        #[unsafe(method_family = none)]
        pub unsafe fn remainingComplicationUserInfoTransfers(&self) -> NSUInteger;

        /// Use this directory to persist any data specific to the selected Watch. The location of the URL will change when the selected Watch changes. This directory will be deleted upon next launch if the watch app is uninstalled for the selected Watch, or that Watch is unpaired. If the watch app is not installed for the selected Watch the value will be nil.
        #[unsafe(method(watchDirectoryURL))]
        #[unsafe(method_family = none)]
        pub unsafe fn watchDirectoryURL(&self) -> Option<Retained<NSURL>>;

        /// Check if the companion app is installed on the paired iPhone. This only applies to Watch apps that can run independently.
        #[unsafe(method(isCompanionAppInstalled))]
        #[unsafe(method_family = none)]
        pub unsafe fn isCompanionAppInstalled(&self) -> bool;

        /// The counterpart app must be reachable for a send message to succeed.
        #[unsafe(method(isReachable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isReachable(&self) -> bool;

        /// Reachability in the Watch app requires the paired iOS device to have been unlocked at least once after reboot. This property can be used to determine if the iOS device needs to be unlocked. If the reachable property is set to NO it may be because the iOS device has rebooted and needs to be unlocked. If this is the case, the Watch can show a prompt to the user suggesting they unlock their paired iOS device.
        #[unsafe(method(iOSDeviceNeedsUnlockAfterRebootForReachability))]
        #[unsafe(method_family = none)]
        pub unsafe fn iOSDeviceNeedsUnlockAfterRebootForReachability(&self) -> bool;

        #[cfg(feature = "block2")]
        /// Clients can use this method to send messages to the counterpart app. Clients wishing to receive a reply to a particular message should pass in a replyHandler block. If the message cannot be sent or if the reply could not be received, the errorHandler block will be invoked with an error. If both a replyHandler and an errorHandler are specified, then exactly one of them will be invoked. Messages can only be sent while the sending app is running. If the sending app exits before the message is dispatched the send will fail. If the counterpart app is not running the counterpart app will be launched upon receiving the message (iOS counterpart app only). The message dictionary can only accept the property list types.
        ///
        /// # Safety
        ///
        /// `message` generic should be of the correct type.
        #[unsafe(method(sendMessage:replyHandler:errorHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendMessage_replyHandler_errorHandler(
            &self,
            message: &NSDictionary<NSString, AnyObject>,
            reply_handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<NSDictionary<NSString, AnyObject>>)>,
            >,
            error_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSError>)>>,
        );

        #[cfg(feature = "block2")]
        /// Clients can use this method to send message data. All the policies of send message apply to send message data. Send message data is meant for clients that have an existing transfer format and do not need the convenience of the send message dictionary.
        #[unsafe(method(sendMessageData:replyHandler:errorHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendMessageData_replyHandler_errorHandler(
            &self,
            data: &NSData,
            reply_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSData>)>>,
            error_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSError>)>>,
        );

        /// Setting the applicationContext is a way to transfer the latest state of an app. After updating the applicationContext, the system initiates the data transfer at an appropriate time, which can occur after the app exits. The counterpart app will receive a delegate callback on next launch if the applicationContext has successfully arrived. If there is no app context, it should be updated with an empty dictionary. The applicationContext dictionary can only accept the property list types.
        #[unsafe(method(applicationContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn applicationContext(&self) -> Retained<NSDictionary<NSString, AnyObject>>;

        /// # Safety
        ///
        /// `application_context` generic should be of the correct type.
        #[unsafe(method(updateApplicationContext:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn updateApplicationContext_error(
            &self,
            application_context: &NSDictionary<NSString, AnyObject>,
        ) -> Result<(), Retained<NSError>>;

        /// Stores the most recently received applicationContext from the counterpart app.
        #[unsafe(method(receivedApplicationContext))]
        #[unsafe(method_family = none)]
        pub unsafe fn receivedApplicationContext(
            &self,
        ) -> Retained<NSDictionary<NSString, AnyObject>>;

        #[cfg(feature = "WCSessionUserInfoTransfer")]
        /// The system will enqueue the user info dictionary and transfer it to the counterpart app at an opportune time. The transfer of user info will continue after the sending app has exited. The counterpart app will receive a delegate callback on next launch if the file has successfully arrived. The userInfo dictionary can only accept the property list types.
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[unsafe(method(transferUserInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn transferUserInfo(
            &self,
            user_info: &NSDictionary<NSString, AnyObject>,
        ) -> Retained<WCSessionUserInfoTransfer>;

        #[cfg(feature = "WCSessionUserInfoTransfer")]
        /// Enqueues a user info dictionary containing the most current information for an enabled complication. If the app's complication is enabled the system will try to transfer this user info immediately. Once a current complication user info is received the system will launch the Watch App Extension in the background and allow it to update the complication content. If the current user info cannot be transferred (i.e. devices disconnected, out of background launch budget, etc.) it will wait in the outstandingUserInfoTransfers queue until next opportune time. There can only be one current complication user info in the outstandingUserInfoTransfers queue. If a current complication user info is outstanding (waiting to transfer) and -transferCurrentComplicationUserInfo: is called again with new user info, the new user info will be tagged as current and the previously current user info will be untagged. The previous user info will however stay in the queue of outstanding transfers.
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[unsafe(method(transferCurrentComplicationUserInfo:))]
        #[unsafe(method_family = none)]
        pub unsafe fn transferCurrentComplicationUserInfo(
            &self,
            user_info: &NSDictionary<NSString, AnyObject>,
        ) -> Retained<WCSessionUserInfoTransfer>;

        #[cfg(feature = "WCSessionUserInfoTransfer")]
        /// Returns an array of user info transfers that are still transferring (i.e. have not been cancelled, failed, or been received by the counterpart app).
        #[unsafe(method(outstandingUserInfoTransfers))]
        #[unsafe(method_family = none)]
        pub unsafe fn outstandingUserInfoTransfers(
            &self,
        ) -> Retained<NSArray<WCSessionUserInfoTransfer>>;

        #[cfg(feature = "WCSessionFile")]
        /// The system will enqueue the file and transfer it to the counterpart app at an opportune time. The transfer of a file will continue after the sending app has exited. The counterpart app will receive a delegate callback on next launch if the file has successfully arrived. The metadata dictionary can only accept the property list types.
        ///
        /// # Safety
        ///
        /// `metadata` generic should be of the correct type.
        #[unsafe(method(transferFile:metadata:))]
        #[unsafe(method_family = none)]
        pub unsafe fn transferFile_metadata(
            &self,
            file: &NSURL,
            metadata: Option<&NSDictionary<NSString, AnyObject>>,
        ) -> Retained<WCSessionFileTransfer>;

        #[cfg(feature = "WCSessionFile")]
        /// Returns an array of file transfers that are still transferring (i.e. have not been cancelled, failed, or been received by the counterpart app).
        #[unsafe(method(outstandingFileTransfers))]
        #[unsafe(method_family = none)]
        pub unsafe fn outstandingFileTransfers(&self) -> Retained<NSArray<WCSessionFileTransfer>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl WCSession {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A delegate protocol that defines methods for receiving messages sent by a [`WCSession`](https://developer.apple.com/documentation/watchconnectivity/wcsession) object.
    ///
    /// ## Overview
    ///
    /// Session objects are used to communicate between a WatchKit extension and the companion iOS app on a paired and active iPhone. When configuring your session object, you must specify a delegate object that implements this protocol. The session calls your delegate methods to deliver incoming data from the counterpart app and to manage session-related changes.
    ///
    /// Most methods of this protocol are optional. You implement the methods you need to respond to the data transfer operations that your apps support. However, apps must implement the [`session:activationDidCompleteWithState:error:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/session(_:activationdidcompletewith:error:)) method, supporting asynchronous activation. On iOS, you must also implement the [`sessionDidBecomeInactive:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/sessiondidbecomeinactive(_:)) and [`sessionDidDeactivate:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/sessiondiddeactivate(_:)) methods, supporting multiple Apple Watches.
    ///
    /// The [`WCSession`](https://developer.apple.com/documentation/watchconnectivity/wcsession) object calls the methods of its delegate serially, so your method implementations do not need to be reentrant. Immediate messages can be sent only while both the WatchKit extension and iOS app are running. By contrast, context updates and file transfers can be initiated at any time and delivered in the background to the other device. All transfers are delivered in the order in which they were sent.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  The methods of this protocol are called on a background thread of your app, so any code you write should be written with that fact in mind. In particular, if your method implementations initiate modifications to your app’s interface, make sure to redirect those modifications to your app’s main thread.
    ///
    ///
    ///
    /// </div>
    /// ### Supporting Communication with Multiple Apple Watches
    ///
    /// An iPhone running iOS 9.3 or later may pair with more than one Apple Watch running watchOS 2.2 or later. Implement the following methods in your session delegate:
    ///
    /// - [`session:activationDidCompleteWithState:error:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/session(_:activationdidcompletewith:error:))
    ///
    /// - [`sessionDidBecomeInactive:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/sessiondidbecomeinactive(_:)) (iOS only)
    ///
    /// - [`sessionDidDeactivate:`](https://developer.apple.com/documentation/watchconnectivity/wcsessiondelegate/sessiondiddeactivate(_:)) (iOS only)
    ///
    /// Use the activation-related methods to track the activation state of the session in your iOS app. With Auto Switch enabled on the user’s iPhone, the session automatically moves to the inactive state when the user puts on a different Apple Watch than the one that is currently active. (If Auto Switch is disabled, the user must manually select which watch is active.) While your iOS app is in the inactive state, the system finishes delivering any data that has been received before moving your app to the deactivated state. While inactive or deactivated, you cannot initiate any new transfers. When your iOS app reaches the deactivated state, call the session’s [`activateSession`](https://developer.apple.com/documentation/watchconnectivity/wcsession/activate()) method again to connect to the new Apple Watch.
    ///
    /// For more information about the flow of messages when a user switches from one Apple Watch to another, see [`WCSession`](https://developer.apple.com/documentation/watchconnectivity/wcsession).
    ///
    ///
    /// ----------------------------- WCSessionDelegate -----------------------------
    /// The session calls the delegate methods when content is received and session
    /// state changes. All delegate methods will be called on the same queue. The
    /// delegate queue is a non-main serial queue. It is the client's responsibility
    /// to dispatch to another queue if neccessary.
    pub unsafe trait WCSessionDelegate: NSObjectProtocol {
        /// Called when the session has completed activation. If session state is WCSessionActivationStateNotActivated there will be an error with more details.
        #[unsafe(method(session:activationDidCompleteWithState:error:))]
        #[unsafe(method_family = none)]
        unsafe fn session_activationDidCompleteWithState_error(
            &self,
            session: &WCSession,
            activation_state: WCSessionActivationState,
            error: Option<&NSError>,
        );

        /// Called when the session can no longer be used to modify or add any new transfers and, all interactive messages will be cancelled, but delegate callbacks for background transfers can still occur. This will happen when the selected watch is being changed.
        #[unsafe(method(sessionDidBecomeInactive:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionDidBecomeInactive(&self, session: &WCSession);

        /// Called when all delegate callbacks for the previously selected watch has occurred. The session can be re-activated for the now selected watch using activateSession.
        #[unsafe(method(sessionDidDeactivate:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionDidDeactivate(&self, session: &WCSession);

        /// Called when any of the Watch state properties change.
        #[optional]
        #[unsafe(method(sessionWatchStateDidChange:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionWatchStateDidChange(&self, session: &WCSession);

        /// Called when the installed state of the Companion app changes.
        #[optional]
        #[unsafe(method(sessionCompanionAppInstalledDidChange:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionCompanionAppInstalledDidChange(&self, session: &WCSession);

        /// Called when the reachable state of the counterpart app changes. The receiver should check the reachable property on receiving this delegate callback.
        #[optional]
        #[unsafe(method(sessionReachabilityDidChange:))]
        #[unsafe(method_family = none)]
        unsafe fn sessionReachabilityDidChange(&self, session: &WCSession);

        /// Called on the delegate of the receiver. Will be called on startup if the incoming message caused the receiver to launch.
        ///
        /// # Safety
        ///
        /// `message` generic should be of the correct type.
        #[optional]
        #[unsafe(method(session:didReceiveMessage:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveMessage(
            &self,
            session: &WCSession,
            message: &NSDictionary<NSString, AnyObject>,
        );

        #[cfg(feature = "block2")]
        /// Called on the delegate of the receiver when the sender sends a message that expects a reply. Will be called on startup if the incoming message caused the receiver to launch.
        ///
        /// # Safety
        ///
        /// `message` generic should be of the correct type.
        #[optional]
        #[unsafe(method(session:didReceiveMessage:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveMessage_replyHandler(
            &self,
            session: &WCSession,
            message: &NSDictionary<NSString, AnyObject>,
            reply_handler: &block2::DynBlock<dyn Fn(NonNull<NSDictionary<NSString, AnyObject>>)>,
        );

        /// Called on the delegate of the receiver. Will be called on startup if the incoming message data caused the receiver to launch.
        #[optional]
        #[unsafe(method(session:didReceiveMessageData:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveMessageData(&self, session: &WCSession, message_data: &NSData);

        #[cfg(feature = "block2")]
        /// Called on the delegate of the receiver when the sender sends message data that expects a reply. Will be called on startup if the incoming message data caused the receiver to launch.
        #[optional]
        #[unsafe(method(session:didReceiveMessageData:replyHandler:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveMessageData_replyHandler(
            &self,
            session: &WCSession,
            message_data: &NSData,
            reply_handler: &block2::DynBlock<dyn Fn(NonNull<NSData>)>,
        );

        /// Called on the delegate of the receiver. Will be called on startup if an applicationContext is available.
        ///
        /// # Safety
        ///
        /// `application_context` generic should be of the correct type.
        #[optional]
        #[unsafe(method(session:didReceiveApplicationContext:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveApplicationContext(
            &self,
            session: &WCSession,
            application_context: &NSDictionary<NSString, AnyObject>,
        );

        #[cfg(feature = "WCSessionUserInfoTransfer")]
        /// Called on the sending side after the user info transfer has successfully completed or failed with an error. Will be called on next launch if the sender was not running when the user info finished.
        #[optional]
        #[unsafe(method(session:didFinishUserInfoTransfer:error:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didFinishUserInfoTransfer_error(
            &self,
            session: &WCSession,
            user_info_transfer: &WCSessionUserInfoTransfer,
            error: Option<&NSError>,
        );

        /// Called on the delegate of the receiver. Will be called on startup if the user info finished transferring when the receiver was not running.
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[optional]
        #[unsafe(method(session:didReceiveUserInfo:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveUserInfo(
            &self,
            session: &WCSession,
            user_info: &NSDictionary<NSString, AnyObject>,
        );

        #[cfg(feature = "WCSessionFile")]
        /// Called on the sending side after the file transfer has successfully completed or failed with an error. Will be called on next launch if the sender was not running when the transfer finished.
        #[optional]
        #[unsafe(method(session:didFinishFileTransfer:error:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didFinishFileTransfer_error(
            &self,
            session: &WCSession,
            file_transfer: &WCSessionFileTransfer,
            error: Option<&NSError>,
        );

        #[cfg(feature = "WCSessionFile")]
        /// Called on the delegate of the receiver. Will be called on startup if the file finished transferring when the receiver was not running. The incoming file will be located in the Documents/Inbox/ folder when being delivered. The receiver must take ownership of the file by moving it to another location. The system will remove any content that has not been moved when this delegate method returns.
        #[optional]
        #[unsafe(method(session:didReceiveFile:))]
        #[unsafe(method_family = none)]
        unsafe fn session_didReceiveFile(&self, session: &WCSession, file: &WCSessionFile);
    }
);
