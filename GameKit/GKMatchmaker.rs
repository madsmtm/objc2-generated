//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// A player’s response to an invitation to join a match.
/// Possible invitee responses
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct GKInviteRecipientResponse(pub NSInteger);
impl GKInviteRecipientResponse {
    /// A response when the player accepts the invitation.
    #[doc(alias = "GKInviteRecipientResponseAccepted")]
    pub const Accepted: Self = Self(0);
    /// A response when the player rejects the invitation.
    #[doc(alias = "GKInviteRecipientResponseDeclined")]
    pub const Declined: Self = Self(1);
    /// A response when the system fails to deliver the invitation to the player.
    #[doc(alias = "GKInviteRecipientResponseFailed")]
    pub const Failed: Self = Self(2);
    /// A response when the player isn’t running a compatible version of the game.
    #[doc(alias = "GKInviteRecipientResponseIncompatible")]
    pub const Incompatible: Self = Self(3);
    /// A response when the system can’t contact the player.
    #[doc(alias = "GKInviteRecipientResponseUnableToConnect")]
    pub const UnableToConnect: Self = Self(4);
    /// A response when the invitation times out because the player doesn’t answer it.
    #[doc(alias = "GKInviteRecipientResponseNoAnswer")]
    pub const NoAnswer: Self = Self(5);
    /// The player accepted the invitation.
    #[deprecated]
    pub const GKInviteeResponseAccepted: Self = Self(GKInviteRecipientResponse::Accepted.0);
    /// The player rejected the invitation.
    #[deprecated]
    pub const GKInviteeResponseDeclined: Self = Self(GKInviteRecipientResponse::Declined.0);
    /// The invitation was unable to be delivered.
    #[deprecated]
    pub const GKInviteeResponseFailed: Self = Self(GKInviteRecipientResponse::Failed.0);
    /// The invitee isn’t running a compatible version of your game.
    #[deprecated]
    pub const GKInviteeResponseIncompatible: Self = Self(GKInviteRecipientResponse::Incompatible.0);
    /// The invitee couldn’t be contacted.
    #[deprecated]
    pub const GKInviteeResponseUnableToConnect: Self =
        Self(GKInviteRecipientResponse::UnableToConnect.0);
    /// The invitation timed out without an answer.
    #[deprecated]
    pub const GKInviteeResponseNoAnswer: Self = Self(GKInviteRecipientResponse::NoAnswer.0);
}

unsafe impl Encode for GKInviteRecipientResponse {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for GKInviteRecipientResponse {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// Possible responses from an invitation to a remote player.
#[deprecated]
pub type GKInviteeResponse = GKInviteRecipientResponse;

/// The kind of match managed by Game Center.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct GKMatchType(pub NSUInteger);
impl GKMatchType {
    /// A peer-to-peer match hosted by Game Center.
    ///
    /// ## Discussion
    ///
    /// A [`GKMatch`](https://developer.apple.com/documentation/gamekit/gkmatch) object represents a peer-to-peer match.
    ///
    ///
    #[doc(alias = "GKMatchTypePeerToPeer")]
    pub const PeerToPeer: Self = Self(0);
    /// A match hosted on your private server.
    #[doc(alias = "GKMatchTypeHosted")]
    pub const Hosted: Self = Self(1);
    /// A turn-based match hosted by Game Center.
    ///
    /// ## Discussion
    ///
    /// A [`GKTurnBasedMatch`](https://developer.apple.com/documentation/gamekit/gkturnbasedmatch) object represents a turn-based match.
    ///
    ///
    #[doc(alias = "GKMatchTypeTurnBased")]
    pub const TurnBased: Self = Self(2);
}

unsafe impl Encode for GKMatchType {
    const ENCODING: Encoding = NSUInteger::ENCODING;
}

unsafe impl RefEncode for GKMatchType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// An object that encapsulates the parameters to create a real-time or turn-based match.
    ///
    /// ## Overview
    ///
    /// To request a match, set the properties of the match request, such as the number of players, the invitation message, and whether to use automatch to fill the player slots. You’re required to set the minimum and maximum number of players allowed in the match. Then, pass the match request to the appropriate class, depending on the type of game and whether you implement your own user interface.
    ///
    /// To use the matchmaking user interface that GameKit provides, pass the match request to the [`GKMatchmakerViewController`](https://developer.apple.com/documentation/gamekit/gkmatchmakerviewcontroller) class for real-time games, or the [`GKTurnBasedMatchmakerViewController`](https://developer.apple.com/documentation/gamekit/gkturnbasedmatchmakerviewcontroller) class for turn-based games. GameKit sends messages to the delegates of these classes when players receive and accept invitations to the match.
    ///
    /// If you implement your own interface for finding players, pass the match request to the [`GKMatchmaker`](https://developer.apple.com/documentation/gamekit/gkmatchmaker) class for real-time games, or the [`GKTurnBasedMatch`](https://developer.apple.com/documentation/gamekit/gkturnbasedmatch) class for turn-based games. If the player selects the other players to invite in your interface, set the [`recipients`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/recipients), the [`inviteMessage`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/invitemessage), and the [`recipientResponseHandler`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/recipientresponsehandler) properties before creating the match.
    ///
    /// ### Matchmaking using rules
    ///
    /// You can refine the match results and reduce player wait times by configuring matchmaking before you present an interface. You can either find players using matchmaking rules you set up on the server, or find players from a subset of players you specify in the game.
    ///
    /// To use matchmaking rules, set the [`queueName`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/queuename) property to the queue name that you configure in App Store Connect. Optionally, set [`properties`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/properties) and [`recipientProperties`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/recipientproperties) to game-specific criteria. Players in the [`recipientProperties`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/recipientproperties) property need to also be in the [`recipients`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/recipients) property — that is, be a recipient of an invitation. When using matchmaking rules, Game Center ignores the subset that you specify using the [`playerGroup`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/playergroup) and [`playerAttributes`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/playerattributes) properties.
    ///
    /// If you set the request’s [`minPlayers`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/minplayers) and [`maxPlayers`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/maxplayers) properties, use values that are in the rule set’s player range. Otherwise, the default values for these properties are the rule set’s `minPlayers` and `maxPlayers` fields (see [`Create a rule set`](https://developer.apple.com/documentation/appstoreconnectapi/post-v1-gamecentermatchmakingrulesets)).
    ///
    /// If you don’t use matchmaking rules, you can restrict finding players to a subset of players. Set the [`queueName`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/queuename) property to `nil`, and set the [`playerGroup`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/playergroup) and [`playerAttributes`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/playerattributes) properties to specify the subset. Then matchmaking ignores the rules-based [`properties`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/properties) and [`recipientProperties`](https://developer.apple.com/documentation/gamekit/gkmatchrequest/recipientproperties) properties.
    ///
    /// For more information, see [Finding players using matchmaking rules](https://developer.apple.com/documentation/gamekit/finding-players-using-matchmaking-rules).
    ///
    /// <div class="warning">
    ///
    /// ### Important
    ///  Matchmaking rules are only available for peer-to-peer ([`GKMatchTypeTurnBased`](https://developer.apple.com/documentation/gamekit/gkmatchtype/turnbased)) and hosted ([`GKMatchTypeHosted`](https://developer.apple.com/documentation/gamekit/gkmatchtype/hosted)) match requests.
    ///
    ///
    ///
    /// </div>
    ///
    /// GKMatchRequest represents the parameters needed to create the match.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKMatchRequest;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKMatchRequest {}
);

impl GKMatchRequest {
    extern_methods!(
        /// Minimum number of players for the match
        #[unsafe(method(minPlayers))]
        #[unsafe(method_family = none)]
        pub unsafe fn minPlayers(&self) -> NSUInteger;

        /// Setter for [`minPlayers`][Self::minPlayers].
        #[unsafe(method(setMinPlayers:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMinPlayers(&self, min_players: NSUInteger);

        /// Maximum number of players for the match
        #[unsafe(method(maxPlayers))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxPlayers(&self) -> NSUInteger;

        /// Setter for [`maxPlayers`][Self::maxPlayers].
        #[unsafe(method(setMaxPlayers:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setMaxPlayers(&self, max_players: NSUInteger);

        /// The player group identifier. Matchmaking will only take place between players in the same group.
        #[unsafe(method(playerGroup))]
        #[unsafe(method_family = none)]
        pub unsafe fn playerGroup(&self) -> NSUInteger;

        /// Setter for [`playerGroup`][Self::playerGroup].
        #[unsafe(method(setPlayerGroup:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPlayerGroup(&self, player_group: NSUInteger);

        /// optional mask that specifies the role that the local player would like to play in the game.  If this value is 0, it will be set to 0xFFFFFFFF (the default), and this property will be ignored. If the value is nonzero, then automatching uses the value as a mask that restricts the role the player can play in the group. Automatching with player attributes matches new players into the game so that the bitwise OR of the masks of all the players in the resulting match equals 0xFFFFFFFF.
        #[unsafe(method(playerAttributes))]
        #[unsafe(method_family = none)]
        pub unsafe fn playerAttributes(&self) -> u32;

        /// Setter for [`playerAttributes`][Self::playerAttributes].
        #[unsafe(method(setPlayerAttributes:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPlayerAttributes(&self, player_attributes: u32);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// Array of GKPlayers to invite, or nil if none. This array can also include local guest players.
        #[unsafe(method(recipients))]
        #[unsafe(method_family = none)]
        pub unsafe fn recipients(&self) -> Option<Retained<NSArray<GKPlayer>>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// Setter for [`recipients`][Self::recipients].
        #[unsafe(method(setRecipients:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRecipients(&self, recipients: Option<&NSArray<GKPlayer>>);

        /// Message sent to invited players, may be modified if using GKMatchmakerViewController
        /// Will return nil if the player is underage or restricted.
        #[unsafe(method(inviteMessage))]
        #[unsafe(method_family = none)]
        pub unsafe fn inviteMessage(&self) -> Option<Retained<NSString>>;

        /// Setter for [`inviteMessage`][Self::inviteMessage].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setInviteMessage:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInviteMessage(&self, invite_message: Option<&NSString>);

        /// Default number of players to use during matchmaking. If not set we will default to the number that the player previously set for this game, or maxPlayers.
        #[unsafe(method(defaultNumberOfPlayers))]
        #[unsafe(method_family = none)]
        pub unsafe fn defaultNumberOfPlayers(&self) -> NSUInteger;

        /// Setter for [`defaultNumberOfPlayers`][Self::defaultNumberOfPlayers].
        #[unsafe(method(setDefaultNumberOfPlayers:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDefaultNumberOfPlayers(&self, default_number_of_players: NSUInteger);

        /// Whether or not a match will be created only using automatch.  If YES, then a player will not be able to
        /// invite anyone (including contacts, friends, and nearby players) to the match, but rely on automatching to
        /// find players for the match.  Default is NO.
        #[deprecated]
        #[unsafe(method(restrictToAutomatch))]
        #[unsafe(method_family = none)]
        pub unsafe fn restrictToAutomatch(&self) -> bool;

        /// Setter for [`restrictToAutomatch`][Self::restrictToAutomatch].
        #[deprecated]
        #[unsafe(method(setRestrictToAutomatch:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRestrictToAutomatch(&self, restrict_to_automatch: bool);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// An recipientResponseHandler can be set in order to receive responses from programmatically invited players.
        ///
        /// # Safety
        ///
        /// The returned block's argument 1 must be a valid pointer.
        #[unsafe(method(recipientResponseHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn recipientResponseHandler(
            &self,
        ) -> *mut block2::DynBlock<dyn Fn(NonNull<GKPlayer>, GKInviteRecipientResponse)>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Setter for [`recipientResponseHandler`][Self::recipientResponseHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setRecipientResponseHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRecipientResponseHandler(
            &self,
            recipient_response_handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<GKPlayer>, GKInviteRecipientResponse)>,
            >,
        );

        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// The returned block's argument 1 must be a valid pointer.
        #[deprecated]
        #[unsafe(method(inviteeResponseHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn inviteeResponseHandler(
            &self,
        ) -> *mut block2::DynBlock<dyn Fn(NonNull<NSString>, GKInviteeResponse)>;

        #[cfg(feature = "block2")]
        /// Setter for [`inviteeResponseHandler`][Self::inviteeResponseHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[deprecated]
        #[unsafe(method(setInviteeResponseHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInviteeResponseHandler(
            &self,
            invitee_response_handler: Option<
                &block2::DynBlock<dyn Fn(NonNull<NSString>, GKInviteeResponse)>,
            >,
        );

        /// To determine the maximum allowed players for each type of match supported.
        #[unsafe(method(maxPlayersAllowedForMatchOfType:))]
        #[unsafe(method_family = none)]
        pub unsafe fn maxPlayersAllowedForMatchOfType(match_type: GKMatchType) -> NSUInteger;

        #[deprecated]
        #[unsafe(method(playersToInvite))]
        #[unsafe(method_family = none)]
        pub unsafe fn playersToInvite(&self) -> Option<Retained<NSArray<NSString>>>;

        /// Setter for [`playersToInvite`][Self::playersToInvite].
        #[deprecated]
        #[unsafe(method(setPlayersToInvite:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setPlayersToInvite(&self, players_to_invite: Option<&NSArray<NSString>>);

        /// The name of the queue, if rule-based matchmaking is used.
        #[unsafe(method(queueName))]
        #[unsafe(method_family = none)]
        pub unsafe fn queueName(&self) -> Option<Retained<NSString>>;

        /// Setter for [`queueName`][Self::queueName].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[unsafe(method(setQueueName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setQueueName(&self, queue_name: Option<&NSString>);

        #[cfg(feature = "GKDefines")]
        /// The match properties, if rule-based matchmaking is used.
        #[unsafe(method(properties))]
        #[unsafe(method_family = none)]
        pub unsafe fn properties(&self) -> Option<Retained<GKMatchProperties>>;

        #[cfg(feature = "GKDefines")]
        /// Setter for [`properties`][Self::properties].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `properties` generic should be of the correct type.
        #[unsafe(method(setProperties:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setProperties(&self, properties: Option<&GKMatchProperties>);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKDefines", feature = "GKPlayer"))]
        /// The recipient specific match properties, if rule-based matchmaking is used when inviting players.
        #[unsafe(method(recipientProperties))]
        #[unsafe(method_family = none)]
        pub unsafe fn recipientProperties(
            &self,
        ) -> Option<Retained<NSDictionary<GKPlayer, GKMatchProperties>>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKDefines", feature = "GKPlayer"))]
        /// Setter for [`recipientProperties`][Self::recipientProperties].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        ///
        /// # Safety
        ///
        /// `recipient_properties` generic generic should be of the correct type.
        #[unsafe(method(setRecipientProperties:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setRecipientProperties(
            &self,
            recipient_properties: Option<&NSDictionary<GKPlayer, GKMatchProperties>>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
impl GKMatchRequest {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An invitation to join a match sent to the local player from another player.
    ///
    /// ## Overview
    ///
    /// Your game never directly creates `GKInvite` objects. Instead, these objects are created by GameKit and delivered to your game’s matchmaking event handler. The properties of the invitation object describe the match to which another player invites the local player.
    ///
    ///
    /// GKInvite represents an accepted game invite, it is used to create a GKMatchmakerViewController
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKInvite;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKInvite {}
);

impl GKInvite {
    extern_methods!(
        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        #[unsafe(method(sender))]
        #[unsafe(method_family = none)]
        pub unsafe fn sender(&self) -> Retained<GKPlayer>;

        #[unsafe(method(isHosted))]
        #[unsafe(method_family = none)]
        pub unsafe fn isHosted(&self) -> bool;

        /// player group from inviter's match request
        #[unsafe(method(playerGroup))]
        #[unsafe(method_family = none)]
        pub unsafe fn playerGroup(&self) -> NSUInteger;

        /// player attributes from inviter's match request
        #[unsafe(method(playerAttributes))]
        #[unsafe(method_family = none)]
        pub unsafe fn playerAttributes(&self) -> u32;

        /// * This property is obsolete. **
        #[deprecated]
        #[unsafe(method(inviter))]
        #[unsafe(method_family = none)]
        pub unsafe fn inviter(&self) -> Retained<NSString>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKInvite {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// A protocol that handles invite events from Game Center.
    ///
    /// ## Overview
    ///
    /// Implement the methods in the [`GKInviteEventListener`](https://developer.apple.com/documentation/gamekit/gkinviteeventlistener) protocol to accept invitations from other players or handle when other players accept invitations from the local player.
    ///
    /// Adopt the [`GKLocalPlayerListener`](https://developer.apple.com/documentation/gamekit/gklocalplayerlistener) protocol to listen for and handle a variety of Game Center events for player accounts instead of the individual [`GKChallengeListener`](https://developer.apple.com/documentation/gamekit/gkchallengelistener), [`GKInviteEventListener`](https://developer.apple.com/documentation/gamekit/gkinviteeventlistener), [`GKSavedGameListener`](https://developer.apple.com/documentation/gamekit/gksavedgamelistener), and [`GKTurnBasedEventListener`](https://developer.apple.com/documentation/gamekit/gkturnbasedeventlistener) protocols.
    ///
    /// For details, see [Finding multiple players for a game](https://developer.apple.com/documentation/gamekit/finding-multiple-players-for-a-game).
    ///
    ///
    /// GKInviteEventListener uses the GKLocalPlayerListener mechanism on GKLocalPlayer to listen to the two kinds of invite events that a game must respond to
    pub unsafe trait GKInviteEventListener {
        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// player:didAcceptInvite: gets called when another player accepts the invite from the local player
        #[optional]
        #[unsafe(method(player:didAcceptInvite:))]
        #[unsafe(method_family = none)]
        unsafe fn player_didAcceptInvite(&self, player: &GKPlayer, invite: &GKInvite);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// didRequestMatchWithRecipients: gets called when the player chooses to play with another player from Game Center and it launches the game to start matchmaking
        #[optional]
        #[unsafe(method(player:didRequestMatchWithRecipients:))]
        #[unsafe(method_family = none)]
        unsafe fn player_didRequestMatchWithRecipients(
            &self,
            player: &GKPlayer,
            recipient_players: &NSArray<GKPlayer>,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[optional]
        #[unsafe(method(player:didRequestMatchWithPlayers:))]
        #[unsafe(method_family = none)]
        unsafe fn player_didRequestMatchWithPlayers(
            &self,
            player: &GKPlayer,
            player_i_ds_to_invite: &NSArray<NSString>,
        );
    }
);

extern_class!(
    /// An object that represents matchmaking results, including the players that join the match and their properties that matchmaking rules uses.
    ///
    /// ## Overview
    ///
    /// If the [`properties`](https://developer.apple.com/documentation/gamekit/gkmatchedplayers/properties) and `playersProperties` properties are `nil`, Game Center didn’t use matchmaking rules to find the players. For more information, see [Matchmaking rules](https://developer.apple.com/documentation/gamekit/matchmaking-rules).
    ///
    ///
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKMatchedPlayers;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKMatchedPlayers {}
);

impl GKMatchedPlayers {
    extern_methods!(
        #[cfg(feature = "GKDefines")]
        #[unsafe(method(properties))]
        #[unsafe(method_family = none)]
        pub unsafe fn properties(&self) -> Option<Retained<GKMatchProperties>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        #[unsafe(method(players))]
        #[unsafe(method_family = none)]
        pub unsafe fn players(&self) -> Retained<NSArray<GKPlayer>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKDefines", feature = "GKPlayer"))]
        #[unsafe(method(playerProperties))]
        #[unsafe(method_family = none)]
        pub unsafe fn playerProperties(
            &self,
        ) -> Option<Retained<NSDictionary<GKPlayer, GKMatchProperties>>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKMatchedPlayers {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_class!(
    /// An object that creates matches with other players without presenting an interface to the players.
    ///
    /// ## Overview
    ///
    /// Use the `GKMatchmaker` class to auto-match players for a quicker game start, programmatically invite specific players, or implement your own interface for players to invite other players. If you want to present a familiar matchmaking GameKit interface to players, instead use either the [`GKMatchmakerViewController`](https://developer.apple.com/documentation/gamekit/gkmatchmakerviewcontroller) or [`GKTurnBasedMatchmakerViewController`](https://developer.apple.com/documentation/gamekit/gkturnbasedmatchmakerviewcontroller) class.
    ///
    /// If you host a game on your own server, you can also use this class to find Game Center players. That is, you implement the networking and communication between the players through your own servers not Game Center.
    ///
    /// To find players using this class, create a [`GKMatchRequest`](https://developer.apple.com/documentation/gamekit/gkmatchrequest) object and configure it according to the parameters of your game. Then, pass the match request and a handler using the [`findMatchForRequest:withCompletionHandler:`](https://developer.apple.com/documentation/gamekit/gkmatchmaker/findmatch(for:withcompletionhandler:)) method, or the [`findPlayersForHostedMatchRequest:withCompletionHandler:`](https://developer.apple.com/documentation/gamekit/gkmatchmaker/findplayers(forhostedmatchrequest:withcompletionhandler:)) method for hosted games, to the shared `GKMatchmaker` object.
    ///
    /// GameKit calls the handler when players accept their invitations. Implement the handler to set the delegate of the [`GKMatch`](https://developer.apple.com/documentation/gamekit/gkmatch) object that GameKit sends and start the game when there are enough players.
    ///
    /// If the match doesn’t have enough players (for example, some players decline their invitations), you can create another match request and call the [`addPlayersToMatch:matchRequest:completionHandler:`](https://developer.apple.com/documentation/gamekit/gkmatchmaker/addplayers(to:matchrequest:completionhandler:)) method repeatedly until the match’s [`expectedPlayerCount`](https://developer.apple.com/documentation/gamekit/gkmatch/expectedplayercount) property is zero. When you have enough players to start the match, call the [`finishMatchmakingForMatch:`](https://developer.apple.com/documentation/gamekit/gkmatchmaker/finishmatchmaking(for:)) method to end the matchmaking process.
    ///
    /// If you provide a SharePlay interface for inviting players, use the [`startGroupActivityWithPlayerHandler:`](https://developer.apple.com/documentation/gamekit/gkmatchmaker/startgroupactivity(playerhandler:)) and [`stopGroupActivity`](https://developer.apple.com/documentation/gamekit/gkmatchmaker/stopgroupactivity()) methods to create a group activity on behalf of the player.
    ///
    ///
    /// GKMatchmaker is a singleton object to manage match creation from invites and automatching.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKMatchmaker;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKMatchmaker {}
);

impl GKMatchmaker {
    extern_methods!(
        /// The shared matchmaker
        #[unsafe(method(sharedMatchmaker))]
        #[unsafe(method_family = none)]
        pub unsafe fn sharedMatchmaker() -> Retained<GKMatchmaker>;

        #[cfg(all(feature = "GKMatch", feature = "block2"))]
        /// Get a match for an accepted invite
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Invite cancelled
        #[unsafe(method(matchForInvite:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn matchForInvite_completionHandler(
            &self,
            invite: &GKInvite,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut GKMatch, *mut NSError)>>,
        );

        #[cfg(all(feature = "GKMatch", feature = "block2"))]
        /// Automatching or invites to find a peer-to-peer match for the specified request. Error will be nil on success:
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Unauthenticated player
        /// 3. Timeout
        /// Note that the players property on the returned GKMatch instance will only contain connected players. It will initially be empty as players are connecting. Implement the GKMatchDelegate method match:player:didChangeConnectionState: to listen for updates to the GKMatch instance's players property.
        #[unsafe(method(findMatchForRequest:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn findMatchForRequest_withCompletionHandler(
            &self,
            request: &GKMatchRequest,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut GKMatch, *mut NSError)>>,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Automatching or invites for host-client match request. This returns a list of player identifiers to be included in the match. Determination and communication with the host is not part of this API.
        /// When inviting, no player identifiers will be returned. Player responses will be reported via the inviteeResponseHandler.
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Unauthenticated player
        /// 3. Timeout
        #[unsafe(method(findPlayersForHostedRequest:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn findPlayersForHostedRequest_withCompletionHandler(
            &self,
            request: &GKMatchRequest,
            completion_handler: Option<
                &block2::DynBlock<dyn Fn(*mut NSArray<GKPlayer>, *mut NSError)>,
            >,
        );

        #[cfg(feature = "block2")]
        /// Automatching or invites for host-client rule-based match request.
        #[unsafe(method(findMatchedPlayers:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn findMatchedPlayers_withCompletionHandler(
            &self,
            request: &GKMatchRequest,
            completion_handler: &block2::DynBlock<dyn Fn(*mut GKMatchedPlayers, *mut NSError)>,
        );

        #[cfg(all(feature = "GKMatch", feature = "block2"))]
        /// Automatching or invites to add additional players to a peer-to-peer match for the specified request. Error will be nil on success:
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Timeout
        #[unsafe(method(addPlayersToMatch:matchRequest:completionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addPlayersToMatch_matchRequest_completionHandler(
            &self,
            r#match: &GKMatch,
            match_request: &GKMatchRequest,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut NSError)>>,
        );

        /// Cancel matchmaking and any pending invites
        #[unsafe(method(cancel))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancel(&self);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// Cancel a pending invitation to a player
        #[unsafe(method(cancelPendingInviteToPlayer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelPendingInviteToPlayer(&self, player: &GKPlayer);

        #[cfg(feature = "GKMatch")]
        /// Call this when finished with all programmatic P2P invites/matchmaking, for compatability with connected players using GKMatchmakerViewController.
        #[unsafe(method(finishMatchmakingForMatch:))]
        #[unsafe(method_family = none)]
        pub unsafe fn finishMatchmakingForMatch(&self, r#match: &GKMatch);

        #[cfg(feature = "block2")]
        /// Query the server for recent activity in the specified player group. A larger value indicates that a given group has seen more recent activity. Error will be nil on success.
        /// Possible reasons for error:
        /// 1. Communications failure
        #[unsafe(method(queryPlayerGroupActivity:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn queryPlayerGroupActivity_withCompletionHandler(
            &self,
            player_group: NSUInteger,
            completion_handler: Option<&block2::DynBlock<dyn Fn(NSInteger, *mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// Query the server for recent activity for all the player groups of that game. Error will be nil on success.
        /// Possible reasons for error:
        /// 1. Communications failure
        #[unsafe(method(queryActivityWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn queryActivityWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(NSInteger, *mut NSError)>>,
        );

        #[cfg(feature = "block2")]
        /// Query the server for recent activity for the specified queue.
        #[unsafe(method(queryQueueActivity:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn queryQueueActivity_withCompletionHandler(
            &self,
            queue_name: &NSString,
            completion_handler: Option<&block2::DynBlock<dyn Fn(NSInteger, *mut NSError)>>,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Start browsing for nearby players that can be invited to a match. The reachableHandler will be called for each player found with a compatible game. It may be called more than once for the same player if that player ever becomes unreachable (e.g. moves out of range). You should call stopBrowsingForNearbyPlayers when finished browsing.
        #[unsafe(method(startBrowsingForNearbyPlayersWithHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startBrowsingForNearbyPlayersWithHandler(
            &self,
            reachable_handler: Option<&block2::DynBlock<dyn Fn(NonNull<GKPlayer>, Bool)>>,
        );

        /// Stop browsing for nearby players.
        #[unsafe(method(stopBrowsingForNearbyPlayers))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopBrowsingForNearbyPlayers(&self);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Activate  a  group activity by Game Center for your game, which allows people in the FaceTime call to join the local player's game. The handler will be called for each player who joined from the activity.
        #[unsafe(method(startGroupActivityWithPlayerHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startGroupActivityWithPlayerHandler(
            &self,
            handler: &block2::DynBlock<dyn Fn(NonNull<GKPlayer>)>,
        );

        /// End the group activity created by Game Center for your game, which was activated by the local player.
        #[unsafe(method(stopGroupActivity))]
        #[unsafe(method_family = none)]
        pub unsafe fn stopGroupActivity(&self);
    );
}

/// Methods declared on superclass `NSObject`.
impl GKMatchmaker {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// GKDeprecated.
impl GKMatchmaker {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// # Safety
        ///
        /// - The returned block's argument 1 must be a valid pointer.
        /// - The returned block's argument 2 must be a valid pointer or null.
        #[deprecated = "Use the ``GKLocalPlayer/register(_:)`` method instead."]
        #[unsafe(method(inviteHandler))]
        #[unsafe(method_family = none)]
        pub unsafe fn inviteHandler(
            &self,
        ) -> *mut block2::DynBlock<dyn Fn(NonNull<GKInvite>, *mut NSArray)>;

        #[cfg(feature = "block2")]
        /// Setter for [`inviteHandler`][Self::inviteHandler].
        ///
        /// This is [copied][objc2_foundation::NSCopying::copy] when set.
        #[deprecated = "Use the ``GKLocalPlayer/register(_:)`` method instead."]
        #[unsafe(method(setInviteHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setInviteHandler(
            &self,
            invite_handler: Option<&block2::DynBlock<dyn Fn(NonNull<GKInvite>, *mut NSArray)>>,
        );
    );
}

/// Obsoleted.
impl GKMatchmaker {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[unsafe(method(startBrowsingForNearbyPlayersWithReachableHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn startBrowsingForNearbyPlayersWithReachableHandler(
            &self,
            reachable_handler: Option<&block2::DynBlock<dyn Fn(NonNull<NSString>, Bool)>>,
        );

        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[unsafe(method(cancelInviteToPlayer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelInviteToPlayer(&self, player_id: &NSString);

        #[cfg(feature = "block2")]
        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[unsafe(method(findPlayersForHostedMatchRequest:withCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn findPlayersForHostedMatchRequest_withCompletionHandler(
            &self,
            request: &GKMatchRequest,
            completion_handler: Option<
                &block2::DynBlock<dyn Fn(*mut NSArray<NSString>, *mut NSError)>,
            >,
        );
    );
}
