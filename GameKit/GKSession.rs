//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// The GKSession handles networking between peers for a game, which includes establishing and maintaining connections over a game network, and network data transport.
    ///
    /// This a not a Game Center feature. To support Game Center and online play, see GKMatch.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamekit/gksession?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[deprecated]
    pub struct GKSession;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKSession {}
);

impl GKSession {
    extern_methods!(
        #[cfg(feature = "GKPublicConstants")]
        /// # Safety
        ///
        /// - `session_id` might not allow `None`.
        /// - `name` might not allow `None`.
        #[deprecated = "No longer available"]
        #[unsafe(method(initWithSessionID:displayName:sessionMode:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithSessionID_displayName_sessionMode(
            this: Allocated<Self>,
            session_id: Option<&NSString>,
            name: Option<&NSString>,
            mode: GKSessionMode,
        ) -> Option<Retained<Self>>;

        #[cfg(feature = "GKPublicProtocols")]
        #[deprecated = "No longer supported."]
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn GKSessionDelegate>>>;

        #[cfg(feature = "GKPublicProtocols")]
        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        ///
        /// # Safety
        ///
        /// `delegate` might not allow `None`.
        #[deprecated = "No longer supported."]
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn GKSessionDelegate>>);

        #[deprecated]
        #[unsafe(method(sessionID))]
        #[unsafe(method_family = none)]
        pub unsafe fn sessionID(&self) -> Option<Retained<NSString>>;

        #[deprecated]
        #[unsafe(method(displayName))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayName(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "GKPublicConstants")]
        #[deprecated = "No longer supported."]
        #[unsafe(method(sessionMode))]
        #[unsafe(method_family = none)]
        pub unsafe fn sessionMode(&self) -> GKSessionMode;

        #[deprecated]
        #[unsafe(method(peerID))]
        #[unsafe(method_family = none)]
        pub unsafe fn peerID(&self) -> Option<Retained<NSString>>;

        /// Toggle availability on the network based on session mode and search criteria.  Delegate will get a callback -session:didReceiveConnectionRequestFromPeer: when a peer attempts a connection.
        #[deprecated]
        #[unsafe(method(isAvailable))]
        #[unsafe(method_family = none)]
        pub unsafe fn isAvailable(&self) -> bool;

        /// Setter for [`isAvailable`][Self::isAvailable].
        #[deprecated]
        #[unsafe(method(setAvailable:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setAvailable(&self, available: bool);

        /// The timeout for disconnecting a peer if it appears that the peer has lost connection to the game network
        #[deprecated]
        #[unsafe(method(disconnectTimeout))]
        #[unsafe(method_family = none)]
        pub unsafe fn disconnectTimeout(&self) -> NSTimeInterval;

        /// Setter for [`disconnectTimeout`][Self::disconnectTimeout].
        #[deprecated]
        #[unsafe(method(setDisconnectTimeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDisconnectTimeout(&self, disconnect_timeout: NSTimeInterval);

        /// Return the application chosen name of a specific peer
        ///
        /// # Safety
        ///
        /// `peer_id` might not allow `None`.
        #[deprecated]
        #[unsafe(method(displayNameForPeer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn displayNameForPeer(
            &self,
            peer_id: Option<&NSString>,
        ) -> Option<Retained<NSString>>;

        #[cfg(feature = "GKPublicConstants")]
        /// Asynchronous delivery of data to one or more peers.  Returns YES if delivery started, NO if unable to start sending, and error will be set.  Delivery will be reliable or unreliable as set by mode.
        ///
        /// # Safety
        ///
        /// - `data` might not allow `None`.
        /// - `peers` generic should be of the correct type.
        /// - `peers` might not allow `None`.
        /// - `error` might not allow `None`.
        #[deprecated = "No longer supported."]
        #[unsafe(method(sendData:toPeers:withDataMode:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendData_toPeers_withDataMode_error(
            &self,
            data: Option<&NSData>,
            peers: Option<&NSArray>,
            mode: GKSendDataMode,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        #[cfg(feature = "GKPublicConstants")]
        /// Asynchronous delivery to all peers.  Returns YES if delivery started, NO if unable to start sending, and error will be set.  Delivery will be reliable or unreliable as set by mode.
        ///
        /// # Safety
        ///
        /// - `data` might not allow `None`.
        /// - `error` might not allow `None`.
        #[deprecated = "No longer supported."]
        #[unsafe(method(sendDataToAllPeers:withDataMode:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDataToAllPeers_withDataMode_error(
            &self,
            data: Option<&NSData>,
            mode: GKSendDataMode,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        /// Set the handler to receive data sent from remote peers.
        ///
        /// # Safety
        ///
        /// - `handler` should be of the correct type.
        /// - `handler` might not allow `None`.
        /// - `context` must be a valid pointer.
        #[deprecated]
        #[unsafe(method(setDataReceiveHandler:withContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDataReceiveHandler_withContext(
            &self,
            handler: Option<&AnyObject>,
            context: *mut c_void,
        );

        /// Attempt connection to a remote peer.  Remote peer gets a callback to -session:didReceiveConnectionRequestFromPeer:.
        ///
        /// Success results in a call to delegate -session:peer:didChangeState: GKPeerStateConnected
        /// Failure results in a call to delegate -session:connectionWithPeerFailed:withError:
        ///
        /// # Safety
        ///
        /// `peer_id` might not allow `None`.
        #[deprecated]
        #[unsafe(method(connectToPeer:withTimeout:))]
        #[unsafe(method_family = none)]
        pub unsafe fn connectToPeer_withTimeout(
            &self,
            peer_id: Option<&NSString>,
            timeout: NSTimeInterval,
        );

        /// # Safety
        ///
        /// `peer_id` might not allow `None`.
        #[deprecated]
        #[unsafe(method(cancelConnectToPeer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn cancelConnectToPeer(&self, peer_id: Option<&NSString>);

        /// Methods to accept or deny a prior connection request from -session:didReceiveConnectionRequestFromPeer:
        ///
        /// # Safety
        ///
        /// - `peer_id` might not allow `None`.
        /// - `error` might not allow `None`.
        #[deprecated]
        #[unsafe(method(acceptConnectionFromPeer:error:))]
        #[unsafe(method_family = none)]
        pub unsafe fn acceptConnectionFromPeer_error(
            &self,
            peer_id: Option<&NSString>,
            error: Option<&mut Option<Retained<NSError>>>,
        ) -> bool;

        /// # Safety
        ///
        /// `peer_id` might not allow `None`.
        #[deprecated]
        #[unsafe(method(denyConnectionFromPeer:))]
        #[unsafe(method_family = none)]
        pub unsafe fn denyConnectionFromPeer(&self, peer_id: Option<&NSString>);

        /// Disconnect a peer from the session (the peer gets disconnected from all connected peers).
        ///
        /// # Safety
        ///
        /// `peer_id` might not allow `None`.
        #[deprecated]
        #[unsafe(method(disconnectPeerFromAllPeers:))]
        #[unsafe(method_family = none)]
        pub unsafe fn disconnectPeerFromAllPeers(&self, peer_id: Option<&NSString>);

        /// Disconnect local peer
        #[deprecated]
        #[unsafe(method(disconnectFromAllPeers))]
        #[unsafe(method_family = none)]
        pub unsafe fn disconnectFromAllPeers(&self);

        #[cfg(feature = "GKPublicConstants")]
        /// Returns peers according to connection state
        #[deprecated = "No longer supported."]
        #[unsafe(method(peersWithConnectionState:))]
        #[unsafe(method_family = none)]
        pub unsafe fn peersWithConnectionState(
            &self,
            state: GKPeerConnectionState,
        ) -> Option<Retained<NSArray>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKSession {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
