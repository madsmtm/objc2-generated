//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkmatchsenddatamode?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct GKMatchSendDataMode(pub NSInteger);
impl GKMatchSendDataMode {
    #[doc(alias = "GKMatchSendDataReliable")]
    pub const Reliable: Self = Self(0);
    /// a.s.a.p. but requires fragmentation and reassembly for large messages, may stall if network congestion occurs
    #[doc(alias = "GKMatchSendDataUnreliable")]
    pub const Unreliable: Self = Self(1);
}

unsafe impl Encode for GKMatchSendDataMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for GKMatchSendDataMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkplayerconnectionstate?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct GKPlayerConnectionState(pub NSInteger);
impl GKPlayerConnectionState {
    #[doc(alias = "GKPlayerStateUnknown")]
    pub const StateUnknown: Self = Self(0);
    /// initial player state
    #[doc(alias = "GKPlayerStateConnected")]
    pub const StateConnected: Self = Self(1);
    /// connected to the match
    #[doc(alias = "GKPlayerStateDisconnected")]
    pub const StateDisconnected: Self = Self(2);
}

unsafe impl Encode for GKPlayerConnectionState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for GKPlayerConnectionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// GKMatch represents an active networking sessions between players. It handles network communications and can report player connection status. All matches are created by a GKMatchmaker.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkmatch?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKMatch;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKMatch {}
);

impl GKMatch {
    extern_methods!(
        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        #[unsafe(method(players))]
        #[unsafe(method_family = none)]
        pub unsafe fn players(&self) -> Retained<NSArray<GKPlayer>>;

        /// all the GKPlayers in the match
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn GKMatchDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn GKMatchDelegate>>);

        #[unsafe(method(expectedPlayerCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectedPlayerCount(&self) -> NSUInteger;

        #[cfg(feature = "GKDefines")]
        #[unsafe(method(properties))]
        #[unsafe(method_family = none)]
        pub unsafe fn properties(&self) -> Option<Retained<GKMatchProperties>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKDefines", feature = "GKPlayer"))]
        #[unsafe(method(playerProperties))]
        #[unsafe(method_family = none)]
        pub unsafe fn playerProperties(
            &self,
        ) -> Option<Retained<NSDictionary<GKPlayer, GKMatchProperties>>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// Asynchronously send data to one or more GKPlayers. Returns YES if delivery started, NO if unable to start sending and error will be set.
        #[unsafe(method(sendData:toPlayers:dataMode:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendData_toPlayers_dataMode_error(
            &self,
            data: &NSData,
            players: &NSArray<GKPlayer>,
            mode: GKMatchSendDataMode,
        ) -> Result<(), Retained<NSError>>;

        /// Asynchronously broadcasts data to all players. Returns YES if delivery started, NO if unable to start sending and error will be set.
        #[unsafe(method(sendDataToAllPlayers:withDataMode:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDataToAllPlayers_withDataMode_error(
            &self,
            data: &NSData,
            mode: GKMatchSendDataMode,
        ) -> Result<(), Retained<NSError>>;

        /// Disconnect the match. This will show all other players in the match that the local player has disconnected. This should be called before releasing the match instance.
        #[unsafe(method(disconnect))]
        #[unsafe(method_family = none)]
        pub unsafe fn disconnect(&self);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Choose the best host from among the connected players using gathered estimates for bandwidth and packet loss. This is intended for applications that wish to implement a client-server model on top of the match. The returned player ID will be nil if the best host cannot currently be determined (e.g. players are still connecting).
        #[unsafe(method(chooseBestHostingPlayerWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn chooseBestHostingPlayerWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut GKPlayer)>,
        );

        #[cfg(feature = "block2")]
        /// Automatching to recreate a previous peer-to-peer match that became disconnected. A new match with the same set of players will be returned by the completion handler. All players should perform this when the match has ended for automatching to succeed. Error will be nil on success.
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Timeout
        #[unsafe(method(rematchWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rematchWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut GKMatch, *mut NSError)>>,
        );

        #[cfg(feature = "GKVoiceChat")]
        /// * This method is deprecated. GKVoiceChat is no longer supported. **
        #[deprecated = "No longer supported"]
        #[unsafe(method(voiceChatWithName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn voiceChatWithName(&self, name: &NSString) -> Option<Retained<GKVoiceChat>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKMatch {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// [Apple's documentation](https://developer.apple.com/documentation/gamekit/gkmatchdelegate?language=objc)
    pub unsafe trait GKMatchDelegate: NSObjectProtocol {
        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// The match received data sent from the player.
        #[optional]
        #[unsafe(method(match:didReceiveData:fromRemotePlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_didReceiveData_fromRemotePlayer(
            &self,
            r#match: &GKMatch,
            data: &NSData,
            player: &GKPlayer,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        #[optional]
        #[unsafe(method(match:didReceiveData:forRecipient:fromRemotePlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_didReceiveData_forRecipient_fromRemotePlayer(
            &self,
            r#match: &GKMatch,
            data: &NSData,
            recipient: &GKPlayer,
            player: &GKPlayer,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// The player state changed (eg. connected or disconnected)
        #[optional]
        #[unsafe(method(match:player:didChangeConnectionState:))]
        #[unsafe(method_family = none)]
        unsafe fn match_player_didChangeConnectionState(
            &self,
            r#match: &GKMatch,
            player: &GKPlayer,
            state: GKPlayerConnectionState,
        );

        /// The match was unable to be established with any players due to an error.
        #[optional]
        #[unsafe(method(match:didFailWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn match_didFailWithError(&self, r#match: &GKMatch, error: Option<&NSError>);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// This method is called when the match is interrupted; if it returns YES, a new invite will be sent to attempt reconnection. This is supported only for 1v1 games
        #[optional]
        #[unsafe(method(match:shouldReinviteDisconnectedPlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_shouldReinviteDisconnectedPlayer(
            &self,
            r#match: &GKMatch,
            player: &GKPlayer,
        ) -> bool;

        /// * These protocol methods are obsoleted. They will never be invoked and their implementation does nothing**
        #[deprecated]
        #[optional]
        #[unsafe(method(match:didReceiveData:fromPlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_didReceiveData_fromPlayer(
            &self,
            r#match: &GKMatch,
            data: &NSData,
            player_id: &NSString,
        );

        #[deprecated]
        #[optional]
        #[unsafe(method(match:player:didChangeState:))]
        #[unsafe(method_family = none)]
        unsafe fn match_player_didChangeState(
            &self,
            r#match: &GKMatch,
            player_id: &NSString,
            state: GKPlayerConnectionState,
        );

        #[deprecated]
        #[optional]
        #[unsafe(method(match:shouldReinvitePlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_shouldReinvitePlayer(
            &self,
            r#match: &GKMatch,
            player_id: &NSString,
        ) -> bool;
    }
);

/// Obsoleted.
impl GKMatch {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[unsafe(method(chooseBestHostPlayerWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn chooseBestHostPlayerWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSString)>,
        );

        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[unsafe(method(sendData:toPlayers:withDataMode:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendData_toPlayers_withDataMode_error(
            &self,
            data: &NSData,
            player_i_ds: &NSArray<NSString>,
            mode: GKMatchSendDataMode,
        ) -> Result<(), Retained<NSError>>;

        /// * This property is obsolete.  **
        #[deprecated]
        #[unsafe(method(playerIDs))]
        #[unsafe(method_family = none)]
        pub unsafe fn playerIDs(&self) -> Option<Retained<NSArray<NSString>>>;
    );
}
