//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

/// The mechanism used to transmit data to other players.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct GKMatchSendDataMode(pub NSInteger);
impl GKMatchSendDataMode {
    /// Sends data continuously until the recipients successfully receive it or the connection times out.
    ///
    /// ## Discussion
    ///
    /// Use this mode when you need guaranteed delivery in the order it’s sent, and the speed isn’t critical.
    ///
    ///
    #[doc(alias = "GKMatchSendDataReliable")]
    pub const Reliable: Self = Self(0);
    /// Sends data once even if an error occurs.
    ///
    /// ## Discussion
    ///
    /// Use this mode for small packets of data that must arrive quickly to be useful to the recipient. Unreliable data may arrive in a different order than when you sent it.
    ///
    ///
    /// a.s.a.p. but requires fragmentation and reassembly for large messages, may stall if network congestion occurs
    #[doc(alias = "GKMatchSendDataUnreliable")]
    pub const Unreliable: Self = Self(1);
}

unsafe impl Encode for GKMatchSendDataMode {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for GKMatchSendDataMode {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The possible states of a connection to a match.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct GKPlayerConnectionState(pub NSInteger);
impl GKPlayerConnectionState {
    /// An undetermined state in which the player can’t receive data.
    #[doc(alias = "GKPlayerStateUnknown")]
    pub const StateUnknown: Self = Self(0);
    /// A state in which a player connects to the match and can receive data.
    /// initial player state
    #[doc(alias = "GKPlayerStateConnected")]
    pub const StateConnected: Self = Self(1);
    /// A state in which a player disconnects from the match and can’t receive data.
    /// connected to the match
    #[doc(alias = "GKPlayerStateDisconnected")]
    pub const StateDisconnected: Self = Self(2);
}

unsafe impl Encode for GKPlayerConnectionState {
    const ENCODING: Encoding = NSInteger::ENCODING;
}

unsafe impl RefEncode for GKPlayerConnectionState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

extern_class!(
    /// A peer-to-peer network between a group of players that sign into Game Center.
    ///
    /// ## Overview
    ///
    /// Matches provide a mechanism for a player to send both game and voice data to other players.
    ///
    /// You never create a `GKMatch` object directly. Instead, GameKit passes a match object to a [`GKMatchmakerViewControllerDelegate`](https://developer.apple.com/documentation/gamekit/gkmatchmakerviewcontrollerdelegate) method or a [`GKMatchmaker`](https://developer.apple.com/documentation/gamekit/gkmatchmaker) handler when you set up a multiplayer game. For details, see [Finding multiple players for a game](https://developer.apple.com/documentation/gamekit/finding-multiple-players-for-a-game).
    ///
    /// If you use the [`GKMatchmakerViewController`](https://developer.apple.com/documentation/gamekit/gkmatchmakerviewcontroller) class to find players, implement the [`matchmakerViewController:didFindMatch:`](https://developer.apple.com/documentation/gamekit/gkmatchmakerviewcontrollerdelegate/matchmakerviewcontroller(_:didfind:)) delegate method to set the match delegate. If you use the [`GKMatchmaker`](https://developer.apple.com/documentation/gamekit/gkmatchmaker) class, set the match delegate in the handler you pass to the [`findMatchForRequest:withCompletionHandler:`](https://developer.apple.com/documentation/gamekit/gkmatchmaker/findmatch(for:withcompletionhandler:)) method.
    ///
    /// You can begin exchanging data when two or more players join the match. Implement the [`match:player:didChangeConnectionState:`](https://developer.apple.com/documentation/gamekit/gkmatchdelegate/match(_:player:didchange:)-8ohgr) delegate method to track when players connect or disconnect from the match. Then use either the [`sendDataToAllPlayers:withDataMode:error:`](https://developer.apple.com/documentation/gamekit/gkmatch/senddata(toallplayers:with:)) or the [`sendData:toPlayers:dataMode:error:`](https://developer.apple.com/documentation/gamekit/gkmatch/send(_:to:datamode:)) method to send data. To process the data on the recipient side, implement the [`match:didReceiveData:fromRemotePlayer:`](https://developer.apple.com/documentation/gamekit/gkmatchdelegate/match(_:didreceive:fromremoteplayer:)) delegate method.
    ///
    /// To implement voice chat, use the [`voiceChatWithName:`](https://developer.apple.com/documentation/gamekit/gkmatch/voicechat(withname:)) method to create one or more voice channels represented by the returned [`GKVoiceChat`](https://developer.apple.com/documentation/gamekit/gkvoicechat) object.
    ///
    /// When you’re finished with a match, call the [`disconnect`](https://developer.apple.com/documentation/gamekit/gkmatch/disconnect()) method and set the match’s delegate to `nil`. Otherwise, GameKit may send [`match:player:didChangeConnectionState:`](https://developer.apple.com/documentation/gamekit/gkmatchdelegate/match(_:player:didchange:)-8ohgr) to the delegate until all players disconnect from the match.
    ///
    ///
    /// GKMatch represents an active networking sessions between players. It handles network communications and can report player connection status. All matches are created by a GKMatchmaker.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    pub struct GKMatch;
);

extern_conformance!(
    unsafe impl NSObjectProtocol for GKMatch {}
);

impl GKMatch {
    extern_methods!(
        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        #[unsafe(method(players))]
        #[unsafe(method_family = none)]
        pub unsafe fn players(&self) -> Retained<NSArray<GKPlayer>>;

        /// all the GKPlayers in the match
        #[unsafe(method(delegate))]
        #[unsafe(method_family = none)]
        pub unsafe fn delegate(&self) -> Option<Retained<ProtocolObject<dyn GKMatchDelegate>>>;

        /// Setter for [`delegate`][Self::delegate].
        ///
        /// This is a [weak property][objc2::topics::weak_property].
        #[unsafe(method(setDelegate:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setDelegate(&self, delegate: Option<&ProtocolObject<dyn GKMatchDelegate>>);

        #[unsafe(method(expectedPlayerCount))]
        #[unsafe(method_family = none)]
        pub unsafe fn expectedPlayerCount(&self) -> NSUInteger;

        #[cfg(feature = "GKDefines")]
        #[unsafe(method(properties))]
        #[unsafe(method_family = none)]
        pub unsafe fn properties(&self) -> Option<Retained<GKMatchProperties>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKDefines", feature = "GKPlayer"))]
        #[unsafe(method(playerProperties))]
        #[unsafe(method_family = none)]
        pub unsafe fn playerProperties(
            &self,
        ) -> Option<Retained<NSDictionary<GKPlayer, GKMatchProperties>>>;

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// Asynchronously send data to one or more GKPlayers. Returns YES if delivery started, NO if unable to start sending and error will be set.
        #[unsafe(method(sendData:toPlayers:dataMode:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendData_toPlayers_dataMode_error(
            &self,
            data: &NSData,
            players: &NSArray<GKPlayer>,
            mode: GKMatchSendDataMode,
        ) -> Result<(), Retained<NSError>>;

        /// Asynchronously broadcasts data to all players. Returns YES if delivery started, NO if unable to start sending and error will be set.
        #[unsafe(method(sendDataToAllPlayers:withDataMode:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendDataToAllPlayers_withDataMode_error(
            &self,
            data: &NSData,
            mode: GKMatchSendDataMode,
        ) -> Result<(), Retained<NSError>>;

        /// Disconnect the match. This will show all other players in the match that the local player has disconnected. This should be called before releasing the match instance.
        #[unsafe(method(disconnect))]
        #[unsafe(method_family = none)]
        pub unsafe fn disconnect(&self);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer", feature = "block2"))]
        /// Choose the best host from among the connected players using gathered estimates for bandwidth and packet loss. This is intended for applications that wish to implement a client-server model on top of the match. The returned player ID will be nil if the best host cannot currently be determined (e.g. players are still connecting).
        #[unsafe(method(chooseBestHostingPlayerWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn chooseBestHostingPlayerWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut GKPlayer)>,
        );

        #[cfg(feature = "block2")]
        /// Automatching to recreate a previous peer-to-peer match that became disconnected. A new match with the same set of players will be returned by the completion handler. All players should perform this when the match has ended for automatching to succeed. Error will be nil on success.
        /// Possible reasons for error:
        /// 1. Communications failure
        /// 2. Timeout
        #[unsafe(method(rematchWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn rematchWithCompletionHandler(
            &self,
            completion_handler: Option<&block2::DynBlock<dyn Fn(*mut GKMatch, *mut NSError)>>,
        );

        #[cfg(feature = "GKVoiceChat")]
        /// * This method is deprecated. GKVoiceChat is no longer supported. **
        #[deprecated = "No longer supported"]
        #[unsafe(method(voiceChatWithName:))]
        #[unsafe(method_family = none)]
        pub unsafe fn voiceChatWithName(&self, name: &NSString) -> Option<Retained<GKVoiceChat>>;
    );
}

/// Methods declared on superclass `NSObject`.
impl GKMatch {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

extern_protocol!(
    /// An object that receives connection status and data transmitted in a multiplayer game.
    pub unsafe trait GKMatchDelegate: NSObjectProtocol {
        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// The match received data sent from the player.
        #[optional]
        #[unsafe(method(match:didReceiveData:fromRemotePlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_didReceiveData_fromRemotePlayer(
            &self,
            r#match: &GKMatch,
            data: &NSData,
            player: &GKPlayer,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        #[optional]
        #[unsafe(method(match:didReceiveData:forRecipient:fromRemotePlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_didReceiveData_forRecipient_fromRemotePlayer(
            &self,
            r#match: &GKMatch,
            data: &NSData,
            recipient: &GKPlayer,
            player: &GKPlayer,
        );

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// The player state changed (eg. connected or disconnected)
        #[optional]
        #[unsafe(method(match:player:didChangeConnectionState:))]
        #[unsafe(method_family = none)]
        unsafe fn match_player_didChangeConnectionState(
            &self,
            r#match: &GKMatch,
            player: &GKPlayer,
            state: GKPlayerConnectionState,
        );

        /// The match was unable to be established with any players due to an error.
        #[optional]
        #[unsafe(method(match:didFailWithError:))]
        #[unsafe(method_family = none)]
        unsafe fn match_didFailWithError(&self, r#match: &GKMatch, error: Option<&NSError>);

        #[cfg(all(feature = "GKBasePlayer", feature = "GKPlayer"))]
        /// This method is called when the match is interrupted; if it returns YES, a new invite will be sent to attempt reconnection. This is supported only for 1v1 games
        #[optional]
        #[unsafe(method(match:shouldReinviteDisconnectedPlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_shouldReinviteDisconnectedPlayer(
            &self,
            r#match: &GKMatch,
            player: &GKPlayer,
        ) -> bool;

        /// * These protocol methods are obsoleted. They will never be invoked and their implementation does nothing**
        #[deprecated]
        #[optional]
        #[unsafe(method(match:didReceiveData:fromPlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_didReceiveData_fromPlayer(
            &self,
            r#match: &GKMatch,
            data: &NSData,
            player_id: &NSString,
        );

        #[deprecated]
        #[optional]
        #[unsafe(method(match:player:didChangeState:))]
        #[unsafe(method_family = none)]
        unsafe fn match_player_didChangeState(
            &self,
            r#match: &GKMatch,
            player_id: &NSString,
            state: GKPlayerConnectionState,
        );

        #[deprecated]
        #[optional]
        #[unsafe(method(match:shouldReinvitePlayer:))]
        #[unsafe(method_family = none)]
        unsafe fn match_shouldReinvitePlayer(
            &self,
            r#match: &GKMatch,
            player_id: &NSString,
        ) -> bool;
    }
);

/// Obsoleted.
impl GKMatch {
    extern_methods!(
        #[cfg(feature = "block2")]
        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[unsafe(method(chooseBestHostPlayerWithCompletionHandler:))]
        #[unsafe(method_family = none)]
        pub unsafe fn chooseBestHostPlayerWithCompletionHandler(
            &self,
            completion_handler: &block2::DynBlock<dyn Fn(*mut NSString)>,
        );

        /// * This method is obsolete. It will never be invoked and its implementation does nothing**
        #[deprecated]
        #[unsafe(method(sendData:toPlayers:withDataMode:error:_))]
        #[unsafe(method_family = none)]
        pub unsafe fn sendData_toPlayers_withDataMode_error(
            &self,
            data: &NSData,
            player_i_ds: &NSArray<NSString>,
            mode: GKMatchSendDataMode,
        ) -> Result<(), Retained<NSError>>;

        /// * This property is obsolete.  **
        #[deprecated]
        #[unsafe(method(playerIDs))]
        #[unsafe(method_family = none)]
        pub unsafe fn playerIDs(&self) -> Option<Retained<NSArray<NSString>>>;
    );
}
