//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;

use crate::*;

#[cfg(all(feature = "JSContext", feature = "objc2"))]
impl JSContext {
    /// Creates a JavaScript context group.
    ///
    /// A JSContextGroup associates JavaScript contexts with one another.
    /// Contexts in the same group may share and exchange JavaScript objects. Sharing and/or exchanging
    /// JavaScript objects between contexts in different groups will produce undefined behavior.
    /// When objects from the same context group are used in multiple threads, explicit
    /// synchronization is required.
    ///
    /// A JSContextGroup may need to run deferred tasks on a run loop, such as garbage collection
    /// or resolving WebAssembly compilations. By default, calling JSContextGroupCreate will use
    /// the run loop of the thread it was called on. Currently, there is no API to change a
    /// JSContextGroup's run loop once it has been created.
    ///
    /// Returns: The created JSContextGroup.
    #[doc(alias = "JSContextGroupCreate")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn group_create() -> JSContextGroupRef {
        extern "C-unwind" {
            fn JSContextGroupCreate() -> JSContextGroupRef;
        }
        unsafe { JSContextGroupCreate() }
    }

    /// Retains a JavaScript context group.
    ///
    /// Parameter `group`: The JSContextGroup to retain.
    ///
    /// Returns: A JSContextGroup that is the same as group.
    ///
    /// # Safety
    ///
    /// `group` must be a valid pointer.
    #[doc(alias = "JSContextGroupRetain")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn group_retain(group: JSContextGroupRef) -> JSContextGroupRef {
        extern "C-unwind" {
            fn JSContextGroupRetain(group: JSContextGroupRef) -> JSContextGroupRef;
        }
        unsafe { JSContextGroupRetain(group) }
    }

    /// Releases a JavaScript context group.
    ///
    /// Parameter `group`: The JSContextGroup to release.
    ///
    /// # Safety
    ///
    /// `group` must be a valid pointer.
    #[doc(alias = "JSContextGroupRelease")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn group_release(group: JSContextGroupRef) {
        extern "C-unwind" {
            fn JSContextGroupRelease(group: JSContextGroupRef);
        }
        unsafe { JSContextGroupRelease(group) }
    }
}

extern "C-unwind" {
    /// Creates a global JavaScript execution context.
    ///
    /// JSGlobalContextCreate allocates a global object and populates it with all the
    /// built-in JavaScript objects, such as Object, Function, String, and Array.
    ///
    /// In WebKit version 4.0 and later, the context is created in a unique context group.
    /// Therefore, scripts may execute in it concurrently with scripts executing in other contexts.
    /// However, you may not use values created in the context in other contexts.
    ///
    /// Parameter `globalObjectClass`: The class to use when creating the global object. Pass
    /// NULL to use the default object class.
    ///
    /// Returns: A JSGlobalContext with a global object of class globalObjectClass.
    ///
    /// # Safety
    ///
    /// `global_object_class` must be a valid pointer.
    #[cfg(feature = "JSBase")]
    pub fn JSGlobalContextCreate(global_object_class: JSClassRef) -> JSGlobalContextRef;
}

extern "C-unwind" {
    /// Creates a global JavaScript execution context in the context group provided.
    ///
    /// JSGlobalContextCreateInGroup allocates a global object and populates it with
    /// all the built-in JavaScript objects, such as Object, Function, String, and Array.
    ///
    /// Parameter `globalObjectClass`: The class to use when creating the global object. Pass
    /// NULL to use the default object class.
    ///
    /// Parameter `group`: The context group to use. The created global context retains the group.
    /// Pass NULL to create a unique group for the context.
    ///
    /// Returns: A JSGlobalContext with a global object of class globalObjectClass and a context
    /// group equal to group.
    ///
    /// # Safety
    ///
    /// - `group` must be a valid pointer.
    /// - `global_object_class` must be a valid pointer.
    #[cfg(feature = "JSBase")]
    pub fn JSGlobalContextCreateInGroup(
        group: JSContextGroupRef,
        global_object_class: JSClassRef,
    ) -> JSGlobalContextRef;
}

extern "C-unwind" {
    /// Retains a global JavaScript execution context.
    ///
    /// Parameter `ctx`: The JSGlobalContext to retain.
    ///
    /// Returns: A JSGlobalContext that is the same as ctx.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[cfg(feature = "JSBase")]
    pub fn JSGlobalContextRetain(ctx: JSGlobalContextRef) -> JSGlobalContextRef;
}

extern "C-unwind" {
    /// Releases a global JavaScript execution context.
    ///
    /// Parameter `ctx`: The JSGlobalContext to release.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[cfg(feature = "JSBase")]
    pub fn JSGlobalContextRelease(ctx: JSGlobalContextRef);
}

#[cfg(all(feature = "JSContext", feature = "objc2"))]
impl JSContext {
    /// Gets the global object of a JavaScript execution context.
    ///
    /// Parameter `ctx`: The JSContext whose global object you want to get.
    ///
    /// Returns: ctx's global object.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSContextGetGlobalObject")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn global_object(ctx: JSContextRef) -> JSObjectRef {
        extern "C-unwind" {
            fn JSContextGetGlobalObject(ctx: JSContextRef) -> JSObjectRef;
        }
        unsafe { JSContextGetGlobalObject(ctx) }
    }

    /// Gets the context group to which a JavaScript execution context belongs.
    ///
    /// Parameter `ctx`: The JSContext whose group you want to get.
    ///
    /// Returns: ctx's group.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSContextGetGroup")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn group(ctx: JSContextRef) -> JSContextGroupRef {
        extern "C-unwind" {
            fn JSContextGetGroup(ctx: JSContextRef) -> JSContextGroupRef;
        }
        unsafe { JSContextGetGroup(ctx) }
    }

    /// Gets the global context of a JavaScript execution context.
    ///
    /// Parameter `ctx`: The JSContext whose global context you want to get.
    ///
    /// Returns: ctx's global context.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSContextGetGlobalContext")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn global_context(ctx: JSContextRef) -> JSGlobalContextRef {
        extern "C-unwind" {
            fn JSContextGetGlobalContext(ctx: JSContextRef) -> JSGlobalContextRef;
        }
        unsafe { JSContextGetGlobalContext(ctx) }
    }
}

extern "C-unwind" {
    /// Gets a copy of the name of a context.
    ///
    /// Parameter `ctx`: The JSGlobalContext whose name you want to get.
    ///
    /// Returns: The name for ctx.
    ///
    /// A JSGlobalContext's name is exposed when inspecting the context to make it easier to identify the context you would like to inspect.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[cfg(feature = "JSBase")]
    pub fn JSGlobalContextCopyName(ctx: JSGlobalContextRef) -> JSStringRef;
}

extern "C-unwind" {
    /// Sets the name exposed when inspecting a context.
    ///
    /// Parameter `ctx`: The JSGlobalContext that you want to name.
    ///
    /// Parameter `name`: The name to set on the context.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `name` must be a valid pointer.
    #[cfg(feature = "JSBase")]
    pub fn JSGlobalContextSetName(ctx: JSGlobalContextRef, name: JSStringRef);
}

extern "C-unwind" {
    /// Gets whether the context is inspectable in Web Inspector.
    ///
    /// Parameter `ctx`: The JSGlobalContext that you want to change the inspectability of.
    ///
    /// Returns: Whether the context is inspectable in Web Inspector.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[cfg(feature = "JSBase")]
    pub fn JSGlobalContextIsInspectable(ctx: JSGlobalContextRef) -> bool;
}

extern "C-unwind" {
    /// Sets whether the context is inspectable in Web Inspector. Default value is NO.
    ///
    /// Parameter `ctx`: The JSGlobalContext that you want to change the inspectability of.
    ///
    /// Parameter `inspectable`: YES to allow Web Inspector to connect to the context, otherwise NO.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[cfg(feature = "JSBase")]
    pub fn JSGlobalContextSetInspectable(ctx: JSGlobalContextRef, inspectable: bool);
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSContext::group_create`"]
    pub fn JSContextGroupCreate() -> JSContextGroupRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSContext::group_retain`"]
    pub fn JSContextGroupRetain(group: JSContextGroupRef) -> JSContextGroupRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSContext::group_release`"]
    pub fn JSContextGroupRelease(group: JSContextGroupRef);
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSContext::global_object`"]
    pub fn JSContextGetGlobalObject(ctx: JSContextRef) -> JSObjectRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSContext::group`"]
    pub fn JSContextGetGroup(ctx: JSContextRef) -> JSContextGroupRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSContext::global_context`"]
    pub fn JSContextGetGlobalContext(ctx: JSContextRef) -> JSGlobalContextRef;
}
