//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

#[cfg(feature = "objc2")]
extern_protocol!(
    /// The protocol for exporting Objective-C objects to JavaScript.
    ///
    /// ## Overview
    ///
    /// Implement this protocol to export your Objective-C classes and their instance methods, class methods, and properties to JavaScript code.
    ///
    /// ### Export Objective-C Objects to JavaScript
    ///
    /// When you create a JavaScript value from an instance of an Objective-C class, and the [`JSValue`](https://developer.apple.com/documentation/javascriptcore/jsvalue) class doesn’t specify a copying convention, JavaScriptCore creates a JavaScript wrapper object. For certain classes, JavaScriptCore automatically copies values to the appropriate JavaScript type; for example, [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) instances become JavaScript strings.
    ///
    /// JavaScript supports inheritance using a chain of prototype objects. For each Objective-C class you export, JavaScriptCore creates a prototype within the enclosing JavaScript context (a [`JSContext`](https://developer.apple.com/documentation/javascriptcore/jscontext) object). For the [`NSObject`](https://developer.apple.com/documentation/objectivec/nsobject-swift.class) class, the prototype object is the JavaScript context’s `Object` prototype. For all other Objective-C classes, JavaScriptCore creates a prototype object with an internal `[Prototype]` property that points to the prototype property it creates for the Objective-C class’s superclass. As such, the prototype chain for a JavaScript wrapper object reflects the wrapped Objective-C type’s inheritance hierarchy.
    ///
    /// In addition to the prototype object, JavaScriptCore produces a JavaScript constructor object for each Objective-C class.
    ///
    /// ### Expose Objective-C Methods and Properties to JavaScript
    ///
    /// By default, no methods or properties of the Objective-C class have exposure to JavaScript. Instead, you must choose methods and properties to export. For each protocol that a class conforms to, if the protocol incorporates the [`JSExport`](https://developer.apple.com/documentation/javascriptcore/jsexport) protocol, JavaScriptCore interprets that protocol as a list of methods and properties to export to JavaScript.
    ///
    /// For each instance method you export, JavaScriptCore creates a corresponding JavaScript function as a property of the prototype object. For each Objective-C property you export, JavaScriptCore creates a JavaScript accessor property on the prototype. For each class method you export, JavaScriptCore creates a JavaScript function on the constructor object. The following code example illustrates adoption of the [`JSExport`](https://developer.apple.com/documentation/javascriptcore/jsexport) protocol:
    ///
    /// ```objc
    /// @protocol MyPointExports <JSExport>
    /// @property double x;
    /// @property double y;
    /// - (NSString *)description;
    /// - (instancetype)initWithX:(double)x y:(double)y;
    /// + (MyPoint *)makePointWithX:(double)x y:(double)y;
    /// @end
    ///  
    /// @interface MyPoint : NSObject <MyPointExports>
    /// - (void)myPrivateMethod;  // This isn't in the MyPointExports protocol, so it isn't visible to JavaScript code.
    /// @end
    ///  
    /// @implementation MyPoint
    /// // ...
    /// @end
    /// ```
    ///
    /// The following code example illustrates the API that an exported class presents in JavaScript:
    ///
    /// ```javascript
    /// // Objective-C properties become fields.
    /// point.x;
    /// point.x = 10;
    /// // Objective-C instance methods become functions.
    /// point.description();
    /// // Call Objective-C initializers with constructor syntax.
    /// var p = MyPoint(1, 2);
    /// // Objective-C class methods become functions on the constructor object.
    /// var q = MyPoint.makePointWithXY(0, 0);
    /// ```
    ///
    /// The attributes of an Objective-C `@property` declaration determine the attributes of the corresponding JavaScript property as follows:
    ///
    /// - If the Objective-C property is `readonly`, the JavaScript property has the attributes `writable: false`, `enumerable: false`, `configurable: true`.
    ///
    /// - If the Objective-C property is `readwrite`, the JavaScript property has the attributes `writable: true`, `enumerable: true`, `configurable: true`.
    ///
    /// Wrapped Objective-C properties, parameters, and return values convert according to the copying convention that the [`JSValue`](https://developer.apple.com/documentation/javascriptcore/jsvalue) class specifies for their types. See [`JSValue`](https://developer.apple.com/documentation/javascriptcore/jsvalue) for the complete list of copying conventions.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  If a class declares conformance to the [`JSExport`](https://developer.apple.com/documentation/javascriptcore/jsexport) protocol, JavaScriptCore ignores its normal copying conventions for built-in types. For example, if you define a custom [`NSString`](https://developer.apple.com/documentation/foundation/nsstring) subclass that conforms to the [`JSExport`](https://developer.apple.com/documentation/javascriptcore/jsexport) protocol and pass an instance of that class to the `valueWithObject:` method, the result is a JavaScript wrapper object for the custom class, not a JavaScript string primitive.
    ///
    ///
    ///
    /// </div>
    /// ### Customize Export of Objective-C Selectors
    ///
    /// When exporting a selector that takes one or more arguments, JavaScriptCore generates a corresponding function name using the following conversion:
    ///
    /// - It removes all colons from the selector.
    ///
    /// - It capitalizes any lowercase letter that follows a colon.
    ///
    /// For example, under the default conversion, the Objective-C selector `doX:withY:` exports as the JavaScript function `doXWithY`.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  You can only apply the `JSExportAs` macro to a selector that takes one or more arguments.
    ///
    ///
    ///
    /// </div>
    /// To rename a selector that you export to JavaScript, use the `JSExportAs` macro. For example, to instead export the Objective-C selector `doX:withY:` as the JavaScript function `doX`, use the following declaration:
    ///
    /// ```objc
    /// @protocol MyClassJavaScriptMethods <JSExport>
    /// JSExportAs(doX,
    /// - (void)doX:(id)x withY:(id)y
    /// );
    /// @end
    /// ```
    ///
    ///
    /// JSExport provides a declarative way to export Objective-C objects and
    /// classes -- including properties, instance methods, class methods, and
    /// initializers -- to JavaScript.
    ///
    /// When an Objective-C object is exported to JavaScript, a JavaScript
    /// wrapper object is created.
    ///
    /// In JavaScript, inheritance works via a chain of prototype objects.
    /// For each Objective-C class in each JSContext, an object appropriate for use
    /// as a prototype will be provided. For the class NSObject the prototype
    /// will be the Object prototype. For all other Objective-C
    /// classes a prototype will be created. The prototype for a given
    /// Objective-C class will have its internal [Prototype] property set to point to
    /// the prototype created for the Objective-C class's superclass. As such the
    /// prototype chain for a JavaScript wrapper object will reflect the wrapped
    /// Objective-C type's inheritance hierarchy.
    ///
    /// JavaScriptCore also produces a constructor for each Objective-C class. The
    /// constructor has a property named 'prototype' that references the prototype,
    /// and the prototype has a property named 'constructor' that references the
    /// constructor.
    ///
    /// By default JavaScriptCore does not export any methods or properties from an
    /// Objective-C class to JavaScript; however methods and properties may be exported
    /// explicitly using JSExport. For each protocol that a class conforms to, if the
    /// protocol incorporates the protocol JSExport, JavaScriptCore exports the methods
    /// and properties in that protocol to JavaScript
    ///
    /// For each exported instance method JavaScriptCore will assign a corresponding
    /// JavaScript function to the prototype. For each exported Objective-C property
    /// JavaScriptCore will assign a corresponding JavaScript accessor to the prototype.
    /// For each exported class method JavaScriptCore will assign a corresponding
    /// JavaScript function to the constructor. For example:
    ///
    /// <pre>
    ///
    /// ```text
    ///     @protocol MyClassJavaScriptMethods <JSExport>
    ///     - (void)foo;
    ///     @end
    ///
    ///     @interface MyClass : NSObject <MyClassJavaScriptMethods>
    ///     - (void)foo;
    ///     - (void)bar;
    ///     @end
    /// ```
    ///
    /// </pre>
    ///
    /// Data properties that are created on the prototype or constructor objects have
    /// the attributes:
    /// <code>
    /// writable:true
    /// </code>
    /// ,
    /// <code>
    /// enumerable:false
    /// </code>
    /// ,
    /// <code>
    /// configurable:true
    /// </code>
    /// .
    /// Accessor properties have the attributes:
    /// <code>
    /// enumerable:false
    /// </code>
    /// and
    /// <code>
    /// configurable:true
    /// </code>
    /// .
    ///
    /// If an instance of
    /// <code>
    /// MyClass
    /// </code>
    /// is converted to a JavaScript value, the resulting
    /// wrapper object will (via its prototype) export the method
    /// <code>
    /// foo
    /// </code>
    /// to JavaScript,
    /// since the class conforms to the
    /// <code>
    /// MyClassJavaScriptMethods
    /// </code>
    /// protocol, and this
    /// protocol incorporates
    /// <code>
    /// JSExport
    /// </code>
    /// .
    /// <code>
    /// bar
    /// </code>
    /// will not be exported.
    ///
    /// JSExport supports properties, arguments, and return values of the following types:
    ///
    /// Primitive numbers: signed values up to 32-bits convert using JSValue's
    /// valueWithInt32/toInt32. Unsigned values up to 32-bits convert using JSValue's
    /// valueWithUInt32/toUInt32. All other numeric values convert using JSValue's
    /// valueWithDouble/toDouble.
    ///
    /// BOOL: values convert using JSValue's valueWithBool/toBool.
    ///
    /// id: values convert using JSValue's valueWithObject/toObject.
    ///
    /// Objective-C instance pointers: Pointers convert using JSValue's
    /// valueWithObjectOfClass/toObject.
    ///
    /// C structs: C structs for CGPoint, NSRange, CGRect, and CGSize convert using
    /// JSValue's appropriate methods. Other C structs are not supported.
    ///
    /// Blocks: Blocks convert using JSValue's valueWithObject/toObject.
    ///
    /// All objects that conform to JSExport convert to JavaScript wrapper objects,
    /// even if they subclass classes that would otherwise behave differently. For
    /// example, if a subclass of NSString conforms to JSExport, it converts to
    /// JavaScript as a wrapper object rather than a JavaScript string.
    #[cfg(feature = "objc2")]
    pub unsafe trait JSExport {}
);
