//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

#[cfg(feature = "objc2")]
extern_class!(
    /// A self-contained environment for JavaScript execution.
    ///
    /// ## Overview
    ///
    /// You use this class for two main purposes: to support concurrent JavaScript execution, and to manage memory for objects that bridge between JavaScript and Objective-C or Swift.
    ///
    /// ### Support Threading and Concurrent JavaScript Execution
    ///
    /// Each JavaScript context (a [`JSContext`](https://developer.apple.com/documentation/javascriptcore/jscontext) object) belongs to a virtual machine. Each virtual machine can encompass multiple contexts, allowing values ([`JSValue`](https://developer.apple.com/documentation/javascriptcore/jsvalue) objects) to pass between contexts. However, each virtual machine is distinct—you can’t pass a value that you create in one virtual machine to a context in another virtual machine.
    ///
    /// The JavaScriptCore API is thread-safe—for example, you can create [`JSValue`](https://developer.apple.com/documentation/javascriptcore/jsvalue) objects or evaluate scripts from any thread—however, all other threads attempting to use the same virtual machine must wait. To run JavaScript concurrently on multiple threads, use a separate [`JSVirtualMachine`](https://developer.apple.com/documentation/javascriptcore/jsvirtualmachine) instance for each thread.
    ///
    /// ### Manage Memory for Exported Objects
    ///
    /// When you export an Objective-C or Swift object to JavaScript, you must not to store JavaScript values in that object. This action creates a retain cycle—[`JSValue`](https://developer.apple.com/documentation/javascriptcore/jsvalue) objects hold strong references to their enclosing JavaScript contexts, and [`JSContext`](https://developer.apple.com/documentation/javascriptcore/jscontext) objects hold strong references to the native objects you export to JavaScript. Instead, use the [`JSManagedValue`](https://developer.apple.com/documentation/javascriptcore/jsmanagedvalue) class to conditionally retain a JavaScript value, and report the native ownership chain for that managed value to the JavaScriptCore virtual machine. Use the [`addManagedReference:withOwner:`](https://developer.apple.com/documentation/javascriptcore/jsvirtualmachine/addmanagedreference(_:withowner:)) and [`removeManagedReference:withOwner:`](https://developer.apple.com/documentation/javascriptcore/jsvirtualmachine/removemanagedreference(_:withowner:)) methods to describe your native object graph to JavaScriptCore. After you remove the last managed reference for an object, the JavaScript garbage collector can safely destroy that object.
    ///
    ///
    /// An instance of JSVirtualMachine represents a single JavaScript "object space"
    /// or set of execution resources. Thread safety is supported by locking the
    /// virtual machine, with concurrent JavaScript execution supported by allocating
    /// separate instances of JSVirtualMachine.
    ///
    /// A virtual machine may need to run deferred tasks on a run loop, such as garbage collection
    /// or resolving WebAssembly compilations. By default, a virtual machine will use the run loop
    /// of the thread it was initialized on. Currently, there is no API to change a
    /// JSVirtualMachine's run loop once it has been initialized.
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "objc2")]
    pub struct JSVirtualMachine;
);

#[cfg(feature = "objc2")]
extern_conformance!(
    unsafe impl NSObjectProtocol for JSVirtualMachine {}
);

#[cfg(feature = "objc2")]
impl JSVirtualMachine {
    extern_methods!(
        /// Create a new JSVirtualMachine.
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        /// Notify the JSVirtualMachine of an external object relationship.
        ///
        /// Allows clients of JSVirtualMachine to make the JavaScript runtime aware of
        /// arbitrary external Objective-C object graphs. The runtime can then use
        /// this information to retain any JavaScript values that are referenced
        /// from somewhere in said object graph.
        ///
        /// For correct behavior clients must make their external object graphs
        /// reachable from within the JavaScript runtime. If an Objective-C object is
        /// reachable from within the JavaScript runtime, all managed references
        /// transitively reachable from it as recorded using
        /// -addManagedReference:withOwner: will be scanned by the garbage collector.
        ///
        /// Parameter `object`: The object that the owner points to.
        ///
        /// Parameter `owner`: The object that owns the pointed to object.
        ///
        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `object` might not allow `None`.
        /// - `owner` should be of the correct type.
        /// - `owner` might not allow `None`.
        #[unsafe(method(addManagedReference:withOwner:))]
        #[unsafe(method_family = none)]
        pub unsafe fn addManagedReference_withOwner(
            &self,
            object: Option<&AnyObject>,
            owner: Option<&AnyObject>,
        );

        /// Notify the JSVirtualMachine that a previous object relationship no longer exists.
        ///
        /// The JavaScript runtime will continue to scan any references that were
        /// reported to it by -addManagedReference:withOwner: until those references are removed.
        ///
        /// Parameter `object`: The object that was formerly owned.
        ///
        /// Parameter `owner`: The former owner.
        ///
        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `object` might not allow `None`.
        /// - `owner` should be of the correct type.
        /// - `owner` might not allow `None`.
        #[unsafe(method(removeManagedReference:withOwner:))]
        #[unsafe(method_family = none)]
        pub unsafe fn removeManagedReference_withOwner(
            &self,
            object: Option<&AnyObject>,
            owner: Option<&AnyObject>,
        );
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "objc2")]
impl JSVirtualMachine {
    extern_methods!(
        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
