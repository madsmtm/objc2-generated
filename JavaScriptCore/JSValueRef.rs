//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// A constant identifying the type of a JSValue.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jstype?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct JSType(pub c_uint);
impl JSType {
    #[doc(alias = "kJSTypeUndefined")]
    pub const Undefined: Self = Self(0);
    #[doc(alias = "kJSTypeNull")]
    pub const Null: Self = Self(1);
    #[doc(alias = "kJSTypeBoolean")]
    pub const Boolean: Self = Self(2);
    #[doc(alias = "kJSTypeNumber")]
    pub const Number: Self = Self(3);
    #[doc(alias = "kJSTypeString")]
    pub const String: Self = Self(4);
    #[doc(alias = "kJSTypeObject")]
    pub const Object: Self = Self(5);
    #[doc(alias = "kJSTypeSymbol")]
    pub const Symbol: Self = Self(6);
    #[doc(alias = "kJSTypeBigInt")]
    pub const BigInt: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for JSType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for JSType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A constant identifying the Typed Array type of a JSObjectRef.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jstypedarraytype?language=objc)
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct JSTypedArrayType(pub c_uint);
impl JSTypedArrayType {
    #[doc(alias = "kJSTypedArrayTypeInt8Array")]
    pub const Int8Array: Self = Self(0);
    #[doc(alias = "kJSTypedArrayTypeInt16Array")]
    pub const Int16Array: Self = Self(1);
    #[doc(alias = "kJSTypedArrayTypeInt32Array")]
    pub const Int32Array: Self = Self(2);
    #[doc(alias = "kJSTypedArrayTypeUint8Array")]
    pub const Uint8Array: Self = Self(3);
    #[doc(alias = "kJSTypedArrayTypeUint8ClampedArray")]
    pub const Uint8ClampedArray: Self = Self(4);
    #[doc(alias = "kJSTypedArrayTypeUint16Array")]
    pub const Uint16Array: Self = Self(5);
    #[doc(alias = "kJSTypedArrayTypeUint32Array")]
    pub const Uint32Array: Self = Self(6);
    #[doc(alias = "kJSTypedArrayTypeFloat32Array")]
    pub const Float32Array: Self = Self(7);
    #[doc(alias = "kJSTypedArrayTypeFloat64Array")]
    pub const Float64Array: Self = Self(8);
    #[doc(alias = "kJSTypedArrayTypeArrayBuffer")]
    pub const ArrayBuffer: Self = Self(9);
    #[doc(alias = "kJSTypedArrayTypeNone")]
    pub const None: Self = Self(10);
    #[doc(alias = "kJSTypedArrayTypeBigInt64Array")]
    pub const BigInt64Array: Self = Self(11);
    #[doc(alias = "kJSTypedArrayTypeBigUint64Array")]
    pub const BigUint64Array: Self = Self(12);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for JSTypedArrayType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for JSTypedArrayType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// A constant identifying the type of JavaScript relation condition.
///
/// See also [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jsrelationcondition?language=objc)
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct JSRelationCondition(pub u32);
impl JSRelationCondition {
    /// A constant identifying the type of JavaScript relation condition.
    #[doc(alias = "kJSRelationConditionUndefined")]
    pub const Undefined: Self = Self(0);
    /// A constant identifying the type of JavaScript relation condition.
    #[doc(alias = "kJSRelationConditionEqual")]
    pub const Equal: Self = Self(1);
    /// A constant identifying the type of JavaScript relation condition.
    #[doc(alias = "kJSRelationConditionGreaterThan")]
    pub const GreaterThan: Self = Self(2);
    /// A constant identifying the type of JavaScript relation condition.
    #[doc(alias = "kJSRelationConditionLessThan")]
    pub const LessThan: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for JSRelationCondition {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for JSRelationCondition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(all(feature = "JSValue", feature = "objc2"))]
impl JSValue {
    /// Returns a JavaScript value's type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue whose type you want to obtain.
    ///
    /// Returns: A value of type JSType that identifies value's type.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueGetType")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn r#type(ctx: JSContextRef, value: JSValueRef) -> JSType {
        extern "C-unwind" {
            fn JSValueGetType(ctx: JSContextRef, value: JSValueRef) -> JSType;
        }
        unsafe { JSValueGetType(ctx, value) }
    }

    /// Tests whether a JavaScript value's type is the undefined type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the undefined type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsUndefined")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_undefined(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsUndefined(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsUndefined(ctx, value) }
    }

    /// Tests whether a JavaScript value's type is the null type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the null type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsNull")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_null(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsNull(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsNull(ctx, value) }
    }

    /// Tests whether a JavaScript value's type is the boolean type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the boolean type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsBoolean")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_boolean(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsBoolean(ctx, value) }
    }

    /// Tests whether a JavaScript value's type is the number type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the number type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsNumber")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_number(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsNumber(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsNumber(ctx, value) }
    }

    /// Tests whether a JavaScript value's type is the string type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the string type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsString")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_string(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsString(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsString(ctx, value) }
    }

    /// Tests whether a JavaScript value's type is the symbol type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the symbol type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsSymbol")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_symbol(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsSymbol(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsSymbol(ctx, value) }
    }

    /// Tests whether a JavaScript value's type is the BigInt type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the BigInt type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsBigInt")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_big_int(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsBigInt(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsBigInt(ctx, value) }
    }

    /// Tests whether a JavaScript value's type is the object type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the object type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsObject")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_object(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsObject(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsObject(ctx, value) }
    }

    /// Tests whether a JavaScript value is an object with a given class in its class chain.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Parameter `jsClass`: The JSClass to test against.
    ///
    /// Returns: true if value is an object and has jsClass in its class chain, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `js_class` must be a valid pointer.
    #[doc(alias = "JSValueIsObjectOfClass")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_object_of_class(
        ctx: JSContextRef,
        value: JSValueRef,
        js_class: JSClassRef,
    ) -> bool {
        extern "C-unwind" {
            fn JSValueIsObjectOfClass(
                ctx: JSContextRef,
                value: JSValueRef,
                js_class: JSClassRef,
            ) -> bool;
        }
        unsafe { JSValueIsObjectOfClass(ctx, value, js_class) }
    }

    /// Tests whether a JavaScript value is an array.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value is an array, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsArray")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_array(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsArray(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsArray(ctx, value) }
    }

    /// Tests whether a JavaScript value is a date.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value is a date, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsDate")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_date(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsDate(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsDate(ctx, value) }
    }

    /// Returns a JavaScript value's Typed Array type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue whose Typed Array type to return.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of type JSTypedArrayType that identifies value's Typed Array type, or kJSTypedArrayTypeNone if the value is not a Typed Array object.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueGetTypedArrayType")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn typed_array_type(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType {
        extern "C-unwind" {
            fn JSValueGetTypedArrayType(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> JSTypedArrayType;
        }
        unsafe { JSValueGetTypedArrayType(ctx, value, exception) }
    }

    /// Tests whether two JavaScript values are equal, as compared by the JS == operator.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `a`: The first value to test.
    ///
    /// Parameter `b`: The second value to test.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: true if the two values are equal, false if they are not equal or an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `a` must be a valid pointer.
    /// - `b` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueIsEqual")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_equal(
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool {
        extern "C-unwind" {
            fn JSValueIsEqual(
                ctx: JSContextRef,
                a: JSValueRef,
                b: JSValueRef,
                exception: *mut JSValueRef,
            ) -> bool;
        }
        unsafe { JSValueIsEqual(ctx, a, b, exception) }
    }

    /// Tests whether two JavaScript values are strict equal, as compared by the JS === operator.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `a`: The first value to test.
    ///
    /// Parameter `b`: The second value to test.
    ///
    /// Returns: true if the two values are strict equal, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `a` must be a valid pointer.
    /// - `b` must be a valid pointer.
    #[doc(alias = "JSValueIsStrictEqual")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_strict_equal(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsStrictEqual(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool;
        }
        unsafe { JSValueIsStrictEqual(ctx, a, b) }
    }

    /// Tests whether a JavaScript value is an object constructed by a given constructor, as compared by the JS instanceof operator.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Parameter `constructor`: The constructor to test against.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: true if value is an object constructed by constructor, as compared by the JS instanceof operator, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `constructor` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueIsInstanceOfConstructor")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_instance_of_constructor(
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool {
        extern "C-unwind" {
            fn JSValueIsInstanceOfConstructor(
                ctx: JSContextRef,
                value: JSValueRef,
                constructor: JSObjectRef,
                exception: *mut JSValueRef,
            ) -> bool;
        }
        unsafe { JSValueIsInstanceOfConstructor(ctx, value, constructor, exception) }
    }

    /// Compares two JSValues.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The JSValue as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// The result is computed by comparing the results of JavaScript's `==`, `
    /// <
    /// `, and `>` operators. If either `left` or `right` is (or would coerce to) `NaN` in JavaScript, then the result is kJSRelationConditionUndefined.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `left` must be a valid pointer.
    /// - `right` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueCompare")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn compare(
        ctx: JSContextRef,
        left: JSValueRef,
        right: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition {
        extern "C-unwind" {
            fn JSValueCompare(
                ctx: JSContextRef,
                left: JSValueRef,
                right: JSValueRef,
                exception: *mut JSValueRef,
            ) -> JSRelationCondition;
        }
        unsafe { JSValueCompare(ctx, left, right, exception) }
    }

    /// Compares a JSValue with a signed 64-bit integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The int64_t as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// `left` is converted to an integer according to the rules specified by the JavaScript language then compared with `right`.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `left` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueCompareInt64")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn compare_int64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: i64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition {
        extern "C-unwind" {
            fn JSValueCompareInt64(
                ctx: JSContextRef,
                left: JSValueRef,
                right: i64,
                exception: *mut JSValueRef,
            ) -> JSRelationCondition;
        }
        unsafe { JSValueCompareInt64(ctx, left, right, exception) }
    }

    /// Compares a JSValue with an unsigned 64-bit integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The uint64_t as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// `left` is converted to an integer according to the rules specified by the JavaScript language then compared with `right`.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `left` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueCompareUInt64")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn compare_u_int64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: u64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition {
        extern "C-unwind" {
            fn JSValueCompareUInt64(
                ctx: JSContextRef,
                left: JSValueRef,
                right: u64,
                exception: *mut JSValueRef,
            ) -> JSRelationCondition;
        }
        unsafe { JSValueCompareUInt64(ctx, left, right, exception) }
    }

    /// Compares a JSValue with a double.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The double as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// `left` is converted to a double according to the rules specified by the JavaScript language then compared with `right`.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `left` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueCompareDouble")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn compare_double(
        ctx: JSContextRef,
        left: JSValueRef,
        right: c_double,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition {
        extern "C-unwind" {
            fn JSValueCompareDouble(
                ctx: JSContextRef,
                left: JSValueRef,
                right: c_double,
                exception: *mut JSValueRef,
            ) -> JSRelationCondition;
        }
        unsafe { JSValueCompareDouble(ctx, left, right, exception) }
    }

    /// Creates a JavaScript value of the undefined type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Returns: The unique undefined value.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSValueMakeUndefined")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_undefined(ctx: JSContextRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeUndefined(ctx: JSContextRef) -> JSValueRef;
        }
        unsafe { JSValueMakeUndefined(ctx) }
    }

    /// Creates a JavaScript value of the null type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Returns: The unique null value.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSValueMakeNull")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_null(ctx: JSContextRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeNull(ctx: JSContextRef) -> JSValueRef;
        }
        unsafe { JSValueMakeNull(ctx) }
    }

    /// Creates a JavaScript value of the boolean type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `boolean`: The bool to assign to the newly created JSValue.
    ///
    /// Returns: A JSValue of the boolean type, representing the value of boolean.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSValueMakeBoolean")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_boolean(ctx: JSContextRef, boolean: bool) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeBoolean(ctx: JSContextRef, boolean: bool) -> JSValueRef;
        }
        unsafe { JSValueMakeBoolean(ctx, boolean) }
    }

    /// Creates a JavaScript value of the number type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `number`: The double to assign to the newly created JSValue.
    ///
    /// Returns: A JSValue of the number type, representing the value of number.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSValueMakeNumber")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_number(ctx: JSContextRef, number: c_double) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeNumber(ctx: JSContextRef, number: c_double) -> JSValueRef;
        }
        unsafe { JSValueMakeNumber(ctx, number) }
    }

    /// Creates a JavaScript value of the string type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `string`: The JSString to assign to the newly created JSValue. The
    /// newly created JSValue retains string, and releases it upon garbage collection.
    ///
    /// Returns: A JSValue of the string type, representing the value of string.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `string` must be a valid pointer.
    #[doc(alias = "JSValueMakeString")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_string(ctx: JSContextRef, string: JSStringRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
        }
        unsafe { JSValueMakeString(ctx, string) }
    }

    /// Creates a JavaScript value of the symbol type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `description`: A description of the newly created symbol value.
    ///
    /// Returns: A unique JSValue of the symbol type, whose description matches the one provided.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `description` must be a valid pointer.
    #[doc(alias = "JSValueMakeSymbol")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_symbol(ctx: JSContextRef, description: JSStringRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeSymbol(ctx: JSContextRef, description: JSStringRef) -> JSValueRef;
        }
        unsafe { JSValueMakeSymbol(ctx, description) }
    }
}

extern "C-unwind" {
    /// Creates a JavaScript BigInt with a double.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The value to copy into the new BigInt JSValue.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the value, or NULL if an exception is thrown.
    ///
    /// If the value is not an integer, an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithDouble(
        ctx: JSContextRef,
        value: c_double,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript BigInt with a 64-bit signed integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `integer`: The 64-bit signed integer to copy into the new BigInt JSValue.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the integer, or NULL if an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithInt64(
        ctx: JSContextRef,
        integer: i64,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript BigInt with a 64-bit unsigned integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `integer`: The 64-bit unsigned integer to copy into the new BigInt JSValue.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the integer, or NULL if an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithUInt64(
        ctx: JSContextRef,
        integer: u64,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    /// Creates a JavaScript BigInt with an integer represented in string.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `string`: The JSStringRef representation of an integer.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the string, or NULL if an exception is thrown.
    ///
    /// This is equivalent to calling the `BigInt` constructor from JavaScript with a string argument.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `string` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithString(
        ctx: JSContextRef,
        string: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

#[cfg(all(feature = "JSValue", feature = "objc2"))]
impl JSValue {
    /// Creates a JavaScript value from a JSON formatted string.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `string`: The JSString containing the JSON string to be parsed.
    ///
    /// Returns: A JSValue containing the parsed value, or NULL if the input is invalid.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `string` must be a valid pointer.
    #[doc(alias = "JSValueMakeFromJSONString")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn from_json_string(ctx: JSContextRef, string: JSStringRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeFromJSONString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
        }
        unsafe { JSValueMakeFromJSONString(ctx, string) }
    }

    /// Creates a JavaScript string containing the JSON serialized representation of a JS value.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The value to serialize.
    ///
    /// Parameter `indent`: The number of spaces to indent when nesting.  If 0, the resulting JSON will not contains newlines.  The size of the indent is clamped to 10 spaces.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A JSString with the result of serialization, or NULL if an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueCreateJSONString")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn create_json_string(
        ctx: JSContextRef,
        value: JSValueRef,
        indent: c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef {
        extern "C-unwind" {
            fn JSValueCreateJSONString(
                ctx: JSContextRef,
                value: JSValueRef,
                indent: c_uint,
                exception: *mut JSValueRef,
            ) -> JSStringRef;
        }
        unsafe { JSValueCreateJSONString(ctx, value, indent, exception) }
    }

    /// Converts a JavaScript value to boolean and returns the resulting boolean.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Returns: The boolean result of conversion.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueToBoolean")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_boolean(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueToBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueToBoolean(ctx, value) }
    }

    /// Converts a JavaScript value to number and returns the resulting number.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: The numeric result of conversion, or NaN if an exception is thrown.
    ///
    /// The result is equivalent to `Number(value)` in JavaScript.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueToNumber")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_number(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> c_double {
        extern "C-unwind" {
            fn JSValueToNumber(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> c_double;
        }
        unsafe { JSValueToNumber(ctx, value, exception) }
    }

    /// Converts a JSValue to a singed 32-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: An int32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int32_t.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueToInt32")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_int32(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> i32 {
        extern "C-unwind" {
            fn JSValueToInt32(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> i32;
        }
        unsafe { JSValueToInt32(ctx, value, exception) }
    }

    /// Converts a JSValue to an unsigned 32-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A uint32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint32_t.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueToUInt32")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_u_int32(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> u32 {
        extern "C-unwind" {
            fn JSValueToUInt32(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> u32;
        }
        unsafe { JSValueToUInt32(ctx, value, exception) }
    }

    /// Converts a JSValue to a singed 64-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: An int64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int64_t.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueToInt64")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_int64(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> i64 {
        extern "C-unwind" {
            fn JSValueToInt64(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> i64;
        }
        unsafe { JSValueToInt64(ctx, value, exception) }
    }

    /// Converts a JSValue to an unsigned 64-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A uint64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint64_t.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueToUInt64")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_u_int64(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> u64 {
        extern "C-unwind" {
            fn JSValueToUInt64(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> u64;
        }
        unsafe { JSValueToUInt64(ctx, value, exception) }
    }

    /// Converts a JavaScript value to string and copies the result into a JavaScript string.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A JSString with the result of conversion, or NULL if an exception is thrown. Ownership follows the Create Rule.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueToStringCopy")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_string_copy(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef {
        extern "C-unwind" {
            fn JSValueToStringCopy(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> JSStringRef;
        }
        unsafe { JSValueToStringCopy(ctx, value, exception) }
    }

    /// Converts a JavaScript value to object and returns the resulting object.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: The JSObject result of conversion, or NULL if an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueToObject")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_object(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        extern "C-unwind" {
            fn JSValueToObject(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> JSObjectRef;
        }
        unsafe { JSValueToObject(ctx, value, exception) }
    }

    /// Protects a JavaScript value from garbage collection.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to protect.
    ///
    /// Use this method when you want to store a JSValue in a global or on the heap, where the garbage collector will not be able to discover your reference to it.
    ///
    /// A value may be protected multiple times and must be unprotected an equal number of times before becoming eligible for garbage collection.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueProtect")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn protect(ctx: JSContextRef, value: JSValueRef) {
        extern "C-unwind" {
            fn JSValueProtect(ctx: JSContextRef, value: JSValueRef);
        }
        unsafe { JSValueProtect(ctx, value) }
    }

    /// Unprotects a JavaScript value from garbage collection.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to unprotect.
    ///
    /// A value may be protected multiple times and must be unprotected an
    /// equal number of times before becoming eligible for garbage collection.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueUnprotect")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn unprotect(ctx: JSContextRef, value: JSValueRef) {
        extern "C-unwind" {
            fn JSValueUnprotect(ctx: JSContextRef, value: JSValueRef);
        }
        unsafe { JSValueUnprotect(ctx, value) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::type`"]
    pub fn JSValueGetType(ctx: JSContextRef, value: JSValueRef) -> JSType;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_undefined`"]
    pub fn JSValueIsUndefined(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_null`"]
    pub fn JSValueIsNull(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_boolean`"]
    pub fn JSValueIsBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_number`"]
    pub fn JSValueIsNumber(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_string`"]
    pub fn JSValueIsString(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_symbol`"]
    pub fn JSValueIsSymbol(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_big_int`"]
    pub fn JSValueIsBigInt(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_object`"]
    pub fn JSValueIsObject(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_object_of_class`"]
    pub fn JSValueIsObjectOfClass(
        ctx: JSContextRef,
        value: JSValueRef,
        js_class: JSClassRef,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_array`"]
    pub fn JSValueIsArray(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_date`"]
    pub fn JSValueIsDate(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::typed_array_type`"]
    pub fn JSValueGetTypedArrayType(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_equal`"]
    pub fn JSValueIsEqual(
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_strict_equal`"]
    pub fn JSValueIsStrictEqual(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_instance_of_constructor`"]
    pub fn JSValueIsInstanceOfConstructor(
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::compare`"]
    pub fn JSValueCompare(
        ctx: JSContextRef,
        left: JSValueRef,
        right: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::compare_int64`"]
    pub fn JSValueCompareInt64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: i64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::compare_u_int64`"]
    pub fn JSValueCompareUInt64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: u64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::compare_double`"]
    pub fn JSValueCompareDouble(
        ctx: JSContextRef,
        left: JSValueRef,
        right: c_double,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_undefined`"]
    pub fn JSValueMakeUndefined(ctx: JSContextRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_null`"]
    pub fn JSValueMakeNull(ctx: JSContextRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_boolean`"]
    pub fn JSValueMakeBoolean(ctx: JSContextRef, boolean: bool) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_number`"]
    pub fn JSValueMakeNumber(ctx: JSContextRef, number: c_double) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_string`"]
    pub fn JSValueMakeString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_symbol`"]
    pub fn JSValueMakeSymbol(ctx: JSContextRef, description: JSStringRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::from_json_string`"]
    pub fn JSValueMakeFromJSONString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::create_json_string`"]
    pub fn JSValueCreateJSONString(
        ctx: JSContextRef,
        value: JSValueRef,
        indent: c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_boolean`"]
    pub fn JSValueToBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_number`"]
    pub fn JSValueToNumber(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> c_double;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_int32`"]
    pub fn JSValueToInt32(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef) -> i32;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_u_int32`"]
    pub fn JSValueToUInt32(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef)
        -> u32;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_int64`"]
    pub fn JSValueToInt64(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef) -> i64;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_u_int64`"]
    pub fn JSValueToUInt64(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef)
        -> u64;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_string_copy`"]
    pub fn JSValueToStringCopy(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_object`"]
    pub fn JSValueToObject(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::protect`"]
    pub fn JSValueProtect(ctx: JSContextRef, value: JSValueRef);
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::unprotect`"]
    pub fn JSValueUnprotect(ctx: JSContextRef, value: JSValueRef);
}
