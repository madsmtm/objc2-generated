//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// Constants that identify the type of a JavaScript value.
/// A constant identifying the type of a JSValue.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct JSType(pub c_uint);
impl JSType {
    /// The unique undefined value.
    #[doc(alias = "kJSTypeUndefined")]
    pub const Undefined: Self = Self(0);
    /// The unique null value.
    #[doc(alias = "kJSTypeNull")]
    pub const Null: Self = Self(1);
    /// A primitive Boolean value.
    ///
    /// ## Discussion
    ///
    /// This value can be [`true`](https://developer.apple.com/documentation/swift/true) or [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    #[doc(alias = "kJSTypeBoolean")]
    pub const Boolean: Self = Self(2);
    /// A primitive number value.
    #[doc(alias = "kJSTypeNumber")]
    pub const Number: Self = Self(3);
    /// A primitive string value.
    #[doc(alias = "kJSTypeString")]
    pub const String: Self = Self(4);
    /// An object value.
    ///
    /// ## Discussion
    ///
    /// This [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) represents a [`JSObjectRef`](https://developer.apple.com/documentation/javascriptcore/jsobjectref).
    ///
    ///
    #[doc(alias = "kJSTypeObject")]
    pub const Object: Self = Self(5);
    /// A primitive symbol value.
    #[doc(alias = "kJSTypeSymbol")]
    pub const Symbol: Self = Self(6);
    #[doc(alias = "kJSTypeBigInt")]
    pub const BigInt: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for JSType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for JSType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

/// The type of a JavaScript typed array object.
/// A constant identifying the Typed Array type of a JSObjectRef.
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct JSTypedArrayType(pub c_uint);
impl JSTypedArrayType {
    /// An 8-bit integer array type.
    #[doc(alias = "kJSTypedArrayTypeInt8Array")]
    pub const Int8Array: Self = Self(0);
    /// A 16-bit integer array type.
    #[doc(alias = "kJSTypedArrayTypeInt16Array")]
    pub const Int16Array: Self = Self(1);
    /// A 32-bit integer array type.
    #[doc(alias = "kJSTypedArrayTypeInt32Array")]
    pub const Int32Array: Self = Self(2);
    /// An 8-bit unsigned integer array type.
    #[doc(alias = "kJSTypedArrayTypeUint8Array")]
    pub const Uint8Array: Self = Self(3);
    /// An 8-bit unsigned integer clamped array type.
    #[doc(alias = "kJSTypedArrayTypeUint8ClampedArray")]
    pub const Uint8ClampedArray: Self = Self(4);
    /// A 16-bit unsigned integer array type.
    #[doc(alias = "kJSTypedArrayTypeUint16Array")]
    pub const Uint16Array: Self = Self(5);
    /// A 32-bit unsigned integer array type.
    #[doc(alias = "kJSTypedArrayTypeUint32Array")]
    pub const Uint32Array: Self = Self(6);
    /// A 32-bit floating point array type.
    #[doc(alias = "kJSTypedArrayTypeFloat32Array")]
    pub const Float32Array: Self = Self(7);
    /// A 64-bit floating point array type.
    #[doc(alias = "kJSTypedArrayTypeFloat64Array")]
    pub const Float64Array: Self = Self(8);
    /// An array buffer type.
    #[doc(alias = "kJSTypedArrayTypeArrayBuffer")]
    pub const ArrayBuffer: Self = Self(9);
    /// Not a typed array.
    #[doc(alias = "kJSTypedArrayTypeNone")]
    pub const None: Self = Self(10);
    #[doc(alias = "kJSTypedArrayTypeBigInt64Array")]
    pub const BigInt64Array: Self = Self(11);
    #[doc(alias = "kJSTypedArrayTypeBigUint64Array")]
    pub const BigUint64Array: Self = Self(12);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for JSTypedArrayType {
    const ENCODING: Encoding = c_uint::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for JSTypedArrayType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

///
/// ## Overview
///
/// A constant identifying the type of JavaScript relation condition.
///
///
/// A constant identifying the type of JavaScript relation condition.
// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct JSRelationCondition(pub u32);
impl JSRelationCondition {
    ///
    /// ## Discussion
    ///
    /// A constant identifying the type of JavaScript relation condition.
    ///
    ///
    /// A constant identifying the type of JavaScript relation condition.
    #[doc(alias = "kJSRelationConditionUndefined")]
    pub const Undefined: Self = Self(0);
    ///
    /// ## Discussion
    ///
    /// A constant identifying the type of JavaScript relation condition.
    ///
    ///
    /// A constant identifying the type of JavaScript relation condition.
    #[doc(alias = "kJSRelationConditionEqual")]
    pub const Equal: Self = Self(1);
    ///
    /// ## Discussion
    ///
    /// A constant identifying the type of JavaScript relation condition.
    ///
    ///
    /// A constant identifying the type of JavaScript relation condition.
    #[doc(alias = "kJSRelationConditionGreaterThan")]
    pub const GreaterThan: Self = Self(2);
    ///
    /// ## Discussion
    ///
    /// A constant identifying the type of JavaScript relation condition.
    ///
    ///
    /// A constant identifying the type of JavaScript relation condition.
    #[doc(alias = "kJSRelationConditionLessThan")]
    pub const LessThan: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for JSRelationCondition {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for JSRelationCondition {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

#[cfg(all(feature = "JSValue", feature = "objc2"))]
impl JSValue {
    /// Returns a JavaScript value’s type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) with the type you want to obtain.
    ///
    ///
    /// ## Return Value
    ///
    /// A [`JSType`](https://developer.apple.com/documentation/javascriptcore/jstype) value that identifies the value’s type.
    ///
    ///
    /// Returns a JavaScript value's type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue whose type you want to obtain.
    ///
    /// Returns: A value of type JSType that identifies value's type.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueGetType")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn r#type(ctx: JSContextRef, value: JSValueRef) -> JSType {
        extern "C-unwind" {
            fn JSValueGetType(ctx: JSContextRef, value: JSValueRef) -> JSType;
        }
        unsafe { JSValueGetType(ctx, value) }
    }

    /// Tests whether a JavaScript value’s type is the undefined type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the type of `value` is the undefined type; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value's type is the undefined type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the undefined type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsUndefined")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_undefined(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsUndefined(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsUndefined(ctx, value) }
    }

    /// Tests whether a JavaScript value’s type is the null type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the type of `value` is the null type; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value's type is the null type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the null type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsNull")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_null(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsNull(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsNull(ctx, value) }
    }

    /// Tests whether a JavaScript value is Boolean.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if `value` is a Boolean; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value's type is the boolean type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the boolean type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsBoolean")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_boolean(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsBoolean(ctx, value) }
    }

    /// Tests whether a JavaScript value’s type is the number type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the type of `value` is the number type; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value's type is the number type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the number type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsNumber")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_number(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsNumber(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsNumber(ctx, value) }
    }

    /// Tests whether a JavaScript value’s type is the string type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the type of `value` is the string type; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value's type is the string type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the string type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsString")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_string(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsString(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsString(ctx, value) }
    }

    /// Tests whether a JavaScript value’s type is the symbol type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the type of `value` is the symbol type; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value's type is the symbol type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the symbol type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsSymbol")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_symbol(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsSymbol(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsSymbol(ctx, value) }
    }

    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The JSValue to test.
    ///
    ///
    /// ## Return Value
    ///
    /// True if value’s type is the BigInt type, otherwise false.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Tests whether a JavaScript value’s type is the BigInt type.
    ///
    ///
    /// Tests whether a JavaScript value's type is the BigInt type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the BigInt type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsBigInt")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_big_int(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsBigInt(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsBigInt(ctx, value) }
    }

    /// Tests whether a JavaScript value’s type is the object type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the type of `value` is the object type; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value's type is the object type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value's type is the object type, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsObject")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_object(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsObject(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsObject(ctx, value) }
    }

    /// Tests whether a JavaScript value is an object with a specified class in its class chain.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    /// - jsClass: The [`JSClassRef`](https://developer.apple.com/documentation/javascriptcore/jsclassref) to test against.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if `value` is an object and has `jsClass` in its class chain; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value is an object with a given class in its class chain.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Parameter `jsClass`: The JSClass to test against.
    ///
    /// Returns: true if value is an object and has jsClass in its class chain, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `js_class` must be a valid pointer.
    #[doc(alias = "JSValueIsObjectOfClass")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_object_of_class(
        ctx: JSContextRef,
        value: JSValueRef,
        js_class: JSClassRef,
    ) -> bool {
        extern "C-unwind" {
            fn JSValueIsObjectOfClass(
                ctx: JSContextRef,
                value: JSValueRef,
                js_class: JSClassRef,
            ) -> bool;
        }
        unsafe { JSValueIsObjectOfClass(ctx, value, js_class) }
    }

    /// Tests whether a JavaScript value is an array.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if `value` is an array; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value is an array.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value is an array, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsArray")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_array(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsArray(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsArray(ctx, value) }
    }

    /// Tests whether a JavaScript value is a date.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if `value` is a date; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value is a date.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Returns: true if value is a date, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueIsDate")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_date(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsDate(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueIsDate(ctx, value) }
    }

    /// Returns a JavaScript value’s typed array type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) with the typed array type to return.
    ///
    /// - exception: A pointer to a [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to store an exception in, if any. Pass `NULL` to discard any exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A value of type [`JSTypedArrayType`](https://developer.apple.com/documentation/javascriptcore/jstypedarraytype) that identifies the typed array type of `value`, or [`kJSTypedArrayTypeNone`](https://developer.apple.com/documentation/javascriptcore/kjstypedarraytypenone) if `value` isn’t a typed array object.
    ///
    ///
    /// Returns a JavaScript value's Typed Array type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue whose Typed Array type to return.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of type JSTypedArrayType that identifies value's Typed Array type, or kJSTypedArrayTypeNone if the value is not a Typed Array object.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueGetTypedArrayType")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn typed_array_type(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType {
        extern "C-unwind" {
            fn JSValueGetTypedArrayType(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> JSTypedArrayType;
        }
        unsafe { JSValueGetTypedArrayType(ctx, value, exception) }
    }

    /// Tests whether two JavaScript values are equal.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - a: The first value to test.
    ///
    /// - b: The second value to test.
    ///
    /// - exception: A pointer to a [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to store an exception in, if any. Pass `NULL` to discard any exception.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the two values are equal according to the JavaScript `==` operator; [`false`](https://developer.apple.com/documentation/swift/false) if they’re unequal or the system throws an exception.
    ///
    ///
    /// Tests whether two JavaScript values are equal, as compared by the JS == operator.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `a`: The first value to test.
    ///
    /// Parameter `b`: The second value to test.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: true if the two values are equal, false if they are not equal or an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `a` must be a valid pointer.
    /// - `b` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueIsEqual")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_equal(
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool {
        extern "C-unwind" {
            fn JSValueIsEqual(
                ctx: JSContextRef,
                a: JSValueRef,
                b: JSValueRef,
                exception: *mut JSValueRef,
            ) -> bool;
        }
        unsafe { JSValueIsEqual(ctx, a, b, exception) }
    }

    /// Tests whether two JavaScript values are strict equal.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - a: The first value to test.
    ///
    /// - b: The second value to test.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the two values are strict equal according to the JavaScript `===` operator; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether two JavaScript values are strict equal, as compared by the JS === operator.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `a`: The first value to test.
    ///
    /// Parameter `b`: The second value to test.
    ///
    /// Returns: true if the two values are strict equal, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `a` must be a valid pointer.
    /// - `b` must be a valid pointer.
    #[doc(alias = "JSValueIsStrictEqual")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_strict_equal(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueIsStrictEqual(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool;
        }
        unsafe { JSValueIsStrictEqual(ctx, a, b) }
    }

    /// Tests whether a JavaScript value is an object that the specified constructor creates.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to test.
    ///
    /// - constructor: The constructor to test against.
    ///
    /// - exception: A pointer to a [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to store an exception in, if any. Pass `NULL` to discard any exception.
    ///
    ///
    /// ## Return Value
    ///
    /// [`true`](https://developer.apple.com/documentation/swift/true) if the value is an object that `constructor` creates, according to the JavaScript `instanceof` operator; otherwise, [`false`](https://developer.apple.com/documentation/swift/false).
    ///
    ///
    /// Tests whether a JavaScript value is an object constructed by a given constructor, as compared by the JS instanceof operator.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to test.
    ///
    /// Parameter `constructor`: The constructor to test against.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: true if value is an object constructed by constructor, as compared by the JS instanceof operator, otherwise false.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `constructor` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueIsInstanceOfConstructor")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn is_instance_of_constructor(
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool {
        extern "C-unwind" {
            fn JSValueIsInstanceOfConstructor(
                ctx: JSContextRef,
                value: JSValueRef,
                constructor: JSObjectRef,
                exception: *mut JSValueRef,
            ) -> bool;
        }
        unsafe { JSValueIsInstanceOfConstructor(ctx, value, constructor, exception) }
    }

    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - left: The JSValue as the left operand.
    ///
    /// - right: The JSValue as the right operand.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Compares two JSValues.
    ///
    /// The result is computed by comparing the results of JavaScript’s `==`, `<`, and `>` operators. If either `left` or `right` is (or would coerce to) `NaN` in JavaScript, then the result is kJSRelationConditionUndefined.
    ///
    ///
    /// Compares two JSValues.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The JSValue as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// The result is computed by comparing the results of JavaScript's `==`, `
    /// <
    /// `, and `>` operators. If either `left` or `right` is (or would coerce to) `NaN` in JavaScript, then the result is kJSRelationConditionUndefined.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `left` must be a valid pointer.
    /// - `right` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueCompare")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn compare(
        ctx: JSContextRef,
        left: JSValueRef,
        right: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition {
        extern "C-unwind" {
            fn JSValueCompare(
                ctx: JSContextRef,
                left: JSValueRef,
                right: JSValueRef,
                exception: *mut JSValueRef,
            ) -> JSRelationCondition;
        }
        unsafe { JSValueCompare(ctx, left, right, exception) }
    }

    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - left: The JSValue as the left operand.
    ///
    /// - right: The int64_t as the right operand.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Compares a JSValue with a signed 64-bit integer.
    ///
    /// `left` is converted to an integer according to the rules specified by the JavaScript language then compared with `right`.
    ///
    ///
    /// Compares a JSValue with a signed 64-bit integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The int64_t as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// `left` is converted to an integer according to the rules specified by the JavaScript language then compared with `right`.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `left` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueCompareInt64")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn compare_int64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: i64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition {
        extern "C-unwind" {
            fn JSValueCompareInt64(
                ctx: JSContextRef,
                left: JSValueRef,
                right: i64,
                exception: *mut JSValueRef,
            ) -> JSRelationCondition;
        }
        unsafe { JSValueCompareInt64(ctx, left, right, exception) }
    }

    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - left: The JSValue as the left operand.
    ///
    /// - right: The uint64_t as the right operand.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Compares a JSValue with an unsigned 64-bit integer.
    ///
    /// `left` is converted to an integer according to the rules specified by the JavaScript language then compared with `right`.
    ///
    ///
    /// Compares a JSValue with an unsigned 64-bit integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The uint64_t as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// `left` is converted to an integer according to the rules specified by the JavaScript language then compared with `right`.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `left` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueCompareUInt64")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn compare_u_int64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: u64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition {
        extern "C-unwind" {
            fn JSValueCompareUInt64(
                ctx: JSContextRef,
                left: JSValueRef,
                right: u64,
                exception: *mut JSValueRef,
            ) -> JSRelationCondition;
        }
        unsafe { JSValueCompareUInt64(ctx, left, right, exception) }
    }

    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - left: The JSValue as the left operand.
    ///
    /// - right: The double as the right operand.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Compares a JSValue with a double.
    ///
    /// `left` is converted to a double according to the rules specified by the JavaScript language then compared with `right`.
    ///
    ///
    /// Compares a JSValue with a double.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `left`: The JSValue as the left operand.
    ///
    /// Parameter `right`: The double as the right operand.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
    ///
    /// `left` is converted to a double according to the rules specified by the JavaScript language then compared with `right`.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `left` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueCompareDouble")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn compare_double(
        ctx: JSContextRef,
        left: JSValueRef,
        right: c_double,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition {
        extern "C-unwind" {
            fn JSValueCompareDouble(
                ctx: JSContextRef,
                left: JSValueRef,
                right: c_double,
                exception: *mut JSValueRef,
            ) -> JSRelationCondition;
        }
        unsafe { JSValueCompareDouble(ctx, left, right, exception) }
    }

    /// Creates a JavaScript value of the undefined type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    ///
    /// ## Return Value
    ///
    /// The unique undefined value.
    ///
    ///
    /// Creates a JavaScript value of the undefined type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Returns: The unique undefined value.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSValueMakeUndefined")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_undefined(ctx: JSContextRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeUndefined(ctx: JSContextRef) -> JSValueRef;
        }
        unsafe { JSValueMakeUndefined(ctx) }
    }

    /// Creates a JavaScript value of the null type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    ///
    /// ## Return Value
    ///
    /// The unique null value.
    ///
    ///
    /// Creates a JavaScript value of the null type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Returns: The unique null value.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSValueMakeNull")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_null(ctx: JSContextRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeNull(ctx: JSContextRef) -> JSValueRef;
        }
        unsafe { JSValueMakeNull(ctx) }
    }

    /// Creates a JavaScript Boolean value.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - boolean: The Boolean value to assign to the newly created [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref).
    ///
    ///
    /// ## Return Value
    ///
    /// A [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) of the Boolean type that represents the value of `boolean`.
    ///
    ///
    /// Creates a JavaScript value of the boolean type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `boolean`: The bool to assign to the newly created JSValue.
    ///
    /// Returns: A JSValue of the boolean type, representing the value of boolean.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSValueMakeBoolean")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_boolean(ctx: JSContextRef, boolean: bool) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeBoolean(ctx: JSContextRef, boolean: bool) -> JSValueRef;
        }
        unsafe { JSValueMakeBoolean(ctx, boolean) }
    }

    /// Creates a JavaScript value of the number type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - number: The double to assign to the newly created [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref).
    ///
    ///
    /// ## Return Value
    ///
    /// A [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) of the number type that represents the value of `number`.
    ///
    ///
    /// Creates a JavaScript value of the number type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `number`: The double to assign to the newly created JSValue.
    ///
    /// Returns: A JSValue of the number type, representing the value of number.
    ///
    /// # Safety
    ///
    /// `ctx` must be a valid pointer.
    #[doc(alias = "JSValueMakeNumber")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_number(ctx: JSContextRef, number: c_double) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeNumber(ctx: JSContextRef, number: c_double) -> JSValueRef;
        }
        unsafe { JSValueMakeNumber(ctx, number) }
    }

    /// Creates a JavaScript value of the string type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - string: The [`JSStringRef`](https://developer.apple.com/documentation/javascriptcore/jsstringref) to assign to the newly created [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref). The newly created [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) retains `string`, and releases it upon garbage collection.
    ///
    ///
    /// ## Return Value
    ///
    /// A [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) of the string type that represents the value of `string`.
    ///
    ///
    /// Creates a JavaScript value of the string type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `string`: The JSString to assign to the newly created JSValue. The
    /// newly created JSValue retains string, and releases it upon garbage collection.
    ///
    /// Returns: A JSValue of the string type, representing the value of string.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `string` must be a valid pointer.
    #[doc(alias = "JSValueMakeString")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_string(ctx: JSContextRef, string: JSStringRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
        }
        unsafe { JSValueMakeString(ctx, string) }
    }

    /// Creates a JavaScript value of the symbol type.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - description: A description of the newly created symbol value.
    ///
    ///
    /// ## Return Value
    ///
    /// A unique [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) of the symbol type with a description that matches `description`.
    ///
    ///
    /// Creates a JavaScript value of the symbol type.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `description`: A description of the newly created symbol value.
    ///
    /// Returns: A unique JSValue of the symbol type, whose description matches the one provided.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `description` must be a valid pointer.
    #[doc(alias = "JSValueMakeSymbol")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn new_symbol(ctx: JSContextRef, description: JSStringRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeSymbol(ctx: JSContextRef, description: JSStringRef) -> JSValueRef;
        }
        unsafe { JSValueMakeSymbol(ctx, description) }
    }
}

extern "C-unwind" {
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The value to copy into the new BigInt JSValue.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A BigInt JSValue of the value, or NULL if an exception is thrown.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Creates a JavaScript BigInt with a double.
    ///
    /// If the value is not an integer, an exception is thrown.
    ///
    ///
    /// Creates a JavaScript BigInt with a double.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The value to copy into the new BigInt JSValue.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the value, or NULL if an exception is thrown.
    ///
    /// If the value is not an integer, an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithDouble(
        ctx: JSContextRef,
        value: c_double,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - integer: The 64-bit signed integer to copy into the new BigInt JSValue.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A BigInt JSValue of the integer, or NULL if an exception is thrown.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Creates a JavaScript BigInt with a 64-bit signed integer.
    ///
    ///
    /// Creates a JavaScript BigInt with a 64-bit signed integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `integer`: The 64-bit signed integer to copy into the new BigInt JSValue.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the integer, or NULL if an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithInt64(
        ctx: JSContextRef,
        integer: i64,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - integer: The 64-bit unsigned integer to copy into the new BigInt JSValue.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A BigInt JSValue of the integer, or NULL if an exception is thrown.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Creates a JavaScript BigInt with a 64-bit unsigned integer.
    ///
    ///
    /// Creates a JavaScript BigInt with a 64-bit unsigned integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `integer`: The 64-bit unsigned integer to copy into the new BigInt JSValue.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the integer, or NULL if an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithUInt64(
        ctx: JSContextRef,
        integer: u64,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

extern "C-unwind" {
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - string: The JSStringRef representation of an integer.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A BigInt JSValue of the string, or NULL if an exception is thrown.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Creates a JavaScript BigInt with an integer represented in string.
    ///
    /// This is equivalent to calling the `BigInt` constructor from JavaScript with a string argument.
    ///
    ///
    /// Creates a JavaScript BigInt with an integer represented in string.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `string`: The JSStringRef representation of an integer.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A BigInt JSValue of the string, or NULL if an exception is thrown.
    ///
    /// This is equivalent to calling the `BigInt` constructor from JavaScript with a string argument.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `string` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[cfg(feature = "JSBase")]
    pub fn JSBigIntCreateWithString(
        ctx: JSContextRef,
        string: JSStringRef,
        exception: *mut JSValueRef,
    ) -> JSValueRef;
}

#[cfg(all(feature = "JSValue", feature = "objc2"))]
impl JSValue {
    /// Creates a JavaScript value from a JSON-formatted string.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - string: The [`JSStringRef`](https://developer.apple.com/documentation/javascriptcore/jsstringref) that contains the JSON string to parse.
    ///
    ///
    /// ## Return Value
    ///
    /// A [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) that contains the parsed value, or `NULL` if the input is invalid.
    ///
    ///
    /// Creates a JavaScript value from a JSON formatted string.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `string`: The JSString containing the JSON string to be parsed.
    ///
    /// Returns: A JSValue containing the parsed value, or NULL if the input is invalid.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `string` must be a valid pointer.
    #[doc(alias = "JSValueMakeFromJSONString")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn from_json_string(ctx: JSContextRef, string: JSStringRef) -> JSValueRef {
        extern "C-unwind" {
            fn JSValueMakeFromJSONString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
        }
        unsafe { JSValueMakeFromJSONString(ctx, string) }
    }

    /// Creates a JavaScript string that contains the JSON-serialized representation of a JavaScript value.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The value to serialize.
    ///
    /// - indent: The number of spaces to indent when nesting. If `0`, the resulting JSON string doesn’t contain new lines. The size of the indent clamps to 10 spaces.
    ///
    /// - exception: A pointer to a [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to store an exception in, if any. Pass `NULL` to discard any exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A [`JSStringRef`](https://developer.apple.com/documentation/javascriptcore/jsstringref) with the result of serialization, or `NULL` if the system throws an exception.
    ///
    ///
    /// Creates a JavaScript string containing the JSON serialized representation of a JS value.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The value to serialize.
    ///
    /// Parameter `indent`: The number of spaces to indent when nesting.  If 0, the resulting JSON will not contains newlines.  The size of the indent is clamped to 10 spaces.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A JSString with the result of serialization, or NULL if an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueCreateJSONString")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn create_json_string(
        ctx: JSContextRef,
        value: JSValueRef,
        indent: c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef {
        extern "C-unwind" {
            fn JSValueCreateJSONString(
                ctx: JSContextRef,
                value: JSValueRef,
                indent: c_uint,
                exception: *mut JSValueRef,
            ) -> JSStringRef;
        }
        unsafe { JSValueCreateJSONString(ctx, value, indent, exception) }
    }

    /// Converts a JavaScript value to a Boolean and returns the resulting Boolean.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to convert.
    ///
    ///
    /// ## Return Value
    ///
    /// The Boolean result of conversion.
    ///
    ///
    /// Converts a JavaScript value to boolean and returns the resulting boolean.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Returns: The boolean result of conversion.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueToBoolean")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_boolean(ctx: JSContextRef, value: JSValueRef) -> bool {
        extern "C-unwind" {
            fn JSValueToBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
        }
        unsafe { JSValueToBoolean(ctx, value) }
    }

    /// Converts a JavaScript value to a number and returns the resulting number.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to convert.
    ///
    /// - exception: A pointer to a [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to store an exception in, if any. Pass `NULL` to discard any exception.
    ///
    ///
    /// ## Return Value
    ///
    /// The numeric result of conversion, or `NaN` if the system throws an exception.
    ///
    ///
    /// Converts a JavaScript value to number and returns the resulting number.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: The numeric result of conversion, or NaN if an exception is thrown.
    ///
    /// The result is equivalent to `Number(value)` in JavaScript.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueToNumber")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_number(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> c_double {
        extern "C-unwind" {
            fn JSValueToNumber(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> c_double;
        }
        unsafe { JSValueToNumber(ctx, value, exception) }
    }

    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The JSValue to convert.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// An int32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Converts a JSValue to a singed 32-bit integer and returns the resulting integer.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int32_t.
    ///
    ///
    /// Converts a JSValue to a singed 32-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: An int32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int32_t.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueToInt32")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_int32(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> i32 {
        extern "C-unwind" {
            fn JSValueToInt32(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> i32;
        }
        unsafe { JSValueToInt32(ctx, value, exception) }
    }

    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The JSValue to convert.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A uint32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Converts a JSValue to an unsigned 32-bit integer and returns the resulting integer.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint32_t.
    ///
    ///
    /// Converts a JSValue to an unsigned 32-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A uint32_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint32_t.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueToUInt32")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_u_int32(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> u32 {
        extern "C-unwind" {
            fn JSValueToUInt32(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> u32;
        }
        unsafe { JSValueToUInt32(ctx, value, exception) }
    }

    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The JSValue to convert.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// An int64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Converts a JSValue to a singed 64-bit integer and returns the resulting integer.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int64_t.
    ///
    ///
    /// Converts a JSValue to a singed 64-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: An int64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to an int64_t.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueToInt64")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_int64(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> i64 {
        extern "C-unwind" {
            fn JSValueToInt64(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> i64;
        }
        unsafe { JSValueToInt64(ctx, value, exception) }
    }

    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The JSValue to convert.
    ///
    /// - exception: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A uint64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    ///
    ///
    /// ## Discussion
    ///
    /// Converts a JSValue to an unsigned 64-bit integer and returns the resulting integer.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint64_t.
    ///
    ///
    /// Converts a JSValue to an unsigned 64-bit integer and returns the resulting integer.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A uint64_t with the result of conversion, or 0 if an exception is thrown. Since 0 is valid value, `exception` must be checked after the call.
    ///
    /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the JSValue is truncated to a uint64_t.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer or null.
    #[doc(alias = "JSValueToUInt64")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_u_int64(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> u64 {
        extern "C-unwind" {
            fn JSValueToUInt64(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> u64;
        }
        unsafe { JSValueToUInt64(ctx, value, exception) }
    }

    /// Converts a JavaScript value to a string and copies the result into a JavaScript string.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to convert.
    ///
    /// - exception: A pointer to a [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to store an exception in, if any. Pass `NULL` to discard any exception.
    ///
    ///
    /// ## Return Value
    ///
    /// A [`JSStringRef`](https://developer.apple.com/documentation/javascriptcore/jsstringref) with the result of conversion, or `NULL` if the system throws an exception. Ownership follows [The Create Rule](https://developer.apple.com/library/archive/documentation/CoreFoundation/Conceptual/CFMemoryMgmt/Concepts/Ownership.html#//apple_ref/doc/uid/20001148-103029).
    ///
    ///
    /// Converts a JavaScript value to string and copies the result into a JavaScript string.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: A JSString with the result of conversion, or NULL if an exception is thrown. Ownership follows the Create Rule.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueToStringCopy")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_string_copy(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef {
        extern "C-unwind" {
            fn JSValueToStringCopy(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> JSStringRef;
        }
        unsafe { JSValueToStringCopy(ctx, value, exception) }
    }

    /// Converts a JavaScript value to an object and returns the resulting object.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to convert.
    ///
    /// - exception: A pointer to a [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to store an exception in, if any. Pass `NULL` to discard any exception.
    ///
    ///
    /// ## Return Value
    ///
    /// The [`JSObjectRef`](https://developer.apple.com/documentation/javascriptcore/jsobjectref) result of conversion, or `NULL` if the system throws an exception.
    ///
    ///
    /// Converts a JavaScript value to object and returns the resulting object.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to convert.
    ///
    /// Parameter `exception`: A pointer to a JSValueRef in which to store an exception, if any. To reliable detect exception, initialize this to null before the call. Pass NULL if you do not care to store an exception.
    ///
    /// Returns: The JSObject result of conversion, or NULL if an exception is thrown.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    /// - `exception` must be a valid pointer.
    #[doc(alias = "JSValueToObject")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn to_object(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef {
        extern "C-unwind" {
            fn JSValueToObject(
                ctx: JSContextRef,
                value: JSValueRef,
                exception: *mut JSValueRef,
            ) -> JSObjectRef;
        }
        unsafe { JSValueToObject(ctx, value, exception) }
    }

    /// Protects a JavaScript value from garbage collection.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to protect.
    ///
    ///
    /// ## Discussion
    ///
    /// Use this method when you want to store a [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) in a global or on the heap, where the garbage collector can’t discover your reference to it.
    ///
    /// You can protect a value multiple times and must unprotect it an equal number of times before it becomes eligible for garbage collection.
    ///
    ///
    /// Protects a JavaScript value from garbage collection.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to protect.
    ///
    /// Use this method when you want to store a JSValue in a global or on the heap, where the garbage collector will not be able to discover your reference to it.
    ///
    /// A value may be protected multiple times and must be unprotected an equal number of times before becoming eligible for garbage collection.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueProtect")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn protect(ctx: JSContextRef, value: JSValueRef) {
        extern "C-unwind" {
            fn JSValueProtect(ctx: JSContextRef, value: JSValueRef);
        }
        unsafe { JSValueProtect(ctx, value) }
    }

    /// Unprotects a JavaScript value from garbage collection.
    ///
    /// Parameters:
    /// - ctx: The execution context to use.
    ///
    /// - value: The [`JSValueRef`](https://developer.apple.com/documentation/javascriptcore/jsvalueref) to unprotect.
    ///
    ///
    /// ## Discussion
    ///
    /// You can protect a value multiple times and must unprotect it an equal number of times before it becomes eligible for garbage collection.
    ///
    ///
    /// Unprotects a JavaScript value from garbage collection.
    ///
    /// Parameter `ctx`: The execution context to use.
    ///
    /// Parameter `value`: The JSValue to unprotect.
    ///
    /// A value may be protected multiple times and must be unprotected an
    /// equal number of times before becoming eligible for garbage collection.
    ///
    /// # Safety
    ///
    /// - `ctx` must be a valid pointer.
    /// - `value` must be a valid pointer.
    #[doc(alias = "JSValueUnprotect")]
    #[cfg(feature = "JSBase")]
    #[inline]
    pub unsafe fn unprotect(ctx: JSContextRef, value: JSValueRef) {
        extern "C-unwind" {
            fn JSValueUnprotect(ctx: JSContextRef, value: JSValueRef);
        }
        unsafe { JSValueUnprotect(ctx, value) }
    }
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::type`"]
    pub fn JSValueGetType(ctx: JSContextRef, value: JSValueRef) -> JSType;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_undefined`"]
    pub fn JSValueIsUndefined(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_null`"]
    pub fn JSValueIsNull(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_boolean`"]
    pub fn JSValueIsBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_number`"]
    pub fn JSValueIsNumber(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_string`"]
    pub fn JSValueIsString(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_symbol`"]
    pub fn JSValueIsSymbol(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_big_int`"]
    pub fn JSValueIsBigInt(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_object`"]
    pub fn JSValueIsObject(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_object_of_class`"]
    pub fn JSValueIsObjectOfClass(
        ctx: JSContextRef,
        value: JSValueRef,
        js_class: JSClassRef,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_array`"]
    pub fn JSValueIsArray(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_date`"]
    pub fn JSValueIsDate(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::typed_array_type`"]
    pub fn JSValueGetTypedArrayType(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSTypedArrayType;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_equal`"]
    pub fn JSValueIsEqual(
        ctx: JSContextRef,
        a: JSValueRef,
        b: JSValueRef,
        exception: *mut JSValueRef,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_strict_equal`"]
    pub fn JSValueIsStrictEqual(ctx: JSContextRef, a: JSValueRef, b: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::is_instance_of_constructor`"]
    pub fn JSValueIsInstanceOfConstructor(
        ctx: JSContextRef,
        value: JSValueRef,
        constructor: JSObjectRef,
        exception: *mut JSValueRef,
    ) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::compare`"]
    pub fn JSValueCompare(
        ctx: JSContextRef,
        left: JSValueRef,
        right: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::compare_int64`"]
    pub fn JSValueCompareInt64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: i64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::compare_u_int64`"]
    pub fn JSValueCompareUInt64(
        ctx: JSContextRef,
        left: JSValueRef,
        right: u64,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::compare_double`"]
    pub fn JSValueCompareDouble(
        ctx: JSContextRef,
        left: JSValueRef,
        right: c_double,
        exception: *mut JSValueRef,
    ) -> JSRelationCondition;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_undefined`"]
    pub fn JSValueMakeUndefined(ctx: JSContextRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_null`"]
    pub fn JSValueMakeNull(ctx: JSContextRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_boolean`"]
    pub fn JSValueMakeBoolean(ctx: JSContextRef, boolean: bool) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_number`"]
    pub fn JSValueMakeNumber(ctx: JSContextRef, number: c_double) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_string`"]
    pub fn JSValueMakeString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::new_symbol`"]
    pub fn JSValueMakeSymbol(ctx: JSContextRef, description: JSStringRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::from_json_string`"]
    pub fn JSValueMakeFromJSONString(ctx: JSContextRef, string: JSStringRef) -> JSValueRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::create_json_string`"]
    pub fn JSValueCreateJSONString(
        ctx: JSContextRef,
        value: JSValueRef,
        indent: c_uint,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_boolean`"]
    pub fn JSValueToBoolean(ctx: JSContextRef, value: JSValueRef) -> bool;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_number`"]
    pub fn JSValueToNumber(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> c_double;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_int32`"]
    pub fn JSValueToInt32(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef) -> i32;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_u_int32`"]
    pub fn JSValueToUInt32(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef)
        -> u32;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_int64`"]
    pub fn JSValueToInt64(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef) -> i64;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_u_int64`"]
    pub fn JSValueToUInt64(ctx: JSContextRef, value: JSValueRef, exception: *mut JSValueRef)
        -> u64;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_string_copy`"]
    pub fn JSValueToStringCopy(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSStringRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::to_object`"]
    pub fn JSValueToObject(
        ctx: JSContextRef,
        value: JSValueRef,
        exception: *mut JSValueRef,
    ) -> JSObjectRef;
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::protect`"]
    pub fn JSValueProtect(ctx: JSContextRef, value: JSValueRef);
}

extern "C-unwind" {
    #[cfg(feature = "JSBase")]
    #[deprecated = "renamed to `JSValue::unprotect`"]
    pub fn JSValueUnprotect(ctx: JSContextRef, value: JSValueRef);
}
