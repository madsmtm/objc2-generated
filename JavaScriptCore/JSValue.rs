//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;
#[cfg(feature = "objc2-foundation")]
use objc2_foundation::*;

use crate::*;

#[cfg(feature = "objc2")]
extern_class!(
    /// A JSValue is a reference to a JavaScript value. Every JSValue
    /// originates from a JSContext and holds a strong reference to it.
    /// When a JSValue instance method creates a new JSValue, the new value
    /// originates from the same JSContext.
    ///
    /// All JSValues values also originate from a JSVirtualMachine
    /// (available indirectly via the context property). It is an error to pass a
    /// JSValue to a method or property of a JSValue or JSContext originating from a
    /// different JSVirtualMachine. Doing so will raise an Objective-C exception.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jsvalue?language=objc)
    #[unsafe(super(NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "objc2")]
    pub struct JSValue;
);

#[cfg(feature = "objc2")]
extern_conformance!(
    unsafe impl NSObjectProtocol for JSValue {}
);

#[cfg(feature = "objc2")]
impl JSValue {
    extern_methods!(
        #[cfg(feature = "JSContext")]
        /// The JSContext that this value originates from.
        #[unsafe(method(context))]
        #[unsafe(method_family = none)]
        pub unsafe fn context(&self) -> Option<Retained<JSContext>>;

        #[cfg(feature = "JSContext")]
        /// Create a JSValue by converting an Objective-C object.
        ///
        /// The resulting JSValue retains the provided Objective-C object.
        ///
        /// Parameter `value`: The Objective-C object to be converted.
        ///
        /// Returns: The new JSValue.
        ///
        /// # Safety
        ///
        /// - `value` should be of the correct type.
        /// - `value` might not allow `None`.
        /// - `context` might not allow `None`.
        #[unsafe(method(valueWithObject:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithObject_inContext(
            value: Option<&AnyObject>,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a JavaScript value from a BOOL primitive.
        ///
        /// Parameter `context`: The JSContext in which the resulting JSValue will be created.
        ///
        /// Returns: The new JSValue representing the equivalent boolean value.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithBool:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithBool_inContext(
            value: bool,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a JavaScript value from a double primitive.
        ///
        /// Parameter `context`: The JSContext in which the resulting JSValue will be created.
        ///
        /// Returns: The new JSValue representing the equivalent boolean value.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithDouble:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithDouble_inContext(
            value: c_double,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a JavaScript value from an
        /// <code>
        /// int32_t
        /// </code>
        /// primitive.
        ///
        /// Parameter `context`: The JSContext in which the resulting JSValue will be created.
        ///
        /// Returns: The new JSValue representing the equivalent boolean value.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithInt32:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithInt32_inContext(
            value: i32,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a JavaScript value from a
        /// <code>
        /// uint32_t
        /// </code>
        /// primitive.
        ///
        /// Parameter `context`: The JSContext in which the resulting JSValue will be created.
        ///
        /// Returns: The new JSValue representing the equivalent boolean value.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithUInt32:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithUInt32_inContext(
            value: u32,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a new, empty JavaScript object.
        ///
        /// Parameter `context`: The JSContext in which the resulting object will be created.
        ///
        /// Returns: The new JavaScript object.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithNewObjectInContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewObjectInContext(
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a new, empty JavaScript array.
        ///
        /// Parameter `context`: The JSContext in which the resulting array will be created.
        ///
        /// Returns: The new JavaScript array.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithNewArrayInContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewArrayInContext(
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(all(feature = "JSContext", feature = "objc2-foundation"))]
        /// Create a new JavaScript regular expression object.
        ///
        /// Parameter `pattern`: The regular expression pattern.
        ///
        /// Parameter `flags`: The regular expression flags.
        ///
        /// Parameter `context`: The JSContext in which the resulting regular expression object will be created.
        ///
        /// Returns: The new JavaScript regular expression object.
        ///
        /// # Safety
        ///
        /// - `pattern` might not allow `None`.
        /// - `flags` might not allow `None`.
        /// - `context` might not allow `None`.
        #[unsafe(method(valueWithNewRegularExpressionFromPattern:flags:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewRegularExpressionFromPattern_flags_inContext(
            pattern: Option<&NSString>,
            flags: Option<&NSString>,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(all(feature = "JSContext", feature = "objc2-foundation"))]
        /// Create a new JavaScript error object.
        ///
        /// Parameter `message`: The error message.
        ///
        /// Parameter `context`: The JSContext in which the resulting error object will be created.
        ///
        /// Returns: The new JavaScript error object.
        ///
        /// # Safety
        ///
        /// - `message` might not allow `None`.
        /// - `context` might not allow `None`.
        #[unsafe(method(valueWithNewErrorFromMessage:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewErrorFromMessage_inContext(
            message: Option<&NSString>,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(all(feature = "JSContext", feature = "block2"))]
        /// Create a new promise object using the provided executor callback.
        ///
        /// Parameter `callback`: A callback block invoked while the promise object is being initialized. The resolve and reject parameters are functions that can be called to notify any pending reactions about the state of the new promise object.
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing a new promise JavaScript object.
        ///
        /// This method is equivalent to calling the Promise constructor in JavaScript. the resolve and reject callbacks each normally take a single value, which they forward to all relevent pending reactions. While inside the executor callback context will act as if it were in any other callback, except calleeFunction will be
        /// <code>
        /// nil
        /// </code>
        /// . This also means means the new promise object may be accessed via
        /// <code>
        /// [context thisValue]
        /// </code>
        /// .
        ///
        /// # Safety
        ///
        /// - `context` might not allow `None`.
        /// - `callback` might not allow `None`.
        #[unsafe(method(valueWithNewPromiseInContext:fromExecutor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewPromiseInContext_fromExecutor(
            context: Option<&JSContext>,
            callback: Option<&block2::DynBlock<dyn Fn(*mut JSValue, *mut JSValue)>>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a new resolved promise object with the provided value.
        ///
        /// Parameter `result`: The result value to be passed to any reactions.
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing a new promise JavaScript object.
        ///
        /// This method is equivalent to calling
        /// <code>
        /// [JSValue valueWithNewPromiseFromExecutor:^(JSValue *resolve, JSValue *reject) { [resolve callWithArguments:
        /// @
        /// [result]]; } inContext:context]
        /// </code>
        ///
        /// # Safety
        ///
        /// - `result` should be of the correct type.
        /// - `result` might not allow `None`.
        /// - `context` might not allow `None`.
        #[unsafe(method(valueWithNewPromiseResolvedWithResult:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewPromiseResolvedWithResult_inContext(
            result: Option<&AnyObject>,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a new rejected promise object with the provided value.
        ///
        /// Parameter `reason`: The result value to be passed to any reactions.
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing a new promise JavaScript object.
        ///
        /// This method is equivalent to calling
        /// <code>
        /// [JSValue valueWithNewPromiseFromExecutor:^(JSValue *resolve, JSValue *reject) { [reject callWithArguments:
        /// @
        /// [reason]]; } inContext:context]
        /// </code>
        ///
        /// # Safety
        ///
        /// - `reason` should be of the correct type.
        /// - `reason` might not allow `None`.
        /// - `context` might not allow `None`.
        #[unsafe(method(valueWithNewPromiseRejectedWithReason:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewPromiseRejectedWithReason_inContext(
            reason: Option<&AnyObject>,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(all(feature = "JSContext", feature = "objc2-foundation"))]
        /// Create a new, unique, symbol object.
        ///
        /// Parameter `description`: The description of the symbol object being created.
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing a unique JavaScript value with type symbol.
        ///
        /// # Safety
        ///
        /// - `description` might not allow `None`.
        /// - `context` might not allow `None`.
        #[unsafe(method(valueWithNewSymbolFromDescription:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewSymbolFromDescription_inContext(
            description: Option<&NSString>,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(all(feature = "JSContext", feature = "objc2-foundation"))]
        /// Create a new BigInt value from a numeric string.
        ///
        /// Parameter `string`: The string representation of the BigInt JavaScript value being created.
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing a JavaScript value with type BigInt.
        ///
        /// This is equivalent to calling the
        /// <code>
        /// BigInt
        /// </code>
        /// constructor from JavaScript with a string argument.
        #[unsafe(method(valueWithNewBigIntFromString:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewBigIntFromString_inContext(
            string: &NSString,
            context: &JSContext,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a new BigInt value from a
        /// <code>
        /// int64_t
        /// </code>
        /// .
        ///
        /// Parameter `int64`: The signed 64-bit integer of the BigInt JavaScript value being created.
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing a JavaScript value with type BigInt.
        #[unsafe(method(valueWithNewBigIntFromInt64:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewBigIntFromInt64_inContext(
            int64: i64,
            context: &JSContext,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a new BigInt value from a
        /// <code>
        /// uint64_t
        /// </code>
        /// .
        ///
        /// Parameter `uint64`: The unsigned 64-bit integer of the BigInt JavaScript value being created.
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing a JavaScript value with type BigInt.
        #[unsafe(method(valueWithNewBigIntFromUInt64:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewBigIntFromUInt64_inContext(
            uint64: u64,
            context: &JSContext,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create a new BigInt value from a double.
        ///
        /// Parameter `value`: The value of the BigInt JavaScript value being created.
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing a JavaScript value with type BigInt.
        ///
        /// If the value is not an integer, an exception is thrown.
        #[unsafe(method(valueWithNewBigIntFromDouble:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNewBigIntFromDouble_inContext(
            value: c_double,
            context: &JSContext,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create the JavaScript value
        /// <code>
        /// null
        /// </code>
        /// .
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing the JavaScript value
        /// <code>
        /// null
        /// </code>
        /// .
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithNullInContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithNullInContext(
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSContext")]
        /// Create the JavaScript value
        /// <code>
        /// undefined
        /// </code>
        /// .
        ///
        /// Parameter `context`: The JSContext to which the resulting JSValue belongs.
        ///
        /// Returns: The JSValue representing the JavaScript value
        /// <code>
        /// undefined
        /// </code>
        /// .
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithUndefinedInContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithUndefinedInContext(
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        /// When converting between JavaScript values and Objective-C objects a copy is
        /// performed. Values of types listed below are copied to the corresponding
        /// types on conversion in each direction. For NSDictionaries, entries in the
        /// dictionary that are keyed by strings are copied onto a JavaScript object.
        /// For dictionaries and arrays, conversion is recursive, with the same object
        /// conversion being applied to all entries in the collection.
        ///
        /// <pre>
        ///
        /// ```text
        ///    Objective-C type  |   JavaScript type
        ///  --------------------+---------------------
        ///          nil         |     undefined
        ///         NSNull       |        null
        ///        NSString      |       string
        ///        NSNumber      |   number, boolean
        ///      NSDictionary    |   Object object
        ///        NSArray       |    Array object
        ///         NSDate       |     Date object
        ///        NSBlock (1)   |   Function object (1)
        ///           id (2)     |   Wrapper object (2)
        ///         Class (3)    | Constructor object (3)
        /// ```
        ///
        /// </pre>
        ///
        /// (1) Instances of NSBlock with supported arguments types will be presented to
        /// JavaScript as a callable Function object. For more information on supported
        /// argument types see JSExport.h. If a JavaScript Function originating from an
        /// Objective-C block is converted back to an Objective-C object the block will
        /// be returned. All other JavaScript functions will be converted in the same
        /// manner as a JavaScript object of type Object.
        ///
        /// (2) For Objective-C instances that do not derive from the set of types listed
        /// above, a wrapper object to provide a retaining handle to the Objective-C
        /// instance from JavaScript. For more information on these wrapper objects, see
        /// JSExport.h. When a JavaScript wrapper object is converted back to Objective-C
        /// the Objective-C instance being retained by the wrapper is returned.
        ///
        /// (3) For Objective-C Class objects a constructor object containing exported
        /// class methods will be returned. See JSExport.h for more information on
        /// constructor objects.
        ///
        /// For all methods taking arguments of type id, arguments will be converted
        /// into a JavaScript value according to the above conversion.
        ///
        /// Convert this JSValue to an Objective-C object.
        ///
        /// The JSValue is converted to an Objective-C object according
        /// to the conversion rules specified above.
        ///
        /// Returns: The Objective-C representation of this JSValue.
        #[unsafe(method(toObject))]
        #[unsafe(method_family = none)]
        pub unsafe fn toObject(&self) -> Option<Retained<AnyObject>>;

        /// Convert a JSValue to an Objective-C object of a specific class.
        ///
        /// The JSValue is converted to an Objective-C object of the specified Class.
        /// If the result is not of the specified Class then
        /// <code>
        /// nil
        /// </code>
        /// will be returned.
        ///
        /// Returns: An Objective-C object of the specified Class or
        /// <code>
        /// nil
        /// </code>
        /// .
        ///
        /// # Safety
        ///
        /// - `expected_class` probably has further requirements.
        /// - `expected_class` might not allow `None`.
        #[unsafe(method(toObjectOfClass:))]
        #[unsafe(method_family = none)]
        pub unsafe fn toObjectOfClass(
            &self,
            expected_class: Option<&AnyClass>,
        ) -> Option<Retained<AnyObject>>;

        /// Convert a JSValue to a boolean.
        ///
        /// The JSValue is converted to a boolean according to the rules specified
        /// by the JavaScript language.
        ///
        /// Returns: The boolean result of the conversion.
        #[unsafe(method(toBool))]
        #[unsafe(method_family = none)]
        pub unsafe fn toBool(&self) -> bool;

        /// Convert a JSValue to a double.
        ///
        /// Returns: The double result of the conversion.
        ///
        /// Convert the JSValue to a number according to the rules specified by the JavaScript language. Unless the JSValue is a BigInt then this is equivalent to
        /// <code>
        /// Number(value)
        /// </code>
        /// in JavaScript.
        #[unsafe(method(toDouble))]
        #[unsafe(method_family = none)]
        pub unsafe fn toDouble(&self) -> c_double;

        /// Convert a JSValue to an
        /// <code>
        /// int32_t
        /// </code>
        /// .
        ///
        /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the JSValue is a BigInt, then the value is truncated to an
        /// <code>
        /// int32_t
        /// </code>
        /// .
        ///
        /// Returns: The
        /// <code>
        /// int32_t
        /// </code>
        /// result of the conversion.
        #[unsafe(method(toInt32))]
        #[unsafe(method_family = none)]
        pub unsafe fn toInt32(&self) -> i32;

        /// Convert a JSValue to a
        /// <code>
        /// uint32_t
        /// </code>
        /// .
        ///
        /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the JSValue is a BigInt, then the value is truncated to a
        /// <code>
        /// uint32_t
        /// </code>
        /// .
        ///
        /// Returns: The
        /// <code>
        /// uint32_t
        /// </code>
        /// result of the conversion.
        #[unsafe(method(toUInt32))]
        #[unsafe(method_family = none)]
        pub unsafe fn toUInt32(&self) -> u32;

        /// Convert a JSValue to a
        /// <code>
        /// int64_t
        /// </code>
        /// .
        ///
        /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the value is truncated to an
        /// <code>
        /// int64_t
        /// </code>
        /// .
        #[unsafe(method(toInt64))]
        #[unsafe(method_family = none)]
        pub unsafe fn toInt64(&self) -> i64;

        /// Convert a JSValue to a
        /// <code>
        /// uint64_t
        /// </code>
        /// .
        ///
        /// The JSValue is converted to an integer according to the rules specified by the JavaScript language. If the value is a BigInt, then the value is truncated to a
        /// <code>
        /// uint64_t
        /// </code>
        /// .
        #[unsafe(method(toUInt64))]
        #[unsafe(method_family = none)]
        pub unsafe fn toUInt64(&self) -> u64;

        #[cfg(feature = "objc2-foundation")]
        /// Convert a JSValue to a NSNumber.
        ///
        /// If the JSValue represents a boolean, a NSNumber value of YES or NO
        /// will be returned. For all other types, the result is equivalent to
        /// <code>
        /// Number(value)
        /// </code>
        /// in JavaScript.
        ///
        /// Returns: The NSNumber result of the conversion.
        #[unsafe(method(toNumber))]
        #[unsafe(method_family = none)]
        pub unsafe fn toNumber(&self) -> Option<Retained<NSNumber>>;

        #[cfg(feature = "objc2-foundation")]
        /// Convert a JSValue to a NSString.
        ///
        /// The JSValue is converted to a string according to the rules specified
        /// by the JavaScript language.
        ///
        /// Returns: The NSString containing the result of the conversion.
        #[unsafe(method(toString))]
        #[unsafe(method_family = none)]
        pub unsafe fn toString(&self) -> Option<Retained<NSString>>;

        #[cfg(feature = "objc2-foundation")]
        /// Convert a JSValue to a NSDate.
        ///
        /// The value is converted to a number representing a time interval
        /// since 1970 which is then used to create a new NSDate instance.
        ///
        /// Returns: The NSDate created using the converted time interval.
        #[unsafe(method(toDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn toDate(&self) -> Option<Retained<NSDate>>;

        #[cfg(feature = "objc2-foundation")]
        /// Convert a JSValue to a NSArray.
        ///
        /// If the value is
        /// <code>
        /// null
        /// </code>
        /// or
        /// <code>
        /// undefined
        /// </code>
        /// then
        /// <code>
        /// nil
        /// </code>
        /// is returned.
        /// If the value is not an object then a JavaScript TypeError will be thrown.
        /// The property
        /// <code>
        /// length
        /// </code>
        /// is read from the object, converted to an unsigned
        /// integer, and an NSArray of this size is allocated. Properties corresponding
        /// to indices within the array bounds will be copied to the array, with
        /// JSValues converted to equivalent Objective-C objects as specified.
        ///
        /// Returns: The NSArray containing the recursively converted contents of the
        /// converted JavaScript array.
        #[unsafe(method(toArray))]
        #[unsafe(method_family = none)]
        pub unsafe fn toArray(&self) -> Option<Retained<NSArray>>;

        #[cfg(feature = "objc2-foundation")]
        /// Convert a JSValue to a NSDictionary.
        ///
        /// If the value is
        /// <code>
        /// null
        /// </code>
        /// or
        /// <code>
        /// undefined
        /// </code>
        /// then
        /// <code>
        /// nil
        /// </code>
        /// is returned.
        /// If the value is not an object then a JavaScript TypeError will be thrown.
        /// All enumerable properties of the object are copied to the dictionary, with
        /// JSValues converted to equivalent Objective-C objects as specified.
        ///
        /// Returns: The NSDictionary containing the recursively converted contents of
        /// the converted JavaScript object.
        #[unsafe(method(toDictionary))]
        #[unsafe(method_family = none)]
        pub unsafe fn toDictionary(&self) -> Option<Retained<NSDictionary>>;

        /// Check if a JSValue corresponds to the JavaScript value
        /// <code>
        /// undefined
        /// </code>
        /// .
        #[unsafe(method(isUndefined))]
        #[unsafe(method_family = none)]
        pub unsafe fn isUndefined(&self) -> bool;

        /// Check if a JSValue corresponds to the JavaScript value
        /// <code>
        /// null
        /// </code>
        /// .
        #[unsafe(method(isNull))]
        #[unsafe(method_family = none)]
        pub unsafe fn isNull(&self) -> bool;

        /// Check if a JSValue is a boolean.
        #[unsafe(method(isBoolean))]
        #[unsafe(method_family = none)]
        pub unsafe fn isBoolean(&self) -> bool;

        /// Check if a JSValue is a number.
        ///
        /// In JavaScript, there is no differentiation between types of numbers.
        /// Semantically all numbers behave like doubles except in special cases like bit
        /// operations.
        #[unsafe(method(isNumber))]
        #[unsafe(method_family = none)]
        pub unsafe fn isNumber(&self) -> bool;

        /// Check if a JSValue is a string.
        #[unsafe(method(isString))]
        #[unsafe(method_family = none)]
        pub unsafe fn isString(&self) -> bool;

        /// Check if a JSValue is an object.
        #[unsafe(method(isObject))]
        #[unsafe(method_family = none)]
        pub unsafe fn isObject(&self) -> bool;

        /// Check if a JSValue is an array.
        #[unsafe(method(isArray))]
        #[unsafe(method_family = none)]
        pub unsafe fn isArray(&self) -> bool;

        /// Check if a JSValue is a date.
        #[unsafe(method(isDate))]
        #[unsafe(method_family = none)]
        pub unsafe fn isDate(&self) -> bool;

        /// Check if a JSValue is a symbol.
        #[unsafe(method(isSymbol))]
        #[unsafe(method_family = none)]
        pub unsafe fn isSymbol(&self) -> bool;

        /// Check if a JSValue is a BigInt.
        #[unsafe(method(isBigInt))]
        #[unsafe(method_family = none)]
        pub unsafe fn isBigInt(&self) -> bool;

        /// Check if a JSValue is an instance of another object.
        ///
        /// This method has the same function as the JavaScript operator
        /// <code>
        /// instanceof
        /// </code>
        /// .
        /// If an object other than a JSValue is passed, it will first be converted according to
        /// the aforementioned rules.
        ///
        /// # Safety
        ///
        /// - `value` should be of the correct type.
        /// - `value` might not allow `None`.
        #[unsafe(method(isInstanceOf:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isInstanceOf(&self, value: Option<&AnyObject>) -> bool;

        /// Compare two JSValues using JavaScript's
        /// <code>
        /// ===
        /// </code>
        /// operator.
        ///
        /// # Safety
        ///
        /// - `value` should be of the correct type.
        /// - `value` might not allow `None`.
        #[unsafe(method(isEqualToObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEqualToObject(&self, value: Option<&AnyObject>) -> bool;

        /// Compare two JSValues using JavaScript's
        /// <code>
        /// ==
        /// </code>
        /// operator.
        ///
        /// # Safety
        ///
        /// - `value` should be of the correct type.
        /// - `value` might not allow `None`.
        #[unsafe(method(isEqualWithTypeCoercionToObject:))]
        #[unsafe(method_family = none)]
        pub unsafe fn isEqualWithTypeCoercionToObject(&self, value: Option<&AnyObject>) -> bool;

        #[cfg(feature = "JSValueRef")]
        /// Compare two JSValues.
        /// The JSValue to compare with.
        ///
        /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
        ///
        /// The result is computed by comparing the results of JavaScript's
        /// <code>
        /// ==
        /// </code>
        /// ,
        /// <code>
        /// <
        /// </code>
        /// , and
        /// <code>
        /// >
        /// </code>
        /// operators. If either
        /// <code>
        /// self
        /// </code>
        /// or
        /// <code>
        /// other
        /// </code>
        /// is (or would coerce to)
        /// <code>
        /// NaN
        /// </code>
        /// in JavaScript, then the result is kJSRelationConditionUndefined.
        #[unsafe(method(compareJSValue:))]
        #[unsafe(method_family = none)]
        pub unsafe fn compareJSValue(&self, other: &JSValue) -> JSRelationCondition;

        #[cfg(feature = "JSValueRef")]
        /// Compare a JSValue with a
        /// <code>
        /// int64_t
        /// </code>
        /// .
        /// The
        /// <code>
        /// int64_t
        /// </code>
        /// to compare with.
        ///
        /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
        ///
        /// The JSValue is converted to an integer according to the rules specified by the JavaScript language then compared with
        /// <code>
        /// other
        /// </code>
        /// .
        #[unsafe(method(compareInt64:))]
        #[unsafe(method_family = none)]
        pub unsafe fn compareInt64(&self, other: i64) -> JSRelationCondition;

        #[cfg(feature = "JSValueRef")]
        /// Compare a JSValue with a
        /// <code>
        /// uint64_t
        /// </code>
        /// .
        /// The
        /// <code>
        /// uint64_t
        /// </code>
        /// to compare with.
        ///
        /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
        ///
        /// The JSValue is converted to an integer according to the rules specified by the JavaScript language then compared with
        /// <code>
        /// other
        /// </code>
        /// .
        #[unsafe(method(compareUInt64:))]
        #[unsafe(method_family = none)]
        pub unsafe fn compareUInt64(&self, other: u64) -> JSRelationCondition;

        #[cfg(feature = "JSValueRef")]
        /// Compare a JSValue with a double.
        /// The double to compare with.
        ///
        /// Returns: A value of JSRelationCondition, a kJSRelationConditionUndefined is returned if an exception is thrown.
        ///
        /// The JSValue is converted to a double according to the rules specified by the JavaScript language then compared with
        /// <code>
        /// other
        /// </code>
        /// .
        #[unsafe(method(compareDouble:))]
        #[unsafe(method_family = none)]
        pub unsafe fn compareDouble(&self, other: c_double) -> JSRelationCondition;

        #[cfg(feature = "objc2-foundation")]
        /// Invoke a JSValue as a function.
        ///
        /// In JavaScript, if a function doesn't explicitly return a value then it
        /// implicitly returns the JavaScript value
        /// <code>
        /// undefined
        /// </code>
        /// .
        ///
        /// Parameter `arguments`: The arguments to pass to the function.
        ///
        /// Returns: The return value of the function call.
        ///
        /// # Safety
        ///
        /// - `arguments` generic should be of the correct type.
        /// - `arguments` might not allow `None`.
        #[unsafe(method(callWithArguments:))]
        #[unsafe(method_family = none)]
        pub unsafe fn callWithArguments(
            &self,
            arguments: Option<&NSArray>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "objc2-foundation")]
        /// Invoke a JSValue as a constructor.
        ///
        /// This is equivalent to using the
        /// <code>
        /// new
        /// </code>
        /// syntax in JavaScript.
        ///
        /// Parameter `arguments`: The arguments to pass to the constructor.
        ///
        /// Returns: The return value of the constructor call.
        ///
        /// # Safety
        ///
        /// - `arguments` generic should be of the correct type.
        /// - `arguments` might not allow `None`.
        #[unsafe(method(constructWithArguments:))]
        #[unsafe(method_family = none)]
        pub unsafe fn constructWithArguments(
            &self,
            arguments: Option<&NSArray>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "objc2-foundation")]
        /// Invoke a method on a JSValue.
        ///
        /// Accesses the property named
        /// <code>
        /// method
        /// </code>
        /// from this value and
        /// calls the resulting value as a function, passing this JSValue as the
        /// <code>
        /// this
        /// </code>
        /// value along with the specified arguments.
        ///
        /// Parameter `method`: The name of the method to be invoked.
        ///
        /// Parameter `arguments`: The arguments to pass to the method.
        ///
        /// Returns: The return value of the method call.
        ///
        /// # Safety
        ///
        /// - `method` might not allow `None`.
        /// - `arguments` generic should be of the correct type.
        /// - `arguments` might not allow `None`.
        #[unsafe(method(invokeMethod:withArguments:))]
        #[unsafe(method_family = none)]
        pub unsafe fn invokeMethod_withArguments(
            &self,
            method: Option<&NSString>,
            arguments: Option<&NSArray>,
        ) -> Option<Retained<JSValue>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "objc2")]
impl JSValue {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}

/// StructSupport.
///
/// Objective-C methods exported to JavaScript may have argument and/or return
/// values of struct types, provided that conversion to and from the struct is
/// supported by JSValue. Support is provided for any types where JSValue
/// contains both a class method
/// <code>
/// valueWith
/// <Type
/// >:inContext:
/// </code>
/// , and and instance
/// method
/// <code>
/// to
/// <Type
/// >
/// </code>
/// - where the string
/// <code>
/// <Type
/// >
/// </code>
/// in these selector names match,
/// with the first argument to the former being of the same struct type as the
/// return type of the latter.
/// Support is provided for structs of type CGPoint, NSRange, CGRect and CGSize.
#[cfg(feature = "objc2")]
impl JSValue {
    extern_methods!(
        #[cfg(all(feature = "JSContext", feature = "objc2-core-foundation"))]
        /// Create a JSValue from a CGPoint.
        ///
        /// Returns: A newly allocated JavaScript object containing properties
        /// named
        /// <code>
        /// x
        /// </code>
        /// and
        /// <code>
        /// y
        /// </code>
        /// , with values from the CGPoint.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithPoint:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithPoint_inContext(
            point: CGPoint,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(all(feature = "JSContext", feature = "objc2-foundation"))]
        /// Create a JSValue from a NSRange.
        ///
        /// Returns: A newly allocated JavaScript object containing properties
        /// named
        /// <code>
        /// location
        /// </code>
        /// and
        /// <code>
        /// length
        /// </code>
        /// , with values from the NSRange.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithRange:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithRange_inContext(
            range: NSRange,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(all(feature = "JSContext", feature = "objc2-core-foundation"))]
        /// Create a JSValue from a CGRect.
        ///
        /// Returns: A newly allocated JavaScript object containing properties
        /// named
        /// <code>
        /// x
        /// </code>
        /// ,
        /// <code>
        /// y
        /// </code>
        /// ,
        /// <code>
        /// width
        /// </code>
        /// , and
        /// <code>
        /// height
        /// </code>
        /// , with values from the CGRect.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithRect:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithRect_inContext(
            rect: CGRect,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(all(feature = "JSContext", feature = "objc2-core-foundation"))]
        /// Create a JSValue from a CGSize.
        ///
        /// Returns: A newly allocated JavaScript object containing properties
        /// named
        /// <code>
        /// width
        /// </code>
        /// and
        /// <code>
        /// height
        /// </code>
        /// , with values from the CGSize.
        ///
        /// # Safety
        ///
        /// `context` might not allow `None`.
        #[unsafe(method(valueWithSize:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithSize_inContext(
            size: CGSize,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "objc2-core-foundation")]
        /// Convert a JSValue to a CGPoint.
        ///
        /// Reads the properties named
        /// <code>
        /// x
        /// </code>
        /// and
        /// <code>
        /// y
        /// </code>
        /// from
        /// this JSValue, and converts the results to double.
        ///
        /// Returns: The new CGPoint.
        #[unsafe(method(toPoint))]
        #[unsafe(method_family = none)]
        pub unsafe fn toPoint(&self) -> CGPoint;

        #[cfg(feature = "objc2-foundation")]
        /// Convert a JSValue to an NSRange.
        ///
        /// Reads the properties named
        /// <code>
        /// location
        /// </code>
        /// and
        /// <code>
        /// length
        /// </code>
        /// from this JSValue and converts the results to double.
        ///
        /// Returns: The new NSRange.
        #[unsafe(method(toRange))]
        #[unsafe(method_family = none)]
        pub unsafe fn toRange(&self) -> NSRange;

        #[cfg(feature = "objc2-core-foundation")]
        /// Convert a JSValue to a CGRect.
        ///
        /// Reads the properties named
        /// <code>
        /// x
        /// </code>
        /// ,
        /// <code>
        /// y
        /// </code>
        /// ,
        /// <code>
        /// width
        /// </code>
        /// , and
        /// <code>
        /// height
        /// </code>
        /// from this JSValue and converts the results to double.
        ///
        /// Returns: The new CGRect.
        #[unsafe(method(toRect))]
        #[unsafe(method_family = none)]
        pub unsafe fn toRect(&self) -> CGRect;

        #[cfg(feature = "objc2-core-foundation")]
        /// Convert a JSValue to a CGSize.
        ///
        /// Reads the properties named
        /// <code>
        /// width
        /// </code>
        /// and
        /// <code>
        /// height
        /// </code>
        /// from this JSValue and converts the results to double.
        ///
        /// Returns: The new CGSize.
        #[unsafe(method(toSize))]
        #[unsafe(method_family = none)]
        pub unsafe fn toSize(&self) -> CGSize;
    );
}

/// [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jsvalueproperty?language=objc)
#[cfg(feature = "objc2-foundation")]
pub type JSValueProperty = NSString;

/// PropertyAccess.
///
/// These methods enable querying properties on a JSValue.
#[cfg(feature = "objc2")]
impl JSValue {
    extern_methods!(
        #[cfg(feature = "objc2-foundation")]
        /// Access a property of a JSValue.
        ///
        /// Returns: The JSValue for the requested property or the JSValue
        /// <code>
        /// undefined
        /// </code>
        /// if the property does not exist.
        ///
        /// Corresponds to the JavaScript operation
        /// <code>
        /// object[property]
        /// </code>
        /// . Starting with macOS 10.15 and iOS 13, 'property' can be any 'id' and will be converted to a JSValue using the conversion rules of
        /// <code>
        /// valueWithObject:inContext:
        /// </code>
        /// . Prior to macOS 10.15 and iOS 13, 'property' was expected to be an NSString *.
        ///
        /// # Safety
        ///
        /// `property` might not allow `None`.
        #[unsafe(method(valueForProperty:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueForProperty(
            &self,
            property: Option<&JSValueProperty>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "objc2-foundation")]
        /// Set a property on a JSValue.
        ///
        /// Corresponds to the JavaScript operation
        /// <code>
        /// object[property] = value
        /// </code>
        /// . Starting with macOS 10.15 and iOS 13, 'property' can be any 'id' and will be converted to a JSValue using the conversion rules of
        /// <code>
        /// valueWithObject:inContext:
        /// </code>
        /// . Prior to macOS 10.15 and iOS 13, 'property' was expected to be an NSString *.
        ///
        /// # Safety
        ///
        /// - `value` should be of the correct type.
        /// - `value` might not allow `None`.
        /// - `property` might not allow `None`.
        #[unsafe(method(setValue:forProperty:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValue_forProperty(
            &self,
            value: Option<&AnyObject>,
            property: Option<&JSValueProperty>,
        );

        #[cfg(feature = "objc2-foundation")]
        /// Delete a property from a JSValue.
        ///
        /// Returns: YES if deletion is successful, NO otherwise.
        ///
        /// Corresponds to the JavaScript operation
        /// <code>
        /// delete object[property]
        /// </code>
        /// . Starting with macOS 10.15 and iOS 13, 'property' can be any 'id' and will be converted to a JSValue using the conversion rules of
        /// <code>
        /// valueWithObject:inContext:
        /// </code>
        /// . Prior to macOS 10.15 and iOS 13, 'property' was expected to be an NSString *.
        ///
        /// # Safety
        ///
        /// `property` might not allow `None`.
        #[unsafe(method(deleteProperty:))]
        #[unsafe(method_family = none)]
        pub unsafe fn deleteProperty(&self, property: Option<&JSValueProperty>) -> bool;

        #[cfg(feature = "objc2-foundation")]
        /// Check if a JSValue has a property.
        ///
        /// This method has the same function as the JavaScript operator
        /// <code>
        /// in
        /// </code>
        /// .
        ///
        /// Returns: Returns YES if property is present on the value.
        ///
        /// Corresponds to the JavaScript operation
        /// <code>
        /// property in object
        /// </code>
        /// . Starting with macOS 10.15 and iOS 13, 'property' can be any 'id' and will be converted to a JSValue using the conversion rules of
        /// <code>
        /// valueWithObject:inContext:
        /// </code>
        /// . Prior to macOS 10.15 and iOS 13, 'property' was expected to be an NSString *.
        ///
        /// # Safety
        ///
        /// `property` might not allow `None`.
        #[unsafe(method(hasProperty:))]
        #[unsafe(method_family = none)]
        pub unsafe fn hasProperty(&self, property: Option<&JSValueProperty>) -> bool;

        #[cfg(feature = "objc2-foundation")]
        /// Define properties with custom descriptors on JSValues.
        ///
        /// This method may be used to create a data or accessor property on an object.
        /// This method operates in accordance with the Object.defineProperty method in the JavaScript language. Starting with macOS 10.15 and iOS 13, 'property' can be any 'id' and will be converted to a JSValue using the conversion rules of
        /// <code>
        /// valueWithObject:inContext:
        /// </code>
        /// . Prior to macOS 10.15 and iOS 13, 'property' was expected to be an NSString *.
        ///
        /// # Safety
        ///
        /// - `property` might not allow `None`.
        /// - `descriptor` should be of the correct type.
        /// - `descriptor` might not allow `None`.
        #[unsafe(method(defineProperty:descriptor:))]
        #[unsafe(method_family = none)]
        pub unsafe fn defineProperty_descriptor(
            &self,
            property: Option<&JSValueProperty>,
            descriptor: Option<&AnyObject>,
        );

        /// Access an indexed (numerical) property on a JSValue.
        ///
        /// Returns: The JSValue for the property at the specified index.
        /// Returns the JavaScript value
        /// <code>
        /// undefined
        /// </code>
        /// if no property exists at that index.
        #[unsafe(method(valueAtIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueAtIndex(&self, index: NSUInteger) -> Option<Retained<JSValue>>;

        /// Set an indexed (numerical) property on a JSValue.
        ///
        /// For JSValues that are JavaScript arrays, indices greater than
        /// UINT_MAX - 1 will not affect the length of the array.
        ///
        /// # Safety
        ///
        /// - `value` should be of the correct type.
        /// - `value` might not allow `None`.
        #[unsafe(method(setValue:atIndex:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setValue_atIndex(&self, value: Option<&AnyObject>, index: NSUInteger);
    );
}

/// SubscriptSupport.
///
/// Instances of JSValue implement the following methods in order to enable
/// support for subscript access by key and index, for example:
///
/// ```text
///     JSValue *objectA, *objectB;
///     JSValue *v1 = object[@"X"]; // Get value for property "X" from 'object'.
///     JSValue *v2 = object[42];   // Get value for index 42 from 'object'.
///     object[@"Y"] = v1;          // Assign 'v1' to property "Y" of 'object'.
///     object[101] = v2;           // Assign 'v2' to index 101 of 'object'.
/// ```
///
/// An object key passed as a subscript will be converted to a JavaScript value,
/// and then the value using the same rules as
/// <code>
/// valueWithObject:inContext:
/// </code>
/// . In macOS
/// 10.14 and iOS 12 and below, the
/// <code>
/// key
/// </code>
/// argument of
/// <code>
/// setObject:object forKeyedSubscript:key
/// </code>
/// was restricted to an
/// <code>
/// NSObject
/// <NSCopying
/// > *
/// </code>
/// but that restriction was never used internally.
#[cfg(feature = "objc2")]
impl JSValue {
    extern_methods!(
        /// # Safety
        ///
        /// - `key` should be of the correct type.
        /// - `key` might not allow `None`.
        #[unsafe(method(objectForKeyedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectForKeyedSubscript(
            &self,
            key: Option<&AnyObject>,
        ) -> Option<Retained<JSValue>>;

        #[unsafe(method(objectAtIndexedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn objectAtIndexedSubscript(
            &self,
            index: NSUInteger,
        ) -> Option<Retained<JSValue>>;

        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `object` might not allow `None`.
        /// - `key` should be of the correct type.
        /// - `key` might not allow `None`.
        #[unsafe(method(setObject:forKeyedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setObject_forKeyedSubscript(
            &self,
            object: Option<&AnyObject>,
            key: Option<&AnyObject>,
        );

        /// # Safety
        ///
        /// - `object` should be of the correct type.
        /// - `object` might not allow `None`.
        #[unsafe(method(setObject:atIndexedSubscript:))]
        #[unsafe(method_family = none)]
        pub unsafe fn setObject_atIndexedSubscript(
            &self,
            object: Option<&AnyObject>,
            index: NSUInteger,
        );
    );
}

/// JSValueRefSupport.
///
/// These functions are for bridging between the C API and the Objective-C API.
#[cfg(feature = "objc2")]
impl JSValue {
    extern_methods!(
        #[cfg(all(feature = "JSBase", feature = "JSContext"))]
        /// Creates a JSValue, wrapping its C API counterpart.
        ///
        /// Returns: The Objective-C API equivalent of the specified JSValueRef.
        ///
        /// # Safety
        ///
        /// - `value` must be a valid pointer.
        /// - `context` might not allow `None`.
        #[unsafe(method(valueWithJSValueRef:inContext:))]
        #[unsafe(method_family = none)]
        pub unsafe fn valueWithJSValueRef_inContext(
            value: JSValueRef,
            context: Option<&JSContext>,
        ) -> Option<Retained<JSValue>>;

        #[cfg(feature = "JSBase")]
        /// Returns the C API counterpart wrapped by a JSContext.
        ///
        /// Returns: The C API equivalent of this JSValue.
        #[unsafe(method(JSValueRef))]
        #[unsafe(method_family = none)]
        pub unsafe fn JSValueRef(&self) -> JSValueRef;
    );
}

extern "C" {
    /// Property Descriptor Constants
    ///
    /// These keys may assist in creating a property descriptor for use with the
    /// defineProperty method on JSValue.
    /// Property descriptors must fit one of three descriptions:
    ///
    /// Data Descriptor:
    /// - A descriptor containing one or both of the keys
    /// <code>
    /// value
    /// </code>
    /// and
    /// <code>
    /// writable
    /// </code>
    /// ,
    /// and optionally containing one or both of the keys
    /// <code>
    /// enumerable
    /// </code>
    /// and
    /// <code>
    /// configurable
    /// </code>
    /// . A data descriptor may not contain either the
    /// <code>
    /// get
    /// </code>
    /// or
    /// <code>
    /// set
    /// </code>
    /// key.
    /// A data descriptor may be used to create or modify the attributes of a
    /// data property on an object (replacing any existing accessor property).
    ///
    /// Accessor Descriptor:
    /// - A descriptor containing one or both of the keys
    /// <code>
    /// get
    /// </code>
    /// and
    /// <code>
    /// set
    /// </code>
    /// , and
    /// optionally containing one or both of the keys
    /// <code>
    /// enumerable
    /// </code>
    /// and
    /// <code>
    /// configurable
    /// </code>
    /// . An accessor descriptor may not contain either the
    /// <code>
    /// value
    /// </code>
    /// or
    /// <code>
    /// writable
    /// </code>
    /// key.
    /// An accessor descriptor may be used to create or modify the attributes of
    /// an accessor property on an object (replacing any existing data property).
    ///
    /// Generic Descriptor:
    /// - A descriptor containing one or both of the keys
    /// <code>
    /// enumerable
    /// </code>
    /// and
    /// <code>
    /// configurable
    /// </code>
    /// . A generic descriptor may not contain any of the keys
    /// <code>
    /// value
    /// </code>
    /// ,
    /// <code>
    /// writable
    /// </code>
    /// ,
    /// <code>
    /// get
    /// </code>
    /// , or
    /// <code>
    /// set
    /// </code>
    /// .
    /// A generic descriptor may be used to modify the attributes of an existing
    /// data or accessor property, or to create a new data property.
    ///
    /// See also [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jspropertydescriptorwritablekey?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static JSPropertyDescriptorWritableKey: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jspropertydescriptorenumerablekey?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static JSPropertyDescriptorEnumerableKey: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jspropertydescriptorconfigurablekey?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static JSPropertyDescriptorConfigurableKey: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jspropertydescriptorvaluekey?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static JSPropertyDescriptorValueKey: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jspropertydescriptorgetkey?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static JSPropertyDescriptorGetKey: Option<&'static NSString>;
}

extern "C" {
    /// [Apple's documentation](https://developer.apple.com/documentation/javascriptcore/jspropertydescriptorsetkey?language=objc)
    #[cfg(feature = "objc2-foundation")]
    pub static JSPropertyDescriptorSetKey: Option<&'static NSString>;
}
