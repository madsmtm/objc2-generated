//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
use core::ptr::NonNull;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;
#[cfg(feature = "objc2-core-foundation")]
use objc2_core_foundation::*;

use crate::*;

extern "C" {
    /// CFNumber of the total allocation size of the buffer including all planes.
    ///
    /// ## Discussion
    ///
    /// Defaults to BufferHeight * BytesPerRow if not specified. Must be specified for dimensionless buffers.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceAllocSize: &'static CFString;
}

extern "C" {
    /// CFNumber for the width of the IOSurface buffer in pixels.
    ///
    /// ## Discussion
    ///
    /// Required for planar IOSurfaces.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceWidth: &'static CFString;
}

extern "C" {
    /// CFNumber for the height of the IOSurface buffer in pixels.
    ///
    /// ## Discussion
    ///
    /// Required for planar IOSurfaces.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceHeight: &'static CFString;
}

extern "C" {
    /// CFNumber for the bytes per row of the buffer.
    ///
    /// ## Discussion
    ///
    /// If not specified, IOSurface will first calculate the number full elements required on each row (by rounding up), multiplied by the bytes per element for this buffer. That value will then be appropriately aligned.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceBytesPerRow: &'static CFString;
}

extern "C" {
    /// CFNumber for the total number of bytes in an element.
    ///
    /// ## Discussion
    ///
    /// Default to 1.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceBytesPerElement: &'static CFString;
}

extern "C" {
    /// CFNumber for how many pixels wide each element is.
    ///
    /// ## Discussion
    ///
    /// Defaults to 1.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceElementWidth: &'static CFString;
}

extern "C" {
    /// CFNumber for how many pixels high each element is.
    ///
    /// ## Discussion
    ///
    /// Defaults to 1.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceElementHeight: &'static CFString;
}

extern "C" {
    /// CFNumber for the starting offset into the buffer.
    ///
    /// ## Discussion
    ///
    /// Defaults to 0.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceOffset: &'static CFString;
}

extern "C" {
    /// CFArray describing each image plane in the buffer as a CFDictionary.
    ///
    /// ## Discussion
    ///
    /// The CFArray must have at least one entry.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneInfo: &'static CFString;
}

extern "C" {
    /// CFNumber for the width of this plane in pixels.
    ///
    /// ## Discussion
    ///
    /// Required for image planes.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneWidth: &'static CFString;
}

extern "C" {
    /// CFNumber for the height of this plane in pixels.
    ///
    /// ## Discussion
    ///
    /// Required for image planes.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneHeight: &'static CFString;
}

extern "C" {
    /// CFNumber for the bytes per row of this plane.
    ///
    /// ## Discussion
    ///
    /// If not specified, IOSurface will first calculate the number full elements required on each row (by rounding up), multiplied by the bytes per element for this plane. That value will then be appropriately aligned.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneBytesPerRow: &'static CFString;
}

extern "C" {
    /// CFNumber for the offset into the buffer for this plane.
    ///
    /// ## Discussion
    ///
    /// If not specified then IOSurface will lay out each plane sequentially based on the previous plane’s allocation size.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneOffset: &'static CFString;
}

extern "C" {
    /// CFNumber for the total data size of this plane.
    ///
    /// ## Discussion
    ///
    /// Defaults to plane height * plane bytes per row if not specified.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneSize: &'static CFString;
}

extern "C" {
    /// CFNumber for the base offset into the buffer for this plane.
    ///
    /// ## Discussion
    ///
    /// Optional, defaults to the plane offset
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneBase: &'static CFString;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneBitsPerElement: &'static CFString;
}

extern "C" {
    /// CFNumber for the bytes per element of this plane.
    ///
    /// ## Discussion
    ///
    /// Optional, default is 1.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneBytesPerElement: &'static CFString;
}

extern "C" {
    /// CFNumber for the element width of this plane.
    ///
    /// ## Discussion
    ///
    /// Optional, default is 1.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneElementWidth: &'static CFString;
}

extern "C" {
    /// CFNumber for the element height of this plane.
    ///
    /// ## Discussion
    ///
    /// Optional, default is 1.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneElementHeight: &'static CFString;
}

extern "C" {
    /// CFNumber for the CPU cache mode to be used for the allocation.
    ///
    /// ## Discussion
    ///
    /// Default is `kIOMapDefaultCache`.
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceCacheMode: &'static CFString;
}

extern "C" {
    /// CFBoolean If true, the IOSurface may be looked up by any task in the system by its ID.
    ///
    /// ## Discussion
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "Global surfaces are insecure"]
    pub static kIOSurfaceIsGlobal: &'static CFString;
}

extern "C" {
    /// A 32-bit unsigned integer doc://com.apple.documentation/documentation/corefoundation/cfnumber-rjd that stores the traditional macOS buffer format.
    ///
    /// ## Discussion
    ///
    ///
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePixelFormat: &'static CFString;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePixelSizeCastingAllowed: &'static CFString;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneComponentBitDepths: &'static CFString;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneComponentBitOffsets: &'static CFString;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceName: &'static CFString;
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOSurfaceComponentName(pub i32);
impl IOSurfaceComponentName {
    #[doc(alias = "kIOSurfaceComponentNameUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "kIOSurfaceComponentNameAlpha")]
    pub const Alpha: Self = Self(1);
    #[doc(alias = "kIOSurfaceComponentNameRed")]
    pub const Red: Self = Self(2);
    #[doc(alias = "kIOSurfaceComponentNameGreen")]
    pub const Green: Self = Self(3);
    #[doc(alias = "kIOSurfaceComponentNameBlue")]
    pub const Blue: Self = Self(4);
    #[doc(alias = "kIOSurfaceComponentNameLuma")]
    pub const Luma: Self = Self(5);
    #[doc(alias = "kIOSurfaceComponentNameChromaRed")]
    pub const ChromaRed: Self = Self(6);
    #[doc(alias = "kIOSurfaceComponentNameChromaBlue")]
    pub const ChromaBlue: Self = Self(7);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOSurfaceComponentName {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOSurfaceComponentName {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl Send for IOSurfaceComponentName {}

unsafe impl Sync for IOSurfaceComponentName {}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneComponentNames: &'static CFString;
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOSurfaceComponentType(pub i32);
impl IOSurfaceComponentType {
    #[doc(alias = "kIOSurfaceComponentTypeUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "kIOSurfaceComponentTypeUnsignedInteger")]
    pub const UnsignedInteger: Self = Self(1);
    #[doc(alias = "kIOSurfaceComponentTypeSignedInteger")]
    pub const SignedInteger: Self = Self(2);
    #[doc(alias = "kIOSurfaceComponentTypeFloat")]
    pub const Float: Self = Self(3);
    #[doc(alias = "kIOSurfaceComponentTypeSignedNormalized")]
    pub const SignedNormalized: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOSurfaceComponentType {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOSurfaceComponentType {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl Send for IOSurfaceComponentType {}

unsafe impl Sync for IOSurfaceComponentType {}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneComponentTypes: &'static CFString;
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOSurfaceComponentRange(pub i32);
impl IOSurfaceComponentRange {
    #[doc(alias = "kIOSurfaceComponentRangeUnknown")]
    pub const Unknown: Self = Self(0);
    #[doc(alias = "kIOSurfaceComponentRangeFullRange")]
    pub const FullRange: Self = Self(1);
    #[doc(alias = "kIOSurfaceComponentRangeVideoRange")]
    pub const VideoRange: Self = Self(2);
    #[doc(alias = "kIOSurfaceComponentRangeWideRange")]
    pub const WideRange: Self = Self(3);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOSurfaceComponentRange {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOSurfaceComponentRange {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl Send for IOSurfaceComponentRange {}

unsafe impl Sync for IOSurfaceComponentRange {}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfacePlaneComponentRanges: &'static CFString;
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOSurfaceSubsampling(pub i32);
impl IOSurfaceSubsampling {
    #[doc(alias = "kIOSurfaceSubsamplingUnknown")]
    pub const SubsamplingUnknown: Self = Self(0);
    #[doc(alias = "kIOSurfaceSubsamplingNone")]
    pub const SubsamplingNone: Self = Self(1);
    #[doc(alias = "kIOSurfaceSubsampling422")]
    pub const Subsampling422: Self = Self(2);
    #[doc(alias = "kIOSurfaceSubsampling420")]
    pub const Subsampling420: Self = Self(3);
    #[doc(alias = "kIOSurfaceSubsampling411")]
    pub const Subsampling411: Self = Self(4);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOSurfaceSubsampling {
    const ENCODING: Encoding = i32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOSurfaceSubsampling {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl Send for IOSurfaceSubsampling {}

unsafe impl Sync for IOSurfaceSubsampling {}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceSubsampling: &'static CFString;
}

#[cfg(feature = "objc2-core-foundation")]
unsafe impl ConcreteType for IOSurfaceRef {
    #[doc(alias = "IOSurfaceGetTypeID")]
    #[inline]
    fn type_id() -> CFTypeID {
        extern "C-unwind" {
            fn IOSurfaceGetTypeID() -> CFTypeID;
        }
        unsafe { IOSurfaceGetTypeID() }
    }
}

impl IOSurfaceRef {
    /// Creates a brand new IOSurface object
    ///
    /// # Safety
    ///
    /// - `properties` generic must be of the correct type.
    /// - `properties` generic must be of the correct type.
    #[doc(alias = "IOSurfaceCreate")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn new(properties: &CFDictionary) -> Option<CFRetained<IOSurfaceRef>> {
        extern "C-unwind" {
            fn IOSurfaceCreate(properties: &CFDictionary) -> Option<NonNull<IOSurfaceRef>>;
        }
        let ret = unsafe { IOSurfaceCreate(properties) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Performs an atomic lookup and retain of an IOSurface by its IOSurfaceID.
    #[doc(alias = "IOSurfaceLookup")]
    #[cfg(all(feature = "IOSurfaceTypes", feature = "objc2-core-foundation"))]
    #[inline]
    pub fn lookup(csid: IOSurfaceID) -> Option<CFRetained<IOSurfaceRef>> {
        extern "C-unwind" {
            fn IOSurfaceLookup(csid: IOSurfaceID) -> Option<NonNull<IOSurfaceRef>>;
        }
        let ret = unsafe { IOSurfaceLookup(csid) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Retrieves the unique [`IOSurfaceID`](https://developer.apple.com/documentation/iosurface/iosurfaceid) value for an [`IOSurface`](https://developer.apple.com/documentation/iosurface/iosurface).
    #[doc(alias = "IOSurfaceGetID")]
    #[cfg(feature = "IOSurfaceTypes")]
    #[inline]
    pub fn id(&self) -> IOSurfaceID {
        extern "C-unwind" {
            fn IOSurfaceGetID(buffer: &IOSurfaceRef) -> IOSurfaceID;
        }
        unsafe { IOSurfaceGetID(self) }
    }

    /// “Lock” an IOSurface for reading or writing.
    ///
    /// ## Discussion
    ///
    /// The term “lock” is used loosely in this context, and is used along with the “unlock” information to put a bound on CPU access to the raw [`IOSurface`](https://developer.apple.com/documentation/iosurface/iosurface) data.
    ///
    /// If the seed parameter is non-NULL, [`IOSurfaceLock`](https://developer.apple.com/documentation/iosurface/iosurfacelock(_:_:_:)) will store the buffer’s internal modification seed value at the time you made the lock call. You can compare this value to a value returned previously to determine of the contents of the buffer has been changed since the last lock.
    ///
    /// In the case of [`IOSurfaceUnlock`](https://developer.apple.com/documentation/iosurface/iosurfaceunlock(_:_:_:)), the seed value returned will be the internal seed value at the time of the unlock. If you locked the buffer for writing, this value will be incremented as the unlock is performed and the new value will be returned.
    ///
    /// See `IOSurface lock flags` for more information.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Locking and unlocking an IOSurface is not a particularly cheap operation, so care should be taken to avoid the calls whenever possible. The seed values are particularly useful for keeping a cache of the buffer contents.
    ///
    ///
    ///
    /// </div>
    ///
    ///
    /// # Safety
    ///
    /// `seed` must be a valid pointer or null.
    #[doc(alias = "IOSurfaceLock")]
    #[cfg(all(feature = "IOSurfaceTypes", feature = "libc"))]
    #[inline]
    pub unsafe fn lock(
        &self,
        options: IOSurfaceLockOptions,
        seed: *mut u32,
    ) -> libc::kern_return_t {
        extern "C-unwind" {
            fn IOSurfaceLock(
                buffer: &IOSurfaceRef,
                options: IOSurfaceLockOptions,
                seed: *mut u32,
            ) -> libc::kern_return_t;
        }
        unsafe { IOSurfaceLock(self, options, seed) }
    }

    /// “Unlock” an [`IOSurface`](https://developer.apple.com/documentation/iosurface/iosurface) for reading or writing.
    ///
    /// ## Discussion
    ///
    /// The term “lock” is used loosely in this context, and is used along with the “unlock” information to put a bound on CPU access to the raw [`IOSurface`](https://developer.apple.com/documentation/iosurface/iosurface) data.
    ///
    /// If the seed parameter is non-NULL, [`IOSurfaceLock`](https://developer.apple.com/documentation/iosurface/iosurfacelock(_:_:_:)) will store the buffer’s internal modification seed value at the time you made the lock call. You can compare this value to a value returned previously to determine of the contents of the buffer has been changed since the last lock.
    ///
    /// In the case of [`IOSurfaceUnlock`](https://developer.apple.com/documentation/iosurface/iosurfaceunlock(_:_:_:)), the seed value returned will be the internal seed value at the time of the unlock. If you locked the buffer for writing, this value will be incremented as the unlock is performed and the new value will be returned.
    ///
    /// See the kIOSurfaceLock enums for more information.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Locking and unlocking an [`IOSurface`](https://developer.apple.com/documentation/iosurface/iosurface) is not a particularly cheap operation, so care should be taken to avoid the calls whenever possible. The seed values are particularly useful for keeping a cache of the buffer contents.
    ///
    ///
    ///
    /// </div>
    ///
    ///
    /// # Safety
    ///
    /// `seed` must be a valid pointer or null.
    #[doc(alias = "IOSurfaceUnlock")]
    #[cfg(all(feature = "IOSurfaceTypes", feature = "libc"))]
    #[inline]
    pub unsafe fn unlock(
        &self,
        options: IOSurfaceLockOptions,
        seed: *mut u32,
    ) -> libc::kern_return_t {
        extern "C-unwind" {
            fn IOSurfaceUnlock(
                buffer: &IOSurfaceRef,
                options: IOSurfaceLockOptions,
                seed: *mut u32,
            ) -> libc::kern_return_t;
        }
        unsafe { IOSurfaceUnlock(self, options, seed) }
    }

    /// Returns the total allocation size of the buffer including all planes.
    ///
    /// ## Return Value
    ///
    /// Returns 0 if buffer is invalid.
    ///
    ///
    #[doc(alias = "IOSurfaceGetAllocSize")]
    #[inline]
    pub fn alloc_size(&self) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetAllocSize(buffer: &IOSurfaceRef) -> usize;
        }
        unsafe { IOSurfaceGetAllocSize(self) }
    }

    /// Returns the width of the IOSurface buffer in pixels.
    ///
    /// ## Return Value
    ///
    /// Returns 0 if buffer is invalid.
    ///
    ///
    #[doc(alias = "IOSurfaceGetWidth")]
    #[inline]
    pub fn width(&self) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetWidth(buffer: &IOSurfaceRef) -> usize;
        }
        unsafe { IOSurfaceGetWidth(self) }
    }

    /// Returns the height of the IOSurface buffer in pixels.
    ///
    /// ## Return Value
    ///
    /// Returns 0 if buffer is invalid.
    ///
    ///
    #[doc(alias = "IOSurfaceGetHeight")]
    #[inline]
    pub fn height(&self) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetHeight(buffer: &IOSurfaceRef) -> usize;
        }
        unsafe { IOSurfaceGetHeight(self) }
    }

    /// Returns the length (in bytes) of each element in a particular buffer.
    ///
    /// ## Return Value
    ///
    /// Returns 0 if buffer is invalid.
    ///
    ///
    #[doc(alias = "IOSurfaceGetBytesPerElement")]
    #[inline]
    pub fn bytes_per_element(&self) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetBytesPerElement(buffer: &IOSurfaceRef) -> usize;
        }
        unsafe { IOSurfaceGetBytesPerElement(self) }
    }

    /// Returns the length (in bytes) of each row in a particular buffer.
    ///
    /// ## Return Value
    ///
    /// Returns 0 if buffer is invalid.
    ///
    ///
    #[doc(alias = "IOSurfaceGetBytesPerRow")]
    #[inline]
    pub fn bytes_per_row(&self) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetBytesPerRow(buffer: &IOSurfaceRef) -> usize;
        }
        unsafe { IOSurfaceGetBytesPerRow(self) }
    }

    /// Returns the address of the first byte of data in a particular buffer.
    ///
    /// ## Return Value
    ///
    /// Returns NULL if buffer is invalid.
    ///
    ///
    #[doc(alias = "IOSurfaceGetBaseAddress")]
    #[inline]
    pub fn base_address(&self) -> NonNull<c_void> {
        extern "C-unwind" {
            fn IOSurfaceGetBaseAddress(buffer: &IOSurfaceRef) -> Option<NonNull<c_void>>;
        }
        let ret = unsafe { IOSurfaceGetBaseAddress(self) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns the width (in pixels) of each element in a particular buffer.
    ///
    /// ## Return Value
    ///
    /// Returns 0 if buffer is invalid.
    ///
    ///
    #[doc(alias = "IOSurfaceGetElementWidth")]
    #[inline]
    pub fn element_width(&self) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetElementWidth(buffer: &IOSurfaceRef) -> usize;
        }
        unsafe { IOSurfaceGetElementWidth(self) }
    }

    /// Returns the height (in pixels) of each element in a particular buffer.
    ///
    /// ## Return Value
    ///
    /// Returns 0 if buffer is invalid.
    ///
    ///
    #[doc(alias = "IOSurfaceGetElementHeight")]
    #[inline]
    pub fn element_height(&self) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetElementHeight(buffer: &IOSurfaceRef) -> usize;
        }
        unsafe { IOSurfaceGetElementHeight(self) }
    }

    /// Returns an unsigned integer that contains the traditional macOS buffer format.
    ///
    /// ## Return Value
    ///
    /// Returns 0 if buffer is invalid.
    ///
    ///
    #[doc(alias = "IOSurfaceGetPixelFormat")]
    #[inline]
    pub fn pixel_format(&self) -> OSType {
        extern "C-unwind" {
            fn IOSurfaceGetPixelFormat(buffer: &IOSurfaceRef) -> OSType;
        }
        unsafe { IOSurfaceGetPixelFormat(self) }
    }

    ///
    /// ## Discussion
    ///
    /// This will return the current seed value of the buffer and is a cheap call to make to see if the contents of the buffer have changed since the last lock/unlock.
    ///
    ///
    #[doc(alias = "IOSurfaceGetSeed")]
    #[inline]
    pub fn seed(&self) -> u32 {
        extern "C-unwind" {
            fn IOSurfaceGetSeed(buffer: &IOSurfaceRef) -> u32;
        }
        unsafe { IOSurfaceGetSeed(self) }
    }

    ///
    /// ## Discussion
    ///
    /// Return the number of planes in this buffer. May be 0. Returns 0 for an invalid or NULL buffer pointer.
    ///
    ///
    #[doc(alias = "IOSurfaceGetPlaneCount")]
    #[inline]
    pub fn plane_count(&self) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetPlaneCount(buffer: &IOSurfaceRef) -> usize;
        }
        unsafe { IOSurfaceGetPlaneCount(self) }
    }

    /// Returns the width of the specified plane (in pixels).
    ///
    /// ## Discussion
    ///
    /// If the planeIndex is greater than or equal to the plane count of the IOSurface, zero is returned…. with one exception. If this IOSurface has zero planes and a planeIndex of zero is passed in, the routines function just like the non-planar APIs. This is to allow higher level code to treat planar and non-planar buffers is a more uniform fashion.
    ///
    ///
    #[doc(alias = "IOSurfaceGetWidthOfPlane")]
    #[inline]
    pub fn width_of_plane(&self, plane_index: usize) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetWidthOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
        }
        unsafe { IOSurfaceGetWidthOfPlane(self, plane_index) }
    }

    /// Returns the height of the specified plane (in pixels).
    ///
    /// ## Discussion
    ///
    /// If the planeIndex is greater than or equal to the plane count of the IOSurface, zero is returned…. with one exception. If this IOSurface has zero planes and a planeIndex of zero is passed in, the routines function just like the non-planar APIs. This is to allow higher level code to treat planar and non-planar buffers is a more uniform fashion.
    ///
    ///
    #[doc(alias = "IOSurfaceGetHeightOfPlane")]
    #[inline]
    pub fn height_of_plane(&self, plane_index: usize) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetHeightOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
        }
        unsafe { IOSurfaceGetHeightOfPlane(self, plane_index) }
    }

    /// Returns the size of each element (in bytes) in the specified plane.
    ///
    /// ## Discussion
    ///
    /// If the planeIndex is greater than or equal to the plane count of the IOSurface, zero is returned…. with one exception. If this IOSurface has zero planes and a planeIndex of zero is passed in, the routines function just like the non-planar APIs. This is to allow higher level code to treat planar and non-planar buffers is a more uniform fashion.
    ///
    ///
    #[doc(alias = "IOSurfaceGetBytesPerElementOfPlane")]
    #[inline]
    pub fn bytes_per_element_of_plane(&self, plane_index: usize) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetBytesPerElementOfPlane(
                buffer: &IOSurfaceRef,
                plane_index: usize,
            ) -> usize;
        }
        unsafe { IOSurfaceGetBytesPerElementOfPlane(self, plane_index) }
    }

    /// Returns the size of each row (in bytes) in the specified plane.
    ///
    /// ## Discussion
    ///
    /// If the planeIndex is greater than or equal to the plane count of the IOSurface, zero is returned…. with one exception. If this IOSurface has zero planes and a planeIndex of zero is passed in, the routines function just like the non-planar APIs. This is to allow higher level code to treat planar and non-planar buffers is a more uniform fashion.
    ///
    ///
    #[doc(alias = "IOSurfaceGetBytesPerRowOfPlane")]
    #[inline]
    pub fn bytes_per_row_of_plane(&self, plane_index: usize) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetBytesPerRowOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
        }
        unsafe { IOSurfaceGetBytesPerRowOfPlane(self, plane_index) }
    }

    /// Returns the address of the first byte of data in the specified plane.
    ///
    /// ## Discussion
    ///
    /// If the planeIndex is greater than or equal to the plane count of the IOSurface, zero is returned…. with one exception. If this IOSurface has zero planes and a planeIndex of zero is passed in, the routines function just like the non-planar APIs. This is to allow higher level code to treat planar and non-planar buffers is a more uniform fashion.
    ///
    ///
    #[doc(alias = "IOSurfaceGetBaseAddressOfPlane")]
    #[inline]
    pub fn base_address_of_plane(&self, plane_index: usize) -> NonNull<c_void> {
        extern "C-unwind" {
            fn IOSurfaceGetBaseAddressOfPlane(
                buffer: &IOSurfaceRef,
                plane_index: usize,
            ) -> Option<NonNull<c_void>>;
        }
        let ret = unsafe { IOSurfaceGetBaseAddressOfPlane(self, plane_index) };
        ret.expect("function was marked as returning non-null, but actually returned NULL")
    }

    /// Returns the width (in pixels) of each element in the specified plane.
    ///
    /// ## Discussion
    ///
    /// If the planeIndex is greater than or equal to the plane count of the IOSurface, zero is returned…. with one exception. If this IOSurface has zero planes and a planeIndex of zero is passed in, the routines function just like the non-planar APIs. This is to allow higher level code to treat planar and non-planar buffers is a more uniform fashion.
    ///
    ///
    #[doc(alias = "IOSurfaceGetElementWidthOfPlane")]
    #[inline]
    pub fn element_width_of_plane(&self, plane_index: usize) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetElementWidthOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
        }
        unsafe { IOSurfaceGetElementWidthOfPlane(self, plane_index) }
    }

    /// Returns the height (in pixels) of each element in the specified plane.
    ///
    /// ## Discussion
    ///
    /// If the planeIndex is greater than or equal to the plane count of the IOSurface, zero is returned…. with one exception. If this IOSurface has zero planes and a planeIndex of zero is passed in, the routines function just like the non-planar APIs. This is to allow higher level code to treat planar and non-planar buffers is a more uniform fashion.
    ///
    ///
    #[doc(alias = "IOSurfaceGetElementHeightOfPlane")]
    #[inline]
    pub fn element_height_of_plane(&self, plane_index: usize) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetElementHeightOfPlane(buffer: &IOSurfaceRef, plane_index: usize)
                -> usize;
        }
        unsafe { IOSurfaceGetElementHeightOfPlane(self, plane_index) }
    }

    #[doc(alias = "IOSurfaceGetNumberOfComponentsOfPlane")]
    #[inline]
    pub fn number_of_components_of_plane(&self, plane_index: usize) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetNumberOfComponentsOfPlane(
                buffer: &IOSurfaceRef,
                plane_index: usize,
            ) -> usize;
        }
        unsafe { IOSurfaceGetNumberOfComponentsOfPlane(self, plane_index) }
    }

    #[doc(alias = "IOSurfaceGetNameOfComponentOfPlane")]
    #[inline]
    pub fn name_of_component_of_plane(
        &self,
        plane_index: usize,
        component_index: usize,
    ) -> IOSurfaceComponentName {
        extern "C-unwind" {
            fn IOSurfaceGetNameOfComponentOfPlane(
                buffer: &IOSurfaceRef,
                plane_index: usize,
                component_index: usize,
            ) -> IOSurfaceComponentName;
        }
        unsafe { IOSurfaceGetNameOfComponentOfPlane(self, plane_index, component_index) }
    }

    #[doc(alias = "IOSurfaceGetTypeOfComponentOfPlane")]
    #[inline]
    pub fn type_of_component_of_plane(
        &self,
        plane_index: usize,
        component_index: usize,
    ) -> IOSurfaceComponentType {
        extern "C-unwind" {
            fn IOSurfaceGetTypeOfComponentOfPlane(
                buffer: &IOSurfaceRef,
                plane_index: usize,
                component_index: usize,
            ) -> IOSurfaceComponentType;
        }
        unsafe { IOSurfaceGetTypeOfComponentOfPlane(self, plane_index, component_index) }
    }

    #[doc(alias = "IOSurfaceGetRangeOfComponentOfPlane")]
    #[inline]
    pub fn range_of_component_of_plane(
        &self,
        plane_index: usize,
        component_index: usize,
    ) -> IOSurfaceComponentRange {
        extern "C-unwind" {
            fn IOSurfaceGetRangeOfComponentOfPlane(
                buffer: &IOSurfaceRef,
                plane_index: usize,
                component_index: usize,
            ) -> IOSurfaceComponentRange;
        }
        unsafe { IOSurfaceGetRangeOfComponentOfPlane(self, plane_index, component_index) }
    }

    #[doc(alias = "IOSurfaceGetBitDepthOfComponentOfPlane")]
    #[inline]
    pub fn bit_depth_of_component_of_plane(
        &self,
        plane_index: usize,
        component_index: usize,
    ) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetBitDepthOfComponentOfPlane(
                buffer: &IOSurfaceRef,
                plane_index: usize,
                component_index: usize,
            ) -> usize;
        }
        unsafe { IOSurfaceGetBitDepthOfComponentOfPlane(self, plane_index, component_index) }
    }

    #[doc(alias = "IOSurfaceGetBitOffsetOfComponentOfPlane")]
    #[inline]
    pub fn bit_offset_of_component_of_plane(
        &self,
        plane_index: usize,
        component_index: usize,
    ) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetBitOffsetOfComponentOfPlane(
                buffer: &IOSurfaceRef,
                plane_index: usize,
                component_index: usize,
            ) -> usize;
        }
        unsafe { IOSurfaceGetBitOffsetOfComponentOfPlane(self, plane_index, component_index) }
    }

    #[doc(alias = "IOSurfaceGetSubsampling")]
    #[inline]
    pub fn subsampling(&self) -> IOSurfaceSubsampling {
        extern "C-unwind" {
            fn IOSurfaceGetSubsampling(buffer: &IOSurfaceRef) -> IOSurfaceSubsampling;
        }
        unsafe { IOSurfaceGetSubsampling(self) }
    }
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceColorSpace: &'static CFString;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceICCProfile: &'static CFString;
}

extern "C" {
    #[cfg(feature = "objc2-core-foundation")]
    pub static kIOSurfaceContentHeadroom: &'static CFString;
}

impl IOSurfaceRef {
    /// Sets a value in the dictionary associated with the buffer.
    ///
    /// ## Discussion
    ///
    /// This call lets you attach CF property list types to an IOSurface buffer. This call is expensive (it must essentially serialize the data into the kernel) and thus should be avoided whenever possible.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This function cannot be used to change the underlying surface properties.
    ///
    ///
    ///
    /// </div>
    ///
    ///
    /// # Safety
    ///
    /// `value` should be of the correct type.
    #[doc(alias = "IOSurfaceSetValue")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn set_value(&self, key: &CFString, value: &CFType) {
        extern "C-unwind" {
            fn IOSurfaceSetValue(buffer: &IOSurfaceRef, key: &CFString, value: &CFType);
        }
        unsafe { IOSurfaceSetValue(self, key, value) }
    }

    /// Retrieves a value from the dictionary associated with the buffer.
    ///
    /// ## Discussion
    ///
    /// This call lets you attach CF property list types to an IOSurface buffer. This call is expensive (it must essentially serialize the data into the kernel) and thus should be avoided whenever possible.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This function cannot be used to change the underlying surface properties.
    ///
    ///
    ///
    /// </div>
    ///
    #[doc(alias = "IOSurfaceCopyValue")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn value(&self, key: &CFString) -> Option<CFRetained<CFType>> {
        extern "C-unwind" {
            fn IOSurfaceCopyValue(buffer: &IOSurfaceRef, key: &CFString)
                -> Option<NonNull<CFType>>;
        }
        let ret = unsafe { IOSurfaceCopyValue(self, key) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Deletes a value in the dictionary associated with the buffer.
    ///
    /// ## Discussion
    ///
    /// This call lets you attach CF property list types to an IOSurface buffer. This call is expensive (it must essentially serialize the data into the kernel) and thus should be avoided whenever possible.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This function cannot be used to change the underlying surface properties.
    ///
    ///
    ///
    /// </div>
    ///
    #[doc(alias = "IOSurfaceRemoveValue")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn remove_value(&self, key: &CFString) {
        extern "C-unwind" {
            fn IOSurfaceRemoveValue(buffer: &IOSurfaceRef, key: &CFString);
        }
        unsafe { IOSurfaceRemoveValue(self, key) }
    }

    /// # Safety
    ///
    /// - `keys_and_values` generic must be of the correct type.
    /// - `keys_and_values` generic must be of the correct type.
    #[doc(alias = "IOSurfaceSetValues")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub unsafe fn set_values(&self, keys_and_values: &CFDictionary) {
        extern "C-unwind" {
            fn IOSurfaceSetValues(buffer: &IOSurfaceRef, keys_and_values: &CFDictionary);
        }
        unsafe { IOSurfaceSetValues(self, keys_and_values) }
    }

    #[doc(alias = "IOSurfaceCopyAllValues")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn all_values(&self) -> Option<CFRetained<CFDictionary>> {
        extern "C-unwind" {
            fn IOSurfaceCopyAllValues(buffer: &IOSurfaceRef) -> Option<NonNull<CFDictionary>>;
        }
        let ret = unsafe { IOSurfaceCopyAllValues(self) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    #[doc(alias = "IOSurfaceRemoveAllValues")]
    #[inline]
    pub fn remove_all_values(&self) {
        extern "C-unwind" {
            fn IOSurfaceRemoveAllValues(buffer: &IOSurfaceRef);
        }
        unsafe { IOSurfaceRemoveAllValues(self) }
    }

    /// Returns a mach_port_t that holds a reference to the IOSurface.
    ///
    /// ## Discussion
    ///
    /// This is useful if you need to atomically or securely pass an IOSurface to another task without making the surface global to the entire system. The returned port must be deallocated with mach_port_deallocate or the equivalent.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  Any live mach ports created from an IOSurfaceRef implicitly increase the IOSurface’s global use count by one until the port is deleted.
    ///
    ///
    ///
    /// </div>
    ///
    #[doc(alias = "IOSurfaceCreateMachPort")]
    #[cfg(feature = "libc")]
    #[inline]
    pub fn create_mach_port(&self) -> libc::mach_port_t {
        extern "C-unwind" {
            fn IOSurfaceCreateMachPort(buffer: &IOSurfaceRef) -> libc::mach_port_t;
        }
        unsafe { IOSurfaceCreateMachPort(self) }
    }

    /// Recreates an IOSurfaceRef from a mach port.
    ///
    /// ## Discussion
    ///
    /// This call takes a mach_port_t created via IOSurfaceCreatePort() and recreates an IOSurfaceRef from it.
    ///
    /// <div class="warning">
    ///
    /// ### Note
    ///  This call does NOT destroy the port.
    ///
    ///
    ///
    /// </div>
    ///
    #[doc(alias = "IOSurfaceLookupFromMachPort")]
    #[cfg(all(feature = "libc", feature = "objc2-core-foundation"))]
    #[inline]
    pub fn lookup_from_mach_port(port: libc::mach_port_t) -> Option<CFRetained<IOSurfaceRef>> {
        extern "C-unwind" {
            fn IOSurfaceLookupFromMachPort(
                port: libc::mach_port_t,
            ) -> Option<NonNull<IOSurfaceRef>>;
        }
        let ret = unsafe { IOSurfaceLookupFromMachPort(port) };
        ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
    }

    /// Returns the maximum value for a given property that is guaranteed to be compatible with all of the current devices (GPUs, etc.) in the system.
    ///
    /// ## Discussion
    ///
    /// The most important values to obtain are:
    ///
    /// - `kIOSurfaceBytesPerRow`
    ///
    /// - `kIOSurfaceWidth`
    ///
    /// - `kIOSurfaceHeight`
    ///
    /// - `kIOSurfacePlaneBytesPerRow`
    ///
    /// - `kIOSurfacePlaneWidth`
    ///
    /// - `kIOSurfacePlaneHeight`
    ///
    /// For the width and height properties, the maximum values are the largest that are guaranteed to work for both reading and writing. In OpenGL terms this translates into the largest size that will work for both textures and render targets.
    ///
    /// This function returns 0 for properties that have no predefined limit or where the concept of a limit would be considered invalid (such as `kIOSurfacePixelFormat`).
    ///
    ///
    #[doc(alias = "IOSurfaceGetPropertyMaximum")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn property_maximum(property: &CFString) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetPropertyMaximum(property: &CFString) -> usize;
        }
        unsafe { IOSurfaceGetPropertyMaximum(property) }
    }

    /// Returns the alignment requirements for a property (if any).
    ///
    /// ## Discussion
    ///
    /// If the property has no alignment requirement then this function returns 1. The following properties should always be aligned if you choose to calculate them yourself:
    ///
    /// - `kIOSurfaceBytesPerRow`
    ///
    /// - `kIOSurfaceOffset`
    ///
    /// - `kIOSurfacePlaneBase`
    ///
    /// - `kIOSurfacePlaneOffset`
    ///
    /// - `kIOSurfacePlaneBytesPerRow`
    ///
    ///
    #[doc(alias = "IOSurfaceGetPropertyAlignment")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn property_alignment(property: &CFString) -> usize {
        extern "C-unwind" {
            fn IOSurfaceGetPropertyAlignment(property: &CFString) -> usize;
        }
        unsafe { IOSurfaceGetPropertyAlignment(property) }
    }

    /// Returns the smallest aligned value greater than or equal to the specified value.
    ///
    /// ## Discussion
    ///
    /// For properties with no alignment requirements, the original value is returned.
    ///
    ///
    #[doc(alias = "IOSurfaceAlignProperty")]
    #[cfg(feature = "objc2-core-foundation")]
    #[inline]
    pub fn align_property(property: &CFString, value: usize) -> usize {
        extern "C-unwind" {
            fn IOSurfaceAlignProperty(property: &CFString, value: usize) -> usize;
        }
        unsafe { IOSurfaceAlignProperty(property, value) }
    }

    /// Increments the per-process usage count for an [`IOSurface`](https://developer.apple.com/documentation/iosurface/iosurface).
    #[doc(alias = "IOSurfaceIncrementUseCount")]
    #[inline]
    pub fn increment_use_count(&self) {
        extern "C-unwind" {
            fn IOSurfaceIncrementUseCount(buffer: &IOSurfaceRef);
        }
        unsafe { IOSurfaceIncrementUseCount(self) }
    }

    /// Decrements the per-process usage count for an [`IOSurface`](https://developer.apple.com/documentation/iosurface/iosurface).
    #[doc(alias = "IOSurfaceDecrementUseCount")]
    #[inline]
    pub fn decrement_use_count(&self) {
        extern "C-unwind" {
            fn IOSurfaceDecrementUseCount(buffer: &IOSurfaceRef);
        }
        unsafe { IOSurfaceDecrementUseCount(self) }
    }

    /// Returns the per-process usage count for an [`IOSurface`](https://developer.apple.com/documentation/iosurface/iosurface).
    #[doc(alias = "IOSurfaceGetUseCount")]
    #[inline]
    pub fn use_count(&self) -> i32 {
        extern "C-unwind" {
            fn IOSurfaceGetUseCount(buffer: &IOSurfaceRef) -> i32;
        }
        unsafe { IOSurfaceGetUseCount(self) }
    }

    /// Returns true of an IOSurface is in use by any process in the system, otherwise false.
    #[doc(alias = "IOSurfaceIsInUse")]
    #[inline]
    pub fn is_in_use(&self) -> bool {
        extern "C-unwind" {
            fn IOSurfaceIsInUse(buffer: &IOSurfaceRef) -> Boolean;
        }
        let ret = unsafe { IOSurfaceIsInUse(self) };
        ret != 0
    }

    #[doc(alias = "IOSurfaceAllowsPixelSizeCasting")]
    #[inline]
    pub fn allows_pixel_size_casting(&self) -> bool {
        extern "C-unwind" {
            fn IOSurfaceAllowsPixelSizeCasting(buffer: &IOSurfaceRef) -> Boolean;
        }
        let ret = unsafe { IOSurfaceAllowsPixelSizeCasting(self) };
        ret != 0
    }

    /// # Safety
    ///
    /// `old_state` must be a valid pointer or null.
    #[doc(alias = "IOSurfaceSetPurgeable")]
    #[cfg(feature = "libc")]
    #[inline]
    pub unsafe fn set_purgeable(&self, new_state: u32, old_state: *mut u32) -> libc::kern_return_t {
        extern "C-unwind" {
            fn IOSurfaceSetPurgeable(
                buffer: &IOSurfaceRef,
                new_state: u32,
                old_state: *mut u32,
            ) -> libc::kern_return_t;
        }
        unsafe { IOSurfaceSetPurgeable(self, new_state, old_state) }
    }
}

// NS_ENUM
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord)]
pub struct IOSurfaceMemoryLedgerTags(pub c_int);
impl IOSurfaceMemoryLedgerTags {
    #[doc(alias = "kIOSurfaceMemoryLedgerTagDefault")]
    pub const Default: Self = Self(0x00000001);
    #[doc(alias = "kIOSurfaceMemoryLedgerTagNetwork")]
    pub const Network: Self = Self(0x00000002);
    #[doc(alias = "kIOSurfaceMemoryLedgerTagMedia")]
    pub const Media: Self = Self(0x00000003);
    #[doc(alias = "kIOSurfaceMemoryLedgerTagGraphics")]
    pub const Graphics: Self = Self(0x00000004);
    #[doc(alias = "kIOSurfaceMemoryLedgerTagNeural")]
    pub const Neural: Self = Self(0x00000005);
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOSurfaceMemoryLedgerTags {
    const ENCODING: Encoding = c_int::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOSurfaceMemoryLedgerTags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl Send for IOSurfaceMemoryLedgerTags {}

unsafe impl Sync for IOSurfaceMemoryLedgerTags {}

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOSurfaceMemoryLedgerFlags(pub u32);
bitflags::bitflags! {
    impl IOSurfaceMemoryLedgerFlags: u32 {
        #[doc(alias = "kIOSurfaceMemoryLedgerFlagNoFootprint")]
        const NoFootprint = 1<<0;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOSurfaceMemoryLedgerFlags {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOSurfaceMemoryLedgerFlags {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl Send for IOSurfaceMemoryLedgerFlags {}

unsafe impl Sync for IOSurfaceMemoryLedgerFlags {}

impl IOSurfaceRef {
    #[doc(alias = "IOSurfaceSetOwnershipIdentity")]
    #[cfg(feature = "libc")]
    #[inline]
    pub unsafe fn set_ownership_identity(
        &self,
        task_id_token: task_id_token_t,
        new_ledger_tag: c_int,
        new_ledger_options: u32,
    ) -> libc::kern_return_t {
        extern "C-unwind" {
            fn IOSurfaceSetOwnershipIdentity(
                buffer: &IOSurfaceRef,
                task_id_token: task_id_token_t,
                new_ledger_tag: c_int,
                new_ledger_options: u32,
            ) -> libc::kern_return_t;
        }
        unsafe {
            IOSurfaceSetOwnershipIdentity(self, task_id_token, new_ledger_tag, new_ledger_options)
        }
    }
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `IOSurfaceRef::new`"]
#[inline]
pub unsafe extern "C-unwind" fn IOSurfaceCreate(
    properties: &CFDictionary,
) -> Option<CFRetained<IOSurfaceRef>> {
    extern "C-unwind" {
        fn IOSurfaceCreate(properties: &CFDictionary) -> Option<NonNull<IOSurfaceRef>>;
    }
    let ret = unsafe { IOSurfaceCreate(properties) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(all(feature = "IOSurfaceTypes", feature = "objc2-core-foundation"))]
#[deprecated = "renamed to `IOSurfaceRef::lookup`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceLookup(csid: IOSurfaceID) -> Option<CFRetained<IOSurfaceRef>> {
    extern "C-unwind" {
        fn IOSurfaceLookup(csid: IOSurfaceID) -> Option<NonNull<IOSurfaceRef>>;
    }
    let ret = unsafe { IOSurfaceLookup(csid) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "IOSurfaceTypes")]
#[deprecated = "renamed to `IOSurfaceRef::id`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetID(buffer: &IOSurfaceRef) -> IOSurfaceID {
    extern "C-unwind" {
        fn IOSurfaceGetID(buffer: &IOSurfaceRef) -> IOSurfaceID;
    }
    unsafe { IOSurfaceGetID(buffer) }
}

extern "C-unwind" {
    #[cfg(all(feature = "IOSurfaceTypes", feature = "libc"))]
    #[deprecated = "renamed to `IOSurfaceRef::lock`"]
    pub fn IOSurfaceLock(
        buffer: &IOSurfaceRef,
        options: IOSurfaceLockOptions,
        seed: *mut u32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(all(feature = "IOSurfaceTypes", feature = "libc"))]
    #[deprecated = "renamed to `IOSurfaceRef::unlock`"]
    pub fn IOSurfaceUnlock(
        buffer: &IOSurfaceRef,
        options: IOSurfaceLockOptions,
        seed: *mut u32,
    ) -> libc::kern_return_t;
}

#[deprecated = "renamed to `IOSurfaceRef::alloc_size`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetAllocSize(buffer: &IOSurfaceRef) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetAllocSize(buffer: &IOSurfaceRef) -> usize;
    }
    unsafe { IOSurfaceGetAllocSize(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::width`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetWidth(buffer: &IOSurfaceRef) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetWidth(buffer: &IOSurfaceRef) -> usize;
    }
    unsafe { IOSurfaceGetWidth(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::height`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetHeight(buffer: &IOSurfaceRef) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetHeight(buffer: &IOSurfaceRef) -> usize;
    }
    unsafe { IOSurfaceGetHeight(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::bytes_per_element`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetBytesPerElement(buffer: &IOSurfaceRef) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetBytesPerElement(buffer: &IOSurfaceRef) -> usize;
    }
    unsafe { IOSurfaceGetBytesPerElement(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::bytes_per_row`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetBytesPerRow(buffer: &IOSurfaceRef) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetBytesPerRow(buffer: &IOSurfaceRef) -> usize;
    }
    unsafe { IOSurfaceGetBytesPerRow(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::base_address`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetBaseAddress(buffer: &IOSurfaceRef) -> NonNull<c_void> {
    extern "C-unwind" {
        fn IOSurfaceGetBaseAddress(buffer: &IOSurfaceRef) -> Option<NonNull<c_void>>;
    }
    let ret = unsafe { IOSurfaceGetBaseAddress(buffer) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `IOSurfaceRef::element_width`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetElementWidth(buffer: &IOSurfaceRef) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetElementWidth(buffer: &IOSurfaceRef) -> usize;
    }
    unsafe { IOSurfaceGetElementWidth(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::element_height`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetElementHeight(buffer: &IOSurfaceRef) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetElementHeight(buffer: &IOSurfaceRef) -> usize;
    }
    unsafe { IOSurfaceGetElementHeight(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::pixel_format`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetPixelFormat(buffer: &IOSurfaceRef) -> OSType {
    extern "C-unwind" {
        fn IOSurfaceGetPixelFormat(buffer: &IOSurfaceRef) -> OSType;
    }
    unsafe { IOSurfaceGetPixelFormat(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::seed`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetSeed(buffer: &IOSurfaceRef) -> u32 {
    extern "C-unwind" {
        fn IOSurfaceGetSeed(buffer: &IOSurfaceRef) -> u32;
    }
    unsafe { IOSurfaceGetSeed(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::plane_count`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetPlaneCount(buffer: &IOSurfaceRef) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetPlaneCount(buffer: &IOSurfaceRef) -> usize;
    }
    unsafe { IOSurfaceGetPlaneCount(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::width_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetWidthOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetWidthOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
    }
    unsafe { IOSurfaceGetWidthOfPlane(buffer, plane_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::height_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetHeightOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetHeightOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
    }
    unsafe { IOSurfaceGetHeightOfPlane(buffer, plane_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::bytes_per_element_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetBytesPerElementOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetBytesPerElementOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
    }
    unsafe { IOSurfaceGetBytesPerElementOfPlane(buffer, plane_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::bytes_per_row_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetBytesPerRowOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetBytesPerRowOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
    }
    unsafe { IOSurfaceGetBytesPerRowOfPlane(buffer, plane_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::base_address_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetBaseAddressOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
) -> NonNull<c_void> {
    extern "C-unwind" {
        fn IOSurfaceGetBaseAddressOfPlane(
            buffer: &IOSurfaceRef,
            plane_index: usize,
        ) -> Option<NonNull<c_void>>;
    }
    let ret = unsafe { IOSurfaceGetBaseAddressOfPlane(buffer, plane_index) };
    ret.expect("function was marked as returning non-null, but actually returned NULL")
}

#[deprecated = "renamed to `IOSurfaceRef::element_width_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetElementWidthOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetElementWidthOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
    }
    unsafe { IOSurfaceGetElementWidthOfPlane(buffer, plane_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::element_height_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetElementHeightOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetElementHeightOfPlane(buffer: &IOSurfaceRef, plane_index: usize) -> usize;
    }
    unsafe { IOSurfaceGetElementHeightOfPlane(buffer, plane_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::number_of_components_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetNumberOfComponentsOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetNumberOfComponentsOfPlane(
            buffer: &IOSurfaceRef,
            plane_index: usize,
        ) -> usize;
    }
    unsafe { IOSurfaceGetNumberOfComponentsOfPlane(buffer, plane_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::name_of_component_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetNameOfComponentOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
    component_index: usize,
) -> IOSurfaceComponentName {
    extern "C-unwind" {
        fn IOSurfaceGetNameOfComponentOfPlane(
            buffer: &IOSurfaceRef,
            plane_index: usize,
            component_index: usize,
        ) -> IOSurfaceComponentName;
    }
    unsafe { IOSurfaceGetNameOfComponentOfPlane(buffer, plane_index, component_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::type_of_component_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetTypeOfComponentOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
    component_index: usize,
) -> IOSurfaceComponentType {
    extern "C-unwind" {
        fn IOSurfaceGetTypeOfComponentOfPlane(
            buffer: &IOSurfaceRef,
            plane_index: usize,
            component_index: usize,
        ) -> IOSurfaceComponentType;
    }
    unsafe { IOSurfaceGetTypeOfComponentOfPlane(buffer, plane_index, component_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::range_of_component_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetRangeOfComponentOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
    component_index: usize,
) -> IOSurfaceComponentRange {
    extern "C-unwind" {
        fn IOSurfaceGetRangeOfComponentOfPlane(
            buffer: &IOSurfaceRef,
            plane_index: usize,
            component_index: usize,
        ) -> IOSurfaceComponentRange;
    }
    unsafe { IOSurfaceGetRangeOfComponentOfPlane(buffer, plane_index, component_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::bit_depth_of_component_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetBitDepthOfComponentOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
    component_index: usize,
) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetBitDepthOfComponentOfPlane(
            buffer: &IOSurfaceRef,
            plane_index: usize,
            component_index: usize,
        ) -> usize;
    }
    unsafe { IOSurfaceGetBitDepthOfComponentOfPlane(buffer, plane_index, component_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::bit_offset_of_component_of_plane`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetBitOffsetOfComponentOfPlane(
    buffer: &IOSurfaceRef,
    plane_index: usize,
    component_index: usize,
) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetBitOffsetOfComponentOfPlane(
            buffer: &IOSurfaceRef,
            plane_index: usize,
            component_index: usize,
        ) -> usize;
    }
    unsafe { IOSurfaceGetBitOffsetOfComponentOfPlane(buffer, plane_index, component_index) }
}

#[deprecated = "renamed to `IOSurfaceRef::subsampling`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetSubsampling(buffer: &IOSurfaceRef) -> IOSurfaceSubsampling {
    extern "C-unwind" {
        fn IOSurfaceGetSubsampling(buffer: &IOSurfaceRef) -> IOSurfaceSubsampling;
    }
    unsafe { IOSurfaceGetSubsampling(buffer) }
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "renamed to `IOSurfaceRef::set_value`"]
    pub fn IOSurfaceSetValue(buffer: &IOSurfaceRef, key: &CFString, value: &CFType);
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `IOSurfaceRef::value`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceCopyValue(
    buffer: &IOSurfaceRef,
    key: &CFString,
) -> Option<CFRetained<CFType>> {
    extern "C-unwind" {
        fn IOSurfaceCopyValue(buffer: &IOSurfaceRef, key: &CFString) -> Option<NonNull<CFType>>;
    }
    let ret = unsafe { IOSurfaceCopyValue(buffer, key) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `IOSurfaceRef::remove_value`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceRemoveValue(buffer: &IOSurfaceRef, key: &CFString) {
    extern "C-unwind" {
        fn IOSurfaceRemoveValue(buffer: &IOSurfaceRef, key: &CFString);
    }
    unsafe { IOSurfaceRemoveValue(buffer, key) }
}

extern "C-unwind" {
    #[cfg(feature = "objc2-core-foundation")]
    #[deprecated = "renamed to `IOSurfaceRef::set_values`"]
    pub fn IOSurfaceSetValues(buffer: &IOSurfaceRef, keys_and_values: &CFDictionary);
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `IOSurfaceRef::all_values`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceCopyAllValues(
    buffer: &IOSurfaceRef,
) -> Option<CFRetained<CFDictionary>> {
    extern "C-unwind" {
        fn IOSurfaceCopyAllValues(buffer: &IOSurfaceRef) -> Option<NonNull<CFDictionary>>;
    }
    let ret = unsafe { IOSurfaceCopyAllValues(buffer) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[deprecated = "renamed to `IOSurfaceRef::remove_all_values`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceRemoveAllValues(buffer: &IOSurfaceRef) {
    extern "C-unwind" {
        fn IOSurfaceRemoveAllValues(buffer: &IOSurfaceRef);
    }
    unsafe { IOSurfaceRemoveAllValues(buffer) }
}

#[cfg(feature = "libc")]
#[deprecated = "renamed to `IOSurfaceRef::create_mach_port`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceCreateMachPort(buffer: &IOSurfaceRef) -> libc::mach_port_t {
    extern "C-unwind" {
        fn IOSurfaceCreateMachPort(buffer: &IOSurfaceRef) -> libc::mach_port_t;
    }
    unsafe { IOSurfaceCreateMachPort(buffer) }
}

#[cfg(all(feature = "libc", feature = "objc2-core-foundation"))]
#[deprecated = "renamed to `IOSurfaceRef::lookup_from_mach_port`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceLookupFromMachPort(
    port: libc::mach_port_t,
) -> Option<CFRetained<IOSurfaceRef>> {
    extern "C-unwind" {
        fn IOSurfaceLookupFromMachPort(port: libc::mach_port_t) -> Option<NonNull<IOSurfaceRef>>;
    }
    let ret = unsafe { IOSurfaceLookupFromMachPort(port) };
    ret.map(|ret| unsafe { CFRetained::from_raw(ret) })
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `IOSurfaceRef::property_maximum`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetPropertyMaximum(property: &CFString) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetPropertyMaximum(property: &CFString) -> usize;
    }
    unsafe { IOSurfaceGetPropertyMaximum(property) }
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `IOSurfaceRef::property_alignment`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetPropertyAlignment(property: &CFString) -> usize {
    extern "C-unwind" {
        fn IOSurfaceGetPropertyAlignment(property: &CFString) -> usize;
    }
    unsafe { IOSurfaceGetPropertyAlignment(property) }
}

#[cfg(feature = "objc2-core-foundation")]
#[deprecated = "renamed to `IOSurfaceRef::align_property`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceAlignProperty(property: &CFString, value: usize) -> usize {
    extern "C-unwind" {
        fn IOSurfaceAlignProperty(property: &CFString, value: usize) -> usize;
    }
    unsafe { IOSurfaceAlignProperty(property, value) }
}

#[deprecated = "renamed to `IOSurfaceRef::increment_use_count`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceIncrementUseCount(buffer: &IOSurfaceRef) {
    extern "C-unwind" {
        fn IOSurfaceIncrementUseCount(buffer: &IOSurfaceRef);
    }
    unsafe { IOSurfaceIncrementUseCount(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::decrement_use_count`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceDecrementUseCount(buffer: &IOSurfaceRef) {
    extern "C-unwind" {
        fn IOSurfaceDecrementUseCount(buffer: &IOSurfaceRef);
    }
    unsafe { IOSurfaceDecrementUseCount(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::use_count`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceGetUseCount(buffer: &IOSurfaceRef) -> i32 {
    extern "C-unwind" {
        fn IOSurfaceGetUseCount(buffer: &IOSurfaceRef) -> i32;
    }
    unsafe { IOSurfaceGetUseCount(buffer) }
}

#[deprecated = "renamed to `IOSurfaceRef::is_in_use`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceIsInUse(buffer: &IOSurfaceRef) -> bool {
    extern "C-unwind" {
        fn IOSurfaceIsInUse(buffer: &IOSurfaceRef) -> Boolean;
    }
    let ret = unsafe { IOSurfaceIsInUse(buffer) };
    ret != 0
}

#[deprecated = "renamed to `IOSurfaceRef::allows_pixel_size_casting`"]
#[inline]
pub extern "C-unwind" fn IOSurfaceAllowsPixelSizeCasting(buffer: &IOSurfaceRef) -> bool {
    extern "C-unwind" {
        fn IOSurfaceAllowsPixelSizeCasting(buffer: &IOSurfaceRef) -> Boolean;
    }
    let ret = unsafe { IOSurfaceAllowsPixelSizeCasting(buffer) };
    ret != 0
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    #[deprecated = "renamed to `IOSurfaceRef::set_purgeable`"]
    pub fn IOSurfaceSetPurgeable(
        buffer: &IOSurfaceRef,
        new_state: u32,
        old_state: *mut u32,
    ) -> libc::kern_return_t;
}

extern "C-unwind" {
    #[cfg(feature = "libc")]
    #[deprecated = "renamed to `IOSurfaceRef::set_ownership_identity`"]
    pub fn IOSurfaceSetOwnershipIdentity(
        buffer: &IOSurfaceRef,
        task_id_token: task_id_token_t,
        new_ledger_tag: c_int,
        new_ledger_options: u32,
    ) -> libc::kern_return_t;
}
