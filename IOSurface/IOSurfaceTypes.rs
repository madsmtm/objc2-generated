//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ffi::*;
#[cfg(feature = "objc2")]
use objc2::__framework_prelude::*;

use crate::*;

/// An IOSurface identifier.
pub type IOSurfaceID = u32;

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOSurfaceLockOptions(pub u32);
bitflags::bitflags! {
    impl IOSurfaceLockOptions: u32 {
///
/// ## Discussion
///
/// If you are not going to modify the data while you hold the lock, you should set this flag to avoid invalidating any existing caches of the buffer contents. This flag should be passed both to the lock and unlock functions. Non-symmentrical usage of this flag will result in undefined behavior.
///
///
        #[doc(alias = "kIOSurfaceLockReadOnly")]
        const ReadOnly = 0x00000001;
///
/// ## Discussion
///
/// If you want to detect/avoid a potentially expensive paging operation (such as readback from a GPU to system memory) when you lock the buffer, you may include this flag. If locking the buffer requires a readback, the lock will fail with an error return of `kIOReturnCannotLock`.
///
///
        #[doc(alias = "kIOSurfaceLockAvoidSync")]
        const AvoidSync = 0x00000002;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOSurfaceLockOptions {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOSurfaceLockOptions {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl Send for IOSurfaceLockOptions {}

unsafe impl Sync for IOSurfaceLockOptions {}

// NS_OPTIONS
#[repr(transparent)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, Default)]
pub struct IOSurfacePurgeabilityState(pub u32);
bitflags::bitflags! {
    impl IOSurfacePurgeabilityState: u32 {
        #[doc(alias = "kIOSurfacePurgeableNonVolatile")]
        const PurgeableNonVolatile = 0;
        #[doc(alias = "kIOSurfacePurgeableVolatile")]
        const PurgeableVolatile = 1;
        #[doc(alias = "kIOSurfacePurgeableEmpty")]
        const PurgeableEmpty = 2;
        #[doc(alias = "kIOSurfacePurgeableKeepCurrent")]
        const PurgeableKeepCurrent = 3;
    }
}

#[cfg(feature = "objc2")]
unsafe impl Encode for IOSurfacePurgeabilityState {
    const ENCODING: Encoding = u32::ENCODING;
}

#[cfg(feature = "objc2")]
unsafe impl RefEncode for IOSurfacePurgeabilityState {
    const ENCODING_REF: Encoding = Encoding::Pointer(&Self::ENCODING);
}

unsafe impl Send for IOSurfacePurgeabilityState {}

unsafe impl Sync for IOSurfacePurgeabilityState {}

pub const kIOSurfaceDefaultCache: c_uint = 0;
pub const kIOSurfaceInhibitCache: c_uint = 1;
pub const kIOSurfaceWriteThruCache: c_uint = 2;
pub const kIOSurfaceCopybackCache: c_uint = 3;
pub const kIOSurfaceWriteCombineCache: c_uint = 4;
pub const kIOSurfaceCopybackInnerCache: c_uint = 5;

pub const kIOSurfaceMapCacheShift: c_uint = 8;
pub const kIOSurfaceMapDefaultCache: c_uint = kIOSurfaceDefaultCache << kIOSurfaceMapCacheShift;
pub const kIOSurfaceMapInhibitCache: c_uint = kIOSurfaceInhibitCache << kIOSurfaceMapCacheShift;
pub const kIOSurfaceMapWriteThruCache: c_uint = kIOSurfaceWriteThruCache << kIOSurfaceMapCacheShift;
pub const kIOSurfaceMapCopybackCache: c_uint = kIOSurfaceCopybackCache << kIOSurfaceMapCacheShift;
pub const kIOSurfaceMapWriteCombineCache: c_uint =
    kIOSurfaceWriteCombineCache << kIOSurfaceMapCacheShift;
pub const kIOSurfaceMapCopybackInnerCache: c_uint =
    kIOSurfaceCopybackInnerCache << kIOSurfaceMapCacheShift;
