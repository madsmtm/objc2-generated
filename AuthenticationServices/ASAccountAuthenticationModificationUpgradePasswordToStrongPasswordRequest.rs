//! This file has been automatically generated by `objc2`'s `header-translator`.
//! DO NOT EDIT
use core::ptr::NonNull;
use objc2::__framework_prelude::*;
use objc2_foundation::*;

use crate::*;

extern_class!(
    /// [Apple's documentation](https://developer.apple.com/documentation/authenticationservices/asaccountauthenticationmodificationupgradepasswordtostrongpasswordrequest?language=objc)
    #[unsafe(super(ASAccountAuthenticationModificationRequest, NSObject))]
    #[derive(Debug, PartialEq, Eq, Hash)]
    #[cfg(feature = "ASAccountAuthenticationModificationRequest")]
    pub struct ASAccountAuthenticationModificationUpgradePasswordToStrongPasswordRequest;
);

#[cfg(feature = "ASAccountAuthenticationModificationRequest")]
extern_conformance!(
    unsafe impl NSObjectProtocol
        for ASAccountAuthenticationModificationUpgradePasswordToStrongPasswordRequest
    {
    }
);

#[cfg(feature = "ASAccountAuthenticationModificationRequest")]
impl ASAccountAuthenticationModificationUpgradePasswordToStrongPasswordRequest {
    extern_methods!(
        #[cfg(feature = "ASCredentialServiceIdentifier")]
        /// Creates a request for a strong password upgrade invoked within the extension's containing app.
        ///
        /// Parameter `user`: The username for the account to upgrade.
        ///
        /// Parameter `serviceIdentifier`: The service identifier of the credential the user wishes to upgrade.
        ///
        /// Parameter `userInfo`: A dictionary the app can use to pass information to the extension, most likely to help with authorizing the upgrade.
        ///
        /// In this flow, when the extension is invoked from within the containing app, the extension
        /// will receive an empty password for the credential to upgrade. It should check that it is authorized to perform
        /// the upgrade. The authorization check should ideally be done with information in userInfo, but may involve
        /// communicating with a backend server or using a shared data container between the app and extension.
        ///
        /// # Safety
        ///
        /// `user_info` generic should be of the correct type.
        #[unsafe(method(initWithUser:serviceIdentifier:userInfo:))]
        #[unsafe(method_family = init)]
        pub unsafe fn initWithUser_serviceIdentifier_userInfo(
            this: Allocated<Self>,
            user: &NSString,
            service_identifier: &ASCredentialServiceIdentifier,
            user_info: Option<&NSDictionary>,
        ) -> Retained<Self>;

        #[unsafe(method(user))]
        #[unsafe(method_family = none)]
        pub unsafe fn user(&self) -> Retained<NSString>;

        #[cfg(feature = "ASCredentialServiceIdentifier")]
        #[unsafe(method(serviceIdentifier))]
        #[unsafe(method_family = none)]
        pub unsafe fn serviceIdentifier(&self) -> Retained<ASCredentialServiceIdentifier>;

        #[unsafe(method(userInfo))]
        #[unsafe(method_family = none)]
        pub unsafe fn userInfo(&self) -> Option<Retained<NSDictionary>>;
    );
}

/// Methods declared on superclass `NSObject`.
#[cfg(feature = "ASAccountAuthenticationModificationRequest")]
impl ASAccountAuthenticationModificationUpgradePasswordToStrongPasswordRequest {
    extern_methods!(
        #[unsafe(method(init))]
        #[unsafe(method_family = init)]
        pub unsafe fn init(this: Allocated<Self>) -> Retained<Self>;

        #[unsafe(method(new))]
        #[unsafe(method_family = new)]
        pub unsafe fn new() -> Retained<Self>;
    );
}
